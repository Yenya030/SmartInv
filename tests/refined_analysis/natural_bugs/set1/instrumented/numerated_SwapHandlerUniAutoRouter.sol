1 // SPDX-License-Identifier: GPL-2.0-or-later
2 
3 pragma solidity ^0.8.0;
4 
5 import "./SwapHandlerCombinedBase.sol";
6 
7 /// @notice Swap handler executing trades on Uniswap with a payload generated by auto-router
8 contract SwapHandlerUniAutoRouter is SwapHandlerCombinedBase {
9     address immutable public uniSwapRouter02;
10 
11     constructor(address uniSwapRouter02_, address uniSwapRouterV2, address uniSwapRouterV3) SwapHandlerCombinedBase(uniSwapRouterV2, uniSwapRouterV3) {
12         uniSwapRouter02 = uniSwapRouter02_;
13     }
14 
15     function swapPrimary(SwapParams memory params) override internal returns (uint amountOut) {
16         setMaxAllowance(params.underlyingIn, params.amountIn, uniSwapRouter02);
17 
18         if (params.mode == 0) {
19             // for exact input return value is ignored
20             swapInternal(params);
21         } else {
22             // exact output on SwapRouter02 routed through uniV2 is not exact, balance check is needed
23             uint preBalance = IERC20(params.underlyingOut).balanceOf(msg.sender);
24 
25             swapInternal(params);
26 
27             uint postBalance = IERC20(params.underlyingOut).balanceOf(msg.sender);
28 
29             require(postBalance >= preBalance, "SwapHandlerUniAutoRouter: negative amount out");
30 
31             unchecked { amountOut = postBalance - preBalance; }
32         }
33     }
34 
35     function swapInternal(SwapParams memory params) private {
36         (bool success, bytes memory result) = uniSwapRouter02.call(params.payload);
37         if (!success) revertBytes(result);
38     }
39 }
