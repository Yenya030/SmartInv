1 // SPDX-License-Identifier: GPL-3.0
2 pragma solidity 0.8.9;
3 
4 import { ECDSA } from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
5 import { IERC20Token } from "./interfaces/IERC20Token.sol";
6 import { IHermesContract } from "./interfaces/IHermesContract.sol";
7 import { IUniswapV2Router } from "./interfaces/IUniswapV2Router.sol";
8 import { FundsRecovery } from "./FundsRecovery.sol";
9 import { Utils } from "./Utils.sol";
10 
11 
12 contract ChannelImplementation is FundsRecovery, Utils {
13     using ECDSA for bytes32;
14 
15     string constant EXIT_PREFIX = "Exit request:";
16 
17     uint256 internal lastNonce;
18 
19     struct Hermes {
20         address operator;          // signing address
21         address contractAddress;   // hermes smart contract address, funds will be send there
22         uint256 settled;           // total amount already settled by hermes
23     }
24 
25     Hermes public hermes;
26     address public operator;          // channel operator = sha3(IdentityPublicKey)[:20]
27     IUniswapV2Router internal dex;    // any uniswap v2 compatible dex router address
28 
29     event PromiseSettled(address beneficiary, uint256 amount, uint256 totalSettled, bytes32 lock);
30     event Withdraw(address beneficiary, uint256 amount);
31 
32     /*
33       ------------------------------------------- SETUP -------------------------------------------
34     */
35 
36     // Fallback function - exchange received ETH into MYST
37     receive() external payable {
38         address[] memory path = new address[](2);
39         path[0] = dex.WETH();
40         path[1] = address(token);
41 
42         dex.swapExactETHForTokens{value: msg.value}(0, path, address(this), block.timestamp);
43     }
44 
45     // Because of proxy pattern this function is used insted of constructor.
46     // Have to be called right after proxy deployment.
47     function initialize(address _token, address _dexAddress, address _identity, address _hermesId, uint256 _fee) public {
48         require(!isInitialized(), "Is already initialized");
49         require(_identity != address(0), "Identity can't be zero");
50         require(_hermesId != address(0), "HermesID can't be zero");
51         require(_token != address(0), "Token can't be deployd into zero address");
52 
53         token = IERC20Token(_token);
54         dex = IUniswapV2Router(_dexAddress);
55 
56         // Transfer required fee to msg.sender (most probably Registry)
57         if (_fee > 0) {
58             token.transfer(msg.sender, _fee);
59         }
60 
61         operator = _identity;
62         transferOwnership(operator);
63         hermes = Hermes(IHermesContract(_hermesId).getOperator(), _hermesId, 0);
64     }
65 
66     function isInitialized() public view returns (bool) {
67         return operator != address(0);
68     }
69 
70     /*
71       -------------------------------------- MAIN FUNCTIONALITY -----------------------------------
72     */
73 
74     // Settle promise
75     // signedMessage: channelId, totalSettleAmount, fee, hashlock
76     // _lock is random number generated by receiver used in HTLC
77     function settlePromise(uint256 _amount, uint256 _transactorFee, bytes32 _lock, bytes memory _signature) public {
78         bytes32 _hashlock = keccak256(abi.encode(_lock));
79         address _channelId = address(this);
80 
81         address _signer = keccak256(abi.encodePacked(getChainID(), uint256(uint160(_channelId)), _amount, _transactorFee, _hashlock)).recover(_signature);
82         require(_signer == operator, "have to be signed by channel operator");
83 
84         // Calculate amount of tokens to be claimed.
85         uint256 _unpaidAmount = _amount - hermes.settled;
86         require(_unpaidAmount > 0, "amount to settle should be greater that already settled");
87 
88         // If signer has less tokens than asked to transfer, we can transfer as much as he has already
89         // and rest tokens can be transferred via same promise but in another tx
90         // when signer will top up channel balance.
91         uint256 _currentBalance = token.balanceOf(_channelId);
92         if (_unpaidAmount > _currentBalance) {
93             _unpaidAmount = _currentBalance;
94         }
95 
96         // Increase already paid amount
97         hermes.settled = hermes.settled + _unpaidAmount;
98 
99         // Send tokens
100         token.transfer(hermes.contractAddress, _unpaidAmount - _transactorFee);
101 
102         // Pay fee to transaction maker
103         if (_transactorFee > 0) {
104             token.transfer(msg.sender, _transactorFee);
105         }
106 
107         emit PromiseSettled(hermes.contractAddress, _unpaidAmount, hermes.settled, _lock);
108     }
109 
110     // Fast funds withdrawal is possible when hermes agrees that given amount of funds can be withdrawn
111     function fastExit(uint256 _amount, uint256 _transactorFee, address _beneficiary, uint256 _validUntil, bytes memory _operatorSignature, bytes memory _hermesSignature) public {
112         require(_validUntil >= block.timestamp, "Channel: _validUntil have to be greater than or equal to current block timestamp");
113 
114         address _channelId = address(this);
115         bytes32 _msgHash = keccak256(abi.encodePacked(EXIT_PREFIX, getChainID(), uint256(uint160(_channelId)), _amount, _transactorFee, uint256(uint160(_beneficiary)), _validUntil, lastNonce++));
116 
117         address _firstSigner = _msgHash.recover(_operatorSignature);
118         require(_firstSigner == operator, "Channel: have to be signed by operator");
119 
120         address _secondSigner = _msgHash.recover(_hermesSignature);
121         require(_secondSigner == hermes.operator, "Channel: have to be signed by hermes");
122 
123         // Pay fee to transaction maker
124         if (_transactorFee > 0) {
125             require(_amount >= _transactorFee, "Channel: transactor fee can't be bigger that withdrawal amount");
126             token.transfer(msg.sender, _transactorFee);
127         }
128 
129         // Withdraw agreed amount
130         uint256 _amountToSend = _amount - _transactorFee;
131         token.transfer(_beneficiary, _amountToSend);
132         emit Withdraw(_beneficiary, _amountToSend);
133     }
134     /*
135       ------------------------------------------ HELPERS ------------------------------------------
136     */
137 
138     // Setting new destination of funds recovery.
139     string constant FUNDS_DESTINATION_PREFIX = "Set funds destination:";
140     function setFundsDestinationByCheque(address payable _newDestination, bytes memory _signature) public {
141         require(_newDestination != address(0));
142 
143         address _channelId = address(this);
144         address _signer = keccak256(abi.encodePacked(FUNDS_DESTINATION_PREFIX, _channelId, _newDestination, lastNonce++)).recover(_signature);
145         require(_signer == operator, "Channel: have to be signed by proper identity");
146 
147         emit DestinationChanged(fundsDestination, _newDestination);
148 
149         fundsDestination = _newDestination;
150     }
151 
152 }
