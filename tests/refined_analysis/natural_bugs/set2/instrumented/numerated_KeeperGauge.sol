1 // SPDX-License-Identifier: GPL-3.0-or-later
2 pragma solidity 0.8.9;
3 
4 import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
5 
6 import "../../interfaces/IController.sol";
7 import "../../interfaces/tokenomics/IKeeperGauge.sol";
8 
9 import "../../libraries/ScaledMath.sol";
10 import "../../libraries/Errors.sol";
11 import "../../libraries/AddressProviderHelpers.sol";
12 
13 import "../access/Authorization.sol";
14 
15 contract KeeperGauge is IKeeperGauge, Authorization {
16     using AddressProviderHelpers for IAddressProvider;
17     using ScaledMath for uint256;
18 
19     struct KeeperRecord {
20         mapping(uint256 => uint256) feesInPeriod;
21         uint256 nextEpochToClaim;
22         bool firstEpochSet;
23     }
24 
25     mapping(address => KeeperRecord) public keeperRecords;
26     mapping(uint256 => uint256) public perPeriodTotalFees;
27 
28     IController public immutable controller;
29     address public immutable pool;
30     uint256 public epoch;
31 
32     uint48 public lastUpdated;
33     mapping(uint256 => uint256) public perPeriodTotalInflation;
34 
35     bool public override killed;
36 
37     modifier onlyInflationManager() {
38         require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);
39         _;
40     }
41 
42     constructor(IController _controller, address _pool)
43         Authorization(_controller.addressProvider().getRoleManager())
44     {
45         controller = _controller;
46         pool = _pool;
47         lastUpdated = uint48(block.timestamp);
48     }
49 
50     /**
51      * @notice Shut down the gauge.
52      * @dev Accrued inflation can still be claimed from the gauge after shutdown.
53      * @return `true` if successful.
54      */
55     function kill() external override onlyInflationManager returns (bool) {
56         poolCheckpoint();
57         epoch++;
58         killed = true;
59         return true;
60     }
61 
62     /**
63      * @notice Report fees generated by a keeper (this is the basis for inflation accrual).
64      * @dev lpTokenAddress is included for forward compatibility with a single gauge solution.
65      * @param beneficiary Address of the keeper who earned the fees.
66      * @param amount Amount of fees (in lp tokens) earned.
67      * @param lpTokenAddress Address of the lpToken in which the fees are paid.
68      * @return `true` if successful.
69      */
70     function reportFees(
71         address beneficiary,
72         uint256 amount,
73         address lpTokenAddress
74     ) external override returns (bool) {
75         lpTokenAddress; // silencing compiler warning
76         require(
77             IController(controller).addressProvider().isWhiteListedFeeHandler(msg.sender),
78             Error.ADDRESS_NOT_WHITELISTED
79         );
80         require(!killed, Error.CONTRACT_PAUSED);
81         if (!keeperRecords[beneficiary].firstEpochSet) {
82             keeperRecords[beneficiary].firstEpochSet = true;
83             keeperRecords[beneficiary].nextEpochToClaim = epoch;
84         }
85         keeperRecords[beneficiary].feesInPeriod[epoch] += amount;
86         perPeriodTotalFees[epoch] += amount;
87         return true;
88     }
89 
90     /**
91      * @notice Advance the inflation accrual epoch.
92      * @return `true` if successful.
93      */
94     function advanceEpoch() external virtual override onlyInflationManager returns (bool) {
95         poolCheckpoint();
96         epoch++;
97         return true;
98     }
99 
100     function claimRewards(address beneficiary) external override returns (uint256) {
101         return claimRewards(beneficiary, epoch);
102     }
103 
104     function claimableRewards(address beneficiary) external view override returns (uint256) {
105         return _calcTotalClaimable(beneficiary, keeperRecords[beneficiary].nextEpochToClaim, epoch);
106     }
107 
108     function poolCheckpoint() public override returns (bool) {
109         if (killed) return false;
110         uint256 timeElapsed = block.timestamp - uint256(lastUpdated);
111         uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);
112         perPeriodTotalInflation[epoch] += currentRate * timeElapsed;
113         lastUpdated = uint48(block.timestamp);
114         return true;
115     }
116 
117     /**
118      * @notice Claim rewards with an epoch up to which they should be claimed specified.
119      * @param beneficiary Address to claim rewards for.
120      * @param endEpoch Epoch up to which to claim rewards.
121      * @return The amount of rewards claimed.
122      */
123     function claimRewards(address beneficiary, uint256 endEpoch) public returns (uint256) {
124         require(
125             msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
126             Error.UNAUTHORIZED_ACCESS
127         );
128         if (endEpoch > epoch) {
129             endEpoch = epoch;
130         }
131 
132         uint256 totalClaimable = _calcTotalClaimable(
133             beneficiary,
134             keeperRecords[beneficiary].nextEpochToClaim,
135             endEpoch
136         );
137         keeperRecords[beneficiary].nextEpochToClaim = endEpoch;
138         require(totalClaimable > 0, Error.ZERO_TRANSFER_NOT_ALLOWED);
139         _mintRewards(beneficiary, totalClaimable);
140 
141         return totalClaimable;
142     }
143 
144     function _mintRewards(address beneficiary, uint256 amount) internal returns (bool) {
145         IController(controller).inflationManager().mintRewards(beneficiary, amount);
146         return true;
147     }
148 
149     function _calcTotalClaimable(
150         address beneficiary,
151         uint256 startEpoch,
152         uint256 endEpoch
153     ) internal view returns (uint256) {
154         uint256 totalClaimable = 0;
155         for (uint256 i = startEpoch; i < endEpoch; i++) {
156             totalClaimable += (
157                 keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])
158             ).scaledMul(perPeriodTotalInflation[i]);
159         }
160         return totalClaimable;
161     }
162 }
