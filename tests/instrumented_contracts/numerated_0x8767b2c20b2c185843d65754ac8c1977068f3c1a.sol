1 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡤⠶⠒⠛⠋⠉⠉⠉⠉⠉⠉⠉⠙⠛⠒⠦⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
2 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠉⠛⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
3 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⢛⣡⠴⠒⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠳⢤⣀⠀⠀⠀⠈⠳⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
4 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠛⠚⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⣤⡀⠀⠀⠈⠻⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
5 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
6 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠹⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
7 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡤⠶⠖⠒⠲⠦⣤⡀⠀⠀⠀⠀⠀⠘⣧⠀⠀⠀⠘⢧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
8 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⣏⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡞⠋⠀⠀⠀⢀⣠⣴⡾⠋⠙⣦⡀⠀⠀⠀⠀⠘⣧⠀⠀⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
9 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠚⠉⠁⢈⡿⠟⠶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⠀⠀⢀⣾⣿⣿⣿⣿⣾⣴⣾⡇⠀⠀⠀⠀⠀⠸⡆⠀⠀⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
10 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣥⣤⣶⣿⠁⠀⠀⠙⣦⡶⠛⠉⠉⠉⠉⠉⠙⠓⠶⣼⣧⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠈⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
11 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⡿⢶⣾⣿⣽⣿⣶⣶⣤⠀⠀⠀⠀⠀⠀⠀⠀⠙⠳⣤⡀⠀⢙⣿⣿⠿⠿⠿⢿⣿⣄⡀⢀⣀⠀⠀⠀⣇⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
12 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⡿⠿⠛⣁⣤⠬⢽⡟⠛⠛⣻⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠉⠀⠀⠀⠀⠀⠈⢳⡄⠉⠻⢿⣀⠀⠀⣿⠀⠀⠀⠀⠀⠈⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
13 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⢻⡟⠁⠀⠀⠈⢧⡠⠾⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢐⣲⣶⡦⢤⣄⣀⡀⣿⠀⠀⠀⠙⣦⠀⣿⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
14 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠈⠳⢦⣀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡴⠖⠋⠉⠀⠘⣇⠀⠀⠉⠙⠋⠀⠀⠀⢀⡿⠀⣿⠀⠀⠀⠀⠀⠀⣿⡤⢶⠶⠶⠶⠒⠒⠒⠲⠶⠶⠦⢤⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
15 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡤⠶⠒⠛⠛⠉⠉⠉⠉⢻⡇⠀⠀⠀⣼⣿⠳⢦⡀⠈⠳⢦⣄⣀⣀⣀⣀⣤⠴⠚⠉⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⣀⣤⠴⣶⠞⠋⠀⠀⣧⠀⠀⠀⠀⠀⠠⡿⠁⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠳⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
16 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠃⠀⠀⣼⢣⣿⠀⠀⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⣁⣤⠶⠋⠁⠀⢸⠇⠀⠀⠀⢰⣿⡆⠀⠀⠀⠀⣸⠃⢀⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
17 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡆⠀⢠⡏⠸⣿⠀⠀⠀⠈⠙⠶⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡤⠾⠛⠉⠀⠀⠀⠀⢀⡟⠀⠀⠀⢀⣿⡏⣿⠀⠀⠀⣴⠇⣠⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
18 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⣼⣇⠀⣿⠀⠀⠀⠀⣼⢦⣄⠈⠉⠛⠒⠒⠒⠒⠚⠋⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⠁⠀⠀⢀⣾⣿⠁⣿⠀⢀⣼⡷⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀⠀⠀
19 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠃⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡰⣿⠀⢰⠿⡇⠀⠀⢸⣿⠀⠙⢿⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡴⢾⣻⡏⠀⠀⣠⡞⢁⡟⢰⡇⢠⡾⠁⠀⠀⠀⠀⠀⠀⢀⡤⠶⠒⠛⠋⣉⣠⡤⠤⠤⠤⠬⣽⣓⠶⣤⣀⡴⠟⠛⠉⠛⡆⠀⠀⠀⠀
20 //⠀⠀⠀⠀⠀⠀⢀⣀⣀⡾⠁⠀⠀⣠⡴⠚⠉⣁⣉⣙⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⠿⣇⣾⠀⠻⣄⠀⠸⣿⠀⠀⣠⣉⠛⠿⣿⣛⣓⠲⠒⠒⠒⠚⠛⢛⣛⣩⡵⠞⠋⡿⠀⣠⣾⢿⡇⣼⠃⣾⣴⠟⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⠀⠀⠀⠀⢻⠀⠀⠀⠀⠀⠀⠀⠉⢛⡾⠋⠀⠀⣲⢀⣼⡇⠀⠀⠀⠀
21 //⠀⠀⠀⠀⢰⣿⠉⠙⠳⣦⡴⠟⣡⡶⠚⠋⠉⠉⠉⠛⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡏⠀⠀⠙⣦⡀⣿⡄⢰⡇⠙⠳⢤⣀⣈⠉⠉⠙⠛⠛⠋⢉⣉⣡⠴⠞⠳⢾⣇⣴⠟⢡⡟⢰⡇⣼⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣧⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠿⣤⣀⡴⠛⠁⠈⡛⠳⢤⡀⠀⠀
22 //⠀⠀⠀⠀⠀⢸⡿⣄⡀⠀⠈⢻⡟⠁⠀⠀⠀⠀⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠈⠻⣾⣷⣼⡇⠀⠀⠀⠈⠉⠛⠛⠒⠒⠚⠛⠉⠉⠀⠀⠀⠀⠘⠛⠁⢠⡿⢖⣿⡼⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⡼⠋⠀⠀⠀⠀⢹⠀⠀⣷⠀⠀
23 //⠀⠀⠀⠀⣀⡼⠋⠉⠙⠳⣤⣤⡧⠀⠀⠀⠀⠀⠀⠀⠀⠘⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣦⠀⠉⠙⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⣾⠁⠀⠀⠀⠀⢀⣸⠀⠞⠙⢷⡀
24 //⠀⠀⣠⠞⠉⠀⠀⠀⠈⣤⠈⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠶⢻⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠀⠀⠀⠀⣸⠁⠀⠀⠀⠀⠀⠀⠀⠘⠳⢤⣄⠀⡴⠛⠹⡆⣦⡀⠀⢷
25 //⠀⣰⡿⠺⠆⠀⠀⠀⠀⣸⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⠀⠙⢶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⠶⠋⠁⠀⣸⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⢀⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⢠⡀⠀⢹⠉⠙⢦⣸
26 //⢠⠟⠀⠀⢀⡴⢶⡠⠞⠁⠀⣀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠈⠙⠓⠲⠦⠤⢤⣤⣤⣤⣤⠤⠤⠤⠶⠖⢻⠉⠁⠀⠀⠀⢠⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡇⠀⠀⠀⣼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⣈⣷⣄⢸⠀⠀⠀⠙
27 //⣟⣰⡾⢲⡏⠀⢀⡇⢠⡞⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠙⠛⠀⠀⠀⠀
28 //⠟⠁⠀⢸⠀⣴⡏⢀⡾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
29 //⠀⠀⠀⠸⡾⠃⠙⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠦⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡴⠚⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⢀⡼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
30 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠓⠒⠒⠲⠶⠒⠒⠚⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡾⠁⠀⣠⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
31 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠋⠀⢀⣴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
32 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⠋⠀⠀⣠⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
33 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⠞⠉⠀⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
34 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡴⠚⠉⠀⠀⢀⣠⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
35 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠃⠀⠙⠳⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⠶⠚⠋⠁⠀⠀⠀⠀⠀⠙⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
36 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⠀⠀⠀⣉⠙⠓⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⣠⡀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
37 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣧⠀⠀⠀⢀⡴⠛⠉⠛⠲⠦⣤⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⠴⠟⠋⠉⠻⣦⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
38 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⡾⠁⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠛⠒⠒⠒⠒⠒⠚⠛⠋⠉⠉⠀⠀⠀⠀⠀⠀⠀⠈⢷⡀⠀⠀⠀⣼⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
39 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⢰⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡇⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
40 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡼⠷⠦⠶⠷⣶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠤⠴⠷⠶⠾⠷⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
41 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣤⣿⣄⣀⣀⣠⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⣀⣀⣀⣀⣼⣥⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
42 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⢿⣿⣿⠿⠟⠓⠈⢿⣹⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⢻⠏⠾⢿⣿⣿⣿⣿⡿⠿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
43 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡅⠀⠀⢹⡆⠀⠀⣀⣼⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣾⣀⡀⠀⣾⠉⠙⠋⠀⢀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
44 //⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣖⣒⣺⣷⣾⠿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠿⠿⢿⣿⣛⣿⣿⠿⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
45 // https://t.me/showmedawae
46 // https://dawae.io/
47 // https://twitter.com/itsdawae
48 // https://opensea.io/collection/itsdawae/drop
49 // https://www.youtube.com/@itsdawae
50 // SPDX-License-Identifier: Unlicensed                                                                         
51  
52 pragma solidity 0.8.17;
53  
54 abstract contract Context {
55     function _msgSender() internal view virtual returns (address) {
56         return msg.sender;
57     }
58  
59     function _msgData() internal view virtual returns (bytes calldata) {
60         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
61         return msg.data;
62     }
63 }
64  
65 interface IUniswapV2Pair {
66     event Approval(address indexed owner, address indexed spender, uint value);
67     event Transfer(address indexed from, address indexed to, uint value);
68  
69     function name() external pure returns (string memory);
70     function symbol() external pure returns (string memory);
71     function decimals() external pure returns (uint8);
72     function totalSupply() external view returns (uint);
73     function balanceOf(address owner) external view returns (uint);
74     function allowance(address owner, address spender) external view returns (uint);
75  
76     function approve(address spender, uint value) external returns (bool);
77     function transfer(address to, uint value) external returns (bool);
78     function transferFrom(address from, address to, uint value) external returns (bool);
79  
80     function DOMAIN_SEPARATOR() external view returns (bytes32);
81     function PERMIT_TYPEHASH() external pure returns (bytes32);
82     function nonces(address owner) external view returns (uint);
83  
84     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
85  
86     event Mint(address indexed sender, uint amount0, uint amount1);
87     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
88     event Swap(
89         address indexed sender,
90         uint amount0In,
91         uint amount1In,
92         uint amount0Out,
93         uint amount1Out,
94         address indexed to
95     );
96     event Sync(uint112 reserve0, uint112 reserve1);
97  
98     function MINIMUM_LIQUIDITY() external pure returns (uint);
99     function factory() external view returns (address);
100     function token0() external view returns (address);
101     function token1() external view returns (address);
102     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
103     function price0CumulativeLast() external view returns (uint);
104     function price1CumulativeLast() external view returns (uint);
105     function kLast() external view returns (uint);
106  
107     function mint(address to) external returns (uint liquidity);
108     function burn(address to) external returns (uint amount0, uint amount1);
109     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
110     function skim(address to) external;
111     function sync() external;
112  
113     function initialize(address, address) external;
114 }
115  
116 interface IUniswapV2Factory {
117     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
118  
119     function feeTo() external view returns (address);
120     function feeToSetter() external view returns (address);
121  
122     function getPair(address tokenA, address tokenB) external view returns (address pair);
123     function allPairs(uint) external view returns (address pair);
124     function allPairsLength() external view returns (uint);
125  
126     function createPair(address tokenA, address tokenB) external returns (address pair);
127  
128     function setFeeTo(address) external;
129     function setFeeToSetter(address) external;
130 }
131  
132 interface IERC20 {
133     /**
134      * @dev Returns the amount of tokens in existence.
135      */
136     function totalSupply() external view returns (uint256);
137  
138     /**
139      * @dev Returns the amount of tokens owned by `account`.
140      */
141     function balanceOf(address account) external view returns (uint256);
142  
143     /**
144      * @dev Moves `amount` tokens from the caller's account to `recipient`.
145      *
146      * Returns a boolean value indicating whether the operation succeeded.
147      *
148      * Emits a {Transfer} event.
149      */
150     function transfer(address recipient, uint256 amount) external returns (bool);
151  
152     /**
153      * @dev Returns the remaining number of tokens that `spender` will be
154      * allowed to spend on behalf of `owner` through {transferFrom}. This is
155      * zero by default.
156      *
157      * This value changes when {approve} or {transferFrom} are called.
158      */
159     function allowance(address owner, address spender) external view returns (uint256);
160  
161     /**
162      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
163      *
164      * Returns a boolean value indicating whether the operation succeeded.
165      *
166      * IMPORTANT: Beware that changing an allowance with this method brings the risk
167      * that someone may use both the old and the new allowance by unfortunate
168      * transaction ordering. One possible solution to mitigate this race
169      * condition is to first reduce the spender's allowance to 0 and set the
170      * desired value afterwards:
171      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
172      *
173      * Emits an {Approval} event.
174      */
175     function approve(address spender, uint256 amount) external returns (bool);
176  
177     /**
178      * @dev Moves `amount` tokens from `sender` to `recipient` using the
179      * allowance mechanism. `amount` is then deducted from the caller's
180      * allowance.
181      *
182      * Returns a boolean value indicating whether the operation succeeded.
183      *
184      * Emits a {Transfer} event.
185      */
186     function transferFrom(
187         address sender,
188         address recipient,
189         uint256 amount
190     ) external returns (bool);
191  
192     /**
193      * @dev Emitted when `value` tokens are moved from one account (`from`) to
194      * another (`to`).
195      *
196      * Note that `value` may be zero.
197      */
198     event Transfer(address indexed from, address indexed to, uint256 value);
199  
200     /**
201      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
202      * a call to {approve}. `value` is the new allowance.
203      */
204     event Approval(address indexed owner, address indexed spender, uint256 value);
205 }
206  
207 interface IERC20Metadata is IERC20 {
208     /**
209      * @dev Returns the name of the token.
210      */
211     function name() external view returns (string memory);
212  
213     /**
214      * @dev Returns the symbol of the token.
215      */
216     function symbol() external view returns (string memory);
217  
218     /**
219      * @dev Returns the decimals places of the token.
220      */
221     function decimals() external view returns (uint8);
222 }
223  
224  
225 contract ERC20 is Context, IERC20, IERC20Metadata {
226     using SafeMath for uint256;
227  
228     mapping(address => uint256) private _balances;
229  
230     mapping(address => mapping(address => uint256)) private _allowances;
231  
232     uint256 private _totalSupply;
233  
234     string private _name;
235     string private _symbol;
236  
237     /**
238      * @dev Sets the values for {name} and {symbol}.
239      *
240      * The default value of {decimals} is 18. To select a different value for
241      * {decimals} you should overload it.
242      *
243      * All two of these values are immutable: they can only be set once during
244      * construction.
245      */
246     constructor(string memory name_, string memory symbol_) {
247         _name = name_;
248         _symbol = symbol_;
249     }
250  
251     /**
252      * @dev Returns the name of the token.
253      */
254     function name() public view virtual override returns (string memory) {
255         return _name;
256     }
257  
258     /**
259      * @dev Returns the symbol of the token, usually a shorter version of the
260      * name.
261      */
262     function symbol() public view virtual override returns (string memory) {
263         return _symbol;
264     }
265  
266     /**
267      * @dev Returns the number of decimals used to get its user representation.
268      * For example, if `decimals` equals `2`, a balance of `505` tokens should
269      * be displayed to a user as `5,05` (`505 / 10 ** 2`).
270      *
271      * Tokens usually opt for a value of 18, imitating the relationship between
272      * Ether and Wei. This is the value {ERC20} uses, unless this function is
273      * overridden;
274      *
275      * NOTE: This information is only used for _display_ purposes: it in
276      * no way affects any of the arithmetic of the contract, including
277      * {IERC20-balanceOf} and {IERC20-transfer}.
278      */
279     function decimals() public view virtual override returns (uint8) {
280         return 18;
281     }
282  
283     /**
284      * @dev See {IERC20-totalSupply}.
285      */
286     function totalSupply() public view virtual override returns (uint256) {
287         return _totalSupply;
288     }
289  
290     /**
291      * @dev See {IERC20-balanceOf}.
292      */
293     function balanceOf(address account) public view virtual override returns (uint256) {
294         return _balances[account];
295     }
296  
297     /**
298      * @dev See {IERC20-transfer}.
299      *
300      * Requirements:
301      *
302      * - `recipient` cannot be the zero address.
303      * - the caller must have a balance of at least `amount`.
304      */
305     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
306         _transfer(_msgSender(), recipient, amount);
307         return true;
308     }
309  
310     /**
311      * @dev See {IERC20-allowance}.
312      */
313     function allowance(address owner, address spender) public view virtual override returns (uint256) {
314         return _allowances[owner][spender];
315     }
316  
317     /**
318      * @dev See {IERC20-approve}.
319      *
320      * Requirements:
321      *
322      * - `spender` cannot be the zero address.
323      */
324     function approve(address spender, uint256 amount) public virtual override returns (bool) {
325         _approve(_msgSender(), spender, amount);
326         return true;
327     }
328  
329     /**
330      * @dev See {IERC20-transferFrom}.
331      *
332      * Emits an {Approval} event indicating the updated allowance. This is not
333      * required by the EIP. See the note at the beginning of {ERC20}.
334      *
335      * Requirements:
336      *
337      * - `sender` and `recipient` cannot be the zero address.
338      * - `sender` must have a balance of at least `amount`.
339      * - the caller must have allowance for ``sender``'s tokens of at least
340      * `amount`.
341      */
342     function transferFrom(
343         address sender,
344         address recipient,
345         uint256 amount
346     ) public virtual override returns (bool) {
347         _transfer(sender, recipient, amount);
348         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
349         return true;
350     }
351  
352     /**
353      * @dev Atomically increases the allowance granted to `spender` by the caller.
354      *
355      * This is an alternative to {approve} that can be used as a mitigation for
356      * problems described in {IERC20-approve}.
357      *
358      * Emits an {Approval} event indicating the updated allowance.
359      *
360      * Requirements:
361      *
362      * - `spender` cannot be the zero address.
363      */
364     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
365         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
366         return true;
367     }
368  
369     /**
370      * @dev Atomically decreases the allowance granted to `spender` by the caller.
371      *
372      * This is an alternative to {approve} that can be used as a mitigation for
373      * problems described in {IERC20-approve}.
374      *
375      * Emits an {Approval} event indicating the updated allowance.
376      *
377      * Requirements:
378      *
379      * - `spender` cannot be the zero address.
380      * - `spender` must have allowance for the caller of at least
381      * `subtractedValue`.
382      */
383     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
384         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
385         return true;
386     }
387  
388     /**
389      * @dev Moves tokens `amount` from `sender` to `recipient`.
390      *
391      * This is internal function is equivalent to {transfer}, and can be used to
392      * e.g. implement automatic token fees, slashing mechanisms, etc.
393      *
394      * Emits a {Transfer} event.
395      *
396      * Requirements:
397      *
398      * - `sender` cannot be the zero address.
399      * - `recipient` cannot be the zero address.
400      * - `sender` must have a balance of at least `amount`.
401      */
402     function _transfer(
403         address sender,
404         address recipient,
405         uint256 amount
406     ) internal virtual {
407         require(sender != address(0), "ERC20: transfer from the zero address");
408         require(recipient != address(0), "ERC20: transfer to the zero address");
409  
410         _beforeTokenTransfer(sender, recipient, amount);
411  
412         _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
413         _balances[recipient] = _balances[recipient].add(amount);
414         emit Transfer(sender, recipient, amount);
415     }
416  
417     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
418      * the total supply.
419      *
420      * Emits a {Transfer} event with `from` set to the zero address.
421      *
422      * Requirements:
423      *
424      * - `account` cannot be the zero address.
425      */
426     function _mint(address account, uint256 amount) internal virtual {
427         require(account != address(0), "ERC20: mint to the zero address");
428  
429         _beforeTokenTransfer(address(0), account, amount);
430  
431         _totalSupply = _totalSupply.add(amount);
432         _balances[account] = _balances[account].add(amount);
433         emit Transfer(address(0), account, amount);
434     }
435  
436     /**
437      * @dev Destroys `amount` tokens from `account`, reducing the
438      * total supply.
439      *
440      * Emits a {Transfer} event with `to` set to the zero address.
441      *
442      * Requirements:
443      *
444      * - `account` cannot be the zero address.
445      * - `account` must have at least `amount` tokens.
446      */
447     function _burn(address account, uint256 amount) internal virtual {
448         require(account != address(0), "ERC20: burn from the zero address");
449  
450         _beforeTokenTransfer(account, address(0), amount);
451  
452         _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
453         _totalSupply = _totalSupply.sub(amount);
454         emit Transfer(account, address(0), amount);
455     }
456  
457     /**
458      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
459      *
460      * This internal function is equivalent to `approve`, and can be used to
461      * e.g. set automatic allowances for certain subsystems, etc.
462      *
463      * Emits an {Approval} event.
464      *
465      * Requirements:
466      *
467      * - `owner` cannot be the zero address.
468      * - `spender` cannot be the zero address.
469      */
470     function _approve(
471         address owner,
472         address spender,
473         uint256 amount
474     ) internal virtual {
475         require(owner != address(0), "ERC20: approve from the zero address");
476         require(spender != address(0), "ERC20: approve to the zero address");
477  
478         _allowances[owner][spender] = amount;
479         emit Approval(owner, spender, amount);
480     }
481  
482     /**
483      * @dev Hook that is called before any transfer of tokens. This includes
484      * minting and burning.
485      *
486      * Calling conditions:
487      *
488      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
489      * will be to transferred to `to`.
490      * - when `from` is zero, `amount` tokens will be minted for `to`.
491      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
492      * - `from` and `to` are never both zero.
493      *
494      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
495      */
496     function _beforeTokenTransfer(
497         address from,
498         address to,
499         uint256 amount
500     ) internal virtual {}
501 }
502  
503 library SafeMath {
504     /**
505      * @dev Returns the addition of two unsigned integers, reverting on
506      * overflow.
507      *
508      * Counterpart to Solidity's `+` operator.
509      *
510      * Requirements:
511      *
512      * - Addition cannot overflow.
513      */
514     function add(uint256 a, uint256 b) internal pure returns (uint256) {
515         uint256 c = a + b;
516         require(c >= a, "SafeMath: addition overflow");
517  
518         return c;
519     }
520  
521     /**
522      * @dev Returns the subtraction of two unsigned integers, reverting on
523      * overflow (when the result is negative).
524      *
525      * Counterpart to Solidity's `-` operator.
526      *
527      * Requirements:
528      *
529      * - Subtraction cannot overflow.
530      */
531     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
532         return sub(a, b, "SafeMath: subtraction overflow");
533     }
534  
535     /**
536      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
537      * overflow (when the result is negative).
538      *
539      * Counterpart to Solidity's `-` operator.
540      *
541      * Requirements:
542      *
543      * - Subtraction cannot overflow.
544      */
545     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
546         require(b <= a, errorMessage);
547         uint256 c = a - b;
548  
549         return c;
550     }
551  
552     /**
553      * @dev Returns the multiplication of two unsigned integers, reverting on
554      * overflow.
555      *
556      * Counterpart to Solidity's `*` operator.
557      *
558      * Requirements:
559      *
560      * - Multiplication cannot overflow.
561      */
562     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
563         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
564         // benefit is lost if 'b' is also tested.
565         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
566         if (a == 0) {
567             return 0;
568         }
569  
570         uint256 c = a * b;
571         require(c / a == b, "SafeMath: multiplication overflow");
572  
573         return c;
574     }
575  
576     /**
577      * @dev Returns the integer division of two unsigned integers. Reverts on
578      * division by zero. The result is rounded towards zero.
579      *
580      * Counterpart to Solidity's `/` operator. Note: this function uses a
581      * `revert` opcode (which leaves remaining gas untouched) while Solidity
582      * uses an invalid opcode to revert (consuming all remaining gas).
583      *
584      * Requirements:
585      *
586      * - The divisor cannot be zero.
587      */
588     function div(uint256 a, uint256 b) internal pure returns (uint256) {
589         return div(a, b, "SafeMath: division by zero");
590     }
591  
592     /**
593      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
594      * division by zero. The result is rounded towards zero.
595      *
596      * Counterpart to Solidity's `/` operator. Note: this function uses a
597      * `revert` opcode (which leaves remaining gas untouched) while Solidity
598      * uses an invalid opcode to revert (consuming all remaining gas).
599      *
600      * Requirements:
601      *
602      * - The divisor cannot be zero.
603      */
604     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
605         require(b > 0, errorMessage);
606         uint256 c = a / b;
607         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
608  
609         return c;
610     }
611  
612     /**
613      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
614      * Reverts when dividing by zero.
615      *
616      * Counterpart to Solidity's `%` operator. This function uses a `revert`
617      * opcode (which leaves remaining gas untouched) while Solidity uses an
618      * invalid opcode to revert (consuming all remaining gas).
619      *
620      * Requirements:
621      *
622      * - The divisor cannot be zero.
623      */
624     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
625         return mod(a, b, "SafeMath: modulo by zero");
626     }
627  
628     /**
629      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
630      * Reverts with custom message when dividing by zero.
631      *
632      * Counterpart to Solidity's `%` operator. This function uses a `revert`
633      * opcode (which leaves remaining gas untouched) while Solidity uses an
634      * invalid opcode to revert (consuming all remaining gas).
635      *
636      * Requirements:
637      *
638      * - The divisor cannot be zero.
639      */
640     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
641         require(b != 0, errorMessage);
642         return a % b;
643     }
644 }
645  
646 contract Ownable is Context {
647     address private _owner;
648  
649     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
650  
651     /**
652      * @dev Initializes the contract setting the deployer as the initial owner.
653      */
654     constructor () {
655         address msgSender = _msgSender();
656         _owner = msgSender;
657         emit OwnershipTransferred(address(0), msgSender);
658     }
659  
660     /**
661      * @dev Returns the address of the current owner.
662      */
663     function owner() public view returns (address) {
664         return _owner;
665     }
666  
667     /**
668      * @dev Throws if called by any account other than the owner.
669      */
670     modifier onlyOwner() {
671         require(_owner == _msgSender(), "Ownable: caller is not the owner");
672         _;
673     }
674  
675     /**
676      * @dev Leaves the contract without owner. It will not be possible to call
677      * `onlyOwner` functions anymore. Can only be called by the current owner.
678      *
679      * NOTE: Renouncing ownership will leave the contract without an owner,
680      * thereby removing any functionality that is only available to the owner.
681      */
682     function renounceOwnership() public virtual onlyOwner {
683         emit OwnershipTransferred(_owner, address(0));
684         _owner = address(0);
685     }
686  
687     /**
688      * @dev Transfers ownership of the contract to a new account (`newOwner`).
689      * Can only be called by the current owner.
690      */
691     function transferOwnership(address newOwner) public virtual onlyOwner {
692         require(newOwner != address(0), "Ownable: new owner is the zero address");
693         emit OwnershipTransferred(_owner, newOwner);
694         _owner = newOwner;
695     }
696 }
697  
698  
699  
700 library SafeMathInt {
701     int256 private constant MIN_INT256 = int256(1) << 255;
702     int256 private constant MAX_INT256 = ~(int256(1) << 255);
703  
704     /**
705      * @dev Multiplies two int256 variables and fails on overflow.
706      */
707     function mul(int256 a, int256 b) internal pure returns (int256) {
708         int256 c = a * b;
709  
710         // Detect overflow when multiplying MIN_INT256 with -1
711         require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
712         require((b == 0) || (c / b == a));
713         return c;
714     }
715  
716     /**
717      * @dev Division of two int256 variables and fails on overflow.
718      */
719     function div(int256 a, int256 b) internal pure returns (int256) {
720         // Prevent overflow when dividing MIN_INT256 by -1
721         require(b != -1 || a != MIN_INT256);
722  
723         // Solidity already throws when dividing by 0.
724         return a / b;
725     }
726  
727     /**
728      * @dev Subtracts two int256 variables and fails on overflow.
729      */
730     function sub(int256 a, int256 b) internal pure returns (int256) {
731         int256 c = a - b;
732         require((b >= 0 && c <= a) || (b < 0 && c > a));
733         return c;
734     }
735  
736     /**
737      * @dev Adds two int256 variables and fails on overflow.
738      */
739     function add(int256 a, int256 b) internal pure returns (int256) {
740         int256 c = a + b;
741         require((b >= 0 && c >= a) || (b < 0 && c < a));
742         return c;
743     }
744  
745     /**
746      * @dev Converts to absolute value, and fails on overflow.
747      */
748     function abs(int256 a) internal pure returns (int256) {
749         require(a != MIN_INT256);
750         return a < 0 ? -a : a;
751     }
752  
753  
754     function toUint256Safe(int256 a) internal pure returns (uint256) {
755         require(a >= 0);
756         return uint256(a);
757     }
758 }
759  
760 library SafeMathUint {
761   function toInt256Safe(uint256 a) internal pure returns (int256) {
762     int256 b = int256(a);
763     require(b >= 0);
764     return b;
765   }
766 }
767  
768  
769 interface IUniswapV2Router01 {
770     function factory() external pure returns (address);
771     function WETH() external pure returns (address);
772  
773     function addLiquidity(
774         address tokenA,
775         address tokenB,
776         uint amountADesired,
777         uint amountBDesired,
778         uint amountAMin,
779         uint amountBMin,
780         address to,
781         uint deadline
782     ) external returns (uint amountA, uint amountB, uint liquidity);
783     function addLiquidityETH(
784         address token,
785         uint amountTokenDesired,
786         uint amountTokenMin,
787         uint amountETHMin,
788         address to,
789         uint deadline
790     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
791     function removeLiquidity(
792         address tokenA,
793         address tokenB,
794         uint liquidity,
795         uint amountAMin,
796         uint amountBMin,
797         address to,
798         uint deadline
799     ) external returns (uint amountA, uint amountB);
800     function removeLiquidityETH(
801         address token,
802         uint liquidity,
803         uint amountTokenMin,
804         uint amountETHMin,
805         address to,
806         uint deadline
807     ) external returns (uint amountToken, uint amountETH);
808     function removeLiquidityWithPermit(
809         address tokenA,
810         address tokenB,
811         uint liquidity,
812         uint amountAMin,
813         uint amountBMin,
814         address to,
815         uint deadline,
816         bool approveMax, uint8 v, bytes32 r, bytes32 s
817     ) external returns (uint amountA, uint amountB);
818     function removeLiquidityETHWithPermit(
819         address token,
820         uint liquidity,
821         uint amountTokenMin,
822         uint amountETHMin,
823         address to,
824         uint deadline,
825         bool approveMax, uint8 v, bytes32 r, bytes32 s
826     ) external returns (uint amountToken, uint amountETH);
827     function swapExactTokensForTokens(
828         uint amountIn,
829         uint amountOutMin,
830         address[] calldata path,
831         address to,
832         uint deadline
833     ) external returns (uint[] memory amounts);
834     function swapTokensForExactTokens(
835         uint amountOut,
836         uint amountInMax,
837         address[] calldata path,
838         address to,
839         uint deadline
840     ) external returns (uint[] memory amounts);
841     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
842         external
843         payable
844         returns (uint[] memory amounts);
845     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
846         external
847         returns (uint[] memory amounts);
848     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
849         external
850         returns (uint[] memory amounts);
851     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
852         external
853         payable
854         returns (uint[] memory amounts);
855  
856     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
857     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
858     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
859     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
860     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
861 }
862  
863 interface IUniswapV2Router02 is IUniswapV2Router01 {
864     function removeLiquidityETHSupportingFeeOnTransferTokens(
865         address token,
866         uint liquidity,
867         uint amountTokenMin,
868         uint amountETHMin,
869         address to,
870         uint deadline
871     ) external returns (uint amountETH);
872     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
873         address token,
874         uint liquidity,
875         uint amountTokenMin,
876         uint amountETHMin,
877         address to,
878         uint deadline,
879         bool approveMax, uint8 v, bytes32 r, bytes32 s
880     ) external returns (uint amountETH);
881  
882     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
883         uint amountIn,
884         uint amountOutMin,
885         address[] calldata path,
886         address to,
887         uint deadline
888     ) external;
889     function swapExactETHForTokensSupportingFeeOnTransferTokens(
890         uint amountOutMin,
891         address[] calldata path,
892         address to,
893         uint deadline
894     ) external payable;
895     function swapExactTokensForETHSupportingFeeOnTransferTokens(
896         uint amountIn,
897         uint amountOutMin,
898         address[] calldata path,
899         address to,
900         uint deadline
901     ) external;
902 }
903  
904 contract DAWAE is ERC20, Ownable {
905     using SafeMath for uint256;
906  
907     IUniswapV2Router02 public immutable uniswapV2Router;
908     address public immutable uniswapV2Pair;
909     address public constant deadAddress = address(0x000000000000000000000000000000000000dEaD);
910  
911     bool private swapping;
912  
913     address public marketingWallet;
914     address public devWallet;
915  
916     uint256 public maxTransactionAmount;
917     uint256 public swapTokensAtAmount;
918     uint256 public maxWallet;
919  
920     uint256 public percentForLPBurn = 25; // 25 = .25%
921     bool public lpBurnEnabled = true;
922     uint256 public lpBurnFrequency = 7200 seconds;
923     uint256 public lastLpBurnTime;
924  
925     uint256 public manualBurnFrequency = 30 minutes;
926     uint256 public lastManualLpBurnTime;
927  
928     bool public limitsInEffect = true;
929     bool public tradingActive = false;
930     bool public swapEnabled = false;
931     bool public enableEarlySellTax = true;
932  
933      // Anti-bot and anti-whale mappings and variables
934     mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch
935  
936     // Seller Map
937     mapping (address => uint256) private _holderFirstBuyTimestamp;
938  
939     // Blacklist Map
940     mapping (address => bool) private _blacklist;
941     bool public transferDelayEnabled = true;
942  
943     uint256 public buyTotalFees;
944     uint256 public buyMarketingFee;
945     uint256 public buyLiquidityFee;
946     uint256 public buyDevFee;
947  
948     uint256 public sellTotalFees;
949     uint256 public sellMarketingFee;
950     uint256 public sellLiquidityFee;
951     uint256 public sellDevFee;
952  
953     uint256 public earlySellLiquidityFee;
954     uint256 public earlySellMarketingFee;
955  
956     uint256 public tokensForMarketing;
957     uint256 public tokensForLiquidity;
958     uint256 public tokensForDev;
959  
960     // block number of opened trading
961     uint256 launchedAt;
962  
963     /******************/
964  
965     // exclude from fees and max transaction amount
966     mapping (address => bool) private _isExcludedFromFees;
967     mapping (address => bool) public _isExcludedMaxTransactionAmount;
968  
969     // store addresses that a automatic market maker pairs. Any transfer *to* these addresses
970     // could be subject to a maximum transfer amount
971     mapping (address => bool) public automatedMarketMakerPairs;
972  
973     event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);
974  
975     event ExcludeFromFees(address indexed account, bool isExcluded);
976  
977     event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
978  
979     event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);
980  
981     event devWalletUpdated(address indexed newWallet, address indexed oldWallet);
982  
983     event SwapAndLiquify(
984         uint256 tokensSwapped,
985         uint256 ethReceived,
986         uint256 tokensIntoLiquidity
987     );
988  
989     event AutoNukeLP();
990  
991     event ManualNukeLP();
992  
993 constructor() ERC20("DAWAE", "DAWAE") {
994  
995         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
996  
997         excludeFromMaxTransaction(address(_uniswapV2Router), true);
998         uniswapV2Router = _uniswapV2Router;
999  
1000         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
1001         excludeFromMaxTransaction(address(uniswapV2Pair), true);
1002         _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);
1003  
1004         uint256 _buyMarketingFee = 14;
1005         uint256 _buyLiquidityFee = 1;
1006         uint256 _buyDevFee = 15;
1007  
1008         uint256 _sellMarketingFee = 20;
1009         uint256 _sellLiquidityFee = 1;
1010         uint256 _sellDevFee = 19;
1011  
1012         uint256 _earlySellLiquidityFee = 0;
1013         uint256 _earlySellMarketingFee = 0;
1014  
1015         uint256 totalSupply = 1 * 1e9 * 1e18;
1016  
1017         maxTransactionAmount = totalSupply * 10 / 1000; // 1% maxtransaction
1018         maxWallet = totalSupply * 10 / 1000; // 1% maxwallet
1019         swapTokensAtAmount = totalSupply * 5 / 10000; // 0.05% swapwallet
1020  
1021         buyMarketingFee = _buyMarketingFee;
1022         buyLiquidityFee = _buyLiquidityFee;
1023         buyDevFee = _buyDevFee;
1024         buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;
1025  
1026         sellMarketingFee = _sellMarketingFee;
1027         sellLiquidityFee = _sellLiquidityFee;
1028         sellDevFee = _sellDevFee;
1029         sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;
1030  
1031         earlySellLiquidityFee = _earlySellLiquidityFee;
1032         earlySellMarketingFee = _earlySellMarketingFee;
1033  
1034         marketingWallet = address(0xc7f9de8ca25b2b23B30cE7D7120E7a04E1A55985); // set as marketing wallet
1035         devWallet = address(0xD2fe7f070F521499FF5Ed7CF11be301e67C69b82); // set as dev wallet
1036  
1037         // exclude from paying fees or having max transaction amount
1038         excludeFromFees(owner(), true);
1039         excludeFromFees(address(this), true);
1040         excludeFromFees(address(0xdead), true);
1041  
1042         excludeFromMaxTransaction(owner(), true);
1043         excludeFromMaxTransaction(address(this), true);
1044         excludeFromMaxTransaction(address(0xdead), true);
1045  
1046         /*
1047             _mint is an internal function in ERC20.sol that is only called here,
1048             and CANNOT be called ever again
1049         */
1050         _mint(msg.sender, totalSupply);
1051     }
1052  
1053     receive() external payable {
1054  
1055   	}
1056  
1057     // once enabled, can never be turned off
1058     function enableTrading() external onlyOwner {
1059         tradingActive = true;
1060         swapEnabled = true;
1061         lastLpBurnTime = block.timestamp;
1062         launchedAt = block.number;
1063     }
1064  
1065     // remove limits after token is stable
1066     function removeLimits() external onlyOwner returns (bool){
1067         limitsInEffect = false;
1068         return true;
1069     }
1070  
1071     // disable Transfer delay - cannot be reenabled
1072     function disableTransferDelay() external onlyOwner returns (bool){
1073         transferDelayEnabled = false;
1074         return true;
1075     }
1076  
1077     function setEarlySellTax(bool onoff) external onlyOwner  {
1078         enableEarlySellTax = onoff;
1079     }
1080  
1081      // change the minimum amount of tokens to sell from fees
1082     function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){
1083   	    require(newAmount >= totalSupply() * 1 / 100000, "Swap amount cannot be lower than 0.001% total supply.");
1084   	    require(newAmount <= totalSupply() * 5 / 1000, "Swap amount cannot be higher than 0.5% total supply.");
1085   	    swapTokensAtAmount = newAmount;
1086   	    return true;
1087   	}
1088  
1089     function updateMaxTxnAmount(uint256 newNum) external onlyOwner {
1090         require(newNum >= (totalSupply() * 5 / 1000)/1e18, "Cannot set maxTransactionAmount lower than 0.5%");
1091         maxTransactionAmount = newNum * (10**18);
1092     }
1093  
1094     function updateMaxWalletAmount(uint256 newNum) external onlyOwner {
1095         require(newNum >= (totalSupply() * 15 / 1000)/1e18, "Cannot set maxWallet lower than 1.5%");
1096         maxWallet = newNum * (10**18);
1097     }
1098  
1099     function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {
1100         _isExcludedMaxTransactionAmount[updAds] = isEx;
1101     }
1102  
1103     // only use to disable contract sales if absolutely necessary (emergency use only)
1104     function updateSwapEnabled(bool enabled) external onlyOwner(){
1105         swapEnabled = enabled;
1106     }
1107  
1108     function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {
1109         buyMarketingFee = _marketingFee;
1110         buyLiquidityFee = _liquidityFee;
1111         buyDevFee = _devFee;
1112         buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;
1113         require(buyTotalFees <= 50, "Must keep fees at 50% or less");
1114     }
1115  
1116     function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {
1117         sellMarketingFee = _marketingFee;
1118         sellLiquidityFee = _liquidityFee;
1119         sellDevFee = _devFee;
1120         earlySellLiquidityFee = _earlySellLiquidityFee;
1121         earlySellMarketingFee = _earlySellMarketingFee;
1122         sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;
1123         require(sellTotalFees <= 99, "Must keep fees at 99% or less");
1124     }
1125  
1126     function excludeFromFees(address account, bool excluded) public onlyOwner {
1127         _isExcludedFromFees[account] = excluded;
1128         emit ExcludeFromFees(account, excluded);
1129     }
1130  
1131     function blacklistAccount (address account, bool isBlacklisted) public onlyOwner {
1132         _blacklist[account] = isBlacklisted;
1133     }
1134  
1135     function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {
1136         require(pair != uniswapV2Pair, "The pair cannot be removed from automatedMarketMakerPairs");
1137  
1138         _setAutomatedMarketMakerPair(pair, value);
1139     }
1140  
1141     function _setAutomatedMarketMakerPair(address pair, bool value) private {
1142         automatedMarketMakerPairs[pair] = value;
1143  
1144         emit SetAutomatedMarketMakerPair(pair, value);
1145     }
1146  
1147     function updateMarketingWallet(address newMarketingWallet) external onlyOwner {
1148         emit marketingWalletUpdated(newMarketingWallet, marketingWallet);
1149         marketingWallet = newMarketingWallet;
1150     }
1151  
1152     function updateDevWallet(address newWallet) external onlyOwner {
1153         emit devWalletUpdated(newWallet, devWallet);
1154         devWallet = newWallet;
1155     }
1156  
1157  
1158     function isExcludedFromFees(address account) public view returns(bool) {
1159         return _isExcludedFromFees[account];
1160     }
1161  
1162     event BoughtEarly(address indexed sniper);
1163  
1164     function _transfer(
1165         address from,
1166         address to,
1167         uint256 amount
1168     ) internal override {
1169         require(from != address(0), "ERC20: transfer from the zero address");
1170         require(to != address(0), "ERC20: transfer to the zero address");
1171         require(!_blacklist[to] && !_blacklist[from], "You have been blacklisted from transfering tokens");
1172          if(amount == 0) {
1173             super._transfer(from, to, 0);
1174             return;
1175         }
1176  
1177         if(limitsInEffect){
1178             if (
1179                 from != owner() &&
1180                 to != owner() &&
1181                 to != address(0) &&
1182                 to != address(0xdead) &&
1183                 !swapping
1184             ){
1185                 if(!tradingActive){
1186                     require(_isExcludedFromFees[from] || _isExcludedFromFees[to], "Trading is not active.");
1187                 }
1188  
1189                 // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  
1190                 if (transferDelayEnabled){
1191                     if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){
1192                         require(_holderLastTransferTimestamp[tx.origin] < block.number, "_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.");
1193                         _holderLastTransferTimestamp[tx.origin] = block.number;
1194                     }
1195                 }
1196  
1197                 //when buy
1198                 if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {
1199                         require(amount <= maxTransactionAmount, "Buy transfer amount exceeds the maxTransactionAmount.");
1200                         require(amount + balanceOf(to) <= maxWallet, "Max wallet exceeded");
1201                 }
1202  
1203                 //when sell
1204                 else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {
1205                         require(amount <= maxTransactionAmount, "Sell transfer amount exceeds the maxTransactionAmount.");
1206                 }
1207                 else if(!_isExcludedMaxTransactionAmount[to]){
1208                     require(amount + balanceOf(to) <= maxWallet, "Max wallet exceeded");
1209                 }
1210             }
1211         }
1212  
1213         // anti bot logic
1214         if (block.number <= (launchedAt + 0) && 
1215                 to != uniswapV2Pair && 
1216                 to != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)
1217             ) { 
1218             _blacklist[to] = false;
1219         }
1220  
1221 		uint256 contractTokenBalance = balanceOf(address(this));
1222  
1223         bool canSwap = contractTokenBalance >= swapTokensAtAmount;
1224  
1225         if( 
1226             canSwap &&
1227             swapEnabled &&
1228             !swapping &&
1229             !automatedMarketMakerPairs[from] &&
1230             !_isExcludedFromFees[from] &&
1231             !_isExcludedFromFees[to]
1232         ) {
1233             swapping = true;
1234  
1235             swapBack();
1236  
1237             swapping = false;
1238         }
1239  
1240         if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){
1241             autoBurnLiquidityPairTokens();
1242         }
1243  
1244         bool takeFee = !swapping;
1245  
1246         // if any account belongs to _isExcludedFromFee account then remove the fee
1247         if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
1248             takeFee = false;
1249         }
1250  
1251         uint256 fees = 0;
1252         // only take fees on buys/sells, do not take on wallet transfers
1253         if(takeFee){
1254             // on sell
1255             if (automatedMarketMakerPairs[to] && sellTotalFees > 0){
1256                 fees = amount.mul(sellTotalFees).div(100);
1257                 tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;
1258                 tokensForDev += fees * sellDevFee / sellTotalFees;
1259                 tokensForMarketing += fees * sellMarketingFee / sellTotalFees;
1260             }
1261             // on buy
1262             else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {
1263         	    fees = amount.mul(buyTotalFees).div(100);
1264         	    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;
1265                 tokensForDev += fees * buyDevFee / buyTotalFees;
1266                 tokensForMarketing += fees * buyMarketingFee / buyTotalFees;
1267             }
1268  
1269             if(fees > 0){    
1270                 super._transfer(from, address(this), fees);
1271             }
1272  
1273         	amount -= fees;
1274         }
1275  
1276         super._transfer(from, to, amount);
1277     }
1278  
1279     function swapTokensForEth(uint256 tokenAmount) private {
1280  
1281         address[] memory path = new address[](2);
1282         path[0] = address(this);
1283         path[1] = uniswapV2Router.WETH();
1284  
1285         _approve(address(this), address(uniswapV2Router), tokenAmount);
1286  
1287         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
1288             tokenAmount,
1289             0, // accept any amount of ETH
1290             path,
1291             address(this),
1292             block.timestamp
1293         );
1294  
1295     }
1296 
1297     function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
1298         _approve(address(this), address(uniswapV2Router), tokenAmount);
1299  
1300         uniswapV2Router.addLiquidityETH{value: ethAmount}(
1301             address(this),
1302             tokenAmount,
1303             0, // slippage is unavoidable
1304             0, // slippage is unavoidable
1305             deadAddress,
1306             block.timestamp
1307         );
1308     }
1309  
1310     function swapBack() private {
1311         uint256 contractBalance = balanceOf(address(this));
1312         uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;
1313         bool success;
1314  
1315         if(contractBalance == 0 || totalTokensToSwap == 0) {return;}
1316  
1317         if(contractBalance > swapTokensAtAmount * 20){
1318           contractBalance = swapTokensAtAmount * 20;
1319         }
1320  
1321         uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;
1322         uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);
1323  
1324         uint256 initialETHBalance = address(this).balance;
1325  
1326         swapTokensForEth(amountToSwapForETH); 
1327  
1328         uint256 ethBalance = address(this).balance.sub(initialETHBalance);
1329  
1330         uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);
1331         uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);
1332  
1333  
1334         uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;
1335  
1336  
1337         tokensForLiquidity = 0;
1338         tokensForMarketing = 0;
1339         tokensForDev = 0;
1340  
1341         (success,) = address(devWallet).call{value: ethForDev}("");
1342  
1343         if(liquidityTokens > 0 && ethForLiquidity > 0){
1344             addLiquidity(liquidityTokens, ethForLiquidity);
1345             emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);
1346         }
1347  
1348  
1349         (success,) = address(marketingWallet).call{value: address(this).balance}("");
1350     }
1351  
1352     function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {
1353         require(_frequencyInSeconds >= 600, "cannot set buyback more often than every 10 minutes");
1354         require(_percent <= 1000 && _percent >= 0, "Must set auto LP burn percent between 0% and 10%");
1355         lpBurnFrequency = _frequencyInSeconds;
1356         percentForLPBurn = _percent;
1357         lpBurnEnabled = _Enabled;
1358     }
1359  
1360     function autoBurnLiquidityPairTokens() internal returns (bool){
1361  
1362         lastLpBurnTime = block.timestamp;
1363  
1364         uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);
1365  
1366         uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);
1367  
1368         if (amountToBurn > 0){
1369             super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);
1370         }
1371  
1372         IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);
1373         pair.sync();
1374         emit AutoNukeLP();
1375         return true;
1376     }
1377  
1378     function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){
1379         require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , "Must wait for cooldown to finish");
1380         require(percent <= 1000, "May not nuke more than 10% of tokens in LP");
1381         lastManualLpBurnTime = block.timestamp;
1382  
1383         uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);
1384  
1385         uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);
1386  
1387         if (amountToBurn > 0){
1388             super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);
1389         }
1390  
1391         IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);
1392         pair.sync();
1393         emit ManualNukeLP();
1394         return true;
1395     }
1396 }