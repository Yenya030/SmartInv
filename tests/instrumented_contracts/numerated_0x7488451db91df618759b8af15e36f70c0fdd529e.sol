1 {{
2   "language": "Solidity",
3   "sources": {
4     "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
6     },
7     "/contracts/ICO/XifraICO2.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../Token/ERC20/IERC20.sol\";\n\ncontract XifraICO2 {\n\n    address immutable private xifraWallet;                      // Xifra wallet\n    address immutable private xifraToken;                       // Xifra token address\n    address immutable private usdtToken;                        // USDT token address\n    address immutable private usdcToken;                        // USDC token address\n    uint256 immutable private minTokensBuyAllowed;              // Minimum tokens allowed\n    uint256 immutable private maxICOTokens;                     // Max ICO tokens to sell\n    uint256 immutable private icoStartDate;                     // ICO start date\n    uint256 immutable private icoEndDate;                       // ICO end date\n    AggregatorV3Interface immutable internal priceFeed;         // Chainlink price feeder ETH/USD\n\n    uint256 public icoTokensBought;                             // Tokens sold\n    uint256 public tokenListingDate;                            // Token listing date\n    mapping(address => uint256) private userBoughtTokens;       // Mapping to store all the buys\n    mapping(address => uint256) private userWithdrawTokens;     // Mapping to store the user tokens withdraw\n\n    bool private icoFinished;\n    uint256 internal constant _MIN_COINS_FOR_VESTING = 23530 * 10 ** 18;    // Min for vesting: 10000$\n\n    event onTokensBought(address _buyer, uint256 _tokens, uint256 _paymentAmount, address _tokenPayment);\n    event onWithdrawICOFunds(uint256 _usdtBalance, uint256 _usdcBalance, uint256 _ethbalance);\n    event onWithdrawBoughtTokens(address _user, uint256 _maxTokensAllowed);\n    event onICOFinished(uint256 _date);\n\n    /**\n     * @notice Constructor\n     * @param _wallet               --> Xifra master wallet\n     * @param _token                --> Xifra token address\n     * @param _icoStartDate         --> ICO start date\n     * @param _icoEndDate           --> ICO end date\n     * @param _usdtToken            --> USDT token address\n     * @param _usdcToken            --> USDC token address\n     * @param _minTokensBuyAllowed  --> Minimal amount of tokens allowed to buy\n     * @param _maxICOTokens         --> Number of tokens selling in this ICO\n     * @param _tokenListingDate     --> Token listing date for the ICO vesting\n     */\n    constructor(address _wallet, address _token, uint256 _icoStartDate, uint256 _icoEndDate, address _usdtToken, address _usdcToken, uint256 _minTokensBuyAllowed, uint256 _maxICOTokens, uint256 _tokenListingDate) {\n        xifraWallet = _wallet;\n        xifraToken = _token;\n        icoStartDate = _icoStartDate;\n        icoEndDate = _icoEndDate;\n        usdtToken = _usdtToken;\n        usdcToken = _usdcToken;\n        minTokensBuyAllowed = _minTokensBuyAllowed;\n        maxICOTokens = _maxICOTokens;\n        tokenListingDate = _tokenListingDate;\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    }\n\n    /**\n     * @notice Buy function. Used to buy tokens using ETH, USDT or USDC\n     * @param _paymentAmount    --> Result of multiply number of tokens to buy per price per token. Must be always multiplied per 1000 to avoid decimals \n     * @param _tokenPayment     --> Address of the payment token (or 0x0 if payment is ETH)\n     */\n    function buy(uint256 _paymentAmount, address _tokenPayment) external payable {\n        require(_isICOActive() == true, \"ICONotActive\");\n               \n        uint256 paidTokens = 0;\n\n        if (msg.value == 0) {\n            // Stable coin payment\n            require(_paymentAmount > 0, \"BadPayment\");\n            require(_tokenPayment == usdtToken || _tokenPayment == usdcToken, \"TokenNotSupported\");\n            require(IERC20(_tokenPayment).transferFrom(msg.sender, address(this), _paymentAmount));\n            paidTokens = _paymentAmount * 1000 / 425;   // 0.425$ per token in the ICO\n        } else {\n            // ETH Payment\n            uint256 usdETH = _getUSDETHPrice();\n            uint256 paidUSD = msg.value * usdETH / 10**18;\n            paidTokens = paidUSD * 1000 / 425;   // 0.425$ per token in the ICO\n        }\n\n        require((paidTokens + 1*10**18) >= minTokensBuyAllowed, \"BadTokensQuantity\");    // One extra token as threshold rounding decimals\n        require(maxICOTokens - icoTokensBought >= paidTokens, \"NoEnoughTokensInICO\");\n        userBoughtTokens[msg.sender] += paidTokens;\n        icoTokensBought += paidTokens;\n        if (maxICOTokens - icoTokensBought < minTokensBuyAllowed) {\n            // We finish the ICO\n            icoFinished = true;\n            emit onICOFinished(block.timestamp);\n        }\n\n        emit onTokensBought(msg.sender, paidTokens, _paymentAmount, _tokenPayment);\n    }\n\n    /**\n     * @notice Withdraw user tokens when the vesting rules allow it\n     */\n    function withdrawBoughtTokens() external {\n        require(_isICOActive() == false, \"ICONotActive\");\n        require(userBoughtTokens[msg.sender] > 0, \"NoBalance\");\n        require(block.timestamp >= tokenListingDate, \"TokenNoListedYet\");\n\n        uint256 boughtBalance = userBoughtTokens[msg.sender];\n        uint256 maxTokensAllowed = 0;\n        if ((block.timestamp >= tokenListingDate) && (block.timestamp < tokenListingDate + 90 days)) {\n            if (boughtBalance <= _MIN_COINS_FOR_VESTING) {\n                maxTokensAllowed = boughtBalance - userWithdrawTokens[msg.sender];\n            } else {\n                uint maxTokens = boughtBalance * 25 / 100;\n                if (userWithdrawTokens[msg.sender] < maxTokens) {\n                    maxTokensAllowed = maxTokens;\n                }\n            }\n        } else if ((block.timestamp >= tokenListingDate + 90 days) && (block.timestamp < tokenListingDate + 180 days)) {\n            uint256 maxTokens = boughtBalance * 50 / 100;\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\n            }\n        } else if ((block.timestamp >= tokenListingDate + 180 days) && (block.timestamp < tokenListingDate + 270 days)) {\n            uint256 maxTokens = boughtBalance * 75 / 100;\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\n            }\n        } else {\n            uint256 maxTokens = boughtBalance;\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\n            }\n        }\n\n        require(maxTokensAllowed > 0, \"NoTokensToWithdraw\");\n\n        userWithdrawTokens[msg.sender] += maxTokensAllowed;\n        require(IERC20(xifraToken).transfer(msg.sender, maxTokensAllowed));\n\n        emit onWithdrawBoughtTokens(msg.sender, maxTokensAllowed);\n    }\n\n    /**\n     * @notice Returns the crypto numbers and balance in the ICO contract\n     */\n    function withdrawICOFunds() external {\n        require(_isICOActive() == false, \"ICOStillActive\");\n        \n        uint256 usdtBalance = IERC20(usdtToken).balanceOf(address(this));\n        require(IERC20(usdtToken).transfer(xifraWallet, usdtBalance));\n\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\n        require(IERC20(usdcToken).transfer(xifraWallet, usdcBalance));\n\n        uint256 ethbalance = address(this).balance;\n        payable(xifraWallet).transfer(ethbalance);\n\n        emit onWithdrawICOFunds(usdtBalance, usdcBalance, ethbalance);\n    }\n\n    /**\n     * @notice Withdraw the unsold Xifra tokens to the Xifra wallet when the ICO is finished\n     */\n    function withdrawICOTokens() external {\n        require(_isICOActive() == false, \"ICONotActive\");\n        require(msg.sender == xifraWallet, \"OnlyXifra\");\n\n        uint256 balance = maxICOTokens - icoTokensBought;\n        require(IERC20(xifraToken).transfer(xifraWallet, balance));\n    }\n\n    /**\n     * @notice OnlyOwner function. Change the listing date to start the vesting\n     * @param _tokenListDate --> New listing date in UnixDateTime UTC format\n     */\n    function setTokenListDate(uint256 _tokenListDate) external {\n        require(msg.sender == xifraWallet, \"BadOwner\");\n        require(block.timestamp <= tokenListingDate, \"TokenListedYet\");\n\n        tokenListingDate = _tokenListDate;\n    }\n\n    /**\n     * @notice Returns the number of tokens and user has bought\n     * @param _user --> User account\n     * @return Returns the user token balance in wei units\n     */\n    function getUserBoughtTokens(address _user) external view returns(uint256) {\n        return userBoughtTokens[_user];\n    }\n\n    /**\n     * @notice Returns the number of tokens and user has withdrawn\n     * @param _user --> User account\n     * @return Returns the user token withdrawns in wei units\n     */\n    function getUserWithdrawnTokens(address _user) external view returns(uint256) {\n        return userWithdrawTokens[_user];\n    }\n\n    /**\n     * @notice Returns the crypto numbers in the ICO\n     * @return xifra Returns the Xifra tokens balance in the contract\n     * @return eth Returns the ETHs balance in the contract\n     * @return usdt Returns the USDTs balance in the contract\n     * @return usdc Returns the USDCs balance in the contract\n     */\n    function getICOData() external view returns(uint256 xifra, uint256 eth, uint256 usdt, uint256 usdc) {\n        xifra = IERC20(xifraToken).balanceOf(address(this));\n        usdt = IERC20(usdtToken).balanceOf(address(this));\n        usdc = IERC20(usdcToken).balanceOf(address(this));\n        eth = address(this).balance;\n    }\n\n    /**\n     * @notice Traslate a payment in USD to ETHs\n     * @param _paymentAmount --> Payment amount in USD\n     * @return Returns the ETH amount in weis\n     */\n    function calculateETHPayment(uint256 _paymentAmount) external view returns(uint256) {\n        uint256 usdETH = _getUSDETHPrice();\n        return (_paymentAmount * 10 ** 18) / usdETH;\n    }\n\n    /**\n     * @notice Get the vesting unlock dates\n     * @param _period --> There are 4 periods (0,1,2,3)\n     * @return _date Returns the date in UnixDateTime UTC format\n     */\n    function getVestingDate(uint256 _period) external view returns(uint256 _date) {\n        if (_period == 0) {\n            _date = tokenListingDate;\n        } else if (_period == 1) {\n            _date = tokenListingDate + 90 days;\n        } else if (_period == 2) {\n            _date = tokenListingDate + 180 days;\n        } else if (_period == 3) {\n            _date = tokenListingDate + 270 days;\n        }\n    }\n\n    /**\n     * @notice Public function that returns ETHUSD par\n     * @return Returns the how much USDs are in 1 ETH in weis\n     */\n    function getUSDETHPrice() external view returns(uint256) {\n        return _getUSDETHPrice();\n    }\n\n    /**\n     * @notice Uses Chainlink to query the USDETH price\n     * @return Returns the ETH amount in weis (Fixed value of 3932.4 USDs in localhost development environments)\n     */\n    function _getUSDETHPrice() internal view returns(uint256) {\n        (, int price, , , ) = priceFeed.latestRoundData();\n\n        return uint256(price * 10**10);\n    }\n\n    /**\n     * @notice Internal - Is ICO active?\n     * @return Returns true or false\n     */\n    function _isICOActive() internal view returns(bool) {\n        if ((block.timestamp < icoStartDate) || (block.timestamp > icoEndDate) || (icoFinished == true)) return false;\n        else return true;\n    }\n\n    /**\n     * @notice External - Is ICO active?\n     * @return Returns true or false\n     */\n    function isICOActive() external view returns(bool) {\n        return _isICOActive();\n    }\n}"
9     },
10     "/contracts/Token/ERC20/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
12     }
13   },
14   "settings": {
15     "remappings": [],
16     "optimizer": {
17       "enabled": true,
18       "runs": 200
19     },
20     "evmVersion": "london",
21     "libraries": {},
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     }
34   }
35 }}