1 # @version 0.2.12
2 
3 interface AddressProvider:
4     def get_registry() -> address: view
5     def get_address(_id: uint256) -> address: view
6 
7 interface Registry:
8     def find_pool_for_coins(_from: address, _to: address) -> address: view
9     def get_coin_indices(
10         _pool: address,
11         _from: address,
12         _to: address
13     ) -> (uint256, uint256, uint256): view
14 
15 interface RegistrySwap:
16     def get_best_rate(_from: address, _to: address, _amount: uint256) -> (address, uint256): view
17 
18 interface CurveCryptoSwap:
19     def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view
20     def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable
21     def coins(i: uint256) -> address: view
22 
23 interface CurvePool:
24     def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable
25     def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable
26 
27 interface ERC20:
28     def approve(spender: address, amount: uint256): nonpayable
29     def transfer(to: address, amount: uint256): nonpayable
30     def transferFrom(sender: address, to: address, amount: uint256): nonpayable
31     def balanceOf(owner: address) -> uint256: view
32 
33 
34 event CommitOwnership:
35     admin: address
36 
37 event ApplyOwnership:
38     admin: address
39 
40 event TrustedForwardershipTransferred:
41     previous_forwarder: address
42     new_forwarder: address
43 
44 
45 ADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383
46 ETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE
47 WETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
48 
49 swap: public(address)
50 crypto_coins: public(address[3])
51 
52 # token -> spender -> is approved to transfer?
53 is_approved: HashMap[address, HashMap[address, bool]]
54 
55 owner: public(address)
56 trusted_forwarder: public(address)
57 
58 future_owner: public(address)
59 
60 
61 @external
62 def __init__(_swap: address):
63     self.owner = msg.sender
64     self.swap = _swap
65     for i in range(3):
66         coin: address = CurveCryptoSwap(_swap).coins(i)
67         if coin == WETH:
68             self.crypto_coins[i] = ETH
69         else:
70             ERC20(coin).approve(_swap, MAX_UINT256)
71             self.crypto_coins[i] = coin
72 
73 
74 @payable
75 @external
76 def __default__():
77     # required to receive Ether
78     pass
79 
80 
81 @payable
82 @external
83 def exchange(
84     _amount: uint256,
85     _route: address[6],
86     _indices: uint256[8],
87     _min_received: uint256,
88     _receiver: address = msg.sender
89 ):
90     """
91     @notice Perform a cross-asset exchange.
92     @dev `_route` and `_indices` are generated by calling `get_exchange_routing`
93          prior to making a transaction. This reduces gas costs on swaps.
94     @param _amount Amount of the input token being swapped.
95     @param _route Array of token and pool addresses used within the swap.
96     @param _indices Array of `i` and `j` inputs used for individual swaps.
97     @param _min_received Minimum amount of the output token to be received. If
98                          the actual amount received is less the call will revert.
99     @param _receiver An alternate address to which the output of the exchange will be sent
100     """
101     # Meta-tx support
102     msg_sender: address = msg.sender
103     receiver: address = _receiver
104     if msg_sender == self.trusted_forwarder:
105         calldata_len: uint256 = len(msg.data)
106         addr_bytes: Bytes[20] = empty(Bytes[20])
107         # grab the last 20 bytes of calldata which holds the address
108         if calldata_len == 536:
109             addr_bytes = slice(msg.data, 516, 20)
110         elif calldata_len == 568:
111             addr_bytes = slice(msg.data, 548, 20)
112         # convert to an address
113         msg_sender = convert(convert(addr_bytes, uint256), address)
114         if _receiver == msg.sender:
115             # we already know that msg.sender is the trusted forwarder
116             # if _receiver is set to msg.sender change it to be correct
117             receiver = msg_sender
118 
119     eth_value: uint256 = 0
120     amount: uint256 = _amount
121 
122     # perform the first stableswap, if required
123     if _route[1] != ZERO_ADDRESS:
124         ERC20(_route[0]).transferFrom(msg_sender, self, _amount)  # dev: insufficient amount
125 
126         if not self.is_approved[_route[0]][_route[1]]:
127             ERC20(_route[0]).approve(_route[1], MAX_UINT256)  # dev: bad response
128             self.is_approved[_route[0]][_route[1]] = True
129 
130         # `_indices[2]` is a boolean-as-integer indicating if the swap uses `exchange_underlying`
131         if _indices[2] == 0:
132             CurvePool(_route[1]).exchange(
133                 convert(_indices[0], int128),
134                 convert(_indices[1], int128),
135                 _amount,
136                 0,
137                 value=msg.value,
138             )  # dev: bad response
139         else:
140             CurvePool(_route[1]).exchange_underlying(
141                 convert(_indices[0], int128),
142                 convert(_indices[1], int128),
143                 _amount,
144                 0,
145                 value=msg.value,
146             )  # dev: bad response
147 
148         if _route[2] == ETH:
149             amount = self.balance
150             eth_value = self.balance
151         else:
152             amount = ERC20(_route[2]).balanceOf(self)  # dev: bad response
153 
154     # if no initial stableswap, transfer token and validate the amount of ether sent
155     elif _route[2] == ETH:
156         assert _amount == msg.value  # dev: insufficient amount
157         eth_value = msg.value
158     else:
159         assert msg.value == 0
160         ERC20(_route[2]).transferFrom(msg_sender, self, _amount)  # dev: insufficient amount
161 
162     # perform the main crypto swap
163     use_eth: bool = ETH in [_route[2], _route[3]]
164     CurveCryptoSwap(self.swap).exchange(
165         _indices[3],
166         _indices[4],
167         amount,
168         0,
169         use_eth,
170         value=eth_value
171     )  # dev: bad response
172     if _route[3] == ETH:
173         amount = self.balance
174         eth_value = self.balance
175     else:
176         amount = ERC20(_route[3]).balanceOf(self)  # dev: bad response
177         eth_value = 0
178 
179     # perform the second stableswap, if required
180     if _route[4] != ZERO_ADDRESS:
181         if _route[3] != ETH and not self.is_approved[_route[3]][_route[4]]:
182             ERC20(_route[3]).approve(_route[4], MAX_UINT256)  # dev: bad response
183             self.is_approved[_route[3]][_route[4]] = True
184 
185         # `_indices[7]` is a boolean-as-integer indicating if the swap uses `exchange_underlying`
186         if _indices[7] == 0:
187             CurvePool(_route[4]).exchange(
188                 convert(_indices[5], int128),
189                 convert(_indices[6], int128),
190                 amount,
191                 _min_received,
192                 value=eth_value,
193             )  # dev: bad response
194         else:
195             CurvePool(_route[4]).exchange_underlying(
196                 convert(_indices[5], int128),
197                 convert(_indices[6], int128),
198                 amount,
199                 _min_received,
200                 value=eth_value,
201             )  # dev: bad response
202 
203         if _route[5] == ETH:
204             raw_call(receiver, b"", value=self.balance)
205         else:
206             amount = ERC20(_route[5]).balanceOf(self)
207             ERC20(_route[5]).transfer(receiver, amount)
208 
209     # if no final swap, check slippage and transfer to receiver
210     else:
211         assert amount >= _min_received
212         if _route[3] == ETH:
213             raw_call(receiver, b"", value=self.balance)
214         else:
215             ERC20(_route[3]).transfer(receiver, amount)
216 
217 
218 @view
219 @external
220 def get_exchange_routing(
221     _initial: address,
222     _target: address,
223     _amount: uint256
224 ) -> (address[6], uint256[8], uint256):
225     """
226     @notice Get routing data for a cross-asset exchange.
227     @dev Outputs from this function are used as inputs when calling `exchange`.
228     @param _initial Address of the initial token being swapped.
229     @param _target Address of the token to be received in the swap.
230     @param _amount Amount of `_initial` to swap.
231     @return _route Array of token and pool addresses used within the swap,
232                     Array of `i` and `j` inputs used for individual swaps.
233                     Expected amount of the output token to be received.
234     """
235 
236     # route is [initial coin, stableswap, cryptopool input, cryptopool output, stableswap, target coin]
237     route: address[6] = empty(address[6])
238 
239     # indices is [(i, j, is_underlying), (i, j), (i, j, is_underlying)]
240     # tuples indicate first stableswap, crypto swap, second stableswap
241     indices: uint256[8] = empty(uint256[8])
242 
243     crypto_input: address = ZERO_ADDRESS
244     crypto_output: address = ZERO_ADDRESS
245     market: address = ZERO_ADDRESS
246 
247     amount: uint256 = _amount
248     crypto_coins: address[3] = self.crypto_coins
249     swaps: address = AddressProvider(ADDRESS_PROVIDER).get_address(2)
250     registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()
251 
252     # if initial coin is not in the crypto pool, get info for the first stableswap
253     if _initial in crypto_coins:
254         crypto_input = _initial
255     else:
256         received: uint256 = 0
257         for coin in crypto_coins:
258             market, received = RegistrySwap(swaps).get_best_rate(_initial, coin, amount)
259             if market != ZERO_ADDRESS:
260                 indices[0], indices[1], indices[2] = Registry(registry).get_coin_indices(market, _initial, coin)
261                 route[0] = _initial
262                 route[1] = market
263                 crypto_input = coin
264                 amount = received
265                 break
266         assert market != ZERO_ADDRESS
267 
268     # determine target coin when swapping in the crypto pool
269     if _target in crypto_coins:
270         crypto_output = _target
271     else:
272         for coin in crypto_coins:
273             if Registry(registry).find_pool_for_coins(coin, _target) != ZERO_ADDRESS:
274                 crypto_output = coin
275                 break
276         assert crypto_output != ZERO_ADDRESS
277 
278     assert crypto_input != crypto_output
279 
280     # get i, j and dy for crypto swap
281     for x in range(3):
282         coin: address = self.crypto_coins[x]
283         if coin == crypto_input:
284             indices[3] = x
285         elif coin == crypto_output:
286             indices[4] = x
287     route[2] = crypto_input
288     route[3] = crypto_output
289     amount = CurveCryptoSwap(self.swap).get_dy(indices[3], indices[4], amount)
290 
291     # if target coin is not in the crypto pool, get info for the final stableswap
292     if crypto_output != _target:
293         market, amount = RegistrySwap(swaps).get_best_rate(crypto_output, _target, amount)
294         indices[5], indices[6], indices[7] = Registry(registry).get_coin_indices(market, crypto_output, _target)
295         route[4] = market
296         route[5] = _target
297 
298     return route, indices, amount
299 
300 
301 @view
302 @external
303 def can_route(_initial: address, _target: address) -> bool:
304     """
305     @notice Check if a route is available between two tokens.
306     @param _initial Address of the initial token being swapped.
307     @param _target Address of the token to be received in the swap.
308     @return bool Is route available?
309     """
310 
311     crypto_coins: address[3] = self.crypto_coins
312     registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()
313 
314     crypto_input: address = _initial
315     if _initial not in crypto_coins:
316         market: address = ZERO_ADDRESS
317         for coin in crypto_coins:
318             market = Registry(registry).find_pool_for_coins(_initial, coin)
319             if market != ZERO_ADDRESS:
320                 crypto_input = coin
321                 break
322         if market == ZERO_ADDRESS:
323             return False
324 
325     crypto_output: address = _target
326     if _target not in crypto_coins:
327         market: address = ZERO_ADDRESS
328         for coin in crypto_coins:
329             market = Registry(registry).find_pool_for_coins(coin, _target)
330             if market != ZERO_ADDRESS:
331                 crypto_output = coin
332                 break
333         if market == ZERO_ADDRESS:
334             return False
335 
336     return crypto_input != crypto_output
337 
338 
339 @external
340 def commit_transfer_ownership(addr: address):
341     """
342     @notice Transfer ownership of GaugeController to `addr`
343     @param addr Address to have ownership transferred to
344     """
345     assert msg.sender == self.owner  # dev: admin only
346 
347     self.future_owner = addr
348     log CommitOwnership(addr)
349 
350 
351 @external
352 def accept_transfer_ownership():
353     """
354     @notice Accept a pending ownership transfer
355     """
356     _admin: address = self.future_owner
357     assert msg.sender == _admin  # dev: future admin only
358 
359     self.owner = _admin
360     log ApplyOwnership(_admin)
361 
362 
363 @view
364 @external
365 def isTrustedForwarder(_forwarder: address) -> bool:
366     """
367     @notice ERC-2771 meta-txs discovery mechanism
368     @param _forwarder Address to compare against the set trusted forwarder 
369     @return bool True if `_forwarder` equals the set trusted forwarder
370     """
371     return _forwarder == self.trusted_forwarder
372 
373 
374 @external
375 def set_trusted_forwarder(_forwarder: address) -> bool:
376     """
377     @notice Set the trusted forwarder address
378     @param _forwarder The address of the trusted forwarder
379     @return bool True on successful execution
380     """
381     assert msg.sender == self.owner
382 
383     prev_forwarder: address = self.trusted_forwarder
384     self.trusted_forwarder = _forwarder
385 
386     log TrustedForwardershipTransferred(prev_forwarder, _forwarder)
387     return True