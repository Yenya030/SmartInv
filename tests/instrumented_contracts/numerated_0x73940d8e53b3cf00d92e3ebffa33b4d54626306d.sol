1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/LockedKEYS.sol": {
5       "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n    \n    function decimals() external view returns (uint8);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Ownable {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier onlyOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n/**\n    Locked KEYS Contract\n    Auto Compounding Staking Protocol\n */\ncontract LockedKeys is Ownable, IERC20 {\n\n    using SafeMath for uint256;\n\n    // Staking Token\n    IERC20 public immutable token;\n\n    // Staking Protocol Token Info\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    // Trackable User Info\n    struct UserInfo {\n        uint256 balance;\n        uint256 unlockBlock;\n        uint256 totalStaked;\n        uint256 totalWithdrawn;\n    }\n    // User -> UserInfo\n    mapping ( address => UserInfo ) public userInfo;\n\n    // Unstake Early Fee\n    uint256 public leaveEarlyFee;\n\n    // Timer For Leave Early Fee\n    uint256 public leaveEarlyFeeTimer;\n\n    // total supply of MAXI\n    uint256 private _totalShares;\n\n    // Swapper To Purchase Token From ETH\n    address public tokenSwapper;\n\n    // precision factor\n    uint256 private constant precision = 10**18;\n\n    // Reentrancy Guard\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"Reentrancy Guard call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    // Events\n    event PriceChange(uint256 previous, uint256 current, uint256 totalMAXISupply);\n    event Deposit(address depositor, uint256 amountToken);\n    event Withdraw(address withdrawer, uint256 amountToken);\n    event FeeTaken(uint256 fee);\n\n    constructor(\n        string memory name_, \n        string memory symbol_,\n        address token_,\n        address tokenSwapper_,\n        uint256 leaveEarlyFee_,\n        uint256 leaveEarlyFeeTimer_\n    ) {\n\n        require(token_ != address(0), 'Zero Address');\n        require(tokenSwapper_ != address(0), 'Zero Address');\n        require(leaveEarlyFee_ <= 100, 'Fee Too High');\n        require(leaveEarlyFeeTimer_ <= 10**7, 'Fee Timer Too Long');\n\n        // pair token data\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = IERC20(token_).decimals();\n\n        // staking data\n        leaveEarlyFee = leaveEarlyFee_;\n        leaveEarlyFeeTimer = leaveEarlyFeeTimer_;\n        tokenSwapper = tokenSwapper_;\n\n        // pair staking token\n        token = IERC20(token_);\n\n        // set reentrancy\n        _status = _NOT_ENTERED;\n        \n        // emit transfer so bscscan registers contract as token\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() external view override returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /** Shows The Value Of Users' Staked Token */\n    function balanceOf(address account) public view override returns (uint256) {\n        return ReflectionsFromContractBalance(userInfo[account].balance);\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount);\n        }\n        return true;\n    }\n    function transferFrom(address, address recipient, uint256 amount) external override returns (bool) {\n        if (recipient == msg.sender) {\n            withdraw(amount);\n        }        \n        return true;\n    }\n\n    function setLeaveEarlyFee(uint256 newLeaveEarlyFee) external onlyOwner {\n        require(\n            newLeaveEarlyFee <= 100,\n            'Early Fee Too High'\n        );\n        leaveEarlyFee = newLeaveEarlyFee;\n    }\n    function setLeaveEarlyFeeTimer(uint256 newLeaveEarlyFeeTimer) external onlyOwner {\n        require(\n            newLeaveEarlyFeeTimer <= 10**7,\n            'Fee Timer Too High'\n        );\n        leaveEarlyFeeTimer = newLeaveEarlyFeeTimer;\n    }\n    function setTokenSwapper(address newTokenSwapper) external onlyOwner {\n        require(\n            newTokenSwapper != address(0),\n            'Zero Address'\n        );\n        tokenSwapper = newTokenSwapper;\n    }\n\n    function withdrawETH() external onlyOwner {\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(s, 'Error On ETH Withdrawal');\n    }\n\n    function recoverForeignToken(IERC20 _token) external onlyOwner {\n        require(\n            address(_token) != address(token),\n            'Cannot Withdraw Staking Tokens'\n        );\n        require(\n            _token.transfer(msg.sender, _token.balanceOf(address(this))),\n            'Error Withdrawing Foreign Token'\n        );\n    }\n\n    /** \n        ETH Sent To Contract Will Buy And Stake Token\n     */\n    receive() external payable {\n        _deposit(msg.value, true);\n    }\n\n    /**\n        Transfers in `amount` of Token From Sender\n        And Locks In Contract, Minting MAXI Tokens\n     */\n    function deposit(uint256 amount) external {\n        _deposit(amount, false);\n    }\n\n    /**\n        Redeems `amount` of Underlying Tokens, As Seen From BalanceOf()\n     */\n    function withdraw(uint256 amount) public nonReentrant returns (uint256) {\n\n        // Token Amount Into Contract Balance Amount\n        uint MAXI_Amount = amount == balanceOf(msg.sender) ? userInfo[msg.sender].balance : TokenToContractBalance(amount);\n\n        require(\n            userInfo[msg.sender].balance > 0 &&\n            userInfo[msg.sender].balance >= MAXI_Amount &&\n            balanceOf(msg.sender) >= amount &&\n            amount > 0 &&\n            MAXI_Amount > 0,\n            'Insufficient Funds'\n        );\n\n        // burn MAXI Tokens From Sender\n        _burn(msg.sender, MAXI_Amount, amount);\n\n        // increment total withdrawn\n        userInfo[msg.sender].totalWithdrawn += amount;\n\n        // Take Fee If Withdrawn Before Timer\n        uint fee = remainingLockTime(msg.sender) == 0 ? 100 : amount.mul(leaveEarlyFee).div(1000);\n\n        // send amount less fee\n        uint256 sendAmount = amount.sub(fee);\n\n        // ensure round off protection\n        uint256 bal = token.balanceOf(address(this));\n        if (sendAmount > bal) {\n            sendAmount = bal;\n        }\n\n        // transfer amount to sender\n        require(\n            token.transfer(msg.sender, sendAmount),\n            'Error On Token Transfer'\n        );\n\n        // emit event\n        emit Withdraw(msg.sender, sendAmount);\n        return sendAmount;\n    }\n\n    function donate() external payable nonReentrant {\n        // buy staking token\n        _buyToken(address(this).balance);\n    }\n\n    /**\n        Handles Deposits Internally\n     */\n    function _deposit(uint256 amount, bool wETH) internal nonReentrant {\n\n        // Ensure Positive Transfer Amount\n        require(\n            amount > 0,\n            'Zero Amount'\n        );\n\n        // Track Balance Before Deposit\n        uint previousBalance = token.balanceOf(address(this));\n\n        // fetch keys token\n        uint received = wETH ? _buyToken(amount) : _transferIn(amount);\n\n        if (_totalShares == 0 || previousBalance == 0) {\n            // mint first batch to holders\n            _registerFirstPurchase(received);\n        } else {\n\n            // mints correct token amount to sender given data\n            _mintTo(msg.sender, received, previousBalance);\n        }\n    }\n\n    /**\n        Registers the First Stake\n     */\n    function _registerFirstPurchase(uint received) internal {\n        \n        // increment total staked\n        userInfo[msg.sender].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(msg.sender, received, received);\n\n        emit Deposit(msg.sender, received);\n    }\n\n    function _mintTo(address sender, uint256 received, uint256 previousBalance) internal {\n        // Number Of Maxi Tokens To Mint\n        uint nToMint = (_totalShares.mul(received).div(previousBalance)).sub(100);\n        require(\n            nToMint > 0,\n            'Zero To Mint'\n        );\n\n        // increment total staked\n        userInfo[sender].totalStaked += received;\n\n        // mint MAXI Tokens To Sender\n        _mint(sender, nToMint, received);\n\n        emit Deposit(sender, received);\n    }\n\n    function _buyToken(uint amount) internal returns (uint256) {\n        require(\n            amount > 0,\n            'Zero Amount'\n        );\n        uint before = token.balanceOf(address(this));\n        (bool s,) = payable(tokenSwapper).call{value: amount}(\"\");\n        require(s, 'Failure On Token Purchase');\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(received > 0, 'Zero Received');\n        return received;\n    }\n\n    function _transferIn(uint256 amount) internal returns (uint256) {\n        uint before = token.balanceOf(address(this));\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            'Failure On TransferFrom'\n        );\n        uint received = token.balanceOf(address(this)).sub(before);\n        require(\n            received <= amount && received > 0,\n            'Error On Transfer In'\n        );\n        return received;\n    }\n\n    /**\n     * Burns `amount` of Contract Balance Token\n     */\n    function _burn(address from, uint256 amount, uint256 amountToken) private {\n        userInfo[from].balance = userInfo[from].balance.sub(amount);\n        _totalShares = _totalShares.sub(amount);\n        emit Transfer(from, address(0), amountToken);\n    }\n\n    /**\n     * Mints `amount` of Contract Balance Token\n     */\n    function _mint(address to, uint256 amount, uint256 underlyingValue) private {\n        // allocate\n        userInfo[to].balance = userInfo[to].balance.add(amount);\n        _totalShares = _totalShares.add(amount);\n        // update locker info\n        userInfo[msg.sender].unlockBlock = block.number + leaveEarlyFeeTimer;\n        emit Transfer(address(0), to, underlyingValue);\n    }\n\n\n    /**\n        Converts A Staking Token Amount Into A MAXI Amount\n     */\n    function TokenToContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(precision).div(_calculatePrice());\n    }\n\n    /**\n        Converts A MAXI Amount Into A Token Amount\n     */\n    function ReflectionsFromContractBalance(uint256 amount) public view returns (uint256) {\n        return amount.mul(_calculatePrice()).div(precision);\n    }\n\n    /** Conversion Ratio For MAXI -> Token */\n    function calculatePrice() external view returns (uint256) {\n        return _calculatePrice();\n    }\n\n    /**\n        Lock Time Remaining For Stakers\n     */\n    function remainingLockTime(address user) public view returns (uint256) {\n        return userInfo[user].unlockBlock < block.number ? 0 : userInfo[user].unlockBlock - block.number;\n    }\n\n    /** Returns Total Profit for User In Token From MAXI */\n    function getTotalProfits(address user) external view returns (uint256) {\n        uint top = balanceOf(user) + userInfo[user].totalWithdrawn;\n        return top <= userInfo[user].totalStaked ? 0 : top - userInfo[user].totalStaked;\n    }\n    \n    /** Conversion Ratio For MAXI -> Token */\n    function _calculatePrice() internal view returns (uint256) {\n        uint256 backingValue = token.balanceOf(address(this));\n        return (backingValue.mul(precision)).div(_totalShares);\n    }\n\n    /** function has no use in contract */\n    function allowance(address, address) external pure override returns (uint256) { \n        return 0;\n    }\n    /** function has no use in contract */\n    function approve(address spender, uint256) public override returns (bool) {\n        emit Approval(msg.sender, spender, 0);\n        return true;\n    }\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": false,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}