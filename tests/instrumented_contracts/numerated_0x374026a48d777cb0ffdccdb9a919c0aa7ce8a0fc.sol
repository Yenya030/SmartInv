1 
2 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
3 
4 pragma solidity ^0.5.0;
5 
6 /**
7  * @title Elliptic curve signature operations
8  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
9  * TODO Remove this library once solidity supports passing a signature to ecrecover.
10  * See https://github.com/ethereum/solidity/issues/864
11  */
12 
13 library ECDSA {
14     /**
15      * @dev Recover signer address from a message by using their signature
16      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
17      * @param signature bytes signature, the signature is generated using web3.eth.sign()
18      */
19     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
20         bytes32 r;
21         bytes32 s;
22         uint8 v;
23 
24         // Check the signature length
25         if (signature.length != 65) {
26             return (address(0));
27         }
28 
29         // Divide the signature in r, s and v variables
30         // ecrecover takes the signature parameters, and the only way to get them
31         // currently is to use assembly.
32         // solhint-disable-next-line no-inline-assembly
33         assembly {
34             r := mload(add(signature, 0x20))
35             s := mload(add(signature, 0x40))
36             v := byte(0, mload(add(signature, 0x60)))
37         }
38 
39         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
40         if (v < 27) {
41             v += 27;
42         }
43 
44         // If the version is correct return the signer address
45         if (v != 27 && v != 28) {
46             return (address(0));
47         } else {
48             return ecrecover(hash, v, r, s);
49         }
50     }
51 
52     /**
53      * toEthSignedMessageHash
54      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
55      * and hash the result
56      */
57     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
58         // 32 is the length in bytes of hash,
59         // enforced by the type signature above
60         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
61     }
62 }
63 
64 // File: contracts/votingMachines/IntVoteInterface.sol
65 
66 pragma solidity ^0.5.4;
67 
68 interface IntVoteInterface {
69     //When implementing this interface please do not only override function and modifier,
70     //but also to keep the modifiers on the overridden functions.
71     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
72     modifier votable(bytes32 _proposalId) {revert(); _;}
73 
74     event NewProposal(
75         bytes32 indexed _proposalId,
76         address indexed _organization,
77         uint256 _numOfChoices,
78         address _proposer,
79         bytes32 _paramsHash
80     );
81 
82     event ExecuteProposal(bytes32 indexed _proposalId,
83         address indexed _organization,
84         uint256 _decision,
85         uint256 _totalReputation
86     );
87 
88     event VoteProposal(
89         bytes32 indexed _proposalId,
90         address indexed _organization,
91         address indexed _voter,
92         uint256 _vote,
93         uint256 _reputation
94     );
95 
96     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
97     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
98 
99     /**
100      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
101      * generated by calculating keccak256 of a incremented counter.
102      * @param _numOfChoices number of voting choices
103      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
104      * @param _proposer address
105      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
106      * @return proposal's id.
107      */
108     function propose(
109         uint256 _numOfChoices,
110         bytes32 _proposalParameters,
111         address _proposer,
112         address _organization
113         ) external returns(bytes32);
114 
115     function vote(
116         bytes32 _proposalId,
117         uint256 _vote,
118         uint256 _rep,
119         address _voter
120     )
121     external
122     returns(bool);
123 
124     function cancelVote(bytes32 _proposalId) external;
125 
126     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
127 
128     function isVotable(bytes32 _proposalId) external view returns(bool);
129 
130     /**
131      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
132      * @param _proposalId the ID of the proposal
133      * @param _choice the index in the
134      * @return voted reputation for the given choice
135      */
136     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
137 
138     /**
139      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
140      * @return bool true or false
141      */
142     function isAbstainAllow() external pure returns(bool);
143 
144     /**
145      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
146      * @return min - minimum number of choices
147                max - maximum number of choices
148      */
149     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
150 }
151 
152 // File: contracts/libs/RealMath.sol
153 
154 pragma solidity ^0.5.4;
155 
156 /**
157  * RealMath: fixed-point math library, based on fractional and integer parts.
158  * Using uint256 as real216x40, which isn't in Solidity yet.
159  * Internally uses the wider uint256 for some math.
160  *
161  * Note that for addition, subtraction, and mod (%), you should just use the
162  * built-in Solidity operators. Functions for these operations are not provided.
163  *
164  */
165 
166 
167 library RealMath {
168 
169     /**
170      * How many total bits are there?
171      */
172     uint256 constant private REAL_BITS = 256;
173 
174     /**
175      * How many fractional bits are there?
176      */
177     uint256 constant private REAL_FBITS = 40;
178 
179     /**
180      * What's the first non-fractional bit
181      */
182     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
183 
184     /**
185      * Raise a real number to any positive integer power
186      */
187     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
188 
189         uint256 tempRealBase = realBase;
190         uint256 tempExponent = exponent;
191 
192         // Start with the 0th power
193         uint256 realResult = REAL_ONE;
194         while (tempExponent != 0) {
195             // While there are still bits set
196             if ((tempExponent & 0x1) == 0x1) {
197                 // If the low bit is set, multiply in the (many-times-squared) base
198                 realResult = mul(realResult, tempRealBase);
199             }
200                 // Shift off the low bit
201             tempExponent = tempExponent >> 1;
202             if (tempExponent != 0) {
203                 // Do the squaring
204                 tempRealBase = mul(tempRealBase, tempRealBase);
205             }
206         }
207 
208         // Return the final result.
209         return realResult;
210     }
211 
212     /**
213      * Create a real from a rational fraction.
214      */
215     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
216         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
217     }
218 
219     /**
220      * Multiply one real by another. Truncates overflows.
221      */
222     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
223         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
224         // So we just have to clip off the extra REAL_FBITS fractional bits.
225         uint256 res = realA * realB;
226         require(res/realA == realB, "RealMath mul overflow");
227         return (res >> REAL_FBITS);
228     }
229 
230     /**
231      * Divide one real by another real. Truncates overflows.
232      */
233     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
234         // We use the reverse of the multiplication trick: convert numerator from
235         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
236         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
237     }
238 
239 }
240 
241 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
242 
243 pragma solidity ^0.5.0;
244 
245 /**
246  * @title ERC20 interface
247  * @dev see https://github.com/ethereum/EIPs/issues/20
248  */
249 interface IERC20 {
250     function transfer(address to, uint256 value) external returns (bool);
251 
252     function approve(address spender, uint256 value) external returns (bool);
253 
254     function transferFrom(address from, address to, uint256 value) external returns (bool);
255 
256     function totalSupply() external view returns (uint256);
257 
258     function balanceOf(address who) external view returns (uint256);
259 
260     function allowance(address owner, address spender) external view returns (uint256);
261 
262     event Transfer(address indexed from, address indexed to, uint256 value);
263 
264     event Approval(address indexed owner, address indexed spender, uint256 value);
265 }
266 
267 // File: contracts/votingMachines/VotingMachineCallbacksInterface.sol
268 
269 pragma solidity ^0.5.4;
270 
271 
272 interface VotingMachineCallbacksInterface {
273     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
274     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
275 
276     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
277     external
278     returns(bool);
279 
280     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
281     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
282     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
283 }
284 
285 // File: contracts/votingMachines/ProposalExecuteInterface.sol
286 
287 pragma solidity ^0.5.4;
288 
289 interface ProposalExecuteInterface {
290     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
291 }
292 
293 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
294 
295 pragma solidity ^0.5.0;
296 
297 /**
298  * @title SafeMath
299  * @dev Unsigned math operations with safety checks that revert on error
300  */
301 library SafeMath {
302     /**
303     * @dev Multiplies two unsigned integers, reverts on overflow.
304     */
305     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
306         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
307         // benefit is lost if 'b' is also tested.
308         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
309         if (a == 0) {
310             return 0;
311         }
312 
313         uint256 c = a * b;
314         require(c / a == b);
315 
316         return c;
317     }
318 
319     /**
320     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
321     */
322     function div(uint256 a, uint256 b) internal pure returns (uint256) {
323         // Solidity only automatically asserts when dividing by 0
324         require(b > 0);
325         uint256 c = a / b;
326         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
327 
328         return c;
329     }
330 
331     /**
332     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
333     */
334     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
335         require(b <= a);
336         uint256 c = a - b;
337 
338         return c;
339     }
340 
341     /**
342     * @dev Adds two unsigned integers, reverts on overflow.
343     */
344     function add(uint256 a, uint256 b) internal pure returns (uint256) {
345         uint256 c = a + b;
346         require(c >= a);
347 
348         return c;
349     }
350 
351     /**
352     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
353     * reverts when dividing by zero.
354     */
355     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
356         require(b != 0);
357         return a % b;
358     }
359 }
360 
361 // File: openzeppelin-solidity/contracts/math/Math.sol
362 
363 pragma solidity ^0.5.0;
364 
365 /**
366  * @title Math
367  * @dev Assorted math operations
368  */
369 library Math {
370     /**
371     * @dev Returns the largest of two numbers.
372     */
373     function max(uint256 a, uint256 b) internal pure returns (uint256) {
374         return a >= b ? a : b;
375     }
376 
377     /**
378     * @dev Returns the smallest of two numbers.
379     */
380     function min(uint256 a, uint256 b) internal pure returns (uint256) {
381         return a < b ? a : b;
382     }
383 
384     /**
385     * @dev Calculates the average of two numbers. Since these are integers,
386     * averages of an even and odd number cannot be represented, and will be
387     * rounded down.
388     */
389     function average(uint256 a, uint256 b) internal pure returns (uint256) {
390         // (a + b) / 2 can overflow, so we distribute
391         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
392     }
393 }
394 
395 // File: openzeppelin-solidity/contracts/utils/Address.sol
396 
397 pragma solidity ^0.5.0;
398 
399 /**
400  * Utility library of inline functions on addresses
401  */
402 library Address {
403     /**
404      * Returns whether the target address is a contract
405      * @dev This function will return false if invoked during the constructor of a contract,
406      * as the code is not actually created until after the constructor finishes.
407      * @param account address of the account to check
408      * @return whether the target address is a contract
409      */
410     function isContract(address account) internal view returns (bool) {
411         uint256 size;
412         // XXX Currently there is no better way to check if there is a contract in an address
413         // than to check the size of the code at that address.
414         // See https://ethereum.stackexchange.com/a/14016/36603
415         // for more details about how this works.
416         // TODO Check this again before the Serenity release, because all addresses will be
417         // contracts then.
418         // solhint-disable-next-line no-inline-assembly
419         assembly { size := extcodesize(account) }
420         return size > 0;
421     }
422 }
423 
424 // File: contracts/votingMachines/GenesisProtocolLogic.sol
425 
426 pragma solidity ^0.5.4;
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 /**
439  * @title GenesisProtocol implementation -an organization's voting machine scheme.
440  */
441 contract GenesisProtocolLogic is IntVoteInterface {
442     using SafeMath for uint256;
443     using Math for uint256;
444     using RealMath for uint216;
445     using RealMath for uint256;
446     using Address for address;
447 
448     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
449     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
450 
451     //Organization's parameters
452     struct Parameters {
453         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
454         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
455         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
456         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
457                                           //to be in an preparation state (stable) before boosted.
458         uint256 thresholdConst; //constant  for threshold calculation .
459                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
460         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
461                                    //in the threshold calculation to prevent overflow
462         uint256 quietEndingPeriod; //quite ending period
463         uint256 proposingRepReward;//proposer reputation reward.
464         uint256 votersReputationLossRatio;//Unsuccessful pre booster
465                                           //voters lose votersReputationLossRatio% of their reputation.
466         uint256 minimumDaoBounty;
467         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
468                                //(daoBountyConst * averageBoostDownstakes)/100 .
469         uint256 activationTime;//the point in time after which proposals can be created.
470         //if this address is set so only this address is allowed to vote of behalf of someone else.
471         address voteOnBehalf;
472     }
473 
474     struct Voter {
475         uint256 vote; // YES(1) ,NO(2)
476         uint256 reputation; // amount of voter's reputation
477         bool preBoosted;
478     }
479 
480     struct Staker {
481         uint256 vote; // YES(1) ,NO(2)
482         uint256 amount; // amount of staker's stake
483         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
484     }
485 
486     struct Proposal {
487         bytes32 organizationId; // the organization unique identifier the proposal is target to.
488         address callbacks;    // should fulfill voting callbacks interface.
489         ProposalState state;
490         uint256 winningVote; //the winning vote.
491         address proposer;
492         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
493         uint256 currentBoostedVotePeriodLimit;
494         bytes32 paramsHash;
495         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
496         uint256 daoBounty;
497         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
498         uint256 confidenceThreshold;
499         //The percentage from upper stakes which the caller for the expiration was given.
500         uint256 expirationCallBountyPercentage;
501         uint[3] times; //times[0] - submittedTime
502                        //times[1] - boostedPhaseTime
503                        //times[2] -preBoostedPhaseTime;
504         bool daoRedeemItsWinnings;
505         //      vote      reputation
506         mapping(uint256   =>  uint256    ) votes;
507         //      vote      reputation
508         mapping(uint256   =>  uint256    ) preBoostedVotes;
509         //      address     voter
510         mapping(address =>  Voter    ) voters;
511         //      vote        stakes
512         mapping(uint256   =>  uint256    ) stakes;
513         //      address  staker
514         mapping(address  => Staker   ) stakers;
515     }
516 
517     event Stake(bytes32 indexed _proposalId,
518         address indexed _organization,
519         address indexed _staker,
520         uint256 _vote,
521         uint256 _amount
522     );
523 
524     event Redeem(bytes32 indexed _proposalId,
525         address indexed _organization,
526         address indexed _beneficiary,
527         uint256 _amount
528     );
529 
530     event RedeemDaoBounty(bytes32 indexed _proposalId,
531         address indexed _organization,
532         address indexed _beneficiary,
533         uint256 _amount
534     );
535 
536     event RedeemReputation(bytes32 indexed _proposalId,
537         address indexed _organization,
538         address indexed _beneficiary,
539         uint256 _amount
540     );
541 
542     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
543     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
544     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
545     event ConfidenceLevelChange(bytes32 indexed _proposalId, uint256 _confidenceThreshold);
546 
547     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
548     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
549     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
550            //organizationId => organization
551     mapping(bytes32        => address     ) public organizations;
552           //organizationId => averageBoostDownstakes
553     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
554     uint256 constant public NUM_OF_CHOICES = 2;
555     uint256 constant public NO = 2;
556     uint256 constant public YES = 1;
557     uint256 public proposalsCnt; // Total number of proposals
558     IERC20 public stakingToken;
559     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
560     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
561 
562     /**
563      * @dev Constructor
564      */
565     constructor(IERC20 _stakingToken) public {
566       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
567       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
568       //If such contract address does not exist in the network (e.g ganache)
569       //the contract will use the _stakingToken param as the
570       //staking token address.
571         if (address(GEN_TOKEN_ADDRESS).isContract()) {
572             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
573         } else {
574             stakingToken = _stakingToken;
575         }
576     }
577 
578   /**
579    * @dev Check that the proposal is votable
580    * a proposal is votable if it is in one of the following states:
581    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
582    */
583     modifier votable(bytes32 _proposalId) {
584         require(_isVotable(_proposalId));
585         _;
586     }
587 
588     /**
589      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
590      * generated by calculating keccak256 of a incremented counter.
591      * @param _paramsHash parameters hash
592      * @param _proposer address
593      * @param _organization address
594      */
595     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
596         external
597         returns(bytes32)
598     {
599       // solhint-disable-next-line not-rely-on-time
600         require(now > parameters[_paramsHash].activationTime, "not active yet");
601         //Check parameters existence.
602         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
603         // Generate a unique ID:
604         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
605         proposalsCnt = proposalsCnt.add(1);
606          // Open proposal:
607         Proposal memory proposal;
608         proposal.callbacks = msg.sender;
609         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
610 
611         proposal.state = ProposalState.Queued;
612         // solhint-disable-next-line not-rely-on-time
613         proposal.times[0] = now;//submitted time
614         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
615         proposal.proposer = _proposer;
616         proposal.winningVote = NO;
617         proposal.paramsHash = _paramsHash;
618         if (organizations[proposal.organizationId] == address(0)) {
619             if (_organization == address(0)) {
620                 organizations[proposal.organizationId] = msg.sender;
621             } else {
622                 organizations[proposal.organizationId] = _organization;
623             }
624         }
625         //calc dao bounty
626         uint256 daoBounty =
627         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
628         if (daoBounty < parameters[_paramsHash].minimumDaoBounty) {
629             proposal.daoBountyRemain = parameters[_paramsHash].minimumDaoBounty;
630         } else {
631             proposal.daoBountyRemain = daoBounty;
632         }
633         proposal.totalStakes = proposal.daoBountyRemain;
634         proposals[proposalId] = proposal;
635         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
636 
637         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
638         return proposalId;
639     }
640 
641     /**
642       * @dev executeBoosted try to execute a boosted or QuietEndingPeriod proposal if it is expired
643       * @param _proposalId the id of the proposal
644       * @return uint256 expirationCallBounty the bounty amount for the expiration call
645      */
646     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
647         Proposal storage proposal = proposals[_proposalId];
648         require(proposal.state == ProposalState.Boosted || proposal.state == ProposalState.QuietEndingPeriod,
649         "proposal state in not Boosted nor QuietEndingPeriod");
650         require(_execute(_proposalId), "proposal need to expire");
651         uint256 expirationCallBountyPercentage =
652         // solhint-disable-next-line not-rely-on-time
653         (uint(1).add(now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1])).div(15)));
654         if (expirationCallBountyPercentage > 100) {
655             expirationCallBountyPercentage = 100;
656         }
657         proposal.expirationCallBountyPercentage = expirationCallBountyPercentage;
658         expirationCallBounty = expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100);
659         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
660         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
661     }
662 
663     /**
664      * @dev hash the parameters, save them if necessary, and return the hash value
665      * @param _params a parameters array
666      *    _params[0] - _queuedVoteRequiredPercentage,
667      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
668      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
669      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
670      *                  state (stable) before boosted.
671      *    _params[4] -_thresholdConst
672      *    _params[5] -_quietEndingPeriod
673      *    _params[6] -_proposingRepReward
674      *    _params[7] -_votersReputationLossRatio
675      *    _params[8] -_minimumDaoBounty
676      *    _params[9] -_daoBountyConst
677      *    _params[10] -_activationTime
678      * @param _voteOnBehalf - authorized to vote on behalf of others.
679     */
680     function setParameters(
681         uint[11] calldata _params, //use array here due to stack too deep issue.
682         address _voteOnBehalf
683     )
684     external
685     returns(bytes32)
686     {
687         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
688         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
689         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
690         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
691         require(_params[8] > 0, "minimumDaoBounty should be > 0");
692         require(_params[9] > 0, "daoBountyConst should be > 0");
693 
694         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
695         //set a limit for power for a given alpha to prevent overflow
696         uint256 limitExponent = 172;//for alpha less or equal 2
697         uint256 j = 2;
698         for (uint256 i = 2000; i < 16000; i = i*2) {
699             if ((_params[4] > i) && (_params[4] <= i*2)) {
700                 limitExponent = limitExponent/j;
701                 break;
702             }
703             j++;
704         }
705 
706         parameters[paramsHash] = Parameters({
707             queuedVoteRequiredPercentage: _params[0],
708             queuedVotePeriodLimit: _params[1],
709             boostedVotePeriodLimit: _params[2],
710             preBoostedVotePeriodLimit: _params[3],
711             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
712             limitExponentValue:limitExponent,
713             quietEndingPeriod: _params[5],
714             proposingRepReward: _params[6],
715             votersReputationLossRatio:_params[7],
716             minimumDaoBounty:_params[8],
717             daoBountyConst:_params[9],
718             activationTime:_params[10],
719             voteOnBehalf:_voteOnBehalf
720         });
721         return paramsHash;
722     }
723 
724     /**
725      * @dev redeem a reward for a successful stake, vote or proposing.
726      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
727      * users to redeem on behalf of someone else.
728      * @param _proposalId the ID of the proposal
729      * @param _beneficiary - the beneficiary address
730      * @return rewards -
731      *           [0] stakerTokenReward
732      *           [1] voterReputationReward
733      *           [2] proposerReputationReward
734      */
735      // solhint-disable-next-line function-max-lines,code-complexity
736     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
737         Proposal storage proposal = proposals[_proposalId];
738         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
739         "Proposal should be Executed or ExpiredInQueue");
740         Parameters memory params = parameters[proposal.paramsHash];
741         uint256 lostReputation;
742         if (proposal.winningVote == YES) {
743             lostReputation = proposal.preBoostedVotes[NO];
744         } else {
745             lostReputation = proposal.preBoostedVotes[YES];
746         }
747         lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
748         //as staker
749         Staker storage staker = proposal.stakers[_beneficiary];
750         uint256 totalStakes = proposal.stakes[NO].add(proposal.stakes[YES]);
751         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
752 
753         if (staker.amount > 0) {
754             uint256 totalStakesLeftAfterCallBounty =
755             totalStakes.sub(proposal.expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100));
756             if (proposal.state == ProposalState.ExpiredInQueue) {
757                 //Stakes of a proposal that expires in Queue are sent back to stakers
758                 rewards[0] = staker.amount;
759             } else if (staker.vote == proposal.winningVote) {
760                 if (staker.vote == YES) {
761                     if (proposal.daoBounty < totalStakesLeftAfterCallBounty) {
762                         uint256 _totalStakes = totalStakesLeftAfterCallBounty.sub(proposal.daoBounty);
763                         rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
764                     }
765                 } else {
766                     rewards[0] = (staker.amount.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes;
767                 }
768             }
769             staker.amount = 0;
770         }
771             //dao redeem its winnings
772         if (proposal.daoRedeemItsWinnings == false &&
773             _beneficiary == organizations[proposal.organizationId] &&
774             proposal.state != ProposalState.ExpiredInQueue &&
775             proposal.winningVote == NO) {
776             rewards[0] =
777             rewards[0].add((proposal.daoBounty.mul(totalStakes))/totalWinningStakes).sub(proposal.daoBounty);
778             proposal.daoRedeemItsWinnings = true;
779         }
780 
781         //as voter
782         Voter storage voter = proposal.voters[_beneficiary];
783         if ((voter.reputation != 0) && (voter.preBoosted)) {
784             if (proposal.state == ProposalState.ExpiredInQueue) {
785               //give back reputation for the voter
786                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
787             } else if (proposal.winningVote == voter.vote) {
788                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
789                 .add((voter.reputation.mul(lostReputation))/proposal.preBoostedVotes[proposal.winningVote]);
790             }
791             voter.reputation = 0;
792         }
793         //as proposer
794         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
795             rewards[2] = params.proposingRepReward;
796             proposal.proposer = address(0);
797         }
798         if (rewards[0] != 0) {
799             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
800             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
801             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
802         }
803         if (rewards[1].add(rewards[2]) != 0) {
804             VotingMachineCallbacksInterface(proposal.callbacks)
805             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
806             emit RedeemReputation(
807             _proposalId,
808             organizations[proposal.organizationId],
809             _beneficiary,
810             rewards[1].add(rewards[2])
811             );
812         }
813     }
814 
815     /**
816      * @dev redeemDaoBounty a reward for a successful stake.
817      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
818      * users to redeem on behalf of someone else.
819      * @param _proposalId the ID of the proposal
820      * @param _beneficiary - the beneficiary address
821      * @return redeemedAmount - redeem token amount
822      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
823      */
824     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
825     public
826     returns(uint256 redeemedAmount, uint256 potentialAmount) {
827         Proposal storage proposal = proposals[_proposalId];
828         require(proposal.state == ProposalState.Executed);
829         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
830         Staker storage staker = proposal.stakers[_beneficiary];
831         if (
832             (staker.amount4Bounty > 0)&&
833             (staker.vote == proposal.winningVote)&&
834             (proposal.winningVote == YES)&&
835             (totalWinningStakes != 0)) {
836             //as staker
837                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
838             }
839         if ((potentialAmount != 0)&&
840             (VotingMachineCallbacksInterface(proposal.callbacks)
841             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
842             staker.amount4Bounty = 0;
843             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
844             require(
845             VotingMachineCallbacksInterface(proposal.callbacks)
846             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
847             redeemedAmount = potentialAmount;
848             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
849         }
850     }
851 
852     /**
853      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
854      * @param _proposalId the ID of the proposal
855      * @return bool true or false.
856      */
857     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
858         Proposal memory proposal = proposals[_proposalId];
859         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
860     }
861 
862     /**
863      * @dev threshold return the organization's score threshold which required by
864      * a proposal to shift to boosted state.
865      * This threshold is dynamically set and it depend on the number of boosted proposal.
866      * @param _organizationId the organization identifier
867      * @param _paramsHash the organization parameters hash
868      * @return uint256 organization's score threshold as real number.
869      */
870     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
871         uint256 power = orgBoostedProposalsCnt[_organizationId];
872         Parameters storage params = parameters[_paramsHash];
873 
874         if (power > params.limitExponentValue) {
875             power = params.limitExponentValue;
876         }
877 
878         return params.thresholdConst.pow(power);
879     }
880 
881   /**
882    * @dev hashParameters returns a hash of the given parameters
883    */
884     function getParametersHash(
885         uint[11] memory _params,//use array here due to stack too deep issue.
886         address _voteOnBehalf
887     )
888         public
889         pure
890         returns(bytes32)
891         {
892         //double call to keccak256 to avoid deep stack issue when call with too many params.
893         return keccak256(
894             abi.encodePacked(
895             keccak256(
896             abi.encodePacked(
897                 _params[0],
898                 _params[1],
899                 _params[2],
900                 _params[3],
901                 _params[4],
902                 _params[5],
903                 _params[6],
904                 _params[7],
905                 _params[8],
906                 _params[9],
907                 _params[10])
908             ),
909             _voteOnBehalf
910         ));
911     }
912 
913     /**
914       * @dev execute check if the proposal has been decided, and if so, execute the proposal
915       * @param _proposalId the id of the proposal
916       * @return bool true - the proposal has been executed
917       *              false - otherwise.
918      */
919      // solhint-disable-next-line function-max-lines,code-complexity
920     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
921         Proposal storage proposal = proposals[_proposalId];
922         Parameters memory params = parameters[proposal.paramsHash];
923         Proposal memory tmpProposal = proposal;
924         uint256 totalReputation =
925         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
926         //first divide by 100 to prevent overflow
927         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
928         ExecutionState executionState = ExecutionState.None;
929         uint256 averageDownstakesOfBoosted;
930         uint256 confidenceThreshold;
931 
932         if (proposal.votes[proposal.winningVote] > executionBar) {
933          // someone crossed the absolute vote execution bar.
934             if (proposal.state == ProposalState.Queued) {
935                 executionState = ExecutionState.QueueBarCrossed;
936             } else if (proposal.state == ProposalState.PreBoosted) {
937                 executionState = ExecutionState.PreBoostedBarCrossed;
938             } else {
939                 executionState = ExecutionState.BoostedBarCrossed;
940             }
941             proposal.state = ProposalState.Executed;
942         } else {
943             if (proposal.state == ProposalState.Queued) {
944                 // solhint-disable-next-line not-rely-on-time
945                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
946                     proposal.state = ProposalState.ExpiredInQueue;
947                     proposal.winningVote = NO;
948                     executionState = ExecutionState.QueueTimeOut;
949                 } else {
950                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
951                     if (_score(_proposalId) > confidenceThreshold) {
952                         //change proposal mode to PreBoosted mode.
953                         proposal.state = ProposalState.PreBoosted;
954                         // solhint-disable-next-line not-rely-on-time
955                         proposal.times[2] = now;
956                         proposal.confidenceThreshold = confidenceThreshold;
957                     }
958                 }
959             }
960 
961             if (proposal.state == ProposalState.PreBoosted) {
962                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
963               // solhint-disable-next-line not-rely-on-time
964                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
965                     if (_score(_proposalId) > confidenceThreshold) {
966                         if (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS) {
967                          //change proposal mode to Boosted mode.
968                             proposal.state = ProposalState.Boosted;
969                          // solhint-disable-next-line not-rely-on-time
970                             proposal.times[1] = now;
971                             orgBoostedProposalsCnt[proposal.organizationId]++;
972                          //add a value to average -> average = average + ((value - average) / nbValues)
973                             averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
974                           // solium-disable-next-line indentation
975                             averagesDownstakesOfBoosted[proposal.organizationId] =
976                                 uint256(int256(averageDownstakesOfBoosted) +
977                                 ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
978                                 int256(orgBoostedProposalsCnt[proposal.organizationId])));
979                         }
980                     } else {
981                         proposal.state = ProposalState.Queued;
982                     }
983                 } else { //check the Confidence level is stable
984                     uint256 proposalScore = _score(_proposalId);
985                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
986                         proposal.state = ProposalState.Queued;
987                     } else if (proposal.confidenceThreshold > proposalScore) {
988                         proposal.confidenceThreshold = confidenceThreshold;
989                         emit ConfidenceLevelChange(_proposalId, confidenceThreshold);
990                     }
991                 }
992             }
993         }
994 
995         if ((proposal.state == ProposalState.Boosted) ||
996             (proposal.state == ProposalState.QuietEndingPeriod)) {
997             // solhint-disable-next-line not-rely-on-time
998             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
999                 proposal.state = ProposalState.Executed;
1000                 executionState = ExecutionState.BoostedTimeOut;
1001             }
1002         }
1003 
1004         if (executionState != ExecutionState.None) {
1005             if ((executionState == ExecutionState.BoostedTimeOut) ||
1006                 (executionState == ExecutionState.BoostedBarCrossed)) {
1007                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
1008                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1009                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
1010                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1011                 if (boostedProposals == 0) {
1012                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1013                 } else {
1014                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1015                     averagesDownstakesOfBoosted[proposal.organizationId] =
1016                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1017                 }
1018             }
1019             emit ExecuteProposal(
1020             _proposalId,
1021             organizations[proposal.organizationId],
1022             proposal.winningVote,
1023             totalReputation
1024             );
1025             emit GPExecuteProposal(_proposalId, executionState);
1026             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1027             proposal.daoBounty = proposal.daoBountyRemain;
1028         }
1029         if (tmpProposal.state != proposal.state) {
1030             emit StateChange(_proposalId, proposal.state);
1031         }
1032         return (executionState != ExecutionState.None);
1033     }
1034 
1035     /**
1036      * @dev staking function
1037      * @param _proposalId id of the proposal
1038      * @param _vote  NO(2) or YES(1).
1039      * @param _amount the betting amount
1040      * @return bool true - the proposal has been executed
1041      *              false - otherwise.
1042      */
1043     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1044         // 0 is not a valid vote.
1045         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1046         require(_amount > 0, "staking amount should be >0");
1047 
1048         if (_execute(_proposalId)) {
1049             return true;
1050         }
1051         Proposal storage proposal = proposals[_proposalId];
1052 
1053         if ((proposal.state != ProposalState.PreBoosted) &&
1054             (proposal.state != ProposalState.Queued)) {
1055             return false;
1056         }
1057 
1058         // enable to increase stake only on the previous stake vote
1059         Staker storage staker = proposal.stakers[_staker];
1060         if ((staker.amount > 0) && (staker.vote != _vote)) {
1061             return false;
1062         }
1063 
1064         uint256 amount = _amount;
1065         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1066         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1067         staker.amount = staker.amount.add(amount);
1068         //This is to prevent average downstakes calculation overflow
1069         //Note that any how GEN cap is 100000000 ether.
1070         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1071         require(proposal.totalStakes <= 0x100000000000000000000000000000000, "total stakes is too high");
1072 
1073         if (_vote == YES) {
1074             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1075         }
1076         staker.vote = _vote;
1077 
1078         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1079         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1080         return _execute(_proposalId);
1081     }
1082 
1083     /**
1084      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1085      * @param _proposalId id of the proposal
1086      * @param _voter used in case the vote is cast for someone else
1087      * @param _vote a value between 0 to and the proposal's number of choices.
1088      * @param _rep how many reputation the voter would like to stake for this vote.
1089      *         if  _rep==0 so the voter full reputation will be use.
1090      * @return true in case of proposal execution otherwise false
1091      * throws if proposal is not open or if it has been executed
1092      * NB: executes the proposal if a decision has been reached
1093      */
1094      // solhint-disable-next-line function-max-lines,code-complexity
1095     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1096         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1097         if (_execute(_proposalId)) {
1098             return true;
1099         }
1100 
1101         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1102         Proposal storage proposal = proposals[_proposalId];
1103 
1104         // Check voter has enough reputation:
1105         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
1106         require(reputation > 0, "_voter must have reputation");
1107         require(reputation >= _rep, "reputation >= _rep");
1108         uint256 rep = _rep;
1109         if (rep == 0) {
1110             rep = reputation;
1111         }
1112         // If this voter has already voted, return false.
1113         if (proposal.voters[_voter].reputation != 0) {
1114             return false;
1115         }
1116         // The voting itself:
1117         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
1118         //check if the current winningVote changed or there is a tie.
1119         //for the case there is a tie the current winningVote set to NO.
1120         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
1121             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
1122             proposal.winningVote == YES)) {
1123             if (proposal.state == ProposalState.Boosted &&
1124             // solhint-disable-next-line not-rely-on-time
1125                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
1126                 proposal.state == ProposalState.QuietEndingPeriod) {
1127                 //quietEndingPeriod
1128                 if (proposal.state != ProposalState.QuietEndingPeriod) {
1129                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
1130                     proposal.state = ProposalState.QuietEndingPeriod;
1131                 }
1132                 // solhint-disable-next-line not-rely-on-time
1133                 proposal.times[1] = now;
1134             }
1135             proposal.winningVote = _vote;
1136         }
1137         proposal.voters[_voter] = Voter({
1138             reputation: rep,
1139             vote: _vote,
1140             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
1141         });
1142         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
1143             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
1144             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
1145             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
1146         }
1147         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
1148         return _execute(_proposalId);
1149     }
1150 
1151     /**
1152      * @dev _score return the proposal score (Confidence level)
1153      * For dual choice proposal S = (S+)/(S-)
1154      * @param _proposalId the ID of the proposal
1155      * @return uint256 proposal score as real number.
1156      */
1157     function _score(bytes32 _proposalId) internal view returns(uint256) {
1158         Proposal storage proposal = proposals[_proposalId];
1159         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
1160         return uint216(proposal.stakes[YES]).fraction(uint216(proposal.stakes[NO]));
1161     }
1162 
1163     /**
1164       * @dev _isVotable check if the proposal is votable
1165       * @param _proposalId the ID of the proposal
1166       * @return bool true or false
1167     */
1168     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
1169         ProposalState pState = proposals[_proposalId].state;
1170         return ((pState == ProposalState.PreBoosted)||
1171                 (pState == ProposalState.Boosted)||
1172                 (pState == ProposalState.QuietEndingPeriod)||
1173                 (pState == ProposalState.Queued)
1174         );
1175     }
1176 }
1177 
1178 // File: contracts/votingMachines/GenesisProtocol.sol
1179 
1180 pragma solidity ^0.5.4;
1181 
1182 
1183 
1184 
1185 /**
1186  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1187  */
1188 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
1189     using ECDSA for bytes32;
1190 
1191     // Digest describing the data the user signs according EIP 712.
1192     // Needs to match what is passed to Metamask.
1193     bytes32 public constant DELEGATION_HASH_EIP712 =
1194     keccak256(abi.encodePacked(
1195     "address GenesisProtocolAddress",
1196     "bytes32 ProposalId",
1197     "uint256 Vote",
1198     "uint256 AmountToStake",
1199     "uint256 Nonce"
1200     ));
1201 
1202     mapping(address=>uint256) public stakesNonce; //stakes Nonce
1203 
1204     /**
1205      * @dev Constructor
1206      */
1207     constructor(IERC20 _stakingToken)
1208     public
1209     // solhint-disable-next-line no-empty-blocks
1210     GenesisProtocolLogic(_stakingToken) {
1211     }
1212 
1213     /**
1214      * @dev staking function
1215      * @param _proposalId id of the proposal
1216      * @param _vote  NO(2) or YES(1).
1217      * @param _amount the betting amount
1218      * @return bool true - the proposal has been executed
1219      *              false - otherwise.
1220      */
1221     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
1222         return _stake(_proposalId, _vote, _amount, msg.sender);
1223     }
1224 
1225     /**
1226      * @dev stakeWithSignature function
1227      * @param _proposalId id of the proposal
1228      * @param _vote  NO(2) or YES(1).
1229      * @param _amount the betting amount
1230      * @param _nonce nonce value ,it is part of the signature to ensure that
1231               a signature can be received only once.
1232      * @param _signatureType signature type
1233               1 - for web3.eth.sign
1234               2 - for eth_signTypedData according to EIP #712.
1235      * @param _signature  - signed data by the staker
1236      * @return bool true - the proposal has been executed
1237      *              false - otherwise.
1238      */
1239     function stakeWithSignature(
1240         bytes32 _proposalId,
1241         uint256 _vote,
1242         uint256 _amount,
1243         uint256 _nonce,
1244         uint256 _signatureType,
1245         bytes calldata _signature
1246         )
1247         external
1248         returns(bool)
1249         {
1250         // Recreate the digest the user signed
1251         bytes32 delegationDigest;
1252         if (_signatureType == 2) {
1253             delegationDigest = keccak256(
1254                 abi.encodePacked(
1255                     DELEGATION_HASH_EIP712, keccak256(
1256                         abi.encodePacked(
1257                         address(this),
1258                         _proposalId,
1259                         _vote,
1260                         _amount,
1261                         _nonce)
1262                     )
1263                 )
1264             );
1265         } else {
1266             delegationDigest = keccak256(
1267                         abi.encodePacked(
1268                         address(this),
1269                         _proposalId,
1270                         _vote,
1271                         _amount,
1272                         _nonce)
1273                     ).toEthSignedMessageHash();
1274         }
1275         address staker = delegationDigest.recover(_signature);
1276         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
1277         require(staker != address(0), "staker address cannot be 0");
1278         require(stakesNonce[staker] == _nonce);
1279         stakesNonce[staker] = stakesNonce[staker].add(1);
1280         return _stake(_proposalId, _vote, _amount, staker);
1281     }
1282 
1283     /**
1284      * @dev voting function
1285      * @param _proposalId id of the proposal
1286      * @param _vote NO(2) or YES(1).
1287      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
1288      * @param _voter voter address
1289      * @return bool true - the proposal has been executed
1290      *              false - otherwise.
1291      */
1292     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
1293     external
1294     votable(_proposalId)
1295     returns(bool) {
1296         Proposal storage proposal = proposals[_proposalId];
1297         Parameters memory params = parameters[proposal.paramsHash];
1298         address voter;
1299         if (params.voteOnBehalf != address(0)) {
1300             require(msg.sender == params.voteOnBehalf);
1301             voter = _voter;
1302         } else {
1303             voter = msg.sender;
1304         }
1305         return internalVote(_proposalId, voter, _vote, _amount);
1306     }
1307 
1308   /**
1309    * @dev Cancel the vote of the msg.sender.
1310    * cancel vote is not allow in genesisProtocol so this function doing nothing.
1311    * This function is here in order to comply to the IntVoteInterface .
1312    */
1313     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
1314        //this is not allowed
1315         return;
1316     }
1317 
1318     /**
1319       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1320       * @param _proposalId the id of the proposal
1321       * @return bool true - the proposal has been executed
1322       *              false - otherwise.
1323      */
1324     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
1325         return _execute(_proposalId);
1326     }
1327 
1328   /**
1329     * @dev getNumberOfChoices returns the number of choices possible in this proposal
1330     * @return uint256 that contains number of choices
1331     */
1332     function getNumberOfChoices(bytes32) external view returns(uint256) {
1333         return NUM_OF_CHOICES;
1334     }
1335 
1336     /**
1337       * @dev getProposalTimes returns proposals times variables.
1338       * @param _proposalId id of the proposal
1339       * @return proposals times array
1340       */
1341     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
1342         return proposals[_proposalId].times;
1343     }
1344 
1345     /**
1346      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
1347      * @param _proposalId the ID of the proposal
1348      * @param _voter the address of the voter
1349      * @return uint256 vote - the voters vote
1350      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
1351      */
1352     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
1353         Voter memory voter = proposals[_proposalId].voters[_voter];
1354         return (voter.vote, voter.reputation);
1355     }
1356 
1357     /**
1358     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
1359     * @param _proposalId the ID of the proposal
1360     * @param _choice the index in the
1361     * @return voted reputation for the given choice
1362     */
1363     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
1364         return proposals[_proposalId].votes[_choice];
1365     }
1366 
1367     /**
1368     * @dev isVotable check if the proposal is votable
1369     * @param _proposalId the ID of the proposal
1370     * @return bool true or false
1371     */
1372     function isVotable(bytes32 _proposalId) external view returns(bool) {
1373         return _isVotable(_proposalId);
1374     }
1375 
1376     /**
1377     * @dev proposalStatus return the total votes and stakes for a given proposal
1378     * @param _proposalId the ID of the proposal
1379     * @return uint256 preBoostedVotes YES
1380     * @return uint256 preBoostedVotes NO
1381     * @return uint256 total stakes YES
1382     * @return uint256 total stakes NO
1383     */
1384     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
1385         return (
1386                 proposals[_proposalId].preBoostedVotes[YES],
1387                 proposals[_proposalId].preBoostedVotes[NO],
1388                 proposals[_proposalId].stakes[YES],
1389                 proposals[_proposalId].stakes[NO]
1390         );
1391     }
1392 
1393   /**
1394     * @dev getProposalOrganization return the organizationId for a given proposal
1395     * @param _proposalId the ID of the proposal
1396     * @return bytes32 organization identifier
1397     */
1398     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
1399         return (proposals[_proposalId].organizationId);
1400     }
1401 
1402     /**
1403       * @dev getStaker return the vote and stake amount for a given proposal and staker
1404       * @param _proposalId the ID of the proposal
1405       * @param _staker staker address
1406       * @return uint256 vote
1407       * @return uint256 amount
1408     */
1409     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
1410         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
1411     }
1412 
1413     /**
1414       * @dev voteStake return the amount stakes for a given proposal and vote
1415       * @param _proposalId the ID of the proposal
1416       * @param _vote vote number
1417       * @return uint256 stake amount
1418     */
1419     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
1420         return proposals[_proposalId].stakes[_vote];
1421     }
1422 
1423   /**
1424     * @dev voteStake return the winningVote for a given proposal
1425     * @param _proposalId the ID of the proposal
1426     * @return uint256 winningVote
1427     */
1428     function winningVote(bytes32 _proposalId) external view returns(uint256) {
1429         return proposals[_proposalId].winningVote;
1430     }
1431 
1432     /**
1433       * @dev voteStake return the state for a given proposal
1434       * @param _proposalId the ID of the proposal
1435       * @return ProposalState proposal state
1436     */
1437     function state(bytes32 _proposalId) external view returns(ProposalState) {
1438         return proposals[_proposalId].state;
1439     }
1440 
1441    /**
1442     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
1443     * @return bool true or false
1444     */
1445     function isAbstainAllow() external pure returns(bool) {
1446         return false;
1447     }
1448 
1449     /**
1450      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
1451      * @return min - minimum number of choices
1452                max - maximum number of choices
1453      */
1454     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
1455         return (YES, NO);
1456     }
1457 
1458     /**
1459      * @dev score return the proposal score
1460      * @param _proposalId the ID of the proposal
1461      * @return uint256 proposal score.
1462      */
1463     function score(bytes32 _proposalId) public view returns(uint256) {
1464         return  _score(_proposalId);
1465     }
1466 }
