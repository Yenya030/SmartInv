1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/council/simpleProxy.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\ncontract SimpleProxy {\n    // This contract splits the storage of a contract from its logic, it will\n    // call an implementation contract via delegatecall. That implementation\n    // changes what is stored in this contract, by changing the implementation\n    // address this contract effectively has different logic.\n\n    // NOTE - Functions 'upgradeProxy', 'resetProxyOwner', 'proxyImplementation' and 'proxyGovernance'\n    // are occupied namespace and cannot be used in implementation contracts. In a very unlikely\n    // edge case a 4 bit hash collision between function selectors could block other function names.\n\n    // The implementation contains the logic for this proxy, it for security reasons\n    // should not assume only this contract can call it.\n    // NOTE - It's insecure in implementation proxies to use the default storage layout since\n    //        it is possible to overwrite this address. Use Storage.sol for storage.\n    address public proxyImplementation;\n    // The address which can upgrade this contract\n    address public proxyGovernance;\n\n    /// @notice Sets up the authorizable library for the proxy\n    /// @param _governance An address which will be authorized to change the implementation\n    ///                    it will also be set at the owner of this contract.\n    /// @param _firstImplementation The first implementation address\n    constructor(address _governance, address _firstImplementation) {\n        // Set governance\n        proxyGovernance = _governance;\n        // Set the first implementation\n        proxyImplementation = _firstImplementation;\n    }\n\n    /// @notice Allows authorized addresses to change the implementation\n    /// @param _newImplementation The new implementation address\n    function upgradeProxy(address _newImplementation) external {\n        require(msg.sender == proxyGovernance, \"unauthorized\");\n        proxyImplementation = _newImplementation;\n    }\n\n    /// @notice Sets the address which can upgrade this proxy, only callable\n    ///         by the current address which can upgrade this proxy.\n    /// @param _newGovernance The new governance address\n    function resetProxyOwner(address _newGovernance) external {\n        require(msg.sender == proxyGovernance, \"unauthorized\");\n        proxyGovernance = _newGovernance;\n    }\n\n    /// @notice The fallback is the routing function for the proxy and uses delegatecall\n    ///         to forward any calls which are made to this address to be executed by the\n    ///         logic contract.\n    /// @dev WARNING - We don't do extcode size checks like high level solidity if the\n    ///                implementation has 0 bytecode this will succeed but do nothing.\n    fallback() external payable {\n        assembly {\n            let calldataLength := calldatasize()\n\n            // equivalent to receive() external payable {}\n            if iszero(calldataLength) {\n                return(0, 0)\n            }\n\n            // We load the free memory pointer\n            // Note - We technically don't need to do this because the whole call is\n            // in assembly but it's good practice to match solidity's memory management\n            let ptr := mload(0x40)\n            // Copy the calldata into memory\n            calldatacopy(\n                // The position in memory this copies to\n                ptr,\n                // The calldata index this copies from\n                0,\n                // The number of bytes to copy\n                calldataLength\n            )\n            // Move the free memory pointer\n            mstore(0x40, add(ptr, calldataLength))\n            // Load the implementation address\n            let implementation := sload(proxyImplementation.slot)\n            // It's very unlikely any extra data got loaded but we clean anyway\n            implementation := and(\n                implementation,\n                0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n            )\n            // Now we make the delegatecall\n            let success := delegatecall(\n                // The gas param\n                gas(),\n                // The address\n                implementation,\n                // The memory location of the input data\n                ptr,\n                // The input size\n                calldataLength,\n                // The output memory pointer and size, we use the return data instead\n                0,\n                0\n            )\n            // Load our new free memory pointer\n            ptr := mload(0x40)\n            // Load the return data size\n            let returndataLength := returndatasize()\n            // Copy the return data\n            returndatacopy(\n                // Memory location of the output\n                ptr,\n                // Memory location of the input\n                0,\n                // Length of the input\n                returndataLength\n            )\n            // If the call was not successful we revert\n            if iszero(success) {\n                revert(ptr, returndataLength)\n            }\n\n            // If the call was successful we return\n            return(ptr, returndataLength)\n        }\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 10000
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}