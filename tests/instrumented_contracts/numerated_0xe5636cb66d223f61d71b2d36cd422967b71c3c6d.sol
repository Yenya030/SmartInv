1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 
20 pragma solidity ^0.4.20;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   uint256 public totalSupply;
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
43     if (a == 0) {
44       return 0;
45     }
46     uint256 c = a * b;
47     assert(c / a == b);
48     return c;
49   }
50 
51   function div(uint256 a, uint256 b) internal pure returns (uint256) {
52     // assert(b > 0); // Solidity automatically throws when dividing by 0
53     uint256 c = a / b;
54     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
55     return c;
56   }
57 
58   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
59     assert(b <= a);
60     return a - b;
61   }
62 
63   function add(uint256 a, uint256 b) internal pure returns (uint256) {
64     uint256 c = a + b;
65     assert(c >= a);
66     return c;
67   }
68 }
69 
70 
71 
72 /**
73  * @title Basic token
74  * @dev Basic version of StandardToken, with no allowances.
75  */
76 contract BasicToken is ERC20Basic {
77   using SafeMath for uint256;
78 
79   mapping(address => uint256) balances;
80 
81   /**
82   * @dev transfer token for a specified address
83   * @param _to The address to transfer to.
84   * @param _value The amount to be transferred.
85   */
86   function transfer(address _to, uint256 _value) public returns (bool) {
87     require(_to != address(0));
88     require(_value <= balances[msg.sender]);
89 
90     // SafeMath.sub will throw if there is not enough balance.
91     balances[msg.sender] = balances[msg.sender].sub(_value);
92     balances[_to] = balances[_to].add(_value);
93     Transfer(msg.sender, _to, _value);
94     return true;
95   }
96 
97   /**
98   * @dev Gets the balance of the specified address.
99   * @param _owner The address to query the the balance of.
100   * @return An uint256 representing the amount owned by the passed address.
101   */
102   function balanceOf(address _owner) public view returns (uint256 balance) {
103     return balances[_owner];
104   }
105 
106 }
107 
108 
109 
110 /**
111  * @title ERC20 interface
112  * @dev see https://github.com/ethereum/EIPs/issues/20
113  */
114 contract ERC20 is ERC20Basic {
115   function allowance(address owner, address spender) public view returns (uint256);
116   function transferFrom(address from, address to, uint256 value) public returns (bool);
117   function approve(address spender, uint256 value) public returns (bool);
118   event Approval(address indexed owner, address indexed spender, uint256 value);
119 }
120 
121 
122 
123 /**
124  * @title Standard ERC20 token
125  *
126  * @dev Implementation of the basic standard token.
127  * @dev https://github.com/ethereum/EIPs/issues/20
128  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
129  */
130 contract StandardToken is ERC20, BasicToken {
131 
132   mapping (address => mapping (address => uint256)) internal allowed;
133 
134 
135   /**
136    * @dev Transfer tokens from one address to another
137    * @param _from address The address which you want to send tokens from
138    * @param _to address The address which you want to transfer to
139    * @param _value uint256 the amount of tokens to be transferred
140    */
141   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
142     require(_to != address(0));
143     require(_value <= balances[_from]);
144     require(_value <= allowed[_from][msg.sender]);
145 
146     balances[_from] = balances[_from].sub(_value);
147     balances[_to] = balances[_to].add(_value);
148     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
149     Transfer(_from, _to, _value);
150     return true;
151   }
152 
153   /**
154    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
155    *
156    * Beware that changing an allowance with this method brings the risk that someone may use both the old
157    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
158    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
159    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
160    * @param _spender The address which will spend the funds.
161    * @param _value The amount of tokens to be spent.
162    */
163   function approve(address _spender, uint256 _value) public returns (bool) {
164     allowed[msg.sender][_spender] = _value;
165     Approval(msg.sender, _spender, _value);
166     return true;
167   }
168 
169   /**
170    * @dev Function to check the amount of tokens that an owner allowed to a spender.
171    * @param _owner address The address which owns the funds.
172    * @param _spender address The address which will spend the funds.
173    * @return A uint256 specifying the amount of tokens still available for the spender.
174    */
175   function allowance(address _owner, address _spender) public view returns (uint256) {
176     return allowed[_owner][_spender];
177   }
178 
179   /**
180    * approve should be called when allowed[_spender] == 0. To increment
181    * allowed value is better to use this function to avoid 2 calls (and wait until
182    * the first transaction is mined)
183    * From MonolithDAO Token.sol
184    */
185   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
186     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
187     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
188     return true;
189   }
190 
191   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
192     uint oldValue = allowed[msg.sender][_spender];
193     if (_subtractedValue > oldValue) {
194       allowed[msg.sender][_spender] = 0;
195     } else {
196       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
197     }
198     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
199     return true;
200   }
201 
202 }
203 
204 
205 
206 /**
207  * @title Ownable
208  * @dev The Ownable contract has an owner address, and provides basic authorization control
209  * functions, this simplifies the implementation of "user permissions".
210  */
211 contract Ownable {
212   address public owner;
213 
214 
215   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
216 
217 
218   /**
219    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
220    * account.
221    */
222   function Ownable() public {
223     owner = msg.sender;
224   }
225 
226 
227   /**
228    * @dev Throws if called by any account other than the owner.
229    */
230   modifier onlyOwner() {
231     require(msg.sender == owner);
232     _;
233   }
234 
235 
236   /**
237    * @dev Allows the current owner to transfer control of the contract to a newOwner.
238    * @param newOwner The address to transfer ownership to.
239    */
240   function transferOwnership(address newOwner) public onlyOwner {
241     require(newOwner != address(0));
242     OwnershipTransferred(owner, newOwner);
243     owner = newOwner;
244   }
245 
246 }
247 
248 
249 
250 /**
251  * @title Mintable token
252  * @dev Simple ERC20 Token example, with mintable token creation
253  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
254  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
255  */
256 
257 contract MintableToken is StandardToken, Ownable {
258   event Mint(address indexed to, uint256 amount);
259   event MintFinished();
260 
261   bool public mintingFinished = false;
262 
263 
264   modifier canMint() {
265     require(!mintingFinished);
266     _;
267   }
268 
269   /**
270    * @dev Function to mint tokens
271    * @param _to The address that will receive the minted tokens.
272    * @param _amount The amount of tokens to mint.
273    * @return A boolean that indicates if the operation was successful.
274    */
275   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
276     totalSupply = totalSupply.add(_amount);
277     balances[_to] = balances[_to].add(_amount);
278     Mint(_to, _amount);
279     Transfer(address(0), _to, _amount);
280     return true;
281   }
282 
283   /**
284    * @dev Function to stop minting new tokens.
285    * @return True if the operation was successful.
286    */
287   function finishMinting() onlyOwner canMint public returns (bool) {
288     mintingFinished = true;
289     MintFinished();
290     return true;
291   }
292 }
293 
294 
295 /**
296  * @title Crowdsale
297  * @dev Crowdsale is a base contract for managing a token crowdsale.
298  * Crowdsales have a start and end timestamps, where investors can make
299  * token purchases and the crowdsale will assign them tokens based
300  * on a token per ETH rate. Funds collected are forwarded to a wallet
301  * as they arrive.
302  */
303 contract Crowdsale {
304   using SafeMath for uint256;
305 
306   // The token being sold
307   MintableToken public token;
308 
309   // start and end timestamps where investments are allowed (both inclusive)
310   uint256 public startTime;
311   uint256 public endTime;
312 
313   // address where funds are collected
314   address public wallet;
315 
316   // how many token units a buyer gets per wei
317   uint256 public rate;
318 
319   // amount of raised money in wei
320   uint256 public weiRaised;
321 
322   /**
323    * event for token purchase logging
324    * @param purchaser who paid for the tokens
325    * @param beneficiary who got the tokens
326    * @param value weis paid for purchase
327    * @param amount amount of tokens purchased
328    */
329   event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
330 
331 
332   function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
333     require(_startTime >= now);
334     require(_endTime >= _startTime);
335     require(_rate > 0);
336     require(_wallet != address(0));
337 
338     token = createTokenContract();
339     startTime = _startTime;
340     endTime = _endTime;
341     rate = _rate;
342     wallet = _wallet;
343   }
344 
345   // creates the token to be sold.
346   // override this method to have crowdsale of a specific mintable token.
347   function createTokenContract() internal returns (MintableToken) {
348     return new MintableToken();
349   }
350 
351 
352   // fallback function can be used to buy tokens
353   function () external payable {
354     buyTokens(msg.sender);
355   }
356 
357   // low level token purchase function
358   function buyTokens(address beneficiary) public payable {
359     require(beneficiary != address(0));
360     require(validPurchase());
361 
362     uint256 weiAmount = msg.value;
363 
364     // calculate token amount to be created
365     uint256 tokens = weiAmount.mul(rate);
366 
367     // update state
368     weiRaised = weiRaised.add(weiAmount);
369 
370     token.mint(beneficiary, tokens);
371     TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
372 
373     forwardFunds();
374   }
375 
376   // send ether to the fund collection wallet
377   // override to create custom fund forwarding mechanisms
378   function forwardFunds() internal {
379     wallet.transfer(msg.value);
380   }
381 
382   // @return true if the transaction can buy tokens
383   function validPurchase() internal view returns (bool) {
384     bool withinPeriod = now >= startTime && now <= endTime;
385     bool nonZeroPurchase = msg.value != 0;
386     return withinPeriod && nonZeroPurchase;
387   }
388 
389   // @return true if crowdsale event has ended
390   function hasEnded() public view returns (bool) {
391     return now > endTime;
392   }
393 
394 
395 }
396 
397 
398 /**
399  * @title FinalizableCrowdsale
400  * @dev Extension of Crowdsale where an owner can do extra work
401  * after finishing.
402  */
403 contract FinalizableCrowdsale is Crowdsale, Ownable {
404   using SafeMath for uint256;
405 
406   bool public isFinalized = false;
407 
408   event Finalized();
409 
410   /**
411    * @dev Must be called after crowdsale ends, to do some extra finalization
412    * work. Calls the contract's finalization function.
413    */
414   function finalize() onlyOwner public {
415     require(!isFinalized);
416     require(hasEnded());
417 
418     finalization();
419     Finalized();
420 
421     isFinalized = true;
422   }
423 
424   /**
425    * @dev Can be overridden to add finalization logic. The overriding function
426    * should call super.finalization() to ensure the chain of finalization is
427    * executed entirely.
428    */
429   function finalization() internal {
430   }
431 }
432 
433 
434 /**
435  * @title RefundVault
436  * @dev This contract is used for storing funds while a crowdsale
437  * is in progress. Supports refunding the money if crowdsale fails,
438  * and forwarding it if crowdsale is successful.
439  */
440 contract RefundVault is Ownable {
441   using SafeMath for uint256;
442 
443   enum State { Active, Refunding, Closed }
444 
445   mapping (address => uint256) public deposited;
446   address public wallet;
447   State public state;
448 
449   event Closed();
450   event RefundsEnabled();
451   event Refunded(address indexed beneficiary, uint256 weiAmount);
452 
453   function RefundVault(address _wallet) public {
454     require(_wallet != address(0));
455     wallet = _wallet;
456     state = State.Active;
457   }
458 
459   function deposit(address investor) onlyOwner public payable {
460     require(state == State.Active);
461     deposited[investor] = deposited[investor].add(msg.value);
462   }
463 
464   function close() onlyOwner public {
465     require(state == State.Active);
466     state = State.Closed;
467     Closed();
468     wallet.transfer(this.balance);
469   }
470 
471   function enableRefunds() onlyOwner public {
472     require(state == State.Active);
473     state = State.Refunding;
474     RefundsEnabled();
475   }
476 
477   function refund(address investor) public {
478     require(state == State.Refunding);
479     uint256 depositedValue = deposited[investor];
480     deposited[investor] = 0;
481     investor.transfer(depositedValue);
482     Refunded(investor, depositedValue);
483   }
484 }
485 
486 
487 
488 contract FreezableToken is StandardToken {
489     // freezing chains
490     mapping (bytes32 => uint64) internal chains;
491     // freezing amounts for each chain
492     mapping (bytes32 => uint) internal freezings;
493     // total freezing balance per address
494     mapping (address => uint) internal freezingBalance;
495 
496     event Freezed(address indexed to, uint64 release, uint amount);
497     event Released(address indexed owner, uint amount);
498 
499 
500     /**
501      * @dev Gets the balance of the specified address include freezing tokens.
502      * @param _owner The address to query the the balance of.
503      * @return An uint256 representing the amount owned by the passed address.
504      */
505     function balanceOf(address _owner) public view returns (uint256 balance) {
506         return super.balanceOf(_owner) + freezingBalance[_owner];
507     }
508 
509     /**
510      * @dev Gets the balance of the specified address without freezing tokens.
511      * @param _owner The address to query the the balance of.
512      * @return An uint256 representing the amount owned by the passed address.
513      */
514     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
515         return super.balanceOf(_owner);
516     }
517 
518     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
519         return freezingBalance[_owner];
520     }
521 
522     /**
523      * @dev gets freezing count
524      * @param _addr Address of freeze tokens owner.
525      */
526     function freezingCount(address _addr) public view returns (uint count) {
527         uint64 release = chains[toKey(_addr, 0)];
528         while (release != 0) {
529             count ++;
530             release = chains[toKey(_addr, release)];
531         }
532     }
533 
534     /**
535      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
536      * @param _addr Address of freeze tokens owner.
537      * @param _index Freezing portion index. It ordered by release date descending.
538      */
539     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
540         for (uint i = 0; i < _index + 1; i ++) {
541             _release = chains[toKey(_addr, _release)];
542             if (_release == 0) {
543                 return;
544             }
545         }
546         _balance = freezings[toKey(_addr, _release)];
547     }
548 
549     /**
550      * @dev freeze your tokens to the specified address.
551      *      Be careful, gas usage is not deterministic,
552      *      and depends on how many freezes _to address already has.
553      * @param _to Address to which token will be freeze.
554      * @param _amount Amount of token to freeze.
555      * @param _until Release date, must be in future.
556      */
557     function freezeTo(address _to, uint _amount, uint64 _until) public {
558         require(_to != address(0));
559         require(_amount <= balances[msg.sender]);
560 
561         balances[msg.sender] = balances[msg.sender].sub(_amount);
562 
563         bytes32 currentKey = toKey(_to, _until);
564         freezings[currentKey] = freezings[currentKey].add(_amount);
565         freezingBalance[_to] = freezingBalance[_to].add(_amount);
566 
567         freeze(_to, _until);
568         Transfer(msg.sender, _to, _amount);
569         Freezed(_to, _until, _amount);
570     }
571 
572     /**
573      * @dev release first available freezing tokens.
574      */
575     function releaseOnce() public {
576         bytes32 headKey = toKey(msg.sender, 0);
577         uint64 head = chains[headKey];
578         require(head != 0);
579         require(uint64(block.timestamp) > head);
580         bytes32 currentKey = toKey(msg.sender, head);
581 
582         uint64 next = chains[currentKey];
583 
584         uint amount = freezings[currentKey];
585         delete freezings[currentKey];
586 
587         balances[msg.sender] = balances[msg.sender].add(amount);
588         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
589 
590         if (next == 0) {
591             delete chains[headKey];
592         }
593         else {
594             chains[headKey] = next;
595             delete chains[currentKey];
596         }
597         Released(msg.sender, amount);
598     }
599 
600     /**
601      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
602      * @return how many tokens was released
603      */
604     function releaseAll() public returns (uint tokens) {
605         uint release;
606         uint balance;
607         (release, balance) = getFreezing(msg.sender, 0);
608         while (release != 0 && block.timestamp > release) {
609             releaseOnce();
610             tokens += balance;
611             (release, balance) = getFreezing(msg.sender, 0);
612         }
613     }
614 
615     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
616         // WISH masc to increase entropy
617         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
618         assembly {
619             result := or(result, mul(_addr, 0x10000000000000000))
620             result := or(result, _release)
621         }
622     }
623 
624     function freeze(address _to, uint64 _until) internal {
625         require(_until > block.timestamp);
626         bytes32 key = toKey(_to, _until);
627         bytes32 parentKey = toKey(_to, uint64(0));
628         uint64 next = chains[parentKey];
629 
630         if (next == 0) {
631             chains[parentKey] = _until;
632             return;
633         }
634 
635         bytes32 nextKey = toKey(_to, next);
636         uint parent;
637 
638         while (next != 0 && _until > next) {
639             parent = next;
640             parentKey = nextKey;
641 
642             next = chains[nextKey];
643             nextKey = toKey(_to, next);
644         }
645 
646         if (_until == next) {
647             return;
648         }
649 
650         if (next != 0) {
651             chains[key] = next;
652         }
653 
654         chains[parentKey] = _until;
655     }
656 }
657 
658 /**
659 * @title Contract that will work with ERC223 tokens.
660 */
661 
662 contract ERC223Receiver {
663     /**
664      * @dev Standard ERC223 function that will handle incoming token transfers.
665      *
666      * @param _from  Token sender address.
667      * @param _value Amount of tokens.
668      * @param _data  Transaction metadata.
669      */
670     function tokenFallback(address _from, uint _value, bytes _data) public;
671 }
672 
673 contract ERC223Basic is ERC20Basic {
674     function transfer(address to, uint value, bytes data) public returns (bool);
675     event Transfer(address indexed from, address indexed to, uint value, bytes data);
676 }
677 
678 
679 contract SuccessfulERC223Receiver is ERC223Receiver {
680     event Invoked(address from, uint value, bytes data);
681 
682     function tokenFallback(address _from, uint _value, bytes _data) public {
683         Invoked(_from, _value, _data);
684     }
685 }
686 
687 contract FailingERC223Receiver is ERC223Receiver {
688     function tokenFallback(address, uint, bytes) public {
689         revert();
690     }
691 }
692 
693 contract ERC223ReceiverWithoutTokenFallback {
694 }
695 
696 /**
697  * @title Burnable Token
698  * @dev Token that can be irreversibly burned (destroyed).
699  */
700 contract BurnableToken is StandardToken {
701 
702     event Burn(address indexed burner, uint256 value);
703 
704     /**
705      * @dev Burns a specific amount of tokens.
706      * @param _value The amount of token to be burned.
707      */
708     function burn(uint256 _value) public {
709         require(_value > 0);
710         require(_value <= balances[msg.sender]);
711         // no need to require value <= totalSupply, since that would imply the
712         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
713 
714         address burner = msg.sender;
715         balances[burner] = balances[burner].sub(_value);
716         totalSupply = totalSupply.sub(_value);
717         Burn(burner, _value);
718     }
719 }
720 
721 
722 
723 /**
724  * @title Pausable
725  * @dev Base contract which allows children to implement an emergency stop mechanism.
726  */
727 contract Pausable is Ownable {
728   event Pause();
729   event Unpause();
730 
731   bool public paused = false;
732 
733 
734   /**
735    * @dev Modifier to make a function callable only when the contract is not paused.
736    */
737   modifier whenNotPaused() {
738     require(!paused);
739     _;
740   }
741 
742   /**
743    * @dev Modifier to make a function callable only when the contract is paused.
744    */
745   modifier whenPaused() {
746     require(paused);
747     _;
748   }
749 
750   /**
751    * @dev called by the owner to pause, triggers stopped state
752    */
753   function pause() onlyOwner whenNotPaused public {
754     paused = true;
755     Pause();
756   }
757 
758   /**
759    * @dev called by the owner to unpause, returns to normal state
760    */
761   function unpause() onlyOwner whenPaused public {
762     paused = false;
763     Unpause();
764   }
765 }
766 
767 
768 
769 contract FreezableMintableToken is FreezableToken, MintableToken {
770     /**
771      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
772      *      Be careful, gas usage is not deterministic,
773      *      and depends on how many freezes _to address already has.
774      * @param _to Address to which token will be freeze.
775      * @param _amount Amount of token to mint and freeze.
776      * @param _until Release date, must be in future.
777      * @return A boolean that indicates if the operation was successful.
778      */
779     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
780         totalSupply = totalSupply.add(_amount);
781 
782         bytes32 currentKey = toKey(_to, _until);
783         freezings[currentKey] = freezings[currentKey].add(_amount);
784         freezingBalance[_to] = freezingBalance[_to].add(_amount);
785 
786         freeze(_to, _until);
787         Mint(_to, _amount);
788         Freezed(_to, _until, _amount);
789         Transfer(msg.sender, _to, _amount);
790         return true;
791     }
792 }
793 
794 contract Consts {
795     uint constant TOKEN_DECIMALS = 18;
796     uint8 constant TOKEN_DECIMALS_UINT8 = 18;
797     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
798 
799     string constant TOKEN_NAME = "Hulmu";
800     string constant TOKEN_SYMBOL = "HLMU";
801     bool constant PAUSED = false;
802     address constant TARGET_USER = 0xAafB403212A36a7Bb0da271f36BBDB0e30e04EbE;
803     
804     uint constant START_TIME = 1526313641;
805     
806     bool constant CONTINUE_MINTING = false;
807 }
808 
809 
810 
811 
812 /**
813  * @title Reference implementation of the ERC223 standard token.
814  */
815 contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {
816     using SafeMath for uint;
817 
818     /**
819      * @dev Transfer the specified amount of tokens to the specified address.
820      *      Invokes the `tokenFallback` function if the recipient is a contract.
821      *      The token transfer fails if the recipient is a contract
822      *      but does not implement the `tokenFallback` function
823      *      or the fallback function to receive funds.
824      *
825      * @param _to    Receiver address.
826      * @param _value Amount of tokens that will be transferred.
827      * @param _data  Transaction metadata.
828      */
829     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
830         // Standard function transfer similar to ERC20 transfer with no _data .
831         // Added due to backwards compatibility reasons .
832         uint codeLength;
833 
834         assembly {
835             // Retrieve the size of the code on target address, this needs assembly.
836             codeLength := extcodesize(_to)
837         }
838 
839         balances[msg.sender] = balances[msg.sender].sub(_value);
840         balances[_to] = balances[_to].add(_value);
841         if(codeLength > 0) {
842             ERC223Receiver receiver = ERC223Receiver(_to);
843             receiver.tokenFallback(msg.sender, _value, _data);
844         }
845         Transfer(msg.sender, _to, _value, _data);
846         return true;
847     }
848 
849     /**
850      * @dev Transfer the specified amount of tokens to the specified address.
851      *      This function works the same with the previous one
852      *      but doesn't contain `_data` param.
853      *      Added due to backwards compatibility reasons.
854      *
855      * @param _to    Receiver address.
856      * @param _value Amount of tokens that will be transferred.
857      */
858     function transfer(address _to, uint256 _value) public returns (bool) {
859         bytes memory empty;
860         return transfer(_to, _value, empty);
861     }
862 }
863 
864 
865 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
866     
867     , ERC223Token
868     
869 {
870     
871 
872     function name() pure public returns (string _name) {
873         return TOKEN_NAME;
874     }
875 
876     function symbol() pure public returns (string _symbol) {
877         return TOKEN_SYMBOL;
878     }
879 
880     function decimals() pure public returns (uint8 _decimals) {
881         return TOKEN_DECIMALS_UINT8;
882     }
883 
884     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
885         require(!paused);
886         return super.transferFrom(_from, _to, _value);
887     }
888 
889     function transfer(address _to, uint256 _value) public returns (bool _success) {
890         require(!paused);
891         return super.transfer(_to, _value);
892     }
893 }
894 
895 
896 
897 
898 /**
899  * @title CappedCrowdsale
900  * @dev Extension of Crowdsale with a max amount of funds raised
901  */
902 contract CappedCrowdsale is Crowdsale {
903   using SafeMath for uint256;
904 
905   uint256 public cap;
906 
907   function CappedCrowdsale(uint256 _cap) public {
908     require(_cap > 0);
909     cap = _cap;
910   }
911 
912   // overriding Crowdsale#validPurchase to add extra cap logic
913   // @return true if investors can buy at the moment
914   function validPurchase() internal view returns (bool) {
915     bool withinCap = weiRaised.add(msg.value) <= cap;
916     return super.validPurchase() && withinCap;
917   }
918 
919   // overriding Crowdsale#hasEnded to add cap logic
920   // @return true if crowdsale event has ended
921   function hasEnded() public view returns (bool) {
922     bool capReached = weiRaised >= cap;
923     return super.hasEnded() || capReached;
924   }
925 
926 }
927 
928 
929 
930 /**
931  * @title RefundableCrowdsale
932  * @dev Extension of Crowdsale contract that adds a funding goal, and
933  * the possibility of users getting a refund if goal is not met.
934  * Uses a RefundVault as the crowdsale's vault.
935  */
936 contract RefundableCrowdsale is FinalizableCrowdsale {
937   using SafeMath for uint256;
938 
939   // minimum amount of funds to be raised in weis
940   uint256 public goal;
941 
942   // refund vault used to hold funds while crowdsale is running
943   RefundVault public vault;
944 
945   function RefundableCrowdsale(uint256 _goal) public {
946     require(_goal > 0);
947     vault = new RefundVault(wallet);
948     goal = _goal;
949   }
950 
951   // We're overriding the fund forwarding from Crowdsale.
952   // In addition to sending the funds, we want to call
953   // the RefundVault deposit function
954   function forwardFunds() internal {
955     vault.deposit.value(msg.value)(msg.sender);
956   }
957 
958   // if crowdsale is unsuccessful, investors can claim refunds here
959   function claimRefund() public {
960     require(isFinalized);
961     require(!goalReached());
962 
963     vault.refund(msg.sender);
964   }
965 
966   // vault finalization task, called when owner calls finalize()
967   function finalization() internal {
968     if (goalReached()) {
969       vault.close();
970     } else {
971       vault.enableRefunds();
972     }
973 
974     super.finalization();
975   }
976 
977   function goalReached() public view returns (bool) {
978     return weiRaised >= goal;
979   }
980 
981 }
982 
983 
984 contract MainCrowdsale is Consts, FinalizableCrowdsale {
985     function hasStarted() public constant returns (bool) {
986         return now >= startTime;
987     }
988 
989     function finalization() internal {
990         super.finalization();
991 
992         if (PAUSED) {
993             MainToken(token).unpause();
994         }
995 
996         if (!CONTINUE_MINTING) {
997             token.finishMinting();
998         }
999 
1000         token.transferOwnership(TARGET_USER);
1001     }
1002 
1003     function buyTokens(address beneficiary) public payable {
1004         require(beneficiary != address(0));
1005         require(validPurchase());
1006 
1007         uint256 weiAmount = msg.value;
1008 
1009         // calculate token amount to be created
1010         uint256 tokens = weiAmount.mul(rate).div(1 ether);
1011 
1012         // update state
1013         weiRaised = weiRaised.add(weiAmount);
1014 
1015         token.mint(beneficiary, tokens);
1016         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1017 
1018         forwardFunds();
1019     }
1020 }
1021 
1022 
1023 contract Checkable {
1024     address private serviceAccount;
1025     /**
1026      * Flag means that contract accident already occurs.
1027      */
1028     bool private triggered = false;
1029 
1030     /**
1031      * Occurs when accident happened.
1032      */
1033     event Triggered(uint balance);
1034     /**
1035      * Occurs when check finished.
1036      */
1037     event Checked(bool isAccident);
1038 
1039     function Checkable() public {
1040         serviceAccount = msg.sender;
1041     }
1042 
1043     /**
1044      * @dev Replace service account with new one.
1045      * @param _account Valid service account address.
1046      */
1047     function changeServiceAccount(address _account) onlyService public {
1048         assert(_account != 0);
1049         serviceAccount = _account;
1050     }
1051 
1052     /**
1053      * @dev Is caller (sender) service account.
1054      */
1055     function isServiceAccount() view public returns (bool) {
1056         return msg.sender == serviceAccount;
1057     }
1058 
1059     /**
1060      * Public check method.
1061      */
1062     function check() onlyService notTriggered payable public {
1063         if (internalCheck()) {
1064             Triggered(this.balance);
1065             triggered = true;
1066             internalAction();
1067         }
1068     }
1069 
1070     /**
1071      * @dev Do inner check.
1072      * @return bool true of accident triggered, false otherwise.
1073      */
1074     function internalCheck() internal returns (bool);
1075 
1076     /**
1077      * @dev Do inner action if check was success.
1078      */
1079     function internalAction() internal;
1080 
1081     modifier onlyService {
1082         require(msg.sender == serviceAccount);
1083         _;
1084     }
1085 
1086     modifier notTriggered() {
1087         require(!triggered);
1088         _;
1089     }
1090 }
1091 
1092 
1093 contract BonusableCrowdsale is Consts, Crowdsale {
1094 
1095     function buyTokens(address beneficiary) public payable {
1096         require(beneficiary != address(0));
1097         require(validPurchase());
1098 
1099         uint256 weiAmount = msg.value;
1100 
1101         // calculate token amount to be created
1102         uint256 bonusRate = getBonusRate(weiAmount);
1103         uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);
1104 
1105         // update state
1106         weiRaised = weiRaised.add(weiAmount);
1107 
1108         token.mint(beneficiary, tokens);
1109         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1110 
1111         forwardFunds();
1112     }
1113 
1114     function getBonusRate(uint256 weiAmount) internal view returns (uint256) {
1115         uint256 bonusRate = rate;
1116 
1117         
1118         // apply bonus for time & weiRaised
1119         uint[5] memory weiRaisedStartsBoundaries = [uint(0),uint(21000000000000000000000),uint(42000000000000000000000),uint(63000000000000000000000),uint(84000000000000000000000)];
1120         uint[5] memory weiRaisedEndsBoundaries = [uint(21000000000000000000000),uint(42000000000000000000000),uint(63000000000000000000000),uint(84000000000000000000000),uint(105000000000000000000000)];
1121         uint64[5] memory timeStartsBoundaries = [uint64(1526313641),uint64(1526313641),uint64(1526313641),uint64(1526313641),uint64(1526313641)];
1122         uint64[5] memory timeEndsBoundaries = [uint64(1559318395),uint64(1559318395),uint64(1559318395),uint64(1559318395),uint64(1559318395)];
1123         uint[5] memory weiRaisedAndTimeRates = [uint(1660),uint(1000),uint(600),uint(330),uint(150)];
1124 
1125         for (uint i = 0; i < 5; i++) {
1126             bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);
1127             bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);
1128             if (weiRaisedInBound && timeInBound) {
1129                 bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;
1130             }
1131         }
1132         
1133 
1134         
1135 
1136         return bonusRate;
1137     }
1138 }
1139 
1140 
1141 
1142 contract TemplateCrowdsale is Consts, MainCrowdsale
1143     
1144     , BonusableCrowdsale
1145     
1146     
1147     , CappedCrowdsale
1148     
1149     , Checkable
1150     
1151 {
1152     event Initialized();
1153     bool public initialized = false;
1154 
1155     function TemplateCrowdsale(MintableToken _token) public
1156         Crowdsale(START_TIME > now ? START_TIME : now, 1559318400, 100 * TOKEN_DECIMAL_MULTIPLIER, 0x695f2040F98b05F31943469325D0B75Be61483A7)
1157         CappedCrowdsale(126000000000000000000000)
1158         
1159     {
1160         token = _token;
1161     }
1162 
1163     function init() public onlyOwner {
1164         require(!initialized);
1165         initialized = true;
1166 
1167         if (PAUSED) {
1168             MainToken(token).pause();
1169         }
1170 
1171         
1172         address[3] memory addresses = [address(0x1ddac4f21ae17698b3bae7c8b2a65cfaaf530a7b),address(0x9e235ab6749765ea38bd8e3c0cfa2be456e0dcfe),address(0xf3af0b511d4845a7964972a92f25af8afffaf8af)];
1173         uint[3] memory amounts = [uint(4200000000000000000000000),uint(2100000000000000000000000),uint(2100000000000000000000000)];
1174         uint64[3] memory freezes = [uint64(0),uint64(0),uint64(0)];
1175 
1176         for (uint i = 0; i < addresses.length; i++) {
1177             if (freezes[i] == 0) {
1178                 MainToken(token).mint(addresses[i], amounts[i]);
1179             } else {
1180                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1181             }
1182         }
1183         
1184 
1185         transferOwnership(TARGET_USER);
1186 
1187         Initialized();
1188     }
1189 
1190     /**
1191      * @dev override token creation to set token address in constructor.
1192      */
1193     function createTokenContract() internal returns (MintableToken) {
1194         return MintableToken(0);
1195     }
1196 
1197     
1198     /**
1199      * @dev Do inner check.
1200      * @return bool true of accident triggered, false otherwise.
1201      */
1202     function internalCheck() internal returns (bool) {
1203         bool result = !isFinalized && hasEnded();
1204         Checked(result);
1205         return result;
1206     }
1207 
1208     /**
1209      * @dev Do inner action if check was success.
1210      */
1211     function internalAction() internal {
1212         finalization();
1213         Finalized();
1214 
1215         isFinalized = true;
1216     }
1217     
1218 
1219     
1220 
1221     
1222 
1223 }