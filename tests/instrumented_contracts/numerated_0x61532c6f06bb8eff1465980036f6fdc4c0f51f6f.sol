1 /*     
2     ░░  ░   ░   ░   ░   ░  ░░  ░   ░       ░  ░░  ░   ░   ░   ░  ░░  ░   ░   ░   ░
3                                   ╓╖▒░░░
4                                 @╬▓▓▒░░░░
5                                ╫╢╢╢╢╢@▒@@@▒
6       ░░  ░   ░   ░   ░  ░░  ░ ▓╢╢╢╢╢╢╢╢╢╢▓Ñ╖░  ░░  ░   ░   ░  ░░  ░░  ░   ░   ░   ░
7                                 ▓╢╢╢╢╢╢╢╢╢╢╢╢▓@╖,        ╖╖╖╖.                  ░
8       ░░  ░   ░   ░   ░  ░░  ░   ╙▓╢╢╢╢╢╢╢╢╢╢╢╣╢▓▓▓ ░ ╓╢▓▒▒▒░░ ░░  ░░  ░   ░   ░   ░
9                                    ╙╩▓╢╢╢╢╢╢╢╫╣╢╢╢╢  ║▒▓╢▓▒▒▒▒░
10                                       `╨▓╢╢╢╢╢╢╢╢╢╢  ╢╣╢╢╢▓▓▓▓╖
11                  ,                      ]╢╢╢╢╢╢╢╢╢╢▒  ▓╢╢╢╢╢╢╢▒╖
12     ░░  ░   ░ ,▒▒░░▒∩╖     ░░  ░   ░   ░ ▓╢╢╢╢╢╢╢╢╢▒╖ ░▓╢╢╢╢╢╢╢@╖░░  ░   ░   ░   ░
13       ░░  ░░  ║▒▒▒▒▒▓▓▓▓▓▓▓@╖,   ░   ░   ░▓╢╢╢╢╢╢╢╢╣▒╖  ▓╢╢╢╢╢╢╣▓@ ░░  ░   ░   ░   ░
14               ╫╢╢╢╢╢╢╢╢╢╢╢╢╢╫▓▓╖           ▓╢╢╢╢╢╢╢╢╣▓╣ └╢╢╢╢╢╢╢╢▓▒
15       ░░  ░   ╚╣╣╣╢╢╢╢╢╢╢╢╢╢╢╢╢▒ ░   ░   ░╟╢╢╢╢╢╬╣╢╢╢╢▓░░╟╢╢╢╢╢╢╢╢▓░░  ░   ░   ░   ░
16                 ╙╨╩▓▓▓▓╢╢╢╣╢╢╢╢▓▒         ╟╢╢╢╢╢╢╢╢╢╢▓╜   ▓╢╢╢╢╢╢╢╢╣
17                        ╟╢╣╣╢╣╣╣╣╣▓        ▒╢╢╢╢╢╢╢╢╢╢╣   ╓▒▓╢╢╢╢╢╢╢▓[   ╓╢▒▒▒▒
18                         ▓╣╣╣╣╣╢╣▓▓▓       ▒╢╢╣╢╢╢╢╢╢╢Ü  ╓▒▓╢╢╢╢╣╣╢╢╢▒  ╢▒▓╢▓▒▒▒
19     ░░  ░░  ░   ░   ░  ░░▓▓▓╣╣▓▓╢╢╣▓╖  ░  ▒╣╣╣╣╣╣╣╣╣▓ ░,▒╣╢╢╢╢╢╢╢▓▓▓ ░ ▒╢╢╢▓@▒▒ 
20                          ]╣▓▓╣▓▓╣╣╣╣▓@╖ ╓▓╫╣╣╣╣╣╣╣╣╣▓ ,╫╣╣╣╣╣╣╣╢╣╢▓    ╠╢╢╢╢╢╢╜
21     ░░  ░   ░   ░   ░   ░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╣╣╣╣╣╣╣╣▓g▓╣╣╣╣╣╣╣╣╣▓╜░  ░ ╟╣╣╣╢╢╣   
22           ░               └▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╣▓▓▓▓▓▓▓▓╣▓▓▓╣╣╣╣╣╣╣╣▓      ╥▓╣╢╫╣╢╣H
23       ]▒▒▒▒▓H╖,            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓      ╫▓╣╣╣╣╢╣▓
24       ]▒▒▒▒▓▓▓▒╖           j▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░   ,╓╢▓╣╣╣╣╣╣╣▓
25       ░▓▓▓▓▓▓▓▓▒  ░   ░  ░░ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓@@▓▓▓▓▓▓▓▓▓▓▓▓  ░   ░
26     ░░ ▓▓▓▓▓▓▓▓M░   ░  ░░  ░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ░   ░
27       ]▓▓▓▓▓▓▓▓╖  ░   ░  ░░╓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓M   ░   ░
28       ▓▓▓▓▓▓▓▓▓▓▓N,      ,╢▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
29       ▀▓▓▓▓▓▓▓▓▓▓▓▓▓╖  ,@▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░
30         ╙▓▓▓▓▓▓▓▓▓▓▓▓▓╢▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀`
31     ░░  ░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╜ ░   ░   ░   ░
32       ░░  ░ ▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ░░  ░   ░   ░   ░
33              ║▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
34       ░░  ░   ╫▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓C ░░  ░   ░   ░   ░
35               └▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
36                 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌
37                  ╙▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░
38     ░░  ░   ░   ░   ╙▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ░░  ░   ░   ░   ░
39       ░░  ░   ░   ░    `▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░  ░░  ░░  ░   ░   ░
40     ░░  ░   ░   ░   ░   ░  ▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╜  ░░  ░   ░   ░   ░
41                              ▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╣
42                               ╙▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓@
43                                ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╣
44       ░   ░              ░   ░  ╫▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓M░  ░   ░
45     ░░  ░░  ░   ░   ░  ░░  ░░  ░╘▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ░░  ░   ░   ░   ░
46                                  ╫▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓U
47     ░░  ░   ░   ░   ░   ░  ░░  ░ ╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ░░  ░   ░   ░   ░
48                       ,▄▄▄▄,     ╟▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌@
49           ,.⌐∞═ⁿ▀▀▀▀▀▀ ` . ▀██▄▄▄╣▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒
50                        ╙▀▀█▄▄████╫███▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▄███▀▀▀▀▀▀M═∞¡
51       ░░  ░   ░   *w▄,░  ░░  '▀█████▓▓▓████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████▀  ░ , ░   ░   ░
52      ░                ▀▀R▄▄▄▄▄▄████████████████████████████████████▀RP▀▀ ░       ░
53       ░░  ░   ░   ░   ░       '-   ▄Æ█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀-      ░  ░   ░   ░   ░   ░
54      The Summoning Jutsu: Reanimation is a forbidden technique used to revive the dead
55 	 
56 	 Brought back to enter the flesh again
57 */	 
58 //	 44 6F 20 6E 6F 74 20 62 75 79 20 75 6E 74 69 6C 20 34 38 20 68 6F 75 72 73 20 61 66 74 65 72 20 6F 70 65 6E 20 74 72 61 64 65
59 	 
60 //	 22 47 72 65 65 64 20 6B 69 6C 6C 65 64 20 6D 61 6E 73 20 73 6F 75 6C 22 20
61 	 
62 // SPDX-License-Identifier: MIT
63 pragma solidity >=0.6.0 <0.9.0;
64 
65 abstract contract Context {
66     function _msgSender() internal view returns (address payable) {
67         return payable(msg.sender);
68     }
69 
70     function _msgData() internal view returns (bytes memory) {
71         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
72         return msg.data;
73     }
74 }
75 
76 
77 /**
78  * @dev Interface of the ERC20 standard as defined in the EIP.
79  */
80 interface IERC20Upgradeable {
81     /**
82      * @dev Returns the amount of tokens in existence.
83      */
84     function totalSupply() external view returns (uint256);
85 
86     /**
87      * @dev Returns the amount of tokens owned by `account`.
88      */
89     function balanceOf(address account) external view returns (uint256);
90 
91     /**
92      * @dev Moves `amount` tokens from the caller's account to `recipient`.
93      *
94      * Returns a boolean value indicating whether the operation succeeded.
95      *
96      * Emits a {Transfer} event.
97      */
98     function transfer(address recipient, uint256 amount) external returns (bool);
99 
100     /**
101      * @dev Returns the remaining number of tokens that `spender` will be
102      * allowed to spend on behalf of `owner` through {transferFrom}. This is
103      * zero by default.
104      *
105      * This value changes when {approve} or {transferFrom} are called.
106      */
107     function allowance(address owner, address spender) external view returns (uint256);
108 
109     /**
110      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
111      *
112      * Returns a boolean value indicating whether the operation succeeded.
113      *
114      * IMPORTANT: Beware that changing an allowance with this method brings the risk
115      * that someone may use both the old and the new allowance by unfortunate
116      * transaction ordering. One possible solution to mitigate this race
117      * condition is to first reduce the spender's allowance to 0 and set the
118      * desired value afterwards:
119      * https://github.com/ethereum/EIPs/od/ai/nu/20#issuecomment-263524729
120      *
121      * Emits an {Approval} event.
122      */
123     function approve(address spender, uint256 amount) external returns (bool);
124 
125     /**
126      * @dev Moves `amount` tokens from `sender` to `recipient` using the
127      * allowance mechanism. `amount` is then deducted from the caller's
128      * allowance.
129      *
130      * Returns a boolean value indicating whether the operation succeeded.
131      *
132      * Emits a {Transfer} event.
133      */
134     function transferFrom(
135         address sender,
136         address recipient,
137         uint256 amount
138     ) external returns (bool);
139 
140     /**
141      * @dev Emitted when `value` tokens are moved from one account (`from`) to
142      * another (`to`).
143      *
144      * Note that `value` may be zero.
145      */
146     event Transfer(address indexed from, address indexed to, uint256 value);
147 
148     /**
149      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
150      * a call to {approve}. `value` is the new allowance.
151      */
152     event Approval(address indexed owner, address indexed spender, uint256 value);
153 }
154 
155 library Address {
156     function isContract(address account) internal view returns (bool) {
157         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
158         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
159         // for accounts without code, i.e. `keccak256('')`
160         bytes32 codehash;
161         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
162         // solhint-disable-next-line no-inline-assembly
163         assembly { codehash := extcodehash(account) }
164         return (codehash != accountHash && codehash != 0x0);
165     }
166 
167     function sendValue(address payable recipient, uint256 amount) internal {
168         require(address(this).balance >= amount, "Address: insufficient balance");
169 
170         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
171         (bool success, ) = recipient.call{ value: amount }("");
172         require(success, "Address: unable to send value, recipient may have reverted");
173     }
174 
175     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
176         return functionCall(target, data, "Address: low-level call failed");
177     }
178 
179     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
180         return _functionCallWithValue(target, data, 0, errorMessage);
181     }
182 
183 
184     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
185         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
186     }
187 
188     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
189         require(address(this).balance >= value, "Address: insufficient balance for call");
190         return _functionCallWithValue(target, data, value, errorMessage);
191     }
192 
193     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
194         require(isContract(target), "Address: call to non-contract");
195 
196         // solhint-disable-next-line avoid-low-level-calls
197         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
198         if (success) {
199             return returndata;
200         } else {
201             // Look for revert reason and bubble it up if present
202             if (returndata.length > 0) {
203                 // The easiest way to bubble the revert reason is using memory via assembly
204 
205                 // solhint-disable-next-line no-inline-assembly
206                 assembly {
207                     let returndata_size := mload(returndata)
208                     revert(add(32, returndata), returndata_size)
209                 }
210             } else {
211                 revert(errorMessage);
212             }
213         }
214     }
215 }
216 
217 interface IUniswapV2Factory {
218     event PairCreated(address indexed token0, address indexed token1, address lpPair, uint);
219     function getPair(address tokenA, address tokenB) external view returns (address lpPair);
220     function createPair(address tokenA, address tokenB) external returns (address lpPair);
221 }
222 
223 interface IUniswapV2Router01 {
224     function factory() external pure returns (address);
225     function WETH() external pure returns (address);
226     function addLiquidityETH(
227         address token,
228         uint amountTokenDesired,
229         uint amountTokenMin,
230         uint amountETHMin,
231         address to,
232         uint deadline
233     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
234 }
235 
236 interface IUniswapV2Router02 is IUniswapV2Router01 {
237     function removeLiquidityETHSupportingFeeOnTransferTokens(
238         address token,
239         uint liquidity,
240         uint amountTokenMin,
241         uint amountETHMin,
242         address to,
243         uint deadline
244     ) external returns (uint amountETH);
245     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
246         address token,
247         uint liquidity,
248         uint amountTokenMin,
249         uint amountETHMin,
250         address to,
251         uint deadline,
252         bool approveMax, uint8 v, bytes32 r, bytes32 s
253     ) external returns (uint amountETH);
254 
255     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
256         uint amountIn,
257         uint amountOutMin,
258         address[] calldata path,
259         address to,
260         uint deadline
261     ) external;
262     function swapExactETHForTokensSupportingFeeOnTransferTokens(
263         uint amountOutMin,
264         address[] calldata path,
265         address to,
266         uint deadline
267     ) external payable;
268     function swapExactTokensForETHSupportingFeeOnTransferTokens(
269         uint amountIn,
270         uint amountOutMin,
271         address[] calldata path,
272         address to,
273         uint deadline
274     ) external;
275 }
276 
277 contract ReAnimationDAO is Context, IERC20Upgradeable {
278     // Ownership moved to in-contract for customizability.
279     address private _owner;
280 
281     mapping (address => uint256) private _rOwned;
282     mapping (address => uint256) private _tOwned;
283     mapping (address => bool) lpPairs;
284     uint256 private timeSinceLastPair = 0;
285     mapping (address => mapping (address => uint256)) private _allowances;
286 
287     mapping (address => bool) private _isExcludedFromFee;
288     mapping (address => bool) private _isExcluded;
289     address[] private _excluded;
290 
291     mapping (address => bool) private _isSniperOrBlacklisted;
292     mapping (address => bool) private _liquidityHolders;
293    
294     uint256 private startingSupply;
295 
296     string private _name;
297     string private _symbol;
298 
299     uint256 public _reflectFee = 0;
300     uint256 public _liquidityFee = 300;
301     uint256 public _marketingFee = 500;
302 
303     uint256 public _buyReflectFee = _reflectFee;
304     uint256 public _buyLiquidityFee = _liquidityFee;
305     uint256 public _buyMarketingFee = _marketingFee;
306 
307     uint256 public _sellReflectFee = 0;
308     uint256 public _sellLiquidityFee = 300;
309     uint256 public _sellMarketingFee = 500;
310     
311     uint256 public _transferReflectFee = _buyReflectFee;
312     uint256 public _transferLiquidityFee = _buyLiquidityFee;
313     uint256 public _transferMarketingFee = _buyMarketingFee;
314     
315     uint256 private maxReflectFee = 1000;
316     uint256 private maxLiquidityFee = 1000;
317     uint256 private maxMarketingFee = 2000;
318 
319     uint256 public _liquidityRatio = 300;
320     uint256 public _marketingRatio = 500;
321 
322     uint256 private masterTaxDivisor = 10000;
323 
324     uint256 private constant MAX = ~uint256(0);
325     uint8 private _decimals;
326     uint256 private _decimalsMul;
327     uint256 private _tTotal;
328     uint256 private _rTotal;
329     uint256 private _tFeeTotal;
330 
331     IUniswapV2Router02 public dexRouter;
332     address public lpPair;
333 
334     // UNI ROUTER
335     address public _routerAddress;
336 
337     address public DEAD = 0x000000000000000000000000000000000000dEaD;
338     address public ZERO = 0x0000000000000000000000000000000000000000;
339     address payable private _marketingWallet;
340     
341     bool inSwapAndLiquify;
342     bool public swapAndLiquifyEnabled = false;
343     
344     uint256 private _maxTxAmount;
345     uint256 public maxTxAmountUI;
346 
347     uint256 private _maxWalletSize;
348     uint256 public maxWalletSizeUI;
349 
350     uint256 private swapThreshold;
351     uint256 private swapAmount;
352 
353     bool tradingEnabled = false;
354 
355     bool private sniperProtection = true;
356     bool public _hasLiqBeenAdded = false;
357     uint256 private _liqAddBlock = 0;
358     uint256 private _liqAddStamp = 0;
359     uint256 private snipeBlockAmt = 0;
360     uint256 public snipersCaught = 0;
361     bool private gasLimitActive = true;
362     uint256 private gasPriceLimit;
363     bool private sameBlockActive = true;
364     mapping (address => uint256) private lastTrade;
365 
366     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
367     event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
368     event SwapAndLiquifyEnabledUpdated(bool enabled);
369     event SwapAndLiquify(
370         uint256 tokensSwapped,
371         uint256 ethReceived,
372         uint256 tokensIntoLiqudity
373     );
374     event SniperCaught(address sniperAddress);
375     
376     bool contractInitialized = false;
377     
378     modifier lockTheSwap {
379         inSwapAndLiquify = true;
380         _;
381         inSwapAndLiquify = false;
382     }
383 
384     modifier onlyOwner() {
385         require(_owner == _msgSender(), "Ownable: caller is not the owner");
386         _;
387     }
388     
389     constructor () payable {
390         // Set the owner.
391         _owner = msg.sender;
392 
393         if (block.chainid == 56) {
394             _routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
395         } else if (block.chainid == 97) {
396             _routerAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;
397         } else if (block.chainid == 1 || block.chainid == 4 || block.chainid == 3) {
398             _routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
399         } else {
400             revert();
401         }
402 
403         _isExcludedFromFee[owner()] = true;
404         _isExcludedFromFee[address(this)] = true;
405         _liquidityHolders[owner()] = true;
406 
407         _approve(_msgSender(), _routerAddress, MAX);
408         _approve(address(this), _routerAddress, MAX);
409 
410     }
411 
412     receive() external payable {}
413 
414     function intializeContract(address payable setNewWallet, string memory _tokenname, string memory _tokensymbol, uint8 _block, uint256 gas) external onlyOwner {
415         require(!contractInitialized);
416         require(snipeBlockAmt == 0 && gasPriceLimit == 0 && !_hasLiqBeenAdded);
417         require(gas >= 75, "you fucking jeet");
418 
419         _marketingWallet = payable(setNewWallet);
420 
421         _name = _tokenname;
422         _symbol = _tokensymbol;
423         startingSupply = 888_888_888_888;
424         if (startingSupply < 10000000000) {
425             _decimals = 18;
426             _decimalsMul = _decimals;
427         } else {
428             _decimals = 9;
429             _decimalsMul = _decimals;
430         }
431         _tTotal = startingSupply * (10**_decimalsMul);
432         _rTotal = (MAX - (MAX % _tTotal));
433 
434         dexRouter = IUniswapV2Router02(_routerAddress);
435         lpPair = IUniswapV2Factory(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));
436         lpPairs[lpPair] = true;
437         _allowances[address(this)][address(dexRouter)] = type(uint256).max;
438         
439         snipeBlockAmt = _block;
440         gasPriceLimit = gas * 1 gwei;
441         _maxTxAmount = (_tTotal * 2000) / 100000;
442         maxTxAmountUI = (startingSupply * 500) / 100000;
443         _maxWalletSize = (_tTotal * 20) / 1000;
444         maxWalletSizeUI = (startingSupply * 10) / 1000;
445         swapThreshold = (_tTotal * 5) / 10000;
446         swapAmount = (_tTotal * 5) / 1000;
447 
448         approve(_routerAddress, type(uint256).max);
449 
450         contractInitialized = true;
451         _rOwned[owner()] = _rTotal;
452         emit Transfer(ZERO, owner(), _tTotal);
453 
454         _approve(address(this), address(dexRouter), type(uint256).max);
455 
456         _transfer(owner(), address(this), balanceOf(owner()));
457 
458 
459         
460 
461         dexRouter.addLiquidityETH{value: address(this).balance}(
462             address(this),
463             balanceOf(address(this)),
464             0, 
465             0, 
466             owner(),
467             block.timestamp
468         );
469 
470     }
471 
472 //===============================================================================================================
473 //===============================================================================================================
474 //===============================================================================================================
475     // Ownable removed as a lib and added here to allow for custom transfers and recnouncements.
476     // This allows for removal of ownership privelages from the owner once renounced or transferred.
477     function owner() public view returns (address) {
478         return _owner;
479     }
480 
481     function transferOwner(address newOwner) external onlyOwner() {
482         require(newOwner != address(0), "Call renounceOwnership to transfer owner to the zero address.");
483         require(newOwner != DEAD, "Call renounceOwnership to transfer owner to the zero address.");
484         setExcludedFromFee(_owner, false);
485         setExcludedFromFee(newOwner, true);
486         setExcludedFromReward(newOwner, true);
487         
488         if (_marketingWallet == payable(_owner))
489             _marketingWallet = payable(newOwner);
490         
491         _allowances[_owner][newOwner] = balanceOf(_owner);
492         if(balanceOf(_owner) > 0) {
493             _transfer(_owner, newOwner, balanceOf(_owner));
494         }
495         
496         _owner = newOwner;
497         emit OwnershipTransferred(_owner, newOwner);
498         
499     }
500 
501     function renounceOwnership() public virtual onlyOwner() {
502         setExcludedFromFee(_owner, false);
503         _owner = address(0);
504         emit OwnershipTransferred(_owner, address(0));
505     }
506 //===============================================================================================================
507 //===============================================================================================================
508 //===============================================================================================================
509 
510     function totalSupply() external view override returns (uint256) { return _tTotal; }
511     function decimals() external view returns (uint8) { return _decimals; }
512     function symbol() external view returns (string memory) { return _symbol; }
513     function name() external view returns (string memory) { return _name; }
514     function getOwner() external view returns (address) { return owner(); }
515     function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }
516 
517     function balanceOf(address account) public view override returns (uint256) {
518         if (_isExcluded[account]) return _tOwned[account];
519         return tokenFromReflection(_rOwned[account]);
520     }
521 
522     function transfer(address recipient, uint256 amount) public override returns (bool) {
523         _transfer(_msgSender(), recipient, amount);
524         return true;
525     }
526 
527     function approve(address spender, uint256 amount) public override returns (bool) {
528         _approve(_msgSender(), spender, amount);
529         return true;
530     }
531 
532     function approveMax(address spender) public returns (bool) {
533         return approve(spender, type(uint256).max);
534     }
535 
536     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
537         _transfer(sender, recipient, amount);
538         _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);
539         return true;
540     }
541 
542     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
543         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
544         return true;
545     }
546 
547     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
548         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);
549         return true;
550     }
551 
552     function setNewRouter(address newRouter) external onlyOwner() {
553         IUniswapV2Router02 _newRouter = IUniswapV2Router02(newRouter);
554         address get_pair = IUniswapV2Factory(_newRouter.factory()).getPair(address(this), _newRouter.WETH());
555         if (get_pair == address(0)) {
556             lpPair = IUniswapV2Factory(_newRouter.factory()).createPair(address(this), _newRouter.WETH());
557         }
558         else {
559             lpPair = get_pair;
560         }
561         dexRouter = _newRouter;
562         _approve(address(this), newRouter, MAX);
563     }
564 
565     function setLpPair(address pair, bool enabled) external onlyOwner {
566         if (enabled == false) {
567             lpPairs[pair] = false;
568         } else {
569             if (timeSinceLastPair != 0) {
570                 require(block.timestamp - timeSinceLastPair > 1 weeks, "Cannot set a new pair this week!");
571             }
572             lpPairs[pair] = true;
573             timeSinceLastPair = block.timestamp;
574         }
575     }
576 
577     function isExcludedFromReward(address account) public view returns (bool) {
578         return _isExcluded[account];
579     }
580 
581     function isExcludedFromFee(address account) public view returns(bool) {
582         return _isExcludedFromFee[account];
583     }
584 
585     function isSniperOrBlacklisted(address account) public view returns (bool) {
586         return _isSniperOrBlacklisted[account];
587     }
588 
589     function setProtectionSettings(bool antiSnipe, bool antiGas, bool antiBlock) external onlyOwner() {
590         sniperProtection = antiSnipe;
591         gasLimitActive = antiGas;
592         sameBlockActive = antiBlock;
593     }
594 
595     function setGasPriceLimit(uint256 gas) external onlyOwner {
596         require(gas >= 75, "you fucking jeet");
597         gasPriceLimit = gas * 1 gwei;
598     }
599 
600     function setBlacklistEnabled(address account, bool enabled) external onlyOwner() {
601         _isSniperOrBlacklisted[account] = enabled;
602     }
603 
604     function setBlacklistMultipleEnabled(address[] memory account, bool enabled) external onlyOwner() {
605         for (uint i = 0; i < account.length; i++) {
606             _isSniperOrBlacklisted[account[i]] = enabled;
607         }
608     }
609     
610     function setTaxesBuy(uint256 reflect, uint256 liquidity, uint256 marketing) external onlyOwner {
611         require(reflect <= maxReflectFee
612                 && liquidity <= maxLiquidityFee
613                 && marketing <= maxMarketingFee
614                 );
615         require(reflect + liquidity + marketing <= 3450);
616         _buyReflectFee = reflect;
617         _buyLiquidityFee = liquidity;
618         _buyMarketingFee = marketing;
619     }
620 
621     function setTaxesSell(uint256 reflect, uint256 liquidity, uint256 marketing) external onlyOwner {
622         require(reflect <= maxReflectFee
623                 && liquidity <= maxLiquidityFee
624                 && marketing <= maxMarketingFee
625                 );
626         require(reflect + liquidity + marketing <= 3450);
627         _sellReflectFee = reflect;
628         _sellLiquidityFee = liquidity;
629         _sellMarketingFee = marketing;
630     }
631 
632     function setTaxesTransfer(uint256 reflect, uint256 liquidity, uint256 marketing) external onlyOwner {
633         require(reflect <= maxReflectFee
634                 && liquidity <= maxLiquidityFee
635                 && marketing <= maxMarketingFee
636                 );
637         require(reflect + liquidity + marketing <= 3450);
638         _transferReflectFee = reflect;
639         _transferLiquidityFee = liquidity;
640         _transferMarketingFee = marketing;
641     }
642 
643     function setRatios(uint256 liquidity, uint256 marketing) external onlyOwner {
644         _liquidityRatio = liquidity;
645         _marketingRatio = marketing;
646     }
647 
648     function setMaxTxPercent(uint256 percent, uint256 divisor) external onlyOwner {
649         uint256 check = (_tTotal * percent) / divisor;
650         require(check >= (_tTotal / 1000), "Max Transaction amt must be above 0.1% of total supply.");
651         _maxTxAmount = check;
652         maxTxAmountUI = (startingSupply * percent) / divisor;
653     }
654 
655     function setMaxWalletSize(uint256 percent, uint256 divisor) external onlyOwner {
656         uint256 check = (_tTotal * percent) / divisor;
657         require(check >= (_tTotal / 1000), "Max Wallet amt must be above 0.1% of total supply.");
658         _maxWalletSize = check;
659         maxWalletSizeUI = (startingSupply * percent) / divisor;
660     }
661 
662     function setSwapSettings(uint256 thresholdPercent, uint256 thresholdDivisor, uint256 amountPercent, uint256 amountDivisor) external onlyOwner {
663         swapThreshold = (_tTotal * thresholdPercent) / thresholdDivisor;
664         swapAmount = (_tTotal * amountPercent) / amountDivisor;
665     }
666 
667     function setMarketingWallet(address payable newWallet) external onlyOwner {
668         require(_marketingWallet != newWallet, "Wallet already set!");
669         _marketingWallet = payable(newWallet);
670     }
671 
672     function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
673         swapAndLiquifyEnabled = _enabled;
674         emit SwapAndLiquifyEnabledUpdated(_enabled);
675     }
676 
677     function setExcludedFromFee(address account, bool enabled) public onlyOwner {
678         _isExcludedFromFee[account] = enabled;
679     }
680 
681     function setExcludedFromReward(address account, bool enabled) public onlyOwner {
682         if (enabled == true) {
683             require(!_isExcluded[account], "Account is already excluded.");
684             if(_rOwned[account] > 0) {
685                 _tOwned[account] = tokenFromReflection(_rOwned[account]);
686             }
687             _isExcluded[account] = true;
688             _excluded.push(account);
689         } else if (enabled == false) {
690             require(_isExcluded[account], "Account is already included.");
691             for (uint256 i = 0; i < _excluded.length; i++) {
692                 if (_excluded[i] == account) {
693                     _excluded[i] = _excluded[_excluded.length - 1];
694                     _tOwned[account] = 0;
695                     _isExcluded[account] = false;
696                     _excluded.pop();
697                     break;
698                 }
699             }
700         }
701     }
702 
703     function totalFees() public view returns (uint256) {
704         return _tFeeTotal;
705     }
706 
707     function _hasLimits(address from, address to) internal view returns (bool) {
708         return from != owner()
709             && to != owner()
710             && !_liquidityHolders[to]
711             && !_liquidityHolders[from]
712             && to != DEAD
713             && to != address(0)
714             && from != address(this);
715     }
716 
717     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
718         require(rAmount <= _rTotal, "Amount must be less than total reflections");
719         uint256 currentRate =  _getRate();
720         return rAmount / currentRate;
721     }
722     
723     function _approve(address sender, address spender, uint256 amount) internal {
724         require(sender != address(0), "ERC20: approve from the zero address");
725         require(spender != address(0), "ERC20: approve to the zero address");
726 
727         _allowances[sender][spender] = amount;
728         emit Approval(sender, spender, amount);
729     }
730 
731     function _transfer(address from, address to, uint256 amount) internal returns (bool) {
732         require(from != address(0), "ERC20: transfer from the zero address");
733         require(to != address(0), "ERC20: transfer to the zero address");
734         require(amount > 0, "Transfer amount must be greater than zero");
735         if (gasLimitActive) {
736             require(tx.gasprice <= gasPriceLimit, "Gas price exceeds limit.");
737         }
738         if(_hasLimits(from, to)) {
739             if(!tradingEnabled) {
740                 revert("Trading not yet enabled!");
741             }
742             if (sameBlockActive) {
743                 if (lpPairs[from]){
744                     require(lastTrade[to] != block.number);
745                     lastTrade[to] = block.number;
746                 } else {
747                     require(lastTrade[from] != block.number);
748                     lastTrade[from] = block.number;
749                 }
750             }
751             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
752             if(to != _routerAddress && !lpPairs[to]) {
753                 require(balanceOf(to) + amount <= _maxWalletSize, "Transfer amount exceeds the maxWalletSize.");
754             }
755         }
756 
757         bool takeFee = true;
758         if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){
759             takeFee = false;
760         }
761 
762         if (lpPairs[to]) {
763             if (!inSwapAndLiquify
764                 && swapAndLiquifyEnabled
765             ) {
766                 uint256 contractTokenBalance = balanceOf(address(this));
767                 if (contractTokenBalance >= swapThreshold) {
768                     if(contractTokenBalance >= swapAmount) { contractTokenBalance = swapAmount; }
769                     swapAndLiquify(contractTokenBalance);
770                 }
771             }      
772         } 
773         return _finalizeTransfer(from, to, amount, takeFee);
774     }
775 
776     function swapAndLiquify(uint256 contractTokenBalance) internal lockTheSwap {
777         if (_liquidityRatio + _marketingRatio == 0)
778             return;
779         uint256 toLiquify = ((contractTokenBalance * _liquidityRatio) / (_liquidityRatio + _marketingRatio)) / 2;
780 
781         uint256 toSwapForEth = contractTokenBalance - toLiquify;
782 
783         address[] memory path = new address[](2);
784         path[0] = address(this);
785         path[1] = dexRouter.WETH();
786 
787         dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
788             toSwapForEth,
789             0,
790             path,
791             address(this),
792             block.timestamp
793         );
794 
795 
796         uint256 liquidityBalance = ((address(this).balance * _liquidityRatio) / (_liquidityRatio + _marketingRatio)) / 2;
797 
798         if (toLiquify > 0) {
799             dexRouter.addLiquidityETH{value: liquidityBalance}(
800                 address(this),
801                 toLiquify,
802                 0, 
803                 0, 
804                 DEAD,
805                 block.timestamp
806             );
807             emit SwapAndLiquify(toLiquify, liquidityBalance, toLiquify);
808         }
809         if (contractTokenBalance - toLiquify > 0) {
810             _marketingWallet.transfer(address(this).balance);
811         }
812     }
813 
814     
815 
816     function _checkLiquidityAdd(address from, address to) internal {
817         require(!_hasLiqBeenAdded, "Liquidity already added and marked.");
818         if (!_hasLimits(from, to) && to == lpPair) {
819             _liquidityHolders[from] = true;
820             _hasLiqBeenAdded = true;
821             _liqAddStamp = block.timestamp;
822 
823             swapAndLiquifyEnabled = true;
824             emit SwapAndLiquifyEnabledUpdated(true);
825         }
826     }
827 
828     function enableTrading() public onlyOwner {
829         require(!tradingEnabled, "Trading already enabled!");
830         setExcludedFromReward(address(this), true);
831         setExcludedFromReward(lpPair, true);
832         if (snipeBlockAmt > 3) {
833             _liqAddBlock = block.number + 500;
834         } else {
835             _liqAddBlock = block.number;
836         }
837         tradingEnabled = true;
838     }
839 
840     struct ExtraValues {
841         uint256 tTransferAmount;
842         uint256 tFee;
843         uint256 tLiquidity;
844 
845         uint256 rTransferAmount;
846         uint256 rAmount;
847         uint256 rFee;
848     }
849 
850     function _finalizeTransfer(address from, address to, uint256 tAmount, bool takeFee) internal returns (bool) {
851         if (sniperProtection){
852             if (isSniperOrBlacklisted(from) || isSniperOrBlacklisted(to)) {
853                 revert("Rejected.");
854             }
855 
856             if (!_hasLiqBeenAdded) {
857                 _checkLiquidityAdd(from, to);
858                 if (!_hasLiqBeenAdded && _hasLimits(from, to)) {
859                     revert("Only owner can transfer at this time.");
860                 }
861             } else {
862                 if (_liqAddBlock > 0 
863                     && lpPairs[from] 
864                     && _hasLimits(from, to)
865                 ) {
866                     if (block.number - _liqAddBlock < snipeBlockAmt) {
867                         _isSniperOrBlacklisted[to] = true;
868                         snipersCaught ++;
869                         emit SniperCaught(to);
870                     }
871                 }
872             }
873         }
874 
875         ExtraValues memory values = _getValues(from, to, tAmount, takeFee);
876 
877         _rOwned[from] = _rOwned[from] - values.rAmount;
878         _rOwned[to] = _rOwned[to] + values.rTransferAmount;
879 
880         if (_isExcluded[from] && !_isExcluded[to]) {
881             _tOwned[from] = _tOwned[from] - tAmount;
882         } else if (!_isExcluded[from] && _isExcluded[to]) {
883             _tOwned[to] = _tOwned[to] + values.tTransferAmount;  
884         } else if (_isExcluded[from] && _isExcluded[to]) {
885             _tOwned[from] = _tOwned[from] - tAmount;
886             _tOwned[to] = _tOwned[to] + values.tTransferAmount;
887         }
888 
889         if (values.tLiquidity > 0)
890             _takeLiquidity(from, values.tLiquidity);
891         if (values.rFee > 0 || values.tFee > 0)
892             _takeReflect(values.rFee, values.tFee);
893 
894         emit Transfer(from, to, values.tTransferAmount);
895         return true;
896     }
897 
898     function _getValues(address from, address to, uint256 tAmount, bool takeFee) internal returns (ExtraValues memory) {
899         ExtraValues memory values;
900         uint256 currentRate = _getRate();
901 
902         values.rAmount = tAmount * currentRate;
903 
904         if(takeFee) {
905             if (lpPairs[to]) {
906                 _reflectFee = _sellReflectFee;
907                 _liquidityFee = _sellLiquidityFee;
908                 _marketingFee = _sellMarketingFee;
909             } else if (lpPairs[from]) {
910                 _reflectFee = _buyReflectFee;
911                 _liquidityFee = _buyLiquidityFee;
912                 _marketingFee = _buyMarketingFee;
913             } else {
914                 _reflectFee = _transferReflectFee;
915                 _liquidityFee = _transferLiquidityFee;
916                 _marketingFee = _transferMarketingFee;
917             }
918 
919             values.tFee = (tAmount * _reflectFee) / masterTaxDivisor;
920             values.tLiquidity = (tAmount * (_liquidityFee + _marketingFee)) / masterTaxDivisor;
921             values.tTransferAmount = tAmount - (values.tFee + values.tLiquidity);
922 
923             values.rFee = values.tFee * currentRate;
924         } else {
925             values.tFee = 0;
926             values.tLiquidity = 0;
927             values.tTransferAmount = tAmount;
928 
929             values.rFee = 0;
930         }
931 
932         values.rTransferAmount = values.rAmount - (values.rFee + (values.tLiquidity * currentRate));
933         return values;
934     }
935 
936     function _getRate() internal view returns(uint256) {
937         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
938         return rSupply / tSupply;
939     }
940 
941     function _getCurrentSupply() internal view returns(uint256, uint256) {
942         uint256 rSupply = _rTotal;
943         uint256 tSupply = _tTotal;
944         for (uint256 i = 0; i < _excluded.length; i++) {
945             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
946             rSupply = rSupply - _rOwned[_excluded[i]];
947             tSupply = tSupply - _tOwned[_excluded[i]];
948         }
949         if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);
950         return (rSupply, tSupply);
951     }
952     
953     function _takeReflect(uint256 rFee, uint256 tFee) internal {
954         _rTotal = _rTotal - rFee;
955         _tFeeTotal = _tFeeTotal + tFee;
956     }
957 
958     function rescueETH() external onlyOwner {
959         payable(owner()).transfer(address(this).balance);
960     }
961     
962     function _takeLiquidity(address sender, uint256 tLiquidity) internal {
963         uint256 currentRate =  _getRate();
964         uint256 rLiquidity = tLiquidity * currentRate;
965         _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;
966         if(_isExcluded[address(this)])
967             _tOwned[address(this)] = _tOwned[address(this)] + tLiquidity;
968         emit Transfer(sender, address(this), tLiquidity); // Transparency is the key to success.
969     }
970 }