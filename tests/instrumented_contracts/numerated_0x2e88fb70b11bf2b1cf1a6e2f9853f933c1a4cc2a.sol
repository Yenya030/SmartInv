1 {{
2   "language": "Solidity",
3   "sources": {
4     "jiggle/jiggleosonchain.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n/**\n * @title JiggleOs-On-Chain contract\n * @author Jiggle Labs\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\n * @notice Generate 4294967295 free JiggleOs with the option to mint 10000\n * @notice This project is self-contained inside this non-upgradeable, one-page contract\n *\n *         gg                                                     _,gggggg,_\n *        dP8,                                   ,dPYb,         ,d8P\"\"d8P\"Y8b,\n *       dP Yb                                   IP'`Yb        ,d8'   Y8   \"8b,dP\n *      ,8  `8,     gg                           I8  8I        d8'    `Ybaaad88P'\n *      I8   Yb     \"\"                           I8  8'        8P       `\"\"\"\"Y8\n *      `8b, `8,    gg     ,gggg,gg    ,gggg,gg  I8 dP   ,ggg, 8b            d8  ,g,\n *       `\"Y88888   88    dP\"  \"Y8I   dP\"  \"Y8I  I8dP   i8\" \"8iY8,          ,8P ,8'8,\n *           \"Y8    88   i8'    ,8I  i8'    ,8I  I8P    I8, ,8I`Y8,        ,8P',8'  Yb\n *            ,88,_,88,_,d8,   ,d8I ,d8,   ,d8I ,d8b,_  `YbadP' `Y8b,,__,,d8P',8'_   8)\n *        ,ad888888P\"\"Y8P\"Y8888P\"888P\"Y8888P\"8888P'\"Y88888P\"Y888  `\"Y8888P\"'  P' \"YY8P8P\n *      ,dP\"'   Yb             ,d8I'       ,d8I'\n *     ,8'      I8           ,dP'8I      ,dP'8I   Jiggleos-On-Chain is a collection of 10,000\n *    ,8'       I8          ,8\"  8I     ,8\"  8I   unique animations created by the minters out\n *    I8,      ,8'          I8   8I     I8   8I   of a possible 4,294,967,295. It's a very long,\n *    `Y8,___,d8'           `8, ,8I     `8, ,8I   if not the longest animated film ever made.\n *      \"Y888P\"              `Y8P\"       `Y8P\".\n */\nlibrary Base64 {\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        string memory table = TABLE;\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 32)\n            for {} lt(dataPtr, endPtr) {}{\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        return result;\n    }\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary Counters {\n    struct Counter {\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n    unchecked {\n        counter._value += 1;\n    }\n    }\n}\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n        interfaceId == type(IERC721).interfaceId ||\n        interfaceId == type(IERC721Metadata).interfaceId ||\n        super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\ncontract JiggleosOnChain is ERC721, ReentrancyGuard, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _nextTokenId;\n    using Strings for uint256;\n    bool public saleON = false;\n    string public base_external_url;\n    string public base_img_url;\n    string public youtube_url;\n    string public img_suffix;\n    string internal constant head = '<svg id=\"JSVG\" viewBox=\"0 0 1000 1000\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"> \\n <title>JiggleOs-On-Chain - Generative Ethereum Animation</title> \\n <script>//<![CDATA[\\n document.addEventListener(\"DOMContentLoaded\",function(){ class R{constructor(S){this.S=S;}r_d(){this.S^=this.S<<13;this.S^=this.S>>17;this.S^=this.S<<5;return((this.S<0?~this.S+1:this.S)%1000)/1000;}r_b(a,b){return a+(b-a)*this.r_d();}r_i(a,b){return Math.floor(this.r_b(a,b+1));}r_c(x){return x[Math.floor(this.r_b(0,x.length*0.99))];}};const S=';\n    string internal constant tail = ';const r=new R(S);const ns=\"http://www.w3.org/2000/svg\";const dX=r.r_i(-5,5);const dY=r.r_i(-5,5);const rF=r.r_b(1,5);const cF=r.r_b(5,15);const ra=r.r_c([30,60,90,120,150.180]);let s=1000;let l=r.r_b(1,360);let lR=(l+180)%360;const bg=document.createElementNS(ns,\"rect\");bg.setAttribute(\"width\",s);bg.setAttribute(\"height\",s);bg.setAttribute(\"fill\",\"hsl(\"+lR+\",100%,50%)\");document.getElementById(\"JSVG\").appendChild(bg);let rt=[];for(let i=0;i<200;i++){ let mR=document.createElementNS(ns,\"rect\");mR.setAttribute(\"x\",r.r_b(0,s));mR.setAttribute(\"y\",r.r_b(0,s));mR.setAttribute(\"width\",r.r_b(1,s/rF));mR.setAttribute(\"height\",r.r_b(1,s/rF));mR.setAttribute(\"fill\",\"hsl(\"+((r.r_b(0,1)*(lR+ra-(lR-ra)))+(lR-ra))+\",\"+((r.r_b(70,100)))+\"%\"+\",\"+((r.r_b(50,80)))+\"%\");mR.setAttribute(\"fill-opacity\",(r.r_b(.8,1)));mR.setAttributeNS(null,\"clip-path\",\"url(#clip)\");document.getElementById(\"JSVG\").appendChild(mR);rt.push(mR);};let cr=[];for(let i=0;i<200;i++){ let mC=document.createElementNS(ns,\"circle\");mC.setAttribute(\"cx\",r.r_b(1,1000));mC.setAttribute(\"cy\",r.r_b(1,1000));mC.setAttribute(\"r\",r.r_b(2,cF));mC.setAttribute(\"fill\",\"hsl(\"+((r.r_b(0,1)*(l+ra-(l-ra)))+(l-ra))+\",\"+((r.r_b(80,100)))+\"%\"+\",\"+((r.r_b(50,100)))+\"%\");mC.setAttribute(\"fill-opacity\",(r.r_b(.8,1)));mC.setAttributeNS(null,\"clip-path\",\"url(#clip)\");document.getElementById(\"JSVG\").appendChild(mC);cr.push(mC);};let clippath=document.createElementNS(ns,\"clipPath\");clippath.setAttributeNS(null,\"id\",\"clip\");document.getElementById(\"JSVG\").appendChild(clippath);let rect=document.createElementNS(ns,\"rect\");rect.setAttributeNS(null,\"x\",\"0\");rect.setAttributeNS(null,\"y\",\"0\");rect.setAttributeNS(null,\"width\",\"1000\");rect.setAttributeNS(null,\"height\",\"1000\");clippath.appendChild(rect);function jR(){ for(let i=0;i<rt.length;i++){let mR=rt[i];let x=parseInt(mR.getAttribute(\"x\"));let y=parseInt(mR.getAttribute(\"y\"));if(x<-mR.getAttribute(\"width\")){x=1000;}else if(x>1000){x=-mR.getAttribute(\"width\");}if(y<-mR.getAttribute(\"height\")){y=1000;}else if(y>1000){y=-mR.getAttribute(\"height\");}mR.setAttribute(\"x\",x+(r.r_b(0,2))*dX);mR.setAttribute(\"y\",y+(r.r_b(0,2))*dY);}}function jC(){ for(let i=0;i<cr.length;i++){let mC=cr[i];let x=parseInt(mC.getAttribute(\"cx\"));let y=parseInt(mC.getAttribute(\"cy\"));if(x<-mC.getAttribute(\"width\")*3){x=1000;}else if(x>1000){x=-mC.getAttribute(\"width\");}if(y<-mC.getAttribute(\"height\")*2){y=1000;}else if(y>1000){y=-mC.getAttribute(\"height\");}mC.setAttribute(\"cx\",x+(r.r_b(0,2))*dX);mC.setAttribute(\"cy\",y+(r.r_b(0,2))*dY);}}setInterval(jR,r.r_i(25, 75));setInterval(jC,r.r_i(25, 75));}); \\n //]]> \\n </script> \\n </svg>';\n    string internal constant logo = '<svg viewBox=\"0 0 1000 1000\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"><title>JiggleOs-On-Chain Logo</title><path fill=\"#6c9\" d=\"M0 0h1000v1000H0z\"/><path fill=\"#fff\" d=\"M677 76c-7 0-137 31-193 81-1 1-363 344-396 435-86 237 208 436 398 274 127-108 258-238 380-361 136-159 41-429-189-429z\"/><path d=\"M427 324c0 340 514 333 505 0-5-332-505-332-505-1zm318 55c9 144-201 78-168 51 22-15 121 28 118-51 2-194-3-220 25-220 29 0 25 18 25 220z\"/></svg>';\n\n    mapping (uint => uint) public idToSeed;\n    mapping (uint => uint) public seedToId;\n    mapping (uint => string) public idToName;\n    mapping (uint => address) public idToSeeder;\n\n    constructor() ERC721(\"JiggleOs-On-Chain\", \"JOC\") {\n        _nextTokenId.increment();\n        //@dev alternate url: jiggleos.crypto\n        base_external_url = \"https://jiggleos.com/\";\n        base_img_url = \"https://jiggleos.com/\";\n        img_suffix = \".gif\";\n        youtube_url = \"https://www.youtube.com/channel/UCEGGbojYdDQOKk6dUQQeH2A\";\n    }\n\n    //@notice This function mints 10000 unique JiggleOs for 0.1 ether each\n    //@notice The seed number must be unique, between 1 and 4294967295\n    //@notice The name can be anything between 1 and 32 characters\n    //@notice Once minted, the seed and name are unchangeable. Choose wisely\n    //@notice The minter, the one who provides the seed and name, is the director\n\n    function mint(uint32 seed, string memory name) external payable nonReentrant {\n        uint id = _nextTokenId.current();\n\n        require(nameLength(name) == true, \"Name must be between 1-32 characters\");\n        require(id < 10001, \"Sold out\");\n        require(seedToId[seed] == 0, \"Seed already minted\");\n\n        if (msg.sender != owner()) {\n            require(saleON, \"Sale OFF\");\n            require(msg.value == 0.1 ether);\n        }\n\n        idToName[id] = name;\n        idToSeeder[id] = msg.sender;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n\n        _nextTokenId.increment();\n        _mint(msg.sender, id);\n    }\n\n    function drawSVG(uint256 _tokenId) internal view returns(string memory) {\n        uint256 currentSeed = (idToSeed[_tokenId]);\n        return Base64.encode(bytes(\n                abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )));\n    }\n\n    function drawLOGO() internal pure returns(string memory) {\n        return Base64.encode(bytes(\n                abi.encodePacked(\n                    logo\n                )));\n    }\n\n    //@notice This function generates 4 billion unique free JiggleOs!\n    //@notice The seed number must be unique between 1 and 4294967295\n    //@notice The seed must not be one that has already been minted\n    function drawFreeSVG(uint32 _seed) public view returns(string memory) {\n        require(seedToId[_seed] == 0, \"Seed already minted\");\n        uint256 currentSeed = _seed;\n        return string(abi.encodePacked(\n                'data:image/svg+xml;base64,', Base64.encode(bytes(abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )))));\n    }\n\n    //@notice Both \"image_data\" and \"animation_url\" return immutable and lossless original art\n    //@notice The \"image\" returns a fallback raster preview of the original art for compatibility\n  function tokenURI(uint256 _tokenId) public view virtual override returns(string memory) {\n      require(_exists(_tokenId),\"Nonexistent token\");\n        string memory director = Strings.toHexString(uint256(uint160(idToSeeder[_tokenId])), 20);\n        string memory seed = (idToSeed[_tokenId]).toString();\n        return string(abi.encodePacked(\n                'data:application/json;base64,', Base64.encode(bytes(abi.encodePacked(\n                    '{\"name\":\"', idToName[_tokenId],\n                    '\", \"description\":\"', 'JiggleO #', _tokenId.toString(),\n                    '\", \"attributes\": [{\"trait_type\": \"Director\", \"value\": \"', director,\n                    '\"},{\"trait_type\": \"Seed\", \"value\": \"', seed,\n                    '\"}], \"external_url\":\"', base_external_url, _tokenId.toString(),\n                    '\", \"image\":\"', base_img_url, _tokenId.toString(), img_suffix,\n                    '\", \"image_data\": \"', 'data:image/svg+xml;base64,', drawSVG(_tokenId),\n                    '\", \"animation_url\": \"','data:image/svg+xml;base64,', drawSVG(_tokenId),\n                    '\", \"youtube_url\":\"', youtube_url,\n                    '\"}'\n                    )))));\n    }\n\n    function contractURI() external view returns(string memory) {\n        string memory beneficiary = Strings.toHexString(uint256(uint160(owner())), 20);\n        return string(abi.encodePacked(\n                'data:application/json;base64,', Base64.encode(bytes(abi.encodePacked(\n                    '{\"name\":\"', 'Jiggleos-On-Chain',\n                    '\", \"description\":\"', 'Jiggleos-On-Chain - 10,000 Generative Ethereum Animations',\n                    '\",  \"external_url\":\"', base_external_url,\n                    '\", \"image\": \"', 'data:image/svg+xml;base64,', drawLOGO(),\n                    '\", \"seller_fee_basis_points\": \"', '250',\n                    '\", \"fee_recipient\": \"', beneficiary,\n                    '\"}'\n                    )))));\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _nextTokenId.current() - 1;\n    }\n\n    function remainingSupply() external view returns (uint256) {\n        return 10000 - _nextTokenId.current() + 1;\n    }\n\n    function nameLength(string memory str) internal pure returns (bool){\n        bytes memory b = bytes(str);\n        if(b.length < 1) return false;\n        if(b.length > 32) return false;\n        return true;\n    }\n\n    function toggleSale() external onlyOwner {\n        saleON = !saleON;\n    }\n\n    function setBaseExternalURL(string memory url) external onlyOwner {\n        base_external_url = url;\n    }\n\n    function setBaseImgURL(string memory url) external onlyOwner {\n        base_img_url = url;\n    }\n\n    function setYoutubeURL(string memory url) external onlyOwner {\n        youtube_url = url;\n    }\n\n    function setImgSuffix(string memory suffix) external onlyOwner {\n        img_suffix = suffix;\n    }\n\n    function withdraw() external payable onlyOwner {\n        (bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\n        require(os);\n    }\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": false,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}