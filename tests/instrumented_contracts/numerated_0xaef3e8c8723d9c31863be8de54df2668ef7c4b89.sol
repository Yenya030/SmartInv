1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/core/SoundCreatorV1.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\n/*\n                 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n               ▒███████████████████████████████████████████████████████████\n               ▒███████████████████████████████████████████████████████████\n ▒▓▓▓▓▓▓▓▓▓▓▓▓▓████████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████████████████████▓▒▒▒▒▒▒▒▒▒▒▒▒▒\n █████████████████████████████▓              ████████████████████████████████████████████\n █████████████████████████████▓              ████████████████████████████████████████████\n █████████████████████████████▓               ▒▒▒▒▒▒▒▒▒▒▒▒▒██████████████████████████████\n █████████████████████████████▓                            ▒█████████████████████████████\n █████████████████████████████▓                             ▒████████████████████████████\n █████████████████████████████████████████████████████████▓\n ███████████████████████████████████████████████████████████\n ███████████████████████████████████████████████████████████▒\n                              ███████████████████████████████████████████████████████████▒\n                              ▓██████████████████████████████████████████████████████████▒\n                               ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓███████████████████████████████▒\n █████████████████████████████                             ▒█████████████████████████████▒\n ██████████████████████████████                            ▒█████████████████████████████▒\n ██████████████████████████████▓▒▒▒▒▒▒▒▒▒▒▒▒▒              ▒█████████████████████████████▒\n ████████████████████████████████████████████▒             ▒█████████████████████████████▒\n ████████████████████████████████████████████▒             ▒█████████████████████████████▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒███████████████████████████████▓▓▓▓▓▓▓▓▓▓▓▓▓███████████████▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n               ▓█████████████████████████████████████████████████████████▒\n               ▓██████████████████████████████████████████████████████████\n*/\n\nimport { Clones } from \"openzeppelin/proxy/Clones.sol\";\nimport { UUPSUpgradeable } from \"openzeppelin-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport { ISoundCreatorV1 } from \"./interfaces/ISoundCreatorV1.sol\";\nimport { ISoundEditionV1 } from \"./interfaces/ISoundEditionV1.sol\";\nimport { IMetadataModule } from \"./interfaces/IMetadataModule.sol\";\n\nimport { OwnableRoles } from \"solady/auth/OwnableRoles.sol\";\n\n/**\n * @title SoundCreatorV1\n * @notice A factory that deploys minimal proxies of `SoundEditionV1.sol`.\n * @dev The proxies are OpenZeppelin's Clones implementation of https://eips.ethereum.org/EIPS/eip-1167\n */\ncontract SoundCreatorV1 is ISoundCreatorV1, OwnableRoles {\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    /**\n     * @dev The implementation contract delegated to by Sound edition proxies.\n     */\n    address public soundEditionImplementation;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(address _soundEditionImplementation) implementationNotZero(_soundEditionImplementation) {\n        soundEditionImplementation = _soundEditionImplementation;\n        _initializeOwner(msg.sender);\n    }\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @inheritdoc ISoundCreatorV1\n     */\n    function createSoundAndMints(\n        bytes32 salt,\n        bytes calldata initData,\n        address[] calldata contracts,\n        bytes[] calldata data\n    ) external returns (address soundEdition, bytes[] memory results) {\n        // Create Sound Edition proxy.\n        soundEdition = payable(Clones.cloneDeterministic(soundEditionImplementation, _saltedSalt(msg.sender, salt)));\n\n        // Initialize proxy.\n        assembly {\n            // Grab the free memory pointer.\n            let m := mload(0x40)\n            // Copy the `initData` to the free memory.\n            calldatacopy(m, initData.offset, initData.length)\n            // Call the initializer, and revert if the call fails.\n            if iszero(\n                call(\n                    gas(), // Gas remaining.\n                    soundEdition, // Address of the edition.\n                    0, // `msg.value` of the call: 0 ETH.\n                    m, // Start of input.\n                    initData.length, // Length of input.\n                    0x00, // Start of output. Not used.\n                    0x00 // Size of output. Not used.\n                )\n            ) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n        }\n\n        results = _callContracts(contracts, data);\n\n        OwnableRoles(soundEdition).transferOwnership(msg.sender);\n\n        emit SoundEditionCreated(soundEdition, msg.sender, initData, contracts, data, results);\n    }\n\n    /**\n     * @inheritdoc ISoundCreatorV1\n     */\n    function setEditionImplementation(address newImplementation)\n        external\n        onlyOwner\n        implementationNotZero(newImplementation)\n    {\n        soundEditionImplementation = newImplementation;\n\n        emit SoundEditionImplementationSet(soundEditionImplementation);\n    }\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @inheritdoc ISoundCreatorV1\n     */\n    function soundEditionAddress(address by, bytes32 salt) external view returns (address addr, bool exists) {\n        addr = Clones.predictDeterministicAddress(soundEditionImplementation, _saltedSalt(by, salt), address(this));\n        exists = addr.code.length > 0;\n    }\n\n    // =============================================================\n    //                  INTERNAL / PRIVATE HELPERS\n    // =============================================================\n\n    /**\n     * @dev Call the `contracts` in order with `data`.\n     * @param contracts The addresses of the contracts.\n     * @param data      The `abi.encodeWithSelector` calldata for each of the contracts.\n     * @return results The results of calling the contracts.\n     */\n    function _callContracts(address[] calldata contracts, bytes[] calldata data)\n        internal\n        returns (bytes[] memory results)\n    {\n        if (contracts.length != data.length) revert ArrayLengthsMismatch();\n\n        assembly {\n            // Grab the free memory pointer.\n            // We will use the free memory to construct the `results` array,\n            // and also as a temporary space for the calldata.\n            results := mload(0x40)\n            // Set `results.length` to be equal to `data.length`.\n            mstore(results, data.length)\n            // Skip the first word, which is used to store the length\n            let resultsOffsets := add(results, 0x20)\n            // Compute the location of the last calldata offset in `data`.\n            // `shl(5, n)` is a gas-saving shorthand for `mul(0x20, n)`.\n            let dataOffsetsEnd := add(data.offset, shl(5, data.length))\n            // This is the start of the unused free memory.\n            // We use it to temporarily store the calldata to call the contracts.\n            let m := add(resultsOffsets, shl(5, data.length))\n\n            // Loop through `contacts` and `data` together.\n            // prettier-ignore\n            for { let i := data.offset } iszero(eq(i, dataOffsetsEnd)) { i := add(i, 0x20) } {\n                // Location of `bytes[i]` in calldata.\n                let o := add(data.offset, calldataload(i))\n                // Copy `bytes[i]` from calldata to the free memory.\n                calldatacopy(\n                    m, // Start of the unused free memory.\n                    add(o, 0x20), // Location of starting byte of `data[i]` in calldata.\n                    calldataload(o) // The length of the `bytes[i]`.\n                )\n                // Grab `contracts[i]` from the calldata.\n                // As `contracts` is the same length as `data`,\n                // `sub(i, data.offset)` gives the relative offset to apply to\n                // `contracts.offset` for `contracts[i]` to match `data[i]`.\n                let c := calldataload(add(contracts.offset, sub(i, data.offset)))\n                // Call the contract, and revert if the call fails.\n                if iszero(\n                    call(\n                        gas(), // Gas remaining.\n                        c, // `contracts[i]`.\n                        0, // `msg.value` of the call: 0 ETH.\n                        m, // Start of the copy of `bytes[i]` in memory.\n                        calldataload(o), // The length of the `bytes[i]`.\n                        0x00, // Start of output. Not used.\n                        0x00 // Size of output. Not used.\n                    )\n                ) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                // Append the current `m` into `resultsOffsets`.\n                mstore(resultsOffsets, m)\n                resultsOffsets := add(resultsOffsets, 0x20)\n\n                // Append the `returndatasize()` to `results`.\n                mstore(m, returndatasize())\n                // Append the return data to `results`.\n                returndatacopy(add(m, 0x20), 0x00, returndatasize())\n                // Advance `m` by `returndatasize() + 0x20`,\n                // rounded up to the next multiple of 32.\n                // `0x3f = 32 + 31`. The mask is `type(uint64).max & ~31`,\n                // which is big enough for all purposes (see memory expansion costs).\n                m := and(add(add(m, returndatasize()), 0x3f), 0xffffffffffffffe0)\n            }\n            // Allocate the memory for `results` by updating the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /**\n     * @dev Returns the salted salt.\n     *      To prevent griefing and accidental collisions from clients that don't\n     *      generate their salt properly.\n     * @param by   The caller of the {createSoundAndMints} function.\n     * @param salt The salt, generated on the client side.\n     * @return result The computed value.\n     */\n    function _saltedSalt(address by, bytes32 salt) internal pure returns (bytes32 result) {\n        assembly {\n            // Store the variables into the scratch space.\n            mstore(0x00, by)\n            mstore(0x20, salt)\n            // Equivalent to `keccak256(abi.encode(by, salt))`.\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Reverts if the given implementation address is zero.\n     * @param implementation The address of the implementation.\n     */\n    modifier implementationNotZero(address implementation) {\n        if (implementation == address(0)) {\n            revert ImplementationAddressCantBeZero();\n        }\n        _;\n    }\n}\n"
6     },
7     "lib/openzeppelin-contracts/contracts/proxy/Clones.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
9     },
10     "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
12     },
13     "contracts/core/interfaces/ISoundCreatorV1.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { IMetadataModule } from \"./IMetadataModule.sol\";\n\n/**\n * @title ISoundCreatorV1\n * @notice The interface for the Sound edition factory.\n */\ninterface ISoundCreatorV1 {\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when an edition is created.\n     * @param soundEdition The address of the edition.\n     * @param deployer     The address of the deployer.\n     * @param initData     The calldata to initialize SoundEdition via `abi.encodeWithSelector`.\n     * @param contracts    The list of contracts called.\n     * @param data         The list of calldata created via `abi.encodeWithSelector`\n     * @param results      The results of calling the contracts. Use `abi.decode` to decode them.\n     */\n    event SoundEditionCreated(\n        address indexed soundEdition,\n        address indexed deployer,\n        bytes initData,\n        address[] contracts,\n        bytes[] data,\n        bytes[] results\n    );\n\n    /**\n     * @dev Emitted when the edition implementation address is set.\n     * @param newImplementation The new implementation address to be set.\n     */\n    event SoundEditionImplementationSet(address newImplementation);\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev Thrown if the implementation address is zero.\n     */\n    error ImplementationAddressCantBeZero();\n\n    /**\n     * @dev Thrown if the lengths of the input arrays are not equal.\n     */\n    error ArrayLengthsMismatch();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Creates a Sound Edition proxy, initializes it,\n     *      and creates mint configurations on a given set of minter addresses.\n     * @param salt      The salt used for the CREATE2 to deploy the clone to a\n     *                  deterministic address.\n     * @param initData  The calldata to initialize SoundEdition via\n     *                  `abi.encodeWithSelector`.\n     * @param contracts A list of contracts to call.\n     * @param data      A list of calldata created via `abi.encodeWithSelector`\n     *                  This must contain the same number of entries as `contracts`.\n     * @return soundEdition Returns the address of the created contract.\n     * @return results      The results of calling the contracts.\n     *                      Use `abi.decode` to decode them.\n     */\n    function createSoundAndMints(\n        bytes32 salt,\n        bytes calldata initData,\n        address[] calldata contracts,\n        bytes[] calldata data\n    ) external returns (address soundEdition, bytes[] memory results);\n\n    /**\n     * @dev Changes the SoundEdition implementation contract address.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract.\n     *\n     * @param newImplementation The new implementation address to be set.\n     */\n    function setEditionImplementation(address newImplementation) external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev The address of the sound edition implementation.\n     * @return The configured value.\n     */\n    function soundEditionImplementation() external returns (address);\n\n    /**\n     * @dev Returns the deterministic address for the sound edition clone.\n     * @param by   The caller of the {createSoundAndMints} function.\n     * @param salt The salt, generated on the client side.\n     * @return addr The computed address.\n     * @return exists Whether the contract exists.\n     */\n    function soundEditionAddress(address by, bytes32 salt) external view returns (address addr, bool exists);\n}\n"
15     },
16     "contracts/core/interfaces/ISoundEditionV1.sol": {
17       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { IERC721AUpgradeable } from \"chiru-labs/ERC721A-Upgradeable/IERC721AUpgradeable.sol\";\nimport { IERC2981Upgradeable } from \"openzeppelin-upgradeable/interfaces/IERC2981Upgradeable.sol\";\nimport { IERC165Upgradeable } from \"openzeppelin-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\nimport { IMetadataModule } from \"./IMetadataModule.sol\";\n\n/**\n * @dev The information pertaining to this edition.\n */\nstruct EditionInfo {\n    // Base URI for the tokenId.\n    string baseURI;\n    // Contract URI for OpenSea storefront.\n    string contractURI;\n    // Name of the collection.\n    string name;\n    // Symbol of the collection.\n    string symbol;\n    // Address that receives primary and secondary royalties.\n    address fundingRecipient;\n    // The current max mintable amount;\n    uint32 editionMaxMintable;\n    // The lower limit of the maximum number of tokens that can be minted.\n    uint32 editionMaxMintableUpper;\n    // The upper limit of the maximum number of tokens that can be minted.\n    uint32 editionMaxMintableLower;\n    // The timestamp (in seconds since unix epoch) after which the\n    // max amount of tokens mintable will drop from\n    // `maxMintableUpper` to `maxMintableLower`.\n    uint32 editionCutoffTime;\n    // Address of metadata module, address(0x00) if not used.\n    address metadataModule;\n    // The current mint randomness value.\n    uint256 mintRandomness;\n    // The royalty BPS (basis points).\n    uint16 royaltyBPS;\n    // Whether the mint randomness is enabled.\n    bool mintRandomnessEnabled;\n    // Whether the mint has concluded.\n    bool mintConcluded;\n    // Whether the metadata has been frozen.\n    bool isMetadataFrozen;\n    // Next token ID to be minted.\n    uint256 nextTokenId;\n    // Total number of tokens burned.\n    uint256 totalBurned;\n    // Total number of tokens minted.\n    uint256 totalMinted;\n    // Total number of tokens currently in existence.\n    uint256 totalSupply;\n}\n\n/**\n * @title ISoundEditionV1\n * @notice The interface for Sound edition contracts.\n */\ninterface ISoundEditionV1 is IERC721AUpgradeable, IERC2981Upgradeable {\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when the metadata module is set.\n     * @param metadataModule the address of the metadata module.\n     */\n    event MetadataModuleSet(address metadataModule);\n\n    /**\n     * @dev Emitted when the `baseURI` is set.\n     * @param baseURI the base URI of the edition.\n     */\n    event BaseURISet(string baseURI);\n\n    /**\n     * @dev Emitted when the `contractURI` is set.\n     * @param contractURI The contract URI of the edition.\n     */\n    event ContractURISet(string contractURI);\n\n    /**\n     * @dev Emitted when the metadata is frozen (e.g.: `baseURI` can no longer be changed).\n     * @param metadataModule The address of the metadata module.\n     * @param baseURI        The base URI of the edition.\n     * @param contractURI    The contract URI of the edition.\n     */\n    event MetadataFrozen(address metadataModule, string baseURI, string contractURI);\n\n    /**\n     * @dev Emitted when the `fundingRecipient` is set.\n     * @param fundingRecipient The address of the funding recipient.\n     */\n    event FundingRecipientSet(address fundingRecipient);\n\n    /**\n     * @dev Emitted when the `royaltyBPS` is set.\n     * @param bps The new royalty, measured in basis points.\n     */\n    event RoyaltySet(uint16 bps);\n\n    /**\n     * @dev Emitted when the edition's maximum mintable token quantity range is set.\n     * @param editionMaxMintableLower_ The lower limit of the maximum number of tokens that can be minted.\n     * @param editionMaxMintableUpper_ The upper limit of the maximum number of tokens that can be minted.\n     */\n    event EditionMaxMintableRangeSet(uint32 editionMaxMintableLower_, uint32 editionMaxMintableUpper_);\n\n    /**\n     * @dev Emitted when the edition's cutoff time set.\n     * @param editionCutoffTime_ The timestamp.\n     */\n    event EditionCutoffTimeSet(uint32 editionCutoffTime_);\n\n    /**\n     * @dev Emitted when the `mintRandomnessEnabled` is set.\n     * @param mintRandomnessEnabled_ The boolean value.\n     */\n    event MintRandomnessEnabledSet(bool mintRandomnessEnabled_);\n\n    /**\n     * @dev Emitted upon initialization.\n     * @param edition_                 The address of the edition.\n     * @param name_                    Name of the collection.\n     * @param symbol_                  Symbol of the collection.\n     * @param metadataModule_          Address of metadata module, address(0x00) if not used.\n     * @param baseURI_                 Base URI.\n     * @param contractURI_             Contract URI for OpenSea storefront.\n     * @param fundingRecipient_        Address that receives primary and secondary royalties.\n     * @param royaltyBPS_              Royalty amount in bps (basis points).\n     * @param editionMaxMintableLower_ The lower bound of the max mintable quantity for the edition.\n     * @param editionMaxMintableUpper_ The upper bound of the max mintable quantity for the edition.\n     * @param editionCutoffTime_       The timestamp after which `editionMaxMintable` drops from\n     *                                 `editionMaxMintableUpper` to\n     *                                 `max(_totalMinted(), editionMaxMintableLower)`.\n     * @param flags_                   The bitwise OR result of the initialization flags.\n     *                                 See: {METADATA_IS_FROZEN_FLAG}\n     *                                 See: {MINT_RANDOMNESS_ENABLED_FLAG}\n     */\n    event SoundEditionInitialized(\n        address indexed edition_,\n        string name_,\n        string symbol_,\n        address metadataModule_,\n        string baseURI_,\n        string contractURI_,\n        address fundingRecipient_,\n        uint16 royaltyBPS_,\n        uint32 editionMaxMintableLower_,\n        uint32 editionMaxMintableUpper_,\n        uint32 editionCutoffTime_,\n        uint8 flags_\n    );\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev The edition's metadata is frozen (e.g.: `baseURI` can no longer be changed).\n     */\n    error MetadataIsFrozen();\n\n    /**\n     * @dev The given `royaltyBPS` is invalid.\n     */\n    error InvalidRoyaltyBPS();\n\n    /**\n     * @dev The given `randomnessLockedAfterMinted` value is invalid.\n     */\n    error InvalidRandomnessLock();\n\n    /**\n     * @dev The requested quantity exceeds the edition's remaining mintable token quantity.\n     * @param available The number of tokens remaining available for mint.\n     */\n    error ExceedsEditionAvailableSupply(uint32 available);\n\n    /**\n     * @dev The given amount is invalid.\n     */\n    error InvalidAmount();\n\n    /**\n     * @dev The given `fundingRecipient` address is invalid.\n     */\n    error InvalidFundingRecipient();\n\n    /**\n     * @dev The `editionMaxMintableLower` must not be greater than `editionMaxMintableUpper`.\n     */\n    error InvalidEditionMaxMintableRange();\n\n    /**\n     * @dev The `editionMaxMintable` has already been reached.\n     */\n    error MaximumHasAlreadyBeenReached();\n\n    /**\n     * @dev The mint `quantity` cannot exceed `ADDRESS_BATCH_MINT_LIMIT` tokens.\n     */\n    error ExceedsAddressBatchMintLimit();\n\n    /**\n     * @dev The mint randomness has already been revealed.\n     */\n    error MintRandomnessAlreadyRevealed();\n\n    /**\n     * @dev No addresses to airdrop.\n     */\n    error NoAddressesToAirdrop();\n\n    /**\n     * @dev The mint has already concluded.\n     */\n    error MintHasConcluded();\n\n    /**\n     * @dev Cannot perform the operation after a token has been minted.\n     */\n    error MintsAlreadyExist();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Initializes the contract.\n     * @param name_                    Name of the collection.\n     * @param symbol_                  Symbol of the collection.\n     * @param metadataModule_          Address of metadata module, address(0x00) if not used.\n     * @param baseURI_                 Base URI.\n     * @param contractURI_             Contract URI for OpenSea storefront.\n     * @param fundingRecipient_        Address that receives primary and secondary royalties.\n     * @param royaltyBPS_              Royalty amount in bps (basis points).\n     * @param editionMaxMintableLower_ The lower bound of the max mintable quantity for the edition.\n     * @param editionMaxMintableUpper_ The upper bound of the max mintable quantity for the edition.\n     * @param editionCutoffTime_       The timestamp after which `editionMaxMintable` drops from\n     *                                 `editionMaxMintableUpper` to\n     *                                 `max(_totalMinted(), editionMaxMintableLower)`.\n     * @param flags_                   The bitwise OR result of the initialization flags.\n     *                                 See: {METADATA_IS_FROZEN_FLAG}\n     *                                 See: {MINT_RANDOMNESS_ENABLED_FLAG}\n     */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address metadataModule_,\n        string memory baseURI_,\n        string memory contractURI_,\n        address fundingRecipient_,\n        uint16 royaltyBPS_,\n        uint32 editionMaxMintableLower_,\n        uint32 editionMaxMintableUpper_,\n        uint32 editionCutoffTime_,\n        uint8 flags_\n    ) external;\n\n    /**\n     * @dev Mints `quantity` tokens to addrress `to`\n     *      Each token will be assigned a token ID that is consecutively increasing.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have either the\n     *   `ADMIN_ROLE`, `MINTER_ROLE`, which can be granted via {grantRole}.\n     *   Multiple minters, such as different minter contracts,\n     *   can be authorized simultaneously.\n     *\n     * @param to       Address to mint to.\n     * @param quantity Number of tokens to mint.\n     * @return fromTokenId The first token ID minted.\n     */\n    function mint(address to, uint256 quantity) external payable returns (uint256 fromTokenId);\n\n    /**\n     * @dev Mints `quantity` tokens to each of the addresses in `to`.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the\n     *   `ADMIN_ROLE`, which can be granted via {grantRole}.\n     *\n     * @param to           Address to mint to.\n     * @param quantity     Number of tokens to mint.\n     * @return fromTokenId The first token ID minted.\n     */\n    function airdrop(address[] calldata to, uint256 quantity) external returns (uint256 fromTokenId);\n\n    /**\n     * @dev Withdraws collected ETH royalties to the fundingRecipient.\n     */\n    function withdrawETH() external;\n\n    /**\n     * @dev Withdraws collected ERC20 royalties to the fundingRecipient.\n     * @param tokens array of ERC20 tokens to withdraw\n     */\n    function withdrawERC20(address[] calldata tokens) external;\n\n    /**\n     * @dev Sets metadata module.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param metadataModule Address of metadata module.\n     */\n    function setMetadataModule(address metadataModule) external;\n\n    /**\n     * @dev Sets global base URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param baseURI The base URI to be set.\n     */\n    function setBaseURI(string memory baseURI) external;\n\n    /**\n     * @dev Sets contract URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param contractURI The contract URI to be set.\n     */\n    function setContractURI(string memory contractURI) external;\n\n    /**\n     * @dev Freezes metadata by preventing any more changes to base URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     */\n    function freezeMetadata() external;\n\n    /**\n     * @dev Sets funding recipient address.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param fundingRecipient Address to be set as the new funding recipient.\n     */\n    function setFundingRecipient(address fundingRecipient) external;\n\n    /**\n     * @dev Sets royalty amount in bps (basis points).\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param bps The new royalty basis points to be set.\n     */\n    function setRoyalty(uint16 bps) external;\n\n    /**\n     * @dev Sets the edition max mintable range.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param editionMaxMintableLower_ The lower limit of the maximum number of tokens that can be minted.\n     * @param editionMaxMintableUpper_ The upper limit of the maximum number of tokens that can be minted.\n     */\n    function setEditionMaxMintableRange(uint32 editionMaxMintableLower_, uint32 editionMaxMintableUpper_) external;\n\n    /**\n     * @dev Sets the timestamp after which, the `editionMaxMintable` drops\n     *      from `editionMaxMintableUpper` to `editionMaxMintableLower.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param editionCutoffTime_ The timestamp.\n     */\n    function setEditionCutoffTime(uint32 editionCutoffTime_) external;\n\n    /**\n     * @dev Sets whether the `mintRandomness` is enabled.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param mintRandomnessEnabled_ The boolean value.\n     */\n    function setMintRandomnessEnabled(bool mintRandomnessEnabled_) external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the edition info.\n     * @return editionInfo The latest value.\n     */\n    function editionInfo() external view returns (EditionInfo memory editionInfo);\n\n    /**\n     * @dev Returns the minter role flag.\n     * @return The constant value.\n     */\n    function MINTER_ROLE() external view returns (uint256);\n\n    /**\n     * @dev Returns the admin role flag.\n     * @return The constant value.\n     */\n    function ADMIN_ROLE() external view returns (uint256);\n\n    /**\n     * @dev Returns the maximum limit for the mint or airdrop `quantity`.\n     *      Prevents the first-time transfer costs for tokens near the end of large mint batches\n     *      via ERC721A from becoming too expensive due to the need to scan many storage slots.\n     *      See: https://chiru-labs.github.io/ERC721A/#/tips?id=batch-size\n     * @return The constant value.\n     */\n    function ADDRESS_BATCH_MINT_LIMIT() external pure returns (uint256);\n\n    /**\n     * @dev Returns the bit flag to freeze the metadata on initialization.\n     * @return The constant value.\n     */\n    function METADATA_IS_FROZEN_FLAG() external pure returns (uint8);\n\n    /**\n     * @dev Returns the bit flag to enable the mint randomness feature on initialization.\n     * @return The constant value.\n     */\n    function MINT_RANDOMNESS_ENABLED_FLAG() external pure returns (uint8);\n\n    /**\n     * @dev Returns the base token URI for the collection.\n     * @return The configured value.\n     */\n    function baseURI() external view returns (string memory);\n\n    /**\n     * @dev Returns the contract URI to be used by Opensea.\n     *      See: https://docs.opensea.io/docs/contract-level-metadata\n     * @return The configured value.\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @dev Returns the address of the funding recipient.\n     * @return The configured value.\n     */\n    function fundingRecipient() external view returns (address);\n\n    /**\n     * @dev Returns the maximum amount of tokens mintable for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintable() external view returns (uint32);\n\n    /**\n     * @dev Returns the upper bound for the maximum tokens that can be minted for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintableUpper() external view returns (uint32);\n\n    /**\n     * @dev Returns the lower bound for the maximum tokens that can be minted for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintableLower() external view returns (uint32);\n\n    /**\n     * @dev Returns the timestamp after which `editionMaxMintable` drops from\n     *      `editionMaxMintableUpper` to `editionMaxMintableLower`.\n     * @return The configured value.\n     */\n    function editionCutoffTime() external view returns (uint32);\n\n    /**\n     * @dev Returns the address of the metadata module.\n     * @return The configured value.\n     */\n    function metadataModule() external view returns (address);\n\n    /**\n     * @dev Returns the randomness based on latest block hash, which is stored upon each mint.\n     *      unless {mintConcluded} is true.\n     *      Used for game mechanics like the Sound Golden Egg.\n     *      Returns 0 before revealed.\n     *      WARNING: This value should NOT be used for any reward of significant monetary\n     *      value, due to it being computed via a purely on-chain psuedorandom mechanism.\n     * @return The latest value.\n     */\n    function mintRandomness() external view returns (uint256);\n\n    /**\n     * @dev Returns whether the `mintRandomness` has been enabled.\n     * @return The configured value.\n     */\n    function mintRandomnessEnabled() external view returns (bool);\n\n    /**\n     * @dev Returns whether the mint has been concluded.\n     * @return The latest value.\n     */\n    function mintConcluded() external view returns (bool);\n\n    /**\n     * @dev Returns the royalty basis points.\n     * @return The configured value.\n     */\n    function royaltyBPS() external view returns (uint16);\n\n    /**\n     * @dev Returns whether the metadata module is frozen.\n     * @return The configured value.\n     */\n    function isMetadataFrozen() external view returns (bool);\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     * @return The latest value.\n     */\n    function nextTokenId() external view returns (uint256);\n\n    /**\n     * @dev Returns the number of tokens minted by `owner`.\n     * @param owner Address to query for number minted.\n     * @return The latest value.\n     */\n    function numberMinted(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the number of tokens burned by `owner`.\n     * @param owner Address to query for number burned.\n     * @return The latest value.\n     */\n    function numberBurned(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the total amount of tokens minted.\n     * @return The latest value.\n     */\n    function totalMinted() external view returns (uint256);\n\n    /**\n     * @dev Returns the total amount of tokens burned.\n     * @return The latest value.\n     */\n    function totalBurned() external view returns (uint256);\n\n    /**\n     * @dev Informs other contracts which interfaces this contract supports.\n     *      Required by https://eips.ethereum.org/EIPS/eip-165\n     * @param interfaceId The interface id to check.\n     * @return Whether the `interfaceId` is supported.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        override(IERC721AUpgradeable, IERC165Upgradeable)\n        returns (bool);\n}\n"
18     },
19     "contracts/core/interfaces/IMetadataModule.sol": {
20       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\n/**\n * @title IMetadataModule\n * @notice The interface for custom metadata modules.\n */\ninterface IMetadataModule {\n    /**\n     * @dev When implemented, SoundEdition's `tokenURI` redirects execution to this `tokenURI`.\n     * @param tokenId The token ID to retrieve the token URI for.\n     * @return The token URI string.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
21     },
22     "lib/solady/src/auth/OwnableRoles.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner and multiroles authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/OwnableRoles.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\n/// may be unique to this codebase.\nabstract contract OwnableRoles {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"NewOwnerIsZeroAddress()\")))`.\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\n\n    /// @dev `bytes4(keccak256(bytes(\"NoHandoverRequest()\")))`.\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been cancelled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev The `user`'s roles is updated to `roles`.\n    /// Each bit of `roles` represents whether the role is set.\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /// @dev `keccak256(bytes(\"RolesUpdated(address,uint256)\"))`.\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally choosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    ///\n    /// The role slot of `user` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n    ///     let roleSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// This automatically ignores the upper bits of the `user` in case\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Grants the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn on.\n    function _grantRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value and `or` it with `roles`.\n            let newRoles := or(sload(roleSlot), roles)\n            // Store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /// @dev Removes the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn off.\n    function _removeRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value.\n            let currentRoles := sload(roleSlot)\n            // Use `and` to compute the intersection of `currentRoles` and `roles`,\n            // `xor` it with `currentRoles` to flip the bits in the intersection.\n            let newRoles := xor(currentRoles, and(currentRoles, roles))\n            // Then, store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Reverts if the `newOwner` is the zero address.\n            if iszero(newOwner) {\n                mstore(0x00, _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n        }\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public virtual onlyOwner {\n        assembly {\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), 0)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), 0)\n        }\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            assembly {\n                // Compute and set the handover slot to 1.\n                mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n                sstore(keccak256(0x00, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public virtual {\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n            sstore(keccak256(0x00, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            pendingOwner := shr(96, shl(96, pendingOwner))\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            let handoverSlot := keccak256(0x00, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), pendingOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), pendingOwner)\n        }\n    }\n\n    /// @dev Allows the owner to grant `user` `roles`.\n    /// If the `user` already has a role, then it will be an no-op for the role.\n    function grantRoles(address user, uint256 roles) public virtual onlyOwner {\n        _grantRoles(user, roles);\n    }\n\n    /// @dev Allows the owner to remove `user` `roles`.\n    /// If the `user` does not have a role, then it will be an no-op for the role.\n    function revokeRoles(address user, uint256 roles) public virtual onlyOwner {\n        _removeRoles(user, roles);\n    }\n\n    /// @dev Allow the caller to remove their own roles.\n    /// If the caller does not have a role, then it will be an no-op for the role.\n    function renounceRoles(uint256 roles) public virtual {\n        _removeRoles(msg.sender, roles);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner) public view virtual returns (uint256 result) {\n        assembly {\n            // Compute the handover slot.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            // Load the handover slot.\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /// @dev Returns whether `user` has any of `roles`.\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value, and set the result to whether the\n            // `and` intersection of the value and `roles` is not zero.\n            result := iszero(iszero(and(sload(keccak256(0x00, 0x20)), roles)))\n        }\n    }\n\n    /// @dev Returns whether `user` has all of `roles`.\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Whether the stored value is contains all the set bits in `roles`.\n            result := eq(and(sload(keccak256(0x00, 0x20)), roles), roles)\n        }\n    }\n\n    /// @dev Returns the roles of `user`.\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value.\n            roles := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from the `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {\n        assembly {\n            // Skip the length slot.\n            let o := add(ordinals, 0x20)\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := add(o, shl(5, mload(ordinals)))\n            // prettier-ignore\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } {\n                roles := or(roles, shl(and(mload(o), 0xff), 1))\n            }\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from the `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {\n        assembly {\n            // Grab the pointer to the free memory.\n            let ptr := add(mload(0x40), 0x20)\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            // prettier-ignore\n            for { let i := 0 } 1 { i := add(i, 1) } {\n                mstore(ptr, i)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(roles, 1)))\n                roles := shr(1, roles)\n                // prettier-ignore\n                if iszero(roles) { break }\n            }\n            // Set `ordinals` to the start of the free memory.\n            ordinals := mload(0x40)\n            // Allocate the memory.\n            mstore(0x40, ptr)\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`.\n    modifier onlyRoles(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by the owner or by an account\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\n        assembly {\n            // If the caller is not the stored owner.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                // Compute the role slot.\n                mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ROLE CONSTANTS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // IYKYK\n\n    uint256 internal constant _ROLE_0 = 1 << 0;\n    uint256 internal constant _ROLE_1 = 1 << 1;\n    uint256 internal constant _ROLE_2 = 1 << 2;\n    uint256 internal constant _ROLE_3 = 1 << 3;\n    uint256 internal constant _ROLE_4 = 1 << 4;\n    uint256 internal constant _ROLE_5 = 1 << 5;\n    uint256 internal constant _ROLE_6 = 1 << 6;\n    uint256 internal constant _ROLE_7 = 1 << 7;\n    uint256 internal constant _ROLE_8 = 1 << 8;\n    uint256 internal constant _ROLE_9 = 1 << 9;\n    uint256 internal constant _ROLE_10 = 1 << 10;\n    uint256 internal constant _ROLE_11 = 1 << 11;\n    uint256 internal constant _ROLE_12 = 1 << 12;\n    uint256 internal constant _ROLE_13 = 1 << 13;\n    uint256 internal constant _ROLE_14 = 1 << 14;\n    uint256 internal constant _ROLE_15 = 1 << 15;\n    uint256 internal constant _ROLE_16 = 1 << 16;\n    uint256 internal constant _ROLE_17 = 1 << 17;\n    uint256 internal constant _ROLE_18 = 1 << 18;\n    uint256 internal constant _ROLE_19 = 1 << 19;\n    uint256 internal constant _ROLE_20 = 1 << 20;\n    uint256 internal constant _ROLE_21 = 1 << 21;\n    uint256 internal constant _ROLE_22 = 1 << 22;\n    uint256 internal constant _ROLE_23 = 1 << 23;\n    uint256 internal constant _ROLE_24 = 1 << 24;\n    uint256 internal constant _ROLE_25 = 1 << 25;\n    uint256 internal constant _ROLE_26 = 1 << 26;\n    uint256 internal constant _ROLE_27 = 1 << 27;\n    uint256 internal constant _ROLE_28 = 1 << 28;\n    uint256 internal constant _ROLE_29 = 1 << 29;\n    uint256 internal constant _ROLE_30 = 1 << 30;\n    uint256 internal constant _ROLE_31 = 1 << 31;\n    uint256 internal constant _ROLE_32 = 1 << 32;\n    uint256 internal constant _ROLE_33 = 1 << 33;\n    uint256 internal constant _ROLE_34 = 1 << 34;\n    uint256 internal constant _ROLE_35 = 1 << 35;\n    uint256 internal constant _ROLE_36 = 1 << 36;\n    uint256 internal constant _ROLE_37 = 1 << 37;\n    uint256 internal constant _ROLE_38 = 1 << 38;\n    uint256 internal constant _ROLE_39 = 1 << 39;\n    uint256 internal constant _ROLE_40 = 1 << 40;\n    uint256 internal constant _ROLE_41 = 1 << 41;\n    uint256 internal constant _ROLE_42 = 1 << 42;\n    uint256 internal constant _ROLE_43 = 1 << 43;\n    uint256 internal constant _ROLE_44 = 1 << 44;\n    uint256 internal constant _ROLE_45 = 1 << 45;\n    uint256 internal constant _ROLE_46 = 1 << 46;\n    uint256 internal constant _ROLE_47 = 1 << 47;\n    uint256 internal constant _ROLE_48 = 1 << 48;\n    uint256 internal constant _ROLE_49 = 1 << 49;\n    uint256 internal constant _ROLE_50 = 1 << 50;\n    uint256 internal constant _ROLE_51 = 1 << 51;\n    uint256 internal constant _ROLE_52 = 1 << 52;\n    uint256 internal constant _ROLE_53 = 1 << 53;\n    uint256 internal constant _ROLE_54 = 1 << 54;\n    uint256 internal constant _ROLE_55 = 1 << 55;\n    uint256 internal constant _ROLE_56 = 1 << 56;\n    uint256 internal constant _ROLE_57 = 1 << 57;\n    uint256 internal constant _ROLE_58 = 1 << 58;\n    uint256 internal constant _ROLE_59 = 1 << 59;\n    uint256 internal constant _ROLE_60 = 1 << 60;\n    uint256 internal constant _ROLE_61 = 1 << 61;\n    uint256 internal constant _ROLE_62 = 1 << 62;\n    uint256 internal constant _ROLE_63 = 1 << 63;\n    uint256 internal constant _ROLE_64 = 1 << 64;\n    uint256 internal constant _ROLE_65 = 1 << 65;\n    uint256 internal constant _ROLE_66 = 1 << 66;\n    uint256 internal constant _ROLE_67 = 1 << 67;\n    uint256 internal constant _ROLE_68 = 1 << 68;\n    uint256 internal constant _ROLE_69 = 1 << 69;\n    uint256 internal constant _ROLE_70 = 1 << 70;\n    uint256 internal constant _ROLE_71 = 1 << 71;\n    uint256 internal constant _ROLE_72 = 1 << 72;\n    uint256 internal constant _ROLE_73 = 1 << 73;\n    uint256 internal constant _ROLE_74 = 1 << 74;\n    uint256 internal constant _ROLE_75 = 1 << 75;\n    uint256 internal constant _ROLE_76 = 1 << 76;\n    uint256 internal constant _ROLE_77 = 1 << 77;\n    uint256 internal constant _ROLE_78 = 1 << 78;\n    uint256 internal constant _ROLE_79 = 1 << 79;\n    uint256 internal constant _ROLE_80 = 1 << 80;\n    uint256 internal constant _ROLE_81 = 1 << 81;\n    uint256 internal constant _ROLE_82 = 1 << 82;\n    uint256 internal constant _ROLE_83 = 1 << 83;\n    uint256 internal constant _ROLE_84 = 1 << 84;\n    uint256 internal constant _ROLE_85 = 1 << 85;\n    uint256 internal constant _ROLE_86 = 1 << 86;\n    uint256 internal constant _ROLE_87 = 1 << 87;\n    uint256 internal constant _ROLE_88 = 1 << 88;\n    uint256 internal constant _ROLE_89 = 1 << 89;\n    uint256 internal constant _ROLE_90 = 1 << 90;\n    uint256 internal constant _ROLE_91 = 1 << 91;\n    uint256 internal constant _ROLE_92 = 1 << 92;\n    uint256 internal constant _ROLE_93 = 1 << 93;\n    uint256 internal constant _ROLE_94 = 1 << 94;\n    uint256 internal constant _ROLE_95 = 1 << 95;\n    uint256 internal constant _ROLE_96 = 1 << 96;\n    uint256 internal constant _ROLE_97 = 1 << 97;\n    uint256 internal constant _ROLE_98 = 1 << 98;\n    uint256 internal constant _ROLE_99 = 1 << 99;\n    uint256 internal constant _ROLE_100 = 1 << 100;\n    uint256 internal constant _ROLE_101 = 1 << 101;\n    uint256 internal constant _ROLE_102 = 1 << 102;\n    uint256 internal constant _ROLE_103 = 1 << 103;\n    uint256 internal constant _ROLE_104 = 1 << 104;\n    uint256 internal constant _ROLE_105 = 1 << 105;\n    uint256 internal constant _ROLE_106 = 1 << 106;\n    uint256 internal constant _ROLE_107 = 1 << 107;\n    uint256 internal constant _ROLE_108 = 1 << 108;\n    uint256 internal constant _ROLE_109 = 1 << 109;\n    uint256 internal constant _ROLE_110 = 1 << 110;\n    uint256 internal constant _ROLE_111 = 1 << 111;\n    uint256 internal constant _ROLE_112 = 1 << 112;\n    uint256 internal constant _ROLE_113 = 1 << 113;\n    uint256 internal constant _ROLE_114 = 1 << 114;\n    uint256 internal constant _ROLE_115 = 1 << 115;\n    uint256 internal constant _ROLE_116 = 1 << 116;\n    uint256 internal constant _ROLE_117 = 1 << 117;\n    uint256 internal constant _ROLE_118 = 1 << 118;\n    uint256 internal constant _ROLE_119 = 1 << 119;\n    uint256 internal constant _ROLE_120 = 1 << 120;\n    uint256 internal constant _ROLE_121 = 1 << 121;\n    uint256 internal constant _ROLE_122 = 1 << 122;\n    uint256 internal constant _ROLE_123 = 1 << 123;\n    uint256 internal constant _ROLE_124 = 1 << 124;\n    uint256 internal constant _ROLE_125 = 1 << 125;\n    uint256 internal constant _ROLE_126 = 1 << 126;\n    uint256 internal constant _ROLE_127 = 1 << 127;\n    uint256 internal constant _ROLE_128 = 1 << 128;\n    uint256 internal constant _ROLE_129 = 1 << 129;\n    uint256 internal constant _ROLE_130 = 1 << 130;\n    uint256 internal constant _ROLE_131 = 1 << 131;\n    uint256 internal constant _ROLE_132 = 1 << 132;\n    uint256 internal constant _ROLE_133 = 1 << 133;\n    uint256 internal constant _ROLE_134 = 1 << 134;\n    uint256 internal constant _ROLE_135 = 1 << 135;\n    uint256 internal constant _ROLE_136 = 1 << 136;\n    uint256 internal constant _ROLE_137 = 1 << 137;\n    uint256 internal constant _ROLE_138 = 1 << 138;\n    uint256 internal constant _ROLE_139 = 1 << 139;\n    uint256 internal constant _ROLE_140 = 1 << 140;\n    uint256 internal constant _ROLE_141 = 1 << 141;\n    uint256 internal constant _ROLE_142 = 1 << 142;\n    uint256 internal constant _ROLE_143 = 1 << 143;\n    uint256 internal constant _ROLE_144 = 1 << 144;\n    uint256 internal constant _ROLE_145 = 1 << 145;\n    uint256 internal constant _ROLE_146 = 1 << 146;\n    uint256 internal constant _ROLE_147 = 1 << 147;\n    uint256 internal constant _ROLE_148 = 1 << 148;\n    uint256 internal constant _ROLE_149 = 1 << 149;\n    uint256 internal constant _ROLE_150 = 1 << 150;\n    uint256 internal constant _ROLE_151 = 1 << 151;\n    uint256 internal constant _ROLE_152 = 1 << 152;\n    uint256 internal constant _ROLE_153 = 1 << 153;\n    uint256 internal constant _ROLE_154 = 1 << 154;\n    uint256 internal constant _ROLE_155 = 1 << 155;\n    uint256 internal constant _ROLE_156 = 1 << 156;\n    uint256 internal constant _ROLE_157 = 1 << 157;\n    uint256 internal constant _ROLE_158 = 1 << 158;\n    uint256 internal constant _ROLE_159 = 1 << 159;\n    uint256 internal constant _ROLE_160 = 1 << 160;\n    uint256 internal constant _ROLE_161 = 1 << 161;\n    uint256 internal constant _ROLE_162 = 1 << 162;\n    uint256 internal constant _ROLE_163 = 1 << 163;\n    uint256 internal constant _ROLE_164 = 1 << 164;\n    uint256 internal constant _ROLE_165 = 1 << 165;\n    uint256 internal constant _ROLE_166 = 1 << 166;\n    uint256 internal constant _ROLE_167 = 1 << 167;\n    uint256 internal constant _ROLE_168 = 1 << 168;\n    uint256 internal constant _ROLE_169 = 1 << 169;\n    uint256 internal constant _ROLE_170 = 1 << 170;\n    uint256 internal constant _ROLE_171 = 1 << 171;\n    uint256 internal constant _ROLE_172 = 1 << 172;\n    uint256 internal constant _ROLE_173 = 1 << 173;\n    uint256 internal constant _ROLE_174 = 1 << 174;\n    uint256 internal constant _ROLE_175 = 1 << 175;\n    uint256 internal constant _ROLE_176 = 1 << 176;\n    uint256 internal constant _ROLE_177 = 1 << 177;\n    uint256 internal constant _ROLE_178 = 1 << 178;\n    uint256 internal constant _ROLE_179 = 1 << 179;\n    uint256 internal constant _ROLE_180 = 1 << 180;\n    uint256 internal constant _ROLE_181 = 1 << 181;\n    uint256 internal constant _ROLE_182 = 1 << 182;\n    uint256 internal constant _ROLE_183 = 1 << 183;\n    uint256 internal constant _ROLE_184 = 1 << 184;\n    uint256 internal constant _ROLE_185 = 1 << 185;\n    uint256 internal constant _ROLE_186 = 1 << 186;\n    uint256 internal constant _ROLE_187 = 1 << 187;\n    uint256 internal constant _ROLE_188 = 1 << 188;\n    uint256 internal constant _ROLE_189 = 1 << 189;\n    uint256 internal constant _ROLE_190 = 1 << 190;\n    uint256 internal constant _ROLE_191 = 1 << 191;\n    uint256 internal constant _ROLE_192 = 1 << 192;\n    uint256 internal constant _ROLE_193 = 1 << 193;\n    uint256 internal constant _ROLE_194 = 1 << 194;\n    uint256 internal constant _ROLE_195 = 1 << 195;\n    uint256 internal constant _ROLE_196 = 1 << 196;\n    uint256 internal constant _ROLE_197 = 1 << 197;\n    uint256 internal constant _ROLE_198 = 1 << 198;\n    uint256 internal constant _ROLE_199 = 1 << 199;\n    uint256 internal constant _ROLE_200 = 1 << 200;\n    uint256 internal constant _ROLE_201 = 1 << 201;\n    uint256 internal constant _ROLE_202 = 1 << 202;\n    uint256 internal constant _ROLE_203 = 1 << 203;\n    uint256 internal constant _ROLE_204 = 1 << 204;\n    uint256 internal constant _ROLE_205 = 1 << 205;\n    uint256 internal constant _ROLE_206 = 1 << 206;\n    uint256 internal constant _ROLE_207 = 1 << 207;\n    uint256 internal constant _ROLE_208 = 1 << 208;\n    uint256 internal constant _ROLE_209 = 1 << 209;\n    uint256 internal constant _ROLE_210 = 1 << 210;\n    uint256 internal constant _ROLE_211 = 1 << 211;\n    uint256 internal constant _ROLE_212 = 1 << 212;\n    uint256 internal constant _ROLE_213 = 1 << 213;\n    uint256 internal constant _ROLE_214 = 1 << 214;\n    uint256 internal constant _ROLE_215 = 1 << 215;\n    uint256 internal constant _ROLE_216 = 1 << 216;\n    uint256 internal constant _ROLE_217 = 1 << 217;\n    uint256 internal constant _ROLE_218 = 1 << 218;\n    uint256 internal constant _ROLE_219 = 1 << 219;\n    uint256 internal constant _ROLE_220 = 1 << 220;\n    uint256 internal constant _ROLE_221 = 1 << 221;\n    uint256 internal constant _ROLE_222 = 1 << 222;\n    uint256 internal constant _ROLE_223 = 1 << 223;\n    uint256 internal constant _ROLE_224 = 1 << 224;\n    uint256 internal constant _ROLE_225 = 1 << 225;\n    uint256 internal constant _ROLE_226 = 1 << 226;\n    uint256 internal constant _ROLE_227 = 1 << 227;\n    uint256 internal constant _ROLE_228 = 1 << 228;\n    uint256 internal constant _ROLE_229 = 1 << 229;\n    uint256 internal constant _ROLE_230 = 1 << 230;\n    uint256 internal constant _ROLE_231 = 1 << 231;\n    uint256 internal constant _ROLE_232 = 1 << 232;\n    uint256 internal constant _ROLE_233 = 1 << 233;\n    uint256 internal constant _ROLE_234 = 1 << 234;\n    uint256 internal constant _ROLE_235 = 1 << 235;\n    uint256 internal constant _ROLE_236 = 1 << 236;\n    uint256 internal constant _ROLE_237 = 1 << 237;\n    uint256 internal constant _ROLE_238 = 1 << 238;\n    uint256 internal constant _ROLE_239 = 1 << 239;\n    uint256 internal constant _ROLE_240 = 1 << 240;\n    uint256 internal constant _ROLE_241 = 1 << 241;\n    uint256 internal constant _ROLE_242 = 1 << 242;\n    uint256 internal constant _ROLE_243 = 1 << 243;\n    uint256 internal constant _ROLE_244 = 1 << 244;\n    uint256 internal constant _ROLE_245 = 1 << 245;\n    uint256 internal constant _ROLE_246 = 1 << 246;\n    uint256 internal constant _ROLE_247 = 1 << 247;\n    uint256 internal constant _ROLE_248 = 1 << 248;\n    uint256 internal constant _ROLE_249 = 1 << 249;\n    uint256 internal constant _ROLE_250 = 1 << 250;\n    uint256 internal constant _ROLE_251 = 1 << 251;\n    uint256 internal constant _ROLE_252 = 1 << 252;\n    uint256 internal constant _ROLE_253 = 1 << 253;\n    uint256 internal constant _ROLE_254 = 1 << 254;\n    uint256 internal constant _ROLE_255 = 1 << 255;\n}\n"
24     },
25     "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
27     },
28     "lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
30     },
31     "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
33     },
34     "lib/ERC721A-Upgradeable/contracts/IERC721AUpgradeable.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.2\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721AUpgradeable {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
36     },
37     "lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC2981Upgradeable.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
39     },
40     "lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
42     },
43     "lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
45     },
46     "lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
48     },
49     "lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
51     }
52   },
53   "settings": {
54     "remappings": [
55       "@core/=contracts/core/",
56       "@modules/=contracts/modules/",
57       "ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",
58       "chiru-labs/ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",
59       "ds-test/=lib/forge-std/lib/ds-test/src/",
60       "forge-std/=lib/forge-std/src/",
61       "murky/=lib/murky/src/",
62       "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
63       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
64       "openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
65       "openzeppelin/=lib/openzeppelin-contracts/contracts/",
66       "solady/=lib/solady/src/",
67       "solmate/=lib/solady/lib/solmate/src/"
68     ],
69     "optimizer": {
70       "enabled": true,
71       "runs": 1000
72     },
73     "metadata": {
74       "bytecodeHash": "ipfs"
75     },
76     "outputSelection": {
77       "*": {
78         "*": [
79           "evm.bytecode",
80           "evm.deployedBytecode",
81           "devdoc",
82           "userdoc",
83           "metadata",
84           "abi"
85         ]
86       }
87     },
88     "evmVersion": "london",
89     "libraries": {}
90   }
91 }}