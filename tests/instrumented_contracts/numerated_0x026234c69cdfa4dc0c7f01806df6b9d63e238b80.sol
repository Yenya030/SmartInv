1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/Guardable/src/Guardable.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IGuardable.sol\";\n\n/**\n* Abstract contract to be used with ERC1155 or ERC721 or their extensions.\n* See ERC721Guardable or ERC1155Guardable for examples of how to overwrite\n* setApprovalForAll and approve to be Guardable. Overwriting other functions\n* is possible but not recommended.\n*/\nabstract contract Guardable is IGuardable {\n  mapping(address => address) internal locks;\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IGuardable).interfaceId;\n  }\n\n  function setGuardian(address guardian) public {\n    if (msg.sender == guardian || guardian == address(0)) {\n      revert InvalidGuardian();\n    }\n\n    locks[msg.sender] = guardian;\n    emit GuardianAdded(msg.sender, guardian);\n  }\n\n  function guardianOf(address tokenOwner) public view returns (address) {\n    return locks[tokenOwner];\n  }\n\n  function removeGuardianOf(address tokenOwner) external {\n    if (msg.sender != guardianOf(tokenOwner)) {\n      revert CallerGuardianMismatch(msg.sender, guardianOf(tokenOwner));\n    }\n    delete locks[tokenOwner];\n    emit GuardianRemoved(tokenOwner);\n  }\n\n  function _lockToSelf() internal virtual {\n    locks[msg.sender] = msg.sender;\n    emit GuardianAdded(msg.sender, msg.sender);\n  }\n}"
6     },
7     "lib/Guardable/src/IGuardable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IGuardable is IERC165 {\n  // Interface ID 0x126f5523\n\n  error TokenIsLocked();\n  error CallerGuardianMismatch(address caller, address guardian);\n  error InvalidGuardian();\n\n  event GuardianAdded(address indexed addressGuarded, address indexed guardian);\n  event GuardianRemoved(address indexed addressGuarded);\n\n  function setGuardian(address guardian) external;\n\n  function removeGuardianOf(address tokenOwner) external;\n\n  function guardianOf(address tokenOwner) external view returns (address);\n}"
9     },
10     "lib/Guardable/src/tokens/ERC721Guardable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"../Guardable.sol\";\n\n/**\n * @dev Contract module which provides added security functionality, where\n * where an account can assign a guardian to protect their NFTs. While a guardian\n * is assigned, setApprovalForAll and approve are both locked. New approvals cannot be set. There can\n * only ever be one guardian per account, and setting a new guardian will overwrite\n * any existing one.\n *\n * Existing approvals can still be leveraged as normal, and it is expected that this\n * functionality be used after a user has set the approvals they want to set. Approvals\n * can still be removed while a guardian is set.\n * \n * Setting a guardian has no effect on transfers, so users can move assets to a new wallet\n * to effectively \"clear\" guardians if a guardian is maliciously set, or keys to a guardian\n * are lost.\n *\n * It is not recommended to use _lockToSelf, as removing this lock would be easily added to\n * a malicious workflow, whereas removing a traditional lock from a guardian account would\n * be sufficiently prohibitive.\n */\n\ncontract ERC721Guardable is ERC721, Guardable {\n  string internal baseUri;\n\n  constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override(Guardable, ERC721) returns (bool) {\n    return Guardable.supportsInterface(interfaceId) || ERC721.supportsInterface(interfaceId);\n  }\n\n  function approve(address to, uint256 tokenId) public override {\n    if (locks[msg.sender] != address(0)) {\n      revert TokenIsLocked();\n    }\n\n    super.approve(to, tokenId);\n  }\n\n  function setApprovalForAll(address operator, bool approved) public override {\n    if (locks[msg.sender] != address(0) && approved) {\n      revert TokenIsLocked();\n    }\n\n    super.setApprovalForAll(operator, approved);\n  }\n\n  function tokenURI(uint256 id) public view virtual override returns (string memory) {\n    return string(abi.encodePacked(baseUri, _toString(id)));\n  }\n\n  // From ERC721A\n  /**\n    * @dev Converts a uint256 to its ASCII string decimal representation.\n  */\n  function _toString(uint256 value) internal pure virtual returns (string memory str) {\n      assembly {\n          // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n          // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n          // We will need 1 word for the trailing zeros padding, 1 word for the length,\n          // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n          let m := add(mload(0x40), 0xa0)\n          // Update the free memory pointer to allocate.\n          mstore(0x40, m)\n          // Assign the `str` to the end.\n          str := sub(m, 0x20)\n          // Zeroize the slot after the string.\n          mstore(str, 0)\n\n          // Cache the end of the memory to calculate the length later.\n          let end := str\n\n          // We write the string from rightmost digit to leftmost digit.\n          // The following is essentially a do-while loop that also handles the zero case.\n          // prettier-ignore\n          for { let temp := value } 1 {} {\n              str := sub(str, 1)\n              // Write the character to the pointer.\n              // The ASCII index of the '0' character is 48.\n              mstore8(str, add(48, mod(temp, 10)))\n              // Keep dividing `temp` until zero.\n              temp := div(temp, 10)\n              // prettier-ignore\n              if iszero(temp) { break }\n          }\n\n          let length := sub(end, str)\n          // Move the pointer 32 bytes leftwards to make room for the length.\n          str := sub(str, 0x20)\n          // Store the length.\n          mstore(str, length)\n      }\n  }\n}"
12     },
13     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
15     },
16     "lib/solmate/src/auth/Owned.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
18     },
19     "lib/solmate/src/tokens/ERC721.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
21     },
22     "src/MadMaraudersOfTheAccidentalApocalypse.sol": {
23       "content": "import \"Guardable/ERC721Guardable.sol\";\nimport \"solmate/auth/Owned.sol\";\nimport \"./lib/MarauderErrors.sol\";\nimport \"./lib/MarauderStructs.sol\";\nimport \"./interfaces/INuclearNerds.sol\";\nimport \"./interfaces/IWarm.sol\";\nimport \"./interfaces/IDelegateCash.sol\";\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\ncontract MadMaraudersOfTheAccidentalApocalypse is ERC721Guardable, Owned {\n    address public immutable BOX_O_BAD_GUYS_CONTRACT_ADDRESS;\n    address public immutable NERDS_CONTRACT_ADDRESS;\n\n    bool claimOpen;\n\n    IWarm public immutable warm;\n    IDelegateCash public immutable delegateCash;\n    INuclearNerds private immutable nerds;\n\n    mapping(uint256 => bool) public nerdHasClaimed;\n    mapping(uint256 => bool) public berserkersEligibleForClaim;\n\n    // max supply 7843 (1:1 nerds + bonus for berserkers - 900 enforcers - 300 warlords)\n    ClaimableTokenDetails public raiderTokenDetails;\n\n    /**\n     * @notice max supply 5907 (enforced by MadMarauderBoxOBadGuys contract)\n     * ------------------------\n     * box supply = 2 * 969\n     * a la carte supply = 3069\n     * claimable supply = 900\n     * ------------------------\n     * 2 * 969 + 2069 + 900 = 5907\n     * ------------------------\n     */\n    MintableTokenDetails public enforcerTokenDetails;\n\n    /**\n     * @notice max supply 3338 (enforced by MadMarauderBoxOBadGuys contract)\n     * ------------------------\n     * box supply = 969\n     * a la carte supply = 2069\n     * claimable supply = 300\n     * ------------------------\n     * 969 + 3069 + 300 = 3338\n     * ------------------------\n     */\n    MintableTokenDetails public warlordTokenDetails;\n\n    constructor(\n      address _mintPassContractAddress,\n      address _nerdsContractAddress,\n      address _warmWalletContractAddress,\n      address _delegateCashContract,\n      uint256[43] memory berserkerTokenIds,\n      string memory _uri\n    ) ERC721Guardable(\"Marauders Of The Accidental Apocalypse\", \"MARAUDERS\") Owned(msg.sender) {\n      BOX_O_BAD_GUYS_CONTRACT_ADDRESS = _mintPassContractAddress;\n      NERDS_CONTRACT_ADDRESS = _nerdsContractAddress;\n      warm = IWarm(_warmWalletContractAddress);\n      delegateCash = IDelegateCash(_delegateCashContract);\n      nerds = INuclearNerds(NERDS_CONTRACT_ADDRESS);\n\n      enforcerTokenDetails.startTokenId = enforcerTokenDetails.currentTokenId = 9043;\n      warlordTokenDetails.startTokenId = warlordTokenDetails.currentTokenId = 14050;\n\n      raiderTokenDetails.currentBonusTokenId = 9000;\n      raiderTokenDetails.maxBonusTokenId = 9042;\n\n      for (uint256 i = 0; i < berserkerTokenIds.length;) {\n        berserkersEligibleForClaim[berserkerTokenIds[i]] = true;\n        unchecked {++i;}\n      }\n\n      baseUri = _uri;\n    }\n\n    /**\n     * @notice function to claim a raider for each nerd you own\n     * @param _tokenIds Nerd IDs to claim for. Must own each nerd token, supports delegation through delegate.cash and warm.xyz\n     */\n    function claimRaiders(uint256[] calldata _tokenIds) external {\n      if (!claimOpen) revert ClaimNotStarted();\n\n      for (uint256 i = 0; i < _tokenIds.length;) {\n        uint256 tokenId = _tokenIds[i];\n        if (!ownerOrDelegateOf(tokenId)) revert MustOwnMatchingNerd();\n        if (nerdHasClaimed[tokenId]) revert AlreadyClaimed();\n        nerdHasClaimed[tokenId] = true;\n        _mint(msg.sender, tokenId);\n\n        if (berserkersEligibleForClaim[tokenId]) {\n          if (raiderTokenDetails.currentBonusTokenId > raiderTokenDetails.maxBonusTokenId) revert AllBerserkersMinted();\n          _mint(msg.sender, raiderTokenDetails.currentBonusTokenId);\n          unchecked { \n            ++raiderTokenDetails.currentBonusTokenId;\n            ++raiderTokenDetails.totalSupply;\n          }\n        }\n\n        unchecked { \n          ++i;\n          ++raiderTokenDetails.totalSupply;\n        }\n      }\n    }\n\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\n      return string(abi.encodePacked(baseUri, _toString(id)));\n    }\n\n    /**\n     * @notice The total number of minted raiders\n     */\n    function totalRaiderSupply() public view returns (uint256) {\n      return raiderTokenDetails.totalSupply;\n    }\n\n    /**\n     * @notice The total number of minted enforcers\n     */\n    function totalEnforcerSupply() public view returns (uint256) {\n      return enforcerTokenDetails.currentTokenId - enforcerTokenDetails.startTokenId;\n    }\n\n    /**\n     * @notice The total number of minted warlords\n     */\n    function totalWarlordSupply() public view returns (uint256) {\n      return warlordTokenDetails.currentTokenId - warlordTokenDetails.startTokenId;\n    }\n\n    /**\n     * @notice The total number of all minted tokens combined: raiders, enforcers, and warlords.\n     */\n    function totalSupply() public view returns (uint256) {\n      return totalRaiderSupply() + totalEnforcerSupply() + totalWarlordSupply();\n    }\n\n    /**\n     * @notice Token burn callable by token owner or approved address\n     */\n    function burn(uint256[] calldata tokenIds) external {\n      for (uint256 i = 0; i < tokenIds.length;) {\n        address from = ownerOf(tokenIds[i]);\n\n        if (msg.sender != from && !isApprovedForAll[from][msg.sender] && msg.sender != getApproved[tokenIds[i]]) {\n          revert InvalidCaller();\n        }\n\n        _burn(tokenIds[i]);\n        unchecked { ++i; }\n      }\n    }\n\n    /**\n     * @dev Checks for ownership or delegated ownership of a given token. Supports Warm and Delegate.cash\n     */\n    function ownerOrDelegateOf(uint256 tokenId) internal view returns (bool) {\n      return\n        msg.sender == nerds.ownerOf(tokenId) ||\n        delegateCash.checkDelegateForToken(msg.sender, nerds.ownerOf(tokenId), NERDS_CONTRACT_ADDRESS, tokenId) ||\n        msg.sender == warm.ownerOf(NERDS_CONTRACT_ADDRESS, tokenId);\n    }\n\n    /* BOX FUNCTIONS (callable from Box Of Bad Guys contract) */\n\n    function mintFromBox(address recipient, uint256 amount) external onlyBox {\n      _mint(enforcerTokenDetails, amount * 2, recipient);\n      _mint(warlordTokenDetails, amount, recipient);\n    }\n\n    function mintEnforcer(address recipient, uint256 amount) external onlyBox {\n      _mint(enforcerTokenDetails, amount, recipient);\n    }\n\n    function mintWarlord(address recipient, uint256 amount) external onlyBox {\n      _mint(warlordTokenDetails, amount, recipient);\n    }\n\n    modifier onlyBox {\n      if (msg.sender != BOX_O_BAD_GUYS_CONTRACT_ADDRESS) revert InvalidCaller();\n      _;\n    }\n\n    /* ADMIN FUNCTIONS */\n\n    function setBaseURI(string memory _uri) external onlyOwner {\n      baseUri = _uri;\n    }\n\n    function setClaimStatus(bool status) external onlyOwner {\n      claimOpen = status;\n    }\n\n    /* INTERNAL HELPERS */\n\n    function _mint(MintableTokenDetails storage tokenDetails, uint256 amount, address recipient) internal {\n      for (uint256 i = 0; i < amount;) {\n        _mint(recipient, tokenDetails.currentTokenId);\n        unchecked { \n          ++tokenDetails.currentTokenId;\n          ++i; \n        }\n      }\n    }\n}\n"
24     },
25     "src/interfaces/IDelegateCash.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IDelegateCash {\n    function checkDelegateForToken(\n        address delegate,\n        address vault,\n        address contract_,\n        uint256 tokenId\n    ) external view returns (bool);\n}"
27     },
28     "src/interfaces/INuclearNerds.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface INuclearNerds {\n  function isOwnerOf(address account, uint256[] calldata _tokenIds) external view returns (bool);\n  function ownerOf(uint256 tokenid) external view returns (address);\n}\n"
30     },
31     "src/interfaces/IWarm.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IWarm {\n    function ownerOf(\n        address contractAddress,\n        uint256 tokenId\n    ) external view returns (address);\n}\n"
33     },
34     "src/lib/MarauderErrors.sol": {
35       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nerror InvalidProof();\nerror WrongValueSent();\nerror ExceedMaxSupply();\nerror InvalidCaller();\nerror TokenTypeSoldOut();\nerror MustOwnMatchingNerd();\nerror AllBerserkersMinted();\nerror AlreadyClaimed();\nerror ConsumerAlreadySet();\nerror SaleNotActive();\nerror ArrayLengthMismatch();\nerror ExceedMaxPerWallet();\nerror SmashingNotActive();\nerror FailedToMint();\nerror ClaimNotStarted();\nerror MintZeroAmount();\n"
36     },
37     "src/lib/MarauderStructs.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nstruct MintableTokenDetails {\n  uint16 startTokenId;\n  uint16 currentTokenId;\n}\n\nstruct ClaimableTokenDetails {\n  uint16 totalSupply;\n  uint16 currentBonusTokenId;\n  uint16 maxBonusTokenId;\n}\n\nstruct PhaseDetails {\n  bytes32 root;\n  uint64 startTime;\n}\n\nstruct ItemDetails {\n  bytes4 mintFunctionSelector;\n  uint16 numUnitsSold;\n  uint16 maxUnitsAllowed;\n  uint16 maxNerdPhaseUnitsAllowedPerWallet;\n  address mintContractAddress;\n  uint64 price;\n  uint64 discountedPrice;\n}\n\nstruct MintTracker {\n  uint32 numBoxesMinted;\n  uint32 numEnforcersMinted;\n  uint32 numWarlordsMinted;\n  uint32 numSerumsMinted;\n}"
39     }
40   },
41   "settings": {
42     "remappings": [
43       "@openzeppelin/=lib/Guardable/lib/openzeppelin-contracts/",
44       "ERC721A/=lib/ERC721A/contracts/",
45       "Guardable/=lib/Guardable/src/tokens/",
46       "ds-test/=lib/forge-std/lib/ds-test/src/",
47       "forge-std/=lib/forge-std/src/",
48       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
49       "openzeppelin/=lib/openzeppelin-contracts/",
50       "solmate/=lib/solmate/src/"
51     ],
52     "optimizer": {
53       "enabled": true,
54       "runs": 200
55     },
56     "metadata": {
57       "bytecodeHash": "ipfs",
58       "appendCBOR": true
59     },
60     "outputSelection": {
61       "*": {
62         "*": [
63           "evm.bytecode",
64           "evm.deployedBytecode",
65           "devdoc",
66           "userdoc",
67           "metadata",
68           "abi"
69         ]
70       }
71     },
72     "evmVersion": "london",
73     "libraries": {}
74   }
75 }}