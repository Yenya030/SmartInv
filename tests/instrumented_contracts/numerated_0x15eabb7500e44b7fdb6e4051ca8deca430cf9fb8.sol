1 /*
2 
3 * This file was generated by MyWish Platform (https://mywish.io/)
4 
5 * The complete code could be found at https://github.com/MyWishPlatform/
6 
7 * Copyright (C) 2018 MyWish
8 
9 *
10 
11 * This program is free software: you can redistribute it and/or modify
12 
13 * it under the terms of the GNU Lesser General Public License as published by
14 
15 * the Free Software Foundation, either version 3 of the License, or
16 
17 * (at your option) any later version.
18 
19 *
20 
21 * This program is distributed in the hope that it will be useful,
22 
23 * but WITHOUT ANY WARRANTY; without even the implied warranty of
24 
25 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
26 
27 * GNU Lesser General Public License for more details.
28 
29 *
30 
31 * You should have received a copy of the GNU Lesser General Public License
32 
33 * along with this program. If not, see <http://www.gnu.org/licenses/>.
34 
35 */
36 
37 pragma solidity ^0.4.23;
38 
39 /**
40 
41 * @title ERC20Basic
42 
43 * @dev Simpler version of ERC20 interface
44 
45 * @dev see https://github.com/ethereum/EIPs/issues/179
46 
47 */
48 
49 contract ERC20Basic {
50 
51 function totalSupply() public view returns (uint256);
52 
53 function balanceOf(address who) public view returns (uint256);
54 
55 function transfer(address to, uint256 value) public returns (bool);
56 
57 event Transfer(address indexed from, address indexed to, uint256 value);
58 
59 }
60 
61 /**
62 
63 * @title SafeMath
64 
65 * @dev Math operations with safety checks that throw on error
66 
67 */
68 
69 library SafeMath {
70 
71 /**
72 
73 * @dev Multiplies two numbers, throws on overflow.
74 
75 */
76 
77 function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
78 
79 // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
80 
81 // benefit is lost if 'b' is also tested.
82 
83 // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
84 
85 if (a == 0) {
86 
87 return 0;
88 
89 }
90 
91 c = a * b;
92 
93 assert(c / a == b);
94 
95 return c;
96 
97 }
98 
99 /**
100 
101 * @dev Integer division of two numbers, truncating the quotient.
102 
103 */
104 
105 function div(uint256 a, uint256 b) internal pure returns (uint256) {
106 
107 // assert(b > 0); // Solidity automatically throws when dividing by 0
108 
109 // uint256 c = a / b;
110 
111 // assert(a == b * c + a % b); // There is no case in which this doesn't hold
112 
113 return a / b;
114 
115 }
116 
117 /**
118 
119 * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
120 
121 */
122 
123 function sub(uint256 a, uint256 b) internal pure returns (uint256) {
124 
125 assert(b <= a);
126 
127 return a - b;
128 
129 }
130 
131 /**
132 
133 * @dev Adds two numbers, throws on overflow.
134 
135 */
136 
137 function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
138 
139 c = a + b;
140 
141 assert(c >= a);
142 
143 return c;
144 
145 }
146 
147 }
148 
149 /**
150 
151 * @title Basic token
152 
153 * @dev Basic version of StandardToken, with no allowances.
154 
155 */
156 
157 contract BasicToken is ERC20Basic {
158 
159 using SafeMath for uint256;
160 
161 mapping(address => uint256) balances;
162 
163 uint256 totalSupply_;
164 
165 /**
166 
167 * @dev total number of tokens in existence
168 
169 */
170 
171 function totalSupply() public view returns (uint256) {
172 
173 return totalSupply_;
174 
175 }
176 
177 /**
178 
179 * @dev transfer token for a specified address
180 
181 * @param _to The address to transfer to.
182 
183 * @param _value The amount to be transferred.
184 
185 */
186 
187 function transfer(address _to, uint256 _value) public returns (bool) {
188 
189 require(_to != address(0));
190 
191 require(_value <= balances[msg.sender]);
192 
193 balances[msg.sender] = balances[msg.sender].sub(_value);
194 
195 balances[_to] = balances[_to].add(_value);
196 
197 emit Transfer(msg.sender, _to, _value);
198 
199 return true;
200 
201 }
202 
203 /**
204 
205 * @dev Gets the balance of the specified address.
206 
207 * @param _owner The address to query the the balance of.
208 
209 * @return An uint256 representing the amount owned by the passed address.
210 
211 */
212 
213 function balanceOf(address _owner) public view returns (uint256) {
214 
215 return balances[_owner];
216 
217 }
218 
219 }
220 
221 /**
222 
223 * @title ERC20 interface
224 
225 * @dev see https://github.com/ethereum/EIPs/issues/20
226 
227 */
228 
229 contract ERC20 is ERC20Basic {
230 
231 function allowance(address owner, address spender)
232 
233 public view returns (uint256);
234 
235 function transferFrom(address from, address to, uint256 value)
236 
237 public returns (bool);
238 
239 function approve(address spender, uint256 value) public returns (bool);
240 
241 event Approval(
242 
243 address indexed owner,
244 
245 address indexed spender,
246 
247 uint256 value
248 
249 );
250 
251 }
252 
253 /**
254 
255 * @title Standard ERC20 token
256 
257 *
258 
259 * @dev Implementation of the basic standard token.
260 
261 * @dev https://github.com/ethereum/EIPs/issues/20
262 
263 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
264 
265 */
266 
267 contract StandardToken is ERC20, BasicToken {
268 
269 mapping (address => mapping (address => uint256)) internal allowed;
270 
271 /**
272 
273 * @dev Transfer tokens from one address to another
274 
275 * @param _from address The address which you want to send tokens from
276 
277 * @param _to address The address which you want to transfer to
278 
279 * @param _value uint256 the amount of tokens to be transferred
280 
281 */
282 
283 function transferFrom(
284 
285 address _from,
286 
287 address _to,
288 
289 uint256 _value
290 
291 )
292 
293 public
294 
295 returns (bool)
296 
297 {
298 
299 require(_to != address(0));
300 
301 require(_value <= balances[_from]);
302 
303 require(_value <= allowed[_from][msg.sender]);
304 
305 balances[_from] = balances[_from].sub(_value);
306 
307 balances[_to] = balances[_to].add(_value);
308 
309 allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
310 
311 emit Transfer(_from, _to, _value);
312 
313 return true;
314 
315 }
316 
317 /**
318 
319 * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
320 
321 *
322 
323 * Beware that changing an allowance with this method brings the risk that someone may use both the old
324 
325 * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
326 
327 * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
328 
329 * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
330 
331 * @param _spender The address which will spend the funds.
332 
333 * @param _value The amount of tokens to be spent.
334 
335 */
336 
337 function approve(address _spender, uint256 _value) public returns (bool) {
338 
339 allowed[msg.sender][_spender] = _value;
340 
341 emit Approval(msg.sender, _spender, _value);
342 
343 return true;
344 
345 }
346 
347 /**
348 
349 * @dev Function to check the amount of tokens that an owner allowed to a spender.
350 
351 * @param _owner address The address which owns the funds.
352 
353 * @param _spender address The address which will spend the funds.
354 
355 * @return A uint256 specifying the amount of tokens still available for the spender.
356 
357 */
358 
359 function allowance(
360 
361 address _owner,
362 
363 address _spender
364 
365 )
366 
367 public
368 
369 view
370 
371 returns (uint256)
372 
373 {
374 
375 return allowed[_owner][_spender];
376 
377 }
378 
379 /**
380 
381 * @dev Increase the amount of tokens that an owner allowed to a spender.
382 
383 *
384 
385 * approve should be called when allowed[_spender] == 0. To increment
386 
387 * allowed value is better to use this function to avoid 2 calls (and wait until
388 
389 * the first transaction is mined)
390 
391 * From MonolithDAO Token.sol
392 
393 * @param _spender The address which will spend the funds.
394 
395 * @param _addedValue The amount of tokens to increase the allowance by.
396 
397 */
398 
399 function increaseApproval(
400 
401 address _spender,
402 
403 uint _addedValue
404 
405 )
406 
407 public
408 
409 returns (bool)
410 
411 {
412 
413 allowed[msg.sender][_spender] = (
414 
415 allowed[msg.sender][_spender].add(_addedValue));
416 
417 emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
418 
419 return true;
420 
421 }
422 
423 /**
424 
425 * @dev Decrease the amount of tokens that an owner allowed to a spender.
426 
427 *
428 
429 * approve should be called when allowed[_spender] == 0. To decrement
430 
431 * allowed value is better to use this function to avoid 2 calls (and wait until
432 
433 * the first transaction is mined)
434 
435 * From MonolithDAO Token.sol
436 
437 * @param _spender The address which will spend the funds.
438 
439 * @param _subtractedValue The amount of tokens to decrease the allowance by.
440 
441 */
442 
443 function decreaseApproval(
444 
445 address _spender,
446 
447 uint _subtractedValue
448 
449 )
450 
451 public
452 
453 returns (bool)
454 
455 {
456 
457 uint oldValue = allowed[msg.sender][_spender];
458 
459 if (_subtractedValue > oldValue) {
460 
461 allowed[msg.sender][_spender] = 0;
462 
463 } else {
464 
465 allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
466 
467 }
468 
469 emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
470 
471 return true;
472 
473 }
474 
475 }
476 
477 /**
478 
479 * @title Ownable
480 
481 * @dev The Ownable contract has an owner address, and provides basic authorization control
482 
483 * functions, this simplifies the implementation of "user permissions".
484 
485 */
486 
487 contract Ownable {
488 
489 address public owner;
490 
491 event OwnershipRenounced(address indexed previousOwner);
492 
493 event OwnershipTransferred(
494 
495 address indexed previousOwner,
496 
497 address indexed newOwner
498 
499 );
500 
501 /**
502 
503 * @dev The Ownable constructor sets the original `owner` of the contract to the sender
504 
505 * account.
506 
507 */
508 
509 constructor() public {
510 
511 owner = msg.sender;
512 
513 }
514 
515 /**
516 
517 * @dev Throws if called by any account other than the owner.
518 
519 */
520 
521 modifier onlyOwner() {
522 
523 require(msg.sender == owner);
524 
525 _;
526 
527 }
528 
529 /**
530 
531 * @dev Allows the current owner to relinquish control of the contract.
532 
533 */
534 
535 function renounceOwnership() public onlyOwner {
536 
537 emit OwnershipRenounced(owner);
538 
539 owner = address(0);
540 
541 }
542 
543 /**
544 
545 * @dev Allows the current owner to transfer control of the contract to a newOwner.
546 
547 * @param _newOwner The address to transfer ownership to.
548 
549 */
550 
551 function transferOwnership(address _newOwner) public onlyOwner {
552 
553 _transferOwnership(_newOwner);
554 
555 }
556 
557 /**
558 
559 * @dev Transfers control of the contract to a newOwner.
560 
561 * @param _newOwner The address to transfer ownership to.
562 
563 */
564 
565 function _transferOwnership(address _newOwner) internal {
566 
567 require(_newOwner != address(0));
568 
569 emit OwnershipTransferred(owner, _newOwner);
570 
571 owner = _newOwner;
572 
573 }
574 
575 }
576 
577 /**
578 
579 * @title Mintable token
580 
581 * @dev Simple ERC20 Token example, with mintable token creation
582 
583 * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
584 
585 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
586 
587 */
588 
589 contract MintableToken is StandardToken, Ownable {
590 
591 event Mint(address indexed to, uint256 amount);
592 
593 event MintFinished();
594 
595 bool public mintingFinished = false;
596 
597 modifier canMint() {
598 
599 require(!mintingFinished);
600 
601 _;
602 
603 }
604 
605 modifier hasMintPermission() {
606 
607 require(msg.sender == owner);
608 
609 _;
610 
611 }
612 
613 /**
614 
615 * @dev Function to mint tokens
616 
617 * @param _to The address that will receive the minted tokens.
618 
619 * @param _amount The amount of tokens to mint.
620 
621 * @return A boolean that indicates if the operation was successful.
622 
623 */
624 
625 function mint(
626 
627 address _to,
628 
629 uint256 _amount
630 
631 )
632 
633 hasMintPermission
634 
635 canMint
636 
637 public
638 
639 returns (bool)
640 
641 {
642 
643 totalSupply_ = totalSupply_.add(_amount);
644 
645 balances[_to] = balances[_to].add(_amount);
646 
647 emit Mint(_to, _amount);
648 
649 emit Transfer(address(0), _to, _amount);
650 
651 return true;
652 
653 }
654 
655 /**
656 
657 * @dev Function to stop minting new tokens.
658 
659 * @return True if the operation was successful.
660 
661 */
662 
663 function finishMinting() onlyOwner canMint public returns (bool) {
664 
665 mintingFinished = true;
666 
667 emit MintFinished();
668 
669 return true;
670 
671 }
672 
673 }
674 
675 contract FreezableToken is StandardToken {
676 
677 // freezing chains
678 
679 mapping (bytes32 => uint64) internal chains;
680 
681 // freezing amounts for each chain
682 
683 mapping (bytes32 => uint) internal freezings;
684 
685 // total freezing balance per address
686 
687 mapping (address => uint) internal freezingBalance;
688 
689 event Freezed(address indexed to, uint64 release, uint amount);
690 
691 event Released(address indexed owner, uint amount);
692 
693 /**
694 
695 * @dev Gets the balance of the specified address include freezing tokens.
696 
697 * @param _owner The address to query the the balance of.
698 
699 * @return An uint256 representing the amount owned by the passed address.
700 
701 */
702 
703 function balanceOf(address _owner) public view returns (uint256 balance) {
704 
705 return super.balanceOf(_owner) + freezingBalance[_owner];
706 
707 }
708 
709 /**
710 
711 * @dev Gets the balance of the specified address without freezing tokens.
712 
713 * @param _owner The address to query the the balance of.
714 
715 * @return An uint256 representing the amount owned by the passed address.
716 
717 */
718 
719 function actualBalanceOf(address _owner) public view returns (uint256 balance) {
720 
721 return super.balanceOf(_owner);
722 
723 }
724 
725 function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
726 
727 return freezingBalance[_owner];
728 
729 }
730 
731 /**
732 
733 * @dev gets freezing count
734 
735 * @param _addr Address of freeze tokens owner.
736 
737 */
738 
739 function freezingCount(address _addr) public view returns (uint count) {
740 
741 uint64 release = chains[toKey(_addr, 0)];
742 
743 while (release != 0) {
744 
745 count++;
746 
747 release = chains[toKey(_addr, release)];
748 
749 }
750 
751 }
752 
753 /**
754 
755 * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
756 
757 * @param _addr Address of freeze tokens owner.
758 
759 * @param _index Freezing portion index. It ordered by release date descending.
760 
761 */
762 
763 function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
764 
765 for (uint i = 0; i < _index + 1; i++) {
766 
767 _release = chains[toKey(_addr, _release)];
768 
769 if (_release == 0) {
770 
771 return;
772 
773 }
774 
775 }
776 
777 _balance = freezings[toKey(_addr, _release)];
778 
779 }
780 
781 /**
782 
783 * @dev freeze your tokens to the specified address.
784 
785 * Be careful, gas usage is not deterministic,
786 
787 * and depends on how many freezes _to address already has.
788 
789 * @param _to Address to which token will be freeze.
790 
791 * @param _amount Amount of token to freeze.
792 
793 * @param _until Release date, must be in future.
794 
795 */
796 
797 function freezeTo(address _to, uint _amount, uint64 _until) public {
798 
799 require(_to != address(0));
800 
801 require(_amount <= balances[msg.sender]);
802 
803 balances[msg.sender] = balances[msg.sender].sub(_amount);
804 
805 bytes32 currentKey = toKey(_to, _until);
806 
807 freezings[currentKey] = freezings[currentKey].add(_amount);
808 
809 freezingBalance[_to] = freezingBalance[_to].add(_amount);
810 
811 freeze(_to, _until);
812 
813 emit Transfer(msg.sender, _to, _amount);
814 
815 emit Freezed(_to, _until, _amount);
816 
817 }
818 
819 /**
820 
821 * @dev release first available freezing tokens.
822 
823 */
824 
825 function releaseOnce() public {
826 
827 bytes32 headKey = toKey(msg.sender, 0);
828 
829 uint64 head = chains[headKey];
830 
831 require(head != 0);
832 
833 require(uint64(block.timestamp) > head);
834 
835 bytes32 currentKey = toKey(msg.sender, head);
836 
837 uint64 next = chains[currentKey];
838 
839 uint amount = freezings[currentKey];
840 
841 delete freezings[currentKey];
842 
843 balances[msg.sender] = balances[msg.sender].add(amount);
844 
845 freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
846 
847 if (next == 0) {
848 
849 delete chains[headKey];
850 
851 } else {
852 
853 chains[headKey] = next;
854 
855 delete chains[currentKey];
856 
857 }
858 
859 emit Released(msg.sender, amount);
860 
861 }
862 
863 /**
864 
865 * @dev release all available for release freezing tokens. Gas usage is not deterministic!
866 
867 * @return how many tokens was released
868 
869 */
870 
871 function releaseAll() public returns (uint tokens) {
872 
873 uint release;
874 
875 uint balance;
876 
877 (release, balance) = getFreezing(msg.sender, 0);
878 
879 while (release != 0 && block.timestamp > release) {
880 
881 releaseOnce();
882 
883 tokens += balance;
884 
885 (release, balance) = getFreezing(msg.sender, 0);
886 
887 }
888 
889 }
890 
891 function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
892 
893 // WISH masc to increase entropy
894 
895 result = 0x5749534800000000000000000000000000000000000000000000000000000000;
896 
897 assembly {
898 
899 result := or(result, mul(_addr, 0x10000000000000000))
900 
901 result := or(result, _release)
902 
903 }
904 
905 }
906 
907 function freeze(address _to, uint64 _until) internal {
908 
909 require(_until > block.timestamp);
910 
911 bytes32 key = toKey(_to, _until);
912 
913 bytes32 parentKey = toKey(_to, uint64(0));
914 
915 uint64 next = chains[parentKey];
916 
917 if (next == 0) {
918 
919 chains[parentKey] = _until;
920 
921 return;
922 
923 }
924 
925 bytes32 nextKey = toKey(_to, next);
926 
927 uint parent;
928 
929 while (next != 0 && _until > next) {
930 
931 parent = next;
932 
933 parentKey = nextKey;
934 
935 next = chains[nextKey];
936 
937 nextKey = toKey(_to, next);
938 
939 }
940 
941 if (_until == next) {
942 
943 return;
944 
945 }
946 
947 if (next != 0) {
948 
949 chains[key] = next;
950 
951 }
952 
953 chains[parentKey] = _until;
954 
955 }
956 
957 }
958 
959 /**
960 
961 * @title Burnable Token
962 
963 * @dev Token that can be irreversibly burned (destroyed).
964 
965 */
966 
967 contract BurnableToken is BasicToken {
968 
969 event Burn(address indexed burner, uint256 value);
970 
971 /**
972 
973 * @dev Burns a specific amount of tokens.
974 
975 * @param _value The amount of token to be burned.
976 
977 */
978 
979 function burn(uint256 _value) public {
980 
981 _burn(msg.sender, _value);
982 
983 }
984 
985 function _burn(address _who, uint256 _value) internal {
986 
987 require(_value <= balances[_who]);
988 
989 // no need to require value <= totalSupply, since that would imply the
990 
991 // sender's balance is greater than the totalSupply, which *should* be an assertion failure
992 
993 balances[_who] = balances[_who].sub(_value);
994 
995 totalSupply_ = totalSupply_.sub(_value);
996 
997 emit Burn(_who, _value);
998 
999 emit Transfer(_who, address(0), _value);
1000 
1001 }
1002 
1003 }
1004 
1005 /**
1006 
1007 * @title Pausable
1008 
1009 * @dev Base contract which allows children to implement an emergency stop mechanism.
1010 
1011 */
1012 
1013 contract Pausable is Ownable {
1014 
1015 event Pause();
1016 
1017 event Unpause();
1018 
1019 bool public paused = false;
1020 
1021 /**
1022 
1023 * @dev Modifier to make a function callable only when the contract is not paused.
1024 
1025 */
1026 
1027 modifier whenNotPaused() {
1028 
1029 require(!paused);
1030 
1031 _;
1032 
1033 }
1034 
1035 /**
1036 
1037 * @dev Modifier to make a function callable only when the contract is paused.
1038 
1039 */
1040 
1041 modifier whenPaused() {
1042 
1043 require(paused);
1044 
1045 _;
1046 
1047 }
1048 
1049 /**
1050 
1051 * @dev called by the owner to pause, triggers stopped state
1052 
1053 */
1054 
1055 function pause() onlyOwner whenNotPaused public {
1056 
1057 paused = true;
1058 
1059 emit Pause();
1060 
1061 }
1062 
1063 /**
1064 
1065 * @dev called by the owner to unpause, returns to normal state
1066 
1067 */
1068 
1069 function unpause() onlyOwner whenPaused public {
1070 
1071 paused = false;
1072 
1073 emit Unpause();
1074 
1075 }
1076 
1077 }
1078 
1079 contract FreezableMintableToken is FreezableToken, MintableToken {
1080 
1081 /**
1082 
1083 * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
1084 
1085 * Be careful, gas usage is not deterministic,
1086 
1087 * and depends on how many freezes _to address already has.
1088 
1089 * @param _to Address to which token will be freeze.
1090 
1091 * @param _amount Amount of token to mint and freeze.
1092 
1093 * @param _until Release date, must be in future.
1094 
1095 * @return A boolean that indicates if the operation was successful.
1096 
1097 */
1098 
1099 function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
1100 
1101 totalSupply_ = totalSupply_.add(_amount);
1102 
1103 bytes32 currentKey = toKey(_to, _until);
1104 
1105 freezings[currentKey] = freezings[currentKey].add(_amount);
1106 
1107 freezingBalance[_to] = freezingBalance[_to].add(_amount);
1108 
1109 freeze(_to, _until);
1110 
1111 emit Mint(_to, _amount);
1112 
1113 emit Freezed(_to, _until, _amount);
1114 
1115 emit Transfer(msg.sender, _to, _amount);
1116 
1117 return true;
1118 
1119 }
1120 
1121 }
1122 
1123 contract Consts {
1124 
1125 uint public constant TOKEN_DECIMALS = 18;
1126 
1127 uint8 public constant TOKEN_DECIMALS_UINT8 = 18;
1128 
1129 uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
1130 
1131 string public constant TOKEN_NAME = "Dexfin";
1132 
1133 string public constant TOKEN_SYMBOL = "DXF";
1134 
1135 bool public constant PAUSED = false;
1136 
1137 address public constant TARGET_USER = 0x7Ff42Ed42Baf8d4A8ba376ABE8623A599ECA0Ef0;
1138 
1139 bool public constant CONTINUE_MINTING = false;
1140 
1141 }
1142 
1143 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
1144 
1145 {
1146 
1147 event Initialized();
1148 
1149 bool public initialized = false;
1150 
1151 constructor() public {
1152 
1153 init();
1154 
1155 transferOwnership(TARGET_USER);
1156 
1157 }
1158 
1159 function name() public pure returns (string _name) {
1160 
1161 return TOKEN_NAME;
1162 
1163 }
1164 
1165 function symbol() public pure returns (string _symbol) {
1166 
1167 return TOKEN_SYMBOL;
1168 
1169 }
1170 
1171 function decimals() public pure returns (uint8 _decimals) {
1172 
1173 return TOKEN_DECIMALS_UINT8;
1174 
1175 }
1176 
1177 function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
1178 
1179 require(!paused);
1180 
1181 return super.transferFrom(_from, _to, _value);
1182 
1183 }
1184 
1185 function transfer(address _to, uint256 _value) public returns (bool _success) {
1186 
1187 require(!paused);
1188 
1189 return super.transfer(_to, _value);
1190 
1191 }
1192 
1193 function init() private {
1194 
1195 require(!initialized);
1196 
1197 initialized = true;
1198 
1199 if (PAUSED) {
1200 
1201 pause();
1202 
1203 }
1204 
1205 address[1] memory addresses = [address(0x43d0e7786185dc29c3ce0ad28eef31b9349c111b)];
1206 
1207 uint[1] memory amounts = [uint(1168000000000000000000000000)];
1208 
1209 uint64[1] memory freezes = [uint64(0)];
1210 
1211 for (uint i = 0; i < addresses.length; i++) {
1212 
1213 if (freezes[i] == 0) {
1214 
1215 mint(addresses[i], amounts[i]);
1216 
1217 } else {
1218 
1219 mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1220 
1221 }
1222 
1223 }
1224 
1225 if (!CONTINUE_MINTING) {
1226 
1227 finishMinting();
1228 
1229 }
1230 
1231 emit Initialized();
1232 
1233 }
1234 
1235 }