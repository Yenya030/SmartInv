1 /**
2  *Submitted for verification at Etherscan.io on 2021-06-05
3 */
4 
5 /*
6 
7 
8  t.me/shibaramen
9  Shiba Ramen
10  $SHIBARAMEN
11  
12  So delicious! 
13 
14                                                                              ████████            
15                                                                     ██░░▓▓▓▓▒▒▒▒▒▒██            
16                                                             ████████▒▒▒▒▒▒▒▒████████            
17                                                     ░░░░██▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒██            
18                                             ████████▒▒▒▒▒▒░░████████▒▒▒▒▒▒▒▒██████              
19                                     ████████▒▒▒▒▒▒▒▒████▓▓██▒▒▒▒▒▒▒▒████████                    
20                             ██▓▓▓▓▓▓▒▒▒▒▒▒▒▒████████▒▒░░▒▒▒▒████████                            
21                       ██████▒▒██▓▓▒▒████████▒▒▒▒▒▒▒▒▓▓██████                                    
22                     ██▒▒▒▒▒▒██░░░░██░░██▒▒▒▒██████▓▓                                            
23                     ████████░░░░░░░░░░██████                                                    
24                     ██▒▒▒▒██░░██░░░░░░██                                                        
25                     ██▓▓████░░██░░░░░░██                                                        
26                           ██░░██░░░░░░██                                                        
27                           ██░░██░░░░░░░░▓▓                                                      
28                             ▓▓░░▓▓░░░░░░████▓▓▓▓▒▒██████▓▓▓▓                                    
29                         ██████░░██░░▓▓  ██▓▓▓▓▓▓▓▓██▓▓██▓▓▓▓██    ██▓▓▓▓                        
30                 ██▓▓████▒▒▓▓██░░██░░██  ██▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▒▒▓▓▒▒▓▓▓▓██████▓▓                
31           ██▓▓██▒▒▒▒▒▒▒▒▓▓▓▓██░░▓▓░░██  ██▓▓▓▓▓▓▓▓▓▓▒▒▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒██████          
32       ██▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓██░░██░░██░░██▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒████      
33     ██▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░████░░████████████████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒██    
34   ██▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████░░████░░██  ░░░░▒▒▒▒▒▒▒▒░░░░████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒██  
35 ██▒▒▓▓▓▓▓▓▓▓▓▓▓▓████████▒▒▒▒▒▒██  ██░░░░██▒▒▒▒██████░░░░████░░░░░░░░░░░░████████▓▓▓▓▓▓▓▓▓▓▓▓▒▒██
36 ██▒▒▓▓▓▓▓▓██████▒▒▒▒▒▒▒▒░░░░░░██░░██░░░░██░░░░░░░░░░██▓▓    ██▒▒▒▒▒▒  ████░░░░░░██████▓▓▓▓▓▓▒▒██
37 ██▒▒██▓▓██░░░░░░░░▒▒██████▒▒████░░██░░░░██████▒▒░░██      ▒▒  ██▒▒████    ██░░▒▒▒▒▒▒░░██▓▓██▒▒██
38 ██▓▓▒▒██▒▒▒▒▒▒██████  ░░░░██░░░░██░░██  ██░░░░██▒▒██  ▒▒▒▒░░▒▒░░██    ▒▒    ██░░░░  ░░░░██▒▒▓▓██
39 ██▓▓▓▓▒▒████▒▒▒▒▒▒▒▒▒▒▒▒████▒▒████░░░░██░░██▒▒░░██    ░░░░░░▒▒██  ░░░░░░░░░░██▒▒░░▒▒████▒▒▓▓▓▓██
40   ██▓▓▓▓▒▒▒▒██▓▓████▒▒░░░░░░░░░░██████░░██░░██████  ░░░░▒▒░░██  ▒▒░░▒▒▒▒░░░░████████▒▒▒▒▓▓▓▓██  
41   ██▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒██████████▒▒▒▒▒▒░░░░░░▒▒░░▒▒██  ░░▒▒▒▒██░░░░▒▒██████████▒▒▒▒▓▓▒▒▓▓▓▓▓▓▓▓██  
42     ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▒▒██▓▓▓▓████▓▓▓▓▓▓██▓▓██▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓██░░  
43     ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓██    
44       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██      
45         ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██        
46         ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██        
47           ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██          
48             ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██            
49             ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██            
50               ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██              
51                 ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                
52                   ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                  
53                     ██▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                    
54                       ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                      
55                         ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                        
56                           ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                          
57                             ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                            
58                               ████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████                              
59                                   ████████████████████████████                                  
60                                     ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██                                    
61                                       ████████████████████                                      
62   ░░░░                                                        ░░░░                              
63   ░░    ░░░░  ░░  ░░                                                                            
64 
65  
66  Twitter: https://twitter.com/shibaramenn
67 
68  Telegram: https://t.me/shibaramen (https://t.me/shibaramen)
69 
70  Instagram: https://instagram.com/officialshibaramen?utm_medium=copy_link
71 
72  Reddit: https://www.reddit.com/r/ShibaRamen/
73 
74  Marketing paid
75 
76  Liqudity Locked
77  
78  wnership renounced
79  
80  No Devwallets
81  
82  CG, CMC listing: Ongoing
83 
84  SPDX-License-Identifier: Mines™®©
85 */
86 pragma solidity ^0.8.4;
87 
88 abstract contract Context {
89     function _msgSender() internal view virtual returns (address) {
90         return msg.sender;
91     }
92 }
93 
94 interface IERC20 {
95     function totalSupply() external view returns (uint256);
96     function balanceOf(address account) external view returns (uint256);
97     function transfer(address recipient, uint256 amount) external returns (bool);
98     function allowance(address owner, address spender) external view returns (uint256);
99     function approve(address spender, uint256 amount) external returns (bool);
100     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
101     event Transfer(address indexed from, address indexed to, uint256 value);
102     event Approval(address indexed owner, address indexed spender, uint256 value);
103 }
104 
105 library SafeMath {
106     function add(uint256 a, uint256 b) internal pure returns (uint256) {
107         uint256 c = a + b;
108         require(c >= a, "SafeMath: addition overflow");
109         return c;
110     }
111 
112     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
113         return sub(a, b, "SafeMath: subtraction overflow");
114     }
115 
116     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
117         require(b <= a, errorMessage);
118         uint256 c = a - b;
119         return c;
120     }
121 
122     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
123         if (a == 0) {
124             return 0;
125         }
126         uint256 c = a * b;
127         require(c / a == b, "SafeMath: multiplication overflow");
128         return c;
129     }
130 
131     function div(uint256 a, uint256 b) internal pure returns (uint256) {
132         return div(a, b, "SafeMath: division by zero");
133     }
134 
135     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
136         require(b > 0, errorMessage);
137         uint256 c = a / b;
138         return c;
139     }
140 
141 }
142 
143 contract Ownable is Context {
144     address private _owner;
145     address private _previousOwner;
146     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
147 
148     constructor () {
149         address msgSender = _msgSender();
150         _owner = msgSender;
151         emit OwnershipTransferred(address(0), msgSender);
152     }
153 
154     function owner() public view returns (address) {
155         return _owner;
156     }
157 
158     modifier onlyOwner() {
159         require(_owner == _msgSender(), "Ownable: caller is not the owner");
160         _;
161     }
162 
163     function renounceOwnership() public virtual onlyOwner {
164         emit OwnershipTransferred(_owner, address(0));
165         _owner = address(0);
166     }
167 
168 }  
169 
170 interface IUniswapV2Factory {
171     function createPair(address tokenA, address tokenB) external returns (address pair);
172 }
173 
174 interface IUniswapV2Router02 {
175     function swapExactTokensForETHSupportingFeeOnTransferTokens(
176         uint amountIn,
177         uint amountOutMin,
178         address[] calldata path,
179         address to,
180         uint deadline
181     ) external;
182     function factory() external pure returns (address);
183     function WETH() external pure returns (address);
184     function addLiquidityETH(
185         address token,
186         uint amountTokenDesired,
187         uint amountTokenMin,
188         uint amountETHMin,
189         address to,
190         uint deadline
191     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
192 }
193 
194 contract SHIBARAMEN is Context, IERC20, Ownable {
195     using SafeMath for uint256;
196     mapping (address => uint256) private _rOwned;
197     mapping (address => uint256) private _tOwned;
198     mapping (address => mapping (address => uint256)) private _allowances;
199     mapping (address => bool) private _isExcludedFromFee;
200     mapping (address => bool) private bots;
201     mapping (address => uint) private cooldown;
202     uint256 private constant MAX = ~uint256(0);
203     uint256 private constant _tTotal = 1000000000000000000 * 10**9;
204     uint256 private _rTotal = (MAX - (MAX % _tTotal));
205     uint256 private _tFeeTotal;
206     string private constant _name = "Shiba Ramen";
207     string private constant _symbol = unicode'SHIBRAMEN🍜';
208     uint8 private constant _decimals = 9;
209     uint256 private _taxFee;
210     uint256 private _teamFee;
211     uint256 private _previousTaxFee = _taxFee;
212     uint256 private _previousteamFee = _teamFee;
213     address payable private _FeeAddress;
214     address payable private _marketingWalletAddress;
215     IUniswapV2Router02 private uniswapV2Router;
216     address private uniswapV2Pair;
217     bool private tradingOpen;
218     bool private inSwap = false;
219     bool private swapEnabled = false;
220     bool private cooldownEnabled = false;
221     uint256 private _maxTxAmount = _tTotal;
222     event MaxTxAmountUpdated(uint _maxTxAmount);
223     modifier lockTheSwap {
224         inSwap = true;
225         _;
226         inSwap = false;
227     }
228     constructor (address payable FeeAddress, address payable marketingWalletAddress) {
229         _FeeAddress = FeeAddress;
230         _marketingWalletAddress = marketingWalletAddress;
231         _rOwned[_msgSender()] = _rTotal;
232         _isExcludedFromFee[owner()] = true;
233         _isExcludedFromFee[address(this)] = true;
234         _isExcludedFromFee[FeeAddress] = true;
235         _isExcludedFromFee[marketingWalletAddress] = true;
236         emit Transfer(address(0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B), _msgSender(), _tTotal);
237     }
238 
239     function name() public pure returns (string memory) {
240         return _name;
241     }
242 
243     function symbol() public pure returns (string memory) {
244         return _symbol;
245     }
246 
247     function decimals() public pure returns (uint8) {
248         return _decimals;
249     }
250 
251     function totalSupply() public pure override returns (uint256) {
252         return _tTotal;
253     }
254 
255     function balanceOf(address account) public view override returns (uint256) {
256         return tokenFromReflection(_rOwned[account]);
257     }
258 
259     function transfer(address recipient, uint256 amount) public override returns (bool) {
260         _transfer(_msgSender(), recipient, amount);
261         return true;
262     }
263 
264     function allowance(address owner, address spender) public view override returns (uint256) {
265         return _allowances[owner][spender];
266     }
267 
268     function approve(address spender, uint256 amount) public override returns (bool) {
269         _approve(_msgSender(), spender, amount);
270         return true;
271     }
272 
273     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
274         _transfer(sender, recipient, amount);
275         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
276         return true;
277     }
278 
279     function setCooldownEnabled(bool onoff) external onlyOwner() {
280         cooldownEnabled = onoff;
281     }
282 
283     function tokenFromReflection(uint256 rAmount) private view returns(uint256) {
284         require(rAmount <= _rTotal, "Amount must be less than total reflections");
285         uint256 currentRate =  _getRate();
286         return rAmount.div(currentRate);
287     }
288 
289     function removeAllFee() private {
290         if(_taxFee == 0 && _teamFee == 0) return;
291         _previousTaxFee = _taxFee;
292         _previousteamFee = _teamFee;
293         _taxFee = 0;
294         _teamFee = 0;
295     }
296     
297     function restoreAllFee() private {
298         _taxFee = _previousTaxFee;
299         _teamFee = _previousteamFee;
300     }
301 
302     function _approve(address owner, address spender, uint256 amount) private {
303         require(owner != address(0), "ERC20: approve from the zero address");
304         require(spender != address(0), "ERC20: approve to the zero address");
305         _allowances[owner][spender] = amount;
306         emit Approval(owner, spender, amount);
307     }
308 
309     function _transfer(address from, address to, uint256 amount) private {
310         require(from != address(0), "ERC20: transfer from the zero address");
311         require(to != address(0), "ERC20: transfer to the zero address");
312         require(amount > 0, "Transfer amount must be greater than zero");
313         _taxFee = 5;
314         _teamFee = 10;
315         if (from != owner() && to != owner()) {
316             require(!bots[from] && !bots[to]);
317             if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {
318                 require(amount <= _maxTxAmount);
319                 require(cooldown[to] < block.timestamp);
320                 cooldown[to] = block.timestamp + (30 seconds);
321             }
322             if (to == uniswapV2Pair && from != address(uniswapV2Router) && ! _isExcludedFromFee[from]) {
323                 _taxFee = 5;
324                 _teamFee = 10;
325             }
326             uint256 contractTokenBalance = balanceOf(address(this));
327             if (!inSwap && from != uniswapV2Pair && swapEnabled) {
328                 swapTokensForEth(contractTokenBalance);
329                 uint256 contractETHBalance = address(this).balance;
330                 if(contractETHBalance > 0) {
331                     sendETHToFee(address(this).balance);
332                 }
333             }
334         }
335         bool takeFee = true;
336 
337         if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){
338             takeFee = false;
339         }
340 		
341         _tokenTransfer(from,to,amount,takeFee);
342     }
343 
344     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
345         address[] memory path = new address[](2);
346         path[0] = address(this);
347         path[1] = uniswapV2Router.WETH();
348         _approve(address(this), address(uniswapV2Router), tokenAmount);
349         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
350             tokenAmount,
351             0,
352             path,
353             address(this),
354             block.timestamp
355         );
356     }
357         
358     function sendETHToFee(uint256 amount) private {
359         _FeeAddress.transfer(amount.div(2));
360         _marketingWalletAddress.transfer(amount.div(2));
361     }
362     
363     function openTrading() external onlyOwner() {
364         require(!tradingOpen,"trading is already open");
365         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
366         uniswapV2Router = _uniswapV2Router;
367         _approve(address(this), address(uniswapV2Router), _tTotal);
368         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
369         uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
370         swapEnabled = true;
371         cooldownEnabled = true;
372         _maxTxAmount = 100000000000000000 * 10**9;
373         tradingOpen = true;
374         IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
375     }
376     
377     function setBots(address[] memory bots_) public onlyOwner {
378         for (uint i = 0; i < bots_.length; i++) {
379             bots[bots_[i]] = true;
380         }
381     }
382     
383     function delBot(address notbot) public onlyOwner {
384         bots[notbot] = false;
385     }
386         
387     function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {
388         if(!takeFee)
389             removeAllFee();
390         _transferStandard(sender, recipient, amount);
391         if(!takeFee)
392             restoreAllFee();
393     }
394 
395     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
396         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);
397         _rOwned[sender] = _rOwned[sender].sub(rAmount);
398         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); 
399         _takeTeam(tTeam);
400         _reflectFee(rFee, tFee);
401         emit Transfer(sender, recipient, tTransferAmount);
402     }
403 
404     function _takeTeam(uint256 tTeam) private {
405         uint256 currentRate =  _getRate();
406         uint256 rTeam = tTeam.mul(currentRate);
407         _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
408     }
409 
410     function _reflectFee(uint256 rFee, uint256 tFee) private {
411         _rTotal = _rTotal.sub(rFee);
412         _tFeeTotal = _tFeeTotal.add(tFee);
413     }
414 
415     receive() external payable {}
416     
417     function manualswap() external {
418         require(_msgSender() == _FeeAddress);
419         uint256 contractBalance = balanceOf(address(this));
420         swapTokensForEth(contractBalance);
421     }
422     
423     function manualsend() external {
424         require(_msgSender() == _FeeAddress);
425         uint256 contractETHBalance = address(this).balance;
426         sendETHToFee(contractETHBalance);
427     }
428     
429 
430     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
431         (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _taxFee, _teamFee);
432         uint256 currentRate =  _getRate();
433         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);
434         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
435     }
436 
437     function _getTValues(uint256 tAmount, uint256 taxFee, uint256 TeamFee) private pure returns (uint256, uint256, uint256) {
438         uint256 tFee = tAmount.mul(taxFee).div(100);
439         uint256 tTeam = tAmount.mul(TeamFee).div(100);
440         uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
441         return (tTransferAmount, tFee, tTeam);
442     }
443 
444     function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
445         uint256 rAmount = tAmount.mul(currentRate);
446         uint256 rFee = tFee.mul(currentRate);
447         uint256 rTeam = tTeam.mul(currentRate);
448         uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
449         return (rAmount, rTransferAmount, rFee);
450     }
451 
452 	function _getRate() private view returns(uint256) {
453         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
454         return rSupply.div(tSupply);
455     }
456 
457     function _getCurrentSupply() private view returns(uint256, uint256) {
458         uint256 rSupply = _rTotal;
459         uint256 tSupply = _tTotal;      
460         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
461         return (rSupply, tSupply);
462     }
463 
464     function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
465         require(maxTxPercent > 0, "Amount must be greater than 0");
466         _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);
467         emit MaxTxAmountUpdated(_maxTxAmount);
468     }
469 }