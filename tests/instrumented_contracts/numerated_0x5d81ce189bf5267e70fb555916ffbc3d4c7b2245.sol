1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/ens-contracts/contracts/ethregistrar/IBaseRegistrar.sol": {
5       "content": "import \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
6     },
7     "lib/ens-contracts/contracts/registry/ENS.sol": {
8       "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
9     },
10     "lib/ens-contracts/contracts/wrapper/IMetadataService.sol": {
11       "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
12     },
13     "lib/ens-contracts/contracts/wrapper/INameWrapper.sol": {
14       "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant CANNOT_APPROVE = 64;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
15     },
16     "lib/ens-contracts/contracts/wrapper/INameWrapperUpgrade.sol": {
17       "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}\n"
18     },
19     "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
21     },
22     "node_modules/@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
24     },
25     "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
27     },
28     "node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
30     },
31     "node_modules/@openzeppelin/contracts/utils/Context.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
33     },
34     "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
36     },
37     "src/EnsVision-BatchRenew.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./interfaces/IEnsRenewer.sol\";\nimport \"ens-contracts/ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {INameWrapper, CAN_EXTEND_EXPIRY} from \"ens-contracts/wrapper/INameWrapper.sol\";\n\ncontract EnsBatchRenew is Ownable {\n    IEnsRenewer public immutable ens;\n    IBaseRegistrar public immutable baseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    constructor(\n        IEnsRenewer _ens,\n        IBaseRegistrar _baseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        ens = _ens;\n        baseRegistrar = _baseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    /**\n     * Function called \"batchRenew\" that allows the caller to renew multiple ENS names in a single transaction\n     * @param _names: an array of strings representing the ENS names to be renewed\n     * @param _durations: an array of uint256 values representing the number of seconds for which each corresponding ENS name in \"names\" should be renewed\n     */\n    function batchRenew(\n        string[] calldata _names,\n        uint256[] calldata _durations\n    ) public payable {\n        //no price check in here. but ENS will revert if the price is not correct\n        for (uint256 i; i < _names.length; ) {\n            ens.renew{value: ens.rentPrice(_names[i], _durations[i])}(\n                _names[i],\n                _durations[i]\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        //return any excess funds to the caller if any\n        if (address(this).balance > 0) {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    /**\n        @notice Function called \"batchRenewAny\" that can renew both ENS names and subdomains in a single transaction\n        @param _names: an array of labels for TLDs\n        @param _durations: an array of uint256 values representing the number of seconds for which each corresponding ENS name in \"names\" should be renewed\n        @param _parentNodes: array of parent nodes for subdomains\n        @param _subLabelHashes: array of subdomain label hashes\n        @param _subExpiries: array of expires for subdomains\n     */\n    function batchRenewAny(\n        string[] calldata _names,\n        uint256[] calldata _durations,\n        bytes32[] calldata _parentNodes,\n        bytes32[] calldata _subLabelHashes,\n        uint64[] calldata _subExpiries\n    ) external payable {\n        batchRenew(_names, _durations);\n        batchRenewSubdomains(_parentNodes, _subLabelHashes, _subExpiries);\n    }\n\n    /**\n     * @notice Function called \"batchRenewSubdomains\" that allows the caller to renew multiple subdomains in a single transaction\n     * @dev Only can be renewed by owner of subdomain if CAN_EXTEND_EXPIRY fuse is set\n     * @dev Only can be renewed by owner of parent domain if CAN_EXTEND_EXPIRY fuse is not set\n     * @param _parentNodes: array of parent nodes for subdomains\n     * @param _subLabelHashes: array of subdomain label hashes\n     * @param _subExpiries: array of expiries for subdomains\n     */\n    function batchRenewSubdomains(\n        bytes32[] calldata _parentNodes,\n        bytes32[] calldata _subLabelHashes,\n        uint64[] calldata _subExpiries\n    ) public {\n        require(\n            _parentNodes.length == _subLabelHashes.length,\n            \"length mismatch\"\n        );\n        for (uint256 i; i < _parentNodes.length; ) {\n            bytes32 subdomainHash = keccak256(\n                abi.encodePacked(_parentNodes[i], _subLabelHashes[i])\n            );\n            (address owner, uint32 fuses, ) = nameWrapper.getData(\n                uint256(subdomainHash)\n            );\n\n            if (\n                (fuses & CAN_EXTEND_EXPIRY != 0 && owner == msg.sender) ||\n                (nameWrapper.ownerOf(uint256(_parentNodes[i])) == msg.sender)\n            ) {\n                nameWrapper.extendExpiry(\n                    _parentNodes[i],\n                    _subLabelHashes[i],\n                    _subExpiries[i]\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // withdraw any tokens that may be sent to this contract\n    function withdrawTokens(address _token) public onlyOwner {\n        IERC20 token = IERC20(_token);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Function called \"getPrice\" that allows the caller to calculate the total price for renewing a list of ENS names for specified durations\n     * @param _names: an array of strings representing the ENS names to be renewed\n     * @param _durations: an array of uint256 values representing the number of seconds for which each corresponding ENS name in \"names\" should be renewed\n     * @return _price the total price for renewing all the names in \"names\" for the corresponding durations in \"durations\"\n     */\n    function getPrice(\n        string[] calldata _names,\n        uint256[] memory _durations\n    ) public view returns (uint256 _price) {\n        require(_names.length == _durations.length, \"length mismatch\");\n\n        for (uint256 i; i < _names.length; ) {\n            //you can overflow it if you want.. not going to achive much though.\n            unchecked {\n                _price += ens.rentPrice(_names[i], _durations[i]);\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice\n     * This function retrieves the expiry time for each name in the given array.\n     *\n     * @param _names An array of names to get the expiry time for.\n     * @return _expiries An array of expiry times for the given names.\n     */\n    function getExpiryArrayFromLabels(\n        string[] calldata _names\n    ) public view returns (uint256[] memory _expiries) {\n        // Initialize the array to hold the expiry times to the same length as the names array.\n        _expiries = new uint256[](_names.length);\n\n        // Loop through each name in the array.\n        for (uint256 i; i < _names.length; ) {\n            // Get the expiry time for the name by hashing the name and looking up the expiry time using the hash as the ID.\n            _expiries[i] = baseRegistrar.nameExpires(\n                uint256(keccak256(abi.encodePacked(_names[i])))\n            );\n\n            // Increment the counter without checking for integer overflow.\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice\n     * This function retrieves the price for aggregated renewals.\n     *\n     * @param _names An array of names to get the expiry time for.\n     * @return _price A sum of the prices for each name.\n     */\n    function getSyncPriceFromLabels(\n        string[] calldata _names,\n        uint256 _syncdate\n    ) external view returns (uint256 _price) {\n        uint256[] memory durations = getSyncArrayFromLabels(_names, _syncdate);\n        _price = getPrice(_names, durations);\n    }\n\n    function visionRenew(\n        string[] calldata _names,\n        uint256 _duration\n    ) external payable {\n        for (uint256 i; i < _names.length; ) {\n            ens.renew{value: ens.rentPrice(_names[i], _duration)}(\n                _names[i],\n                _duration\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        //return any excess funds to the caller if any\n        if (address(this).balance > 0) {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    function syncExpirations(\n        string[] calldata _names,\n        uint256 _syncdate\n    ) external payable {\n        uint256[] memory durations = getSyncArrayFromLabels(_names, _syncdate);\n\n        for (uint256 i; i < _names.length; ) {\n            ens.renew{value: ens.rentPrice(_names[i], durations[i])}(\n                _names[i],\n                durations[i]\n            );\n            unchecked {\n                ++i;\n            }\n        }\n\n        //return any excess funds to the caller if any\n        if (address(this).balance > 0) {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    /**\n     * @notice\n     * This function retrieves the expiry time for each ID in the given array.\n     *\n     * @param _ids An array of IDs to get the expiry time for.\n     * @return _expiries An array of expiry times for the given IDs.\n     */\n    function getExpiryArray(\n        uint256[] calldata _ids\n    ) external view returns (uint256[] memory _expiries) {\n        // Initialize the array to hold the expiry times to the same length as the ID array.\n        _expiries = new uint256[](_ids.length);\n\n        // Loop through each ID in the array.\n        for (uint256 i; i < _ids.length; ) {\n            // Get the expiry time for the ID.\n            _expiries[i] = baseRegistrar.nameExpires(_ids[i]);\n\n            // Increment the counter without checking for integer overflow.\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice\n     * This function calculates the duration between a new expiry time and the current expiry time for each ID in the given array.\n     * If the new expiry time is earlier than the current expiry time, the duration will be set to 0.\n     *\n     * @param _ids An array of IDs to calculate the duration for.\n     * @param _newExpiry The new expiry time to use for the calculation.\n     */\n    function getSyncArray(\n        uint256[] calldata _ids,\n        uint256 _newExpiry\n    ) external view returns (uint256[] memory _durations) {\n        // Initialize the array to hold the durations to the same length as the ID array.\n        _durations = new uint256[](_ids.length);\n\n        // Loop through each ID in the array.\n        for (uint256 i; i < _ids.length; ) {\n            // Get the current expiry time for the ID.\n            uint256 expiry = baseRegistrar.nameExpires(_ids[i]);\n\n            // If the new expiry time is later than the current expiry time, set the duration to the difference between the two.\n            // Otherwise, set the duration to 0.\n            _durations[i] = _newExpiry > expiry ? _newExpiry - expiry : 0;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice\n     * This function calculates the duration between a new expiry time and the current expiry time for each label in the given array.\n     * If the new expiry time is earlier than the current expiry time, the duration will be set to 0.\n     *\n     * @param _labels An array of labels to calculate the duration for.\n     * @param _newExpiry The new expiry time to use for the calculation.\n     */\n    function getSyncArrayFromLabels(\n        string[] calldata _labels,\n        uint256 _newExpiry\n    ) public view returns (uint256[] memory _durations) {\n        // Initialize the array to hold the durations to the same length as the label array.\n        _durations = new uint256[](_labels.length);\n\n        // Loop through each label in the array.\n        for (uint256 i; i < _labels.length; ) {\n            // Get the current expiry time for the label by hashing the label and looking up the expiry time using the hash as the ID.\n            uint256 expiry = baseRegistrar.nameExpires(\n                uint256(keccak256(abi.encodePacked(_labels[i])))\n            );\n\n            // If the new expiry time is later than the current expiry time, set the duration to the difference between the two.\n            // Otherwise, set the duration to 0.\n            _durations[i] = _newExpiry > expiry ? _newExpiry - expiry : 0;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
39     },
40     "src/interfaces/IEnsRenewer.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IEnsRenewer {\n    function renew(string calldata _name, uint256 _duration) external payable;\n\n    function rentPrice(\n        string calldata _name,\n        uint256 _duration\n    ) external view returns (uint256);\n}\n"
42     }
43   },
44   "settings": {
45     "remappings": [
46       "@ens/=lib/EnsPrimaryContractNamer/lib/ens-contracts/contracts/",
47       "@ensdomains/buffer/=lib/buffer/",
48       "@openzeppelin/=node_modules/@openzeppelin/",
49       "EnsPrimaryContractNamer/=lib/EnsPrimaryContractNamer/src/",
50       "chainlink/=lib/chainlink/integration-tests/contracts/ethereum/src/",
51       "ds-test/=lib/forge-std/lib/ds-test/src/",
52       "ens-contracts/=lib/ens-contracts/contracts/",
53       "forge-std/=lib/forge-std/src/",
54       "old-ens-contracts/=lib/old-ens-contracts/contracts/",
55       "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
56       "solady/=lib/solady/src/",
57       "solmate/=lib/solady/lib/solmate/src/",
58       "string-utils/=lib/solidity-stringutils/blob/master/src/"
59     ],
60     "optimizer": {
61       "enabled": true,
62       "runs": 10000,
63       "details": {
64         "peephole": true,
65         "inliner": true,
66         "deduplicate": false,
67         "cse": true,
68         "yul": true
69       }
70     },
71     "metadata": {
72       "bytecodeHash": "ipfs"
73     },
74     "outputSelection": {
75       "*": {
76         "*": [
77           "evm.bytecode",
78           "evm.deployedBytecode",
79           "devdoc",
80           "userdoc",
81           "metadata",
82           "abi"
83         ]
84       }
85     },
86     "evmVersion": "london",
87     "libraries": {}
88   }
89 }}