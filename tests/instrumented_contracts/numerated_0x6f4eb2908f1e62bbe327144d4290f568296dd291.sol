1 /**
2 Twitter: https://twitter.com/hentaicoinerc
3 Telegram: Also on twitter
4 
5 ⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⠤⠶⠶⠛⠛⠉⢹⡇⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⢰⣀⠀⠀⠀⠀⠀⠈⠹⣆⢱⡄⠀⠀⠀⠀⠀⠀⠉⢻⡄⠀⠘⢷⡀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
6 ⠤⠄⠒⠒⠂⠋⠉⠉⡟⠉⠀⢰⠃⠀⠀⠀⠀⣿⣇⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⢸⠘⣆⠀⠀⠀⠀⠀⣄⢹⡄⣇⠀⠐⣦⠀⠀⠀⠀⠀⢳⡀⠀⠈⢳⡀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
7 ⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡏⠀⠀⠀⠀⠀⣿⣽⠀⠀⠀⡇⢸⠀⠀⠀⠀⠀⢸⡆⣿⡀⠀⠀⠀⠀⠸⣧⢻⣼⠀⠀⢻⣇⠀⠀⠀⠹⣆⢿⡀⠀⠈⢷⠀⠀⠀⠀⣿⢀⠀⠀⠀⠀
8 ⠀⠀⠀⠀⠀⠀⠀⠸⡇⠀⠀⡇⠀⠀⠀⠀⢠⢿⣿⡄⠀⠀⡇⢹⡄⠀⠀⠀⠀⠀⣿⡟⣧⠀⠀⠀⠀⠀⢹⣷⢿⠀⠀⢸⠸⣧⠀⠀⠀⢹⣎⢧⠀⠀⠈⣧⠀⠀⠀⠀⠀⠙⡆⠀⠀
9 ⠀⠀⠀⠀⠀⠀⠀⢀⡇⠀⢠⡇⠀⠀⠀⠀⣼⠀⠹⣧⠀⠀⢻⢸⣇⠀⠀⠀⠀⠀⢹⡇⢻⡄⠀⠀⠀⠀⠀⣿⣿⡄⠀⣼⠶⣿⡄⣠⣄⡀⣿⣾⡆⠀⠀⠸⣇⠀⠀⠀⠀⠀⠸⡀⠀
10 ⠀⠀⠀⠀⠀⠀⢰⣟⢷⠀⢸⡇⠀⠀⠀⠀⣿⠀⠀⠸⣇⠀⢸⣼⣿⠀⠀⠀⠀⠀⣄⣷⣾⣿⡿⠟⠛⠛⠳⣿⡘⣷⢀⡿⠀⠀⠷⠇⢹⡝⢿⡜⣿⠀⠀⠀⢻⡀⠀⠀⠀⠀⠀⢠⠴
11 ⠀⠀⠀⠀⠀⠀⣼⣿⡸⡇⠸⡇⠀⠀⠀⠀⢻⡀⠀⠀⠹⣦⢀⣿⣿⡆⠀⠀⣀⣀⣿⣿⡏⠁⠀⠀⠀⣀⣰⣀⣽⣻⡼⠁⠀⠀⠀⠀⠈⣷⠈⠇⢻⡇⠀⠀⠈⣇⠀⠀⠀⠀⠀⠀⠀
12 ⠀⠀⠀⠀⠀⠀⡿⠻⢷⣽⡀⢧⠀⠀⠀⠀⢸⡿⠿⠗⠂⣿⢮⣿⡀⢿⣴⠞⠋⠉⠉⠉⠛⠠⢶⣲⡿⠿⠛⣁⣈⣬⣭⣄⣀⣀⠀⠀⠀⢸⡇⠀⠈⠃⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀
13 ⠀⠀⠀⠀⠀⡀⡇⣠⣴⢷⣷⣸⡀⠀⣀⣀⡘⡇⠀⠀⠀⠘⣯⠛⢷⡌⢡⣤⠤⣤⣤⣆⣠⣴⡿⢋⣤⣶⣿⣿⣿⠛⠛⠛⠻⠿⣿⣶⣴⠀⣿⠀⠀⡄⠀⠀⠀⠘⣷⠀⠀⠀⠀⠀⠀
14 ⠀⠀⠀⠀⢸⠀⡿⠛⠁⠀⠉⠻⣷⠋⠉⠉⠉⢿⡀⠀⠀⠀⢿⣆⡀⠙⠋⠀⠀⠀⠀⠉⣹⢏⣴⣿⣿⡿⠟⠁⣼⠀⠀⠀⠀⠀⠀⠹⣿⡟⣿⠀⢀⡇⠀⠀⠀⠀⢹⣧⠀⠀⠀⠀⠀
15 ⠀⠀⠀⠀⠘⡆⣿⡀⠀⠀⠀⠀⣈⣤⣤⣤⣤⣴⣧⠀⠀⠀⠈⢻⡇⠀⠀⠀⠀⠀⠀⠀⢩⣾⡿⢷⣄⣀⣀⡴⠃⠀⠀⠀⠀⠀⠀⢠⡿⠁⢸⠀⢸⠀⠀⣤⠀⠀⠘⣿⡆⠀⠀⠀⠀
16 ⣄⡴⠶⠶⣶⣧⢿⠀⢀⣴⣾⣿⣿⣷⣶⣶⣶⣯⣿⢷⡄⠀⠀⠘⠁⠀⠀⠀⠀⠀⠀⠀⠸⠟⠀⠀⠈⠘⠁⣀⣀⣤⠤⠤⠤⢄⣠⠞⣁⠀⢸⠀⣿⡀⠀⣻⠀⠀⠀⣿⣷⠀⠀⠀⠀
17 ⠉⠀⠀⠈⣿⣿⣿⣷⣿⣿⠟⠉⠉⢿⡛⠻⠿⠿⣟⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⣶⡿⣷⠖⠻⠟⠛⠟⢋⡵⢋⡘⡳⢸⣴⣟⡇⠀⡟⠀⠀⠀⢸⣿⣇⠀⠀⠀
18 ⠀⠀⠀⢰⣿⡿⣿⣿⣿⡅⠀⠀⠀⠀⠙⠷⠴⠶⠋⠀⠀⠀⢘⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣷⡶⢟⣠⠟⢃⡠⢂⡴⢋⣴⣯⠞⣡⣾⠏⢿⡇⢠⡇⠀⠀⠀⠀⡏⢻⡇⠀⠀
19 ⠀⠀⢰⠘⣿⠀⠘⢻⣿⣥⡀⠀⣀⣠⣤⣤⠤⢤⡤⠄⢀⡴⠋⠙⣆⠀⠀⠀⠀⠀⠀⠀⣠⢞⡵⡿⠋⣠⠞⠃⠀⢉⡴⠋⡰⢋⡼⣣⢞⡱⠋⠀⠈⢿⣼⠀⡄⠀⠀⠀⡇⠀⢿⣧⠀
20 ⠀⠀⢸⡀⢻⡆⡀⠀⢛⡯⢩⣿⠟⣉⡽⠃⣠⢞⡔⣠⢏⡤⠀⠀⠈⠂⠀⠀⠀⠀⢀⠜⠑⡋⠈⠀⠚⠁⠐⠀⣠⠞⠀⠘⣱⠛⠊⠡⡿⢰⠀⠀⠀⣰⡇⠀⡇⠀⠀⠀⡃⠀⠸⣇⣆
21 ⠀⠀⠘⣧⠸⣿⡇⠀⠩⢤⡾⢣⣤⡿⢥⡾⣡⢞⡴⠃⠈⠀⠀⠀⠀⠀⠀⠀⠀⠐⠁⠈⠀⠀⠀⠀⠀⠀⠀⠘⠁⠤⣠⠞⠁⠀⠀⠐⠷⠟⠀⠀⣠⠏⠀⣰⡏⠀⠀⠀⠀⠀⠀⢻⡜
22 ⠀⠀⠀⣿⢰⡹⣿⡄⠀⡼⣵⣿⠋⣰⠟⡴⣫⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠁⠀⠀⠀⠀⠀⠀⠀⢀⣴⠋⣠⢾⡿⡇⠀⠀⠀⢀⠀⠀⢸⣿
23 ⡄⠀⠀⣿⣿⣷⣿⣧⠆⠀⡽⠃⡼⠃⢈⡽⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⡤⠴⠲⢤⣤⣀⠀⠀⠀⠀⠀⣠⡾⠁⠀⠀⠀⠀⠀⠀⣀⣴⣿⠵⠋⠁⣸⠡⡇⠀⠀⠀⠸⡀⠀⡸⢿
24 ⡇⠀⠀⢹⣿⣿⣟⠿⣶⡌⢠⡞⠁⠀⠞⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠋⣁⣠⣤⣤⣶⣶⣦⣌⢉⣷⣶⣶⣿⡿⠀⠀⠀⠀⠀⠰⠖⠛⠋⠉⠀⠀⠀⠰⢿⠀⡇⠀⠀⠀⠀⠁⠐⠁⠀
25 ⣿⡀⠀⠀⢿⣻⣿⣇⠈⠙⠿⢤⣤⡄⠀⠀⠀⠀⠀⣶⣄⣠⣾⢁⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⠀⣧⠀⠀⠀⡀⠀⠇⠀⠀
26 ⠈⣷⡀⠀⠈⢷⡻⣿⡆⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⡇⣿⠀⠀⠀⡆⠀⠀⠄⠀
27 ⠀⣿⡿⣤⣀⠀⠻⣿⣿⣄⠀⠀⠀⣄⠾⡄⠀⠀⠀⠀⠀⠹⣿⣿⡿⠋⠈⠻⣿⣿⣿⠟⠉⠀⠀⠈⢿⡿⠁⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⠀⠀⠀⡇⠀⠀⠀⡀
28 ⣠⣿⡇⠀⠈⠓⢦⣀⡙⠻⣆⣀⠀⠙⢛⣣⡄⠀⠀⠀⠀⠀⠹⣿⡇⠀⠀⠀⢻⡿⠁⠀⠀⠀⠀⠰⢿⠀⠀⠀⠀⠀⠀⠀⠀⠘⠦⠆⠀⠀⣠⣾⣿⣿⣿⡿⣿⡇⠀⠀⣇⠀⠀⠀⢳
29 ⣥⣿⠁⠀⠀⣠⣿⣿⣿⣶⣶⣿⣟⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⢻⠀⠀⠀⠀⣾⡇⠀⠀⠀⢀⢈⣷⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⡇⠈⣿⠀⣤⣿⡀⠀⠀⠀
30 ⣿⡁⠀⣠⡾⣿⣿⣿⣿⡿⣿⣻⡏⠓⢦⣄⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⠀⡟⠀⠀⠀⠀⠎⠉⡼⠻⡄⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣹⣷⣶⠈⢣⣿⡾⢱⣦⡀⠀
31 ⠈⠙⠛⢿⣿⣶⣷⣶⣶⣶⣄⣽⣿⠀⠀⣿⣷⣤⡀⠀⠀⠀⠀⣷⠀⠀⠀⢠⣯⠀⠀⠀⠀⠀⣼⠳⣶⠟⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣀⣽⣿⣿⣿⣿⣿⠀⡾⣿⣷⣌⠻⣿⣦
32 ⠀⠀⠀⠀⠈⠙⠻⢿⣿⣿⣿⣿⠏⠀⣴⡿⣿⣿⣿⣶⣄⡀⠀⠹⡄⠀⠀⠀⠉⠀⠀⢀⣤⠞⠁⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣸⣿⣿⠏⣻⣆⠈⠉
33 ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⢿⣧⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⣳⠀⠀⠀⠀⠀⣴⡏⠀⠀⠀⠀⠀⢀⣠⣴⣿⠿⠿⢿⣿⣿⣿⡿⠿⠟⠛⠉⠉⠁⠀⠀⢠⣿⣿⣿⠆⠉⠿⣧⠀
34 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢯⡛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡠⠀⠀⣸⡟⠀⠀⠀⢀⣠⡴⢟⣉⣤⡤⠶⠟⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⡁⠄⠁⠄⠙⢷
35 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠉⠛⠛⠉⠙⠛⠋⠉⠳⣌⠉⠘⣧⣤⣶⡿⣛⣿⡾⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⡏⠁⠄⠁⠄⠀⠄
36 ⠀⠀⠀⠀⠀⢐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢑⣶⣄⠀⣀⢀⠀⠀⠀⠀⠀⢙⡇⠀⣿⢋⡉⠚⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⠄⠀⠀⠀⠄⠀⠄
37 */
38 // File: @openzeppelin/contracts/utils/Context.sol
39 // SPDX-License-Identifier: MIT
40 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
41 
42 pragma solidity ^0.8.0;
43 
44 /**
45  * @dev Provides information about the current execution context, including the
46  * sender of the transaction and its data. While these are generally available
47  * via msg.sender and msg.data, they should not be accessed in such a direct
48  * manner, since when dealing with meta-transactions the account sending and
49  * paying for execution may not be the actual sender (as far as an application
50  * is concerned).
51  *
52  * This contract is only required for intermediate, library-like contracts.
53  */
54 abstract contract Context {
55     function _msgSender() internal view virtual returns (address) {
56         return msg.sender;
57     }
58 
59     function _msgData() internal view virtual returns (bytes calldata) {
60         return msg.data;
61     }
62 }
63 
64 // File: @openzeppelin/contracts/token/ERC20/IERC20.sol
65 
66 
67 // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
68 
69 pragma solidity ^0.8.0;
70 
71 /**
72  * @dev Interface of the ERC20 standard as defined in the EIP.
73  */
74 interface IERC20 {
75     /**
76      * @dev Emitted when `value` tokens are moved from one account (`from`) to
77      * another (`to`).
78      *
79      * Note that `value` may be zero.
80      */
81     event Transfer(address indexed from, address indexed to, uint256 value);
82 
83     /**
84      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
85      * a call to {approve}. `value` is the new allowance.
86      */
87     event Approval(address indexed owner, address indexed spender, uint256 value);
88 
89     /**
90      * @dev Returns the amount of tokens in existence.
91      */
92     function totalSupply() external view returns (uint256);
93 
94     /**
95      * @dev Returns the amount of tokens owned by `account`.
96      */
97     function balanceOf(address account) external view returns (uint256);
98 
99     /**
100      * @dev Moves `amount` tokens from the caller's account to `to`.
101      *
102      * Returns a boolean value indicating whether the operation succeeded.
103      *
104      * Emits a {Transfer} event.
105      */
106     function transfer(address to, uint256 amount) external returns (bool);
107 
108     /**
109      * @dev Returns the remaining number of tokens that `spender` will be
110      * allowed to spend on behalf of `owner` through {transferFrom}. This is
111      * zero by default.
112      *
113      * This value changes when {approve} or {transferFrom} are called.
114      */
115     function allowance(address owner, address spender) external view returns (uint256);
116 
117     /**
118      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
119      *
120      * Returns a boolean value indicating whether the operation succeeded.
121      *
122      * IMPORTANT: Beware that changing an allowance with this method brings the risk
123      * that someone may use both the old and the new allowance by unfortunate
124      * transaction ordering. One possible solution to mitigate this race
125      * condition is to first reduce the spender's allowance to 0 and set the
126      * desired value afterwards:
127      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
128      *
129      * Emits an {Approval} event.
130      */
131     function approve(address spender, uint256 amount) external returns (bool);
132 
133     /**
134      * @dev Moves `amount` tokens from `from` to `to` using the
135      * allowance mechanism. `amount` is then deducted from the caller's
136      * allowance.
137      *
138      * Returns a boolean value indicating whether the operation succeeded.
139      *
140      * Emits a {Transfer} event.
141      */
142     function transferFrom(
143         address from,
144         address to,
145         uint256 amount
146     ) external returns (bool);
147 }
148 
149 // File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
150 
151 
152 // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
153 
154 pragma solidity ^0.8.0;
155 
156 
157 /**
158  * @dev Interface for the optional metadata functions from the ERC20 standard.
159  *
160  * _Available since v4.1._
161  */
162 interface IERC20Metadata is IERC20 {
163     /**
164      * @dev Returns the name of the token.
165      */
166     function name() external view returns (string memory);
167 
168     /**
169      * @dev Returns the symbol of the token.
170      */
171     function symbol() external view returns (string memory);
172 
173     /**
174      * @dev Returns the decimals places of the token.
175      */
176     function decimals() external view returns (uint8);
177 }
178 
179 // File: @openzeppelin/contracts/token/ERC20/ERC20.sol
180 
181 
182 // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)
183 
184 pragma solidity ^0.8.0;
185 
186 
187 
188 
189 /**
190  * @dev Implementation of the {IERC20} interface.
191  *
192  * This implementation is agnostic to the way tokens are created. This means
193  * that a supply mechanism has to be added in a derived contract using {_mint}.
194  * For a generic mechanism see {ERC20PresetMinterPauser}.
195  *
196  * TIP: For a detailed writeup see our guide
197  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
198  * to implement supply mechanisms].
199  *
200  * We have followed general OpenZeppelin Contracts guidelines: functions revert
201  * instead returning `false` on failure. This behavior is nonetheless
202  * conventional and does not conflict with the expectations of ERC20
203  * applications.
204  *
205  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
206  * This allows applications to reconstruct the allowance for all accounts just
207  * by listening to said events. Other implementations of the EIP may not emit
208  * these events, as it isn't required by the specification.
209  *
210  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
211  * functions have been added to mitigate the well-known issues around setting
212  * allowances. See {IERC20-approve}.
213  */
214 contract ERC20 is Context, IERC20, IERC20Metadata {
215     mapping(address => uint256) private _balances;
216 
217     mapping(address => mapping(address => uint256)) private _allowances;
218 
219     uint256 private _totalSupply;
220 
221     string private _name;
222     string private _symbol;
223 
224     /**
225      * @dev Sets the values for {name} and {symbol}.
226      *
227      * The default value of {decimals} is 18. To select a different value for
228      * {decimals} you should overload it.
229      *
230      * All two of these values are immutable: they can only be set once during
231      * construction.
232      */
233     constructor(string memory name_, string memory symbol_) {
234         _name = name_;
235         _symbol = symbol_;
236     }
237 
238     /**
239      * @dev Returns the name of the token.
240      */
241     function name() public view virtual override returns (string memory) {
242         return _name;
243     }
244 
245     /**
246      * @dev Returns the symbol of the token, usually a shorter version of the
247      * name.
248      */
249     function symbol() public view virtual override returns (string memory) {
250         return _symbol;
251     }
252 
253     /**
254      * @dev Returns the number of decimals used to get its user representation.
255      * For example, if `decimals` equals `2`, a balance of `505` tokens should
256      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
257      *
258      * Tokens usually opt for a value of 18, imitating the relationship between
259      * Ether and Wei. This is the value {ERC20} uses, unless this function is
260      * overridden;
261      *
262      * NOTE: This information is only used for _display_ purposes: it in
263      * no way affects any of the arithmetic of the contract, including
264      * {IERC20-balanceOf} and {IERC20-transfer}.
265      */
266     function decimals() public view virtual override returns (uint8) {
267         return 18;
268     }
269 
270     /**
271      * @dev See {IERC20-totalSupply}.
272      */
273     function totalSupply() public view virtual override returns (uint256) {
274         return _totalSupply;
275     }
276 
277     /**
278      * @dev See {IERC20-balanceOf}.
279      */
280     function balanceOf(address account) public view virtual override returns (uint256) {
281         return _balances[account];
282     }
283 
284     /**
285      * @dev See {IERC20-transfer}.
286      *
287      * Requirements:
288      *
289      * - `to` cannot be the zero address.
290      * - the caller must have a balance of at least `amount`.
291      */
292     function transfer(address to, uint256 amount) public virtual override returns (bool) {
293         address owner = _msgSender();
294         _transfer(owner, to, amount);
295         return true;
296     }
297 
298     /**
299      * @dev See {IERC20-allowance}.
300      */
301     function allowance(address owner, address spender) public view virtual override returns (uint256) {
302         return _allowances[owner][spender];
303     }
304 
305     /**
306      * @dev See {IERC20-approve}.
307      *
308      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
309      * `transferFrom`. This is semantically equivalent to an infinite approval.
310      *
311      * Requirements:
312      *
313      * - `spender` cannot be the zero address.
314      */
315     function approve(address spender, uint256 amount) public virtual override returns (bool) {
316         address owner = _msgSender();
317         _approve(owner, spender, amount);
318         return true;
319     }
320 
321     /**
322      * @dev See {IERC20-transferFrom}.
323      *
324      * Emits an {Approval} event indicating the updated allowance. This is not
325      * required by the EIP. See the note at the beginning of {ERC20}.
326      *
327      * NOTE: Does not update the allowance if the current allowance
328      * is the maximum `uint256`.
329      *
330      * Requirements:
331      *
332      * - `from` and `to` cannot be the zero address.
333      * - `from` must have a balance of at least `amount`.
334      * - the caller must have allowance for ``from``'s tokens of at least
335      * `amount`.
336      */
337     function transferFrom(
338         address from,
339         address to,
340         uint256 amount
341     ) public virtual override returns (bool) {
342         address spender = _msgSender();
343         _spendAllowance(from, spender, amount);
344         _transfer(from, to, amount);
345         return true;
346     }
347 
348     /**
349      * @dev Atomically increases the allowance granted to `spender` by the caller.
350      *
351      * This is an alternative to {approve} that can be used as a mitigation for
352      * problems described in {IERC20-approve}.
353      *
354      * Emits an {Approval} event indicating the updated allowance.
355      *
356      * Requirements:
357      *
358      * - `spender` cannot be the zero address.
359      */
360     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
361         address owner = _msgSender();
362         _approve(owner, spender, allowance(owner, spender) + addedValue);
363         return true;
364     }
365 
366     /**
367      * @dev Atomically decreases the allowance granted to `spender` by the caller.
368      *
369      * This is an alternative to {approve} that can be used as a mitigation for
370      * problems described in {IERC20-approve}.
371      *
372      * Emits an {Approval} event indicating the updated allowance.
373      *
374      * Requirements:
375      *
376      * - `spender` cannot be the zero address.
377      * - `spender` must have allowance for the caller of at least
378      * `subtractedValue`.
379      */
380     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
381         address owner = _msgSender();
382         uint256 currentAllowance = allowance(owner, spender);
383         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
384         unchecked {
385             _approve(owner, spender, currentAllowance - subtractedValue);
386         }
387 
388         return true;
389     }
390 
391     /**
392      * @dev Moves `amount` of tokens from `from` to `to`.
393      *
394      * This internal function is equivalent to {transfer}, and can be used to
395      * e.g. implement automatic token fees, slashing mechanisms, etc.
396      *
397      * Emits a {Transfer} event.
398      *
399      * Requirements:
400      *
401      * - `from` cannot be the zero address.
402      * - `to` cannot be the zero address.
403      * - `from` must have a balance of at least `amount`.
404      */
405     function _transfer(
406         address from,
407         address to,
408         uint256 amount
409     ) internal virtual {
410         require(from != address(0), "ERC20: transfer from the zero address");
411         require(to != address(0), "ERC20: transfer to the zero address");
412 
413         _beforeTokenTransfer(from, to, amount);
414 
415         uint256 fromBalance = _balances[from];
416         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
417         unchecked {
418             _balances[from] = fromBalance - amount;
419             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
420             // decrementing then incrementing.
421             _balances[to] += amount;
422         }
423 
424         emit Transfer(from, to, amount);
425 
426         _afterTokenTransfer(from, to, amount);
427     }
428 
429     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
430      * the total supply.
431      *
432      * Emits a {Transfer} event with `from` set to the zero address.
433      *
434      * Requirements:
435      *
436      * - `account` cannot be the zero address.
437      */
438     function _mint(address account, uint256 amount) internal virtual {
439         require(account != address(0), "ERC20: mint to the zero address");
440 
441         _beforeTokenTransfer(address(0), account, amount);
442 
443         _totalSupply += amount;
444         unchecked {
445             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
446             _balances[account] += amount;
447         }
448         emit Transfer(address(0), account, amount);
449 
450         _afterTokenTransfer(address(0), account, amount);
451     }
452 
453     /**
454      * @dev Destroys `amount` tokens from `account`, reducing the
455      * total supply.
456      *
457      * Emits a {Transfer} event with `to` set to the zero address.
458      *
459      * Requirements:
460      *
461      * - `account` cannot be the zero address.
462      * - `account` must have at least `amount` tokens.
463      */
464     function _burn(address account, uint256 amount) internal virtual {
465         require(account != address(0), "ERC20: burn from the zero address");
466 
467         _beforeTokenTransfer(account, address(0), amount);
468 
469         uint256 accountBalance = _balances[account];
470         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
471         unchecked {
472             _balances[account] = accountBalance - amount;
473             // Overflow not possible: amount <= accountBalance <= totalSupply.
474             _totalSupply -= amount;
475         }
476 
477         emit Transfer(account, address(0), amount);
478 
479         _afterTokenTransfer(account, address(0), amount);
480     }
481 
482     /**
483      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
484      *
485      * This internal function is equivalent to `approve`, and can be used to
486      * e.g. set automatic allowances for certain subsystems, etc.
487      *
488      * Emits an {Approval} event.
489      *
490      * Requirements:
491      *
492      * - `owner` cannot be the zero address.
493      * - `spender` cannot be the zero address.
494      */
495     function _approve(
496         address owner,
497         address spender,
498         uint256 amount
499     ) internal virtual {
500         require(owner != address(0), "ERC20: approve from the zero address");
501         require(spender != address(0), "ERC20: approve to the zero address");
502 
503         _allowances[owner][spender] = amount;
504         emit Approval(owner, spender, amount);
505     }
506 
507     /**
508      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
509      *
510      * Does not update the allowance amount in case of infinite allowance.
511      * Revert if not enough allowance is available.
512      *
513      * Might emit an {Approval} event.
514      */
515     function _spendAllowance(
516         address owner,
517         address spender,
518         uint256 amount
519     ) internal virtual {
520         uint256 currentAllowance = allowance(owner, spender);
521         if (currentAllowance != type(uint256).max) {
522             require(currentAllowance >= amount, "ERC20: insufficient allowance");
523             unchecked {
524                 _approve(owner, spender, currentAllowance - amount);
525             }
526         }
527     }
528 
529     /**
530      * @dev Hook that is called before any transfer of tokens. This includes
531      * minting and burning.
532      *
533      * Calling conditions:
534      *
535      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
536      * will be transferred to `to`.
537      * - when `from` is zero, `amount` tokens will be minted for `to`.
538      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
539      * - `from` and `to` are never both zero.
540      *
541      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
542      */
543     function _beforeTokenTransfer(
544         address from,
545         address to,
546         uint256 amount
547     ) internal virtual {}
548 
549     /**
550      * @dev Hook that is called after any transfer of tokens. This includes
551      * minting and burning.
552      *
553      * Calling conditions:
554      *
555      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
556      * has been transferred to `to`.
557      * - when `from` is zero, `amount` tokens have been minted for `to`.
558      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
559      * - `from` and `to` are never both zero.
560      *
561      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
562      */
563     function _afterTokenTransfer(
564         address from,
565         address to,
566         uint256 amount
567     ) internal virtual {}
568 }
569 
570 // File: Hentai.sol
571 
572 
573 pragma solidity ^0.8.9;
574 
575 
576 contract HentaiCoin is ERC20 {
577     constructor() ERC20("Hentai Coin", "HENTAI") {
578         _mint(msg.sender, 69696969420 * 10 ** decimals());
579     }
580 }