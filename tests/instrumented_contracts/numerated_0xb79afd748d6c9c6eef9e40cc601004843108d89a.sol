1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 pragma solidity ^0.5.7;
20 
21 /**
22  * @title Ownable
23  * @dev The Ownable contract has an owner address, and provides basic authorization control
24  * functions, this simplifies the implementation of "user permissions".
25  */
26 contract Ownable {
27     address private _owner;
28 
29     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
30 
31     /**
32      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
33      * account.
34      */
35     constructor () internal {
36         _owner = msg.sender;
37         emit OwnershipTransferred(address(0), _owner);
38     }
39 
40     /**
41      * @return the address of the owner.
42      */
43     function owner() public view returns (address) {
44         return _owner;
45     }
46 
47     /**
48      * @dev Throws if called by any account other than the owner.
49      */
50     modifier onlyOwner() {
51         require(isOwner());
52         _;
53     }
54 
55     /**
56      * @return true if `msg.sender` is the owner of the contract.
57      */
58     function isOwner() public view returns (bool) {
59         return msg.sender == _owner;
60     }
61 
62     /**
63      * @dev Allows the current owner to relinquish control of the contract.
64      * It will not be possible to call the functions with the `onlyOwner`
65      * modifier anymore.
66      * @notice Renouncing ownership will leave the contract without an owner,
67      * thereby removing any functionality that is only available to the owner.
68      */
69     function renounceOwnership() public onlyOwner {
70         emit OwnershipTransferred(_owner, address(0));
71         _owner = address(0);
72     }
73 
74     /**
75      * @dev Allows the current owner to transfer control of the contract to a newOwner.
76      * @param newOwner The address to transfer ownership to.
77      */
78     function transferOwnership(address newOwner) public onlyOwner {
79         _transferOwnership(newOwner);
80     }
81 
82     /**
83      * @dev Transfers control of the contract to a newOwner.
84      * @param newOwner The address to transfer ownership to.
85      */
86     function _transferOwnership(address newOwner) internal {
87         require(newOwner != address(0));
88         emit OwnershipTransferred(_owner, newOwner);
89         _owner = newOwner;
90     }
91 }
92 
93 
94 /**
95  * @title ERC20 interface without bool returns
96  * @dev see https://eips.ethereum.org/EIPS/eip-20
97  */
98 interface IERC20 {
99     function transfer(address to, uint256 value) external;
100 
101     function approve(address spender, uint256 value) external;
102 
103     function transferFrom(address from, address to, uint256 value) external;
104 
105     function totalSupply() external view returns (uint256);
106 
107     function balanceOf(address who) external view returns (uint256);
108 
109     function allowance(address owner, address spender) external view returns (uint256);
110 
111     event Transfer(address indexed from, address indexed to, uint256 value);
112 
113     event Approval(address indexed owner, address indexed spender, uint256 value);
114 }
115 
116 
117 /**
118  * @title Helps contracts guard against reentrancy attacks.
119  * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>
120  * @dev If you mark a function `nonReentrant`, you should also
121  * mark it `external`.
122  */
123 contract ReentrancyGuard {
124     /// @dev counter to allow mutex lock with only one SSTORE operation
125     uint256 private _guardCounter;
126 
127     constructor () internal {
128         // The counter starts at one to prevent changing it from zero to a non-zero
129         // value, which is a more expensive operation.
130         _guardCounter = 1;
131     }
132 
133     /**
134      * @dev Prevents a contract from calling itself, directly or indirectly.
135      * Calling a `nonReentrant` function from another `nonReentrant`
136      * function is not supported. It is possible to prevent this from happening
137      * by making the `nonReentrant` function external, and make it call a
138      * `private` function that does the actual work.
139      */
140     modifier nonReentrant() {
141         _guardCounter += 1;
142         uint256 localCounter = _guardCounter;
143         _;
144         require(localCounter == _guardCounter);
145     }
146 }
147 
148 
149 /**
150  * @title SafeMath
151  * @dev Unsigned math operations with safety checks that revert on error
152  */
153 library SafeMath {
154     /**
155      * @dev Multiplies two unsigned integers, reverts on overflow.
156      */
157     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
158         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
159         // benefit is lost if 'b' is also tested.
160         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
161         if (a == 0) {
162             return 0;
163         }
164 
165         uint256 c = a * b;
166         require(c / a == b);
167 
168         return c;
169     }
170 
171     /**
172      * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
173      */
174     function div(uint256 a, uint256 b) internal pure returns (uint256) {
175         // Solidity only automatically asserts when dividing by 0
176         require(b > 0);
177         uint256 c = a / b;
178         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
179 
180         return c;
181     }
182 
183     /**
184      * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
185      */
186     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
187         require(b <= a);
188         uint256 c = a - b;
189 
190         return c;
191     }
192 
193     /**
194      * @dev Adds two unsigned integers, reverts on overflow.
195      */
196     function add(uint256 a, uint256 b) internal pure returns (uint256) {
197         uint256 c = a + b;
198         require(c >= a);
199 
200         return c;
201     }
202 
203     /**
204      * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
205      * reverts when dividing by zero.
206      */
207     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
208         require(b != 0);
209         return a % b;
210     }
211 }
212 
213 
214 interface ISwaps {
215     function createOrder(
216         bytes32 _id,
217         address _baseAddress,
218         address _quoteAddress,
219         uint _baseLimit,
220         uint _quoteLimit,
221         uint _expirationTimestamp,
222         address _baseOnlyInvestor,
223         uint _minBaseInvestment,
224         uint _minQuoteInvestment
225     ) external;
226 
227     function deposit(
228         bytes32 _id,
229         address _token,
230         uint _amount
231     ) payable external;
232 
233     function cancel(bytes32 _id) external;
234 
235     function refund(bytes32 _id, address _token) external;
236 }
237 
238 
239 contract Vault is Ownable {
240     address public swaps;
241 
242     modifier onlySwaps() {
243         require(msg.sender == swaps);
244         _;
245     }
246 
247     function () external payable {
248     }
249 
250     function tokenFallback(address, uint, bytes calldata) external {
251     }
252 
253     function setSwaps(address _swaps) public onlyOwner {
254         swaps = _swaps;
255     }
256 
257     function withdraw(address _token, address _receiver, uint _amount) public onlySwaps {
258         if (_token == address(0)) {
259             address(uint160(_receiver)).transfer(_amount);
260         } else {
261             IERC20(_token).transfer(_receiver, _amount);
262         }
263     }
264 }
265 
266 
267 contract Swaps is Ownable, ISwaps, ReentrancyGuard {
268     using SafeMath for uint;
269 
270     uint public MAX_INVESTORS = 10;
271 
272     Vault public vault;
273     mapping (bytes32 => address) public baseOnlyInvestor;
274     mapping (bytes32 => address) public owners;
275     mapping (bytes32 => address) public baseAddresses;
276     mapping (bytes32 => address) public quoteAddresses;
277     mapping (bytes32 => uint) public expirationTimestamps;
278     mapping (bytes32 => bool) public isSwapped;
279     mapping (bytes32 => bool) public isCancelled;
280     mapping (bytes32 => mapping (address => uint)) public limits;
281     mapping (bytes32 => mapping (address => uint)) public raised;
282     mapping (bytes32 => mapping (address => address[])) public investors;
283     mapping (bytes32 => mapping (address => mapping (address => uint))) public investments;
284     mapping (bytes32 => mapping (address => uint)) public minInvestments;
285 
286     modifier onlyInvestor(bytes32 _id, address _token) {
287         require(_isInvestor(_id, _token, msg.sender), "Allowed only for investors");
288         _;
289     }
290 
291     modifier onlyWhenVaultDefined() {
292         require(address(vault) != address(0), "Vault is not defined");
293         _;
294     }
295 
296     modifier onlyOrderOwner(bytes32 _id) {
297         require(msg.sender == owners[_id], "Allowed only for owner");
298         _;
299     }
300 
301     modifier onlyWhenOrderExists(bytes32 _id) {
302         require(owners[_id] != address(0), "Order doesn't exist");
303         _;
304     }
305 
306     event OrderCreated(
307         bytes32 id,
308         address owner,
309         address baseAddress,
310         address quoteAddress,
311         uint baseLimit,
312         uint quoteLimit,
313         uint expirationTimestamp,
314         address baseOnlyInvestor,
315         uint minBaseInvestment,
316         uint minQuoteInvestment
317     );
318 
319     event OrderCancelled(bytes32 id);
320 
321     event Deposit(
322         bytes32 id,
323         address token,
324         address user,
325         uint amount,
326         uint balance
327     );
328 
329     event Refund(
330         bytes32 id,
331         address token,
332         address user,
333         uint amount
334     );
335 
336     event OrderSwapped(
337         bytes32 id,
338         address byUser
339     );
340 
341     event SwapSend(
342         bytes32 id,
343         address token,
344         address user,
345         uint amount
346     );
347 
348     function tokenFallback(address, uint, bytes calldata) external {
349     }
350 
351     function createOrder(
352         bytes32 _id,
353         address _baseAddress,
354         address _quoteAddress,
355         uint _baseLimit,
356         uint _quoteLimit,
357         uint _expirationTimestamp,
358         address _baseOnlyInvestor,
359         uint _minBaseInvestment,
360         uint _minQuoteInvestment
361     )
362         external
363         nonReentrant
364         onlyWhenVaultDefined
365     {
366         require(owners[_id] == address(0), "Order already exists");
367         require(_baseAddress != _quoteAddress, "Exchanged tokens must be different");
368         require(_baseLimit > 0, "Base limit must be positive");
369         require(_quoteLimit > 0, "Quote limit must be positive");
370         require(_expirationTimestamp > now, "Expiration time must be in future");
371 
372         owners[_id] = msg.sender;
373         baseAddresses[_id] = _baseAddress;
374         quoteAddresses[_id] = _quoteAddress;
375         expirationTimestamps[_id] = _expirationTimestamp;
376         limits[_id][_baseAddress] = _baseLimit;
377         limits[_id][_quoteAddress] = _quoteLimit;
378         baseOnlyInvestor[_id] = _baseOnlyInvestor;
379         minInvestments[_id][_baseAddress] = _minBaseInvestment;
380         minInvestments[_id][_quoteAddress] = _minQuoteInvestment;
381 
382         emit OrderCreated(
383             _id,
384             msg.sender,
385             _baseAddress,
386             _quoteAddress,
387             _baseLimit,
388             _quoteLimit,
389             _expirationTimestamp,
390             _baseOnlyInvestor,
391             _minBaseInvestment,
392             _minQuoteInvestment
393         );
394     }
395 
396     function deposit(
397         bytes32 _id,
398         address _token,
399         uint _amount
400     )
401         payable
402         external
403         nonReentrant
404         onlyWhenVaultDefined
405         onlyWhenOrderExists(_id)
406     {
407         if (_token == address(0)) {
408             require(msg.value == _amount, "Payable value should be equals value");
409             address(vault).transfer(msg.value);
410         } else {
411             require(msg.value == 0, "Payable not allowed here");
412             uint allowance = IERC20(_token).allowance(msg.sender, address(this));
413             require(_amount <= allowance, "Allowance should be not less than amount");
414             IERC20(_token).transferFrom(msg.sender, address(vault), _amount);
415         }
416         _deposit(_id, _token, msg.sender, _amount);
417     }
418 
419     function cancel(bytes32 _id)
420         external
421         nonReentrant
422         onlyOrderOwner(_id)
423         onlyWhenVaultDefined
424         onlyWhenOrderExists(_id)
425     {
426         require(!isCancelled[_id], "Already cancelled");
427         require(!isSwapped[_id], "Already swapped");
428 
429         address[2] memory tokens = [baseAddresses[_id], quoteAddresses[_id]];
430         for (uint t = 0; t < tokens.length; t++) {
431             address token = tokens[t];
432             for (uint u = 0; u < investors[_id][token].length; u++) {
433                 address user = investors[_id][token][u];
434                 uint userInvestment = investments[_id][token][user];
435                 vault.withdraw(token, user, userInvestment);
436             }
437         }
438 
439         isCancelled[_id] = true;
440         emit OrderCancelled(_id);
441     }
442 
443     function refund(bytes32 _id, address _token)
444         external
445         nonReentrant
446         onlyInvestor(_id, _token)
447         onlyWhenVaultDefined
448         onlyWhenOrderExists(_id)
449     {
450         require(!isSwapped[_id], "Already swapped");
451         address user = msg.sender;
452         uint investment = investments[_id][_token][user];
453         if (investment > 0) {
454             delete investments[_id][_token][user];
455         }
456 
457         _removeInvestor(investors[_id][_token], user);
458 
459         if (investment > 0) {
460             raised[_id][_token] = raised[_id][_token].sub(investment);
461             vault.withdraw(_token, user, investment);
462         }
463 
464         emit Refund(_id, _token, user, investment);
465     }
466 
467     function setVault(Vault _vault) external onlyOwner {
468         vault = _vault;
469     }
470 
471     function createKey(address _owner)
472         public
473         view
474         returns (bytes32 result)
475     {
476         uint creationTime = now;
477         result = 0x0000000000000000000000000000000000000000000000000000000000000000;
478         assembly {
479             result := or(result, mul(_owner, 0x1000000000000000000000000))
480             result := or(result, and(creationTime, 0xffffffffffffffffffffffff))
481         }
482     }
483 
484     function baseLimit(bytes32 _id)
485         public
486         view
487         returns (uint)
488     {
489         return limits[_id][baseAddresses[_id]];
490     }
491 
492     function quoteLimit(bytes32 _id)
493         public
494         view
495         returns (uint)
496     {
497         return limits[_id][quoteAddresses[_id]];
498     }
499 
500     function baseRaised(bytes32 _id)
501         public
502         view
503         returns (uint)
504     {
505         return raised[_id][baseAddresses[_id]];
506     }
507 
508     function quoteRaised(bytes32 _id)
509         public
510         view
511         returns (uint)
512     {
513         return raised[_id][quoteAddresses[_id]];
514     }
515 
516     function isBaseFilled(bytes32 _id)
517         public
518         view
519         returns (bool)
520     {
521         return raised[_id][baseAddresses[_id]] == limits[_id][baseAddresses[_id]];
522     }
523 
524     function isQuoteFilled(bytes32 _id)
525         public
526         view
527         returns (bool)
528     {
529         return raised[_id][quoteAddresses[_id]] == limits[_id][quoteAddresses[_id]];
530     }
531 
532     function baseInvestors(bytes32 _id)
533         public
534         view
535         returns (address[] memory)
536     {
537         return investors[_id][baseAddresses[_id]];
538     }
539 
540     function quoteInvestors(bytes32 _id)
541         public
542         view
543         returns (address[] memory)
544     {
545         return investors[_id][quoteAddresses[_id]];
546     }
547 
548     function baseUserInvestment(bytes32 _id, address _user)
549         public
550         view
551         returns (uint)
552     {
553         return investments[_id][baseAddresses[_id]][_user];
554     }
555 
556     function quoteUserInvestment(bytes32 _id, address _user)
557         public
558         view
559         returns (uint)
560     {
561         return investments[_id][quoteAddresses[_id]][_user];
562     }
563 
564     function _swap(bytes32 _id) internal {
565         require(!isSwapped[_id], "Already swapped");
566         require(!isCancelled[_id], "Already cancelled");
567         require(isBaseFilled(_id), "Base tokens not filled");
568         require(isQuoteFilled(_id), "Quote tokens not filled");
569         require(now <= expirationTimestamps[_id], "Contract expired");
570 
571         _distribute(_id, baseAddresses[_id], quoteAddresses[_id]);
572         _distribute(_id, quoteAddresses[_id], baseAddresses[_id]);
573 
574         isSwapped[_id] = true;
575         emit OrderSwapped(_id, msg.sender);
576     }
577 
578     function _distribute(bytes32 _id, address _aSide, address _bSide) internal {
579         uint remainder = raised[_id][_bSide];
580         for (uint i = 0; i < investors[_id][_aSide].length; i++) {
581             address user = investors[_id][_aSide][i];
582             uint toPay;
583             // last
584             if (i + 1 == investors[_id][_aSide].length) {
585                 toPay = remainder;
586             } else {
587                 uint aSideRaised = raised[_id][_aSide];
588                 uint userInvestment = investments[_id][_aSide][user];
589                 uint bSideRaised = raised[_id][_bSide];
590                 toPay = userInvestment.mul(bSideRaised).div(aSideRaised);
591                 remainder = remainder.sub(toPay);
592             }
593 
594             vault.withdraw(_bSide, user, toPay);
595             emit SwapSend(_id, _bSide, user, toPay);
596         }
597     }
598 
599     function _removeInvestor(address[] storage _array, address _investor) internal {
600         uint idx = _array.length - 1;
601         for (uint i = 0; i < _array.length - 1; i++) {
602             if (_array[i] == _investor) {
603                 idx = i;
604                 break;
605             }
606         }
607 
608         _array[idx] = _array[_array.length - 1];
609         delete _array[_array.length - 1];
610         _array.length--;
611     }
612 
613     function _deposit(
614         bytes32 _id,
615         address _token,
616         address _from,
617         uint _amount
618     ) internal {
619         uint amount = _amount;
620         require(baseAddresses[_id] == _token || quoteAddresses[_id] == _token, "You can deposit only base or quote currency");
621         require(raised[_id][_token] < limits[_id][_token], "Limit already reached");
622         require(now <= expirationTimestamps[_id], "Contract expired");
623         if (baseAddresses[_id] == _token && baseOnlyInvestor[_id] != address(0)) {
624             require(msg.sender == baseOnlyInvestor[_id], "Allowed only for specified address");
625         }
626         if (limits[_id][_token].sub(raised[_id][_token]) > minInvestments[_id][_token]) {
627             require(_amount >= minInvestments[_id][_token], "Should not be less than minimum value");
628         }
629 
630         if (!_isInvestor(_id, _token, _from)) {
631             require(investors[_id][_token].length < MAX_INVESTORS, "Too many investors");
632             investors[_id][_token].push(_from);
633         }
634 
635         uint raisedWithOverflow = raised[_id][_token].add(amount);
636         if (raisedWithOverflow > limits[_id][_token]) {
637             uint overflow = raisedWithOverflow.sub(limits[_id][_token]);
638             vault.withdraw(_token, _from, overflow);
639             amount = amount.sub(overflow);
640         }
641 
642         investments[_id][_token][_from] = investments[_id][_token][_from].add(amount);
643 
644         raised[_id][_token] = raised[_id][_token].add(amount);
645         emit Deposit(
646             _id,
647             _token,
648             _from,
649             amount,
650             investments[_id][_token][_from]
651         );
652 
653         if (isBaseFilled(_id) && isQuoteFilled(_id)) {
654             _swap(_id);
655         }
656     }
657 
658     function _isInvestor(
659         bytes32 _id,
660         address _token,
661         address _who
662     )
663         internal
664         view
665         returns (bool)
666     {
667         return investments[_id][_token][_who] > 0;
668     }
669 }