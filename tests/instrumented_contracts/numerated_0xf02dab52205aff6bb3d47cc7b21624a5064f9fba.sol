1 /**
2  *Submitted for verification at Etherscan.io on 2019-06-07
3 */
4 
5 /*
6  * This file was generated by MyWish Platform (https://mywish.io/)
7  * The complete code could be found at https://github.com/MyWishPlatform/
8  * Copyright (C) 2018 MyWish
9  *
10  * This program is free software: you can redistribute it and/or modify
11  * it under the terms of the GNU Lesser General Public License as published by
12  * the Free Software Foundation, either version 3 of the License, or
13  * (at your option) any later version.
14  *
15  * This program is distributed in the hope that it will be useful,
16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
18  * GNU Lesser General Public License for more details.
19  *
20  * You should have received a copy of the GNU Lesser General Public License
21  * along with this program. If not, see <http://www.gnu.org/licenses/>.
22  */
23 pragma solidity ^0.4.23;
24 
25 
26 /**
27  * @title ERC20Basic
28  * @dev Simpler version of ERC20 interface
29  * @dev see https://github.com/ethereum/EIPs/issues/179
30  */
31 contract ERC20Basic {
32   function totalSupply() public view returns (uint256);
33   function balanceOf(address who) public view returns (uint256);
34   function transfer(address to, uint256 value) public returns (bool);
35   event Transfer(address indexed from, address indexed to, uint256 value);
36 }
37 
38 
39 
40 /**
41  * @title SafeMath
42  * @dev Math operations with safety checks that throw on error
43  */
44 library SafeMath {
45 
46   /**
47   * @dev Multiplies two numbers, throws on overflow.
48   */
49   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
50     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
51     // benefit is lost if 'b' is also tested.
52     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
53     if (a == 0) {
54       return 0;
55     }
56 
57     c = a * b;
58     assert(c / a == b);
59     return c;
60   }
61 
62   /**
63   * @dev Integer division of two numbers, truncating the quotient.
64   */
65   function div(uint256 a, uint256 b) internal pure returns (uint256) {
66     // assert(b > 0); // Solidity automatically throws when dividing by 0
67     // uint256 c = a / b;
68     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
69     return a / b;
70   }
71 
72   /**
73   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
74   */
75   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
76     assert(b <= a);
77     return a - b;
78   }
79 
80   /**
81   * @dev Adds two numbers, throws on overflow.
82   */
83   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
84     c = a + b;
85     assert(c >= a);
86     return c;
87   }
88 }
89 
90 
91 
92 /**
93  * @title Basic token
94  * @dev Basic version of StandardToken, with no allowances.
95  */
96 contract BasicToken is ERC20Basic {
97   using SafeMath for uint256;
98 
99   mapping(address => uint256) balances;
100 
101   uint256 totalSupply_;
102 
103   /**
104   * @dev total number of tokens in existence
105   */
106   function totalSupply() public view returns (uint256) {
107     return totalSupply_;
108   }
109 
110   /**
111   * @dev transfer token for a specified address
112   * @param _to The address to transfer to.
113   * @param _value The amount to be transferred.
114   */
115   function transfer(address _to, uint256 _value) public returns (bool) {
116     require(_to != address(0));
117     require(_value <= balances[msg.sender]);
118 
119     balances[msg.sender] = balances[msg.sender].sub(_value);
120     balances[_to] = balances[_to].add(_value);
121     emit Transfer(msg.sender, _to, _value);
122     return true;
123   }
124 
125   /**
126   * @dev Gets the balance of the specified address.
127   * @param _owner The address to query the the balance of.
128   * @return An uint256 representing the amount owned by the passed address.
129   */
130   function balanceOf(address _owner) public view returns (uint256) {
131     return balances[_owner];
132   }
133 
134 }
135 
136 
137 /**
138  * @title ERC20 interface
139  * @dev see https://github.com/ethereum/EIPs/issues/20
140  */
141 contract ERC20 is ERC20Basic {
142   function allowance(address owner, address spender)
143     public view returns (uint256);
144 
145   function transferFrom(address from, address to, uint256 value)
146     public returns (bool);
147 
148   function approve(address spender, uint256 value) public returns (bool);
149   event Approval(
150     address indexed owner,
151     address indexed spender,
152     uint256 value
153   );
154 }
155 
156 
157 /**
158  * @title Standard ERC20 token
159  *
160  * @dev Implementation of the basic standard token.
161  * @dev https://github.com/ethereum/EIPs/issues/20
162  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
163  */
164 contract StandardToken is ERC20, BasicToken {
165 
166   mapping (address => mapping (address => uint256)) internal allowed;
167 
168 
169   /**
170    * @dev Transfer tokens from one address to another
171    * @param _from address The address which you want to send tokens from
172    * @param _to address The address which you want to transfer to
173    * @param _value uint256 the amount of tokens to be transferred
174    */
175   function transferFrom(
176     address _from,
177     address _to,
178     uint256 _value
179   )
180     public
181     returns (bool)
182   {
183     require(_to != address(0));
184     require(_value <= balances[_from]);
185     require(_value <= allowed[_from][msg.sender]);
186 
187     balances[_from] = balances[_from].sub(_value);
188     balances[_to] = balances[_to].add(_value);
189     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
190     emit Transfer(_from, _to, _value);
191     return true;
192   }
193 
194   /**
195    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
196    *
197    * Beware that changing an allowance with this method brings the risk that someone may use both the old
198    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
199    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
200    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
201    * @param _spender The address which will spend the funds.
202    * @param _value The amount of tokens to be spent.
203    */
204   function approve(address _spender, uint256 _value) public returns (bool) {
205     allowed[msg.sender][_spender] = _value;
206     emit Approval(msg.sender, _spender, _value);
207     return true;
208   }
209 
210   /**
211    * @dev Function to check the amount of tokens that an owner allowed to a spender.
212    * @param _owner address The address which owns the funds.
213    * @param _spender address The address which will spend the funds.
214    * @return A uint256 specifying the amount of tokens still available for the spender.
215    */
216   function allowance(
217     address _owner,
218     address _spender
219    )
220     public
221     view
222     returns (uint256)
223   {
224     return allowed[_owner][_spender];
225   }
226 
227   /**
228    * @dev Increase the amount of tokens that an owner allowed to a spender.
229    *
230    * approve should be called when allowed[_spender] == 0. To increment
231    * allowed value is better to use this function to avoid 2 calls (and wait until
232    * the first transaction is mined)
233    * From MonolithDAO Token.sol
234    * @param _spender The address which will spend the funds.
235    * @param _addedValue The amount of tokens to increase the allowance by.
236    */
237   function increaseApproval(
238     address _spender,
239     uint _addedValue
240   )
241     public
242     returns (bool)
243   {
244     allowed[msg.sender][_spender] = (
245       allowed[msg.sender][_spender].add(_addedValue));
246     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
247     return true;
248   }
249 
250   /**
251    * @dev Decrease the amount of tokens that an owner allowed to a spender.
252    *
253    * approve should be called when allowed[_spender] == 0. To decrement
254    * allowed value is better to use this function to avoid 2 calls (and wait until
255    * the first transaction is mined)
256    * From MonolithDAO Token.sol
257    * @param _spender The address which will spend the funds.
258    * @param _subtractedValue The amount of tokens to decrease the allowance by.
259    */
260   function decreaseApproval(
261     address _spender,
262     uint _subtractedValue
263   )
264     public
265     returns (bool)
266   {
267     uint oldValue = allowed[msg.sender][_spender];
268     if (_subtractedValue > oldValue) {
269       allowed[msg.sender][_spender] = 0;
270     } else {
271       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
272     }
273     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
274     return true;
275   }
276 
277 }
278 
279 
280 
281 /**
282  * @title Ownable
283  * @dev The Ownable contract has an owner address, and provides basic authorization control
284  * functions, this simplifies the implementation of "user permissions".
285  */
286 contract Ownable {
287   address public owner;
288 
289 
290   event OwnershipRenounced(address indexed previousOwner);
291   event OwnershipTransferred(
292     address indexed previousOwner,
293     address indexed newOwner
294   );
295 
296 
297   /**
298    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
299    * account.
300    */
301   constructor() public {
302     owner = msg.sender;
303   }
304 
305   /**
306    * @dev Throws if called by any account other than the owner.
307    */
308   modifier onlyOwner() {
309     require(msg.sender == owner);
310     _;
311   }
312 
313   /**
314    * @dev Allows the current owner to relinquish control of the contract.
315    */
316   function renounceOwnership() public onlyOwner {
317     emit OwnershipRenounced(owner);
318     owner = address(0);
319   }
320 
321   /**
322    * @dev Allows the current owner to transfer control of the contract to a newOwner.
323    * @param _newOwner The address to transfer ownership to.
324    */
325   function transferOwnership(address _newOwner) public onlyOwner {
326     _transferOwnership(_newOwner);
327   }
328 
329   /**
330    * @dev Transfers control of the contract to a newOwner.
331    * @param _newOwner The address to transfer ownership to.
332    */
333   function _transferOwnership(address _newOwner) internal {
334     require(_newOwner != address(0));
335     emit OwnershipTransferred(owner, _newOwner);
336     owner = _newOwner;
337   }
338 }
339 
340 
341 /**
342  * @title Mintable token
343  * @dev Simple ERC20 Token example, with mintable token creation
344  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
345  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
346  */
347 contract MintableToken is StandardToken, Ownable {
348   event Mint(address indexed to, uint256 amount);
349   event MintFinished();
350 
351   bool public mintingFinished = false;
352 
353 
354   modifier canMint() {
355     require(!mintingFinished);
356     _;
357   }
358 
359   modifier hasMintPermission() {
360     require(msg.sender == owner);
361     _;
362   }
363 
364   /**
365    * @dev Function to mint tokens
366    * @param _to The address that will receive the minted tokens.
367    * @param _amount The amount of tokens to mint.
368    * @return A boolean that indicates if the operation was successful.
369    */
370   function mint(
371     address _to,
372     uint _amount
373   )
374     hasMintPermission
375     public
376     returns (bool)
377   {
378     totalSupply_ = totalSupply_.add(_amount);
379     balances[_to] = balances[_to].add(_amount);
380     emit Mint(_to, _amount);
381     emit Transfer(address(0), _to, _amount);
382     return true;
383   }
384 
385   /**
386    * @dev Function to stop minting new tokens.
387    * @return True if the operation was successful.
388    */
389   function finishMinting() onlyOwner canMint public returns (bool) {
390     mintingFinished = true;
391     emit MintFinished();
392     return true;
393   }
394 }
395 
396 
397 contract FreezableToken is StandardToken {
398     // freezing chains
399     mapping (bytes32 => uint64) internal chains;
400     // freezing amounts for each chain
401     mapping (bytes32 => uint) internal freezings;
402     // total freezing balance per address
403     mapping (address => uint) internal freezingBalance;
404 
405     event Freezed(address indexed to, uint64 release, uint amount);
406     event Released(address indexed owner, uint amount);
407 
408     /**
409      * @dev Gets the balance of the specified address include freezing tokens.
410      * @param _owner The address to query the the balance of.
411      * @return An uint256 representing the amount owned by the passed address.
412      */
413     function balanceOf(address _owner) public view returns (uint256 balance) {
414         return super.balanceOf(_owner) + freezingBalance[_owner];
415     }
416 
417     /**
418      * @dev Gets the balance of the specified address without freezing tokens.
419      * @param _owner The address to query the the balance of.
420      * @return An uint256 representing the amount owned by the passed address.
421      */
422     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
423         return super.balanceOf(_owner);
424     }
425 
426     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
427         return freezingBalance[_owner];
428     }
429 
430     /**
431      * @dev gets freezing count
432      * @param _addr Address of freeze tokens owner.
433      */
434     function freezingCount(address _addr) public view returns (uint count) {
435         uint64 release = chains[toKey(_addr, 0)];
436         while (release != 0) {
437             count++;
438             release = chains[toKey(_addr, release)];
439         }
440     }
441 
442     /**
443      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
444      * @param _addr Address of freeze tokens owner.
445      * @param _index Freezing portion index. It ordered by release date descending.
446      */
447     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
448         for (uint i = 0; i < _index + 1; i++) {
449             _release = chains[toKey(_addr, _release)];
450             if (_release == 0) {
451                 return;
452             }
453         }
454         _balance = freezings[toKey(_addr, _release)];
455     }
456 
457     /**
458      * @dev freeze your tokens to the specified address.
459      *      Be careful, gas usage is not deterministic,
460      *      and depends on how many freezes _to address already has.
461      * @param _to Address to which token will be freeze.
462      * @param _amount Amount of token to freeze.
463      * @param _until Release date, must be in future.
464      */
465     function freezeTo(address _to, uint _amount, uint64 _until) public {
466         require(_to != address(0));
467         require(_amount <= balances[msg.sender]);
468 
469         balances[msg.sender] = balances[msg.sender].sub(_amount);
470 
471         bytes32 currentKey = toKey(_to, _until);
472         freezings[currentKey] = freezings[currentKey].add(_amount);
473         freezingBalance[_to] = freezingBalance[_to].add(_amount);
474 
475         freeze(_to, _until);
476         emit Transfer(msg.sender, _to, _amount);
477         emit Freezed(_to, _until, _amount);
478     }
479 
480     /**
481      * @dev release first available freezing tokens.
482      */
483     function releaseOnce() public {
484         bytes32 headKey = toKey(msg.sender, 0);
485         uint64 head = chains[headKey];
486         require(head != 0);
487         require(uint64(block.timestamp) > head);
488         bytes32 currentKey = toKey(msg.sender, head);
489 
490         uint64 next = chains[currentKey];
491 
492         uint amount = freezings[currentKey];
493         delete freezings[currentKey];
494 
495         balances[msg.sender] = balances[msg.sender].add(amount);
496         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
497 
498         if (next == 0) {
499             delete chains[headKey];
500         } else {
501             chains[headKey] = next;
502             delete chains[currentKey];
503         }
504         emit Released(msg.sender, amount);
505     }
506 
507     /**
508      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
509      * @return how many tokens was released
510      */
511     function releaseAll() public returns (uint tokens) {
512         uint release;
513         uint balance;
514         (release, balance) = getFreezing(msg.sender, 0);
515         while (release != 0 && block.timestamp > release) {
516             releaseOnce();
517             tokens += balance;
518             (release, balance) = getFreezing(msg.sender, 0);
519         }
520     }
521 
522     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
523         // WISH masc to increase entropy
524         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
525         assembly {
526             result := or(result, mul(_addr, 0x10000000000000000))
527             result := or(result, _release)
528         }
529     }
530 
531     function freeze(address _to, uint64 _until) internal {
532         require(_until > block.timestamp);
533         bytes32 key = toKey(_to, _until);
534         bytes32 parentKey = toKey(_to, uint64(0));
535         uint64 next = chains[parentKey];
536 
537         if (next == 0) {
538             chains[parentKey] = _until;
539             return;
540         }
541 
542         bytes32 nextKey = toKey(_to, next);
543         uint parent;
544 
545         while (next != 0 && _until > next) {
546             parent = next;
547             parentKey = nextKey;
548 
549             next = chains[nextKey];
550             nextKey = toKey(_to, next);
551         }
552 
553         if (_until == next) {
554             return;
555         }
556 
557         if (next != 0) {
558             chains[key] = next;
559         }
560 
561         chains[parentKey] = _until;
562     }
563 }
564 
565 
566 /**
567  * @title Burnable Token
568  * @dev Token that can be irreversibly burned (destroyed).
569  */
570 contract BurnableToken is BasicToken {
571 
572   event Burn(address indexed burner, uint256 value);
573 
574   /**
575    * @dev Burns a specific amount of tokens.
576    * @param _value The amount of token to be burned.
577    */
578   function burn(uint256 _value) public {
579     _burn(msg.sender, _value);
580   }
581 
582   function _burn(address _who, uint256 _value) internal {
583     require(_value <= balances[_who]);
584     // no need to require value <= totalSupply, since that would imply the
585     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
586 
587     balances[_who] = balances[_who].sub(_value);
588     totalSupply_ = totalSupply_.sub(_value);
589     emit Burn(_who, _value);
590     emit Transfer(_who, address(0), _value);
591   }
592 }
593 
594 
595 
596 /**
597  * @title Pausable
598  * @dev Base contract which allows children to implement an emergency stop mechanism.
599  */
600 contract Pausable is Ownable {
601   event Pause();
602   event Unpause();
603 
604   bool public paused = false;
605 
606 
607   /**
608    * @dev Modifier to make a function callable only when the contract is not paused.
609    */
610   modifier whenNotPaused() {
611     require(!paused);
612     _;
613   }
614 
615   /**
616    * @dev Modifier to make a function callable only when the contract is paused.
617    */
618   modifier whenPaused() {
619     require(paused);
620     _;
621   }
622 
623   /**
624    * @dev called by the owner to pause, triggers stopped state
625    */
626   function pause() onlyOwner whenNotPaused public {
627     paused = true;
628     emit Pause();
629   }
630 
631   /**
632    * @dev called by the owner to unpause, returns to normal state
633    */
634   function unpause() onlyOwner whenPaused public {
635     paused = false;
636     emit Unpause();
637   }
638 }
639 
640 
641 contract FreezableMintableToken is FreezableToken, MintableToken {
642     /**
643      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
644      *      Be careful, gas usage is not deterministic,
645      *      and depends on how many freezes _to address already has.
646      * @param _to Address to which token will be freeze.
647      * @param _amount Amount of token to mint and freeze.
648      * @param _until Release date, must be in future.
649      * @return A boolean that indicates if the operation was successful.
650      */
651     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
652         totalSupply_ = totalSupply_.add(_amount);
653 
654         bytes32 currentKey = toKey(_to, _until);
655         freezings[currentKey] = freezings[currentKey].add(_amount);
656         freezingBalance[_to] = freezingBalance[_to].add(_amount);
657 
658         freeze(_to, _until);
659         emit Mint(_to, _amount);
660         emit Freezed(_to, _until, _amount);
661         emit Transfer(msg.sender, _to, _amount);
662         return true;
663     }
664 }
665 
666 
667 
668 contract Consts {
669     uint public constant TOKEN_DECIMALS = 4;
670     uint8 public constant TOKEN_DECIMALS_UINT8 = 4;
671     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
672 
673     string public constant TOKEN_NAME = "Pyrrhos Gold";
674     string public constant TOKEN_SYMBOL = "PGOLD";
675     bool public constant PAUSED = false;
676     address public constant TARGET_USER = 0x5d799e0A223fd22618A06286dC48A4796F325F5A;
677     
678     bool public constant CONTINUE_MINTING = false;
679 }
680 
681 
682 
683 
684 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
685     
686 {
687     
688     event Initialized();
689     bool public initialized = false;
690 
691     constructor() public {
692         init();
693         transferOwnership(msg.sender);
694     }
695     
696 
697     function name() public pure returns (string _name) {
698         return TOKEN_NAME;
699     }
700 
701     function symbol() public pure returns (string _symbol) {
702         return TOKEN_SYMBOL;
703     }
704 
705     function decimals() public pure returns (uint8 _decimals) {
706         return TOKEN_DECIMALS_UINT8;
707     }
708 
709     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
710         require(!paused);
711         return super.transferFrom(_from, _to, _value);
712     }
713 
714     function transfer(address _to, uint256 _value) public returns (bool _success) {
715         require(!paused);
716         return super.transfer(_to, _value);
717     }
718 
719     
720     function init() private {
721         require(!initialized);
722         initialized = true;
723 
724         if (PAUSED) {
725             pause();
726         }
727 
728         
729         address[1] memory addresses = [address(0x5d799e0A223fd22618A06286dC48A4796F325F5A)];
730         uint[1] memory amounts = [uint(10000000000000)];
731         uint64[1] memory freezes = [uint64(0)];
732 
733         for (uint i = 0; i < addresses.length; i++) {
734             if (freezes[i] == 0) {
735                 mint(addresses[i], amounts[i]);
736             } else {
737                 mintAndFreeze(addresses[i], amounts[i], freezes[i]);
738             }
739         }
740         
741 
742         if (!CONTINUE_MINTING) {
743             finishMinting();
744         }
745 
746         emit Initialized();
747     }
748     
749 }