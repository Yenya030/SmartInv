1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Staking.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.7.5;\n\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IsFLOOR.sol\";\nimport \"./interfaces/IgFLOOR.sol\";\nimport \"./interfaces/IDistributor.sol\";\n\nimport \"./types/FloorAccessControlled.sol\";\n\ncontract FloorStaking is FloorAccessControlled {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IsFLOOR;\n    using SafeERC20 for IgFLOOR;\n\n    /* ========== EVENTS ========== */\n\n    event DistributorSet(address distributor);\n    event WarmupSet(uint256 warmup);\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Epoch {\n        uint256 length; // in seconds\n        uint256 number; // since inception\n        uint256 end; // timestamp\n        uint256 distribute; // amount\n    }\n\n    struct Claim {\n        uint256 deposit; // if forfeiting\n        uint256 gons; // staked balance\n        uint256 expiry; // end of warmup period\n        bool lock; // prevents malicious delays for claim\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public immutable FLOOR;\n    IsFLOOR public immutable sFLOOR;\n    IgFLOOR public immutable gFLOOR;\n\n    Epoch public epoch;\n\n    IDistributor public distributor;\n\n    mapping(address => Claim) public warmupInfo;\n    uint256 public warmupPeriod;\n    uint256 private gonsInWarmup;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _floor,\n        address _sFLOOR,\n        address _gFLOOR,\n        uint256 _epochLength,\n        uint256 _firstEpochNumber,\n        uint256 _firstEpochTime,\n        address _authority\n    ) FloorAccessControlled(IFloorAuthority(_authority)) {\n        require(_floor != address(0), \"Zero address: FLOOR\");\n        FLOOR = IERC20(_floor);\n        require(_sFLOOR != address(0), \"Zero address: sFLOOR\");\n        sFLOOR = IsFLOOR(_sFLOOR);\n        require(_gFLOOR != address(0), \"Zero address: gFLOOR\");\n        gFLOOR = IgFLOOR(_gFLOOR);\n\n        epoch = Epoch({length: _epochLength, number: _firstEpochNumber, end: _firstEpochTime, distribute: 0});\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice stake FLOOR to enter warmup\n     * @param _to address\n     * @param _amount uint\n     * @param _claim bool\n     * @param _rebasing bool\n     * @return uint\n     */\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256) {\n        FLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = _amount.add(rebase()); // add bounty if rebase occurred\n        if (_claim && warmupPeriod == 0) {\n            return _send(_to, _amount, _rebasing);\n        } else {\n            Claim memory info = warmupInfo[_to];\n            if (!info.lock) {\n                require(_to == msg.sender, \"External deposits for account are locked\");\n            }\n\n            warmupInfo[_to] = Claim({\n                deposit: info.deposit.add(_amount),\n                gons: info.gons.add(sFLOOR.gonsForBalance(_amount)),\n                expiry: epoch.number.add(warmupPeriod),\n                lock: info.lock\n            });\n\n            gonsInWarmup = gonsInWarmup.add(sFLOOR.gonsForBalance(_amount));\n\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice retrieve stake from warmup\n     * @param _to address\n     * @param _rebasing bool\n     * @return uint\n     */\n    function claim(address _to, bool _rebasing) public returns (uint256) {\n        Claim memory info = warmupInfo[_to];\n\n        if (!info.lock) {\n            require(_to == msg.sender, \"External claims for account are locked\");\n        }\n\n        if (epoch.number >= info.expiry && info.expiry != 0) {\n            delete warmupInfo[_to];\n\n            gonsInWarmup = gonsInWarmup.sub(info.gons);\n\n            return _send(_to, sFLOOR.balanceForGons(info.gons), _rebasing);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice forfeit stake and retrieve FLOOR\n     * @return uint\n     */\n    function forfeit() external returns (uint256) {\n        Claim memory info = warmupInfo[msg.sender];\n        delete warmupInfo[msg.sender];\n\n        gonsInWarmup = gonsInWarmup.sub(info.gons);\n\n        FLOOR.safeTransfer(msg.sender, info.deposit);\n\n        return info.deposit;\n    }\n\n    /**\n     * @notice prevent new deposits or claims from ext. address (protection from malicious activity)\n     */\n    function toggleLock() external {\n        warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\n    }\n\n    /**\n     * @notice redeem sFLOOR for FLOORs\n     * @param _to address\n     * @param _amount uint\n     * @param _trigger bool\n     * @param _rebasing bool\n     * @return amount_ uint\n     */\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256 amount_) {\n        amount_ = _amount;\n        uint256 bounty;\n        if (_trigger) {\n            bounty = rebase();\n        }\n        if (_rebasing) {\n            sFLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n            amount_ = amount_.add(bounty);\n        } else {\n            gFLOOR.burn(msg.sender, _amount); // amount was given in gFLOOR terms\n            amount_ = gFLOOR.balanceFrom(amount_).add(bounty); // convert amount to FLOOR terms & add bounty\n        }\n\n        require(amount_ <= FLOOR.balanceOf(address(this)), \"Insufficient FLOOR balance in contract\");\n        FLOOR.safeTransfer(_to, amount_);\n    }\n\n    /**\n     * @notice convert _amount sFLOOR into gBalance_ gFLOOR\n     * @param _to address\n     * @param _amount uint\n     * @return gBalance_ uint\n     */\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_) {\n        sFLOOR.safeTransferFrom(msg.sender, address(this), _amount);\n        gBalance_ = gFLOOR.balanceTo(_amount);\n        gFLOOR.mint(_to, gBalance_);\n    }\n\n    /**\n     * @notice convert _amount gFLOOR into sBalance_ sFLOOR\n     * @param _to address\n     * @param _amount uint\n     * @return sBalance_ uint\n     */\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_) {\n        gFLOOR.burn(msg.sender, _amount);\n        sBalance_ = gFLOOR.balanceFrom(_amount);\n        sFLOOR.safeTransfer(_to, sBalance_);\n    }\n\n    /**\n     * @notice trigger rebase if epoch over\n     * @return uint256\n     */\n    function rebase() public returns (uint256) {\n        uint256 bounty;\n        if (epoch.end <= block.timestamp) {\n            sFLOOR.rebase(epoch.distribute, epoch.number);\n\n            epoch.end = epoch.end.add(epoch.length);\n            epoch.number++;\n\n            if (address(distributor) != address(0)) {\n                distributor.distribute();\n                bounty = distributor.retrieveBounty(); // Will mint floor for this contract if there exists a bounty\n            }\n            uint256 balance = FLOOR.balanceOf(address(this));\n            uint256 staked = sFLOOR.circulatingSupply();\n            if (balance <= staked.add(bounty)) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance.sub(staked).sub(bounty);\n            }\n        }\n        return bounty;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @notice send staker their amount as sFLOOR or gFLOOR\n     * @param _to address\n     * @param _amount uint\n     * @param _rebasing bool\n     */\n    function _send(\n        address _to,\n        uint256 _amount,\n        bool _rebasing\n    ) internal returns (uint256) {\n        if (_rebasing) {\n            sFLOOR.safeTransfer(_to, _amount); // send as sFLOOR (equal unit as FLOOR)\n            return _amount;\n        } else {\n            gFLOOR.mint(_to, gFLOOR.balanceTo(_amount)); // send as gFLOOR (convert units from FLOOR)\n            return gFLOOR.balanceTo(_amount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns the sFLOOR index, which tracks rebase growth\n     * @return uint\n     */\n    function index() public view returns (uint256) {\n        return sFLOOR.index();\n    }\n\n    /**\n     * @notice total supply in warmup\n     */\n    function supplyInWarmup() public view returns (uint256) {\n        return sFLOOR.balanceForGons(gonsInWarmup);\n    }\n\n    /**\n     * @notice seconds until the next epoch begins\n     */\n    function secondsToNextEpoch() external view returns (uint256) {\n        return epoch.end.sub(block.timestamp);\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice sets the contract address for LP staking\n     * @param _distributor address\n     */\n    function setDistributor(address _distributor) external onlyGovernor {\n        distributor = IDistributor(_distributor);\n        emit DistributorSet(_distributor);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmupLength(uint256 _warmupPeriod) external onlyGovernor {\n        warmupPeriod = _warmupPeriod;\n        emit WarmupSet(_warmupPeriod);\n    }\n}"
6     },
7     "contracts/libraries/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.7.5;\n\n\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a > 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b < c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n}"
9     },
10     "contracts/libraries/SafeERC20.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}"
12     },
13     "contracts/interfaces/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
15     },
16     "contracts/interfaces/IsFLOOR.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IsFLOOR is IERC20 {\n    function rebase( uint256 floorProfit_, uint epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance( uint amount ) external view returns ( uint );\n\n    function balanceForGons( uint gons ) external view returns ( uint );\n\n    function index() external view returns ( uint );\n\n    function toG(uint amount) external view returns (uint);\n\n    function fromG(uint amount) external view returns (uint);\n\n     function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n\n}\n"
18     },
19     "contracts/interfaces/IgFLOOR.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IgFLOOR is IERC20 {\n  function mint(address _to, uint256 _amount) external;\n\n  function burn(address _from, uint256 _amount) external;\n\n  function index() external view returns (uint256);\n\n  function balanceFrom(uint256 _amount) external view returns (uint256);\n\n  function balanceTo(uint256 _amount) external view returns (uint256);\n}\n"
21     },
22     "contracts/interfaces/IDistributor.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IDistributor {\n    function distribute() external;\n\n    function bounty() external view returns (uint256);\n\n    function retrieveBounty() external returns (uint256);\n\n    function nextRewardAt(uint256 _rate) external view returns (uint256);\n\n    function nextRewardFor(address _recipient) external view returns (uint256);\n\n    function setBounty(uint256 _bounty) external;\n\n    function addRecipient(address _recipient, uint256 _rewardRate) external;\n\n    function removeRecipient(uint256 _index) external;\n\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external;\n}\n"
24     },
25     "contracts/types/FloorAccessControlled.sol": {
26       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IFloorAuthority.sol\";\n\nabstract contract FloorAccessControlled {\n\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IFloorAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IFloorAuthority public authority;\n\n\n    /* ========== Constructor ========== */\n\n    constructor(IFloorAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n    \n\n    /* ========== MODIFIERS ========== */\n    \n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n    \n    /* ========== GOV ONLY ========== */\n    \n    function setAuthority(IFloorAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
27     },
28     "contracts/interfaces/IFloorAuthority.sol": {
29       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IFloorAuthority {\n    /* ========== EVENTS ========== */\n    \n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n    \n    function governor() external view returns (address);\n    function guardian() external view returns (address);\n    function policy() external view returns (address);\n    function vault() external view returns (address);\n}"
30     }
31   },
32   "settings": {
33     "metadata": {
34       "bytecodeHash": "none",
35       "useLiteralContent": true
36     },
37     "optimizer": {
38       "enabled": true,
39       "runs": 200
40     },
41     "outputSelection": {
42       "*": {
43         "*": [
44           "evm.bytecode",
45           "evm.deployedBytecode",
46           "devdoc",
47           "userdoc",
48           "metadata",
49           "abi"
50         ]
51       }
52     },
53     "libraries": {}
54   }
55 }}