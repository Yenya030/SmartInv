1 {{
2   "language": "Solidity",
3   "sources": {
4     "PixelRoyale.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n// This is no CC0\r\n// www.PixelRoyal.xyz\r\n// The Pixel Royale will start after mint out\r\npragma solidity 0.8.15;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"erc721a/contracts/ERC721A.sol\";\r\nimport './PixelTag.sol';\r\n\r\ncontract PixelRoyale is ERC721A, Ownable {\r\n    //---------- Addies ----------//\r\n    address public contractCreator;\r\n    address public lastPlayer;\r\n    address public mostAttacks;\r\n    address public randomPlayer;\r\n    address public randomTag;\r\n    address public abashoCollective; // ---> Needs to be set\r\n    address public pixelTagContract; // ---> Interface for Tags\r\n    //---------- Mint Vars ----------//\r\n    bool public started;\r\n    bool public claimed;\r\n    uint256 public constant MAXPIXELS = 4444;\r\n    uint256 public constant WALLETLIMIT = 2;\r\n    uint256 public constant CREATORCLAIMAMOUNT = 3;\r\n    mapping(address => uint) public addressClaimed; // ---> keeps track of wallet limit\r\n    // MetadataURI\r\n    string private baseURI;\r\n    //---------- PixelRoyale Vars ----------//\r\n    bool public pixelWarStarted;\r\n    bool public pixelWarConcluded;\r\n    uint256 public timeLimit = 1671667200; // Thursday, 22. December 2022 00:00:00 GMT\r\n    uint constant ITEM_PRICE = 0.005 ether;\r\n    mapping(address => uint) public walletHighscore; // ---> keeps track of each wallet highscore\r\n    uint256 public currentHighscore;\r\n    string private salt;\r\n    bool public payout;\r\n    //---------- Mini Jackpot Vars ----------//\r\n    uint256[] public jackpot;\r\n    //---------- Player Vars ----------//\r\n    struct Pixel {\r\n        int256 health;\r\n        bool status;\r\n    }\r\n    mapping(uint256 => Pixel) public pixelList; // ---> maps ID to a Player Struct\r\n\r\n    //---------- Events ----------//\r\n    event ItemBought(address from,address currentMA,uint tokenId,int256 amount);\r\n    event DropOut(address from,uint tokenId);\r\n    event MiniJackpotWin(address winner, uint256 jackpotAmount);\r\n    event MiniJackpotAmount(uint256 jackpotAmount);\r\n\r\n    //---------- Construct ERC721A TOKEN ----------//\r\n    constructor() ERC721A(\"PixelRoyale BATTLE GAME\", \"PRBG\") {\r\n        contractCreator = msg.sender;\r\n    }\r\n\r\n    function _startTokenId() internal view virtual override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- MINT FUNCTIONS ----------//\r\n    //---------- Start Minting -----------//\r\n    function startMint() external onlyOwner {\r\n        require(!started, \"mint has already started\");\r\n        started = true;\r\n    }\r\n\r\n    //---------- Free Mint Function ----------//\r\n    function mint(uint256 _amount) external {\r\n        uint256 total = totalSupply();\r\n        if(_msgSender() != contractCreator) {\r\n            require(started, \"Mint did not start yet\");\r\n            require(addressClaimed[_msgSender()] + _amount <= WALLETLIMIT, \"Wallet limit reached, don't be greedy\");\r\n        }\r\n        require(_amount > 0, \"You need to mint at least 1\");\r\n        require(total + _amount <= MAXPIXELS, \"Not that many NFTs left, try to mint less\");\r\n        require(total <= MAXPIXELS, \"Mint out\");\r\n\r\n        // create structs for minted amount\r\n        for (uint j; j < _amount; j++) {\r\n            Pixel memory newPixel = Pixel(0,true);\r\n            pixelList[total+j+1] = newPixel;\r\n        }\r\n        addressClaimed[_msgSender()] += _amount;\r\n        _safeMint(_msgSender(), _amount);\r\n\r\n        // immediately starts PixelRoyale GAME on mint out\r\n        if(totalSupply() >= MAXPIXELS){\r\n            pixelWarStarted = true;\r\n        }\r\n    }\r\n\r\n    //---------- Team Claim ----------//\r\n    function teamClaim() external onlyOwner {\r\n        uint256 total = totalSupply();\r\n        require(!claimed, \"already claimed\");\r\n        for (uint j; j < CREATORCLAIMAMOUNT; j++) {\r\n            // struct creation for mint amount\r\n            Pixel memory newPixel = Pixel(0,true);\r\n            pixelList[total+j+1] = newPixel;\r\n        }\r\n        _safeMint(contractCreator, CREATORCLAIMAMOUNT);\r\n        claimed = true;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- BATTLE ROYALE GAME ----------//\r\n    //---------- Manually Start PixelRoyale ----------//\r\n    function startPixelWar() external onlyOwner {\r\n        require(!pixelWarStarted, \"The war has already been started\");\r\n        pixelWarStarted = true;\r\n    }\r\n\r\n    //---------- Calculate Amount Of \"Alive\" Players ----------//\r\n    function getPopulation() public view returns(uint256 _population) {\r\n        for (uint j=1; j <= totalSupply(); j++) {\r\n            if(isAlive(j)){\r\n                _population++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //---------- Returns Last Player ID ----------//\r\n    function checkLastSurvivor() public view returns(uint256 _winner) {\r\n        for (uint j; j <= totalSupply(); j++) {\r\n            if(pixelList[j].health > -1){\r\n                _winner = j;\r\n            }\r\n        }\r\n    }\r\n\r\n    //---------- Checks If Specified TokenID Is \"Alive\" ----------//\r\n    function isAlive(uint256 _tokenId) public view returns(bool _alive) {\r\n        pixelList[_tokenId].health < 0 ? _alive = false : _alive = true;\r\n    }\r\n\r\n    //---------- Returns Random \"Alive\" TokenID ----------//\r\n    function returnRandomId() public view returns(uint256 _tokenId) {\r\n        for (uint256 j = pseudoRandom(totalSupply(),\"Q\"); j <= totalSupply() + 1; j++) {\r\n            if(pixelList[j].health > -1) {\r\n                return j;\r\n            }\r\n            if(j == totalSupply()) {\r\n                j = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    //---------- Pseudo Random Number Generator From Range ----------//\r\n    function pseudoRandom(uint256 _number, string memory _specialSalt) public view returns(uint number) {\r\n        number = uint(keccak256(abi.encodePacked(block.timestamp,block.difficulty,msg.sender,salt,_specialSalt))) % _number;\r\n        number == 0 ? number++: number;\r\n    }\r\n\r\n    //---------- Change Salt Value Pseudo Randomness ----------//\r\n    function changeSalt(string memory _newSalt) public onlyOwner {\r\n        salt = _newSalt;\r\n    }\r\n\r\n    //---------- Set HP For Players | Protect/Attack ----------//\r\n    function setHP(uint256 _tokenId, int256 _amount) external payable {\r\n        require(!pixelWarConcluded, \"PixelRoyale has concluded!\");\r\n        require(pixelWarStarted, \"PixelRoyale hasn't started!\");\r\n        require(getPopulation() > 1, \"We already have a winner!\");\r\n        require(_amount != 0, \"Value needs to be > or < than 0\");\r\n        require(pixelList[_tokenId].health > -1, \"Player already out of the Game\");\r\n\r\n        uint priceMod = 10; // ---> 0%\r\n        uint256 amount;\r\n\r\n        // turn _amount into a positive amount value\r\n        _amount < 0 ? amount = uint256(_amount*-1) : amount = uint256(_amount);\r\n\r\n        // bulk pricing:\r\n        if(amount>6) {\r\n            priceMod = 8; // ---> 20%\r\n            if(amount>12) {\r\n                priceMod = 7; // ---> 30%\r\n                if(amount>18) {\r\n                    priceMod = 6; // ---> 40%\r\n                    if(amount>24) { priceMod = 5; } // ---> 50%\r\n                }\r\n            }\r\n        }\r\n\r\n        // calculate purchase\r\n        uint256 currentPrice = ITEM_PRICE / 10 * priceMod * amount;\r\n        require((currentPrice) <= msg.value, \"Not enough ETH\");\r\n\r\n        // checks on attack purchase\r\n        if(_amount < 0) {\r\n            require(pixelList[_tokenId].health+_amount>-2,\"Try less attacks - warrior overkill\");\r\n            walletHighscore[_msgSender()] += amount;\r\n            if(walletHighscore[_msgSender()] > currentHighscore) {\r\n                currentHighscore = walletHighscore[_msgSender()];\r\n                mostAttacks = _msgSender();\r\n            }\r\n        }\r\n\r\n        // change health value in player struct\r\n        (pixelList[_tokenId].health+_amount) < 0 ? pixelList[_tokenId].health = -1 : pixelList[_tokenId].health = pixelList[_tokenId].health + _amount;\r\n\r\n        //emit event for item buy\r\n        emit ItemBought(_msgSender(),mostAttacks,_tokenId,_amount); // ---> buyer, current Highscore Leader, Interacted token, amount of protections/attacks\r\n\r\n        // add to mini jackpot array\r\n        addToPot(msg.value);\r\n\r\n        // try jackpot\r\n        if(jackpot.length>0){\r\n            tryJackpot();\r\n        }\r\n\r\n        // check if token is alive | Check if player has dropped out of Game\r\n        InterfacePixelTags pixelTag = InterfacePixelTags(pixelTagContract); // ---> Interface to Tags NFT\r\n        if ( !isAlive(_tokenId) ) {\r\n            pixelTag.mintPixelTag(_msgSender()); // ---> MINT DogTag FROM ERC721A\r\n            pixelList[_tokenId].status = false;\r\n\r\n            //emit DropOut event\r\n            emit DropOut(_msgSender(),_tokenId); // ---> Killer, Killed Token\r\n        }\r\n        // check if population is smaller than 2 | check if PixelRoyale has concluded\r\n        if ( getPopulation() < 2 ) {\r\n            pixelWarConcluded = true;\r\n            lastPlayer = ownerOf(checkLastSurvivor());\r\n            randomPlayer = ownerOf(pseudoRandom(MAXPIXELS,\"Warrior\"));\r\n            randomTag = pixelTag.ownerOf(pseudoRandom(MAXPIXELS-1,\"Tag\"));\r\n        }\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- BATTLE ROYALE GAME ----------//\r\n    //---------- Add 49% Of Bet To Mini Jackpot ----------//\r\n    function addToPot(uint256 _amount) internal {\r\n        jackpot.push(_amount/100*49);\r\n    }\r\n\r\n    //---------- Calculate Current Mini Jackpot Size ----------//\r\n    function currentPot() internal view returns(uint256 _result) {\r\n        for (uint j; j < jackpot.length; j++) {\r\n            _result += jackpot[j];\r\n        }\r\n    }\r\n\r\n    //---------- Win Mini Jackpot Function ----------//\r\n    function tryJackpot() internal {\r\n        if(pseudoRandom(8,\"\") == 4) { // ---> 12,5% winning chance\r\n            payable(_msgSender()).transfer(currentPot());\r\n            emit MiniJackpotWin(_msgSender(), currentPot()); // ---> emits jackpot amount and winner when hit\r\n            delete jackpot; // ---> purge mini jackpot array after it has been paid out\r\n        }\r\n        else {\r\n            emit MiniJackpotAmount(currentPot()); // ---> emits jackpot amount when not hit\r\n        }\r\n    }\r\n\r\n    //---------- Set PixelTag Contract Address For Interactions/Interface ----------//\r\n    function setTagContract(address _addr) external onlyOwner {\r\n        pixelTagContract = _addr;\r\n    }\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- WITHDRAW FUNCTIONS ----------//\r\n\r\n    //---------- Distribute Balance if Game Has Not Concluded Prior To Time Limit ----------//\r\n    function withdraw() public {\r\n        require(block.timestamp >= timeLimit, \"Play fair, wait until the time limit runs out\");\r\n        require(contractCreator == _msgSender(), \"Only Owner can withdraw after time limit runs out\");\r\n        uint256 balance = address(this).balance;\r\n        payable(abashoCollective).transfer(balance/100*15);\r\n        payable(contractCreator).transfer(address(this).balance);\r\n    }\r\n\r\n    //---------- Distribute Balance if Game Has Concluded Prior To Time Limit ----------//\r\n    function distributeToWinners() public {\r\n        require(pixelWarConcluded, \"The game has not concluded yet!\");\r\n        require(!payout, \"The prize pool has already been paid out!\");\r\n        uint256 balance = address(this).balance;\r\n        // 25% to Last player and most attacks\r\n        payable(lastPlayer).transfer(balance/100*25);\r\n        payable(mostAttacks).transfer(balance/100*25);\r\n        // 15% to random holder of Player and Dog Tag NFTs\r\n        payable(randomPlayer).transfer(balance/100*10);\r\n        payable(randomTag).transfer(balance/100*10);\r\n        // 15% to abasho collective and remainder to Contract Creator\r\n        payable(abashoCollective).transfer(balance/100*15);\r\n        payable(contractCreator).transfer(address(this).balance);\r\n        payout = true;\r\n    }\r\n    //---------------------------------------------------------------------------------------------\r\n    //----------SET LATE ABASHO COLLECTIVE ADDRESS ----\r\n\r\n    function setAbashoADDR(address _addr) external onlyOwner {\r\n        abashoCollective = _addr;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- METADATA & BASEURI ----\r\n\r\n    function setBaseURI(string memory baseURI_) external onlyOwner {\r\n        baseURI = baseURI_;\r\n    }\r\n\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(_tokenId), \"There is no token with that ID\");\r\n        string memory currentBaseURI = _baseURI();\r\n        if(isAlive(_tokenId)) {\r\n            return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(currentBaseURI, _toString(_tokenId), '.json')) : '';\r\n        }\r\n        else {\r\n            return bytes(currentBaseURI).length > 0 ? string(abi.encodePacked(currentBaseURI,'d', _toString(_tokenId), '.json')) : '';\r\n        }\r\n\r\n        \r\n    }\r\n}"
6     },
7     "PixelTag.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n// www.PixelRoyale.xyz\r\n/*\r\n ____ ____ ____ ____ ____ ____ ____ ____ ____ \r\n||P |||i |||x |||e |||l |||T |||a |||g |||s ||\r\n||__|||__|||__|||__|||__|||__|||__|||__|||__||\r\n|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|/__\\|\r\n \r\n */\r\n\r\npragma solidity 0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"erc721a/contracts/ERC721A.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\"; \r\nimport {Base64} from \"base64-sol/base64.sol\";\r\nimport {TraitAssembly} from \"./TraitAssembly.sol\";\r\n\r\ncontract PixelTags is ERC721A, Ownable {\r\n    //---------- Vars ----------//\r\n    address public contractCreator;\r\n    address public pixelRoyale;\r\n    uint256 public constant MAXTAGS = 4443;\r\n    string private baseURI;\r\n    //---------- On-Chain Gen Art ----------//\r\n    uint16 private pixelIndex = 1;\r\n    mapping(uint256 => uint32) private pixelTags;\r\n    //---------- Metadata Snippets ----------//\r\n    string private comb1 = '\",\"description\": \"4443 On-Chain PixelTags given out for confirmed kills in the PixelRoyale BATTLE GAME. Collect the PixelTags for a chance to win 10% of the PixelRoyale prize pool!\",\"external_url\": \"https://pixelroyale.xyz/\",\"attributes\": [{\"trait_type\": \"Background\",\"value\": \"';\r\n    string private comb2 = '\"},{\"trait_type\": \"Base\",\"value\": \"';\r\n    string private comb3 = '\"},{\"trait_type\": \"Soul\",\"value\": \"';\r\n    string private comb4 = '\"},{\"trait_type\": \"Accessoire\",\"value\": \"';\r\n    string private comb5 = '\"},{\"trait_type\": \"Mouth\",\"value\": \"';\r\n    string private comb6 = '\"},{\"trait_type\": \"Eyes\",\"value\": \"';\r\n    string private comb7 = '\"}],\"image\": \"data:image/svg+xml;base64,';\r\n    string private comb8 = '\"}';\r\n    //---------- Trait Names ----------//\r\n    string[4] maTrait = [\"Ag\", \"Au\", \"Pt\", \"Rn\"];\r\n\r\n    //---------- Construct ERC721A TOKEN ----------//\r\n    constructor() ERC721A(\"PixelTags BATTLE GAME\", \"PTBG\") {\r\n      contractCreator = msg.sender;\r\n    }\r\n\r\n    function _startTokenId() internal view virtual override returns (uint256) {\r\n      return 1;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- MINT FUNCTIONS ----------//\r\n    //---------- Set Origin Contract ----------//\r\n    function setMintContract(address _addr) external onlyOwner {\r\n      pixelRoyale = _addr;\r\n    }\r\n\r\n    //---------- Mint PixelTag ----------//\r\n    function mintPixelTag(address _receiver) external {\r\n        require(msg.sender == pixelRoyale, \"Only Contract can mint\");\r\n        uint256 total = totalSupply();\r\n        require(total < MAXTAGS, \"The GAME has most likely concluded\");\r\n        // Mint\r\n        _safeMint(_receiver, 1);\r\n        pixelTags[pixelIndex] = uint32(bytes4(keccak256(abi.encodePacked(block.timestamp, pixelIndex, msg.sender))));\r\n        pixelIndex++;\r\n    }\r\n\r\n    //---------------------------------------------------------------------------------------------\r\n    //---------- METADATA GENERATION ----------//\r\n\r\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(_tokenId), 'There is no Token with that ID');\r\n        //Start JSON and SVG Generation by creating file headers\r\n        bytes memory json = abi.encodePacked('{\"name\": \"Pixel Tag #',Strings.toString(_tokenId)); // --> JSON HEADER\r\n        bytes memory img = abi.encodePacked('<svg xmlns=\"http://www.w3.org/2000/svg\" witdh=\"640\" height=\"640\" viewBox=\"0 0 16 16\">'); // --> SVG HEADER\r\n        uint32 seed = pixelTags[_tokenId];\r\n        //Init Trait Strings\r\n        string memory trait1;\r\n        string memory trait2;\r\n        string memory svg2;\r\n        string memory trait3;\r\n        string memory svg3;\r\n        string memory trait4;\r\n        string memory svg4;\r\n        //Init Color Strings \r\n        string memory basePrimeCol;\r\n        string memory baseSecondCol;\r\n        string memory backgroundColor = Strings.toString((seed%36)*10); \r\n        string memory soulColor =  Strings.toString((seed%72)*5);\r\n\r\n        // ------ BASE COLOR TRAIT ----- //\r\n        if(seed%99==0) { //--> 1%\r\n            trait1 = maTrait[3];\r\n            basePrimeCol =\"179,24%,61%\";\r\n            baseSecondCol = \"179,100%,86%\";\r\n        }\r\n        else if(seed%99>=1 && seed%99<=5) { //--> 5%\r\n            trait1 = maTrait[2];\r\n            basePrimeCol =\"180,6%,57%\";\r\n            baseSecondCol = \"178,53%,88%\";\r\n        }\r\n        else if(seed%99>=6 && seed%99<=20) { //--> 15%\r\n            trait1 = maTrait[1];\r\n            basePrimeCol =\"46,67%,48%\";\r\n            baseSecondCol = \"46,100%,70%\";\r\n        }\r\n        else { //--> 79%\r\n            trait1 = maTrait[0];\r\n            basePrimeCol =\"180,2%,40%\";\r\n            baseSecondCol = \"180,2%,80%\";\r\n        }\r\n\r\n        // ------ ACCESSORY TRAIT ----- //\r\n        if(seed%99>=75) { //--> 24%\r\n            (svg2,trait2) = (\"\",\"None\");\r\n        }\r\n        else { //--> 76%\r\n            (svg2,trait2) = TraitAssembly.choseA(seed);\r\n        }\r\n\r\n        // ------ MOUTH TRAIT ----- //\r\n        (svg3,trait3) = TraitAssembly.choseM(seed);\r\n\r\n        // ------ EYE TRAIT ----- //\r\n        (svg4,trait4) = TraitAssembly.choseE(seed);\r\n\r\n        // ----- JSON ASSEMBLY ------//\r\n        json = abi.encodePacked(json,comb1,backgroundColor);\r\n        json = abi.encodePacked(json,comb2,trait1);\r\n        json = abi.encodePacked(json,comb3,soulColor);\r\n        json = abi.encodePacked(json,comb4,trait2);\r\n        json = abi.encodePacked(json,comb5,trait3);\r\n        json = abi.encodePacked(json,comb6,trait4);\r\n\r\n        // ----- SVG ASSEMBLY ------//\r\n        //BACKGROUND//\r\n        img = abi.encodePacked(img, '<rect x=\"0\" y=\"0\" width=\"16\" height=\"16\" fill=\"hsl(',backgroundColor,',100%,90%)\"/>');\r\n        //BASE// \r\n        img = abi.encodePacked(img, '<polygon points=\"5,1 5,2 4,2 4,3 3,3 3,4 3,13 4,13 4,14 5,14 5,15 11,15 11,14 12,14 12,13 13,13 13,3 12,3 12,2 11,2 11,1\" fill=\"hsl(',basePrimeCol,')\"/>');  // --> Outline\r\n        img = abi.encodePacked(img, '<polygon points=\"5,2 5,3 4,3 4,3 4,3 4,4 4,13 5,13 5,14 6,14 6,14 11,14 11,13 11,13 12,13 12,3 11,3 11,2 11,2\" fill=\"hsl(',baseSecondCol,')\"/>'); //--> Inner\r\n        //ACCESSORY\r\n        img = abi.encodePacked(img, svg2);\r\n        //MOUTH\r\n        img = abi.encodePacked(img, svg3);\r\n        //EYES\r\n        img = abi.encodePacked(img, svg4);\r\n        // ----- CLOSE OFF SVG AND JSON ASSEMBLY ------//\r\n        img = abi.encodePacked(img, '</svg>');\r\n        json = abi.encodePacked(json,comb7,Base64.encode(img),comb8);\r\n        // ----- RETURN BASE64 ENCODED METADATA ------//\r\n        return string(abi.encodePacked('data:application/json;base64,', Base64.encode(json)));\r\n    }\r\n}\r\n//---------------------------------------------------------------------------------------------\r\n//---------- LAY OUT INTERFACE ----------//\r\ninterface InterfacePixelTags {\r\n    function mintPixelTag(address _receiver) external;\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n}"
9     },
10     "erc721a/contracts/ERC721A.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.0.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721A.sol';\n\n/**\n * @dev ERC721 token receiver interface.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n    // Mask of an entry in packed address data.\n    uint256 private constant BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant BITMASK_BURNED = 1 << 224;\n    \n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The tokenId of the next token to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See `_packedOwnershipOf` implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    mapping(uint256 => uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address => uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    /**\n     * @dev Returns the starting token ID. \n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count. \n     * To get the total number of tokens minted, please see `_totalMinted`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _currentIndex does not decrement,\n        // and it is initialized to `_startTokenId()`\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view returns (uint256) {\n        return _burnCounter;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes of the XOR of\n        // all function selectors in the interface. See: https://eips.ethereum.org/EIPS/eip-165\n        // e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_MINTED) & BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_BURNED) & BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] >> BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        assembly { // Cast aux without masking.\n            auxCasted := aux\n        }\n        packed = (packed & BITMASK_AUX_COMPLEMENT) | (auxCasted << BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr)\n                if (curr < _currentIndex) {\n                    uint256 packed = _packedOwnerships[curr];\n                    // If not burned.\n                    if (packed & BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an ownership that has an address and is not burned\n                        // before an ownership that does not have an address and is not burned.\n                        // Hence, curr will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed is zero.\n                        while (packed == 0) {\n                            packed = _packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & BITMASK_BURNED != 0;\n    }\n\n    /**\n     * Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev Casts the address to uint256 without masking.\n     */\n    function _addressToUint256(address value) private pure returns (uint256 result) {\n        assembly {\n            result := value\n        }\n    }\n\n    /**\n     * @dev Casts the boolean to uint256 without branching.\n     */\n    function _boolToUint256(bool value) private pure returns (uint256 result) {\n        assembly {\n            result := value\n        }\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < _currentIndex && // If within bounds,\n            _packedOwnerships[tokenId] & BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the balance and number minted.\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] =\n                _addressToUint256(to) |\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            if (to.code.length != 0) {\n                do {\n                    emit Transfer(address(0), to, updatedIndex);\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (updatedIndex < end);\n                // Reentrancy protection\n                if (_currentIndex != startTokenId) revert();\n            } else {\n                do {\n                    emit Transfer(address(0), to, updatedIndex++);\n                } while (updatedIndex < end);\n            }\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 quantity) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the balance and number minted.\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] =\n                _addressToUint256(to) |\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            do {\n                emit Transfer(address(0), to, updatedIndex++);\n            } while (updatedIndex < end);\n\n            _currentIndex = updatedIndex;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\n            isApprovedForAll(from, _msgSenderERC721A()) ||\n            getApproved(tokenId) == _msgSenderERC721A());\n\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        delete _tokenApprovals[tokenId];\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] =\n                _addressToUint256(to) |\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\n                BITMASK_NEXT_INITIALIZED;\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        if (approvalCheck) {\n            bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\n                isApprovedForAll(from, _msgSenderERC721A()) ||\n                getApproved(tokenId) == _msgSenderERC721A());\n\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        delete _tokenApprovals[tokenId];\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 << BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] =\n                _addressToUint256(from) |\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\n                BITMASK_BURNED | \n                BITMASK_NEXT_INITIALIZED;\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\n            bytes4 retval\n        ) {\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n     * minting.\n     * And also called after one token has been burned.\n     *\n     * startTokenId - the first token id to be transferred\n     * quantity - the amount to be transferred\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), \n            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\n            // We will need 1 32-byte word to store the length, \n            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\n            ptr := add(mload(0x40), 128)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, ptr)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := ptr\n\n            // We write the string from the rightmost digit to the leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // Costs a bit more than early returning for the zero case,\n            // but cheaper in terms of deployment and overall runtime costs.\n            for { \n                // Initialize and perform the first pass without check.\n                let temp := value\n                // Move the pointer 1 byte leftwards to point to an empty character slot.\n                ptr := sub(ptr, 1)\n                // Write the character to the pointer. 48 is the ASCII index of '0'.\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n            } temp { \n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n            } { // Body of the for loop.\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n            }\n            \n            let length := sub(end, ptr)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            ptr := sub(ptr, 32)\n            // Store the length.\n            mstore(ptr, length)\n        }\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/access/Ownable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
15     },
16     "erc721a/contracts/IERC721A.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.0.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of an ERC721A compliant contract.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * The caller cannot approve to their own address.\n     */\n    error ApproveToCaller();\n\n    /**\n     * The caller cannot approve to the current owner.\n     */\n    error ApprovalToCurrentOwner();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n    }\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     *\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // ==============================\n    //            IERC165\n    // ==============================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // ==============================\n    //            IERC721\n    // ==============================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // ==============================\n    //        IERC721Metadata\n    // ==============================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
18     },
19     "TraitAssembly.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\n// www.PixelRoyale.xyz\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nlibrary TraitAssembly {\r\n    \r\n    //---------- ACCESSORY ASSEMBLY - WITH ACCESSORY SVGs ----------//\r\n    function choseA(uint32 _seed) public pure returns (string memory _aString, string memory _aJson) {\r\n        string[13] memory _traitArray = [\"Flower Crown\", \"Night Vision\", \"Trauma\", \"Sleek Curl\", \"Twin Tails\", \"Red Rag\", \"Blue Rag\", \"Snapback\", \"Crown\", \"One Peace\", \"Red Oni\", \"Blue Oni\", \"Clown\"];\r\n        string memory _trait = _traitArray[_seed%12];\r\n        string memory soulCol =  Strings.toString((_seed%72)*5);\r\n        string memory inverseCol = Strings.toString((((_seed%72)*5)+180)%360);\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[0]))) {\r\n            _aString = '<polygon points=\"3,3 8,3 8,4 9,4 9,3 13,3 13,4 14,4 14,5 13,5 13,6 8,6 8,5 7,5 7,6 3,6 3,5 2,5 2,4 3,4\" fill=\"hsl(102, 75%, 58%)\"/><polygon points=\"5,3 11,3 11,4 12,4 12,5 11,5 11,6 10,6 10,5 9,5 9,4 10,4 10,3 6,3 6,4 7,4 7,5 6,5 6,6 5,6 5,5 4,5 4,4 5,4\" fill=\"hsl(0, 100%, 100%)\"/><polygon points=\"5,4 11,4 11,5 10,5 10,4 6,4 6,5 5,5 5,4\" fill=\"hsl(48, 100%, 57%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[1]))) {\r\n            _aString = '<polygon points=\"4,2 6,2 6,3 7,3 7,2 9,2 9,3 10,3 10,2 12,2 12,3 13,3 13,5 14,5 14,6 10,6 10,5 6,5 6,6 2,6 2,5 3,5 3,3 4,3\" fill=\"hsl(0,0%,0%)\"/><polygon points=\"4,3 12,3 12,5 10,5 10,3 9,3 9,4 7,4 7,3 6,3 6,5 4,5\" fill=\"hsl(102, 73%, 64%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[2]))) {\r\n            _aString = '<polygon points=\"9,2 11,2 11,5 10,5 10,3 9,3\" fill=\"hsl(352, 100%, 41%)\"/>'; \r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[3]))) {\r\n            _aString = string(abi.encodePacked('<polygon points=\"4,1 12,1 12,2 13,2 13,7 12,7 12,6 11,6 11,4 8,4 8,5 9,5 9,6 7,6 7,4 5,4 5,6 4,6 4,7 3,7 3,2 4,2\" fill=\"hsl(',inverseCol,', 80%, 60%)\"/>')); \r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[4]))) {\r\n            _aString = string(abi.encodePacked('<polygon points=\"5,1 11,1 11,2 12,2 12,3 13,3 13,4 14,4 14,5 15,5 15,6 16,6 16,10 15,10 15,9 14,9 14,6 13,6 13,7 12,7 12,6 11,6 11,5 10,5 10,6 9,6 9,5 8,5 8,6 6,6 6,5 5,5 5,6 4,6 4,7 3,7 3,6 2,6 2,9 1,9 1,10 0,10 0,6 1,6 1,5 2,5 2,4 3,4 3,3 4,3 4,2 5,2\" fill=\"hsl(',inverseCol,', 80%, 60%)\"/><polygon points=\"2,4 3,4 14,4 14,6 13,6 13,4 3,4 3,6 2,6 \" fill=\"hsl(',soulCol,', 40%, 60%)\"/>'));\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[5]))) {\r\n            _aString = '<polygon points=\"3,2 4,2 4,1 12,1 12,2 13,2 13,5 2,5 2,6 1,6 1,5 2,5 2,4 1,4 1,3 2,3 2,4 3,4\" fill=\"hsl(0, 75%, 50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[6]))) {\r\n            _aString = '<polygon points=\"3,2 4,2 4,1 12,1 12,2 13,2 13,5 2,5 2,6 1,6 1,5 2,5 2,4 1,4 1,3 2,3 2,4 3,4\" fill=\"hsl(225, 75%, 50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[7]))) {\r\n            _aString = string(abi.encodePacked('<polygon points=\"3,4 3,2 4,2 4,1 12,1 12,2 13,2 13,5 2,5 1,5 1,4\" fill=\"hsl(',soulCol,', 75%, 50%)\"/><polygon points=\"7,4 7,3 8,3 8,2 10,2 10,3 11,3 11,4\" fill=\"hsl(',soulCol,', 75%, 25%)\"/>'));\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[8]))) {\r\n            _aString = '<polygon points=\"3,4 4,4 4,3 5,3 5,4 6,4 6,3 7,3 7,2 9,2 9,3 10,3 10,4 11,4 11,3 12,3 12,4 13,4 13,5 3,5 \" fill=\"hsl(45, 100%, 50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[9]))) {\r\n            _aString = '<polygon points=\"1,4 3,4 3,2 4,2 4,1 12,1 12,2 13,2 13,4 15,4 15,5 1,5\" fill=\"hsl(45, 100%, 50%)\"/><rect x=\"3\" y=\"3\" width=\"10\" height=\"1\" fill=\"hsl(0,100%,50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[10]))) {\r\n            _aString = '<polygon points=\"12,5 12,3 13,3 13,2 14,2 14,1 15,1 15,4 14,4 14,5\" fill=\"hsl(0,100%,50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[11]))) {\r\n            _aString = '<polygon points=\"4,5 4,3 3,3 3,2 2,2 2,1 1,1 1,4 2,4 2,5\" fill=\"hsl(225,100%,50%)\"/>';\r\n        }\r\n        else if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[12]))) {\r\n            _aString = string(abi.encodePacked('<polygon points=\"1,1 2,1 2,2 6,2 6,1 7,1 7,0 9,0 9,1 10,1 10,2 14,2 14,1 15,1 15,4 14,4 14,5 12,5 12,3 11,3 11,2 5,2 5,3 4,3 4,5 2,5 2,4 1,4\" fill=\"hsl(',soulCol,',75%,45%)\"/>'));\r\n        }\r\n        return(_aString,_aJson = _trait);\r\n    }\r\n    \r\n    //---------- EYES ASSEMBLY - WITH EYE SVGs ----------//\r\n    function choseE(uint32 _seed) public pure returns (string memory _eString, string memory _eJson) {\r\n        string[17] memory _traitArray = [\"Passive\", \"Sane\", \"Wary\", \"Fine\", \"Shut\", \"Glee\", \"Cool\", \"Tough\", \"Archaic\", \"Sly\", \"Sharp\", \"Sad\", \"Indifferent\", \"Focused\", \"Gloomy\", \"Abnormal\", \"Gem\"];\r\n        string memory _trait = _traitArray[_seed%16];\r\n        string memory soulCol =  Strings.toString((_seed%72)*5);\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[0]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,7 11,7 11,9 9,9 9,7 7,7 7,9 5,9\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"6,7 11,7 11,9 10,9 10,7 7,7 7,9 6,9\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[1]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,8 10,8 10,9 9,9 9,8 6,8 6,9 5,9\" fill=\"hsl(',soulCol,',40%,60%)\"/><polygon points=\"5,6 11,6 11,7 9,7 9,6 7,6 7,7 5,7\" fill=\"hsl(180,0%,0%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[2]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"6,8 11,8 11,9 10,9 10,8 7,8 7,9 6,9\" fill=\"hsl(',soulCol,',40%,60%)\"/><polygon points=\"5,5 6,5 6,6 11,6 11,7 9,7 9,6 7,6 7,7 6,7 6,6 5,6\" fill=\"hsl(180,0%,0%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[3]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"4,8 5,8 5,7 11,7 11,8 12,8 12,9 9,9 9,7 7,7 7,9 4,9\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"5,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9\" fill=\"hsl(',soulCol,',40%,60%)\"/><polygon points=\"6,8 11,8 11,9 10,9 10,8 7,8 7,9 6,9\" fill=\"hsl(180,0%,0%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[4]))) {\r\n            _eString = '<polygon points=\"4,7 5,7 5,8 6,8 6,7 10,7 10,8 11,8 11,7 12,7 12,8 11,8 11,9 10,9 10,8 9,8 9,7 7,7 7,8 6,8 6,9 5,9 5,8 4,8\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[5]))) {\r\n            _eString = '<polygon points=\"4,8 5,8 5,7 6,7 6,8 10,8 10,7 11,7 11,8 12,8 12,9 11,9 11,8 10,8 10,9 9,9 9,8 7,8 7,9 6,9 6,8 5,8 5,9 4,9\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[6]))) {\r\n            _eString = '<polygon points=\"4,7 12,7 12,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9 5,8 4,8\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[7]))) {\r\n            _eString = string(abi.encodePacked('<rect x=\"5\" y=\"8\" width=\"2\" height=\"1\" fill=\"hsl(180,100%,100%)\"/><rect x=\"5\" y=\"8\" width=\"1\" height=\"1\" fill=\"hsl(',soulCol,',40%,60%)\"/><polygon points=\"5,3 6,3 6,4 7,4 7,5 8,5 8,6 9,6 9,7 11,7 11,9 12,9 12,10 11,10 11,9 9,9 9,8 5,8 5,7 7,7 7,8 9,8 9,7 8,7 8,6 7,6 7,5 6,5 6,4 5,4\" fill=\"hsl(180,0%,0%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[8]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,8 10,8 10,9 9,9 9,8 6,8 6,9 5,9\" fill=\"hsl(',soulCol,',40%,60%)\"/><rect x=\"4\" y=\"7\" width=\"8\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[9]))) {\r\n            _eString = string(abi.encodePacked('<rect x=\"4\" y=\"6\" width=\"8\" height=\"3\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"5,7 11,7 11,8 9,8 9,7 7,7 7,8 5,8\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"6,7 11,7 11,8 10,8 10,7 7,7 7,8 6,8\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[10]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,7 5,6 7,6 7,7 9,7 9,6 11,6 11,7 12,7 12,8 11,8 11,9 9,9 9,8 7,8 7,9 5,9 5,8 4,8 4,7\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"5,7 11,7 11,8 9,8 9,7 7,7 7,8 5,8\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[11]))) {\r\n            _eString = '<polygon points=\"11,8 11,10 10,10 10,8 6,8 6,12 5,12 5,8\" fill=\"hsl(188, 39%, 58%)\"/><polygon points=\"5,7 11,7 11,8 9,8 9,7 7,7 7,8 5,8\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[12]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,6 6,6 6,9 10,9 10,6 11,6 11,9 5,9\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"4,7 12,7 12,8 9,8 9,7 7,7 7,8 4,8\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,7 6,7 6,8 10,8 10,7 11,7 11,8 5,8\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[13]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"4,7 12,7 12,8 9,8 9,7 7,7 7,8 4,8\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"4,8 12,8 12,9 9,9 9,8 7,8 7,9 4,9\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,8 6,8 6,9 10,9 10,8 11,8 11,9 5,9\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[14]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"4,5 5,5 5,6 6,6 6,7 10,7 10,6 11,6 11,5 12,5 12,7 13,7 13,8 12,8 12,10 11,10 11,9 10,9 10,8 9,8 9,7 7,7 7,8 6,8 6,9 5,9 5,10 4,10 4,8 3,8 3,7 4,7 \" fill=\"hsl(180,0%,0%)\"/><polygon points=\"4,7 12,7 12,8 10,8 10,7 6,7 6,8 4,8\" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,7 6,7 6,8 11,8 11,7 12,7 12,8 5,8\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[15]))) {\r\n            _eString = '<polygon points=\"5,8 6,8 6,9 10,9 10,7 11,7 11,9 10,9 5,9\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[16]))) {\r\n            _eString = string(abi.encodePacked('<polygon points=\"5,7 11,7 11,9 9,9 9,7 7,7 7,9 5,9 \" fill=\"hsl(180,100%,100%)\"/><polygon points=\"5,8 6,8 6,7 7,7 7,8  10,8 10,7 11,7 11,8 10,8 10,9 9,9 9,8 6,8 6,9 5,9\" fill=\"hsl(',soulCol,',40%,60%)\"/>'));\r\n        }\r\n        return(_eString,_eJson = _trait);\r\n    }\r\n\r\n    //---------- MOUTH ASSEMBLY - WITH MOUTH SVGs ----------//\r\n    function choseM(uint32 seed) public pure returns (string memory _mString, string memory _mJson) {\r\n        string[18] memory _traitArray = [\"Smile\", \"Rabbit\", \"Frown\", \"Jeez\", \"Deez\", \"Grin\", \"Hungry\", \"Hillbilly\", \"Yikes\", \"Dumber\", \"Cigarette\", \"Puke\", \"Raw\", \"Tongue\", \"Surprised\", \"Stunned\", \"Chew\", \"Respirator\"]; \r\n        string memory _trait = _traitArray[seed%17];\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[0]))) {\r\n            _mString = '<polygon points=\"6,11 5,11 5,10 6,10 6,11 10,11 10,10 11,10 11,11 10,11 10,12 6,12\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[1]))) {\r\n            _mString = '<polygon points=\"6,11 5,11 5,10 6,10 6,11 10,11 10,10 11,10 11,11 10,11 10,12 6,12\" fill=\"hsl(180,0%,0%)\"/><polygon points=\"7,13 7,12 9,12 9,13\" fill=\"hsl(180,100%,100%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[2]))) {\r\n            _mString = '<polygon points=\"6,12 5,12 5,11 6,11 6,10 10,10 10,12 11,12 11,11 10,11 10,11 6,11 \" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[3]))) {\r\n            _mString = '<rect x=\"7\" y=\"10\" width=\"2\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[4]))) {\r\n            _mString = '<rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/><rect x=\"6\" y=\"10\" width=\"1\" height=\"1\" fill=\"hsl(180,100%,100%)\"/><rect x=\"9\" y=\"10\" width=\"1\" height=\"1\" fill=\"hsl(180,100%,100%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[5]))) {\r\n            _mString = '<polygon points=\"7,11 6,11 6,10 7,10 7,11 9,11 9,10 10,10 10,11 9,11 9,12 7,12\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[6]))) {\r\n            _mString = '<polygon points=\"7,11 7,12 6,12 6,10 10,10 10,13 9,13 9,12 8,12 8,11\" fill=\"hsl(188, 39%, 58%)\"/><rect x=\"6\" y=\"10\" width=\"4\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[7]))) {\r\n            _mString = '<polygon points=\"7,11 7,12 6,12 6,10 10,10 10,12 9,12 9,11\" fill=\"hsl(180, 100%, 100%)\"/><rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[8]))) {\r\n            _mString = '<rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/><rect x=\"6\" y=\"10\" width=\"4\" height=\"1\" fill=\"hsl(180,100%,100%)\"/> ';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[9]))) {\r\n            _mString = '<rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/><rect x=\"6\" y=\"10\" width=\"4\" height=\"1\" fill=\"hsl(180,100%,100%)\"/><rect x=\"7\" y=\"10\" width=\"1\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[10]))) {\r\n            _mString = '<polygon points=\"6,12 6,11 5,11 5,10 6,10 6,11 10,11 10,12\" fill=\"hsl(180,0%,0%)\"/><rect x=\"9\" y=\"11\" width=\"2\" height=\"1\" fill=\"hsl(180,100%,100%)\"/><rect x=\"11\" y=\"11\" width=\"1\" height=\"1\" fill=\"hsl(358, 100%, 51%)\"/><polygon points=\"13,11 12,11 12,10 13,10 13,7 12,7 12,8 13,8 13,9 14,9 14,10 13,10 \" fill=\"hsl(0, 0%, 90%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[11]))) {\r\n            _mString = '<polygon points=\"9,10 11,10 11,14 10,14 10,13 9,13\" fill=\"hsl(119, 100%, 41%)\"/><rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[12]))) {\r\n            _mString = '<polygon points=\"7,11 7,12 6,12 6,10 9,10 11,10 11,14 10,14 10,13 9,13 9,11\" fill=\"hsl(352, 100%, 41%)\"/><rect x=\"5\" y=\"10\" width=\"6\" height=\"1\" fill=\"hsl(180,0%,0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[13]))) {\r\n            _mString = '<polygon points=\"5,10 11,10 11,11 10,11 10,13 9,13 9,14 8,14 7,14 7,13 6,13 6,11 5,11,\" fill=\"hsl(180, 0%, 0%)\"/><rect x=\"7\" y=\"11\" width=\"2\" height=\"2\" fill=\"hsl(4, 74%, 50%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[14]))) {\r\n            _mString = '<polygon points=\" 7,10 6,10 6,9 10,9 10,10 11,10 11,12 10,12 10,13 6,13 6,12 5,12 5,10\" fill=\"hsl(180, 0%, 0%)\"/><rect x=\"6\" y=\"10\" width=\"4\" height=\"2\" fill=\"hsl(4, 74%, 50%)\"/><rect x=\"9\" y=\"10\" width=\"1\" height=\"1\" fill=\"hsl(180, 100%, 100%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[15]))) {\r\n             _mString = '<rect x=\"7\" y=\"10\" width=\"2\" height=\"2\" fill=\"hsl(4, 74%, 50%)\"/><rect x=\"8\" y=\"10\" width=\"1\" height=\"1\" fill=\"hsl(180, 100%, 100%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[16]))) {\r\n            _mString = '<polygon points=\"6,10 11,10 11,9 10,9 10,12 11,12 11,11 6,11\" fill=\"hsl(180, 0%, 0%)\"/>';\r\n        }\r\n        if (keccak256(abi.encodePacked(_trait)) == keccak256(abi.encodePacked(_traitArray[17]))) {\r\n            _mString = '<polygon points=\"3,8 4,8 4,9 5,9 5,10 6,10 6,9 10,9 10,10 11,10 11,9 12,9 12,8 13,8 13,9 12,9 12,10 11,10 11,12 13,12 13,13 3,13 3,12 5,12 5,10 4,10 4,9 3,9 \" fill=\"hsl(0, 0%, 20%)\"/><rect x=\"6\" y=\"10\" width=\"4\" height=\"2\" fill=\"hsl(53, 12%, 85%)\"/>';\r\n        }\r\n        return(_mString,_mJson = _trait);\r\n    }\r\n}"
21     },
22     "base64-sol/base64.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
24     },
25     "@openzeppelin/contracts/utils/Strings.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/utils/Context.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
30     }
31   },
32   "settings": {
33     "optimizer": {
34       "enabled": true,
35       "runs": 200
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "devdoc",
43           "userdoc",
44           "metadata",
45           "abi"
46         ]
47       }
48     }
49   }
50 }}