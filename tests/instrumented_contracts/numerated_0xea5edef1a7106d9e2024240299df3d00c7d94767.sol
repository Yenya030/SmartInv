1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/core/RcaController.sol": {
5       "content": "/// SPDX-License-Identifier: UNLICENSED\n\n/**\n\n                               ................                            \n                          ..',,;;::::::::ccccc:;,'..                       \n                      ..',;;;;::::::::::::cccccllllc;..                    \n                    .';;;;;;;,'..............',:clllolc,.                  \n                  .,;;;;;,..                    .';cooool;.                \n                .';;;;;'.           .....          .,coodoc.               \n               .,;;;;'.       ..',;:::cccc:;,'.      .;odddl'              \n              .,;;;;.       .,:cccclllllllllool:'      ,odddl'             \n             .,:;:;.      .;ccccc:;,''''',;cooooo:.     ,odddc.            \n             ';:::'     .,ccclc,..         .':odddc.    .cdddo,            \n            .;:::,.     ,cccc;.              .:oddd:.    ,dddd:.           \n            '::::'     .ccll:.                .ldddo'    'odddc.           \n            ,::c:.     ,lllc'    .';;;::::::::codddd;    ,dxxxc.           \n           .,ccc:.    .;lllc.    ,oooooddddddddddddd;    :dxxd:            \n            ,cccc.     ;llll'    .;:ccccccccccccccc;.   'oxxxo'            \n            'cccc,     'loooc.                         'lxxxd;             \n            .:lll:.    .;ooooc.                      .;oxxxd:.             \n             ,llll;.    .;ooddo:'.                ..:oxxxxo;.              \n             .:llol,.     'coddddl:;''.........,;codxxxxd:.                \n              .:lool;.     .':odddddddddoooodddxxxxxxdl;.                  \n               .:ooooc'       .';codddddddxxxxxxdol:,.                     \n                .;ldddoc'.        ...'',,;;;,,''..                         \n                  .:oddddl:'.                          .,;:'.              \n                    .:odddddoc;,...              ..',:ldxxxx;              \n                      .,:odddddddoolcc::::::::cllodxxxxxxxd:.              \n                         .';clddxxxxxxxxxxxxxxxxxxxxxxoc;'.                \n                             ..',;:ccllooooooollc:;,'..                    \n                                        ......                             \n                                                                      \n**/\n\npragma solidity 0.8.11;\nimport \"../general/RcaGovernable.sol\";\nimport \"../library/MerkleProof.sol\";\nimport \"../interfaces/IRcaShield.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title RCA Controller\n * @notice Controller contract for all RCA vaults.\n * This contract creates vaults, emits events when anything happens on a vault,\n * keeps track of variables relevant to vault functionality, keeps track of capacities,\n * amounts for sale on each vault, prices of tokens, and updates vaults when needed.\n * @author Robert M.C. Forster, Romke Jonker, Taek Lee, Chiranjibi Poudyal\n */\n\ncontract RcaController is RcaGovernable {\n    /// @notice Address => whether or not it's a verified shield.\n    mapping(address => bool) public shieldMapping;\n    /// @notice Address => whether or not shield is active.\n    mapping(address => bool) public activeShields;\n\n    /// @notice Address => whether or not router is verified.\n    mapping(address => bool) public isRouterVerified;\n\n    /// @notice Fees for users per year for using the system. Ideally just 0 but option is here.\n    /// In hundredths of %. 1000 == 10%.\n    uint256 public apr;\n    /// @notice Amount of time users must wait to withdraw tokens after requesting redemption. In seconds.\n    uint256 public withdrawalDelay;\n    /// @notice Discount for purchasing tokens being liquidated from a shield. 1000 == 10%.\n    uint256 public discount;\n    /// @notice Address that funds from selling tokens is sent to.\n    address payable public treasury;\n    /// @notice Amount of funds for sale on a protocol, sent in by DAO after a hack occurs (in token).\n    bytes32 public liqForClaimsRoot;\n    /// @notice The amount of each shield that's currently reserved for hack payouts. 1000 == 10%.\n    bytes32 public reservedRoot;\n    /// @notice Root of all underlying token prices--only used if the protocol is doing pricing. Price in Ether.\n    bytes32 public priceRoot;\n\n    /// @notice Nonce to prevent replays of capacity signatures. User => RCA nonce.\n    mapping(address => uint256) public nonces;\n    /// @notice Last time each individual shield was checked for update.\n    mapping(address => uint256) public lastShieldUpdate;\n\n    /**\n     * @dev The update variable flow works in an interesting way to optimize efficiency:\n     * Each time a user interacts with a specific shield vault, it calls Controller\n     * for all necessary interactions (events & updates). The general Controller function\n     * will check when when the last shield update was made vs. all recent other updates.\n     * If a system update is more recent than the shield update, value is changed.\n     */\n    struct SystemUpdates {\n        uint32 liqUpdate;\n        uint32 reservedUpdate;\n        uint32 withdrawalDelayUpdate;\n        uint32 discountUpdate;\n        uint32 aprUpdate;\n        uint32 treasuryUpdate;\n    }\n    SystemUpdates public systemUpdates;\n\n    /**\n     * @dev Events are used to notify the frontend of events on shields. If we have 1,000 shields,\n     * a centralized event system can tell the frontend which shields to check for a specific user.\n     */\n    event Mint(address indexed rcaShield, address indexed user, uint256 timestamp);\n    event RedeemRequest(address indexed rcaShield, address indexed user, uint256 timestamp);\n    event RedeemFinalize(address indexed rcaShield, address indexed user, uint256 timestamp);\n    event Purchase(address indexed rcaShield, address indexed user, uint256 timestamp);\n    event ShieldCreated(\n        address indexed rcaShield,\n        address indexed underlyingToken,\n        string name,\n        string symbol,\n        uint256 timestamp\n    );\n    event ShieldCancelled(address indexed rcaShield);\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////// modifiers //////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Ensure the sender is a shield.\n     * @dev We don't want non-shield contracts creating mint, redeem, purchase events.\n     */\n    modifier onlyShield() {\n        require(shieldMapping[msg.sender], \"Caller must be a Shield Vault.\");\n        _;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////// constructor /////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Construct with initial privileged addresses for controller.\n     * @param _governor Complete control of the contracts. Can change all other owners.\n     * @param _guardian Guardian multisig that can freeze percents after a hack.\n     * @param _priceOracle Oracle that can submit price root to the ecosystem.\n     * @param _capOracle Oracle that can submit capacity root to the ecosystem.\n     * @param _apr Initial fees for the shield (1000 == 10%).\n     * @param _discount Discount for purchasers of the token (1000 == 10%).\n     * @param _withdrawalDelay Amount of time (in seconds) users must wait before withdrawing.\n     * @param _treasury Address of the treasury that Ether funds will be sent to.\n     */\n    constructor(\n        address _governor,\n        address _guardian,\n        address _priceOracle,\n        address _capOracle,\n        uint256 _apr,\n        uint256 _discount,\n        uint256 _withdrawalDelay,\n        address payable _treasury\n    ) {\n        initRcaGovernable(_governor, _guardian, _capOracle, _priceOracle);\n\n        apr = _apr;\n        discount = _discount;\n        treasury = _treasury;\n        withdrawalDelay = _withdrawalDelay;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////// onlyShield /////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Updates contract, emits event for minting, checks capacity.\n     * @param _user User that is minting tokens.\n     * @param _uAmount Underlying token amount being liquidated.\n     * @param _expiry Time (Unix timestamp) that this request expires.\n     * @param _v The recovery byte of the signature.\n     * @param _r Half of the ECDSA signature pair.\n     * @param _s Half of the ECDSA signature pair.\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\n     */\n    function mint(\n        address _user,\n        uint256 _uAmount,\n        uint256 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        uint256 _newCumLiqForClaims,\n        bytes32[] calldata _liqForClaimsProof\n    ) external onlyShield {\n        _update(_newCumLiqForClaims, _liqForClaimsProof, 0, new bytes32[](0), false);\n\n        // Confirm the capacity oracle approved this transaction.\n        verifyCapacitySig(_user, _uAmount, _expiry, _v, _r, _s);\n\n        emit Mint(msg.sender, _user, block.timestamp);\n    }\n\n    /**\n     * @notice Updates contract, emits event for redeem action.\n     * @param _user User that is redeeming tokens.\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\n     * @param _newPercentReserved New percent of the shield that is reserved for hack payouts.\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\n     */\n    function redeemRequest(\n        address _user,\n        uint256 _newCumLiqForClaims,\n        bytes32[] calldata _liqForClaimsProof,\n        uint256 _newPercentReserved,\n        bytes32[] calldata _percentReservedProof\n    ) external onlyShield {\n        _update(_newCumLiqForClaims, _liqForClaimsProof, _newPercentReserved, _percentReservedProof, true);\n\n        emit RedeemRequest(msg.sender, _user, block.timestamp);\n    }\n\n    /**\n     * @notice Updates contract, emits event for redeem action, returns if router is verified.\n     * @param _user User that is redeeming tokens.\n     * @param _to Router address which should be used for zapping.\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\n     * @param _newPercentReserved New percent of the shield that is reserved for hack payouts.\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\n     */\n    function redeemFinalize(\n        address _user,\n        address _to,\n        uint256 _newCumLiqForClaims,\n        bytes32[] calldata _liqForClaimsProof,\n        uint256 _newPercentReserved,\n        bytes32[] calldata _percentReservedProof\n    ) external onlyShield returns (bool) {\n        _update(_newCumLiqForClaims, _liqForClaimsProof, _newPercentReserved, _percentReservedProof, true);\n\n        emit RedeemFinalize(msg.sender, _user, block.timestamp);\n        return isRouterVerified[_to];\n    }\n\n    /**\n     * @notice Updates contract, emits event for purchase action, verifies price.\n     * @param _user The user that is making the purchase.\n     * @param _uToken The user that is making the purchase.\n     * @param _ethPrice The price of one token in Ether.\n     * @param _priceProof Merkle proof to verify the Ether price of the token.\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\n     */\n    function purchase(\n        address _user,\n        address _uToken,\n        uint256 _ethPrice,\n        bytes32[] calldata _priceProof,\n        uint256 _newCumLiqForClaims,\n        bytes32[] calldata _liqForClaimsProof\n    ) external onlyShield {\n        _update(_newCumLiqForClaims, _liqForClaimsProof, 0, new bytes32[](0), false);\n\n        verifyPrice(_uToken, _ethPrice, _priceProof);\n        emit Purchase(msg.sender, _user, block.timestamp);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////// internal //////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice All general updating of shields for a variety of variables that could have changed\n     * since the last interaction. Amount for sale, whether or not the system is paused, new\n     * withdrawal delay, new discount for sales, new APR fee for general functionality.\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\n     * @param _newPercentReserved New percent of tokens of this shield that are reserved.\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\n     * @param _redeem Whether or not this is a redeem request to know whether to update reserved.\n     */\n    function _update(\n        uint256 _newCumLiqForClaims,\n        bytes32[] memory _liqForClaimsProof,\n        uint256 _newPercentReserved,\n        bytes32[] memory _percentReservedProof,\n        bool _redeem\n    ) internal {\n        IRcaShield shield = IRcaShield(msg.sender);\n        uint32 lastUpdate = uint32(lastShieldUpdate[msg.sender]);\n\n        // Seems kinda messy but not too bad on gas.\n        SystemUpdates memory updates = systemUpdates;\n\n        if (lastUpdate <= updates.treasuryUpdate) shield.setTreasury(treasury);\n        if (lastUpdate <= updates.discountUpdate) shield.setDiscount(discount);\n        if (lastUpdate <= updates.withdrawalDelayUpdate) shield.setWithdrawalDelay(withdrawalDelay);\n        // Update shield here to account for interim period where APR was changed but shield had not updated.\n        if (lastUpdate <= updates.aprUpdate) {\n            shield.controllerUpdate(apr, uint256(updates.aprUpdate));\n            shield.setApr(apr);\n        }\n        if (lastUpdate <= updates.liqUpdate) {\n            // Update potentially needed here as well if amtForSale will grow from APR.\n            shield.controllerUpdate(apr, uint256(updates.aprUpdate));\n            \n            verifyLiq(msg.sender, _newCumLiqForClaims, _liqForClaimsProof);\n            shield.setLiqForClaims(_newCumLiqForClaims);\n        }\n        // Only updates if it's a redeem request (which is the only call that's affected by reserved).\n        if (lastUpdate <= updates.reservedUpdate && _redeem) {\n            verifyReserved(msg.sender, _newPercentReserved, _percentReservedProof);\n            shield.setPercentReserved(_newPercentReserved);\n        }\n\n        lastShieldUpdate[msg.sender] = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Verify the signature approving the transaction.\n     * @param _user User that is being minted to.\n     * @param _amount Amount of underlying tokens being deposited.\n     * @param _expiry Time (Unix timestamp) that this request expires.\n     * @param _v The recovery byte of the signature.\n     * @param _r Half of the ECDSA signature pair.\n     * @param _s Half of the ECDSA signature pair.\n     */\n    function verifyCapacitySig(\n        address _user,\n        uint256 _amount,\n        uint256 _expiry,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) internal {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"EASE_RCA_CONTROLLER_1.0\",\n                block.chainid,\n                address(this),\n                _user,\n                msg.sender,\n                _amount,\n                nonces[_user]++,\n                _expiry\n            )\n        );\n        bytes32 message = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", digest));\n        address signatory = ecrecover(message, _v, _r, _s);\n\n        require(signatory == capOracle, \"Invalid capacity oracle signature.\");\n        require(block.timestamp <= _expiry, \"Capacity permission has expired.\");\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////// view ////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Verify the current amount for liquidation.\n     * @param _shield Address of the shield to verify.\n     * @param _newCumLiqForClaims New cumulative amount liquidated.\n     * @param _liqForClaimsProof Proof of the for sale amounts.\n     */\n    function verifyLiq(\n        address _shield,\n        uint256 _newCumLiqForClaims,\n        bytes32[] memory _liqForClaimsProof\n    ) public view {\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _newCumLiqForClaims));\n        require(MerkleProof.verify(_liqForClaimsProof, liqForClaimsRoot, leaf), \"Incorrect liq proof.\");\n    }\n\n    /**\n     * @notice Verify price from Ease price oracle.\n     * @param _shield Address of the shield to find price of.\n     * @param _value Price of the underlying token (in Ether) for this shield.\n     * @param _proof Merkle proof.\n     */\n    function verifyPrice(\n        address _shield,\n        uint256 _value,\n        bytes32[] memory _proof\n    ) public view {\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _value));\n        // This doesn't protect against oracle hacks, but does protect against some bugs.\n        require(_value > 0, \"Invalid price submitted.\");\n        require(MerkleProof.verify(_proof, priceRoot, leaf), \"Incorrect price proof.\");\n    }\n\n    /**\n     * @notice Verify the percent reserved for a particular shield.\n     * @param _shield Address of the shield/token to verify reserved.\n     * @param _percentReserved Percent of shield that's reserved. 10% == 1000.\n     * @param _proof The Merkle proof verifying the percent reserved.\n     */\n    function verifyReserved(\n        address _shield,\n        uint256 _percentReserved,\n        bytes32[] memory _proof\n    ) public view {\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _percentReserved));\n        require(MerkleProof.verify(_proof, reservedRoot, leaf), \"Incorrect capacity proof.\");\n    }\n\n    /**\n     * @notice Makes it easier for frontend to get the balances on many shields.\n     * @param _user User to find balances of.\n     * @param _tokens The shields (also tokens) to find the RCA balances for.\n     */\n    function balanceOfs(address _user, address[] calldata _tokens) external view returns (uint256[] memory balances) {\n        balances = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 balance = IERC20(_tokens[i]).balanceOf(_user);\n            balances[i] = balance;\n        }\n    }\n\n    /**\n     * @notice Makes it easier for frontend to get the currently withdrawing requests for each shield.\n     * @param _user User to find requests of.\n     * @param _shields The shields to find the request data for.\n     */\n    function requestOfs(\n        address _user, \n        address[] calldata _shields\n    ) external view returns (IRcaShield.WithdrawRequest[] memory requests) {\n        requests = new IRcaShield.WithdrawRequest[](_shields.length);\n\n        for (uint256 i = 0; i < _shields.length; i++) {\n            IRcaShield.WithdrawRequest memory request = IRcaShield(_shields[i]).withdrawRequests(_user);\n            requests[i] = request;\n        }\n    }\n\n    /**\n     * @notice Used by frontend to craft signature for a requested transaction.\n     * @param _user User that is being minted to.\n     * @param _shield Address of the shield that tokens are being deposited into.\n     * @param _amount Amount of underlying tokens to deposit.\n     * @param _nonce User nonce (current nonce +1) that this transaction will be.\n     * @param _expiry Time (Unix timestamp) that this request will expire.\n     */\n    function getMessageHash(\n        address _user,\n        address _shield,\n        uint256 _amount,\n        uint256 _nonce,\n        uint256 _expiry\n    ) external view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"EASE_RCA_CONTROLLER_1.0\",\n                    block.chainid,\n                    address(this),\n                    _user,\n                    _shield,\n                    _amount,\n                    _nonce,\n                    _expiry\n                )\n            );\n    }\n\n    function getAprUpdate() external view returns (uint32) {\n        return systemUpdates.aprUpdate;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////// onlyGov //////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Initialize a new shield.\n     * @param _shield Address of the shield to initialize.\n     */\n    function initializeShield(address _shield) external onlyGov {\n        IRcaShield(_shield).initialize(apr, discount, treasury, withdrawalDelay);\n\n        shieldMapping[_shield] = true;\n        activeShields[_shield] = true;\n        lastShieldUpdate[_shield] = block.timestamp;\n\n        emit ShieldCreated(\n            _shield,\n            address(IRcaShield(_shield).uToken()),\n            IRcaShield(_shield).name(),\n            IRcaShield(_shield).symbol(),\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Governance calls to set the new total amount for sale.\n     * @param _newLiqRoot Merkle root for new total amounts for sale for each protocol (in token).\n     * @param _newReservedRoot Reserved root setting all percent reserved back to 0.\n     */\n    function setLiqTotal(bytes32 _newLiqRoot, bytes32 _newReservedRoot) external onlyGov {\n        liqForClaimsRoot = _newLiqRoot;\n        systemUpdates.liqUpdate = uint32(block.timestamp);\n        reservedRoot = _newReservedRoot;\n        systemUpdates.reservedUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Governance can reset withdrawal delay for amount of time it takes to withdraw from vaults.\n     * Not a commonly used function, if at all really.\n     * @param _newWithdrawalDelay New delay (in seconds) for withdrawals.\n     */\n    function setWithdrawalDelay(uint256 _newWithdrawalDelay) external onlyGov {\n        require(_newWithdrawalDelay <= 86400 * 7, \"Withdrawal delay may not be more than 7 days.\");\n        withdrawalDelay = _newWithdrawalDelay;\n        systemUpdates.withdrawalDelayUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Governance can change the amount of discount for purchasing tokens that are being liquidated.\n     * @param _newDiscount New discount for purchase in tenths of a percent (1000 == 10%).\n     */\n    function setDiscount(uint256 _newDiscount) external onlyGov {\n        require(_newDiscount <= 2500, \"Discount may not be more than 25%.\");\n        discount = _newDiscount;\n        systemUpdates.discountUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Governance can set the fees taken per year from a vault. Starts at 0, can update at any time.\n     * @param _newApr New fees per year for being in the RCA system (1000 == 10%).\n     */\n    function setApr(uint256 _newApr) external onlyGov {\n        require(_newApr <= 2000, \"APR may not be more than 20%.\");\n        apr = _newApr;\n        systemUpdates.aprUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Governance can set address of the new treasury contract that accepts funds.\n     * @param _newTreasury New fees per year for being in the RCA system (1000 == 10%).\n     */\n    function setTreasury(address payable _newTreasury) external onlyGov {\n        treasury = _newTreasury;\n        systemUpdates.treasuryUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Governance can cancel the shield support.\n     * @param _shields An array of shield addresses that are being cancelled.\n     */\n    function cancelShield(address[] memory _shields) external onlyGov {\n        for (uint256 i = 0; i < _shields.length; i++) {\n            activeShields[_shields[i]] = false;\n            emit ShieldCancelled(_shields[i]);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////// onlyGuardian ///////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Admin can set the percent paused. This pauses this percent of tokens from each shield\n     * while the DAO analyzes losses. If a withdrawal occurs while reserved > 0,\n     * the user will lose this percent of tokens.\n     * @param _newReservedRoot Percent of shields to temporarily pause for each shield. 1000 == 10%.\n     */\n    function setPercentReserved(bytes32 _newReservedRoot) external onlyGuardian {\n        reservedRoot = _newReservedRoot;\n        systemUpdates.reservedUpdate = uint32(block.timestamp);\n    }\n\n    /**\n     * @notice Admin can set which router is verified and which is not.\n     * @param _routerAddress Address of a router.\n     * @param _verified New verified status of the router.\n     */\n    function setRouterVerified(address _routerAddress, bool _verified) external onlyGuardian {\n        isRouterVerified[_routerAddress] = _verified;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////// onlyPriceOracle //////////////////////////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Set prices of all tokens with our oracle. This will likely be expanded so that price oracle is a\n     * smart contract that accepts input from a few sources to increase decentralization.\n     * @param _newPriceRoot Merkle root for new prices of each underlying token in\n     * Ether (key is shield address or token for rewards).\n     */\n    function setPrices(bytes32 _newPriceRoot) external onlyPriceOracle {\n        priceRoot = _newPriceRoot;\n    }\n}\n"
6     },
7     "contracts/general/RcaGovernable.sol": {
8       "content": "/// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\nimport \"../general/Governable.sol\";\n\n/**\n * @title Governable\n * @dev Pretty default ownable but with variable names changed to better convey owner.\n */\ncontract RcaGovernable is Governable {\n    address public guardian;\n    address public priceOracle;\n    address public capOracle;\n\n    event NewGuardian(address indexed oldGuardian, address indexed newGuardian);\n    event NewPriceOracle(address indexed oldOracle, address indexed newOracle);\n    event NewCapOracle(address indexed oldOracle, address indexed newOracle);\n\n    /**\n     * @dev The Ownable constructor sets the original s of the contract to the sender\n     * account.\n     */\n    function initRcaGovernable(\n        address _governor,\n        address _guardian,\n        address _capOracle,\n        address _priceOracle\n    ) internal {\n        require(governor() == address(0), \"already initialized\");\n        initializeGovernable(_governor);\n\n        guardian = _guardian;\n        capOracle = _capOracle;\n        priceOracle = _priceOracle;\n\n        emit NewGuardian(address(0), _guardian);\n        emit NewCapOracle(address(0), _capOracle);\n        emit NewPriceOracle(address(0), _priceOracle);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyGuardian() {\n        require(msg.sender == guardian, \"msg.sender is not Guardian.\");\n        _;\n    }\n\n    modifier onlyPriceOracle() {\n        require(msg.sender == priceOracle, \"msg.sender is not price oracle.\");\n        _;\n    }\n\n    modifier onlyCapOracle() {\n        require(msg.sender == capOracle, \"msg.sender is not capacity oracle.\");\n        _;\n    }\n\n    /**\n     * @notice Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newGuardian The address to transfer ownership to.\n     */\n    function setGuardian(address _newGuardian) public onlyGov {\n        guardian = _newGuardian;\n    }\n\n    function setPriceOracle(address _newPriceOracle) public onlyGov {\n        priceOracle = _newPriceOracle;\n    }\n\n    function setCapOracle(address _newCapOracle) public onlyGov {\n        capOracle = _newCapOracle;\n    }\n\n    uint256[50] private __gap;\n}\n"
9     },
10     "contracts/library/MerkleProof.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
12     },
13     "contracts/interfaces/IRcaShield.sol": {
14       "content": "/// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRcaShield {\n    function setApr(uint256 apr) external;\n\n    function setTreasury(address treasury) external;\n\n    function setDiscount(uint256 discount) external;\n\n    function setLiqForClaims(uint256 addForSale) external;\n\n    function setPercentReserved(uint256 percentPaused) external;\n\n    function setWithdrawalDelay(uint256 withdrawalDelay) external;\n\n    function initialize(\n        uint256 apr,\n        uint256 discount,\n        address treasury,\n        uint256 withdrawalDelay\n    ) external;\n\n    function name() external returns (string calldata);\n\n    function symbol() external returns (string calldata);\n\n    function uToken() external returns (IERC20);\n\n    function controllerUpdate(uint256 apr, uint256 aprUpdate) external;\n\n    struct WithdrawRequest {\n        uint112 uAmount;\n        uint112 rcaAmount;\n        uint32 endTime;\n    }\n\n    function withdrawRequests(address user) external view returns (WithdrawRequest memory);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
18     },
19     "contracts/general/Governable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\n/**\n * @title Governable\n * @dev Pretty default ownable but with variable names changed to better convey owner.\n */\ncontract Governable {\n    address payable private _governor;\n    address payable private _pendingGovernor;\n\n    event OwnershipTransferred(address indexed previousGovernor, address indexed newGovernor);\n    event PendingOwnershipTransfer(address indexed from, address indexed to);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initializeGovernable(address _newGovernor) internal {\n        require(_governor == address(0), \"already initialized\");\n        _governor = payable(_newGovernor);\n        emit OwnershipTransferred(address(0), _newGovernor);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function governor() public view returns (address payable) {\n        return _governor;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyGov() {\n        require(isGov(), \"msg.sender is not owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isGov() public view returns (bool) {\n        return msg.sender == _governor;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newGovernor The address to transfer ownership to.\n     */\n    function transferOwnership(address payable newGovernor) public onlyGov {\n        _pendingGovernor = newGovernor;\n        emit PendingOwnershipTransfer(_governor, newGovernor);\n    }\n\n    function receiveOwnership() public {\n        require(msg.sender == _pendingGovernor, \"Only pending governor can call this function\");\n        _transferOwnership(_pendingGovernor);\n        _pendingGovernor = payable(address(0));\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newGovernor The address to transfer ownership to.\n     */\n    function _transferOwnership(address payable newGovernor) internal {\n        require(newGovernor != address(0));\n        emit OwnershipTransferred(_governor, newGovernor);\n        _governor = newGovernor;\n    }\n\n    uint256[50] private __gap;\n}\n"
21     }
22   },
23   "settings": {
24     "metadata": {
25       "bytecodeHash": "none"
26     },
27     "optimizer": {
28       "enabled": true,
29       "runs": 200
30     },
31     "outputSelection": {
32       "*": {
33         "*": [
34           "evm.bytecode",
35           "evm.deployedBytecode",
36           "devdoc",
37           "userdoc",
38           "metadata",
39           "abi"
40         ]
41       }
42     },
43     "libraries": {}
44   }
45 }}