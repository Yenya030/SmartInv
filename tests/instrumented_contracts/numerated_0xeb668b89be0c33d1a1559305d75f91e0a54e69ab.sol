1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/BaseRegistrar.sol": {
5       "content": "pragma solidity >=0.8.4;\n\nimport \"./IBaseRegistrar.sol\";\nimport \"./IPRegistrarController.sol\";\nimport \"./IPTokenRenderer.sol\";\nimport \"./ERC721PTO.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrar is ERC721PTO, IBaseRegistrar, Ownable {\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public immutable baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    \n    IPTokenRenderer public tokenRenderer;\n    IPRegistrarController public registrarController;\n    \n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256(\"balanceOf(address)\") ^\n                keccak256(\"ownerOf(uint256)\") ^\n                keccak256(\"approve(address,uint256)\") ^\n                keccak256(\"getApproved(uint256)\") ^\n                keccak256(\"setApprovalForAll(address,bool)\") ^\n                keccak256(\"isApprovedForAll(address,address)\") ^\n                keccak256(\"transferFrom(address,address,uint256)\") ^\n                keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n                keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    function setENS(ENS _ens) public onlyOwner {\n        ens = _ens;\n    }\n    \n    function setRenderer(IPTokenRenderer _renderer) public onlyOwner {\n        tokenRenderer = _renderer;\n    }\n    \n    function setRegistrarController(IPRegistrarController _registrarController) external onlyOwner {\n        registrarController = _registrarController;\n        setOperator(address(_registrarController), true);\n        addController(address(_registrarController));\n    }\n    \n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        override\n        returns (bool)\n    {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n    \n    constructor(ENS _ens, bytes32 _baseNode) ERC721PTO(\"EBPTO: IP Domains\", \"IP\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n    \n    function setTokenRenderer(IPTokenRenderer _tokenRenderer) public onlyOwner {\n        tokenRenderer = _tokenRenderer;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        override(IERC721, ERC721PTO)\n        returns (address)\n    {\n        require(_getExpiryTimestamp(tokenId) > block.timestamp, \"Expiration invalid\");\n        return super.ownerOf(tokenId);\n    }\n    \n    function tokenURI(uint256 tokenId) public view override(ERC721PTO) returns (string memory) {\n        require(_exists(tokenId), \"Doesn't exist\");\n        \n        return tokenRenderer.constructTokenURI(tokenId);\n    }\n    \n    function exists(uint tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) public override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n    \n    function setOperator(address operator, bool status) public onlyOwner {\n        ens.setApprovalForAll(operator, status);\n    }\n    \n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return _getExpiryTimestamp(id);\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it's registered here or in its grace period.\n        return _getExpiryTimestamp(id) + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id), \"Name not available\");\n        \n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n\n        _setExpiryTimestamp(id, uint48(block.timestamp + duration));\n\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint256 duration)\n        external\n        override\n        live\n        onlyController\n        returns (uint256)\n    {\n        uint currentExpiry = _getExpiryTimestamp(id);\n        uint48 newExpiry = uint48(currentExpiry + duration);\n        \n        require(currentExpiry + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n\n        _setExpiryTimestamp(id, newExpiry);\n        emit NameRenewed(id, newExpiry);\n        return newExpiry;\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        override(ERC721PTO, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n    \n    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override(ERC721PTO)\n    {\n        registrarController.beforeTokenTransfer(from, to, tokenId, batchSize);\n        super._beforeTokenTransfer(from, to, tokenId, batchSize);\n    }\n    \n    function _afterTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)\n        internal\n        override(ERC721PTO)\n    {\n        registrarController.afterTokenTransfer(from, to, tokenId, batchSize);\n        super._afterTokenTransfer(from, to, tokenId, batchSize);\n    }\n}"
6     },
7     "contracts/IBaseRegistrar.sol": {
8       "content": "import \"./ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
9     },
10     "contracts/IPRegistrarController.sol": {
11       "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./ENS.sol\";\n\nimport {BaseRegistrar} from \"./BaseRegistrar.sol\";\nimport {PublicResolver} from \"./PublicResolver.sol\";\nimport {ReverseRegistrar} from \"./ReverseRegistrar.sol\";\nimport {IETHRegistrarController, IPriceOracle} from \"@ensdomains/ens-contracts/contracts/ethregistrar/IETHRegistrarController.sol\";\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC20Recoverable} from \"@ensdomains/ens-contracts/contracts/utils/ERC20Recoverable.sol\";\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"solady/src/utils/SafeTransferLib.sol\";\nimport \"./Normalize4.sol\";\nimport \"solady/src/utils/DynamicBufferLib.sol\";\nimport \"solady/src/utils/SSTORE2.sol\";\n\nerror NameNotAvailable(string name);\nerror DurationTooShort(uint256 duration);\nerror InsufficientValue();\n\nimport \"hardhat/console.sol\";\n\ncontract IPRegistrarController is\n    Ownable,\n    IETHRegistrarController,\n    IERC165,\n    ERC20Recoverable,\n    ReentrancyGuard\n{\n    using LibString for *;\n    using Address for *;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeTransferLib for address;\n    using DynamicBufferLib for DynamicBufferLib.DynamicBuffer;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    BaseRegistrar immutable base;\n    IPriceOracle public immutable prices;\n    \n    ENS public immutable ens;\n    address public defaultResolver;\n    ReverseRegistrar public reverseRegistrar;\n    Normalize4 public normalizer;\n    \n    string public constant tldString = 'ip';\n    bytes32 public constant tldLabel = keccak256(abi.encodePacked(tldString));\n    bytes32 public constant rootNode = bytes32(0);\n    bytes32 public immutable tldNode = keccak256(abi.encodePacked(rootNode, tldLabel));\n    \n    mapping (uint => string) public hashToLabelString;\n    \n    uint64 public auctionTimeBuffer = 15 minutes;\n    uint256 public auctionMinBidIncrementPercentage = 10;\n    uint64 public auctionDuration = 24 hours;\n    bool public contractInAuctionMode = true;\n    \n    mapping(uint => Auction) public auctions;\n    EnumerableSet.UintSet activeAuctionIds;\n\n    uint public ethAvailableToWithdraw;\n    address payable public withdrawAddress;\n    \n    address public logoSVG;\n    address[] public fonts;\n    \n    struct Auction {\n        uint tokenId;\n        string name;\n        uint64 startTime;\n        uint64 endTime;\n        Bid[] bids;\n    }\n    \n    struct AuctionInfo {\n        uint tokenId;\n        string name;\n        uint64 startTime;\n        uint64 endTime;\n        Bid[] bids;\n        uint minNextBid;\n        address highestBidder;\n        uint highestBidAMount;\n    }\n    \n    struct Bid {\n        uint80 amount;\n        address bidder;\n    }\n    \n    event AuctionStarted(uint indexed tokenId, uint startTime, uint endTime);\n    event AuctionExtended(uint indexed tokenId, uint endTime);\n    event AuctionBid(uint indexed tokenId, address bidder, uint bidValue, bool auctionExtended);\n    event AuctionSettled(uint indexed tokenId, address winner, uint amount);\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n    \n    event AuctionWithdraw(address indexed addr, uint indexed total);\n    event Withdraw(address indexed addr, uint indexed total);\n    \n    function setDefaultResolver(address _defaultResolver) public onlyOwner {\n        defaultResolver = _defaultResolver;\n    }\n    \n    function setReverseRegistrar(ReverseRegistrar _reverseRegistrar) public onlyOwner {\n        reverseRegistrar = _reverseRegistrar;\n    }\n    \n    function setNormalizer(Normalize4 _normalizer) public onlyOwner {\n        normalizer = _normalizer;\n    }\n    \n    function setAuctionTimeBuffer(uint64 _auctionTimeBuffer) public onlyOwner {\n        auctionTimeBuffer = _auctionTimeBuffer;\n    }\n    \n    function setAuctionMinBidIncrementPercentage(uint256 _auctionMinBidIncrementPercentage) public onlyOwner {\n        auctionMinBidIncrementPercentage = _auctionMinBidIncrementPercentage;\n    }\n    \n    function setAuctionDuration(uint64 _auctionDuration) public onlyOwner {\n        auctionDuration = _auctionDuration;\n    }\n    \n    function setContractInAuctionMode(bool _contractInAuctionMode) public onlyOwner {\n        contractInAuctionMode = _contractInAuctionMode;\n    }\n    \n    function setWithdrawAddress(address _withdrawAddress) public onlyOwner {\n        withdrawAddress = payable(_withdrawAddress);\n    }\n    \n    modifier onlyBaseRegistrar() {\n        require(msg.sender == address(base), \"Only base registrar\");\n        _;\n    }\n\n    constructor(\n        ENS _ens,\n        BaseRegistrar _base,\n        IPriceOracle _prices,\n        ReverseRegistrar _reverseRegistrar,\n        Normalize4 _normalizer,\n        string memory _logoSVG,\n        string[5] memory _fonts\n    ) {\n        ens = _ens;\n        base = _base;\n        prices = _prices;\n        reverseRegistrar = _reverseRegistrar;\n        normalizer = _normalizer;\n        \n        setLogoSVG(_logoSVG);\n        setFonts(_fonts);\n    }\n    \n    bool preRegisterDone;\n    function preRegisterNames(\n        string[] calldata names,\n        bytes[][] calldata data,\n        address owner\n    ) external onlyOwner {\n        require(!preRegisterDone);\n        \n        for (uint i; i < names.length; ++i) {\n            _registerWithoutCommitment(\n                names[i],\n                owner,\n                365 days,\n                address(0),\n                data[0],\n                false,\n                0,\n                0\n            );\n        }\n        \n        preRegisterDone = true;\n    }\n    \n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public view returns (bool) {\n        if (bytes(name).length == 0) return false;\n        \n        try normalizer.normalize(name) returns (string[] memory _norm) {\n            if (!(name.eq(_norm[0]) && _norm.length == 1)) return false;\n        } catch {\n            return false;\n        }\n        \n        return true;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        return registerWithoutCommitment(\n            name,\n            owner,\n            duration,\n            resolver,\n            data,\n            reverseRecord\n        );\n    }\n    \n    function auctionMinNextBid(uint currentHighestBid) public view returns (uint) {\n        return currentHighestBid + (currentHighestBid * auctionMinBidIncrementPercentage / 100);\n    }\n    \n    function max(uint a, uint b) internal pure returns (uint) {\n        return a > b ? a : b;\n    }\n    \n    function auctionHighestBid(uint tokenId) public view returns (Bid memory) {\n        Auction storage auction = auctions[tokenId];\n        if (auction.bids.length == 0) {\n            return Bid({amount: 0, bidder: address(0)});\n        }\n        return auction.bids[auction.bids.length - 1];\n    }\n    \n    function getAuction(string memory name) public view returns (AuctionInfo memory) {\n        uint256 tokenId = uint256(keccak256(bytes(name)));\n\n        Auction memory auction = auctions[tokenId];\n        Bid memory highestBid = auctionHighestBid(tokenId);\n        \n        uint reservePrice = (rentPrice(name, 365 days)).base;\n        uint minNextBid = max(auctionMinNextBid(highestBid.amount), reservePrice);\n        \n        return AuctionInfo({\n            tokenId: tokenId,\n            name: name,\n            startTime: auction.startTime,\n            endTime: auction.endTime,\n            bids: auction.bids,\n            minNextBid: minNextBid,\n            highestBidder: highestBid.bidder,\n            highestBidAMount: highestBid.amount\n        });\n    }\n    \n    function bidOnName(string calldata name) external payable nonReentrant returns (bool success) {\n        uint256 tokenId = uint256(keccak256(bytes(name)));\n\n        Auction storage auction = auctions[tokenId];\n        Bid memory highestBid = auctionHighestBid(tokenId);\n        \n        require(contractInAuctionMode, \"Contract not in auction mode\");\n        require(msg.value < type(uint80).max, \"Out of range\");\n        require(msg.value >= auctionMinNextBid(highestBid.amount), 'Must send at least min increment');\n        \n        require(auction.endTime == 0 || block.timestamp < auction.endTime, \"Auction ended\");\n        \n        if (auction.startTime == 0) {\n            uint reservePrice = (rentPrice(name, 365 days)).base;\n            require(msg.value >= reservePrice, 'Must send at least reservePrice');\n            require(available(name), \"Not available\");\n            \n            auction.startTime = uint64(block.timestamp);\n            auction.endTime = uint64(block.timestamp + auctionDuration);\n            auction.tokenId = tokenId;\n            auction.name = name;\n            \n            activeAuctionIds.add(tokenId);\n            emit AuctionStarted(tokenId, auction.startTime, auction.endTime);\n        }\n        \n        if (highestBid.bidder != address(0)) {\n            highestBid.bidder.forceSafeTransferETH(highestBid.amount);\n        }\n        \n        Bid memory newBid = Bid({\n            amount: uint80(msg.value),\n            bidder: msg.sender\n        });\n        \n        auction.bids.push(newBid);\n        \n        bool extendAuction = auction.endTime - block.timestamp < auctionTimeBuffer;\n        if (extendAuction) {\n            auction.endTime = uint64(block.timestamp + auctionTimeBuffer);\n            emit AuctionExtended(tokenId, auction.endTime);\n        }\n\n        emit AuctionBid(tokenId, newBid.bidder, newBid.amount, extendAuction);\n        \n        return true;\n    }\n    \n    function settleAuction(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord\n    ) external nonReentrant {\n        uint tokenId = uint256(keccak256(bytes(name)));\n        Auction memory auction = auctions[tokenId];\n        Bid memory highestBid = auctionHighestBid(tokenId);\n\n        require(owner == highestBid.bidder, \"Only highest bidder\");\n        require(duration == 365 days, \"Must be 365 days\");\n        require(auction.startTime != 0, \"Auction hasn't begun\");\n        require(block.timestamp >= auction.endTime, \"Auction hasn't completed\");\n        \n        _registerWithoutCommitment(\n            name,\n            owner,\n            duration,\n            resolver,\n            data,\n            reverseRecord,\n            highestBid.amount,\n            0\n        );\n        \n        ethAvailableToWithdraw += highestBid.amount;\n        activeAuctionIds.remove(tokenId);\n        \n        emit AuctionSettled(tokenId, highestBid.bidder, highestBid.amount);\n    }\n    \n    function registerWithoutCommitment(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord\n    ) public payable nonReentrant {\n        require(!contractInAuctionMode, \"Contract in auction mode\");\n        \n        uint tokenId = uint256(keccak256(bytes(name)));\n        require(!activeAuctionIds.contains(tokenId), \"Name in auction\");\n        \n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        \n        if (msg.value < price.base + price.premium) revert InsufficientValue();\n        if (duration < MIN_REGISTRATION_DURATION) revert DurationTooShort(duration);\n\n        _registerWithoutCommitment(\n            name,\n            owner,\n            duration,\n            resolver,\n            data,\n            reverseRecord,\n            price.base,\n            price.premium\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            msg.sender.forceSafeTransferETH(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n    \n    function _registerWithoutCommitment(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint basePrice,\n        uint pricePremium\n    ) internal {\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n        uint256 tokenId = uint256(keccak256(bytes(name)));\n        \n        uint256 expires = base.registerOnly(tokenId, owner, duration);\n        if (resolver == address(0)) {\n            resolver = defaultResolver;\n        }\n        \n        ens.setSubnodeRecord(tldNode, bytes32(tokenId), owner, resolver, 0);\n        bytes32 node = _makeNode(tldNode, keccak256(bytes(name)));\n        \n        PublicResolver(resolver).setAddr(node, owner);\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord && msg.sender == owner) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n        \n        hashToLabelString[tokenId] = name;\n        \n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            basePrice,\n            pricePremium,\n            expires\n        );\n    }\n\n    function renew(string calldata name, uint256 duration) external payable override nonReentrant {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires;\n        expires = base.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            msg.sender.forceSafeTransferETH(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n    \n    function auctionWithdraw() external nonReentrant {\n        require(contractInAuctionMode, \"Contract not in auction mode\");\n        require(ethAvailableToWithdraw > 0, \"Nothing to withdraw\");\n        require(withdrawAddress != address(0), \"Withdraw address not set\");\n        \n        uint balance = ethAvailableToWithdraw;\n        ethAvailableToWithdraw = 0;\n        \n        withdrawAddress.sendValue(balance);\n        emit AuctionWithdraw(withdrawAddress, balance);\n    }\n    \n    function withdraw() external nonReentrant onlyOwner {\n        uint balance = address(this).balance;\n        require(balance > 0, \"Nothing to withdraw\");\n        \n        withdrawAddress.sendValue(balance);\n        emit Withdraw(withdrawAddress, balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n    \n    function beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256\n    ) external onlyBaseRegistrar {}\n    \n    function afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256\n    ) external onlyBaseRegistrar {\n        if (from == address(0) || to == address(0)) return;\n        \n        ens.setSubnodeOwner(tldNode, bytes32(tokenId), to);\n    }\n    \n    function getAllActiveAuctions() external view returns (AuctionInfo[] memory) {\n        return getActiveAuctionsInBatches(0, activeAuctionIds.length());\n    }\n    \n    function getActiveAuctionsInBatches(uint batchIdx, uint batchSize) public view returns (AuctionInfo[] memory) {\n        uint auctionCount = activeAuctionIds.length();\n        uint startIdx = batchIdx * batchSize;\n        uint endIdx = startIdx + batchSize;\n        if (endIdx > auctionCount) {\n            endIdx = auctionCount;\n        }\n        AuctionInfo[] memory ret = new AuctionInfo[](endIdx - startIdx);\n        \n        for (uint i = startIdx; i < endIdx; ++i) {\n            Auction memory auction = auctions[activeAuctionIds.at(i)];\n            string memory name = auction.name;\n            ret[i - startIdx] = getAuction(name);\n        }\n        return ret;\n    }\n\n    /* Internal functions */\n    \n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        bytes32 nodehash = keccak256(abi.encodePacked(tldNode, label));\n        PublicResolver resolver = PublicResolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".\", tldString)\n        );\n    }\n    \n    function _makeNode(bytes32 node, bytes32 labelhash)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(node, labelhash));\n    }\n    \n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        revert(\"No commitment required, call register() directly\");\n    }\n\n    function commit(bytes32 commitment) public override {\n        revert(\"No commitment required, call register() directly\");\n    }\n    \n   function allFonts() public view returns (string memory) {\n        DynamicBufferLib.DynamicBuffer memory fontData;\n        \n        for (uint i = 0; i < fonts.length; i++) {\n            fontData.append(SSTORE2.read(fonts[i]));\n        }\n        \n        return string(fontData.data);\n    }\n    \n    function setFonts(string[5] memory _fonts) public onlyOwner {\n        for (uint i = 0; i < _fonts.length; i++) {\n            fonts.push(SSTORE2.write(bytes(_fonts[i])));\n        }\n    }\n    \n    function setLogoSVG(string memory _logoSVG) public onlyOwner {\n        logoSVG = SSTORE2.write(bytes(_logoSVG));\n    }\n}\n"
12     },
13     "contracts/IPTokenRenderer.sol": {
14       "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\nimport \"./PublicResolver.sol\";\nimport \"./IPRegistrarController.sol\";\nimport \"solady/src/utils/Base64.sol\";\nimport \"solady/src/utils/DynamicBufferLib.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"solady/src/utils/SSTORE2.sol\";\n\nimport \"./BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract IPTokenRenderer is Ownable {\n    using DynamicBufferLib for DynamicBufferLib.DynamicBuffer;\n    using LibString for *;\n    \n    IPRegistrarController public immutable controller;\n    BaseRegistrar public immutable base;\n    \n    string public tokenImageBaseUrl = \"https://token-image.vercel.app/api\";\n    string public tokenBackgroundImageBaseURL = \"https://ipfs.io/ipfs/\";\n    \n    ENS public ethEns = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n    ReverseRegistrar public ethReverseResolver;\n    \n    function addressToEthName(address addr) public view returns (string memory) {\n        bytes32 node = ethReverseResolver.node(addr);\n        address resolverAddr = ethEns.resolver(node);\n        \n        if (resolverAddr == address(0)) return addr.toHexStringChecksumed();\n        \n        string memory name = PublicResolver(resolverAddr).name(node);\n        \n        bytes32 tldNode = keccak256(abi.encodePacked(bytes32(0), keccak256(bytes(\"eth\"))));\n        \n        bytes32 forwardNode = controller._makeNode(tldNode, keccak256(bytes(name.split(\".\")[0])));\n        \n        address forwardResolver = ethEns.resolver(forwardNode);\n        \n        if (forwardResolver == address(0)) return addr.toHexStringChecksumed();\n        \n        address resolved = PublicResolver(forwardResolver).addr(forwardNode);\n        \n        if (resolved == addr) {\n            return name;\n        } else {\n            return addr.toHexStringChecksumed();\n        }\n    }\n\n    constructor(\n        BaseRegistrar _base,\n        IPRegistrarController _controller\n    ) {\n        base = _base;\n        controller = _controller;\n        \n        address reverseEthRegAddress = block.chainid == 5 ?\n            0xD5610A08E370051a01fdfe4bB3ddf5270af1aA48 :\n            0x084b1c3C81545d370f3634392De611CaaBFf8148;\n            \n        ethReverseResolver = ReverseRegistrar(reverseEthRegAddress);\n    }\n    \n    function setTokenImageBaseUrl(string calldata _tokenImageBaseUrl) public onlyOwner {\n        tokenImageBaseUrl = _tokenImageBaseUrl;\n    }\n    \n    function setTokenBackgroundImageBaseURL(string calldata _tokenBackgroundImageBaseURL) public onlyOwner {\n        tokenBackgroundImageBaseURL = _tokenBackgroundImageBaseURL;\n    }\n    \n    function stringIsASCII(string memory str) public pure returns (bool) {\n        return bytes(str).length == str.runeCount();\n    }\n    \n    function getAvatarTextRecord(uint tokenId) public view returns (string memory) {\n        bytes32 node = keccak256(abi.encodePacked(controller.tldNode(), bytes32(tokenId)));\n        \n        TextResolver resolver = TextResolver(ENS(controller.ens()).resolver(node));\n        return resolver.text(node, \"avatar\");\n    }\n    \n    function getNode(uint tokenId) public view returns (bytes32) {\n        return keccak256(abi.encodePacked(controller.tldNode(), bytes32(tokenId)));\n    }\n    \n    function tokenImageURL(uint tokenId) public view returns (string memory) {\n        return string(abi.encodePacked(\n            tokenImageBaseUrl,\n            \"?id=\", tokenId.toString(),\n            \"&address=\", address(this).toHexString(),\n            \"&chainId=\", block.chainid.toString()\n            ));\n    }\n    \n    function constructTokenURI(uint tokenId) external view returns (string memory) {\n        require(base.exists(tokenId), \"Doesn't exist\");\n\n        string memory html = tokenHTMLPage(tokenId);\n        string memory labelString = controller.hashToLabelString(tokenId);\n        \n        bool isAscii = stringIsASCII(labelString);\n        \n        string memory w1 = isAscii ? \"\" : unicode\" ⚠️\";\n        \n        string memory w2 = isAscii ? \"\" : unicode\" ⚠️This name contains non-ASCII characters\";\n        \n        string memory tokenDescription = string.concat(\n            \"The IP Domain \", labelString, \".ip.\", w2\n        );\n        \n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        bytes(\n                            abi.encodePacked(\n                                '{',\n                                '\"name\":\"', string.concat(labelString, \".ip\", w1).escapeJSON(), '\",'\n                                '\"description\":\"', tokenDescription.escapeJSON(), '\",'\n                                '\"image\":\"', tokenImageURL(tokenId), '\",'\n                                '\"owner\":\"', base.ownerOf(tokenId).toHexStringChecksumed(), '\",'\n                                '\"animation_url\":\"data:text/html;charset=utf-8;base64,', Base64.encode(bytes(html)), '\",'\n                                '\"attributes\": ', tokenAttributesAsJSON(tokenId),\n                                '}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n    \n    function tokenAttributesAsJSON(uint tokenId) public view returns (string memory) {\n        require(base.exists(tokenId), \"Doesn't exist\");\n        \n        uint nameLength = controller.hashToLabelString(tokenId).runeCount();\n        uint expirationTimestamp = base.nameExpires(tokenId);\n        uint registeredAsOf = base.getLastTransferTimestamp(tokenId);\n        \n        address owner = base.ownerOf(tokenId);\n        string memory ownerString = addressToEthName(owner);\n\n        return string(abi.encodePacked(\n            '[',\n            '{\"display_type\": \"date\", \"trait_type\": \"Expiration Date\", \"value\":', expirationTimestamp.toString(), '},'\n            '{\"display_type\": \"date\", \"trait_type\": \"Registered As Of\", \"value\":', registeredAsOf.toString(), '},'\n            '{\"trait_type\": \"Registered To\", \"value\":\"', ownerString.escapeJSON(), '\"},'\n            '{\"display_type\": \"number\", \"trait_type\":\"Length\", \"value\":', nameLength.toString(), '}'\n            ']'\n        ));\n    }\n    \n    function tokenHTMLPage(uint tokenId) public view returns (string memory) {\n        DynamicBufferLib.DynamicBuffer memory HTMLBytes;\n        \n        string memory label = controller.hashToLabelString(tokenId);\n        uint lastTransferTime = base.getLastTransferTimestamp(tokenId);\n        address owner = base.ownerOf(tokenId);\n        \n        string memory bg = bytes(getAvatarTextRecord(tokenId)).length > 0\n            ? string.concat(\"url(\", tokenBackgroundImageBaseURL, getAvatarTextRecord(tokenId).escapeHTML(), \")\") :\n            \"linear-gradient(135deg, #00728C 0%, #009CA3 50%, #00A695 100%);\";\n        \n        string memory overlay = bytes(getAvatarTextRecord(tokenId)).length > 0 ? '<div style=\"width: 100%; height: 100%; position: fixed; top:0; left: 0; background:rgba(0,0,0,.2)\"></div>' : \"\";\n        \n        string memory ownerString = addressToEthName(owner);\n        \n        HTMLBytes.append('<!DOCTYPE html><html lang=\"en\">');\n        HTMLBytes.append('<head><meta charset=\"utf-8\" /><meta name=\"viewport\" content=\"width=device-width,minimal-ui,viewport-fit=cover,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no\"/></head>');\n        HTMLBytes.append(abi.encodePacked('<body><div style=\"background:', bg, ';background-size: cover;color:#fff;left: 50%;top: 50%;transform: translate(-50%, -50%);position: fixed;aspect-ratio: 1 / 1;max-width: 100vmin;max-height: 100vmin;width: 100%; height: 100%;display:flex;flex-direction:column; justify-content: center; align-items:center;box-sizing:border-box\"><style>*{box-sizing:border-box;margin:0;padding:0;border:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;overflow-wrap:break-word;overflow:hidden; word-break:break-all;user-select: none;text-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);}'\n        ,controller.allFonts(),\n        '</style>', overlay, '<div style=\"width:84%; height:84%; top:0;left:0; z-index: 10000; display:flex; flex-direction: column; justify-content:space-between\"><div style=\"font-size:3.6vw; line-height: 1.3;  letter-spacing: -0.03em;font-family: SatoshiBlack, sans-serif; display: flex; flex-direction:column;\">',\n        SSTORE2.read(controller.logoSVG()),\n        '<div style=\"margin-top:2vh\">Registered to:</div>'\n        '<div style=\"font-family: SatoshiBold;font-size: 3.4vw; line-height: 1.3\">',  ownerString.escapeHTML(), '</div>'\n        '<div style=\"font-family: SatoshiBold; font-size: 3.4vw; line-height: 1.3\">as of ', timestampToString(lastTransferTime),' UTC</div>'\n        '</div>'\n        '<div style=\"font-size:11vw; letter-spacing: -0.03em;line-height:1.2; display: flex; align-items:center; font-family: SatoshiBlack\">', label.escapeHTML(), '.ip</div>'\n        '</div></div>'));\n        \n        HTMLBytes.append('</body></html>');\n\n        return string(HTMLBytes.data);\n    }\n    \n    function timestampToString(uint timestamp) internal pure returns (string memory) {\n        (uint year, uint month, uint day, uint hour, uint minute, uint second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(timestamp);\n        \n        return string(abi.encodePacked(\n          year.toString(), \"-\",\n          zeroPadTwoDigits(month), \"-\",\n          zeroPadTwoDigits(day), ' at ',\n            zeroPadTwoDigits(hour), \":\",\n            zeroPadTwoDigits(minute), \":\",\n            zeroPadTwoDigits(second)\n        ));\n    }\n    \n    function zeroPadTwoDigits(uint number) internal pure returns (string memory) {\n        string memory numberString = number.toString();\n        \n        if (bytes(numberString).length < 2) {\n            numberString = string(abi.encodePacked(\"0\", numberString));\n        }\n        \n        return numberString;\n    }\n}"
15     },
16     "contracts/ERC721PTO.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721PTO is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n    \n    struct TokenData {\n        address ownerAddress;\n        uint48 expiryTimestamp;\n        uint48 lastTransferTimestamp;\n    }\n\n    struct AddressData {\n        uint64 balance;\n        uint64 numberMinted;\n        uint64 firstRegistrationTimestamp;\n        uint64 largestExpiryTimestamp;\n    }\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => TokenData) internal _tokenData;\n\n    // Mapping owner address to token count\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _addressData[owner].balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721PTO.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenData[tokenId].ownerAddress;\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721PTO.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        \n        AddressData storage addressData = _addressData[to];\n        TokenData storage tokenData = _tokenData[tokenId];\n        \n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            addressData.balance += 1;\n            addressData.numberMinted += 1;\n        }\n\n        tokenData.ownerAddress = to;\n        tokenData.lastTransferTimestamp = uint48(block.timestamp);\n        \n        if (addressData.firstRegistrationTimestamp == 0) {\n            addressData.firstRegistrationTimestamp = uint64(block.timestamp);\n        }\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721PTO.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721PTO.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n        \n        AddressData storage addressData = _addressData[owner];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            addressData.balance -= 1;\n        }\n        delete _tokenData[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721PTO.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721PTO.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n        \n        AddressData storage fromAddressData = _addressData[from];\n        AddressData storage toAddressData = _addressData[to];\n        TokenData storage tokenData = _tokenData[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            fromAddressData.balance -= 1;\n            toAddressData.balance += 1;\n        }\n        tokenData.ownerAddress = to;\n        tokenData.lastTransferTimestamp = uint48(block.timestamp);\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721PTO.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        AddressData storage fromAddressData = _addressData[from];\n        AddressData storage toAddressData = _addressData[to];\n\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                fromAddressData.balance -= uint64(batchSize);\n            }\n            if (to != address(0)) {\n                toAddressData.balance += uint64(batchSize);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    function _setExpiryTimestamp(uint tokenId, uint48 expiryTimestamp) internal {\n        TokenData storage tokenData = _tokenData[tokenId];\n        AddressData storage addressData = _addressData[tokenData.ownerAddress];\n        \n        tokenData.expiryTimestamp = expiryTimestamp;\n        \n        if (expiryTimestamp > addressData.largestExpiryTimestamp) {\n            addressData.largestExpiryTimestamp = expiryTimestamp;\n        }\n    }\n    \n    function _getExpiryTimestamp(uint tokenId) internal view returns (uint48) {\n        return _tokenData[tokenId].expiryTimestamp;\n    }\n    \n    function getLastTransferTimestamp(uint tokenId) public view returns (uint48) {\n        return _tokenData[tokenId].lastTransferTimestamp;\n    }\n\n    function getNumberMinted(address owner) public view returns (uint256) {\n        return _addressData[owner].numberMinted;\n    }\n    \n    function getLargestExpiryTimestamp(address owner) public view returns (uint64) {\n        return _addressData[owner].largestExpiryTimestamp;\n    }\n    \n    function getFirstRegistrationTimestamp(address owner) public view returns (uint64) {\n        return _addressData[owner].firstRegistrationTimestamp;\n    }\n}"
18     },
19     "@openzeppelin/contracts/access/Ownable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
21     },
22     "contracts/ENS.sol": {
23       "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}"
24     },
25     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
27     },
28     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
30     },
31     "contracts/PublicResolver.sol": {
32       "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"./ENS.sol\";\n\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol\";\n\nimport \"@ensdomains/ens-contracts/contracts/resolvers/Multicallable.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver is\n    Multicallable,\n    ABIResolver,\n    AddrResolver,\n    ContentHashResolver,\n    DNSResolver,\n    InterfaceResolver,\n    NameResolver,\n    PubkeyResolver,\n    TextResolver\n{\n    ENS immutable ens;\n    address immutable trustedETHController;\n    address immutable trustedReverseRegistrar;\n\n    /**\n     * A mapping of operators. An address that is authorised for an address\n     * may make any changes to the name that the owner could, but may not update\n     * the set of authorisations.\n     * (owner, operator) => approved\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    constructor(\n        ENS _ens,\n        address _trustedETHController,\n        address _trustedReverseRegistrar\n    ) {\n        ens = _ens;\n        trustedETHController = _trustedETHController;\n        trustedReverseRegistrar = _trustedReverseRegistrar;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) external {\n        require(\n            msg.sender != operator,\n            \"ERC1155: setting approval status for self\"\n        );\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[account][operator];\n    }\n\n    function isAuthorised(bytes32 node) internal view override returns (bool) {\n        if (\n            msg.sender == trustedETHController ||\n            msg.sender == trustedReverseRegistrar\n        ) {\n            return true;\n        }\n        address owner = ens.owner(node);\n        \n        return owner == msg.sender || isApprovedForAll(owner, msg.sender);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        override(\n            Multicallable,\n            ABIResolver,\n            AddrResolver,\n            ContentHashResolver,\n            DNSResolver,\n            InterfaceResolver,\n            NameResolver,\n            PubkeyResolver,\n            TextResolver\n        )\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceID);\n    }\n}"
33     },
34     "contracts/ReverseRegistrar.sol": {
35       "content": "pragma solidity >=0.8.4;\n\nimport \"./ENS.sol\";\nimport \"@ensdomains/ens-contracts/contracts/registry/IReverseRegistrar.sol\";\nimport \"@ensdomains/ens-contracts/contracts/root/Controllable.sol\";\n\nabstract contract NameResolver {\n    function setName(bytes32 node, string memory name) public virtual;\n}\n\nbytes32 constant lookup = 0x3031323334353637383961626364656600000000000000000000000000000000;\n\nbytes32 constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\ncontract ReverseRegistrar is Ownable, Controllable, IReverseRegistrar {\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            \"ReverseRegistrar: Caller is not a controller or authorised by address or the address itself\"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            \"ReverseRegistrar: Resolver address must not be 0\"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver)\n        public\n        override\n        returns (bytes32)\n    {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}"
36     },
37     "contracts/Normalize4.sol": {
38       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Normalize4 is Ownable {\n\n\terror InvalidCodepoint(uint256 cp);\n\n\tuint256 constant STOP = 0x2E;\n\tuint256 constant EMOJI_STATE_MASK  = 0x07FF; \n\tuint256 constant EMOJI_STATE_QUIRK = 0x0800;\n\tuint256 constant EMOJI_STATE_VALID = 0x1000;\n\tuint256 constant EMOJI_STATE_SAVE  = 0x2000;\n\tuint256 constant EMOJI_STATE_CHECK = 0x4000;\n\tuint256 constant EMOJI_STATE_FE0F  = 0x8000;\n\n\tmapping (uint256 => uint256) _emoji;\n\tmapping (uint256 => uint256) _valid;   // bitmap\n\tmapping (uint256 => uint256) _ignored; // bitmap\n\tmapping (uint256 => uint256) _small; // 1-2 cp\n\tmapping (uint256 => uint256) _large; // 3-6 cp\n\tmapping (uint256 => uint256) _class;\n\tmapping (uint256 => uint256) _cm;\n\tmapping (uint256 => uint256) _recomp;\n\tmapping (uint256 => uint256) _decomp;\n\n\tfunction normhash(string memory name) public view returns (bytes32 node) {\n\t\tstring[] memory labels = normalize(name);\n\t\tuint256 i = labels.length;\n\t\twhile (i > 0) {\n\t\t\tbytes32 label = keccak256(bytes(labels[--i]));\n\t\t\tnode = keccak256(abi.encodePacked(node, label));\n\t\t}\n\t}\n\n\tfunction normalize(string memory name) public view returns (string[] memory labels) {\n        (uint256[] memory values, uint256 label_count) = process(decodeUTF8(bytes(name)), false);\n\t\t//n = label_count;\n\t\t//v = values;\n\t\tvalues = nfd(values);\n\t\tlabels = new string[](label_count);\n\t\tuint256 prev;\n\t\tfor (uint256 i; i < label_count; i++) {\n\t\t\tuint256 end = prev;\n\t\t\twhile (end < values.length && values[end] != STOP) end++;\n\t\t\tlabels[i] = string(post_check_label(values, prev, end));\n\t\t\tprev = end + 1;\n\t\t}\n\t}\n\n\tfunction beautify(string memory name) public view returns (string memory) {\n\t\t(uint256[] memory values, ) = process(decodeUTF8(bytes(name)), true);\n\t\treturn string(nfc(nfd(values)));\n\t}\n\n\n\tfunction updateMapping(mapping (uint256 => uint256) storage map, bytes calldata data, uint256 key_bytes) private {\n\t\tuint256 i;\n\t\tuint256 e;\n\t    uint256 mask = ~(type(uint256).max << (key_bytes << 3));\n\t\tassembly {\n\t\t\ti := data.offset\n\t\t\te := add(i, data.length)\n\t\t}\n\t\twhile (i < e) {\n\t\t\tuint256 k;\n\t\t\tuint256 v;\n\t\t\tassembly {\n\t\t\t\t// key-value pairs are packed in reverse \n\t\t\t\t// eg. [value1][key1][value2][key2]...\n\t\t\t\tv := calldataload(i)\n\t\t\t\ti := add(i, key_bytes)\n\t\t\t\tk := and(calldataload(i), mask)\n\t\t\t\ti := add(i, 32)\n\t\t\t}\n\t\t\tmap[k] = v;\n\t\t}\n\t}\n\t\n\tfunction updateBatch1(bytes[] calldata data) public onlyOwner {\n\t\tupdateClass(data[0]);\n        updateCM(data[1]);\n        updateDecomp(data[2]);\n        updateIgnored(data[3]);\n        updateLarge(data[4]);\n        updateValid(data[5]);\n        updateLarge(data[6]);\n\t}\n    \n    function updateBatch2(bytes[] calldata data) public onlyOwner {\n        updateRecomp(data[0]);\n        uploadEmoji(data[1]);\n    }\n\n\tfunction uploadEmoji(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_emoji, data, 4);\n\t}\n\tfunction updateValid(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_valid, data, 2);\n\t}\n\tfunction updateIgnored(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_ignored, data, 2);\n\t}\n\tfunction updateSmall(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_small, data, 3);\n\t}\n\tfunction updateLarge(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_large, data, 3);\n\t}\n\tfunction updateClass(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_class, data, 2);\n\t}\n\tfunction updateCM(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_cm, data, 2);\n\t}\n\tfunction updateDecomp(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_decomp, data, 3);\n\t}\n\tfunction updateRecomp(bytes calldata data) public onlyOwner {\n\t\tupdateMapping(_recomp, data, 5);\n\t}\n\n\t// bitmaps\n\tfunction isCM(uint256 cp) public view returns (bool) {\n\t\treturn ((_cm[cp >> 8] & (1 << (cp & 0xFF))) != 0);\n\t}\n\tfunction isValid(uint256 cp) public view returns (bool) {\n\t\treturn ((_valid[cp >> 8] & (1 << (cp & 0xFF))) != 0);\n\t}\n\tfunction isIgnored(uint256 cp) public view returns (bool) {\n\t\treturn ((_ignored[cp >> 8] & (1 << (cp & 0xFF))) != 0);\n\t}\n\n \tfunction getDecomp(uint256 cp) public view returns (uint256) {\n        return (_decomp[cp >> 2] >> ((cp & 0x3) << 6)) & 0xFFFFFFFFFFFFFFFF;\n    }\n\tfunction getRecomp(uint256 a, uint256 b) public view returns (uint256) {\n\t\treturn (_recomp[(b << 29) | (a >> 3)] >> ((a & 0x7) << 5)) & 0xFFFFFFFF;\n\t}\n\tfunction getClass(uint256 cp) public view returns (uint256) {\n\t\treturn (_class[cp >> 5] >> ((cp & 0x1F) << 3)) & 0xFF;\n\t}\n\n\tfunction getSmall(uint256 cp) public view returns (uint256) {\n\t\treturn (_small[cp >> 2] >> ((cp & 0x3) << 6)) & 0xFFFFFFFFFFFFFFFF;\n\t}\n\tfunction getLarge(uint256 cp) public view returns (uint256) {\n\t\treturn (_large[cp >> 1] >> ((cp & 0x1) << 7)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\t}\n\n\tfunction getEmoji(uint256 s0, uint256 cp) private view returns (uint256) {\n\t\treturn (_emoji[(s0 << 20) | (cp >> 4)] >> ((cp & 0xF) << 4)) & 0xFFFF;\n\t}\n\n\t\n\tfunction debugEmojiState(uint256 s0, uint256 cp) public view returns (uint256 value, bool fe0f, bool check, bool save, bool valid, bool quirk, uint256 s1) {\n\t\t// (state0, Floor[cp/16]) => array: uint32[16]\n\t\t// array[cp%16] => [flags: (4 bits), state1: (12 bits)]\n\t\tvalue = getEmoji(s0, cp);\n\t\tfe0f = (value & EMOJI_STATE_FE0F) != 0;\n\t\tcheck = (value & EMOJI_STATE_CHECK) != 0;\n\t\tsave = (value & EMOJI_STATE_SAVE) != 0;\n\t\tvalid = (value & EMOJI_STATE_VALID) != 0;\n\t\tquirk = (value & EMOJI_STATE_QUIRK) != 0;\n\t\ts1 = value & EMOJI_STATE_MASK; // next state\n\t}\n\n\tfunction isOneEmoji(string memory s) public view returns (bool) {\n\t\tuint256[] memory cps = decodeUTF8(bytes(s));\n\t\tuint256[] memory ret = new uint256[](cps.length);\n\t\t(uint256 pos, uint256 len) = consumeEmoji(cps, 0, ret, 0, false);\n\t\treturn pos == cps.length && len > 0;\n\t}\n\n\t// https://www.unicode.org/versions/Unicode14.0.0/ch03.pdf\n\tuint256 constant S0 = 0xAC00;\n\tuint256 constant L0 = 0x1100;\n\tuint256 constant V0 = 0x1161;\n\tuint256 constant T0 = 0x11A7;\n\tuint256 constant L_COUNT = 19;\n\tuint256 constant V_COUNT = 21;\n\tuint256 constant T_COUNT = 28;\n\tuint256 constant N_COUNT = V_COUNT * T_COUNT;\n\tuint256 constant S_COUNT = L_COUNT * N_COUNT;\n\tuint256 constant S1 = S0 + S_COUNT;\n\tuint256 constant L1 = L0 + L_COUNT;\n\tuint256 constant V1 = V0 + V_COUNT;\n\tuint256 constant T1 = T0 + T_COUNT;\n\tuint256 constant CP_MASK = 0xFFFFFF;\n\n\tfunction isHangul(uint256 cp) private pure returns (bool) {\n\t\treturn cp >= S0 && cp < S1;\n\t}\n\tfunction getComposed(uint256 a, uint256 b) private view returns (uint256) {\n\t\tif (a >= L0 && a < L1 && b >= V0 && b < V1) { // LV\n\t\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n\t\t} else if (isHangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n\t\t\treturn a + (b - T0);\n\t\t} else {\n\t\t\treturn getRecomp(a, b);\n\t\t}\n\t}\n\n\tfunction decodeUTF8(bytes memory src) private pure returns (uint256[] memory ret) {\n\t\tret = new uint256[](src.length);\n\t\tuint256 ptr;\n\t\tassembly {\n\t\t\tptr := src\n\t\t}\n\t\tuint256 len;\n\t\tuint256 end = ptr + src.length;\n\t\twhile (ptr < end) {\n\t\t\t(uint256 cp, uint256 step) = readUTF8(ptr);\n\t\t\tret[len++] = cp;\n\t\t\tptr += step;\n\t\t}\n\t\tassembly {\n\t\t\tmstore(ret, len) // truncate\n\t\t}\n\t}\n\n\t// read one cp from memory at ptr\n\t// step is number of encoded bytes (1-4)\n\t// raw is encoded bytes\n\t// warning: assumes valid UTF8\n\tfunction readUTF8(uint256 ptr) private pure returns (uint256 cp, uint256 step) {\n\t\t// 0xxxxxxx => 1 :: 0aaaaaaa ???????? ???????? ???????? =>                   0aaaaaaa\n\t\t// 110xxxxx => 2 :: 110aaaaa 10bbbbbb ???????? ???????? =>          00000aaa aabbbbbb\n\t\t// 1110xxxx => 3 :: 1110aaaa 10bbbbbb 10cccccc ???????? => 000000aa aaaabbbb bbcccccc\n\t\t// 11110xxx => 4 :: 11110aaa 10bbbbbb 10cccccc 10dddddd => 000aaabb bbbbcccc ccdddddd\n\t\tuint256 raw;\n\t\tassembly {\n\t\t\traw := and(mload(add(ptr, 4)), 0xFFFFFFFF)\n\t\t}\n\t\tuint256 upper = raw >> 28;\n\t\tif (upper < 0x8) {\n\t\t\tstep = 1;\n\t\t\traw >>= 24;\n\t\t\tcp = raw;\n\t\t} else if (upper < 0xE) {\n\t\t\tstep = 2;\n\t\t\traw >>= 16;\n\t\t\tcp = ((raw & 0x1F00) >> 2) | (raw & 0x3F);\n\t\t} else if (upper < 0xF) {\n\t\t\tstep = 3;\n\t\t\traw >>= 8;\n\t\t\tcp = ((raw & 0x0F0000) >> 4) | ((raw & 0x3F00) >> 2) | (raw & 0x3F);\n\t\t} else {\n\t\t\tstep = 4;\n\t\t\tcp = ((raw & 0x07000000) >> 6) | ((raw & 0x3F0000) >> 4) | ((raw & 0x3F00) >> 2) | (raw & 0x3F);\n\t\t}\n\t}\n\n\tfunction encodeUTF8(uint256[] memory cps) private pure returns (bytes memory ret) {\n\t\tret = new bytes(cps.length << 2);\n\t\tuint256 ret_off;\n\t\tassembly {\n\t\t\tret_off := add(ret, 32)\n\t\t}\n\t\tuint256 ret_end = ret_off;\n\t\tfor (uint256 i; i < cps.length; i++) {\n\t\t\tret_end = writeUTF8(ret_end, cps[i] & CP_MASK);\n\t\t}\n\t\tassembly {\n\t\t\tmstore(ret, sub(ret_end, ret_off))\n\t\t}\n\t}\n\n    function writeUTF8(uint256 ptr, uint256 cp) private pure returns (uint256) {\n\t\tif (cp < 0x80) {\n            assembly {\n                mstore8(ptr, cp)\n            }\n            return ptr + 1;\n\t\t} else if (cp < 0x800) {\n            assembly {\n                mstore8(ptr,         or(0xC0, shr(6, cp)))\n                mstore8(add(ptr, 1), or(0x80, and(cp, 0x3F)))\n            }\n            return ptr + 2;\n\t\t} else if (cp < 0x10000) {\n            assembly {\n                mstore8(ptr,         or(0xE0, shr(12, cp)))\n                mstore8(add(ptr, 1), or(0x80, and(shr(6, cp), 0x3F)))\n                mstore8(add(ptr, 2), or(0x80, and(cp, 0x3F)))\n            }\n            return ptr + 3;\n\t\t} else {\n            assembly {\n                mstore8(ptr,         or(0xF0, shr(18, cp)))\n                mstore8(add(ptr, 1), or(0x80, and(shr(12, cp), 0x3F)))\n                mstore8(add(ptr, 2), or(0x80, and(shr(6, cp), 0x3F)))\n                mstore8(add(ptr, 3), or(0x80, and(cp, 0x3F)))\n            }\n            return ptr + 4;\n\t\t}\n\t}\n\n\tfunction process(uint256[] memory cps, bool pretty) public view returns (uint256[] memory ret, uint256 label_count) {\n\t\tret = new uint256[](cps.length * 6); // maximum expansion factor\n\t\tlabel_count = 1;\n\t\tuint256 len;\n\t\tuint256 i;\n\t\twhile(i < cps.length) {\n\t\t\t(uint256 new_i, uint256 new_len) = consumeEmoji(cps, i, ret, len, pretty);\n\t\t\tif (new_i > i) {\n\t\t\t\ti = new_i;\n\t\t\t\tif (pretty && (new_len & VALUE_EMOJI) != 0) {\n\t\t\t\t\tlen = (new_len ^ VALUE_EMOJI) - 1;\n\t\t\t\t\tfor (uint256 j = i + 1; j < len; j++) {\n\t\t\t\t\t\tret[j] = ret[j+1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlen = new_len;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuint256 cp = cps[i++];\n\t\t\tuint256 mapped = getMapped(cp); \n\t\t\tif (mapped != 0) {\n\t\t\t\tret[len++] = mapped;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isValid(cp)) {\t\t\n\t\t\t\tif (cp == STOP) label_count++;\t\t\n \t\t\t\tret[len++] = cp;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isIgnored(cp)) { \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmapped = getSmall(cp);\n\t\t\tif (mapped != 0) {\n\t\t\t\tif (mapped < 0xFFFFFF) {\n\t\t\t\t\tret[len++] = mapped;\n\t\t\t\t} else {\n\t\t\t\t\tret[len++] = mapped >> 24;\n\t\t\t\t\tret[len++] = mapped & 0xFFFFFF;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmapped = getLarge(cp);\n\t\t\tif (mapped == 0) revert InvalidCodepoint(cp);\n\t\t\twhile (mapped != 0) {\n\t\t\t\tret[len++] = mapped & 0x1FFFFF;\n\t\t\t\tmapped >>= 21;\n\t\t\t}\n\t\t}\n\t\tassembly {\n\t\t\tmstore(ret, len)\n\t\t}\n\t}\n\n    function addClass(uint256 cp) private view returns (uint256) {\n        return (getClass(cp) << 24) | cp;\n    }\n\tfunction nfd(uint256[] memory cps) private view returns (uint256[] memory ret) {\n        ret = new uint256[](cps.length * 3); // growth factor\n        uint256 len;\n        uint256 has_nz_class;\n        for (uint256 i; i < cps.length; i++) {\n            uint256 buf = cps[i];\n            uint256 width = 32;\n            while (width != 0) {\n                uint256 cp = buf & 0xFFFFFFFF;\n                buf >>= 32;\n                width -= 32;\n                if (cp < 0x80 || cp >= CP_MASK) {\n                    ret[len++] = cp;\n                } else if (isHangul(cp)) {\n                    uint256 s_index = cp - S0;\n                    uint256 l_index = s_index / N_COUNT | 0;\n                    uint256 v_index = (s_index % N_COUNT) / T_COUNT | 0;\n                    uint256 t_index = s_index % T_COUNT;\n                    uint256 l_cp = addClass(L0 + l_index);\n                    uint256 v_cp = addClass(V0 + v_index);\n                    ret[len++] = l_cp;\n                    ret[len++] = v_cp;\n                    if (has_nz_class == 0 && (l_cp | v_cp) > CP_MASK) has_nz_class = 1;\n                    if (t_index != 0) {\n                        uint256 t_cp = addClass(T0 + t_index);\n                        if (has_nz_class == 0 && t_cp > CP_MASK) has_nz_class = 1;\n                        ret[len++] = t_cp;\n                    }\n                } else {\n                    uint256 decomp = getDecomp(cp);\n                    if (decomp != 0) {\n                        buf |= (decomp << width);\n                        width += (decomp >> 32) == 0 ? 32 : 64;\n                    } else {\n                        uint256 x_cp = addClass(cp);\n                        if (has_nz_class == 0 && x_cp > CP_MASK) has_nz_class = 1;\n                        ret[len++] = x_cp;\n                    }\n                }\n            }\n        }\n        if (has_nz_class != 0) {\n            uint256 prev = ret[0] >> 24;\n            for (uint256 i = 1; i < len; i++) {\n                uint256 rank = ret[i] >> 24;\n                if (prev == 0 || rank == 0 || prev <= rank) {\n                    prev = rank;\n                    continue;\n                }\n                uint256 j = i - 1;\n                while (true) {\n                    (ret[j+1], ret[j]) = (ret[j], ret[j+1]);\n                    if (j == 0) break;\n                    prev = ret[--j] >> 24;\n                    if (prev <= rank) break;\n                }\n                prev = ret[i] >> 24;\n            }\n        }\n        assembly {\n            mstore(ret, len) // truncate\n        }\n    }\n\n\t\n\tfunction nfc(uint256[] memory values) private view returns (bytes memory utf8) {\n\t\tutf8 = new bytes(values.length << 4);\n\t\tuint256 utf_off;\n\t\tassembly {\n\t\t\tutf_off := add(utf8, 32)\n\t\t}\n\t\tuint256 utf_end = utf_off;\n\t\tuint256 prev_cp;\n\t\tfor (uint256 i; i < values.length; i++) {\n\t\t\tuint256 cp = values[i] & CP_MASK;\n\t\t\tif (prev_cp != 0) {\n\t\t\t\tif (cp >= 0x80) {\n\t\t\t\t\tuint256 composed = getComposed(prev_cp, cp);\n\t\t\t\t\tif (composed != 0) {\n\t\t\t\t\t\tprev_cp = composed;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tutf_end = writeUTF8(utf_end, prev_cp);\t\n\t\t\t}\n\t\t\tprev_cp = cp;\t\n\t\t}\n\t\tif (prev_cp != 0) {\n\t\t\tutf_end = writeUTF8(utf_end, prev_cp);\n\t\t}\n\t\tassembly {\n\t\t\tmstore(utf8, sub(utf_end, utf_off))\n\t\t}\n\t}\n\n\n\tfunction post_check_label(uint256[] memory values, uint256 start, uint256 end) private view returns (bytes memory utf8) {\n\t\tuint256 len = end - start;\n\t\tif (len == 0) return ('');\n\t\tuint256 non_ascii;\n\t\tuint256 fail_if_underscore;\n\t\tuint256 fail_if_cm = 1;\n\t\tutf8 = new bytes(len << 4);\n\t\tuint256 utf_off;\n\t\tassembly {\n\t\t\tutf_off := add(utf8, 32)\n\t\t}\n\t\tuint256 utf_end = utf_off;\n\t\tuint256 prev_cp;\n\t\twhile (start < end) {\n\t\t\tuint256 value = values[start++];\n\t\t\tuint256 cp = value & 0xFFFFFF;\n\t\t\tif (cp < 0x80) { // ascii\n\t\t\t\tif (cp == 0x5F) { // underscore\n\t\t\t\t\trequire(fail_if_underscore == 0, \"underscore\");\n\t\t\t\t} else {\n\t\t\t\t\tfail_if_underscore = 1;\n\t\t\t\t}\n\t\t\t\tif (prev_cp != 0) {\n\t\t\t\t\tutf_end = writeUTF8(utf_end, prev_cp);\t\n\t\t\t\t}\n\t\t\t\tprev_cp = cp;\n\t\t\t\tfail_if_cm = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnon_ascii = 1;\n\t\t\tif (isCM(cp)) {\n\t\t\t\trequire(fail_if_cm == 0, \"cm\");\n\t\t\t\tfail_if_cm = 1;\n\t\t\t} else if ((value & VALUE_EMOJI) != 0) {\n\t\t\t\tfail_if_cm = 1;\n\t\t\t} else {\n\t\t\t\tfail_if_cm = 0;\n\t\t\t}\n\t\t\tif (prev_cp != 0) {\n\t\t\t\tuint256 composed = getComposed(prev_cp, cp);\n\t\t\t\tif (composed != 0) {\n\t\t\t\t\tprev_cp = composed;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tutf_end = writeUTF8(utf_end, prev_cp);\t\n\t\t\t}\n\t\t\tprev_cp = cp;\t\n\t\t}\n\t\tutf_end = writeUTF8(utf_end, prev_cp);\t\n\t\t// label extension\n\t\tif (len >= 4 && non_ascii == 0 && utf8[2] == '-' && utf8[3] == '-') {\n\t\t\trevert(\"label extension\");\n\t\t}\n\t\tassembly {\n\t\t\tmstore(utf8, sub(utf_end, utf_off))\n\t\t}\n\t}\n\n\tuint256 constant VALUE_EMOJI = 0x80000000;\n\n\tfunction consumeEmoji(uint256[] memory cps, uint256 pos, uint256[] memory ret, uint256 len, bool add_fe0f) private view returns (uint256 out_pos, uint256 out_len) {\n\t\tuint256 state;\n\t\tuint256 saved;\n\t\twhile (pos < cps.length) {\n\t\t\tuint256 cp = cps[pos++];\n\t\t\tstate = getEmoji(state & EMOJI_STATE_MASK, cp);\n\t\t\tif (state == 0) break;\n\t\t\tif ((state & EMOJI_STATE_SAVE) != 0) { \n\t\t\t\tsaved = cp; \n\t\t\t} else if ((state & EMOJI_STATE_CHECK) != 0) { \n\t\t\t\tif (cp == saved) break;\n\t\t\t}\n\t\t\tret[len++] = cp | VALUE_EMOJI;\n\t\t\tif ((state & EMOJI_STATE_FE0F) != 0) {\n\t\t\t\tif (add_fe0f) ret[len++] = 0xFE0F | VALUE_EMOJI;\n\t\t\t\tif (pos < cps.length && cps[pos] == 0xFE0F) pos++;\n\t\t\t}\n\t\t\tif ((state & EMOJI_STATE_VALID) != 0) {\n\t\t\t\tout_pos = pos;\n\t\t\t\tout_len = len;\n\t\t\t\tif (add_fe0f && (state & EMOJI_STATE_QUIRK) != 0) {\n\t\t\t\t\tout_len |= VALUE_EMOJI;\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\tfunction getMapped(uint256 cp) public pure returns (uint256 ret) {\n        return 0;\n    }*/\n\n\t// auto-generated\n\tfunction getMapped(uint256 cp) public pure returns (uint256 ret) {\n\t\tif (cp <= 0x1D734) {\n\t\t\tif (cp <= 0xFFB3) {\n\t\t\t\tif (cp <= 0x2099) {\n\t\t\t\t\tif (cp <= 0x1CBA) {\n\t\t\t\t\t\tif (cp <= 0x3FF) {\n\t\t\t\t\t\t\tif (cp <= 0xDE) {\n\t\t\t\t\t\t\t\tif (cp >= 0x41 && cp <= 0x5A) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xC0 && cp <= 0xD6) { // Mapped11: 23\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xD8 && cp <= 0xDE) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x388 && cp <= 0x38A) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp + 0x25;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x391 && cp <= 0x3A1) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3A3 && cp <= 0x3AB) { // Mapped11: 9\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3FD && cp <= 0x3FF) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x82;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x556) {\n\t\t\t\t\t\t\t\tif (cp >= 0x400 && cp <= 0x40F) { // Mapped11: 16\n\t\t\t\t\t\t\t\t\tret = cp + 0x50;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x410 && cp <= 0x42F) { // Mapped11: 32\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x531 && cp <= 0x556) { // Mapped11: 38\n\t\t\t\t\t\t\t\t\tret = cp + 0x30;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x6F0 && cp <= 0x6F3) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x90;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x6F7 && cp <= 0x6F9) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x90;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x13F8 && cp <= 0x13FD) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1C90 && cp <= 0x1CBA) { // Mapped11: 43\n\t\t\t\t\t\t\t\t\tret = cp - 0xBC0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x1F0F) {\n\t\t\t\t\t\t\tif (cp <= 0x1D5F) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1CBD && cp <= 0x1CBF) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0xBC0;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D33 && cp <= 0x1D3A) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x1CCC;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D5D && cp <= 0x1D5F) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x19AB;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1DA4 && cp <= 0x1DA6) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x1B3C;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1DAE && cp <= 0x1DB1) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1B3C;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1DBC && cp <= 0x1DBE) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x1B2C;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F08 && cp <= 0x1F0F) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1F4D) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1F18 && cp <= 0x1F1D) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F28 && cp <= 0x1F2F) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F38 && cp <= 0x1F3F) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F48 && cp <= 0x1F4D) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1F68 && cp <= 0x1F6F) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2074 && cp <= 0x2079) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x2040;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2080 && cp <= 0x2089) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x2050;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2096 && cp <= 0x2099) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x202B;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cp <= 0x32E9) {\n\t\t\t\t\t\tif (cp <= 0x313F) {\n\t\t\t\t\t\t\tif (cp <= 0x24CF) {\n\t\t\t\t\t\t\t\tif (cp >= 0x2135 && cp <= 0x2138) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1B65;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2460 && cp <= 0x2468) { // Mapped11: 9\n\t\t\t\t\t\t\t\t\tret = cp - 0x242F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x24B6 && cp <= 0x24CF) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x2455;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x24D0 && cp <= 0x24E9) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x246F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2C00 && cp <= 0x2C2F) { // Mapped11: 48\n\t\t\t\t\t\t\t\t\tret = cp + 0x30;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3137 && cp <= 0x3139) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x2034;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x313A && cp <= 0x313F) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x1F8A;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x317C) {\n\t\t\t\t\t\t\t\tif (cp >= 0x3141 && cp <= 0x3143) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x203B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3145 && cp <= 0x314E) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x203C;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x314F && cp <= 0x3163) { // Mapped11: 21\n\t\t\t\t\t\t\t\t\tret = cp - 0x1FEE;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3178 && cp <= 0x317C) { // Mapped11: 5\n\t\t\t\t\t\t\t\t\tret = cp - 0x204D;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x3184 && cp <= 0x3186) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x202D;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3263 && cp <= 0x3265) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x215E;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3269 && cp <= 0x326D) { // Mapped11: 5\n\t\t\t\t\t\t\t\t\tret = cp - 0x215B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x32E4 && cp <= 0x32E9) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x21A;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0xFF19) {\n\t\t\t\t\t\t\tif (cp <= 0x32FE) {\n\t\t\t\t\t\t\t\tif (cp >= 0x32EE && cp <= 0x32F2) { // Mapped11: 5\n\t\t\t\t\t\t\t\t\tret = cp - 0x210;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x32F5 && cp <= 0x32FA) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0x20D;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x32FB && cp <= 0x32FE) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x20C;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xAB70 && cp <= 0xABBF) { // Mapped11: 80\n\t\t\t\t\t\t\t\t\tret = cp - 0x97D0;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB24 && cp <= 0xFB26) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0xF549;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFE41 && cp <= 0xFE44) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0xCE35;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFF10 && cp <= 0xFF19) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0xFEE0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0xFF93) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFF21 && cp <= 0xFF3A) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0xFEC0;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFF41 && cp <= 0xFF5A) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0xFEE0;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFF85 && cp <= 0xFF8A) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xCEBB;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFF8F && cp <= 0xFF93) { // Mapped11: 5\n\t\t\t\t\t\t\t\t\tret = cp - 0xCEB1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFF96 && cp <= 0xFF9B) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xCEAE;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFA7 && cp <= 0xFFA9) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0xEEA4;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFAA && cp <= 0xFFAF) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xEDFA;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFB1 && cp <= 0xFFB3) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0xEEAB;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cp <= 0x1D503) {\n\t\t\t\t\tif (cp <= 0x118BF) {\n\t\t\t\t\t\tif (cp <= 0x10427) {\n\t\t\t\t\t\t\tif (cp <= 0xFFCF) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFFB5 && cp <= 0xFFBE) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0xEEAC;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFC2 && cp <= 0xFFC7) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xEE61;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFCA && cp <= 0xFFCF) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xEE63;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFFD2 && cp <= 0xFFD7) { // Mapped11: 6\n\t\t\t\t\t\t\t\t\tret = cp - 0xEE65;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFDA && cp <= 0xFFDC) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0xEE67;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFFE9 && cp <= 0xFFEC) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0xDE59;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x10400 && cp <= 0x10427) { // Mapped11: 40\n\t\t\t\t\t\t\t\t\tret = cp + 0x28;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1058A) {\n\t\t\t\t\t\t\t\tif (cp >= 0x104B0 && cp <= 0x104D3) { // Mapped11: 36\n\t\t\t\t\t\t\t\t\tret = cp + 0x28;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x10570 && cp <= 0x1057A) { // Mapped11: 11\n\t\t\t\t\t\t\t\t\tret = cp + 0x27;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1057C && cp <= 0x1058A) { // Mapped11: 15\n\t\t\t\t\t\t\t\t\tret = cp + 0x27;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1058C && cp <= 0x10592) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp + 0x27;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x107B6 && cp <= 0x107B8) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x105F6;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x10C80 && cp <= 0x10CB2) { // Mapped11: 51\n\t\t\t\t\t\t\t\t\tret = cp + 0x40;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x118A0 && cp <= 0x118BF) { // Mapped11: 32\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x1D481) {\n\t\t\t\t\t\t\tif (cp <= 0x1D433) {\n\t\t\t\t\t\t\t\tif (cp >= 0x16E40 && cp <= 0x16E5F) { // Mapped11: 32\n\t\t\t\t\t\t\t\t\tret = cp + 0x20;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D400 && cp <= 0x1D419) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D39F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D41A && cp <= 0x1D433) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3B9;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D434 && cp <= 0x1D44D) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3D3;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D44E && cp <= 0x1D454) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3ED;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D456 && cp <= 0x1D467) { // Mapped11: 18\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3ED;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D468 && cp <= 0x1D481) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D407;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1D4B9) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D482 && cp <= 0x1D49B) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D421;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4A9 && cp <= 0x1D4AC) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D43B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4AE && cp <= 0x1D4B5) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D43B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4B6 && cp <= 0x1D4B9) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D455;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D4BD && cp <= 0x1D4C3) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D455;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4C5 && cp <= 0x1D4CF) { // Mapped11: 11\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D455;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4D0 && cp <= 0x1D4E9) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D46F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D4EA && cp <= 0x1D503) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D489;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cp <= 0x1D621) {\n\t\t\t\t\t\tif (cp <= 0x1D550) {\n\t\t\t\t\t\t\tif (cp <= 0x1D51C) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D507 && cp <= 0x1D50A) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4A3;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D50D && cp <= 0x1D514) { // Mapped11: 8\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4A3;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D516 && cp <= 0x1D51C) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4A3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D51E && cp <= 0x1D537) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4BD;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D53B && cp <= 0x1D53E) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4D7;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D540 && cp <= 0x1D544) { // Mapped11: 5\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4D7;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D54A && cp <= 0x1D550) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4D7;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1D5B9) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D552 && cp <= 0x1D56B) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D4F1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D56C && cp <= 0x1D585) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D50B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D586 && cp <= 0x1D59F) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D525;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D5A0 && cp <= 0x1D5B9) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D53F;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D5BA && cp <= 0x1D5D3) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D559;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D5D4 && cp <= 0x1D5ED) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D573;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D5EE && cp <= 0x1D607) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D58D;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D608 && cp <= 0x1D621) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D5A7;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x1D6C0) {\n\t\t\t\t\t\t\tif (cp <= 0x1D66F) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D622 && cp <= 0x1D63B) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D5C1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D63C && cp <= 0x1D655) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D5DB;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D656 && cp <= 0x1D66F) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D5F5;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D670 && cp <= 0x1D689) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D60F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D68A && cp <= 0x1D6A3) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D629;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D6A8 && cp <= 0x1D6B8) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D2F7;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D6BA && cp <= 0x1D6C0) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D2F7;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1D6FA) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D6C2 && cp <= 0x1D6D2) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D311;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D6D4 && cp <= 0x1D6DA) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D311;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D6E2 && cp <= 0x1D6F2) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D331;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D6F4 && cp <= 0x1D6FA) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D331;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D6FC && cp <= 0x1D70C) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D34B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D70E && cp <= 0x1D714) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D34B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D71C && cp <= 0x1D72C) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D36B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D72E && cp <= 0x1D734) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D36B;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (cp <= 0xFB69) {\n\t\t\t\tif (cp <= 0x1DB) {\n\t\t\t\t\tif (cp <= 0x1D7F5) {\n\t\t\t\t\t\tif (cp <= 0x1D7A0) {\n\t\t\t\t\t\t\tif (cp <= 0x1D766) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D736 && cp <= 0x1D746) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D385;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D748 && cp <= 0x1D74E) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D385;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D756 && cp <= 0x1D766) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3A5;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D768 && cp <= 0x1D76E) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3A5;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D770 && cp <= 0x1D780) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3BF;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D782 && cp <= 0x1D788) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3BF;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D790 && cp <= 0x1D7A0) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3DF;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1D7C2) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D7A2 && cp <= 0x1D7A8) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3DF;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D7AA && cp <= 0x1D7BA) { // Mapped11: 17\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3F9;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D7BC && cp <= 0x1D7C2) { // Mapped11: 7\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D3F9;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D7CE && cp <= 0x1D7D7) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D79E;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D7D8 && cp <= 0x1D7E1) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D7A8;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D7E2 && cp <= 0x1D7EB) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D7B2;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D7EC && cp <= 0x1D7F5) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D7BC;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x1F149) {\n\t\t\t\t\t\t\tif (cp <= 0x1EE0D) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1D7F6 && cp <= 0x1D7FF) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1D7C6;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1E900 && cp <= 0x1E921) { // Mapped11: 34\n\t\t\t\t\t\t\t\t\tret = cp + 0x22;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1EE0A && cp <= 0x1EE0D) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1E7C7;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x1EE2A && cp <= 0x1EE2D) { // Mapped11: 4\n\t\t\t\t\t\t\t\t\tret = cp - 0x1E7E7;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1EE8B && cp <= 0x1EE8D) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x1E847;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1EEAB && cp <= 0x1EEAD) { // Mapped11: 3\n\t\t\t\t\t\t\t\t\tret = cp - 0x1E867;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F130 && cp <= 0x1F149) { // Mapped11: 26\n\t\t\t\t\t\t\t\t\tret = cp - 0x1F0CF;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x147) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1FBF0 && cp <= 0x1FBF9) { // Mapped11: 10\n\t\t\t\t\t\t\t\t\tret = cp - 0x1FBC0;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x100 && cp < 0x130 && (cp & 1 == 0)) { // Mapped22: 24\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x139 && cp < 0x13F && (cp & 1 == 0)) { // Mapped22: 3\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x141 && cp < 0x149 && (cp & 1 == 0)) { // Mapped22: 4\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x14A && cp < 0x178 && (cp & 1 == 0)) { // Mapped22: 23\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x179 && cp < 0x17F && (cp & 1 == 0)) { // Mapped22: 3\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1A0 && cp < 0x1A6 && (cp & 1 == 0)) { // Mapped22: 3\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1CD && cp < 0x1DD && (cp & 1 == 0)) { // Mapped22: 8\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cp <= 0xA69A) {\n\t\t\t\t\t\tif (cp <= 0x4BE) {\n\t\t\t\t\t\t\tif (cp <= 0x232) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1DE && cp < 0x1F0 && (cp & 1 == 0)) { // Mapped22: 9\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1F8 && cp < 0x220 && (cp & 1 == 0)) { // Mapped22: 20\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x222 && cp < 0x234 && (cp & 1 == 0)) { // Mapped22: 9\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x246 && cp < 0x250 && (cp & 1 == 0)) { // Mapped22: 5\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3D8 && cp < 0x3F0 && (cp & 1 == 0)) { // Mapped22: 12\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x460 && cp < 0x482 && (cp & 1 == 0)) { // Mapped22: 17\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x48A && cp < 0x4C0 && (cp & 1 == 0)) { // Mapped22: 27\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x1EFE) {\n\t\t\t\t\t\t\t\tif (cp >= 0x4C1 && cp < 0x4CF && (cp & 1 == 0)) { // Mapped22: 7\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x4D0 && cp < 0x530 && (cp & 1 == 0)) { // Mapped22: 48\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1E00 && cp < 0x1E96 && (cp & 1 == 0)) { // Mapped22: 75\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1EA0 && cp < 0x1F00 && (cp & 1 == 0)) { // Mapped22: 48\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x2C67 && cp < 0x2C6D && (cp & 1 == 0)) { // Mapped22: 3\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2C80 && cp < 0x2CE4 && (cp & 1 == 0)) { // Mapped22: 50\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA640 && cp < 0xA66E && (cp & 1 == 0)) { // Mapped22: 23\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA680 && cp < 0xA69C && (cp & 1 == 0)) { // Mapped22: 14\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x210E) {\n\t\t\t\t\t\t\tif (cp <= 0xA786) {\n\t\t\t\t\t\t\t\tif (cp >= 0xA722 && cp < 0xA730 && (cp & 1 == 0)) { // Mapped22: 7\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA732 && cp < 0xA770 && (cp & 1 == 0)) { // Mapped22: 31\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA77E && cp < 0xA788 && (cp & 1 == 0)) { // Mapped22: 5\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xA796 && cp < 0xA7AA && (cp & 1 == 0)) { // Mapped22: 10\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA7B4 && cp < 0xA7C4 && (cp & 1 == 0)) { // Mapped22: 8\n\t\t\t\t\t\t\t\t\tret = cp + 1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2010 && cp <= 0x2015) { // Mapped10: 6\n\t\t\t\t\t\t\t\t\tret = 0x2D;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x210B && cp <= 0x210E) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x68;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0xFB59) {\n\t\t\t\t\t\t\t\tif (cp >= 0x211B && cp <= 0x211D) { // Mapped10: 3\n\t\t\t\t\t\t\t\t\tret = 0x72;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x23BA && cp <= 0x23BD) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x2D;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB52 && cp <= 0xFB55) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x67B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB56 && cp <= 0xFB59) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x67E;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFB5A && cp <= 0xFB5D) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x680;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB5E && cp <= 0xFB61) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x67A;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB62 && cp <= 0xFB65) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x67F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB66 && cp <= 0xFB69) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x679;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cp <= 0xFECC) {\n\t\t\t\t\tif (cp <= 0xFBE7) {\n\t\t\t\t\t\tif (cp <= 0xFB91) {\n\t\t\t\t\t\t\tif (cp <= 0xFB75) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFB6A && cp <= 0xFB6D) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6A4;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB6E && cp <= 0xFB71) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6A6;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB72 && cp <= 0xFB75) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x684;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFB76 && cp <= 0xFB79) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x683;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB7A && cp <= 0xFB7D) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x686;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB7E && cp <= 0xFB81) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x687;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB8E && cp <= 0xFB91) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6A9;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0xFBA3) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFB92 && cp <= 0xFB95) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6AF;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB96 && cp <= 0xFB99) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6B3;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFB9A && cp <= 0xFB9D) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6B1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFBA0 && cp <= 0xFBA3) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6BB;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFBA6 && cp <= 0xFBA9) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6C1;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFBAA && cp <= 0xFBAD) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6BE;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFBD3 && cp <= 0xFBD6) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6AD;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFBE4 && cp <= 0xFBE7) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6D0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0xFEA4) {\n\t\t\t\t\t\t\tif (cp <= 0xFE92) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFBFC && cp <= 0xFBFF) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x6CC;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFE89 && cp <= 0xFE8C) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x626;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFE8F && cp <= 0xFE92) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x628;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFE95 && cp <= 0xFE98) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x62A;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFE99 && cp <= 0xFE9C) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x62B;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFE9D && cp <= 0xFEA0) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x62C;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEA1 && cp <= 0xFEA4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x62D;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0xFEBC) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFEA5 && cp <= 0xFEA8) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x62E;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEB1 && cp <= 0xFEB4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x633;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEB5 && cp <= 0xFEB8) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x634;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEB9 && cp <= 0xFEBC) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x635;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFEBD && cp <= 0xFEC0) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x636;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEC1 && cp <= 0xFEC4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x637;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEC5 && cp <= 0xFEC8) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x638;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEC9 && cp <= 0xFECC) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x639;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (cp <= 0xD7A3) {\n\t\t\t\t\t\tif (cp <= 0xFEE8) {\n\t\t\t\t\t\t\tif (cp <= 0xFED8) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFECD && cp <= 0xFED0) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x63A;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFED1 && cp <= 0xFED4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x641;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFED5 && cp <= 0xFED8) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x642;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0xFED9 && cp <= 0xFEDC) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x643;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEDD && cp <= 0xFEE0) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x644;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEE1 && cp <= 0xFEE4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x645;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEE5 && cp <= 0xFEE8) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x646;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x167F) {\n\t\t\t\t\t\t\t\tif (cp >= 0xFEE9 && cp <= 0xFEEC) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x647;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xFEF1 && cp <= 0xFEF4) { // Mapped10: 4\n\t\t\t\t\t\t\t\t\tret = 0x64A;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2F831 && cp <= 0x2F833) { // Mapped10: 3\n\t\t\t\t\t\t\t\t\tret = 0x537F;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1400 && cp <= 0x167F) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x2801 && cp <= 0x2933) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x3400 && cp <= 0xA48C) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xA4D0 && cp <= 0xA62B) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0xAC00 && cp <= 0xD7A3) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cp <= 0x18CD5) {\n\t\t\t\t\t\t\tif (cp <= 0x1342E) {\n\t\t\t\t\t\t\t\tif (cp >= 0x10600 && cp <= 0x10736) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x11FFF && cp <= 0x12399) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x13000 && cp <= 0x1342E) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x14400 && cp <= 0x14646) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x16800 && cp <= 0x16A38) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x17000 && cp <= 0x187F7) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x18800 && cp <= 0x18CD5) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (cp <= 0x2A6DF) {\n\t\t\t\t\t\t\t\tif (cp >= 0x1B000 && cp <= 0x1B122) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1B170 && cp <= 0x1B2FB) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x1D800 && cp <= 0x1DA8B) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x20000 && cp <= 0x2A6DF) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (cp >= 0x2A700 && cp <= 0x2B738) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2B820 && cp <= 0x2CEA1) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x2CEB0 && cp <= 0x2EBE0) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t} else if (cp >= 0x30000 && cp <= 0x3134A) { // Valid\n\t\t\t\t\t\t\t\t\tret = cp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
39     },
40     "hardhat/console.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
42     },
43     "@openzeppelin/contracts/utils/Address.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
45     },
46     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
48     },
49     "solady/src/utils/SafeTransferLib.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(\n        address to,\n        uint256 amount,\n        uint256 gasStipend\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // We don't check and revert upon failure here, just in case\n                // `SELFDESTRUCT`'s behavior is changed some day in the future.\n                // (If that ever happens, we will riot, and port the code to use WETH).\n                pop(create(amount, 0x0b, 0x16))\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overriden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // We don't check and revert upon failure here, just in case\n                // `SELFDESTRUCT`'s behavior is changed some day in the future.\n                // (If that ever happens, we will riot, and port the code to use WETH).\n                pop(create(amount, 0x0b, 0x16))\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(\n        address to,\n        uint256 amount,\n        uint256 gasStipend\n    ) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x23b872dd)\n            mstore(0x20, from) // Append the \"from\" argument.\n            mstore(0x40, to) // Append the \"to\" argument.\n            mstore(0x60, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0xa9059cbb)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x095ea7b3)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n}\n"
51     },
52     "solady/src/utils/LibString.sol": {
53       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            // prettier-ignore\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                // prettier-ignore\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                // prettier-ignore\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                // prettier-ignore\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    // prettier-ignore\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(\n        string memory subject,\n        string memory search,\n        string memory replacement\n    ) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        // prettier-ignore\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            // prettier-ignore\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // prettier-ignore\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)    \n                \n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                // prettier-ignore\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    // prettier-ignore\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        // prettier-ignore\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) {\n                    from := fromMax\n                }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                // prettier-ignore\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                // prettier-ignore\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    // prettier-ignore\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                // prettier-ignore\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    // prettier-ignore\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    // prettier-ignore\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(\n        string memory subject,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) {\n                end := subjectLength\n            }\n            if iszero(gt(subjectLength, start)) {\n                start := subjectLength\n            }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(31)\n                // Copy the `subject` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(resultLength, 31), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            // prettier-ignore\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)                        \n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    // prettier-ignore\n                    for { let o := and(add(elementLength, 31), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        // prettier-ignore\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 63), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)                        \n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                // prettier-ignore\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(mload(a), 32), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(bLength, 32), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    function toCase(string memory subject, bool toUpper) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 67108863)\n                let w := not(0)\n                // prettier-ignore\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Restore the result.\n                result := mload(0x40)\n                // Stores the string length.\n                mstore(result, length)\n                // Zeroize the slot after the string.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, and(add(last, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // prettier-ignore\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) { \n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue    \n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 31)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // prettier-ignore\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) { // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue    \n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c) \n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) { // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)    \n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes of `a` and `b`.\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\n            )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
54     },
55     "solady/src/utils/DynamicBufferLib.sol": {
56       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for buffers with automatic capacity resizing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DynamicBuffer.sol)\n/// @author Modified from cozyco (https://github.com/samkingco/cozyco/blob/main/contracts/utils/DynamicBuffer.sol)\nlibrary DynamicBufferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Type to represent a dynamic buffer in memory.\n    /// You can directly assign to `data`, and the `append` function will\n    /// take care of the memory allocation.\n    struct DynamicBuffer {\n        bytes data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Appends `data` to `buffer`.\n    function append(DynamicBuffer memory buffer, bytes memory data) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                let w := not(31)\n                let bufferData := mload(buffer)\n                let bufferDataLength := mload(bufferData)\n                let newBufferDataLength := add(mload(data), bufferDataLength)\n                // Some random prime number to multiply `capacity`, so that\n                // we know that the `capacity` is for a dynamic buffer.\n                // Selected to be larger than any memory pointer realistically.\n                let prime := 1621250193422201\n                let capacity := mload(add(bufferData, w))\n\n                // Extract `capacity`, and set it to 0, if it is not a multiple of `prime`.\n                capacity := mul(div(capacity, prime), iszero(mod(capacity, prime)))\n\n                // Expand / Reallocate memory if required.\n                // Note that we need to allocate an exta word for the length, and\n                // and another extra word as a safety word (giving a total of 0x40 bytes).\n                // Without the safety word, the data at the next free memory word can be overwritten,\n                // because the backwards copying can exceed the buffer space used for storage.\n                // prettier-ignore\n                for {} iszero(lt(newBufferDataLength, capacity)) {} {\n                    // Approximately double the memory with a heuristic,\n                    // ensuring more than enough space for the combined data,\n                    // rounding up to the next multiple of 32.\n                    let newCapacity := and(add(capacity, add(or(capacity, newBufferDataLength), 32)), w)\n\n                    // If next word after current buffer is not eligible for use.\n                    if iszero(eq(mload(0x40), add(bufferData, add(0x40, capacity)))) {\n                        // Set the `newBufferData` to point to the word after capacity.\n                        let newBufferData := add(mload(0x40), 0x20)\n                        // Reallocate the memory.\n                        mstore(0x40, add(newBufferData, add(0x40, newCapacity)))\n                        // Store the `newBufferData`.\n                        mstore(buffer, newBufferData)\n                        // Copy `bufferData` one word at a time, backwards.\n                        // prettier-ignore\n                        for { let o := and(add(bufferDataLength, 32), w) } 1 {} {\n                            mstore(add(newBufferData, o), mload(add(bufferData, o)))\n                            o := add(o, w) // `sub(o, 0x20)`.\n                            // prettier-ignore\n                            if iszero(o) { break }\n                        }\n                        // Store the `capacity` multiplied by `prime` in the word before the `length`.\n                        mstore(add(newBufferData, w), mul(prime, newCapacity))\n                        // Assign `newBufferData` to `bufferData`.\n                        bufferData := newBufferData\n                        break\n                    }\n                    // Expand the memory.\n                    mstore(0x40, add(bufferData, add(0x40, newCapacity)))\n                    // Store the `capacity` multiplied by `prime` in the word before the `length`.\n                    mstore(add(bufferData, w), mul(prime, newCapacity))\n                    break\n                }\n                // Initalize `output` to the next empty position in `bufferData`.\n                let output := add(bufferData, bufferDataLength)\n                // Copy `data` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(mload(data), 32), w) } 1 {} {\n                    mstore(add(output, o), mload(add(data, o)))\n                    o := add(o, w)  // `sub(o, 0x20)`.\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the word after the buffer.\n                mstore(add(add(bufferData, 0x20), newBufferDataLength), 0)\n                // Store the `newBufferDataLength`.\n                mstore(bufferData, newBufferDataLength)\n            }\n        }\n    }\n}\n"
57     },
58     "solady/src/utils/SSTORE2.sol": {
59       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        // Note: The assembly block below does not expand the memory.\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, 1)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASZIE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, 1)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), 1, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + 1` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, 1))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where `end + 1` or `start + 1` overflow.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, 1), size)\n        }\n    }\n}\n"
60     },
61     "@ensdomains/ens-contracts/contracts/ethregistrar/IETHRegistrarController.sol": {
62       "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"./IPriceOracle.sol\";\n\ninterface IETHRegistrarController {\n    function rentPrice(string memory, uint256)\n        external\n        returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint32,\n        uint64\n    ) external returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint32,\n        uint64\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}\n"
63     },
64     "@ensdomains/ens-contracts/contracts/utils/ERC20Recoverable.sol": {
65       "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n    @notice Contract is used to recover ERC20 tokens sent to the contract by mistake.\n */\n\ncontract ERC20Recoverable is Ownable {\n    /**\n    @notice Recover ERC20 tokens sent to the contract by mistake.\n    @dev The contract is Ownable and only the owner can call the recover function.\n    @param _to The address to send the tokens to.\n@param _token The address of the ERC20 token to recover\n    @param _amount The amount of tokens to recover.\n */\n    function recoverFunds(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_token).transfer(_to, _amount);\n    }\n}\n"
66     },
67     "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
68       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
69     },
70     "@ensdomains/ens-contracts/contracts/resolvers/profiles/AddrResolver.sol": {
71       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IAddrResolver.sol\";\nimport \"./IAddressResolver.sol\";\n\nabstract contract AddrResolver is\n    IAddrResolver,\n    IAddressResolver,\n    ResolverBase\n{\n    uint256 private constant COIN_TYPE_ETH = 60;\n\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_addresses;\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param a The address to set.\n     */\n    function setAddr(bytes32 node, address a)\n        external\n        virtual\n        authorised(node)\n    {\n        setAddr(node, COIN_TYPE_ETH, addressToBytes(a));\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node)\n        public\n        view\n        virtual\n        override\n        returns (address payable)\n    {\n        bytes memory a = addr(node, COIN_TYPE_ETH);\n        if (a.length == 0) {\n            return payable(0);\n        }\n        return bytesToAddress(a);\n    }\n\n    function setAddr(\n        bytes32 node,\n        uint256 coinType,\n        bytes memory a\n    ) public virtual authorised(node) {\n        emit AddressChanged(node, coinType, a);\n        if (coinType == COIN_TYPE_ETH) {\n            emit AddrChanged(node, bytesToAddress(a));\n        }\n        versionable_addresses[recordVersions[node]][node][coinType] = a;\n    }\n\n    function addr(bytes32 node, uint256 coinType)\n        public\n        view\n        virtual\n        override\n        returns (bytes memory)\n    {\n        return versionable_addresses[recordVersions[node]][node][coinType];\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IAddrResolver).interfaceId ||\n            interfaceID == type(IAddressResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function bytesToAddress(bytes memory b)\n        internal\n        pure\n        returns (address payable a)\n    {\n        require(b.length == 20);\n        assembly {\n            a := div(mload(add(b, 32)), exp(256, 12))\n        }\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        b = new bytes(20);\n        assembly {\n            mstore(add(b, 32), mul(a, exp(256, 12)))\n        }\n    }\n}\n"
72     },
73     "@ensdomains/ens-contracts/contracts/resolvers/Multicallable.sol": {
74       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IMulticallable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract Multicallable is IMulticallable, ERC165 {\n    function _multicall(bytes32 nodehash, bytes[] calldata data)\n        internal\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            if (nodehash != bytes32(0)) {\n                bytes32 txNamehash = bytes32(data[i][4:36]);\n                require(\n                    txNamehash == nodehash,\n                    \"multicall: All records must have a matching namehash\"\n                );\n            }\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            require(success);\n            results[i] = result;\n        }\n        return results;\n    }\n\n    // This function provides an extra security check when called\n    // from priviledged contracts (such as EthRegistrarController)\n    // that can set records on behalf of the node owners\n    function multicallWithNodeCheck(bytes32 nodehash, bytes[] calldata data)\n        external\n        returns (bytes[] memory results)\n    {\n        return _multicall(nodehash, data);\n    }\n\n    function multicall(bytes[] calldata data)\n        public\n        override\n        returns (bytes[] memory results)\n    {\n        return _multicall(bytes32(0), data);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IMulticallable).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
75     },
76     "@ensdomains/ens-contracts/contracts/resolvers/profiles/ABIResolver.sol": {
77       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\nabstract contract ABIResolver is IABIResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(uint256 => bytes))) versionable_abis;\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external virtual authorised(node) {\n        // Content types must be powers of 2\n        require(((contentType - 1) & contentType) == 0);\n\n        versionable_abis[recordVersions[node]][node][contentType] = data;\n        emit ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes)\n        external\n        view\n        virtual\n        override\n        returns (uint256, bytes memory)\n    {\n        mapping(uint256 => bytes) storage abiset = versionable_abis[\n            recordVersions[node]\n        ][node];\n\n        for (\n            uint256 contentType = 1;\n            contentType <= contentTypes;\n            contentType <<= 1\n        ) {\n            if (\n                (contentType & contentTypes) != 0 &&\n                abiset[contentType].length > 0\n            ) {\n                return (contentType, abiset[contentType]);\n            }\n        }\n\n        return (0, bytes(\"\"));\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IABIResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
78     },
79     "@ensdomains/ens-contracts/contracts/resolvers/profiles/InterfaceResolver.sol": {
80       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../ResolverBase.sol\";\nimport \"./AddrResolver.sol\";\nimport \"./IInterfaceResolver.sol\";\n\nabstract contract InterfaceResolver is IInterfaceResolver, AddrResolver {\n    mapping(uint64 => mapping(bytes32 => mapping(bytes4 => address))) versionable_interfaces;\n\n    /**\n     * Sets an interface associated with a name.\n     * Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.\n     * @param node The node to update.\n     * @param interfaceID The EIP 165 interface ID.\n     * @param implementer The address of a contract that implements this interface for this node.\n     */\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external virtual authorised(node) {\n        versionable_interfaces[recordVersions[node]][node][interfaceID] = implementer;\n        emit InterfaceChanged(node, interfaceID, implementer);\n    }\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID)\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address implementer = versionable_interfaces[recordVersions[node]][node][interfaceID];\n        if (implementer != address(0)) {\n            return implementer;\n        }\n\n        address a = addr(node);\n        if (a == address(0)) {\n            return address(0);\n        }\n\n        (bool success, bytes memory returnData) = a.staticcall(\n            abi.encodeWithSignature(\n                \"supportsInterface(bytes4)\",\n                type(IERC165).interfaceId\n            )\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // EIP 165 not supported by target\n            return address(0);\n        }\n\n        (success, returnData) = a.staticcall(\n            abi.encodeWithSignature(\"supportsInterface(bytes4)\", interfaceID)\n        );\n        if (!success || returnData.length < 32 || returnData[31] == 0) {\n            // Specified interface not supported by target\n            return address(0);\n        }\n\n        return a;\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IInterfaceResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
81     },
82     "@ensdomains/ens-contracts/contracts/resolvers/profiles/ContentHashResolver.sol": {
83       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IContentHashResolver.sol\";\n\nabstract contract ContentHashResolver is IContentHashResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => bytes)) versionable_hashes;\n\n    /**\n     * Sets the contenthash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The contenthash to set\n     */\n    function setContenthash(bytes32 node, bytes calldata hash)\n        external\n        virtual\n        authorised(node)\n    {\n        versionable_hashes[recordVersions[node]][node] = hash;\n        emit ContenthashChanged(node, hash);\n    }\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node)\n        external\n        view\n        virtual\n        override\n        returns (bytes memory)\n    {\n        return versionable_hashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IContentHashResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
84     },
85     "@ensdomains/ens-contracts/contracts/resolvers/profiles/PubkeyResolver.sol": {
86       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./IPubkeyResolver.sol\";\n\nabstract contract PubkeyResolver is IPubkeyResolver, ResolverBase {\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    mapping(uint64 => mapping(bytes32 => PublicKey)) versionable_pubkeys;\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(\n        bytes32 node,\n        bytes32 x,\n        bytes32 y\n    ) external virtual authorised(node) {\n        versionable_pubkeys[recordVersions[node]][node] = PublicKey(x, y);\n        emit PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node)\n        external\n        view\n        virtual\n        override\n        returns (bytes32 x, bytes32 y)\n    {\n        uint64 currentRecordVersion = recordVersions[node];\n        return (\n            versionable_pubkeys[currentRecordVersion][node].x,\n            versionable_pubkeys[currentRecordVersion][node].y\n        );\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IPubkeyResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
87     },
88     "@ensdomains/ens-contracts/contracts/resolvers/profiles/DNSResolver.sol": {
89       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"../../dnssec-oracle/RRUtils.sol\";\nimport \"./IDNSRecordResolver.sol\";\nimport \"./IDNSZoneResolver.sol\";\n\nabstract contract DNSResolver is\n    IDNSRecordResolver,\n    IDNSZoneResolver,\n    ResolverBase\n{\n    using RRUtils for *;\n    using BytesUtils for bytes;\n\n    // Zone hashes for the domains.\n    // A zone hash is an EIP-1577 content hash in binary format that should point to a\n    // resource containing a single zonefile.\n    // node => contenthash\n    mapping(uint64 => mapping(bytes32 => bytes)) private versionable_zonehashes;\n\n    // The records themselves.  Stored as binary RRSETs\n    // node => version => name => resource => data\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => mapping(uint16 => bytes))))\n        private versionable_records;\n\n    // Count of number of entries for a given name.  Required for DNS resolvers\n    // when resolving wildcards.\n    // node => version => name => number of records\n    mapping(uint64 => mapping(bytes32 => mapping(bytes32 => uint16)))\n        private versionable_nameEntriesCount;\n\n    /**\n     * Set one or more DNS records.  Records are supplied in wire-format.\n     * Records with the same node/name/resource must be supplied one after the\n     * other to ensure the data is updated correctly. For example, if the data\n     * was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     a.example.com IN A 5.6.7.8\n     *     www.example.com IN CNAME a.example.com.\n     * then this would store the two A records for a.example.com correctly as a\n     * single RRSET, however if the data was supplied:\n     *     a.example.com IN A 1.2.3.4\n     *     www.example.com IN CNAME a.example.com.\n     *     a.example.com IN A 5.6.7.8\n     * then this would store the first A record, the CNAME, then the second A\n     * record which would overwrite the first.\n     *\n     * @param node the namehash of the node for which to set the records\n     * @param data the DNS wire format records to set\n     */\n    function setDNSRecords(bytes32 node, bytes calldata data)\n        external\n        virtual\n        authorised(node)\n    {\n        uint16 resource = 0;\n        uint256 offset = 0;\n        bytes memory name;\n        bytes memory value;\n        bytes32 nameHash;\n        uint64 version = recordVersions[node];\n        // Iterate over the data to add the resource records\n        for (\n            RRUtils.RRIterator memory iter = data.iterateRRs(0);\n            !iter.done();\n            iter.next()\n        ) {\n            if (resource == 0) {\n                resource = iter.dnstype;\n                name = iter.name();\n                nameHash = keccak256(abi.encodePacked(name));\n                value = bytes(iter.rdata());\n            } else {\n                bytes memory newName = iter.name();\n                if (resource != iter.dnstype || !name.equals(newName)) {\n                    setDNSRRSet(\n                        node,\n                        name,\n                        resource,\n                        data,\n                        offset,\n                        iter.offset - offset,\n                        value.length == 0,\n                        version\n                    );\n                    resource = iter.dnstype;\n                    offset = iter.offset;\n                    name = newName;\n                    nameHash = keccak256(name);\n                    value = bytes(iter.rdata());\n                }\n            }\n        }\n        if (name.length > 0) {\n            setDNSRRSet(\n                node,\n                name,\n                resource,\n                data,\n                offset,\n                data.length - offset,\n                value.length == 0,\n                version\n            );\n        }\n    }\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) public view virtual override returns (bytes memory) {\n        return versionable_records[recordVersions[node]][node][name][resource];\n    }\n\n    /**\n     * Check if a given node has records.\n     * @param node the namehash of the node for which to check the records\n     * @param name the namehash of the node for which to check the records\n     */\n    function hasDNSRecords(bytes32 node, bytes32 name)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return (versionable_nameEntriesCount[recordVersions[node]][node][\n            name\n        ] != 0);\n    }\n\n    /**\n     * setZonehash sets the hash for the zone.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param hash The zonehash to set\n     */\n    function setZonehash(bytes32 node, bytes calldata hash)\n        external\n        virtual\n        authorised(node)\n    {\n        uint64 currentRecordVersion = recordVersions[node];\n        bytes memory oldhash = versionable_zonehashes[currentRecordVersion][\n            node\n        ];\n        versionable_zonehashes[currentRecordVersion][node] = hash;\n        emit DNSZonehashChanged(node, oldhash, hash);\n    }\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node)\n        external\n        view\n        virtual\n        override\n        returns (bytes memory)\n    {\n        return versionable_zonehashes[recordVersions[node]][node];\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IDNSRecordResolver).interfaceId ||\n            interfaceID == type(IDNSZoneResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n\n    function setDNSRRSet(\n        bytes32 node,\n        bytes memory name,\n        uint16 resource,\n        bytes memory data,\n        uint256 offset,\n        uint256 size,\n        bool deleteRecord,\n        uint64 version\n    ) private {\n        bytes32 nameHash = keccak256(name);\n        bytes memory rrData = data.substring(offset, size);\n        if (deleteRecord) {\n            if (\n                versionable_records[version][node][nameHash][resource].length !=\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]--;\n            }\n            delete (versionable_records[version][node][nameHash][resource]);\n            emit DNSRecordDeleted(node, name, resource);\n        } else {\n            if (\n                versionable_records[version][node][nameHash][resource].length ==\n                0\n            ) {\n                versionable_nameEntriesCount[version][node][nameHash]++;\n            }\n            versionable_records[version][node][nameHash][resource] = rrData;\n            emit DNSRecordChanged(node, name, resource, rrData);\n        }\n    }\n}\n"
90     },
91     "@ensdomains/ens-contracts/contracts/resolvers/profiles/NameResolver.sol": {
92       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./INameResolver.sol\";\n\nabstract contract NameResolver is INameResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => string)) versionable_names;\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function setName(bytes32 node, string calldata newName)\n        external\n        virtual\n        authorised(node)\n    {\n        versionable_names[recordVersions[node]][node] = newName;\n        emit NameChanged(node, newName);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node)\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return versionable_names[recordVersions[node]][node];\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(INameResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
93     },
94     "@ensdomains/ens-contracts/contracts/resolvers/profiles/TextResolver.sol": {
95       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"../ResolverBase.sol\";\nimport \"./ITextResolver.sol\";\n\nabstract contract TextResolver is ITextResolver, ResolverBase {\n    mapping(uint64 => mapping(bytes32 => mapping(string => string))) versionable_texts;\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external virtual authorised(node) {\n        versionable_texts[recordVersions[node]][node][key] = value;\n        emit TextChanged(node, key, key, value);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key)\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return versionable_texts[recordVersions[node]][node][key];\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(ITextResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
96     },
97     "@ensdomains/ens-contracts/contracts/resolvers/ResolverBase.sol": {
98       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./profiles/IVersionableResolver.sol\";\n\nabstract contract ResolverBase is ERC165, IVersionableResolver {\n    mapping(bytes32 => uint64) public recordVersions;\n\n    function isAuthorised(bytes32 node) internal view virtual returns (bool);\n\n    modifier authorised(bytes32 node) {\n        require(isAuthorised(node));\n        _;\n    }\n\n    /**\n     * Increments the record version associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     */\n    function clearRecords(bytes32 node) public virtual authorised(node) {\n        recordVersions[node]++;\n        emit VersionChanged(node, recordVersions[node]);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IVersionableResolver).interfaceId ||\n            super.supportsInterface(interfaceID);\n    }\n}\n"
99     },
100     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
101       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(bytes32 node, uint256 coinType)\n        external\n        view\n        returns (bytes memory);\n}\n"
102     },
103     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
104       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
105     },
106     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
107       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
108     },
109     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IVersionableResolver.sol": {
110       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IVersionableResolver {\n    event VersionChanged(bytes32 indexed node, uint64 newVersion);\n\n    function recordVersions(bytes32 node) external view returns (uint64);\n}\n"
111     },
112     "@ensdomains/ens-contracts/contracts/resolvers/IMulticallable.sol": {
113       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMulticallable {\n    function multicall(bytes[] calldata data)\n        external\n        returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(bytes32, bytes[] calldata data)\n        external\n        returns (bytes[] memory results);\n}\n"
114     },
115     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IABIResolver.sol": {
116       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./IABIResolver.sol\";\nimport \"../ResolverBase.sol\";\n\ninterface IABIResolver {\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes)\n        external\n        view\n        returns (uint256, bytes memory);\n}\n"
117     },
118     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IInterfaceResolver.sol": {
119       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IInterfaceResolver {\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID)\n        external\n        view\n        returns (address);\n}\n"
120     },
121     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol": {
122       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
123     },
124     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IPubkeyResolver.sol": {
125       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IPubkeyResolver {\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}\n"
126     },
127     "@ensdomains/ens-contracts/contracts/dnssec-oracle/RRUtils.sol": {
128       "content": "pragma solidity ^0.8.4;\n\nimport \"./BytesUtils.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n * @dev RRUtils is a library that provides utilities for parsing DNS resource records.\n */\nlibrary RRUtils {\n    using BytesUtils for *;\n    using Buffer for *;\n\n    /**\n     * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The length of the DNS name at 'offset', in bytes.\n     */\n    function nameLength(bytes memory self, uint256 offset)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 idx = offset;\n        while (true) {\n            assert(idx < self.length);\n            uint256 labelLen = self.readUint8(idx);\n            idx += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n        }\n        return idx - offset;\n    }\n\n    /**\n     * @dev Returns a DNS format name at the specified offset of self.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return ret The name.\n     */\n    function readName(bytes memory self, uint256 offset)\n        internal\n        pure\n        returns (bytes memory ret)\n    {\n        uint256 len = nameLength(self, offset);\n        return self.substring(offset, len);\n    }\n\n    /**\n     * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\n     * @param self The byte array to read a name from.\n     * @param offset The offset to start reading at.\n     * @return The number of labels in the DNS name at 'offset', in bytes.\n     */\n    function labelCount(bytes memory self, uint256 offset)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 count = 0;\n        while (true) {\n            assert(offset < self.length);\n            uint256 labelLen = self.readUint8(offset);\n            offset += labelLen + 1;\n            if (labelLen == 0) {\n                break;\n            }\n            count += 1;\n        }\n        return count;\n    }\n\n    uint256 constant RRSIG_TYPE = 0;\n    uint256 constant RRSIG_ALGORITHM = 2;\n    uint256 constant RRSIG_LABELS = 3;\n    uint256 constant RRSIG_TTL = 4;\n    uint256 constant RRSIG_EXPIRATION = 8;\n    uint256 constant RRSIG_INCEPTION = 12;\n    uint256 constant RRSIG_KEY_TAG = 16;\n    uint256 constant RRSIG_SIGNER_NAME = 18;\n\n    struct SignedSet {\n        uint16 typeCovered;\n        uint8 algorithm;\n        uint8 labels;\n        uint32 ttl;\n        uint32 expiration;\n        uint32 inception;\n        uint16 keytag;\n        bytes signerName;\n        bytes data;\n        bytes name;\n    }\n\n    function readSignedSet(bytes memory data)\n        internal\n        pure\n        returns (SignedSet memory self)\n    {\n        self.typeCovered = data.readUint16(RRSIG_TYPE);\n        self.algorithm = data.readUint8(RRSIG_ALGORITHM);\n        self.labels = data.readUint8(RRSIG_LABELS);\n        self.ttl = data.readUint32(RRSIG_TTL);\n        self.expiration = data.readUint32(RRSIG_EXPIRATION);\n        self.inception = data.readUint32(RRSIG_INCEPTION);\n        self.keytag = data.readUint16(RRSIG_KEY_TAG);\n        self.signerName = readName(data, RRSIG_SIGNER_NAME);\n        self.data = data.substring(\n            RRSIG_SIGNER_NAME + self.signerName.length,\n            data.length - RRSIG_SIGNER_NAME - self.signerName.length\n        );\n    }\n\n    function rrs(SignedSet memory rrset)\n        internal\n        pure\n        returns (RRIterator memory)\n    {\n        return iterateRRs(rrset.data, 0);\n    }\n\n    /**\n     * @dev An iterator over resource records.\n     */\n    struct RRIterator {\n        bytes data;\n        uint256 offset;\n        uint16 dnstype;\n        uint16 class;\n        uint32 ttl;\n        uint256 rdataOffset;\n        uint256 nextOffset;\n    }\n\n    /**\n     * @dev Begins iterating over resource records.\n     * @param self The byte string to read from.\n     * @param offset The offset to start reading at.\n     * @return ret An iterator object.\n     */\n    function iterateRRs(bytes memory self, uint256 offset)\n        internal\n        pure\n        returns (RRIterator memory ret)\n    {\n        ret.data = self;\n        ret.nextOffset = offset;\n        next(ret);\n    }\n\n    /**\n     * @dev Returns true iff there are more RRs to iterate.\n     * @param iter The iterator to check.\n     * @return True iff the iterator has finished.\n     */\n    function done(RRIterator memory iter) internal pure returns (bool) {\n        return iter.offset >= iter.data.length;\n    }\n\n    /**\n     * @dev Moves the iterator to the next resource record.\n     * @param iter The iterator to advance.\n     */\n    function next(RRIterator memory iter) internal pure {\n        iter.offset = iter.nextOffset;\n        if (iter.offset >= iter.data.length) {\n            return;\n        }\n\n        // Skip the name\n        uint256 off = iter.offset + nameLength(iter.data, iter.offset);\n\n        // Read type, class, and ttl\n        iter.dnstype = iter.data.readUint16(off);\n        off += 2;\n        iter.class = iter.data.readUint16(off);\n        off += 2;\n        iter.ttl = iter.data.readUint32(off);\n        off += 4;\n\n        // Read the rdata\n        uint256 rdataLength = iter.data.readUint16(off);\n        off += 2;\n        iter.rdataOffset = off;\n        iter.nextOffset = off + rdataLength;\n    }\n\n    /**\n     * @dev Returns the name of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the owner name from the RR.\n     */\n    function name(RRIterator memory iter) internal pure returns (bytes memory) {\n        return\n            iter.data.substring(\n                iter.offset,\n                nameLength(iter.data, iter.offset)\n            );\n    }\n\n    /**\n     * @dev Returns the rdata portion of the current record.\n     * @param iter The iterator.\n     * @return A new bytes object containing the RR's RDATA.\n     */\n    function rdata(RRIterator memory iter)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            iter.data.substring(\n                iter.rdataOffset,\n                iter.nextOffset - iter.rdataOffset\n            );\n    }\n\n    uint256 constant DNSKEY_FLAGS = 0;\n    uint256 constant DNSKEY_PROTOCOL = 2;\n    uint256 constant DNSKEY_ALGORITHM = 3;\n    uint256 constant DNSKEY_PUBKEY = 4;\n\n    struct DNSKEY {\n        uint16 flags;\n        uint8 protocol;\n        uint8 algorithm;\n        bytes publicKey;\n    }\n\n    function readDNSKEY(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DNSKEY memory self) {\n        self.flags = data.readUint16(offset + DNSKEY_FLAGS);\n        self.protocol = data.readUint8(offset + DNSKEY_PROTOCOL);\n        self.algorithm = data.readUint8(offset + DNSKEY_ALGORITHM);\n        self.publicKey = data.substring(\n            offset + DNSKEY_PUBKEY,\n            length - DNSKEY_PUBKEY\n        );\n    }\n\n    uint256 constant DS_KEY_TAG = 0;\n    uint256 constant DS_ALGORITHM = 2;\n    uint256 constant DS_DIGEST_TYPE = 3;\n    uint256 constant DS_DIGEST = 4;\n\n    struct DS {\n        uint16 keytag;\n        uint8 algorithm;\n        uint8 digestType;\n        bytes digest;\n    }\n\n    function readDS(\n        bytes memory data,\n        uint256 offset,\n        uint256 length\n    ) internal pure returns (DS memory self) {\n        self.keytag = data.readUint16(offset + DS_KEY_TAG);\n        self.algorithm = data.readUint8(offset + DS_ALGORITHM);\n        self.digestType = data.readUint8(offset + DS_DIGEST_TYPE);\n        self.digest = data.substring(offset + DS_DIGEST, length - DS_DIGEST);\n    }\n\n    function compareNames(bytes memory self, bytes memory other)\n        internal\n        pure\n        returns (int256)\n    {\n        if (self.equals(other)) {\n            return 0;\n        }\n\n        uint256 off;\n        uint256 otheroff;\n        uint256 prevoff;\n        uint256 otherprevoff;\n        uint256 counts = labelCount(self, 0);\n        uint256 othercounts = labelCount(other, 0);\n\n        // Keep removing labels from the front of the name until both names are equal length\n        while (counts > othercounts) {\n            prevoff = off;\n            off = progress(self, off);\n            counts--;\n        }\n\n        while (othercounts > counts) {\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            othercounts--;\n        }\n\n        // Compare the last nonequal labels to each other\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\n            prevoff = off;\n            off = progress(self, off);\n            otherprevoff = otheroff;\n            otheroff = progress(other, otheroff);\n            counts -= 1;\n        }\n\n        if (off == 0) {\n            return -1;\n        }\n        if (otheroff == 0) {\n            return 1;\n        }\n\n        return\n            self.compare(\n                prevoff + 1,\n                self.readUint8(prevoff),\n                other,\n                otherprevoff + 1,\n                other.readUint8(otherprevoff)\n            );\n    }\n\n    /**\n     * @dev Compares two serial numbers using RFC1982 serial number math.\n     */\n    function serialNumberGte(uint32 i1, uint32 i2)\n        internal\n        pure\n        returns (bool)\n    {\n        return int32(i1) - int32(i2) >= 0;\n    }\n\n    function progress(bytes memory body, uint256 off)\n        internal\n        pure\n        returns (uint256)\n    {\n        return off + 1 + body.readUint8(off);\n    }\n\n    /**\n     * @dev Computes the keytag for a chunk of data.\n     * @param data The data to compute a keytag for.\n     * @return The computed key tag.\n     */\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\n        /* This function probably deserves some explanation.\n         * The DNSSEC keytag function is a checksum that relies on summing up individual bytes\n         * from the input string, with some mild bitshifting. Here's a Naive solidity implementation:\n         *\n         *     function computeKeytag(bytes memory data) internal pure returns (uint16) {\n         *         uint ac;\n         *         for (uint i = 0; i < data.length; i++) {\n         *             ac += i & 1 == 0 ? uint16(data.readUint8(i)) << 8 : data.readUint8(i);\n         *         }\n         *         return uint16(ac + (ac >> 16));\n         *     }\n         *\n         * The EVM, with its 256 bit words, is exceedingly inefficient at doing byte-by-byte operations;\n         * the code above, on reasonable length inputs, consumes over 100k gas. But we can make the EVM's\n         * large words work in our favour.\n         *\n         * The code below works by treating the input as a series of 256 bit words. It first masks out\n         * even and odd bytes from each input word, adding them to two separate accumulators `ac1` and `ac2`.\n         * The bytes are separated by empty bytes, so as long as no individual sum exceeds 2^16-1, we're\n         * effectively summing 16 different numbers with each EVM ADD opcode.\n         *\n         * Once it's added up all the inputs, it has to add all the 16 bit values in `ac1` and `ac2` together.\n         * It does this using the same trick - mask out every other value, shift to align them, add them together.\n         * After the first addition on both accumulators, there's enough room to add the two accumulators together,\n         * and the remaining sums can be done just on ac1.\n         */\n        unchecked {\n            require(data.length <= 8192, \"Long keys not permitted\");\n            uint256 ac1;\n            uint256 ac2;\n            for (uint256 i = 0; i < data.length + 31; i += 32) {\n                uint256 word;\n                assembly {\n                    word := mload(add(add(data, 32), i))\n                }\n                if (i + 32 > data.length) {\n                    uint256 unused = 256 - (data.length - i) * 8;\n                    word = (word >> unused) << unused;\n                }\n                ac1 +=\n                    (word &\n                        0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >>\n                    8;\n                ac2 += (word &\n                    0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF);\n            }\n            ac1 =\n                (ac1 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac1 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac2 =\n                (ac2 &\n                    0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) +\n                ((ac2 &\n                    0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >>\n                    16);\n            ac1 = (ac1 << 8) + ac2;\n            ac1 =\n                (ac1 &\n                    0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >>\n                    32);\n            ac1 =\n                (ac1 &\n                    0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) +\n                ((ac1 &\n                    0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >>\n                    64);\n            ac1 =\n                (ac1 &\n                    0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) +\n                (ac1 >> 128);\n            ac1 += (ac1 >> 16) & 0xFFFF;\n            return uint16(ac1);\n        }\n    }\n}\n"
129     },
130     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSZoneResolver.sol": {
131       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSZoneResolver {\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}\n"
132     },
133     "@ensdomains/ens-contracts/contracts/resolvers/profiles/IDNSRecordResolver.sol": {
134       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IDNSRecordResolver {\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}\n"
135     },
136     "@ensdomains/buffer/contracts/Buffer.sol": {
137       "content": "pragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            mstore(0x40, add(32, add(ptr, capacity)))\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    function max(uint a, uint b) private pure returns(uint) {\n        if (a > b) {\n            return a;\n        }\n        return b;\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The start offset to write to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        if (off + len > buf.capacity) {\n            resize(buf, max(buf.capacity, len + off) * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(add(len, off), buflen) {\n                mstore(bufptr, add(len, off))\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, len);\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, data.length);\n    }\n\n    /**\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write the byte at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n        if (off >= buf.capacity) {\n            resize(buf, buf.capacity * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if eq(off, buflen) {\n                mstore(bufptr, add(buflen, 1))\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        return writeUint8(buf, buf.buf.length, data);\n    }\n\n    /**\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + off + len\n                let dest := add(add(bufptr, off), len)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(add(off, len), mload(bufptr)) {\n                    mstore(bufptr, add(off, len))\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, off, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return write(buf, buf.buf.length, data, 32);\n    }\n\n    /**\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param off The offset to write at.\n    * @param data The data to append.\n    * @param len The number of bytes to write (right-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n        if (len + off > buf.capacity) {\n            resize(buf, (len + off) * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + off + sizeof(buffer length) + len\n            let dest := add(add(bufptr, off), len)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(add(off, len), mload(bufptr)) {\n                mstore(bufptr, add(off, len))\n            }\n        }\n        return buf;\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     * exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        return writeInt(buf, buf.buf.length, data, len);\n    }\n}\n"
138     },
139     "@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol": {
140       "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal.\n     * @param self The first bytes to compare.\n     * @param other The second bytes to compare.\n     * @return The result of the comparison.\n     */\n    function compare(bytes memory self, bytes memory other)\n        internal\n        pure\n        returns (int256)\n    {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first bytes to compare.\n     * @param offset The offset of self.\n     * @param len    The length of self.\n     * @param other The second bytes to compare.\n     * @param otheroffset The offset of the other string.\n     * @param otherlen    The length of the other string.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest > 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2**(8 * (32 - shortest + idx)) - 1);\n                }\n                int256 diff = int256(a & mask) - int256(b & mask);\n                if (diff != 0) return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @param len The number of bytes to compare\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal with offsets.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\n     *      they are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length >= offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(bytes memory self, bytes memory other)\n        internal\n        pure\n        returns (bool)\n    {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n     * @dev Returns the 8-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 8 bits of the string, interpreted as an integer.\n     */\n    function readUint8(bytes memory self, uint256 idx)\n        internal\n        pure\n        returns (uint8 ret)\n    {\n        return uint8(self[idx]);\n    }\n\n    /*\n     * @dev Returns the 16-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 16 bits of the string, interpreted as an integer.\n     */\n    function readUint16(bytes memory self, uint256 idx)\n        internal\n        pure\n        returns (uint16 ret)\n    {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bits of the string, interpreted as an integer.\n     */\n    function readUint32(bytes memory self, uint256 idx)\n        internal\n        pure\n        returns (uint32 ret)\n    {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes32(bytes memory self, uint256 idx)\n        internal\n        pure\n        returns (bytes32 ret)\n    {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes20(bytes memory self, uint256 idx)\n        internal\n        pure\n        returns (bytes20 ret)\n    {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(\n                mload(add(add(self, 32), idx)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\n            )\n        }\n    }\n\n    /*\n     * @dev Returns the n byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes.\n     * @param len The number of bytes.\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytesN(\n        bytes memory self,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256**(32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n     * @dev Copies a substring into a new byte string.\n     * @param self The byte string to copy from.\n     * @param offset The offset to start copying at.\n     * @param len The number of bytes to copy.\n     */\n    function substring(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(\n        bytes memory self,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at\n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(\n        bytes memory self,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 idx = off; idx < off + len; idx++) {\n            if (self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
141     },
142     "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {
143       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
144     },
145     "@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol": {
146       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string calldata key)\n        external\n        view\n        returns (string memory);\n}\n"
147     },
148     "@ensdomains/ens-contracts/contracts/registry/IReverseRegistrar.sol": {
149       "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(address owner, address resolver)\n        external\n        returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
150     },
151     "@ensdomains/ens-contracts/contracts/root/Controllable.sol": {
152       "content": "pragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Controllable is Ownable {\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController() {\n        require(\n            controllers[msg.sender],\n            \"Controllable: Caller is not a controller\"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}\n"
153     },
154     "@openzeppelin/contracts/utils/Context.sol": {
155       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
156     },
157     "@ensdomains/ens-contracts/contracts/ethregistrar/IPriceOracle.sol": {
158       "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.17 <0.9.0;\n\ninterface IPriceOracle {\n    struct Price {\n        uint256 base;\n        uint256 premium;\n    }\n\n    /**\n     * @dev Returns the price to register or renew a name.\n     * @param name The name being registered or renewed.\n     * @param expires When the name presently expires (0 if this is a new registration).\n     * @param duration How long the name is being registered or extended for, in seconds.\n     * @return base premium tuple of base price + premium price\n     */\n    function price(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view returns (Price calldata);\n}\n"
159     },
160     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
161       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
162     },
163     "contracts/BokkyPooBahsDateTimeLibrary.sol": {
164       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
165     },
166     "solady/src/utils/Base64.sol": {
167       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(\n        bytes memory data,\n        bool fileSafe,\n        bool noPadding\n    ) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                // prettier-ignore\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                let r := mod(dataLength, 3)\n\n                switch noPadding\n                case 0 {\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n                    // Write the length of the string.\n                    mstore(result, encodedLength)\n                }\n                default {\n                    // Write the length of the string.\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Encodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let end := add(data, dataLength)\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                switch and(dataLength, 3)\n                case 0 {\n                    // If padded.\n                    decodedLength := sub(\n                        decodedLength,\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\n                    )\n                }\n                default {\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                }\n\n                result := mload(0x40)\n\n                // Write the length of the string.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                // prettier-ignore\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n                    \n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 32 + 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\n\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"
168     },
169     "@openzeppelin/contracts/utils/Strings.sol": {
170       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
171     },
172     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
173       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
174     },
175     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
176       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
177     },
178     "@openzeppelin/contracts/utils/math/Math.sol": {
179       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
180     }
181   },
182   "settings": {
183     "optimizer": {
184       "enabled": true,
185       "runs": 200,
186       "details": {
187         "yul": false
188       }
189     },
190     "outputSelection": {
191       "*": {
192         "*": [
193           "evm.bytecode",
194           "evm.deployedBytecode",
195           "devdoc",
196           "userdoc",
197           "metadata",
198           "abi"
199         ]
200       }
201     },
202     "metadata": {
203       "useLiteralContent": true
204     },
205     "libraries": {}
206   }
207 }}