1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 pragma solidity ^0.4.23;
20 
21 
22 /**
23  * @title ERC20Basic
24  * @dev Simpler version of ERC20 interface
25  * @dev see https://github.com/ethereum/EIPs/issues/179
26  */
27 contract ERC20Basic {
28   function totalSupply() public view returns (uint256);
29   function balanceOf(address who) public view returns (uint256);
30   function transfer(address to, uint256 value) public returns (bool);
31   event Transfer(address indexed from, address indexed to, uint256 value);
32 }
33 
34 
35 
36 /**
37  * @title SafeMath
38  * @dev Math operations with safety checks that throw on error
39  */
40 library SafeMath {
41 
42   /**
43   * @dev Multiplies two numbers, throws on overflow.
44   */
45   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
46     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
47     // benefit is lost if 'b' is also tested.
48     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
49     if (a == 0) {
50       return 0;
51     }
52 
53     c = a * b;
54     assert(c / a == b);
55     return c;
56   }
57 
58   /**
59   * @dev Integer division of two numbers, truncating the quotient.
60   */
61   function div(uint256 a, uint256 b) internal pure returns (uint256) {
62     // assert(b > 0); // Solidity automatically throws when dividing by 0
63     // uint256 c = a / b;
64     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
65     return a / b;
66   }
67 
68   /**
69   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
70   */
71   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
72     assert(b <= a);
73     return a - b;
74   }
75 
76   /**
77   * @dev Adds two numbers, throws on overflow.
78   */
79   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
80     c = a + b;
81     assert(c >= a);
82     return c;
83   }
84 }
85 
86 
87 
88 /**
89  * @title Basic token
90  * @dev Basic version of StandardToken, with no allowances.
91  */
92 contract BasicToken is ERC20Basic {
93   using SafeMath for uint256;
94 
95   mapping(address => uint256) balances;
96 
97   uint256 totalSupply_;
98 
99   /**
100   * @dev total number of tokens in existence
101   */
102   function totalSupply() public view returns (uint256) {
103     return totalSupply_;
104   }
105 
106   /**
107   * @dev transfer token for a specified address
108   * @param _to The address to transfer to.
109   * @param _value The amount to be transferred.
110   */
111   function transfer(address _to, uint256 _value) public returns (bool) {
112     require(_to != address(0));
113     require(_value <= balances[msg.sender]);
114 
115     balances[msg.sender] = balances[msg.sender].sub(_value);
116     balances[_to] = balances[_to].add(_value);
117     emit Transfer(msg.sender, _to, _value);
118     return true;
119   }
120 
121   /**
122   * @dev Gets the balance of the specified address.
123   * @param _owner The address to query the the balance of.
124   * @return An uint256 representing the amount owned by the passed address.
125   */
126   function balanceOf(address _owner) public view returns (uint256) {
127     return balances[_owner];
128   }
129 
130 }
131 
132 
133 /**
134  * @title ERC20 interface
135  * @dev see https://github.com/ethereum/EIPs/issues/20
136  */
137 contract ERC20 is ERC20Basic {
138   function allowance(address owner, address spender)
139     public view returns (uint256);
140 
141   function transferFrom(address from, address to, uint256 value)
142     public returns (bool);
143 
144   function approve(address spender, uint256 value) public returns (bool);
145   event Approval(
146     address indexed owner,
147     address indexed spender,
148     uint256 value
149   );
150 }
151 
152 
153 /**
154  * @title Standard ERC20 token
155  *
156  * @dev Implementation of the basic standard token.
157  * @dev https://github.com/ethereum/EIPs/issues/20
158  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
159  */
160 contract StandardToken is ERC20, BasicToken {
161 
162   mapping (address => mapping (address => uint256)) internal allowed;
163 
164 
165   /**
166    * @dev Transfer tokens from one address to another
167    * @param _from address The address which you want to send tokens from
168    * @param _to address The address which you want to transfer to
169    * @param _value uint256 the amount of tokens to be transferred
170    */
171   function transferFrom(
172     address _from,
173     address _to,
174     uint256 _value
175   )
176     public
177     returns (bool)
178   {
179     require(_to != address(0));
180     require(_value <= balances[_from]);
181     require(_value <= allowed[_from][msg.sender]);
182 
183     balances[_from] = balances[_from].sub(_value);
184     balances[_to] = balances[_to].add(_value);
185     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
186     emit Transfer(_from, _to, _value);
187     return true;
188   }
189 
190   /**
191    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
192    *
193    * Beware that changing an allowance with this method brings the risk that someone may use both the old
194    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
195    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
196    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
197    * @param _spender The address which will spend the funds.
198    * @param _value The amount of tokens to be spent.
199    */
200   function approve(address _spender, uint256 _value) public returns (bool) {
201     allowed[msg.sender][_spender] = _value;
202     emit Approval(msg.sender, _spender, _value);
203     return true;
204   }
205 
206   /**
207    * @dev Function to check the amount of tokens that an owner allowed to a spender.
208    * @param _owner address The address which owns the funds.
209    * @param _spender address The address which will spend the funds.
210    * @return A uint256 specifying the amount of tokens still available for the spender.
211    */
212   function allowance(
213     address _owner,
214     address _spender
215    )
216     public
217     view
218     returns (uint256)
219   {
220     return allowed[_owner][_spender];
221   }
222 
223   /**
224    * @dev Increase the amount of tokens that an owner allowed to a spender.
225    *
226    * approve should be called when allowed[_spender] == 0. To increment
227    * allowed value is better to use this function to avoid 2 calls (and wait until
228    * the first transaction is mined)
229    * From MonolithDAO Token.sol
230    * @param _spender The address which will spend the funds.
231    * @param _addedValue The amount of tokens to increase the allowance by.
232    */
233   function increaseApproval(
234     address _spender,
235     uint _addedValue
236   )
237     public
238     returns (bool)
239   {
240     allowed[msg.sender][_spender] = (
241       allowed[msg.sender][_spender].add(_addedValue));
242     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
243     return true;
244   }
245 
246   /**
247    * @dev Decrease the amount of tokens that an owner allowed to a spender.
248    *
249    * approve should be called when allowed[_spender] == 0. To decrement
250    * allowed value is better to use this function to avoid 2 calls (and wait until
251    * the first transaction is mined)
252    * From MonolithDAO Token.sol
253    * @param _spender The address which will spend the funds.
254    * @param _subtractedValue The amount of tokens to decrease the allowance by.
255    */
256   function decreaseApproval(
257     address _spender,
258     uint _subtractedValue
259   )
260     public
261     returns (bool)
262   {
263     uint oldValue = allowed[msg.sender][_spender];
264     if (_subtractedValue > oldValue) {
265       allowed[msg.sender][_spender] = 0;
266     } else {
267       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
268     }
269     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
270     return true;
271   }
272 
273 }
274 
275 
276 
277 /**
278  * @title Ownable
279  * @dev The Ownable contract has an owner address, and provides basic authorization control
280  * functions, this simplifies the implementation of "user permissions".
281  */
282 contract Ownable {
283   address public owner;
284 
285 
286   event OwnershipRenounced(address indexed previousOwner);
287   event OwnershipTransferred(
288     address indexed previousOwner,
289     address indexed newOwner
290   );
291 
292 
293   /**
294    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
295    * account.
296    */
297   constructor() public {
298     owner = msg.sender;
299   }
300 
301   /**
302    * @dev Throws if called by any account other than the owner.
303    */
304   modifier onlyOwner() {
305     require(msg.sender == owner);
306     _;
307   }
308 
309   /**
310    * @dev Allows the current owner to relinquish control of the contract.
311    */
312   function renounceOwnership() public onlyOwner {
313     emit OwnershipRenounced(owner);
314     owner = address(0);
315   }
316 
317   /**
318    * @dev Allows the current owner to transfer control of the contract to a newOwner.
319    * @param _newOwner The address to transfer ownership to.
320    */
321   function transferOwnership(address _newOwner) public onlyOwner {
322     _transferOwnership(_newOwner);
323   }
324 
325   /**
326    * @dev Transfers control of the contract to a newOwner.
327    * @param _newOwner The address to transfer ownership to.
328    */
329   function _transferOwnership(address _newOwner) internal {
330     require(_newOwner != address(0));
331     emit OwnershipTransferred(owner, _newOwner);
332     owner = _newOwner;
333   }
334 }
335 
336 
337 
338 /**
339  * Utility library of inline functions on addresses
340  */
341 library AddressUtils {
342 
343   /**
344    * Returns whether the target address is a contract
345    * @dev This function will return false if invoked during the constructor of a contract,
346    *  as the code is not actually created until after the constructor finishes.
347    * @param addr address to check
348    * @return whether the target address is a contract
349    */
350   function isContract(address addr) internal view returns (bool) {
351     uint256 size;
352     // XXX Currently there is no better way to check if there is a contract in an address
353     // than to check the size of the code at that address.
354     // See https://ethereum.stackexchange.com/a/14016/36603
355     // for more details about how this works.
356     // TODO Check this again before the Serenity release, because all addresses will be
357     // contracts then.
358     // solium-disable-next-line security/no-inline-assembly
359     assembly { size := extcodesize(addr) }
360     return size > 0;
361   }
362 
363 }
364 
365 
366 contract ERC223Basic is ERC20Basic {
367     function transfer(address to, uint value, bytes data) public returns (bool);
368     event Transfer(address indexed from, address indexed to, uint indexed value, bytes data);
369 }
370 
371 
372 
373 /**
374 * @title Contract that will work with ERC223 tokens.
375 */
376 contract ERC223Receiver {
377     /**
378      * @dev Standard ERC223 function that will handle incoming token transfers.
379      *
380      * @param _from  Token sender address.
381      * @param _value Amount of tokens.
382      * @param _data  Transaction metadata.
383      */
384     function tokenFallback(address _from, uint _value, bytes _data) public;
385 }
386 
387 
388 /**
389  * @title Mintable token
390  * @dev Simple ERC20 Token example, with mintable token creation
391  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
392  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
393  */
394 contract MintableToken is StandardToken, Ownable {
395   event Mint(address indexed to, uint256 amount);
396   event MintFinished();
397 
398   bool public mintingFinished = false;
399 
400 
401   modifier canMint() {
402     require(!mintingFinished);
403     _;
404   }
405 
406   modifier hasMintPermission() {
407     require(msg.sender == owner);
408     _;
409   }
410 
411   /**
412    * @dev Function to mint tokens
413    * @param _to The address that will receive the minted tokens.
414    * @param _amount The amount of tokens to mint.
415    * @return A boolean that indicates if the operation was successful.
416    */
417   function mint(
418     address _to,
419     uint256 _amount
420   )
421     hasMintPermission
422     canMint
423     public
424     returns (bool)
425   {
426     totalSupply_ = totalSupply_.add(_amount);
427     balances[_to] = balances[_to].add(_amount);
428     emit Mint(_to, _amount);
429     emit Transfer(address(0), _to, _amount);
430     return true;
431   }
432 
433   /**
434    * @dev Function to stop minting new tokens.
435    * @return True if the operation was successful.
436    */
437   function finishMinting() onlyOwner canMint public returns (bool) {
438     mintingFinished = true;
439     emit MintFinished();
440     return true;
441   }
442 }
443 
444 
445 /**
446  * @title Reference implementation of the ERC223 standard token.
447  */
448 contract ERC223Token is ERC223Basic, BasicToken, ERC223Receiver {
449     using SafeMath for uint;
450     using AddressUtils for address;
451 
452     /**
453      * @dev Token should not accept tokens
454      */
455     function tokenFallback(address, uint, bytes) public {
456         revert();
457     }
458 
459     /**
460      * @dev Transfer the specified amount of tokens to the specified address.
461      *      Invokes the `tokenFallback` function if the recipient is a contract.
462      *      The token transfer fails if the recipient is a contract
463      *      but does not implement the `tokenFallback` function
464      *      or the fallback function to receive funds.
465      *
466      * @param _to    Receiver address.
467      * @param _value Amount of tokens that will be transferred.
468      * @param _data  Transaction metadata.
469      */
470     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
471         // Standard function transfer similar to ERC20 transfer with no _data .
472         // Added due to backwards compatibility reasons .
473         balances[msg.sender] = balances[msg.sender].sub(_value);
474         balances[_to] = balances[_to].add(_value);
475         if (_to.isContract()) {
476             ERC223Receiver receiver = ERC223Receiver(_to);
477             receiver.tokenFallback(msg.sender, _value, _data);
478         }
479         emit Transfer(msg.sender, _to, _value, _data);
480         return true;
481     }
482 
483     /**
484      * @dev Transfer the specified amount of tokens to the specified address.
485      *      This function works the same with the previous one
486      *      but doesn't contain `_data` param.
487      *      Added due to backwards compatibility reasons.
488      *
489      * @param _to    Receiver address.
490      * @param _value Amount of tokens that will be transferred.
491      */
492     function transfer(address _to, uint256 _value) public returns (bool) {
493         bytes memory empty;
494         return transfer(_to, _value, empty);
495     }
496 }
497 
498 
499 contract FreezableToken is StandardToken {
500     // freezing chains
501     mapping (bytes32 => uint64) internal chains;
502     // freezing amounts for each chain
503     mapping (bytes32 => uint) internal freezings;
504     // total freezing balance per address
505     mapping (address => uint) internal freezingBalance;
506 
507     event Freezed(address indexed to, uint64 release, uint amount);
508     event Released(address indexed owner, uint amount);
509 
510     /**
511      * @dev Gets the balance of the specified address include freezing tokens.
512      * @param _owner The address to query the the balance of.
513      * @return An uint256 representing the amount owned by the passed address.
514      */
515     function balanceOf(address _owner) public view returns (uint256 balance) {
516         return super.balanceOf(_owner) + freezingBalance[_owner];
517     }
518 
519     /**
520      * @dev Gets the balance of the specified address without freezing tokens.
521      * @param _owner The address to query the the balance of.
522      * @return An uint256 representing the amount owned by the passed address.
523      */
524     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
525         return super.balanceOf(_owner);
526     }
527 
528     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
529         return freezingBalance[_owner];
530     }
531 
532     /**
533      * @dev gets freezing count
534      * @param _addr Address of freeze tokens owner.
535      */
536     function freezingCount(address _addr) public view returns (uint count) {
537         uint64 release = chains[toKey(_addr, 0)];
538         while (release != 0) {
539             count++;
540             release = chains[toKey(_addr, release)];
541         }
542     }
543 
544     /**
545      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
546      * @param _addr Address of freeze tokens owner.
547      * @param _index Freezing portion index. It ordered by release date descending.
548      */
549     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
550         for (uint i = 0; i < _index + 1; i++) {
551             _release = chains[toKey(_addr, _release)];
552             if (_release == 0) {
553                 return;
554             }
555         }
556         _balance = freezings[toKey(_addr, _release)];
557     }
558 
559     /**
560      * @dev freeze your tokens to the specified address.
561      *      Be careful, gas usage is not deterministic,
562      *      and depends on how many freezes _to address already has.
563      * @param _to Address to which token will be freeze.
564      * @param _amount Amount of token to freeze.
565      * @param _until Release date, must be in future.
566      */
567     function freezeTo(address _to, uint _amount, uint64 _until) public {
568         require(_to != address(0));
569         require(_amount <= balances[msg.sender]);
570 
571         balances[msg.sender] = balances[msg.sender].sub(_amount);
572 
573         bytes32 currentKey = toKey(_to, _until);
574         freezings[currentKey] = freezings[currentKey].add(_amount);
575         freezingBalance[_to] = freezingBalance[_to].add(_amount);
576 
577         freeze(_to, _until);
578         emit Transfer(msg.sender, _to, _amount);
579         emit Freezed(_to, _until, _amount);
580     }
581 
582     /**
583      * @dev release first available freezing tokens.
584      */
585     function releaseOnce() public {
586         bytes32 headKey = toKey(msg.sender, 0);
587         uint64 head = chains[headKey];
588         require(head != 0);
589         require(uint64(block.timestamp) > head);
590         bytes32 currentKey = toKey(msg.sender, head);
591 
592         uint64 next = chains[currentKey];
593 
594         uint amount = freezings[currentKey];
595         delete freezings[currentKey];
596 
597         balances[msg.sender] = balances[msg.sender].add(amount);
598         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
599 
600         if (next == 0) {
601             delete chains[headKey];
602         } else {
603             chains[headKey] = next;
604             delete chains[currentKey];
605         }
606         emit Released(msg.sender, amount);
607     }
608 
609     /**
610      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
611      * @return how many tokens was released
612      */
613     function releaseAll() public returns (uint tokens) {
614         uint release;
615         uint balance;
616         (release, balance) = getFreezing(msg.sender, 0);
617         while (release != 0 && block.timestamp > release) {
618             releaseOnce();
619             tokens += balance;
620             (release, balance) = getFreezing(msg.sender, 0);
621         }
622     }
623 
624     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
625         // WISH masc to increase entropy
626         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
627         assembly {
628             result := or(result, mul(_addr, 0x10000000000000000))
629             result := or(result, _release)
630         }
631     }
632 
633     function freeze(address _to, uint64 _until) internal {
634         require(_until > block.timestamp);
635         bytes32 key = toKey(_to, _until);
636         bytes32 parentKey = toKey(_to, uint64(0));
637         uint64 next = chains[parentKey];
638 
639         if (next == 0) {
640             chains[parentKey] = _until;
641             return;
642         }
643 
644         bytes32 nextKey = toKey(_to, next);
645         uint parent;
646 
647         while (next != 0 && _until > next) {
648             parent = next;
649             parentKey = nextKey;
650 
651             next = chains[nextKey];
652             nextKey = toKey(_to, next);
653         }
654 
655         if (_until == next) {
656             return;
657         }
658 
659         if (next != 0) {
660             chains[key] = next;
661         }
662 
663         chains[parentKey] = _until;
664     }
665 }
666 
667 
668 /**
669  * @title Burnable Token
670  * @dev Token that can be irreversibly burned (destroyed).
671  */
672 contract BurnableToken is BasicToken {
673 
674   event Burn(address indexed burner, uint256 value);
675 
676   /**
677    * @dev Burns a specific amount of tokens.
678    * @param _value The amount of token to be burned.
679    */
680   function burn(uint256 _value) public {
681     _burn(msg.sender, _value);
682   }
683 
684   function _burn(address _who, uint256 _value) internal {
685     require(_value <= balances[_who]);
686     // no need to require value <= totalSupply, since that would imply the
687     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
688 
689     balances[_who] = balances[_who].sub(_value);
690     totalSupply_ = totalSupply_.sub(_value);
691     emit Burn(_who, _value);
692     emit Transfer(_who, address(0), _value);
693   }
694 }
695 
696 
697 
698 /**
699  * @title Pausable
700  * @dev Base contract which allows children to implement an emergency stop mechanism.
701  */
702 contract Pausable is Ownable {
703   event Pause();
704   event Unpause();
705 
706   bool public paused = false;
707 
708 
709   /**
710    * @dev Modifier to make a function callable only when the contract is not paused.
711    */
712   modifier whenNotPaused() {
713     require(!paused);
714     _;
715   }
716 
717   /**
718    * @dev Modifier to make a function callable only when the contract is paused.
719    */
720   modifier whenPaused() {
721     require(paused);
722     _;
723   }
724 
725   /**
726    * @dev called by the owner to pause, triggers stopped state
727    */
728   function pause() onlyOwner whenNotPaused public {
729     paused = true;
730     emit Pause();
731   }
732 
733   /**
734    * @dev called by the owner to unpause, returns to normal state
735    */
736   function unpause() onlyOwner whenPaused public {
737     paused = false;
738     emit Unpause();
739   }
740 }
741 
742 
743 contract ERC223MintableToken is MintableToken, ERC223Token {
744     function mint(
745         address _to,
746         uint256 _amount
747     )
748         hasMintPermission
749         canMint
750         public
751         returns (bool)
752     {
753         bytes memory empty;
754         totalSupply_ = totalSupply_.add(_amount);
755         balances[_to] = balances[_to].add(_amount);
756         if (_to.isContract()) {
757             ERC223Receiver receiver = ERC223Receiver(_to);
758             receiver.tokenFallback(address(this), _amount, empty);
759         }
760         emit Mint(_to, _amount);
761         emit Transfer(msg.sender, _to, _amount, empty);
762         return true;
763     }
764 }
765 
766 
767 contract FreezableMintableToken is FreezableToken, MintableToken {
768     /**
769      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
770      *      Be careful, gas usage is not deterministic,
771      *      and depends on how many freezes _to address already has.
772      * @param _to Address to which token will be freeze.
773      * @param _amount Amount of token to mint and freeze.
774      * @param _until Release date, must be in future.
775      * @return A boolean that indicates if the operation was successful.
776      */
777     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
778         totalSupply_ = totalSupply_.add(_amount);
779 
780         bytes32 currentKey = toKey(_to, _until);
781         freezings[currentKey] = freezings[currentKey].add(_amount);
782         freezingBalance[_to] = freezingBalance[_to].add(_amount);
783 
784         freeze(_to, _until);
785         emit Mint(_to, _amount);
786         emit Freezed(_to, _until, _amount);
787         emit Transfer(msg.sender, _to, _amount);
788         return true;
789     }
790 }
791 
792 
793 
794 contract Consts {
795     uint public constant TOKEN_DECIMALS = 3;
796     uint8 public constant TOKEN_DECIMALS_UINT8 = 3;
797     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
798 
799     string public constant TOKEN_NAME = "GlobalExchangeToken";
800     string public constant TOKEN_SYMBOL = "GEXT";
801     bool public constant PAUSED = false;
802     address public constant TARGET_USER = 0x63Eeb9D8BED8506981fB2c63C5129113b05BBA73;
803     
804     bool public constant CONTINUE_MINTING = true;
805 }
806 
807 
808 
809 
810 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
811     
812     , ERC223MintableToken
813     
814 {
815     
816     event Initialized();
817     bool public initialized = false;
818 
819     constructor() public {
820         init();
821         transferOwnership(TARGET_USER);
822     }
823     
824 
825     function name() public pure returns (string _name) {
826         return TOKEN_NAME;
827     }
828 
829     function symbol() public pure returns (string _symbol) {
830         return TOKEN_SYMBOL;
831     }
832 
833     function decimals() public pure returns (uint8 _decimals) {
834         return TOKEN_DECIMALS_UINT8;
835     }
836 
837     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
838         require(!paused);
839         return super.transferFrom(_from, _to, _value);
840     }
841 
842     function transfer(address _to, uint256 _value) public returns (bool _success) {
843         require(!paused);
844         return super.transfer(_to, _value);
845     }
846 
847     
848     function init() private {
849         require(!initialized);
850         initialized = true;
851 
852         if (PAUSED) {
853             pause();
854         }
855 
856         
857         address[5] memory addresses = [address(0x63eeb9d8bed8506981fb2c63c5129113b05bba73),address(0x8c1614be40d6c05572008a9754f33b476eb9b9b8),address(0xadb73ced5704f331b96f0540f2ad75f72be46eb9),address(0xca4fa333e7ad50343e6edb3820540d6d5230df9f),address(0x9fb59e86e141bc0507d099f0189836e260667142)];
858         uint[5] memory amounts = [uint(1700000000000),uint(50000000000),uint(125000000000),uint(250000000000),uint(375000000000)];
859         uint64[5] memory freezes = [uint64(0),uint64(1580511602),uint64(1556661602),uint64(1580511602),uint64(1580511602)];
860 
861         for (uint i = 0; i < addresses.length; i++) {
862             if (freezes[i] == 0) {
863                 mint(addresses[i], amounts[i]);
864             } else {
865                 mintAndFreeze(addresses[i], amounts[i], freezes[i]);
866             }
867         }
868         
869 
870         if (!CONTINUE_MINTING) {
871             finishMinting();
872         }
873 
874         emit Initialized();
875     }
876     
877 }