1 // SPDX-License-Identifier: MIT
2 
3 
4 
5 
6 //
7 //
8 //
9 // Contract by A.S.
10 //
11 // INK IS MY BLOOD 
12 // 
13 // | I draw for my own sake and for your pleasure | +18 only |
14 // 
15 // 1969 NFT
16 // Free mint
17 // max 2 for tx 
18 //
19 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
20 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
21 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
22 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
23 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
24 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
25 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
26 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
27 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMZMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
28 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMZNDMODMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
29 //MMMMMMMMMMMMMMMMMMMMMMMM~MMMMMMMMMM$Z$+OOMMMMMMMMDMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
30 //MMMMMMMMMMMMMMMMMMMMMMMMINMMMMMMMMDD8Z.O7I7MMMMMMZOMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
31 //MMMMMMMMMMMMMMMMMMMMMMMMMMZZ8MMMMMM7I=$.OZDMMMMMM:ZMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
32 //MMMMMMMMMMMMMMMMMMMMMMMMMMMM7$7MMMMMM: .... MMM.OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
33 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM7Z77=O. . .O  ., ,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
34 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM8$  ,,,:8 .,.NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
35 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM=$+?ZON7=8$MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
36 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMI$~?8DOI+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
37 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM=O8O$IINMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
38 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMI7DI+8MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
39 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM7IO88MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
40 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.=D:+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
41 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM$.8..MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
42 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.$..MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
43 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM$O ,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
44 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.I..MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
45 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM8$.=MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
46 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM   MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
47 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM:~,MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
48 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
49 //MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
50 //IODZD8NMNNNM8MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
51 //  ~:...:?~7=~,.. . ?~I78NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
52 //. ..:I7:..~. . . . . .  .:I7~. =~$OMNDMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
53 //.   .... .  .:..:......,7+~ .  ==, ..,$:  .:,DMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
54 //~~$ .. . .,:  .    .~?+I ,.+~+.: ..... .... ..:$. .++?DNMMMMMMMMMMMMMMMMMMMMMMMM
55 //.   .. .., .....    .......   . .  +I$$$=,~.. . . ....:7  .:7~8MMMMMMMMMMMMMMMMM
56 //...   .. ..=:~:. ,+.   . ...   ... .  ..~ .7..?:~ ,$$$,. .??..?: ..:8MMMMMMMMMMM
57 //   .  .,,I ..+,..      . .,I....     . .~+~..........=~7.III ........7. +8$MNMMM
58 //.,~  . ..:.......   . ..... .:.. .  .   ,:,=~,  .. .  :.  ,+?~,??,$I.+   ..~=.:=
59 //=  ..... .    ..   . .  . . ,..  .. +77......,:,,....:..??=:.~?+O. 7..IO+:+..   
60 //.. .~,~.+..  ...        ......:  .  .   ..  .... ....,=. .   .?$.::II, ~ +7=.7~.
61 //. ,,=   .   . ,.,:.     .   ....,..         .=,,~.. .,,...  .+=,:?..  ,...$7 ,$I
62 //   ....     . . ...., ...    ...I, +~,        ... :.   ...   .==..:. DZO,7=+,?,+
63 // I:~.   .  ,.+:.=,.,..  . .     .. .,,,.=+:I~... :..  ..... . ...,???,:$.:I8IO7?
64 //.....  ..,,..I,..,~ . ..:. . ..     . ,+?~,: .~$ =   :.  .  ..=  ....=~I ~ZZ+.77
65 // +~,7.     .. .,,..... . ~ ..,.. .+.+:=, ?,?$,Z.+.=:,   ,.......,=..$  .,=7,8,:7
66 //,.??.:....       ..$.,....: ~,,, .  .,:.?=,~?=,:.:. ~.. .... =.  . .,I~. ..,~$,+
67 //I=:+,7$?,I..    .. ~:,...,,:,~I...,   ...,..:+,I.,.,..... . :.7,   ...?7+..?~ .=
68 //I77?+?.==8$I+.    .:+~,.,:+,~.=: .~,.+.....~==I.~.. ,..,... O?.... Z., Z$.I,.77.
69 //Z+$77Z~+=,.?. .    .. ..:,,,I., .,. .+.....,.,..... .  ..  .:??..7. ,~.$$$ . .,=
70 //
71 //
72 //
73 //
74 //
75 //
76 //
77 //
78 //
79 //
80 //
81 //
82 //
83 //
84 //
85 //
86 //
87 //
88 //
89 //
90 //
91 //
92 //
93 //
94 //
95 //
96 //
97 //
98 //
99 //
100 //
101 //
102 //
103 //
104 //
105 //
106 //
107 //
108 //
109 //
110 
111 
112 
113 /**
114     !Disclaimer!
115     These contracts have been used to create tutorials,
116     and was created for the purpose to teach people
117     how to create smart contracts on the blockchain.
118     please review this code on your own before using any of
119     the following code for production.
120     HashLips will not be liable in any way if for the use 
121     of the code. That being said, the code has been tested 
122     to the best of the developers' knowledge to work as intended.
123 */
124 
125 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
126 pragma solidity ^0.8.0;
127 /**
128  * @dev Interface of the ERC165 standard, as defined in the
129  * https://eips.ethereum.org/EIPS/eip-165[EIP].
130  *
131  * Implementers can declare support of contract interfaces, which can then be
132  * queried by others ({ERC165Checker}).
133  *
134  * For an implementation, see {ERC165}.
135  */
136 interface IERC165 {
137     /**
138      * @dev Returns true if this contract implements the interface defined by
139      * `interfaceId`. See the corresponding
140      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
141      * to learn more about how these ids are created.
142      *
143      * This function call must use less than 30 000 gas.
144      */
145     function supportsInterface(bytes4 interfaceId) external view returns (bool);
146 }
147 
148 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
149 pragma solidity ^0.8.0;
150 /**
151  * @dev Required interface of an ERC721 compliant contract.
152  */
153 interface IERC721 is IERC165 {
154     /**
155      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
156      */
157     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
158 
159     /**
160      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
161      */
162     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
163 
164     /**
165      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
166      */
167     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
168 
169     /**
170      * @dev Returns the number of tokens in ``owner``'s account.
171      */
172     function balanceOf(address owner) external view returns (uint256 balance);
173 
174     /**
175      * @dev Returns the owner of the `tokenId` token.
176      *
177      * Requirements:
178      *
179      * - `tokenId` must exist.
180      */
181     function ownerOf(uint256 tokenId) external view returns (address owner);
182 
183     /**
184      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
185      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
186      *
187      * Requirements:
188      *
189      * - `from` cannot be the zero address.
190      * - `to` cannot be the zero address.
191      * - `tokenId` token must exist and be owned by `from`.
192      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
193      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
194      *
195      * Emits a {Transfer} event.
196      */
197     function safeTransferFrom(
198         address from,
199         address to,
200         uint256 tokenId
201     ) external;
202 
203     /**
204      * @dev Transfers `tokenId` token from `from` to `to`.
205      *
206      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
207      *
208      * Requirements:
209      *
210      * - `from` cannot be the zero address.
211      * - `to` cannot be the zero address.
212      * - `tokenId` token must be owned by `from`.
213      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
214      *
215      * Emits a {Transfer} event.
216      */
217     function transferFrom(
218         address from,
219         address to,
220         uint256 tokenId
221     ) external;
222 
223     /**
224      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
225      * The approval is cleared when the token is transferred.
226      *
227      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
228      *
229      * Requirements:
230      *
231      * - The caller must own the token or be an approved operator.
232      * - `tokenId` must exist.
233      *
234      * Emits an {Approval} event.
235      */
236     function approve(address to, uint256 tokenId) external;
237 
238     /**
239      * @dev Returns the account approved for `tokenId` token.
240      *
241      * Requirements:
242      *
243      * - `tokenId` must exist.
244      */
245     function getApproved(uint256 tokenId) external view returns (address operator);
246 
247     /**
248      * @dev Approve or remove `operator` as an operator for the caller.
249      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
250      *
251      * Requirements:
252      *
253      * - The `operator` cannot be the caller.
254      *
255      * Emits an {ApprovalForAll} event.
256      */
257     function setApprovalForAll(address operator, bool _approved) external;
258 
259     /**
260      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
261      *
262      * See {setApprovalForAll}
263      */
264     function isApprovedForAll(address owner, address operator) external view returns (bool);
265 
266     /**
267      * @dev Safely transfers `tokenId` token from `from` to `to`.
268      *
269      * Requirements:
270      *
271      * - `from` cannot be the zero address.
272      * - `to` cannot be the zero address.
273      * - `tokenId` token must exist and be owned by `from`.
274      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
275      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
276      *
277      * Emits a {Transfer} event.
278      */
279     function safeTransferFrom(
280         address from,
281         address to,
282         uint256 tokenId,
283         bytes calldata data
284     ) external;
285 }
286 
287 
288 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol
289 pragma solidity ^0.8.0;
290 /**
291  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
292  * @dev See https://eips.ethereum.org/EIPS/eip-721
293  */
294 interface IERC721Enumerable is IERC721 {
295     /**
296      * @dev Returns the total amount of tokens stored by the contract.
297      */
298     function totalSupply() external view returns (uint256);
299 
300     /**
301      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
302      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
303      */
304     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
305 
306     /**
307      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
308      * Use along with {totalSupply} to enumerate all tokens.
309      */
310     function tokenByIndex(uint256 index) external view returns (uint256);
311 }
312 
313 
314 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
315 pragma solidity ^0.8.0;
316 /**
317  * @dev Implementation of the {IERC165} interface.
318  *
319  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
320  * for the additional interface id that will be supported. For example:
321  *
322  * ```solidity
323  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
324  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
325  * }
326  * ```
327  *
328  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
329  */
330 abstract contract ERC165 is IERC165 {
331     /**
332      * @dev See {IERC165-supportsInterface}.
333      */
334     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
335         return interfaceId == type(IERC165).interfaceId;
336     }
337 }
338 
339 // File: @openzeppelin/contracts/utils/Strings.sol
340 
341 
342 
343 pragma solidity ^0.8.0;
344 
345 /**
346  * @dev String operations.
347  */
348 library Strings {
349     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
350 
351     /**
352      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
353      */
354     function toString(uint256 value) internal pure returns (string memory) {
355         // Inspired by OraclizeAPI's implementation - MIT licence
356         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
357 
358         if (value == 0) {
359             return "0";
360         }
361         uint256 temp = value;
362         uint256 digits;
363         while (temp != 0) {
364             digits++;
365             temp /= 10;
366         }
367         bytes memory buffer = new bytes(digits);
368         while (value != 0) {
369             digits -= 1;
370             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
371             value /= 10;
372         }
373         return string(buffer);
374     }
375 
376     /**
377      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
378      */
379     function toHexString(uint256 value) internal pure returns (string memory) {
380         if (value == 0) {
381             return "0x00";
382         }
383         uint256 temp = value;
384         uint256 length = 0;
385         while (temp != 0) {
386             length++;
387             temp >>= 8;
388         }
389         return toHexString(value, length);
390     }
391 
392     /**
393      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
394      */
395     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
396         bytes memory buffer = new bytes(2 * length + 2);
397         buffer[0] = "0";
398         buffer[1] = "x";
399         for (uint256 i = 2 * length + 1; i > 1; --i) {
400             buffer[i] = _HEX_SYMBOLS[value & 0xf];
401             value >>= 4;
402         }
403         require(value == 0, "Strings: hex length insufficient");
404         return string(buffer);
405     }
406 }
407 
408 // File: @openzeppelin/contracts/utils/Address.sol
409 
410 
411 
412 pragma solidity ^0.8.0;
413 
414 /**
415  * @dev Collection of functions related to the address type
416  */
417 library Address {
418     /**
419      * @dev Returns true if `account` is a contract.
420      *
421      * [IMPORTANT]
422      * ====
423      * It is unsafe to assume that an address for which this function returns
424      * false is an externally-owned account (EOA) and not a contract.
425      *
426      * Among others, `isContract` will return false for the following
427      * types of addresses:
428      *
429      *  - an externally-owned account
430      *  - a contract in construction
431      *  - an address where a contract will be created
432      *  - an address where a contract lived, but was destroyed
433      * ====
434      */
435     function isContract(address account) internal view returns (bool) {
436         // This method relies on extcodesize, which returns 0 for contracts in
437         // construction, since the code is only stored at the end of the
438         // constructor execution.
439 
440         uint256 size;
441         assembly {
442             size := extcodesize(account)
443         }
444         return size > 0;
445     }
446 
447     /**
448      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
449      * `recipient`, forwarding all available gas and reverting on errors.
450      *
451      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
452      * of certain opcodes, possibly making contracts go over the 2300 gas limit
453      * imposed by `transfer`, making them unable to receive funds via
454      * `transfer`. {sendValue} removes this limitation.
455      *
456      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
457      *
458      * IMPORTANT: because control is transferred to `recipient`, care must be
459      * taken to not create reentrancy vulnerabilities. Consider using
460      * {ReentrancyGuard} or the
461      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
462      */
463     function sendValue(address payable recipient, uint256 amount) internal {
464         require(address(this).balance >= amount, "Address: insufficient balance");
465 
466         (bool success, ) = recipient.call{value: amount}("");
467         require(success, "Address: unable to send value, recipient may have reverted");
468     }
469 
470     /**
471      * @dev Performs a Solidity function call using a low level `call`. A
472      * plain `call` is an unsafe replacement for a function call: use this
473      * function instead.
474      *
475      * If `target` reverts with a revert reason, it is bubbled up by this
476      * function (like regular Solidity function calls).
477      *
478      * Returns the raw returned data. To convert to the expected return value,
479      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
480      *
481      * Requirements:
482      *
483      * - `target` must be a contract.
484      * - calling `target` with `data` must not revert.
485      *
486      * _Available since v3.1._
487      */
488     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
489         return functionCall(target, data, "Address: low-level call failed");
490     }
491 
492     /**
493      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
494      * `errorMessage` as a fallback revert reason when `target` reverts.
495      *
496      * _Available since v3.1._
497      */
498     function functionCall(
499         address target,
500         bytes memory data,
501         string memory errorMessage
502     ) internal returns (bytes memory) {
503         return functionCallWithValue(target, data, 0, errorMessage);
504     }
505 
506     /**
507      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
508      * but also transferring `value` wei to `target`.
509      *
510      * Requirements:
511      *
512      * - the calling contract must have an ETH balance of at least `value`.
513      * - the called Solidity function must be `payable`.
514      *
515      * _Available since v3.1._
516      */
517     function functionCallWithValue(
518         address target,
519         bytes memory data,
520         uint256 value
521     ) internal returns (bytes memory) {
522         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
523     }
524 
525     /**
526      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
527      * with `errorMessage` as a fallback revert reason when `target` reverts.
528      *
529      * _Available since v3.1._
530      */
531     function functionCallWithValue(
532         address target,
533         bytes memory data,
534         uint256 value,
535         string memory errorMessage
536     ) internal returns (bytes memory) {
537         require(address(this).balance >= value, "Address: insufficient balance for call");
538         require(isContract(target), "Address: call to non-contract");
539 
540         (bool success, bytes memory returndata) = target.call{value: value}(data);
541         return verifyCallResult(success, returndata, errorMessage);
542     }
543 
544     /**
545      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
546      * but performing a static call.
547      *
548      * _Available since v3.3._
549      */
550     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
551         return functionStaticCall(target, data, "Address: low-level static call failed");
552     }
553 
554     /**
555      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
556      * but performing a static call.
557      *
558      * _Available since v3.3._
559      */
560     function functionStaticCall(
561         address target,
562         bytes memory data,
563         string memory errorMessage
564     ) internal view returns (bytes memory) {
565         require(isContract(target), "Address: static call to non-contract");
566 
567         (bool success, bytes memory returndata) = target.staticcall(data);
568         return verifyCallResult(success, returndata, errorMessage);
569     }
570 
571     /**
572      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
573      * but performing a delegate call.
574      *
575      * _Available since v3.4._
576      */
577     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
578         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
579     }
580 
581     /**
582      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
583      * but performing a delegate call.
584      *
585      * _Available since v3.4._
586      */
587     function functionDelegateCall(
588         address target,
589         bytes memory data,
590         string memory errorMessage
591     ) internal returns (bytes memory) {
592         require(isContract(target), "Address: delegate call to non-contract");
593 
594         (bool success, bytes memory returndata) = target.delegatecall(data);
595         return verifyCallResult(success, returndata, errorMessage);
596     }
597 
598     /**
599      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
600      * revert reason using the provided one.
601      *
602      * _Available since v4.3._
603      */
604     function verifyCallResult(
605         bool success,
606         bytes memory returndata,
607         string memory errorMessage
608     ) internal pure returns (bytes memory) {
609         if (success) {
610             return returndata;
611         } else {
612             // Look for revert reason and bubble it up if present
613             if (returndata.length > 0) {
614                 // The easiest way to bubble the revert reason is using memory via assembly
615 
616                 assembly {
617                     let returndata_size := mload(returndata)
618                     revert(add(32, returndata), returndata_size)
619                 }
620             } else {
621                 revert(errorMessage);
622             }
623         }
624     }
625 }
626 
627 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
628 
629 
630 
631 pragma solidity ^0.8.0;
632 
633 
634 /**
635  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
636  * @dev See https://eips.ethereum.org/EIPS/eip-721
637  */
638 interface IERC721Metadata is IERC721 {
639     /**
640      * @dev Returns the token collection name.
641      */
642     function name() external view returns (string memory);
643 
644     /**
645      * @dev Returns the token collection symbol.
646      */
647     function symbol() external view returns (string memory);
648 
649     /**
650      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
651      */
652     function tokenURI(uint256 tokenId) external view returns (string memory);
653 }
654 
655 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
656 
657 
658 
659 pragma solidity ^0.8.0;
660 
661 /**
662  * @title ERC721 token receiver interface
663  * @dev Interface for any contract that wants to support safeTransfers
664  * from ERC721 asset contracts.
665  */
666 interface IERC721Receiver {
667     /**
668      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
669      * by `operator` from `from`, this function is called.
670      *
671      * It must return its Solidity selector to confirm the token transfer.
672      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
673      *
674      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
675      */
676     function onERC721Received(
677         address operator,
678         address from,
679         uint256 tokenId,
680         bytes calldata data
681     ) external returns (bytes4);
682 }
683 
684 // File: @openzeppelin/contracts/utils/Context.sol
685 pragma solidity ^0.8.0;
686 /**
687  * @dev Provides information about the current execution context, including the
688  * sender of the transaction and its data. While these are generally available
689  * via msg.sender and msg.data, they should not be accessed in such a direct
690  * manner, since when dealing with meta-transactions the account sending and
691  * paying for execution may not be the actual sender (as far as an application
692  * is concerned).
693  *
694  * This contract is only required for intermediate, library-like contracts.
695  */
696 abstract contract Context {
697     function _msgSender() internal view virtual returns (address) {
698         return msg.sender;
699     }
700 
701     function _msgData() internal view virtual returns (bytes calldata) {
702         return msg.data;
703     }
704 }
705 
706 
707 // File: @openzeppelin/contracts/token/ERC721/ERC721.sol
708 pragma solidity ^0.8.0;
709 /**
710  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
711  * the Metadata extension, but not including the Enumerable extension, which is available separately as
712  * {ERC721Enumerable}.
713  */
714 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
715     using Address for address;
716     using Strings for uint256;
717 
718     // Token name
719     string private _name;
720 
721     // Token symbol
722     string private _symbol;
723 
724     // Mapping from token ID to owner address
725     mapping(uint256 => address) private _owners;
726 
727     // Mapping owner address to token count
728     mapping(address => uint256) private _balances;
729 
730     // Mapping from token ID to approved address
731     mapping(uint256 => address) private _tokenApprovals;
732 
733     // Mapping from owner to operator approvals
734     mapping(address => mapping(address => bool)) private _operatorApprovals;
735 
736     /**
737      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
738      */
739     constructor(string memory name_, string memory symbol_) {
740         _name = name_;
741         _symbol = symbol_;
742     }
743 
744     /**
745      * @dev See {IERC165-supportsInterface}.
746      */
747     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
748         return
749             interfaceId == type(IERC721).interfaceId ||
750             interfaceId == type(IERC721Metadata).interfaceId ||
751             super.supportsInterface(interfaceId);
752     }
753 
754     /**
755      * @dev See {IERC721-balanceOf}.
756      */
757     function balanceOf(address owner) public view virtual override returns (uint256) {
758         require(owner != address(0), "ERC721: balance query for the zero address");
759         return _balances[owner];
760     }
761 
762     /**
763      * @dev See {IERC721-ownerOf}.
764      */
765     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
766         address owner = _owners[tokenId];
767         require(owner != address(0), "ERC721: owner query for nonexistent token");
768         return owner;
769     }
770 
771     /**
772      * @dev See {IERC721Metadata-name}.
773      */
774     function name() public view virtual override returns (string memory) {
775         return _name;
776     }
777 
778     /**
779      * @dev See {IERC721Metadata-symbol}.
780      */
781     function symbol() public view virtual override returns (string memory) {
782         return _symbol;
783     }
784 
785     /**
786      * @dev See {IERC721Metadata-tokenURI}.
787      */
788     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
789         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
790 
791         string memory baseURI = _baseURI();
792         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
793     }
794 
795     /**
796      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
797      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
798      * by default, can be overriden in child contracts.
799      */
800     function _baseURI() internal view virtual returns (string memory) {
801         return "";
802     }
803 
804     /**
805      * @dev See {IERC721-approve}.
806      */
807     function approve(address to, uint256 tokenId) public virtual override {
808         address owner = ERC721.ownerOf(tokenId);
809         require(to != owner, "ERC721: approval to current owner");
810 
811         require(
812             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
813             "ERC721: approve caller is not owner nor approved for all"
814         );
815 
816         _approve(to, tokenId);
817     }
818 
819     /**
820      * @dev See {IERC721-getApproved}.
821      */
822     function getApproved(uint256 tokenId) public view virtual override returns (address) {
823         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
824 
825         return _tokenApprovals[tokenId];
826     }
827 
828     /**
829      * @dev See {IERC721-setApprovalForAll}.
830      */
831     function setApprovalForAll(address operator, bool approved) public virtual override {
832         require(operator != _msgSender(), "ERC721: approve to caller");
833 
834         _operatorApprovals[_msgSender()][operator] = approved;
835         emit ApprovalForAll(_msgSender(), operator, approved);
836     }
837 
838     /**
839      * @dev See {IERC721-isApprovedForAll}.
840      */
841     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
842         return _operatorApprovals[owner][operator];
843     }
844 
845     /**
846      * @dev See {IERC721-transferFrom}.
847      */
848     function transferFrom(
849         address from,
850         address to,
851         uint256 tokenId
852     ) public virtual override {
853         //solhint-disable-next-line max-line-length
854         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
855 
856         _transfer(from, to, tokenId);
857     }
858 
859     /**
860      * @dev See {IERC721-safeTransferFrom}.
861      */
862     function safeTransferFrom(
863         address from,
864         address to,
865         uint256 tokenId
866     ) public virtual override {
867         safeTransferFrom(from, to, tokenId, "");
868     }
869 
870     /**
871      * @dev See {IERC721-safeTransferFrom}.
872      */
873     function safeTransferFrom(
874         address from,
875         address to,
876         uint256 tokenId,
877         bytes memory _data
878     ) public virtual override {
879         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
880         _safeTransfer(from, to, tokenId, _data);
881     }
882 
883     /**
884      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
885      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
886      *
887      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
888      *
889      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
890      * implement alternative mechanisms to perform token transfer, such as signature-based.
891      *
892      * Requirements:
893      *
894      * - `from` cannot be the zero address.
895      * - `to` cannot be the zero address.
896      * - `tokenId` token must exist and be owned by `from`.
897      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
898      *
899      * Emits a {Transfer} event.
900      */
901     function _safeTransfer(
902         address from,
903         address to,
904         uint256 tokenId,
905         bytes memory _data
906     ) internal virtual {
907         _transfer(from, to, tokenId);
908         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
909     }
910 
911     /**
912      * @dev Returns whether `tokenId` exists.
913      *
914      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
915      *
916      * Tokens start existing when they are minted (`_mint`),
917      * and stop existing when they are burned (`_burn`).
918      */
919     function _exists(uint256 tokenId) internal view virtual returns (bool) {
920         return _owners[tokenId] != address(0);
921     }
922 
923     /**
924      * @dev Returns whether `spender` is allowed to manage `tokenId`.
925      *
926      * Requirements:
927      *
928      * - `tokenId` must exist.
929      */
930     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
931         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
932         address owner = ERC721.ownerOf(tokenId);
933         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
934     }
935 
936     /**
937      * @dev Safely mints `tokenId` and transfers it to `to`.
938      *
939      * Requirements:
940      *
941      * - `tokenId` must not exist.
942      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
943      *
944      * Emits a {Transfer} event.
945      */
946     function _safeMint(address to, uint256 tokenId) internal virtual {
947         _safeMint(to, tokenId, "");
948     }
949 
950     /**
951      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
952      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
953      */
954     function _safeMint(
955         address to,
956         uint256 tokenId,
957         bytes memory _data
958     ) internal virtual {
959         _mint(to, tokenId);
960         require(
961             _checkOnERC721Received(address(0), to, tokenId, _data),
962             "ERC721: transfer to non ERC721Receiver implementer"
963         );
964     }
965 
966     /**
967      * @dev Mints `tokenId` and transfers it to `to`.
968      *
969      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
970      *
971      * Requirements:
972      *
973      * - `tokenId` must not exist.
974      * - `to` cannot be the zero address.
975      *
976      * Emits a {Transfer} event.
977      */
978     function _mint(address to, uint256 tokenId) internal virtual {
979         require(to != address(0), "ERC721: mint to the zero address");
980         require(!_exists(tokenId), "ERC721: token already minted");
981 
982         _beforeTokenTransfer(address(0), to, tokenId);
983 
984         _balances[to] += 1;
985         _owners[tokenId] = to;
986 
987         emit Transfer(address(0), to, tokenId);
988     }
989 
990     /**
991      * @dev Destroys `tokenId`.
992      * The approval is cleared when the token is burned.
993      *
994      * Requirements:
995      *
996      * - `tokenId` must exist.
997      *
998      * Emits a {Transfer} event.
999      */
1000     function _burn(uint256 tokenId) internal virtual {
1001         address owner = ERC721.ownerOf(tokenId);
1002 
1003         _beforeTokenTransfer(owner, address(0), tokenId);
1004 
1005         // Clear approvals
1006         _approve(address(0), tokenId);
1007 
1008         _balances[owner] -= 1;
1009         delete _owners[tokenId];
1010 
1011         emit Transfer(owner, address(0), tokenId);
1012     }
1013 
1014     /**
1015      * @dev Transfers `tokenId` from `from` to `to`.
1016      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1017      *
1018      * Requirements:
1019      *
1020      * - `to` cannot be the zero address.
1021      * - `tokenId` token must be owned by `from`.
1022      *
1023      * Emits a {Transfer} event.
1024      */
1025     function _transfer(
1026         address from,
1027         address to,
1028         uint256 tokenId
1029     ) internal virtual {
1030         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1031         require(to != address(0), "ERC721: transfer to the zero address");
1032 
1033         _beforeTokenTransfer(from, to, tokenId);
1034 
1035         // Clear approvals from the previous owner
1036         _approve(address(0), tokenId);
1037 
1038         _balances[from] -= 1;
1039         _balances[to] += 1;
1040         _owners[tokenId] = to;
1041 
1042         emit Transfer(from, to, tokenId);
1043     }
1044 
1045     /**
1046      * @dev Approve `to` to operate on `tokenId`
1047      *
1048      * Emits a {Approval} event.
1049      */
1050     function _approve(address to, uint256 tokenId) internal virtual {
1051         _tokenApprovals[tokenId] = to;
1052         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1053     }
1054 
1055     /**
1056      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1057      * The call is not executed if the target address is not a contract.
1058      *
1059      * @param from address representing the previous owner of the given token ID
1060      * @param to target address that will receive the tokens
1061      * @param tokenId uint256 ID of the token to be transferred
1062      * @param _data bytes optional data to send along with the call
1063      * @return bool whether the call correctly returned the expected magic value
1064      */
1065     function _checkOnERC721Received(
1066         address from,
1067         address to,
1068         uint256 tokenId,
1069         bytes memory _data
1070     ) private returns (bool) {
1071         if (to.isContract()) {
1072             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1073                 return retval == IERC721Receiver.onERC721Received.selector;
1074             } catch (bytes memory reason) {
1075                 if (reason.length == 0) {
1076                     revert("ERC721: transfer to non ERC721Receiver implementer");
1077                 } else {
1078                     assembly {
1079                         revert(add(32, reason), mload(reason))
1080                     }
1081                 }
1082             }
1083         } else {
1084             return true;
1085         }
1086     }
1087 
1088     /**
1089      * @dev Hook that is called before any token transfer. This includes minting
1090      * and burning.
1091      *
1092      * Calling conditions:
1093      *
1094      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1095      * transferred to `to`.
1096      * - When `from` is zero, `tokenId` will be minted for `to`.
1097      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1098      * - `from` and `to` are never both zero.
1099      *
1100      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1101      */
1102     function _beforeTokenTransfer(
1103         address from,
1104         address to,
1105         uint256 tokenId
1106     ) internal virtual {}
1107 }
1108 
1109 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol
1110 
1111 
1112 
1113 pragma solidity ^0.8.0;
1114 
1115 
1116 
1117 /**
1118  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1119  * enumerability of all the token ids in the contract as well as all token ids owned by each
1120  * account.
1121  */
1122 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1123     // Mapping from owner to list of owned token IDs
1124     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1125 
1126     // Mapping from token ID to index of the owner tokens list
1127     mapping(uint256 => uint256) private _ownedTokensIndex;
1128 
1129     // Array with all token ids, used for enumeration
1130     uint256[] private _allTokens;
1131 
1132     // Mapping from token id to position in the allTokens array
1133     mapping(uint256 => uint256) private _allTokensIndex;
1134 
1135     /**
1136      * @dev See {IERC165-supportsInterface}.
1137      */
1138     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1139         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1140     }
1141 
1142     /**
1143      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1144      */
1145     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1146         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1147         return _ownedTokens[owner][index];
1148     }
1149 
1150     /**
1151      * @dev See {IERC721Enumerable-totalSupply}.
1152      */
1153     function totalSupply() public view virtual override returns (uint256) {
1154         return _allTokens.length;
1155     }
1156 
1157     /**
1158      * @dev See {IERC721Enumerable-tokenByIndex}.
1159      */
1160     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1161         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1162         return _allTokens[index];
1163     }
1164 
1165     /**
1166      * @dev Hook that is called before any token transfer. This includes minting
1167      * and burning.
1168      *
1169      * Calling conditions:
1170      *
1171      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1172      * transferred to `to`.
1173      * - When `from` is zero, `tokenId` will be minted for `to`.
1174      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1175      * - `from` cannot be the zero address.
1176      * - `to` cannot be the zero address.
1177      *
1178      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1179      */
1180     function _beforeTokenTransfer(
1181         address from,
1182         address to,
1183         uint256 tokenId
1184     ) internal virtual override {
1185         super._beforeTokenTransfer(from, to, tokenId);
1186 
1187         if (from == address(0)) {
1188             _addTokenToAllTokensEnumeration(tokenId);
1189         } else if (from != to) {
1190             _removeTokenFromOwnerEnumeration(from, tokenId);
1191         }
1192         if (to == address(0)) {
1193             _removeTokenFromAllTokensEnumeration(tokenId);
1194         } else if (to != from) {
1195             _addTokenToOwnerEnumeration(to, tokenId);
1196         }
1197     }
1198 
1199     /**
1200      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1201      * @param to address representing the new owner of the given token ID
1202      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1203      */
1204     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1205         uint256 length = ERC721.balanceOf(to);
1206         _ownedTokens[to][length] = tokenId;
1207         _ownedTokensIndex[tokenId] = length;
1208     }
1209 
1210     /**
1211      * @dev Private function to add a token to this extension's token tracking data structures.
1212      * @param tokenId uint256 ID of the token to be added to the tokens list
1213      */
1214     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1215         _allTokensIndex[tokenId] = _allTokens.length;
1216         _allTokens.push(tokenId);
1217     }
1218 
1219     /**
1220      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1221      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1222      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1223      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1224      * @param from address representing the previous owner of the given token ID
1225      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1226      */
1227     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1228         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1229         // then delete the last slot (swap and pop).
1230 
1231         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1232         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1233 
1234         // When the token to delete is the last token, the swap operation is unnecessary
1235         if (tokenIndex != lastTokenIndex) {
1236             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1237 
1238             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1239             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1240         }
1241 
1242         // This also deletes the contents at the last position of the array
1243         delete _ownedTokensIndex[tokenId];
1244         delete _ownedTokens[from][lastTokenIndex];
1245     }
1246 
1247     /**
1248      * @dev Private function to remove a token from this extension's token tracking data structures.
1249      * This has O(1) time complexity, but alters the order of the _allTokens array.
1250      * @param tokenId uint256 ID of the token to be removed from the tokens list
1251      */
1252     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1253         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1254         // then delete the last slot (swap and pop).
1255 
1256         uint256 lastTokenIndex = _allTokens.length - 1;
1257         uint256 tokenIndex = _allTokensIndex[tokenId];
1258 
1259         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1260         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1261         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1262         uint256 lastTokenId = _allTokens[lastTokenIndex];
1263 
1264         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1265         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1266 
1267         // This also deletes the contents at the last position of the array
1268         delete _allTokensIndex[tokenId];
1269         _allTokens.pop();
1270     }
1271 }
1272 
1273 
1274 // File: @openzeppelin/contracts/access/Ownable.sol
1275 pragma solidity ^0.8.0;
1276 /**
1277  * @dev Contract module which provides a basic access control mechanism, where
1278  * there is an account (an owner) that can be granted exclusive access to
1279  * specific functions.
1280  *
1281  * By default, the owner account will be the one that deploys the contract. This
1282  * can later be changed with {transferOwnership}.
1283  *
1284  * This module is used through inheritance. It will make available the modifier
1285  * `onlyOwner`, which can be applied to your functions to restrict their use to
1286  * the owner.
1287  */
1288 abstract contract Ownable is Context {
1289     address private _owner;
1290 
1291     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
1292 
1293     /**
1294      * @dev Initializes the contract setting the deployer as the initial owner.
1295      */
1296     constructor() {
1297         _setOwner(_msgSender());
1298     }
1299 
1300     /**
1301      * @dev Returns the address of the current owner.
1302      */
1303     function owner() public view virtual returns (address) {
1304         return _owner;
1305     }
1306 
1307     /**
1308      * @dev Throws if called by any account other than the owner.
1309      */
1310     modifier onlyOwner() {
1311         require(owner() == _msgSender(), "Ownable: caller is not the owner");
1312         _;
1313     }
1314 
1315     /**
1316      * @dev Leaves the contract without owner. It will not be possible to call
1317      * `onlyOwner` functions anymore. Can only be called by the current owner.
1318      *
1319      * NOTE: Renouncing ownership will leave the contract without an owner,
1320      * thereby removing any functionality that is only available to the owner.
1321      */
1322     function renounceOwnership() public virtual onlyOwner {
1323         _setOwner(address(0));
1324     }
1325 
1326     /**
1327      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1328      * Can only be called by the current owner.
1329      */
1330     function transferOwnership(address newOwner) public virtual onlyOwner {
1331         require(newOwner != address(0), "Ownable: new owner is the zero address");
1332         _setOwner(newOwner);
1333     }
1334 
1335     function _setOwner(address newOwner) private {
1336         address oldOwner = _owner;
1337         _owner = newOwner;
1338         emit OwnershipTransferred(oldOwner, newOwner);
1339     }
1340 }
1341 
1342 pragma solidity >=0.7.0 <0.9.0;
1343 
1344 contract INKISMYBLOOD is ERC721Enumerable, Ownable {
1345   using Strings for uint256;
1346 
1347   string baseURI;
1348   string public baseExtension = ".json";
1349   uint256 public cost = 0 ether;
1350   uint256 public maxSupply = 1969;
1351   uint256 public maxMintAmount = 2;
1352   bool public paused = false;
1353   bool public revealed = false;
1354   string public notRevealedUri;
1355 
1356   constructor(
1357     string memory _name,
1358     string memory _symbol,
1359     string memory _initBaseURI,
1360     string memory _initNotRevealedUri
1361   ) ERC721(_name, _symbol) {
1362     setBaseURI(_initBaseURI);
1363     setNotRevealedURI(_initNotRevealedUri);
1364   }
1365 
1366   // internal
1367   function _baseURI() internal view virtual override returns (string memory) {
1368     return baseURI;
1369   }
1370 
1371   // public
1372   function mint(uint256 _mintAmount) public payable {
1373     uint256 supply = totalSupply();
1374     require(!paused);
1375     require(_mintAmount > 0);
1376     require(_mintAmount <= maxMintAmount);
1377     require(supply + _mintAmount <= maxSupply);
1378 
1379     if (msg.sender != owner()) {
1380       require(msg.value >= cost * _mintAmount);
1381     }
1382 
1383     for (uint256 i = 1; i <= _mintAmount; i++) {
1384       _safeMint(msg.sender, supply + i);
1385     }
1386   }
1387 
1388   function walletOfOwner(address _owner)
1389     public
1390     view
1391     returns (uint256[] memory)
1392   {
1393     uint256 ownerTokenCount = balanceOf(_owner);
1394     uint256[] memory tokenIds = new uint256[](ownerTokenCount);
1395     for (uint256 i; i < ownerTokenCount; i++) {
1396       tokenIds[i] = tokenOfOwnerByIndex(_owner, i);
1397     }
1398     return tokenIds;
1399   }
1400 
1401   function tokenURI(uint256 tokenId)
1402     public
1403     view
1404     virtual
1405     override
1406     returns (string memory)
1407   {
1408     require(
1409       _exists(tokenId),
1410       "ERC721Metadata: URI query for nonexistent token"
1411     );
1412     
1413     if(revealed == false) {
1414         return notRevealedUri;
1415     }
1416 
1417     string memory currentBaseURI = _baseURI();
1418     return bytes(currentBaseURI).length > 0
1419         ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))
1420         : "";
1421   }
1422 
1423   //only owner
1424   function reveal() public onlyOwner {
1425       revealed = true;
1426   }
1427   
1428   function setCost(uint256 _newCost) public onlyOwner {
1429     cost = _newCost;
1430   }
1431 
1432   function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {
1433     maxMintAmount = _newmaxMintAmount;
1434   }
1435   
1436   function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {
1437     notRevealedUri = _notRevealedURI;
1438   }
1439 
1440   function setBaseURI(string memory _newBaseURI) public onlyOwner {
1441     baseURI = _newBaseURI;
1442   }
1443 
1444   function setBaseExtension(string memory _newBaseExtension) public onlyOwner {
1445     baseExtension = _newBaseExtension;
1446   }
1447 
1448   function pause(bool _state) public onlyOwner {
1449     paused = _state;
1450   }
1451  
1452   function withdraw() public payable onlyOwner {
1453     // This will pay A.S. 5% of the initial sale.
1454     // You can remove this if you want, or keep it in to support  and his channel.
1455     // =============================================================================
1456     (bool hs, ) = payable(0x610e15b80c9a96Bf1d8c0FEcD862Cc3984EdF6c6).call{value: address(this).balance * 5 / 100}("");
1457     require(hs);
1458     // =============================================================================
1459     
1460     // This will payout the owner 95% of the contract balance.
1461     // Do not remove this otherwise you will not be able to withdraw the funds.
1462     // =============================================================================
1463     (bool os, ) = payable(owner()).call{value: address(this).balance}("");
1464     require(os);
1465     // =============================================================================
1466   }
1467 }