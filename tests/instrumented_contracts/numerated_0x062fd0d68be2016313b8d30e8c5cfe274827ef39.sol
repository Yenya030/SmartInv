1 /**
2 
3 Cheems
4 
5 https://t.me/RipCheems2023
6 
7 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
8 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣏⡽⠷⠾⠭⠍⠉⣯⣿⣶⢶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
9 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠞⣿⣦⣴⣤⣀⠀⠉⣛⠹⣮⡇⣿⣿⢶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
10 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⠃⣴⣿⡯⠟⠀⠈⢀⠀⠹⡄⠙⣷⣿⣿⠶⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
11 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣴⣿⡟⠀⣰⣬⣿⣾⠗⠀⠀⠐⢯⠛⣧⠀⢘⢷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
12 ⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡴⠀⠙⠉⠉⠈⠀⠀⠀⠀⠀⠀⣼⣶⠾⢾⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
13 ⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⠻⠁⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⣠⣿⠙⣄⠾⠿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
14 ⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠥⠀⠀⢀⣴⠀⠀⠀⠀⠀⣨⠀⠴⠋⠀⠘⠁⠀⣠⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
15 ⠀⠀⠀⠀⠀⠈⠙⠿⣿⣧⣤⣯⣿⡿⠋⠀⠀⠀⣤⠞⠀⠀⠀⠀⠀⠀⠀⠀⠟⠁⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
16 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⠛⠁⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⢀⣴⠀⠀⠀⠀⠀⠀⠀⢳⣄⠀⠀⠀⠀⠀⠀⠀⠀
17 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠹⡦⠀⣀⣴⠏⠀⠀⠀⠀⠀⠀⠀⣀⣿⠙⢦⡀⠀⠀⠀⠀⠀⠀
18 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣄⠀⠀⠀⠀⠀⠀⠀⠳⠖⠉⠀⠀⠀⠀⠀⠀⠁⠀⣴⠟⠩⠀⢠⣿⢦⡀⠀⠀⠀⠀
19 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⠀⠿⠀⠁⠀⠀⢀⣸⡯⠙⢷⡀⠀⠀⠀
20 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⠤⠐⠈⠀⠀⠀⠀⠀⠀⠀⣠⠟⠃⠀⢸⣇⠀⠀⠀
21 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⢖⠀⠀⠀⠀⠀⠀⠀⠐⠚⠉⠀⠀⠀⠀⡴⡋⠀⠀⠀⠀⣦⡏⠀⠀⠀⣾⣿⡄⠀⠀
22 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⠷⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢪⡞⠁⠀⠀⠀⠀⠁⠀⠀⠀⣶⠏⣿⣿⡄⠀
23 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡦⡌⠳⠤⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠋⠀⣻⣹⣿⡄
24 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⠋⠀⠀⠀⠀⠀⠀⢀⣾⠀⠀⠀⠀⣾⠀⠹⢿⣿⣷
25 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⣶⠀⠀⠀⠀⠀⣆⠀⠟⠀⠀⠀⠀⠀⡾⠃⠀⢠⡠⠀⢠⣾⣾⣿⣿⡇
26 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⡿⠀⠀⠀⣰⣿⣀⠀⠀⠀⠀⢹⡤⡄⠀⠀⠀⠀⣸⣿⡀⣶⣶⣷⣶⣿⣿⣿⣿⡟⠁
27 ⠀⠀⠀⠀⠀⠀⣀⡠⠶⠋⣸⣗⠀⠀⢀⣿⣻⣿⡦⠤⠤⠤⠿⣷⠇⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀
28 ⠀⣀⡴⠖⠋⠉⠉⢀⣀⡴⣿⡏⠀⢀⣸⡟⠛⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀
29 ⠘⢿⣷⣤⡤⠶⠚⠋⠁⢀⡟⠀⠀⣾⣿⣁⣀⠀⠀⠀⠀⠀⠀⣿⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⠿⠛⠁⠀⠀⠀⠀⠀
30 ⠀⠀⠀⠀⠀⢀⣀⠴⢞⡿⠀⠀⢴⡿⠋⠉⠉⠉⠛⠲⠶⠤⣤⣿⠀⠀⢰⣿⣿⣿⠿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀
31 ⠀⢀⣠⣶⡊⠉⢀⣠⠞⠁⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⢸⣯⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
32 ⠀⠈⠉⠻⠶⣶⡟⠃⡴⠀⢀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⠏⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
33 ⠀⠀⠀⠀⠠⣿⣄⣾⣄⡷⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠀⠀⠀⢸⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
34 ⠀⠀⠀⠀⠀⠈⠁⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣼⡁⠀⠀⠀⢸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
35 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣏⡇⠀⡶⠀⣸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
36 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠹⣇⣴⠷⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
37 
38 **/
39 
40 // SPDX-License-Identifier: MIT
41 
42 pragma solidity 0.8.20;
43 
44 abstract contract Context {
45     function _msgSender() internal view virtual returns (address) {
46         return msg.sender;
47     }
48 }
49 
50 interface IERC20 {
51     function totalSupply() external view returns (uint256);
52     function balanceOf(address account) external view returns (uint256);
53     function transfer(address recipient, uint256 amount) external returns (bool);
54     function allowance(address owner, address spender) external view returns (uint256);
55     function approve(address spender, uint256 amount) external returns (bool);
56     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
57     event Transfer(address indexed from, address indexed to, uint256 value);
58     event Approval(address indexed owner, address indexed spender, uint256 value);
59 }
60 
61 library SafeMath {
62     function add(uint256 a, uint256 b) internal pure returns (uint256) {
63         uint256 c = a + b;
64         require(c >= a, "SafeMath: addition overflow");
65         return c;
66     }
67 
68     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
69         return sub(a, b, "SafeMath: subtraction overflow");
70     }
71 
72     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
73         require(b <= a, errorMessage);
74         uint256 c = a - b;
75         return c;
76     }
77 
78     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
79         if (a == 0) {
80             return 0;
81         }
82         uint256 c = a * b;
83         require(c / a == b, "SafeMath: multiplication overflow");
84         return c;
85     }
86 
87     function div(uint256 a, uint256 b) internal pure returns (uint256) {
88         return div(a, b, "SafeMath: division by zero");
89     }
90 
91     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
92         require(b > 0, errorMessage);
93         uint256 c = a / b;
94         return c;
95     }
96 
97 }
98 
99 contract Ownable is Context {
100     address private _owner;
101     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
102 
103     constructor () {
104         address msgSender = _msgSender();
105         _owner = msgSender;
106         emit OwnershipTransferred(address(0), msgSender);
107     }
108 
109     function owner() public view returns (address) {
110         return _owner;
111     }
112 
113     modifier onlyOwner() {
114         require(_owner == _msgSender(), "Ownable: caller is not the owner");
115         _;
116     }
117 
118     function renounceOwnership() public virtual onlyOwner {
119         emit OwnershipTransferred(_owner, address(0));
120         _owner = address(0);
121     }
122 
123 }
124 
125 interface IUniswapV2Factory {
126     function createPair(address tokenA, address tokenB) external returns (address pair);
127 }
128 
129 interface IUniswapV2Router02 {
130     function swapExactTokensForETHSupportingFeeOnTransferTokens(
131         uint amountIn,
132         uint amountOutMin,
133         address[] calldata path,
134         address to,
135         uint deadline
136     ) external;
137     function factory() external pure returns (address);
138     function WETH() external pure returns (address);
139     function addLiquidityETH(
140         address token,
141         uint amountTokenDesired,
142         uint amountTokenMin,
143         uint amountETHMin,
144         address to,
145         uint deadline
146     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
147 }
148 
149 contract Cheems is Context, IERC20, Ownable {
150     using SafeMath for uint256;
151     mapping (address => uint256) private _balances;
152     mapping (address => mapping (address => uint256)) private _allowances;
153     mapping (address => bool) private _isExcludedFromFee;
154     mapping (address => bool) private bots;
155     mapping(address => uint256) private _holderLastTransferTimestamp;
156     bool public transferDelayEnabled = true;
157     address payable private _taxWallet;
158     uint256 firstBlock;
159 
160     uint256 private _initialBuyTax=17;
161     uint256 private _initialSellTax=45;
162     uint256 private _finalBuyTax=1;
163     uint256 private _finalSellTax=1;
164     uint256 private _reduceBuyTaxAt=6;
165     uint256 private _reduceSellTaxAt=6;
166     uint256 private _preventSwapBefore=7;
167     uint256 private _buyCount=0;
168 
169     uint8 private constant _decimals = 9;
170     uint256 private constant _tTotal = 420690000000000 * 10**_decimals;
171     string private constant _name = unicode"⠀⠀⠀⠀⠀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⡀⣯⡭⠀⢟⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⢠⣼⠏⠴⠶⠈⠘⠻⣘⡆⠀⠀⠀⠀⠀⠀\n⠀⠀⣠⣾⡟⠁⡀⠀⠀⠀⡼⠡⠛⡄⠀⠀⠀⠀⠀\n⠀⠀⠙⠻⢴⠞⠁⠀⠊⠀⠀⠀⠈⠉⢄⠀⠀⠀⠀\n⠀⠀⠀⠀⢀⠀⠀⠀⢃⠄⠂⠀⠀⢀⠞⢣⡀⠀⠀\n⠀⠀⠀⠀⡌⠁⠀⠀⠀⢀⠀⠐⠈⠀⠀⡺⠙⡄⠀\n⠀⠀⠀⠀⡿⡀⠀⠀⠀⠁⠀⠴⠁⠀⠚⠀⡸⣷⠀\n⠀⠀⠀⠀⢹⠈⠀⠀⠀⠀⠔⠁⠀⢀⠄⠀⠁⢻⣧\n⠀⠀⠀⠀⣸⠀⢠⣇⠀⢘⣬⠀⠀⣬⣠⣦⣼⣿⠏\n⡠⠐⢂⡡⠾⢀⡾⠋⠉⠉⡇⠀⢸⣿⣿⣿⡿⠃⠀\n⠉⢉⡠⢰⠃⠸⠓⠒⠂⠤⡇⠀⡿⠟⠛⠁⠀⠀⠀\n⠘⢳⡞⣅⡰⠁⠀⠀⠀⢀⠇⠀⡇⠀⠀⠀⠀⠀⠀\n⠀⠀⠉⠉⠀⠀⠀⠀⢀⣌⢀⢀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠘⠊⠀⠀⠀⠀⠀⠀⠀";
172     string private constant _symbol = unicode"Cheems";
173     uint256 public _maxTxAmount =        3670000000001 * 10**_decimals;
174     uint256 public _maxWalletSize =      3670000000001 * 10**_decimals;
175     uint256 public _taxSwapThreshold=     420000000000 * 10**_decimals;
176     uint256 public _maxTaxSwap=          1270000000000 * 10**_decimals;
177 
178     IUniswapV2Router02 private uniswapV2Router;
179     address private uniswapV2Pair;
180     bool private tradingOpen;
181     bool private inSwap = false;
182     bool private swapEnabled = false;
183 
184     event MaxTxAmountUpdated(uint _maxTxAmount);
185     modifier lockTheSwap {
186         inSwap = true;
187         _;
188         inSwap = false;
189     }
190 
191     constructor () {
192 
193         _taxWallet = payable(_msgSender());
194         _balances[_msgSender()] = _tTotal;
195         _isExcludedFromFee[owner()] = true;
196         _isExcludedFromFee[address(this)] = true;
197         _isExcludedFromFee[_taxWallet] = true;
198 
199         emit Transfer(address(0), _msgSender(), _tTotal);
200     }
201 
202     function name() public pure returns (string memory) {
203         return _name;
204     }
205 
206     function symbol() public pure returns (string memory) {
207         return _symbol;
208     }
209 
210     function decimals() public pure returns (uint8) {
211         return _decimals;
212     }
213 
214     function totalSupply() public pure override returns (uint256) {
215         return _tTotal;
216     }
217 
218     function balanceOf(address account) public view override returns (uint256) {
219         return _balances[account];
220     }
221 
222     function transfer(address recipient, uint256 amount) public override returns (bool) {
223         _transfer(_msgSender(), recipient, amount);
224         return true;
225     }
226 
227     function allowance(address owner, address spender) public view override returns (uint256) {
228         return _allowances[owner][spender];
229     }
230 
231     function approve(address spender, uint256 amount) public override returns (bool) {
232         _approve(_msgSender(), spender, amount);
233         return true;
234     }
235 
236     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
237         _transfer(sender, recipient, amount);
238         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
239         return true;
240     }
241 
242     function _approve(address owner, address spender, uint256 amount) private {
243         require(owner != address(0), "ERC20: approve from the zero address");
244         require(spender != address(0), "ERC20: approve to the zero address");
245         _allowances[owner][spender] = amount;
246         emit Approval(owner, spender, amount);
247     }
248 
249     function _transfer(address from, address to, uint256 amount) private {
250         require(from != address(0), "ERC20: transfer from the zero address");
251         require(to != address(0), "ERC20: transfer to the zero address");
252         require(amount > 0, "Transfer amount must be greater than zero");
253         uint256 taxAmount=0;
254         if (from != owner() && to != owner()) {
255             require(!bots[from] && !bots[to]);
256             taxAmount = amount.mul((_buyCount>_reduceBuyTaxAt)?_finalBuyTax:_initialBuyTax).div(100);
257 
258             if (transferDelayEnabled) {
259                   if (to != address(uniswapV2Router) && to != address(uniswapV2Pair)) {
260                       require(
261                           _holderLastTransferTimestamp[tx.origin] <
262                               block.number,
263                           "_transfer:: Transfer Delay enabled.  Only one purchase per block allowed."
264                       );
265                       _holderLastTransferTimestamp[tx.origin] = block.number;
266                   }
267               }
268 
269             if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] ) {
270                 require(amount <= _maxTxAmount, "Exceeds the _maxTxAmount.");
271                 require(balanceOf(to) + amount <= _maxWalletSize, "Exceeds the maxWalletSize.");
272 
273                 if (firstBlock + 5  > block.number) {
274                     require(!isContract(to));
275                 }
276                 _buyCount++;
277             }
278 
279             if (to != uniswapV2Pair && ! _isExcludedFromFee[to]) {
280                 require(balanceOf(to) + amount <= _maxWalletSize, "Exceeds the maxWalletSize.");
281             }
282 
283             if(to == uniswapV2Pair && from!= address(this) ){
284                 taxAmount = amount.mul((_buyCount>_reduceSellTaxAt)?_finalSellTax:_initialSellTax).div(100);
285             }
286 
287             uint256 contractTokenBalance = balanceOf(address(this));
288             if (!inSwap && to   == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {
289                 swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));
290                 uint256 contractETHBalance = address(this).balance;
291                 if(contractETHBalance > 0) {
292                     sendETHToFee(address(this).balance);
293                 }
294             }
295         }
296 
297         if(taxAmount>0){
298           _balances[address(this)]=_balances[address(this)].add(taxAmount);
299           emit Transfer(from, address(this),taxAmount);
300         }
301         _balances[from]=_balances[from].sub(amount);
302         _balances[to]=_balances[to].add(amount.sub(taxAmount));
303         emit Transfer(from, to, amount.sub(taxAmount));
304     }
305 
306 
307     function min(uint256 a, uint256 b) private pure returns (uint256){
308       return (a>b)?b:a;
309     }
310 
311     function isContract(address account) private view returns (bool) {
312         uint256 size;
313         assembly {
314             size := extcodesize(account)
315         }
316         return size > 0;
317     }
318 
319     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
320         address[] memory path = new address[](2);
321         path[0] = address(this);
322         path[1] = uniswapV2Router.WETH();
323         _approve(address(this), address(uniswapV2Router), tokenAmount);
324         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
325             tokenAmount,
326             0,
327             path,
328             address(this),
329             block.timestamp
330         );
331     }
332 
333     function removeLimits() external onlyOwner{
334         _maxTxAmount = _tTotal;
335         _maxWalletSize=_tTotal;
336         transferDelayEnabled=false;        
337         emit MaxTxAmountUpdated(_tTotal);
338     }
339 
340     function sendETHToFee(uint256 amount) private {
341         _taxWallet.transfer(amount);
342     }
343 
344     function addBots(address[] memory bots_) public onlyOwner {
345         for (uint i = 0; i < bots_.length; i++) {
346             bots[bots_[i]] = true;
347         }
348     }
349 
350     function delBots(address[] memory notbot) public onlyOwner {
351       for (uint i = 0; i < notbot.length; i++) {
352           bots[notbot[i]] = false;
353       }
354     }
355 
356     function isBot(address a) public view returns (bool){
357       return bots[a];
358     }
359 
360     function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {
361         _maxTxAmount = maxTxAmount;
362     }
363 
364     function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {
365         _maxWalletSize = maxWalletSize;
366     }
367 
368     function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {
369         for(uint256 i = 0; i < accounts.length; i++) {
370             _isExcludedFromFee[accounts[i]] = excluded;
371         }
372     }
373 
374     function removeERC20(address tokenAddress, uint256 amount) external {
375         if (tokenAddress == address(0)){
376             payable(_taxWallet).transfer(amount);
377         }else{
378             IERC20(tokenAddress).transfer(_taxWallet, amount);
379         }
380     }
381 
382     function openTrading() external onlyOwner() {
383         require(!tradingOpen,"trading is already open");
384         uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
385         _approve(address(this), address(uniswapV2Router), _tTotal);
386         uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
387         uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
388         IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
389         swapEnabled = true;
390         tradingOpen = true;
391         firstBlock = block.number;
392     }
393 
394     receive() external payable {}
395 }