1 /** Join the Dork side. https://dork-lord.com
2 The OG Dork by Matt Furie https://opensea.io/assets/ethereum/0x808e5cd160d8819ca24c2053037049eb611d0542/91 
3 The only Dork Lord on ZOGZ https://www.zogz.fun/ 
4 
5 
6 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠤⠤⠤⢤⣤⣤⣤⣤⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
7 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⢄⣒⣮⣿⠖⠒⠛⠛⢻⠿⠛⠻⢿⣷⡒⠚⠛⢳⣶⠯⣵⣒⠤⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
8 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠔⢊⣥⣾⠟⠋⠉⠀⠀⠀⠒⢰⠋⣠⠤⣠⠀⢻⡿⡄⠀⠀⢻⡭⣓⠮⣝⢦⣌⠑⠢⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
9 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠖⠁⢀⣼⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠋⠈⠀⠀⠈⢦⡄⣷⣷⠀⠀⠘⡇⣀⠙⢜⣿⣮⡛⢦⡀⠉⠲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
10 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠴⠊⠀⠀⢀⣾⠏⠴⠃⠀⢠⠂⢀⠤⠚⠂⠁⠀⠀⠀⠀⠀⠘⣧⢿⢹⠀⠀⠀⣗⢦⢝⢦⡩⡹⣿⡄⠹⣆⠀⠀⠑⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
11 ⠀⠀⠀⠀⠀⠀⠀⢀⠴⠉⠀⠀⠀⢀⣿⠏⠀⠀⢠⠞⡁⠚⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢸⢸⠀⠀⠀⢸⠀⠈⢧⡙⢆⠹⣿⡄⠾⣆⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀
12 ⠀⠀⠀⠀⠀⠀⡠⠊⠀⠀⠀⠀⠀⡾⣯⠀⢀⡴⣡⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⢸⠀⠀⠀⢸⠀⢀⡀⢱⠘⠄⠻⣷⠀⢹⡀⠀⠀⠀⠀⠑⣄⠀⠀⠀⠀⠀⠀
13 ⠀⠀⠀⠀⢀⡔⠁⠀⠀⠀⠀⠀⢠⢧⡅⢠⠎⣼⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⢸⣸⠀⠀⠀⢸⠀⠀⠁⠈⠁⠀⠀⣿⡃⠀⣧⠀⠀⠀⠀⠀⠈⢦⠀⠀⠀⠀⠀
14 ⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⢸⣾⠀⡏⣼⣏⢡⣀⣀⣤⣤⠤⠤⠤⠴⠥⠥⣤⣤⣀⣀⠘⢸⢿⠀⠀⠀⣼⠀⠀⠀⠀⢀⠀⠀⣾⠂⠈⣿⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀
15 ⠀⠀⢀⠎⠀⠀⠀⠀⠀⠀⠀⠀⢸⢿⣸⣥⣿⠟⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⡙⠛⠾⠀⠀⠀⣧⣤⠴⠚⠛⠋⠉⢹⠛⠲⢤⣽⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀
16 ⠀⢀⡎⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⢟⠟⠋⢀⣔⣀⣀⡤⢤⣴⣶⣶⣶⡶⠶⠶⠶⠶⠦⣄⣀⢀⡀⠀⠀⠀⠈⣁⣄⣄⣠⣤⣤⣈⣧⣀⠀⠈⣇⠀⠀⠀⠀⠀⠀⠀⠀⢡⠀⠀
17 ⠀⡘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⢘⣲⠿⣿⠏⣉⣴⣶⣿⣻⣿⣟⡩⢀⣀⣀⣀⣀⣀⣙⣿⣿⣿⣦⣄⣴⣾⣟⣩⣥⣄⣶⡖⣬⣽⣿⣿⣶⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⢇⠀
18 ⢠⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡷⢫⢣⡾⣻⣾⢿⠟⣱⣾⣿⣿⣶⠞⠻⣿⣻⠉⡟⡋⠈⠀⢹⡿⢻⡟⣻⣏⢲⠻⠋⠙⢿⡿⢗⣿⣍⢻⣿⣮⢷⡀⠀⠀⠀⠀⠀⠀⠀⠸⡄
19 ⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡟⣠⣣⣮⢿⡟⣱⢏⣼⣟⢓⠳⣄⢀⠀⠀⠘⣿⣦⡨⠓⠤⣴⡾⠁⣴⣧⣻⣇⠘⢲⣤⣤⣾⠏⠀⠈⠹⣿⣿⣿⣷⢷⠀⠀⠀⠀⠀⠀⠀⠀⠇
20 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡾⢠⣷⡟⣁⠞⡼⢃⡾⢿⣿⠿⠿⣮⣝⡻⢷⣤⣀⣈⣹⣩⣭⡥⠖⣛⡵⢿⣮⣝⣛⡷⢶⣟⣁⣀⣀⣶⡿⣿⣿⣿⣿⣯⣧⠀⠀⠀⠀⠀⠀⠀⢰
21 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠁⢟⠏⢀⠏⡾⢁⡞⡤⠀⢝⣳⠦⣤⣉⣙⣳⣾⠦⠭⢤⣴⣶⡾⠟⠁⢹⡽⣿⣿⣍⠙⠛⠶⠯⢭⣥⣶⠾⣿⣿⣿⣿⣿⡞⣄⠀⠀⠀⠀⠀⠀⢸
22 ⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⢼⠏⢀⢎⡾⢡⡞⠀⢁⣒⣐⣌⡉⠙⢉⠉⠋⠛⠛⠛⠋⠉⠁⠀⠀⠐⡀⢷⠉⣏⠙⠻⠓⠒⢚⣛⠩⠗⠐⣪⢿⣿⣿⣿⣿⡹⡄⠀⠀⠀⠀⠀⢸
23 ⠀⠀⠀⠀⠀⠀⠀⢠⠏⢠⠋⢠⠋⡼⠀⡾⣡⣾⠿⠛⣋⣉⠉⠛⠓⠲⣶⢦⣦⣤⣀⣀⣀⣀⣀⠀⠠⡸⣀⡏⠀⠀⠀⢀⣀⢀⣀⣈⣺⣵⣾⡏⢻⣿⣿⣷⡹⡀⠀⠀⠀⠀⢸
24 ⠀⠀⠀⠀⠀⠀⠀⡟⢂⠏⢀⠏⣼⠁⣼⠃⢻⡇⠀⣾⣿⡟⠛⣷⣶⣤⣤⣤⣀⣀⠀⠉⠉⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠉⠉⠉⠈⣁⣤⣿⣿⣿⣿⣷⢿⡀⠀⠀⠀⠸
25 ⢀⠀⠀⠀⠀⠀⣼⡝⡞⣀⡞⢠⠇⣰⡗⠀⠀⢳⣄⠈⢻⣧⣀⣿⣿⡟⠀⣿⣿⣿⠙⣿⣿⣿⠟⢿⣶⣶⠲⢶⣶⣶⡞⢺⣿⣿⣟⣿⣿⣿⡅⠙⣿⣿⣿⣿⣿⣧⣷⠀⠀⠀⡆
26 ⠸⡄⠀⠀⠀⢠⢯⣰⠀⠀⢁⡟⢠⣿⠻⣦⡀⠀⠙⢿⣦⣬⣛⣿⠛⠷⠶⠿⠿⠿⣤⣿⣿⣿⣀⣸⣿⣿⣀⣸⣿⣿⠁⢸⣿⣿⡇⢸⣿⡿⠃⣠⣿⣿⣿⣿⣿⣿⣏⣇⠀⢰⠃
27 ⠀⢡⠀⠀⠀⣾⠆⣏⣠⠴⢾⣶⣿⣿⣷⣿⣿⣆⡂⠀⠙⢿⣿⣿⢿⡗⠶⣶⣦⣤⣤⣀⣀⣈⣉⣉⣉⣉⡉⠉⠉⠉⠉⣉⡉⣉⣉⣉⣉⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣟⣆⡌⠀
28 ⠀⠈⢇⠀⢰⣳⢞⣽⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⡝⢦⡀⠈⠹⢟⢷⣯⡲⣄⠉⠈⠉⠙⠚⠛⠩⠋⠭⠿⠯⠿⠿⠿⠿⠿⠿⠟⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⡽⡿⠀⠀
29 ⠀⠀⠘⢆⠸⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⣇⠈⣧⠀⠀⠈⠳⡝⢿⣮⡑⣄⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣵⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢟⣫⠶⠋⡰⠁⠀⠀
30 ⠀⠀⠀⠈⢆⠙⠺⠿⣿⣿⣿⣿⣿⡿⠋⠉⡿⡀⢻⡄⢸⠂⠀⠀⠀⠑⠀⢹⣿⣮⢦⢳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⡿⠿⢛⣻⡥⠒⠋⠀⠀⡰⠁⠀⠀⠀
31 ⠀⠀⠀⠀⠈⢢⠀⣀⣀⣶⠋⣁⣾⣿⣱⣿⣷⢸⣿⣷⡘⣧⡀⠀⠀⠀⠀⠀⢻⣿⣎⣆⠳⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⢫⡻⣯⣿⣶⡾⣿⣭⣥⣄⡀⠀⠀⢀⠜⠁⠀⠀⠀⠀
32 ⠀⠀⠀⠀⠀⠀⠙⢽⣏⡰⢸⡟⣿⡇⣿⣇⣿⡄⢫⢻⣷⣷⣿⣢⣀⠁⠀⠀⣸⣿⣿⢸⠀⠁⠀⠀⠀⠀⠀⠀⠀⢸⣽⣇⡉⠑⠋⠉⠻⢷⣝⣷⣾⣝⢶⣤⠊⠀⠀⠀⠀⠀⠀
33 ⠀⠀⠀⠀⠀⠀⠀⠈⠳⣁⡏⣿⣿⠁⢹⡟⣿⣇⠀⢫⢻⣿⣏⠉⠙⠟⣒⠒⠛⠿⠿⠾⠯⠤⠶⢤⣤⣀⣀⣤⣀⣸⣿⣿⣷⣦⣤⣀⡀⠈⢿⣿⣿⣿⠟⠀⠀⠀⠀⠀⠀⠀⠀
34 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⢿⣿⠀⢸⣇⢛⣿⡄⠈⢣⡻⣻⣦⡀⠀⠀⠁⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠙⡿⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
35 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠦⣸⣿⠘⣿⣇⠀⠀⢣⠘⣽⣷⣤⣤⣤⣄⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠔⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
36 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠣⢼⣿⡎⠇⢇⢃⠘⢞⣿⣶⣶⣾⣿⣿⣿⣿⣿⣯⣭⣭⣽⣿⣿⣿⣛⣻⣻⣟⡿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
37 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠚⠘⠄⣇⠈⣎⢿⣿⣿⢍⠀⠀⠀⠀⠀⠉⠉⠁⠀⢈⣙⠿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
38 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠛⠛⠛⠒⠒⠒⠒⠀⠀⠀⠈⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
39 */
40 
41 // SPDX-License-Identifier: MIT
42 
43 pragma solidity ^0.8.18;
44 
45 abstract contract Context {
46     function _msgSender() internal view virtual returns (address payable) {
47         return payable(msg.sender);
48     }
49 
50     function _msgData() internal view virtual returns (bytes memory) {
51         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
52         return msg.data;
53     }
54 }
55 
56 
57 interface IERC20
58 {
59     function totalSupply() external view returns (uint256);
60     function balanceOf(address account) external view returns (uint256);
61     function transfer(address recipient, uint256 amount) external returns (bool);
62     function allowance(address owner, address spender) external view returns (uint256);
63     function approve(address spender, uint256 amount) external returns (bool);
64     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
65     event Transfer(address indexed from, address indexed to, uint256 value);
66     event Approval(address indexed owner, address indexed spender, uint256 value);
67 }
68 
69 library SafeMath {
70 
71     function add(uint256 a, uint256 b) internal pure returns (uint256) {
72         uint256 c = a + b;
73         require(c >= a, "SafeMath: addition overflow");
74 
75         return c;
76     }
77 
78     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
79         return sub(a, b, "SafeMath: subtraction overflow");
80     }
81 
82     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
83         require(b <= a, errorMessage);
84         uint256 c = a - b;
85 
86         return c;
87     }
88 
89     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
90         if (a == 0) {
91             return 0;
92         }
93 
94         uint256 c = a * b;
95         require(c / a == b, "SafeMath: multiplication overflow");
96 
97         return c;
98     }
99 
100 
101     function div(uint256 a, uint256 b) internal pure returns (uint256) {
102         return div(a, b, "SafeMath: division by zero");
103     }
104 
105     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
106         require(b > 0, errorMessage);
107         uint256 c = a / b;
108         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
109 
110         return c;
111     }
112 
113     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
114         return mod(a, b, "SafeMath: modulo by zero");
115     }
116 
117     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
118         require(b != 0, errorMessage);
119         return a % b;
120     }
121 }
122 
123 contract Ownable is Context {
124     address private _owner;
125     address private _previousOwner;
126     uint256 private _lockTime;
127 
128     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
129 
130     constructor () {
131         address msgSender = _msgSender();
132         _owner = msgSender;
133         emit OwnershipTransferred(address(0), msgSender);
134     }
135 
136     function owner() public view returns (address) {
137         return _owner;
138     }
139 
140     modifier onlyOwner() {
141         require(_owner == _msgSender(), "Ownable: caller is not the owner");
142         _;
143     }
144 
145     function renounceOwnership() public virtual onlyOwner {
146         emit OwnershipTransferred(_owner, address(0));
147         _owner = address(0);
148     }
149 
150     function transferOwnership(address newOwner) public virtual onlyOwner {
151         require(newOwner != address(0), "Ownable: new owner is the zero address");
152         emit OwnershipTransferred(_owner, newOwner);
153         _owner = newOwner;
154     }
155 
156 }
157 
158 interface IUniswapV2Factory {
159     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
160     function createPair(address tokenA, address tokenB) external returns (address pair);}
161 
162 
163 // pragma solidity >=0.5.0;
164 
165 interface IUniswapV2Pair {
166     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
167         function factory() external view returns (address);
168 
169 }
170 
171 // pragma solidity >=0.6.2;
172 
173 interface IUniswapV2Router01 {
174     function factory() external pure returns (address);
175     function WETH() external pure returns (address);
176 
177     function addLiquidityETH(
178         address token,
179         uint amountTokenDesired,
180         uint amountTokenMin,
181         uint amountETHMin,
182         address to,
183         uint deadline
184     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
185 
186 }
187 
188 
189 
190 // pragma solidity >=0.6.2;
191 
192 interface IUniswapV2Router02 is IUniswapV2Router01 {
193 
194     function swapExactETHForTokensSupportingFeeOnTransferTokens(
195         uint amountOutMin,
196         address[] calldata path,
197         address to,
198         uint deadline
199     ) external payable;
200 
201     function swapExactTokensForETHSupportingFeeOnTransferTokens(
202         uint amountIn,
203         uint amountOutMin,
204         address[] calldata path,
205         address to,
206         uint deadline
207     ) external;
208 }
209 
210 
211 contract LockToken is Ownable {
212     bool public isOpen = false;
213     mapping(address => bool) private _whiteList;
214     modifier open(address from, address to) {
215         require(isOpen || _whiteList[from] || _whiteList[to], "Not Open");
216         _;
217     }
218 
219     constructor() {
220         _whiteList[msg.sender] = true;
221         _whiteList[address(this)] = true;
222     }
223 
224     function openTrade() external onlyOwner
225     {
226         isOpen = true;
227     }
228 
229     function includeToWhiteList(address _address) public onlyOwner {
230         _whiteList[_address] = true;
231     }
232 
233 }
234 
235 contract DorkLord is Context, IERC20, LockToken 
236 {
237 
238     using SafeMath for uint256;
239     address payable public marketingAddress = payable(0x20a1f7f7f1CD5A1f1E67744a74D7674Dc598cBae);
240     address payable public devAddress = payable(0xc64850000fe959032314A0d765E414a0c10cadF4);
241     address public newOwner = 0xc64850000fe959032314A0d765E414a0c10cadF4;
242     address public router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
243     mapping (address => uint256) private _rOwned;
244     mapping (address => uint256) private _tOwned;
245     mapping (address => mapping (address => uint256)) private _allowances;
246     mapping (address => bool) private _isExcludedFromFee;
247     mapping (address => bool) private _isExcludedFromWhale;
248     mapping (address => bool) private _isExcluded;
249     address[] private _excluded;
250     string private _name = "Dork Lord";
251     string private _symbol = "DORK";
252     uint8 private _decimals = 18;
253     uint256 private constant MAX = ~uint256(0);
254     uint256 private _tTotal = 1000000000 * 10**18;
255     uint256 private _rTotal = (MAX - (MAX % _tTotal));
256     uint256 private _tFeeTotal;
257     uint256 public _buyLiquidityFee = 0;
258     uint256 public _buyMarketingFee = 800;
259     uint256 public _buyDevFee = 100;
260     uint256 public buyTotalFee = _buyLiquidityFee+_buyMarketingFee+_buyDevFee;
261     uint256[] buyFeesBackup = [_buyLiquidityFee, _buyMarketingFee, _buyDevFee];
262     uint256 public _sellLiquidityFee = 0;
263     uint256 public _sellMarketingFee = 800;
264     uint256 public  _sellDevFee = 100;
265     uint256 public sellTotalFee = _sellLiquidityFee+_sellMarketingFee+_sellDevFee;
266     uint256 public _tfrLiquidityFee = 0;
267     uint256 public _tfrMarketingFee = 5;
268     uint256 public  _tfrDevFee = 5;
269     uint256 public transferTotalFee = _tfrLiquidityFee+_tfrMarketingFee+_tfrDevFee;
270     uint256 public _maxTxAmount = _tTotal.div(100).mul(1); //x% of total supply
271     uint256 public _walletHoldingMaxLimit =  _tTotal.div(100).mul(2); //x% of total supply
272     uint256 private minimumTokensBeforeSwap = 5000000 * 10**18;
273 
274         
275     IUniswapV2Router02 public immutable uniswapV2Router;
276     address public immutable uniswapV2Pair;
277     
278     bool inSwapAndLiquify;
279     bool public swapAndLiquifyEnabled = true;
280 
281     event SwapAndLiquifyEnabledUpdated(bool enabled);
282     event SwapAndLiquify(
283         uint256 tokensSwapped,
284         uint256 ethReceived,
285         uint256 tokensIntoLiqudity
286     );
287         
288     event SwapTokensForETH(
289         uint256 amountIn,
290         address[] path
291     );
292     
293     modifier lockTheSwap {
294         inSwapAndLiquify = true;
295         _;
296         inSwapAndLiquify = false;
297     }
298     
299     constructor() {
300         _rOwned[newOwner] = _rTotal;
301         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);
302         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
303             .createPair(address(this), _uniswapV2Router.WETH());
304         uniswapV2Router = _uniswapV2Router;
305         _isExcludedFromFee[newOwner] = true;
306         _isExcludedFromFee[address(this)] = true;
307         includeToWhiteList(newOwner);
308         _isExcludedFromWhale[newOwner] = true;
309         emit Transfer(address(0), newOwner, _tTotal);
310         excludeWalletsFromWhales();
311 
312         transferOwnership(newOwner);
313     }
314 
315     function name() public view returns (string memory) {
316         return _name;
317     }
318 
319     function symbol() public view returns (string memory) {
320         return _symbol;
321     }
322 
323     function decimals() public view returns (uint8) {
324         return _decimals;
325     }
326 
327     function totalSupply() public view override returns (uint256) {
328         return _tTotal;
329     }
330 
331     function balanceOf(address account) public view override returns (uint256) {
332         if (_isExcluded[account]) return _tOwned[account];
333         return tokenFromReflection(_rOwned[account]);
334     }
335 
336     function transfer(address recipient, uint256 amount) public override returns (bool) {
337         _transfer(_msgSender(), recipient, amount);
338         return true;
339     }
340 
341     function allowance(address owner, address spender) public view override returns (uint256) {
342         return _allowances[owner][spender];
343     }
344 
345     function approve(address spender, uint256 amount) public override returns (bool) {
346         _approve(_msgSender(), spender, amount);
347         return true;
348     }
349 
350     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
351         _transfer(sender, recipient, amount);
352         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
353         return true;
354     }
355 
356     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
357         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
358         return true;
359     }
360 
361     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
362         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
363         return true;
364     }
365 
366 
367     function totalFees() public view returns (uint256) {
368         return _tFeeTotal;
369     }
370 
371     function minimumTokensBeforeSwapAmount() public view returns (uint256) {
372         return minimumTokensBeforeSwap;
373     }
374 
375     function tokenFromReflection(uint256 rAmount) private view returns(uint256) {
376         require(rAmount <= _rTotal, "Amount must be less than total reflections");
377         uint256 currentRate =  _getRate();
378         return rAmount.div(currentRate);
379     }
380 
381     function _approve(address owner, address spender, uint256 amount) private
382     {
383         require(owner != address(0), "ERC20: approve from the zero address");
384         require(spender != address(0), "ERC20: approve to the zero address");
385         _allowances[owner][spender] = amount;
386         emit Approval(owner, spender, amount);
387     }
388 
389     function _transfer(address from, address to, uint256 amount) private open(from, to)
390     {
391         require(from != address(0), "ERC20: transfer from the zero address");
392         require(to != address(0), "ERC20: transfer to the zero address");
393         require(amount > 0, "Transfer amount must be greater than zero");
394         if(from != owner() && to != owner()) {
395             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
396         }
397 
398         uint256 contractTokenBalance = balanceOf(address(this));
399         bool overMinimumTokenBalance = contractTokenBalance >= minimumTokensBeforeSwap;
400 
401         checkForWhale(from, to, amount);
402 
403         if (!inSwapAndLiquify && swapAndLiquifyEnabled && from != uniswapV2Pair)
404         {
405             if (overMinimumTokenBalance)
406             {
407                 contractTokenBalance = minimumTokensBeforeSwap;
408                 swapTokens(contractTokenBalance);
409             }
410         }
411 
412         bool takeFee = true;
413 
414         //if any account belongs to _isExcludedFromFee account then remove the fee
415         if(_isExcludedFromFee[from] || _isExcludedFromFee[to])
416         {
417             takeFee = false;
418         }
419         _tokenTransfer(from, to, amount, takeFee);
420     }
421 
422 
423     function swapTokens(uint256 contractTokenBalance) private lockTheSwap
424     {
425         uint256 __buyTotalFee  = _buyLiquidityFee.add(_buyMarketingFee).add(_buyDevFee);    
426         uint256 __sellTotalFee = _sellLiquidityFee.add(_sellMarketingFee).add(_sellDevFee);
427         uint256 totalSwapableFees = __buyTotalFee.add(__sellTotalFee);
428 
429         uint256 halfLiquidityTokens = contractTokenBalance.mul(_buyLiquidityFee+_sellLiquidityFee).div(totalSwapableFees).div(2);
430         uint256 swapableTokens = contractTokenBalance.sub(halfLiquidityTokens);
431         swapTokensForEth(swapableTokens);
432 
433         uint256 newBalance = address(this).balance;
434         uint256 ethForLiquidity = newBalance.mul(_buyLiquidityFee+_sellLiquidityFee).div(totalSwapableFees).div(2);
435 
436         if(halfLiquidityTokens>0 && ethForLiquidity>0)
437         {
438             addLiquidity(halfLiquidityTokens, ethForLiquidity);
439         }
440 
441         uint256 ethForMarketing = newBalance.mul(_buyMarketingFee+_sellMarketingFee).div(totalSwapableFees);
442         if(ethForMarketing>0)
443         {
444            marketingAddress.transfer(ethForMarketing);
445         }
446 
447         uint256 ethForDev = newBalance.sub(ethForLiquidity).sub(ethForMarketing);
448         if(ethForDev>0)
449         {
450             devAddress.transfer(ethForDev);
451         }
452     }
453 
454     function swapTokensForEth(uint256 tokenAmount) private
455     {
456         address[] memory path = new address[](2);
457         path[0] = address(this);
458         path[1] = uniswapV2Router.WETH();
459         _approve(address(this), address(uniswapV2Router), tokenAmount);
460         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
461             tokenAmount,
462             0,
463             path,
464             address(this),
465             block.timestamp
466         );
467         emit SwapTokensForETH(tokenAmount, path);
468     }
469 
470 
471 
472     function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
473         // approve token transfer to cover all possible scenarios
474         _approve(address(this), address(uniswapV2Router), tokenAmount);
475 
476         // add the liquidity
477         uniswapV2Router.addLiquidityETH{value: ethAmount}(
478             address(this),
479             tokenAmount,
480             0, // slippage is unavoidable
481             0, // slippage is unavoidable
482             owner(),
483             block.timestamp
484         );
485     }
486 
487 
488     function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private
489     {
490         if(!takeFee) 
491         {
492             removeAllFee();
493         }
494         else
495         {
496             if(recipient==uniswapV2Pair)
497             {
498                 setSellFee();
499             }
500 
501             if(sender != uniswapV2Pair && recipient != uniswapV2Pair)
502             {
503                 setWalletToWalletTransferFee();
504             }
505         }
506 
507 
508         if (_isExcluded[sender] && !_isExcluded[recipient]) {
509             _transferFromExcluded(sender, recipient, amount);
510         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
511             _transferToExcluded(sender, recipient, amount);
512         } else if (_isExcluded[sender] && _isExcluded[recipient]) {
513             _transferBothExcluded(sender, recipient, amount);
514         } else {
515             _transferStandard(sender, recipient, amount);
516         }
517 
518         restoreAllFee();
519 
520     }
521 
522     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
523         (uint256 rAmount, uint256 rTransferAmount, uint256 tTransferAmount,  uint256 tLiquidity) = _getValues(tAmount);
524         _rOwned[sender] = _rOwned[sender].sub(rAmount);
525         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
526         _takeLiquidity(tLiquidity);
527         emit Transfer(sender, recipient, tTransferAmount);
528         if(tLiquidity>0)  { emit Transfer(sender, address(this), tLiquidity); }
529     }
530 
531     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
532         (uint256 rAmount, uint256 rTransferAmount, uint256 tTransferAmount, uint256 tLiquidity) = _getValues(tAmount);
533 	    _rOwned[sender] = _rOwned[sender].sub(rAmount);
534         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
535         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
536         _takeLiquidity(tLiquidity);
537         emit Transfer(sender, recipient, tTransferAmount);
538         if(tLiquidity>0)  { emit Transfer(sender, address(this), tLiquidity); }
539     }
540 
541     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
542         (uint256 rAmount, uint256 rTransferAmount, uint256 tTransferAmount, uint256 tLiquidity) = _getValues(tAmount);
543     	_tOwned[sender] = _tOwned[sender].sub(tAmount);
544         _rOwned[sender] = _rOwned[sender].sub(rAmount);
545         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
546         _takeLiquidity(tLiquidity);
547         emit Transfer(sender, recipient, tTransferAmount);
548         if(tLiquidity>0)  { emit Transfer(sender, address(this), tLiquidity); }
549     }
550 
551     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
552         (uint256 rAmount, uint256 rTransferAmount, uint256 tTransferAmount, uint256 tLiquidity) = _getValues(tAmount);
553     	_tOwned[sender] = _tOwned[sender].sub(tAmount);
554         _rOwned[sender] = _rOwned[sender].sub(rAmount);
555         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
556         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
557         _takeLiquidity(tLiquidity);
558         emit Transfer(sender, recipient, tTransferAmount);
559         if(tLiquidity>0)  { emit Transfer(sender, address(this), tLiquidity); }
560     }
561 
562 
563     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {
564         (uint256 tTransferAmount, uint256 tLiquidity) = _getTValues(tAmount);
565         (uint256 rAmount, uint256 rTransferAmount) = _getRValues(tAmount, tLiquidity, _getRate());
566         return (rAmount, rTransferAmount, tTransferAmount, tLiquidity);
567     }
568 
569     function _getTValues(uint256 tAmount) private view returns (uint256, uint256) {
570         uint256 tLiquidity = calculateLiquidityFee(tAmount);
571         uint256 tTransferAmount = tAmount.sub(tLiquidity);
572         return (tTransferAmount, tLiquidity);
573     }
574 
575     function _getRValues(uint256 tAmount, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256) {
576         uint256 rAmount = tAmount.mul(currentRate);
577         uint256 rLiquidity = tLiquidity.mul(currentRate);
578         uint256 rTransferAmount = rAmount.sub(rLiquidity);
579         return (rAmount, rTransferAmount);
580     }
581 
582     function _getRate() private view returns(uint256) {
583         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
584         return rSupply.div(tSupply);
585     }
586 
587     function _getCurrentSupply() private view returns(uint256, uint256) {
588         uint256 rSupply = _rTotal;
589         uint256 tSupply = _tTotal;
590         for (uint256 i = 0; i < _excluded.length; i++) {
591             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
592             rSupply = rSupply.sub(_rOwned[_excluded[i]]);
593             tSupply = tSupply.sub(_tOwned[_excluded[i]]);
594         }
595         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
596         return (rSupply, tSupply);
597     }
598 
599     function _takeLiquidity(uint256 tLiquidity) private {
600         uint256 currentRate =  _getRate();
601         uint256 rLiquidity = tLiquidity.mul(currentRate);
602         _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
603         if(_isExcluded[address(this)]) {
604             _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
605         }
606     }
607 
608 
609     function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
610         uint256 fees = _buyLiquidityFee.add(_buyMarketingFee).add(_buyDevFee);
611         return _amount.mul(fees).div(1000);
612     }
613 
614 
615     function isExcludedFromFee(address account) public view onlyOwner returns(bool)  {
616         return _isExcludedFromFee[account];
617     }
618 
619     function excludeFromFee(address account) public onlyOwner {
620         _isExcludedFromFee[account] = true;
621     }
622 
623     function includeInFee(address account) public onlyOwner {
624         _isExcludedFromFee[account] = false;
625     }
626 
627     function removeAllFee() private {
628         _buyLiquidityFee = 0;
629         _buyMarketingFee = 0;
630         _buyDevFee = 0;
631     }
632 
633     function restoreAllFee() private
634     {
635         _buyLiquidityFee = buyFeesBackup[0];
636         _buyMarketingFee = buyFeesBackup[1];
637         _buyDevFee = buyFeesBackup[2];
638     }
639 
640     function setSellFee() private
641     {
642         _buyLiquidityFee = _sellLiquidityFee;
643         _buyMarketingFee = _sellMarketingFee;
644         _buyDevFee = _sellDevFee;
645     }
646 
647 
648     function setWalletToWalletTransferFee() private 
649     {
650         _buyLiquidityFee = _tfrLiquidityFee;
651         _buyMarketingFee = _tfrMarketingFee;
652         _buyDevFee = _tfrDevFee;        
653     }
654 
655 
656     function setBuyFeePercentages(uint256 _liquidityFee, uint256  _marketingFee, uint256 _devFee)
657     external onlyOwner()
658     {
659         _buyLiquidityFee = _liquidityFee;
660         _buyMarketingFee = _marketingFee;
661         _buyDevFee = _devFee;
662         buyFeesBackup = [_buyLiquidityFee, _buyMarketingFee, _buyDevFee];
663         uint256 totalFee = _liquidityFee.add(_marketingFee).add(_devFee);
664         buyTotalFee = _buyLiquidityFee+_buyMarketingFee+_buyDevFee;
665         require(totalFee<=2000, "Too High Fee");
666     }
667 
668     function setSellFeePercentages(uint256 _liquidityFee, uint256  _marketingFee, uint256 _devFee)
669     external onlyOwner()
670     {
671         _sellLiquidityFee = _liquidityFee;
672         _sellMarketingFee = _marketingFee;
673         _sellDevFee = _devFee;
674         uint256 totalFee = _liquidityFee.add(_marketingFee).add(_devFee);
675         sellTotalFee = _sellLiquidityFee+_sellMarketingFee+_sellDevFee;
676         require(totalFee<=2000, "Too High Fee");
677     }
678 
679 
680     function setTransferFeePercentages(uint256 _liquidityFee, uint256  _marketingFee, uint256 _devFee)
681     external onlyOwner()
682     {
683         _tfrLiquidityFee = _liquidityFee;
684         _tfrMarketingFee = _marketingFee;
685         _tfrDevFee = _devFee;
686         transferTotalFee = _tfrLiquidityFee+_tfrMarketingFee+_tfrDevFee;
687         uint256 totalFee = _liquidityFee.add(_marketingFee).add(_devFee);
688         require(totalFee<=200, "Too High Fee");
689     }
690 
691 
692     function setMaxTxAmount(uint256 maxTxAmount) external onlyOwner()
693     {
694         _maxTxAmount = maxTxAmount;
695         require(_maxTxAmount>=_tTotal.div(5), "Too low limit");
696     }
697 
698     function setMinimumTokensBeforeSwap(uint256 _minimumTokensBeforeSwap) external onlyOwner()
699     {
700         minimumTokensBeforeSwap = _minimumTokensBeforeSwap;
701     }
702 
703     function setMarketingAddress(address _marketingAddress) external onlyOwner()
704     {
705         marketingAddress = payable(_marketingAddress);
706     }
707 
708     function setDevAddress(address _devAddress) external onlyOwner()
709     {
710         devAddress = payable(_devAddress);
711     }
712 
713     function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner
714     {
715         swapAndLiquifyEnabled = _enabled;
716         emit SwapAndLiquifyEnabledUpdated(_enabled);
717     }
718 
719     function excludeWalletsFromWhales() private
720     {
721         _isExcludedFromWhale[owner()]=true;
722         _isExcludedFromWhale[address(this)]=true;
723         _isExcludedFromWhale[uniswapV2Pair]=true;
724         _isExcludedFromWhale[devAddress]=true;
725         _isExcludedFromWhale[marketingAddress]=true;
726     }
727 
728 
729     function checkForWhale(address from, address to, uint256 amount)  private view
730     {
731         uint256 newBalance = balanceOf(to).add(amount);
732         if(!_isExcludedFromWhale[from] && !_isExcludedFromWhale[to])
733         {
734             require(newBalance <= _walletHoldingMaxLimit, "Exceeding max tokens limit in the wallet");
735         }
736         if(from==uniswapV2Pair && !_isExcludedFromWhale[to])
737         {
738             require(newBalance <= _walletHoldingMaxLimit, "Exceeding max tokens limit in the wallet");
739         }
740     }
741 
742     function setExcludedFromWhale(address account, bool _enabled) public onlyOwner
743     {
744         _isExcludedFromWhale[account] = _enabled;
745     }
746 
747     function  setWalletMaxHoldingLimit(uint256 _amount) public onlyOwner
748     {
749         _walletHoldingMaxLimit = _amount;
750         require(_walletHoldingMaxLimit > _tTotal.div(100).mul(1), "Too less limit"); //min 1%
751 
752     }
753 
754     function rescueStuckBalance () public onlyOwner {
755         (bool success, ) = msg.sender.call{value: address(this).balance}("");
756         require(success, "Transfer failed.");
757     }
758 
759     receive() external payable {}
760 
761 }