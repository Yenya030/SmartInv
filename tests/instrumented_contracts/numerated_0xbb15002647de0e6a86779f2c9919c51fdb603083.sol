1 // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
2 // ░░░░░░░░░░░░░▒▓██████████████████████████▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
3 // ░░░░░░░░░░░░▓█▓░░░░░░░░░░░░░░░░░░░░░░░░░░▓█▒░░░░░░▓▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
4 // ░░░░░░░░░░░▒██░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░▒██▓░░░░▒█████▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▓███▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
5 // ░░░░░▒░░░░░▓█▒░░███████▓▒▒▒▒▒▒▒▓███████░░▒███▓░▒▓██████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓▓▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
6 // ░░░░░▒▒▒▒▒▓█▓░░▒███████░░░░░░░░▒███████░░▒████▓▓▓███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░░░░░░░░
7 // ░░░░▒▒▒▒▒▒██░░░███████▒░░░░░░░░▒███████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓█▓░░░░░░░░
8 // ░░░░▒▒▒▒▒▓█▓░░▓███████░░░░░░░░░███████▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒░▒▒░▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒░▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░▓█▓░░░░░░░
9 // ░░░░░▒▒▒░██░░░███████▒░░░░░░░░▒███████░█▓░█████▓▓▓▓▓▓▓▓▓▓▓▓░▒▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓▒░▒▓░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████████░▒▒▒▓███▓▒▒███████▓▓▓███████░░░████░░░░░░
10 // ░░░░░░░░▒█▓░░▓███████░░░░░░░░░███████▒▒███████░░░░░░░░░░░░░░▓▓▓▓▓▓▓░░░░░░░░░▒▓▓▓▓▒▓▒░░░░░░░░░░░░░░░░░███████▒░▓▒▓███▓░░░██████▓░░▒██████▓░░▓████▒░░░░░
11 // ░░░░░░░░██░░░███████░░░░░░░░░▓██████▓░███████▒░░▓███████▒░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▓▓▓▓▒░████████████████████████░▒██████▒░░▓██████░░░███████░░░█████░░░░░░
12 // ░░░░█▒▒▓█▓░░▓███████░░░░░░░░▓█▓▓▒▓█▓░▒███████░░▒████████░░░▓▓▓▓▓▓▓░░░░░░░░░░░░░░░░░▒███████░░░░░░░░░███▓▓▓█▒░██████▓░░░██████▓░░▒██████▓░░▓████▒░░░░░░
13 // ░░▒▓██▓██░░░███████▓▓▓▓▓▓▓▓▓██▓░▒█▓░░███████▒░░▓████▓██▒░░▒▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░████████▓▓▓▓▓▓▓▓▓███▒░▓▓░▓██████▒░░▓██████░░░███▓░▒█░░▒█████░░░░░░░
14 // ░░░░▒░▒█▓░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▒▒░░▒████▓░██░░░▒▒░▒▒▒▒▒▒▒▒▒▒░▒▒░▒▒░▒▒░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒░░░▒▒▒▒▒▒▒░░░▒▒▒▒▒▒░░░▓████▓▒▒▒▒░░░
15 // ░░░░░░██░░░▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░▒█████░░▒█▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒░░░░░▒▒░░░░░▓▓▓▓▓▓▒░░▒█████▒▒▒▒▒░░░
16 // ░░░░░▒█▓░░▒██████▓▒▒▒▒▒▒▓███████░░▒███████████████▒░░░░▓█████████████████████████████▓░░░░░░░░░░░░████████████░░░▓▓▒░░░░░░▒▓▒░▓▒▓████░░░▒▓███▓▒▒▒▒▒▒░░
17 // ░░░░░██░░░███████▒░░░░░░███████▒░░▓███████████████▓▓▓▓▓██████████████████████████████░░░▓▓▓▓▓▒▓░░░████████████▓░░░▓░░▓▓▒░░░▒░░█▓████▒░▒░░░░▓█▓▒▒░░░░░░
18 // ░░░░▒█▓░░▒██████▓░░░░░░▒███████░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▓▓▓▓░▒▒░░░▒▒▒▒▒▒▒▒▒▒▒▒░░░▓█▒░░░░░▒▒░░▓█████▒▓▒███▒░░▓██░░░░░░░
19 // ░░░░██░░░███████▓▒▒▒▒▒▒███████▓▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░▓▓▓▓▓▓▒░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░███▓▓▓▒█▓▒██▓░░▓███░░░░░░
20 // ░░░▒█▓░░▓███████▓▓▓▓▓▓▓▓▓███████░░███████▓▓▓▓▓▓▓▓▓███████▓░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓████▒▓█░▓▓▓▓▓▓▓▓▒▓▓▓▓░░▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▒░░░░▓▓▓█▓▓▒▒▓▓░▒░░▒████▓░░░░░
21 // ░░░██░░░███████░░░░░░░░░▓██████▓░▓███████░░░░░░░░░███▒░▒█░░░░░░░░░░░░░░░░░░█████▓█▒░▓▓▓▓▓▓▓▒▓▓▓▓░░░░░░░░░░░░▒▓▓▓▓▓▓▓▓▒░░░░░░▓██▓▒▓░░░░░░░▒▓█████▒░░░░░
22 // ░░▓█▓░░▓██████▓░░░░░░░░▒███████░░████████████████████▓██▓░▓███████████████████████░░░░▓▓▓▓▓▓░░░░░░░░░░░░░▒▓▓▓▓▓▓▓▓▒░░░░░░▒▒▒▓▓▓▓▓▒░░░░░░░▓██████░░░░░░
23 // ░░██░░░▓░▒▓███░░░░░░░░░▓██████▓░▓███████░░░░░░░░░░░░░░░░░▒███████░░░░░░░░░███████▒░░░░█████▓░░░░░░░░░░▒▓▓▓▓▓▓▓▓▒░░░░░░░░░▒▒▒▒▒▒▒▒░░░░░▒▒░░████▓▒░░░░░░
24 // ░▓█▒░░▓█▒█████▒▒▒▒▒▒▒▒▓███████░░███████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░███████▓▒▒▒▒▒▒▒▒▓███████░░░████████▓▓▓░░░░▒▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒░░▓█████▓░░░▒▒▒░░▒████▒██▓░░░░
25 // ░██░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░░▓▓▓▓▓▓▓▓▓▓▓░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▓▓▓▓▓▓░░░░░░░▒▓█████▓█▓▓░░░░
26 // ░▒█▓▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▓▓█████████░░░░░░░░
27 // ░░▒█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▓░░░░░░░░░
28 // ░░░▒█████████████████████████████████████████████████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓█████████████████████████████████████████████████▓▒░░░░░░░░░░░
29 // ░░░░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░░░░░░░░░░░░░░░░
30 // ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
31 
32 // SPDX-License-Identifier: MIT
33 pragma solidity 0.8.7;  
34 library SafeMath {
35     /**
36      * @dev Returns the addition of two unsigned integers, with an overflow flag.
37      *
38      * _Available since v3.4._
39      */
40     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
41         unchecked {
42             uint256 c = a + b;
43             if (c < a) return (false, 0);
44             return (true, c);
45         }
46     }
47 
48     /**
49      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
50      *
51      * _Available since v3.4._
52      */
53     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
54         unchecked {
55             if (b > a) return (false, 0);
56             return (true, a - b);
57         }
58     }
59 
60     /**
61      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
62      *
63      * _Available since v3.4._
64      */
65     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
66         unchecked {
67             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
68             // benefit is lost if 'b' is also tested.
69             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
70             if (a == 0) return (true, 0);
71             uint256 c = a * b;
72             if (c / a != b) return (false, 0);
73             return (true, c);
74         }
75     }
76 
77     /**
78      * @dev Returns the division of two unsigned integers, with a division by zero flag.
79      *
80      * _Available since v3.4._
81      */
82     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
83         unchecked {
84             if (b == 0) return (false, 0);
85             return (true, a / b);
86         }
87     }
88 
89     /**
90      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
91      *
92      * _Available since v3.4._
93      */
94     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
95         unchecked {
96             if (b == 0) return (false, 0);
97             return (true, a % b);
98         }
99     }
100 
101     /**
102      * @dev Returns the addition of two unsigned integers, reverting on
103      * overflow.
104      *
105      * Counterpart to Solidity's `+` operator.
106      *
107      * Requirements:
108      *
109      * - Addition cannot overflow.
110      */
111     function add(uint256 a, uint256 b) internal pure returns (uint256) {
112         return a + b;
113     }
114 
115     /**
116      * @dev Returns the subtraction of two unsigned integers, reverting on
117      * overflow (when the result is negative).
118      *
119      * Counterpart to Solidity's `-` operator.
120      *
121      * Requirements:
122      *
123      * - Subtraction cannot overflow.
124      */
125     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
126         return a - b;
127     }
128 
129     /**
130      * @dev Returns the multiplication of two unsigned integers, reverting on
131      * overflow.
132      *
133      * Counterpart to Solidity's `*` operator.
134      *
135      * Requirements:
136      *
137      * - Multiplication cannot overflow.
138      */
139     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
140         return a * b;
141     }
142 
143     /**
144      * @dev Returns the integer division of two unsigned integers, reverting on
145      * division by zero. The result is rounded towards zero.
146      *
147      * Counterpart to Solidity's `/` operator.
148      *
149      * Requirements:
150      *
151      * - The divisor cannot be zero.
152      */
153     function div(uint256 a, uint256 b) internal pure returns (uint256) {
154         return a / b;
155     }
156 
157     /**
158      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
159      * reverting when dividing by zero.
160      *
161      * Counterpart to Solidity's `%` operator. This function uses a `revert`
162      * opcode (which leaves remaining gas untouched) while Solidity uses an
163      * invalid opcode to revert (consuming all remaining gas).
164      *
165      * Requirements:
166      *
167      * - The divisor cannot be zero.
168      */
169     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
170         return a % b;
171     }
172 
173     /**
174      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
175      * overflow (when the result is negative).
176      *
177      * CAUTION: This function is deprecated because it requires allocating memory for the error
178      * message unnecessarily. For custom revert reasons use {trySub}.
179      *
180      * Counterpart to Solidity's `-` operator.
181      *
182      * Requirements:
183      *
184      * - Subtraction cannot overflow.
185      */
186     function sub(
187         uint256 a,
188         uint256 b,
189         string memory errorMessage
190     ) internal pure returns (uint256) {
191         unchecked {
192             require(b <= a, errorMessage);
193             return a - b;
194         }
195     }
196 
197     /**
198      * @dev Returns the integer division of two unsigned integers, reverting with custom message on
199      * division by zero. The result is rounded towards zero.
200      *
201      * Counterpart to Solidity's `/` operator. Note: this function uses a
202      * `revert` opcode (which leaves remaining gas untouched) while Solidity
203      * uses an invalid opcode to revert (consuming all remaining gas).
204      *
205      * Requirements:
206      *
207      * - The divisor cannot be zero.
208      */
209     function div(
210         uint256 a,
211         uint256 b,
212         string memory errorMessage
213     ) internal pure returns (uint256) {
214         unchecked {
215             require(b > 0, errorMessage);
216             return a / b;
217         }
218     }
219 
220     /**
221      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
222      * reverting with custom message when dividing by zero.
223      *
224      * CAUTION: This function is deprecated because it requires allocating memory for the error
225      * message unnecessarily. For custom revert reasons use {tryMod}.
226      *
227      * Counterpart to Solidity's `%` operator. This function uses a `revert`
228      * opcode (which leaves remaining gas untouched) while Solidity uses an
229      * invalid opcode to revert (consuming all remaining gas).
230      *
231      * Requirements:
232      *
233      * - The divisor cannot be zero.
234      */
235     function mod(
236         uint256 a,
237         uint256 b,
238         string memory errorMessage
239     ) internal pure returns (uint256) {
240         unchecked {
241             require(b > 0, errorMessage);
242             return a % b;
243         }
244     }
245 }
246 interface IOperatorFilterRegistry {
247     function isOperatorAllowed(address registrant, address operator) external view returns (bool);
248     function register(address registrant) external;
249     function registerAndSubscribe(address registrant, address subscription) external;
250     function registerAndCopyEntries(address registrant, address registrantToCopy) external;
251     function unregister(address addr) external;
252     function updateOperator(address registrant, address operator, bool filtered) external;
253     function updateOperators(address registrant, address[] calldata operators, bool filtered) external;
254     function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;
255     function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;
256     function subscribe(address registrant, address registrantToSubscribe) external;
257     function unsubscribe(address registrant, bool copyExistingEntries) external;
258     function subscriptionOf(address addr) external returns (address registrant);
259     function subscribers(address registrant) external returns (address[] memory);
260     function subscriberAt(address registrant, uint256 index) external returns (address);
261     function copyEntriesOf(address registrant, address registrantToCopy) external;
262     function isOperatorFiltered(address registrant, address operator) external returns (bool);
263     function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);
264     function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);
265     function filteredOperators(address addr) external returns (address[] memory);
266     function filteredCodeHashes(address addr) external returns (bytes32[] memory);
267     function filteredOperatorAt(address registrant, uint256 index) external returns (address);
268     function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);
269     function isRegistered(address addr) external returns (bool);
270     function codeHashOf(address addr) external returns (bytes32);
271 }
272 abstract contract OperatorFilterer {
273     error OperatorNotAllowed(address operator);
274 
275     IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =
276         IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);
277 
278     constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {
279         // If an inheriting token contract is deployed to a network without the registry deployed, the modifier
280         // will not revert, but the contract will need to be registered with the registry once it is deployed in
281         // order for the modifier to filter addresses.
282         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
283             if (subscribe) {
284                 OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);
285             } else {
286                 if (subscriptionOrRegistrantToCopy != address(0)) {
287                     OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);
288                 } else {
289                     OPERATOR_FILTER_REGISTRY.register(address(this));
290                 }
291             }
292         }
293     }
294 
295     modifier onlyAllowedOperator(address from) virtual {
296         // Allow spending tokens from addresses with balance
297         // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred
298         // from an EOA.
299         if (from != msg.sender) {
300             _checkFilterOperator(msg.sender);
301         }
302         _;
303     }
304 
305     modifier onlyAllowedOperatorApproval(address operator) virtual {
306         _checkFilterOperator(operator);
307         _;
308     }
309     
310     function _checkFilterOperator(address operator) internal view virtual {
311         // Check registry code length to facilitate testing in environments without a deployed registry.
312         if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {
313             if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {
314                 revert OperatorNotAllowed(operator);
315             }
316         }
317     }
318 }
319 abstract contract DefaultOperatorFilterer is OperatorFilterer {
320     address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);
321 
322     constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}
323 } 
324 library MerkleProof {
325     function verify(
326         bytes32[] memory proof,
327         bytes32 root,
328         bytes32 leaf
329     ) internal pure returns (bool) {
330         return processProof(proof, leaf) == root;
331     }
332    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
333         bytes32 computedHash = leaf;
334         for (uint256 i = 0; i < proof.length; i++) {
335             bytes32 proofElement = proof[i];
336             if (computedHash <= proofElement) {
337                 computedHash = _efficientHash(computedHash, proofElement);
338             } else {
339                 computedHash = _efficientHash(proofElement, computedHash);
340             }
341         }
342         return computedHash;
343     }
344 
345     function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
346         assembly {
347             mstore(0x00, a)
348             mstore(0x20, b)
349             value := keccak256(0x00, 0x40)
350         }
351     }
352 }
353 abstract contract ReentrancyGuard { 
354     uint256 private constant _NOT_ENTERED = 1;
355     uint256 private constant _ENTERED = 2;
356 
357     uint256 private _status;
358 
359     constructor() {
360         _status = _NOT_ENTERED;
361     }
362     modifier nonReentrant() {
363         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
364    _status = _ENTERED;
365 
366         _;
367         _status = _NOT_ENTERED;
368     }
369 }
370 
371 library Strings {
372     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
373  
374     function toString(uint256 value) internal pure returns (string memory) { 
375         if (value == 0) {
376             return "0";
377         }
378         uint256 temp = value;
379         uint256 digits;
380         while (temp != 0) {
381             digits++;
382             temp /= 10;
383         }
384         bytes memory buffer = new bytes(digits);
385         while (value != 0) {
386             digits -= 1;
387             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
388             value /= 10;
389         }
390         return string(buffer);
391     }
392  
393     function toHexString(uint256 value) internal pure returns (string memory) {
394         if (value == 0) {
395             return "0x00";
396         }
397         uint256 temp = value;
398         uint256 length = 0;
399         while (temp != 0) {
400             length++;
401             temp >>= 8;
402         }
403         return toHexString(value, length);
404     }
405  
406     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
407         bytes memory buffer = new bytes(2 * length + 2);
408         buffer[0] = "0";
409         buffer[1] = "x";
410         for (uint256 i = 2 * length + 1; i > 1; --i) {
411             buffer[i] = _HEX_SYMBOLS[value & 0xf];
412             value >>= 4;
413         }
414         require(value == 0, "Strings: hex length insufficient");
415         return string(buffer);
416     }
417 }
418  
419 abstract contract Context {
420     function _msgSender() internal view virtual returns (address) {
421         return msg.sender;
422     }
423 
424     function _msgData() internal view virtual returns (bytes calldata) {
425         return msg.data;
426     }
427 }
428  
429 abstract contract Ownable is Context {
430     address private _owner;
431 
432     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
433  
434     constructor() {
435         _transferOwnership(_msgSender());
436     }
437  
438     function owner() public view virtual returns (address) {
439         return _owner;
440     } 
441     modifier onlyOwner() {
442         require(owner() == _msgSender(), "Ownable: caller is not the owner");
443         _;
444     }
445  
446     function renounceOwnership() public virtual onlyOwner {
447         _transferOwnership(address(0));
448     }
449  
450     function transferOwnership(address newOwner) public virtual onlyOwner {
451         require(newOwner != address(0), "Ownable: new owner is the zero address");
452         _transferOwnership(newOwner);
453     }
454  
455     function _transferOwnership(address newOwner) internal virtual {
456         address oldOwner = _owner;
457         _owner = newOwner;
458         emit OwnershipTransferred(oldOwner, newOwner);
459     }
460 }
461  
462 library Address { 
463     function isContract(address account) internal view returns (bool) { 
464         uint256 size;
465         assembly {
466             size := extcodesize(account)
467         }
468         return size > 0;
469     } 
470     function sendValue(address payable recipient, uint256 amount) internal {
471         require(address(this).balance >= amount, "Address: insufficient balance");
472 
473         (bool success, ) = recipient.call{value: amount}("");
474         require(success, "Address: unable to send value, recipient may have reverted");
475     }
476  
477     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
478         return functionCall(target, data, "Address: low-level call failed");
479     } 
480     function functionCall(
481         address target,
482         bytes memory data,
483         string memory errorMessage
484     ) internal returns (bytes memory) {
485         return functionCallWithValue(target, data, 0, errorMessage);
486     }
487  
488     function functionCallWithValue(
489         address target,
490         bytes memory data,
491         uint256 value
492     ) internal returns (bytes memory) {
493         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
494     }
495  
496     function functionCallWithValue(
497         address target,
498         bytes memory data,
499         uint256 value,
500         string memory errorMessage
501     ) internal returns (bytes memory) {
502         require(address(this).balance >= value, "Address: insufficient balance for call");
503         require(isContract(target), "Address: call to non-contract");
504 
505         (bool success, bytes memory returndata) = target.call{value: value}(data);
506         return verifyCallResult(success, returndata, errorMessage);
507     } 
508     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
509         return functionStaticCall(target, data, "Address: low-level static call failed");
510     }
511  
512     function functionStaticCall(
513         address target,
514         bytes memory data,
515         string memory errorMessage
516     ) internal view returns (bytes memory) {
517         require(isContract(target), "Address: static call to non-contract");
518 
519         (bool success, bytes memory returndata) = target.staticcall(data);
520         return verifyCallResult(success, returndata, errorMessage);
521     }
522  
523     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
524         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
525     }
526  
527     function functionDelegateCall(
528         address target,
529         bytes memory data,
530         string memory errorMessage
531     ) internal returns (bytes memory) {
532         require(isContract(target), "Address: delegate call to non-contract");
533 
534         (bool success, bytes memory returndata) = target.delegatecall(data);
535         return verifyCallResult(success, returndata, errorMessage);
536     }
537  
538     function verifyCallResult(
539         bool success,
540         bytes memory returndata,
541         string memory errorMessage
542     ) internal pure returns (bytes memory) {
543         if (success) {
544             return returndata;
545         } else { 
546             if (returndata.length > 0) { 
547 
548                 assembly {
549                     let returndata_size := mload(returndata)
550                     revert(add(32, returndata), returndata_size)
551                 }
552             } else {
553                 revert(errorMessage);
554             }
555         }
556     }
557 }
558  
559 interface IERC721Receiver { 
560     function onERC721Received(
561         address operator,
562         address from,
563         uint256 tokenId,
564         bytes calldata data
565     ) external returns (bytes4);
566 }
567  
568 interface IERC165 { 
569     function supportsInterface(bytes4 interfaceId) external view returns (bool);
570 }
571  
572 abstract contract ERC165 is IERC165 { 
573     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
574         return interfaceId == type(IERC165).interfaceId;
575     }
576 } 
577 interface IERC721 is IERC165 { 
578     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); 
579     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); 
580     event ApprovalForAll(address indexed owner, address indexed operator, bool approved); 
581     function balanceOf(address owner) external view returns (uint256 balance); 
582     function ownerOf(uint256 tokenId) external view returns (address owner); 
583     function safeTransferFrom(
584         address from,
585         address to,
586         uint256 tokenId
587     ) external; 
588     function transferFrom(
589         address from,
590         address to,
591         uint256 tokenId
592     ) external; 
593     function approve(address to, uint256 tokenId) external;
594  
595     function getApproved(uint256 tokenId) external view returns (address operator); 
596     function setApprovalForAll(address operator, bool _approved) external; 
597     function isApprovedForAll(address owner, address operator) external view returns (bool); 
598     function safeTransferFrom(
599         address from,
600         address to,
601         uint256 tokenId,
602         bytes calldata data
603     ) external;
604 }
605 interface IERC721Metadata is IERC721 { 
606     function name() external view returns (string memory); 
607     function symbol() external view returns (string memory); 
608     function tokenURI(uint256 tokenId) external view returns (string memory);
609 } 
610 interface IERC721Enumerable is IERC721 { 
611     function totalSupply() external view returns (uint256); 
612     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId); 
613     function tokenByIndex(uint256 index) external view returns (uint256);
614 } 
615 error ApprovalCallerNotOwnerNorApproved();
616 error ApprovalQueryForNonexistentToken();
617 error ApproveToCaller();
618 error ApprovalToCurrentOwner();
619 error BalanceQueryForZeroAddress();
620 error MintToZeroAddress();
621 error MintZeroQuantity();
622 error OwnerQueryForNonexistentToken();
623 error TransferCallerNotOwnerNorApproved();
624 error TransferFromIncorrectOwner();
625 error TransferToNonERC721ReceiverImplementer();
626 error TransferToZeroAddress();
627 error URIQueryForNonexistentToken();
628 
629 /**
630  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
631  * the Metadata extension. Built to optimize for lower gas during batch mints.
632  *
633  * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
634  *
635  * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
636  *
637  * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
638  */
639 contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable, Ownable {
640     using Address for address;
641     using Strings for uint256;
642 
643     // Compiler will pack this into a single 256bit word.
644     struct TokenOwnership {
645         // The address of the owner.
646         address addr;
647         // Keeps track of the start time of ownership with minimal overhead for tokenomics.
648         uint64 startTimestamp;
649         // Whether the token has been burned.
650         bool burned;
651     }
652 
653     // Compiler will pack this into a single 256bit word.
654     struct AddressData {
655         // Realistically, 2**64-1 is more than enough.
656         uint64 balance;
657         // Keeps track of mint count with minimal overhead for tokenomics.
658         uint64 numberMinted;
659         // Keeps track of burn count with minimal overhead for tokenomics.
660         uint64 numberBurned;
661         // For miscellaneous variable(s) pertaining to the address
662         // (e.g. number of whitelist mint slots used).
663         // If there are multiple variables, please pack them into a uint64.
664         uint64 aux;
665     }
666 
667     // The tokenId of the next token to be minted.
668     uint256 internal _currentIndex;
669 
670     // The number of tokens burned.
671     uint256 internal _burnCounter;
672 
673     // Token name
674     string private _name;
675 
676     // Token symbol
677     string private _symbol;
678 
679     // Mapping from token ID to ownership details
680     // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.
681     mapping(uint256 => TokenOwnership) internal _ownerships;
682 
683     // Mapping owner address to address data
684     mapping(address => AddressData) private _addressData;
685 
686     // Mapping from token ID to approved address
687     mapping(uint256 => address) private _tokenApprovals;
688 
689     // Mapping from owner to operator approvals
690     mapping(address => mapping(address => bool)) private _operatorApprovals;
691 
692     constructor(string memory name_, string memory symbol_) {
693         _name = name_;
694         _symbol = symbol_;
695         _currentIndex = _startTokenId();
696     }
697 
698     /**
699      * To change the starting tokenId, please override this function.
700      */
701     function _startTokenId() internal view virtual returns (uint256) {
702         return 0;
703     }
704 
705     /**
706      * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.
707      */
708     function totalSupply() public view override returns (uint256) {
709         return _currentIndex;
710     } 
711     function tokenByIndex(uint256 index) public view override returns (uint256) {
712         require(index < totalSupply(), "ERC721A: global index out of bounds");
713         return index;
714     } 
715     function tokenOfOwnerByIndex(address owner, uint256 index)
716         public
717         view
718         override
719         returns (uint256)
720     {
721         require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
722         uint256 numMintedSoFar = totalSupply();
723         uint256 tokenIdsIdx = 0;
724         address currOwnershipAddr = address(0);
725         for (uint256 i = 0; i < numMintedSoFar; i++) {
726         TokenOwnership memory ownership = _ownerships[i];
727         if (ownership.addr != address(0)) {
728             currOwnershipAddr = ownership.addr;
729         }
730         if (currOwnershipAddr == owner) {
731             if (tokenIdsIdx == index) {
732             return i;
733             }
734             tokenIdsIdx++;
735         }
736         }
737         revert("ERC721A: unable to get token of owner by index");
738     } 
739 
740     /**
741      * Returns the total amount of tokens minted in the contract.
742      */
743     function _totalMinted() internal view returns (uint256) {
744         // Counter underflow is impossible as _currentIndex does not decrement,
745         // and it is initialized to _startTokenId()
746         unchecked {
747             return _currentIndex - _startTokenId();
748         }
749     }
750 
751     /**
752      * @dev See {IERC165-supportsInterface}.
753      */
754     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
755         return
756             interfaceId == type(IERC721).interfaceId ||
757             interfaceId == type(IERC721Metadata).interfaceId ||
758             super.supportsInterface(interfaceId);
759     }
760 
761     /**
762      * @dev See {IERC721-balanceOf}.
763      */
764     function balanceOf(address owner) public view override returns (uint256) {
765         if (owner == address(0)) revert BalanceQueryForZeroAddress();
766         return uint256(_addressData[owner].balance);
767     }
768 
769     /**
770      * Returns the number of tokens minted by `owner`.
771      */
772     function _numberMinted(address owner) internal view returns (uint256) {
773         return uint256(_addressData[owner].numberMinted);
774     }
775 
776     /**
777      * Returns the number of tokens burned by or on behalf of `owner`.
778      */
779     function _numberBurned(address owner) internal view returns (uint256) {
780         return uint256(_addressData[owner].numberBurned);
781     }
782 
783     /**
784      * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
785      */
786     function _getAux(address owner) internal view returns (uint64) {
787         return _addressData[owner].aux;
788     }
789 
790     /**
791      * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).
792      * If there are multiple variables, please pack them into a uint64.
793      */
794     function _setAux(address owner, uint64 aux) internal {
795         _addressData[owner].aux = aux;
796     }
797 
798     /**
799      * Gas spent here starts off proportional to the maximum mint batch size.
800      * It gradually moves to O(1) as tokens get transferred around in the collection over time.
801      */
802     function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
803         uint256 curr = tokenId;
804 
805         unchecked {
806             if (_startTokenId() <= curr && curr < _currentIndex) {
807                 TokenOwnership memory ownership = _ownerships[curr];
808                 if (!ownership.burned) {
809                     if (ownership.addr != address(0)) {
810                         return ownership;
811                     }
812                     // Invariant:
813                     // There will always be an ownership that has an address and is not burned
814                     // before an ownership that does not have an address and is not burned.
815                     // Hence, curr will not underflow.
816                     while (true) {
817                         curr--;
818                         ownership = _ownerships[curr];
819                         if (ownership.addr != address(0)) {
820                             return ownership;
821                         }
822                     }
823                 }
824             }
825         }
826         revert OwnerQueryForNonexistentToken();
827     }
828 
829     /**
830      * @dev See {IERC721-ownerOf}.
831      */
832     function ownerOf(uint256 tokenId) public view override returns (address) {
833         return _ownershipOf(tokenId).addr;
834     }
835 
836     /**
837      * @dev See {IERC721Metadata-name}.
838      */
839     function name() public view virtual override returns (string memory) {
840         return _name;
841     }
842 
843     /**
844      * @dev See {IERC721Metadata-symbol}.
845      */
846     function symbol() public view virtual override returns (string memory) {
847         return _symbol;
848     }
849 
850     /**
851      * @dev See {IERC721Metadata-tokenURI}.
852      */
853     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
854         if (!_exists(tokenId)) revert URIQueryForNonexistentToken();
855 
856         string memory baseURI = _baseURI();
857         return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';
858     }
859 
860     /**
861      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
862      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
863      * by default, can be overriden in child contracts.
864      */
865     function _baseURI() internal view virtual returns (string memory) {
866         return '';
867     }
868 
869     /**
870      * @dev See {IERC721-approve}.
871      */
872     function approve(address to, uint256 tokenId) public virtual override {
873         address owner = ERC721A.ownerOf(tokenId);
874         if (to == owner) revert ApprovalToCurrentOwner();
875 
876         if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {
877             revert ApprovalCallerNotOwnerNorApproved();
878         }
879 
880         _approve(to, tokenId, owner);
881     }
882 
883     /**
884      * @dev See {IERC721-getApproved}.
885      */
886     function getApproved(uint256 tokenId) public view override returns (address) {
887         if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();
888 
889         return _tokenApprovals[tokenId];
890     }
891 
892     /**
893      * @dev See {IERC721-setApprovalForAll}.
894      */
895     function setApprovalForAll(address operator, bool approved) public virtual override {
896         if (operator == _msgSender()) revert ApproveToCaller();
897 
898         _operatorApprovals[_msgSender()][operator] = approved;
899         emit ApprovalForAll(_msgSender(), operator, approved);
900     }
901 
902     /**
903      * @dev See {IERC721-isApprovedForAll}.
904      */
905     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
906         return _operatorApprovals[owner][operator];
907     }
908 
909     /**
910      * @dev See {IERC721-transferFrom}.
911      */
912     function transferFrom(
913         address from,
914         address to,
915         uint256 tokenId
916     ) public virtual override {
917         _transfer(from, to, tokenId);
918     }
919 
920     /**
921      * @dev See {IERC721-safeTransferFrom}.
922      */
923     function safeTransferFrom(
924         address from,
925         address to,
926         uint256 tokenId
927     ) public virtual override {
928         safeTransferFrom(from, to, tokenId, '');
929     }
930 
931     /**
932      * @dev See {IERC721-safeTransferFrom}.
933      */
934     function safeTransferFrom(
935         address from,
936         address to,
937         uint256 tokenId,
938         bytes memory _data
939     ) public virtual override {
940         _transfer(from, to, tokenId);
941         if (to.isContract() && !_checkContractOnERC721Received(from, to, tokenId, _data)) {
942             revert TransferToNonERC721ReceiverImplementer();
943         }
944     }
945 
946     /**
947      * @dev Returns whether `tokenId` exists.
948      *
949      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
950      *
951      * Tokens start existing when they are minted (`_mint`),
952      */
953     function _exists(uint256 tokenId) internal view returns (bool) {
954         return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;
955     }
956 
957     function _safeMint(address to, uint256 quantity) internal {
958         _safeMint(to, quantity, '');
959     }
960 
961     /**
962      * @dev Safely mints `quantity` tokens and transfers them to `to`.
963      *
964      * Requirements:
965      *
966      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
967      * - `quantity` must be greater than 0.
968      *
969      * Emits a {Transfer} event.
970      */
971     function _safeMint(
972         address to,
973         uint256 quantity,
974         bytes memory _data
975     ) internal {
976         _mint(to, quantity, _data, true);
977     }
978 
979     /**
980      * @dev Mints `quantity` tokens and transfers them to `to`.
981      *
982      * Requirements:
983      *
984      * - `to` cannot be the zero address.
985      * - `quantity` must be greater than 0.
986      *
987      * Emits a {Transfer} event.
988      */
989     function _mint(
990         address to,
991         uint256 quantity,
992         bytes memory _data,
993         bool safe
994     ) internal {
995         uint256 startTokenId = _currentIndex;
996         if (to == address(0)) revert MintToZeroAddress();
997         if (quantity == 0) revert MintZeroQuantity();
998 
999         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
1000 
1001         // Overflows are incredibly unrealistic.
1002         // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1
1003         // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1
1004         unchecked {
1005             _addressData[to].balance += uint64(quantity);
1006             _addressData[to].numberMinted += uint64(quantity);
1007 
1008             _ownerships[startTokenId].addr = to;
1009             _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);
1010 
1011             uint256 updatedIndex = startTokenId;
1012             uint256 end = updatedIndex + quantity;
1013 
1014             if (safe && to.isContract()) {
1015                 do {
1016                     emit Transfer(address(0), to, updatedIndex);
1017                     if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {
1018                         revert TransferToNonERC721ReceiverImplementer();
1019                     }
1020                 } while (updatedIndex != end);
1021                 // Reentrancy protection
1022                 if (_currentIndex != startTokenId) revert();
1023             } else {
1024                 do {
1025                     emit Transfer(address(0), to, updatedIndex++);
1026                 } while (updatedIndex != end);
1027             }
1028             _currentIndex = updatedIndex;
1029         }
1030         _afterTokenTransfers(address(0), to, startTokenId, quantity);
1031     }
1032 
1033     /**
1034      * @dev Transfers `tokenId` from `from` to `to`.
1035      *
1036      * Requirements:
1037      *
1038      * - `to` cannot be the zero address.
1039      * - `tokenId` token must be owned by `from`.
1040      *
1041      * Emits a {Transfer} event.
1042      */
1043     function _transfer(
1044         address from,
1045         address to,
1046         uint256 tokenId
1047     ) private {
1048         TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
1049 
1050         if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();
1051 
1052         bool isApprovedOrOwner = (_msgSender() == from ||
1053             isApprovedForAll(from, _msgSender()) ||
1054             getApproved(tokenId) == _msgSender());
1055 
1056         if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
1057         if (to == address(0)) revert TransferToZeroAddress();
1058 
1059         _beforeTokenTransfers(from, to, tokenId, 1);
1060 
1061         // Clear approvals from the previous owner
1062         _approve(address(0), tokenId, from);
1063 
1064         // Underflow of the sender's balance is impossible because we check for
1065         // ownership above and the recipient's balance can't realistically overflow.
1066         // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
1067         unchecked {
1068             _addressData[from].balance -= 1;
1069             _addressData[to].balance += 1;
1070 
1071             TokenOwnership storage currSlot = _ownerships[tokenId];
1072             currSlot.addr = to;
1073             currSlot.startTimestamp = uint64(block.timestamp);
1074 
1075             // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
1076             // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1077             uint256 nextTokenId = tokenId + 1;
1078             TokenOwnership storage nextSlot = _ownerships[nextTokenId];
1079             if (nextSlot.addr == address(0)) {
1080                 // This will suffice for checking _exists(nextTokenId),
1081                 // as a burned slot cannot contain the zero address.
1082                 if (nextTokenId != _currentIndex) {
1083                     nextSlot.addr = from;
1084                     nextSlot.startTimestamp = prevOwnership.startTimestamp;
1085                 }
1086             }
1087         }
1088 
1089         emit Transfer(from, to, tokenId);
1090         _afterTokenTransfers(from, to, tokenId, 1);
1091     }
1092 
1093     /**
1094      * @dev This is equivalent to _burn(tokenId, false)
1095      */
1096     function _burn(uint256 tokenId) internal virtual {
1097         _burn(tokenId, false);
1098     }
1099 
1100     /**
1101      * @dev Destroys `tokenId`.
1102      * The approval is cleared when the token is burned.
1103      *
1104      * Requirements:
1105      *
1106      * - `tokenId` must exist.
1107      *
1108      * Emits a {Transfer} event.
1109      */
1110     function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
1111         TokenOwnership memory prevOwnership = _ownershipOf(tokenId);
1112 
1113         address from = prevOwnership.addr;
1114 
1115         if (approvalCheck) {
1116             bool isApprovedOrOwner = (_msgSender() == from ||
1117                 isApprovedForAll(from, _msgSender()) ||
1118                 getApproved(tokenId) == _msgSender());
1119 
1120             if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
1121         }
1122 
1123         _beforeTokenTransfers(from, address(0), tokenId, 1);
1124 
1125         // Clear approvals from the previous owner
1126         _approve(address(0), tokenId, from);
1127 
1128         // Underflow of the sender's balance is impossible because we check for
1129         // ownership above and the recipient's balance can't realistically overflow.
1130         // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
1131         unchecked {
1132             AddressData storage addressData = _addressData[from];
1133             addressData.balance -= 1;
1134             addressData.numberBurned += 1;
1135 
1136             // Keep track of who burned the token, and the timestamp of burning.
1137             TokenOwnership storage currSlot = _ownerships[tokenId];
1138             currSlot.addr = from;
1139             currSlot.startTimestamp = uint64(block.timestamp);
1140             currSlot.burned = true;
1141 
1142             // If the ownership slot of tokenId+1 is not explicitly set, that means the burn initiator owns it.
1143             // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1144             uint256 nextTokenId = tokenId + 1;
1145             TokenOwnership storage nextSlot = _ownerships[nextTokenId];
1146             if (nextSlot.addr == address(0)) {
1147                 // This will suffice for checking _exists(nextTokenId),
1148                 // as a burned slot cannot contain the zero address.
1149                 if (nextTokenId != _currentIndex) {
1150                     nextSlot.addr = from;
1151                     nextSlot.startTimestamp = prevOwnership.startTimestamp;
1152                 }
1153             }
1154         }
1155 
1156         emit Transfer(from, address(0), tokenId);
1157         _afterTokenTransfers(from, address(0), tokenId, 1);
1158 
1159         // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.
1160         unchecked {
1161             _burnCounter++;
1162         }
1163     }
1164 
1165     /**
1166      * @dev Approve `to` to operate on `tokenId`
1167      *
1168      * Emits a {Approval} event.
1169      */
1170     function _approve(
1171         address to,
1172         uint256 tokenId,
1173         address owner
1174     ) private {
1175         _tokenApprovals[tokenId] = to;
1176         emit Approval(owner, to, tokenId);
1177     }
1178 
1179     /**
1180      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.
1181      *
1182      * @param from address representing the previous owner of the given token ID
1183      * @param to target address that will receive the tokens
1184      * @param tokenId uint256 ID of the token to be transferred
1185      * @param _data bytes optional data to send along with the call
1186      * @return bool whether the call correctly returned the expected magic value
1187      */
1188     function _checkContractOnERC721Received(
1189         address from,
1190         address to,
1191         uint256 tokenId,
1192         bytes memory _data
1193     ) private returns (bool) {
1194         try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1195             return retval == IERC721Receiver(to).onERC721Received.selector;
1196         } catch (bytes memory reason) {
1197             if (reason.length == 0) {
1198                 revert TransferToNonERC721ReceiverImplementer();
1199             } else {
1200                 assembly {
1201                     revert(add(32, reason), mload(reason))
1202                 }
1203             }
1204         }
1205     }
1206 
1207     /**
1208      * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
1209      * And also called before burning one token.
1210      *
1211      * startTokenId - the first token id to be transferred
1212      * quantity - the amount to be transferred
1213      *
1214      * Calling conditions:
1215      *
1216      * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
1217      * transferred to `to`.
1218      * - When `from` is zero, `tokenId` will be minted for `to`.
1219      * - When `to` is zero, `tokenId` will be burned by `from`.
1220      * - `from` and `to` are never both zero.
1221      */
1222     function _beforeTokenTransfers(
1223         address from,
1224         address to,
1225         uint256 startTokenId,
1226         uint256 quantity
1227     ) internal virtual {}
1228 
1229     /**
1230      * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
1231      * minting.
1232      * And also called after one token has been burned.
1233      *
1234      * startTokenId - the first token id to be transferred
1235      * quantity - the amount to be transferred
1236      *
1237      * Calling conditions:
1238      *
1239      * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
1240      * transferred to `to`.
1241      * - When `from` is zero, `tokenId` has been minted for `to`.
1242      * - When `to` is zero, `tokenId` has been burned by `from`.
1243      * - `from` and `to` are never both zero.
1244      */
1245     function _afterTokenTransfers(
1246         address from,
1247         address to,
1248         uint256 startTokenId,
1249         uint256 quantity
1250     ) internal virtual {}
1251 }
1252 
1253 interface IERC20 {
1254     /**
1255      * @dev Returns the amount of tokens in existence.
1256      */
1257     function totalSupply() external view returns (uint256);
1258 
1259     /**
1260      * @dev Returns the amount of tokens owned by `account`.
1261      */
1262     function balanceOf(address account) external view returns (uint256);
1263 
1264     /**
1265      * @dev Moves `amount` tokens from the caller's account to `to`.
1266      *
1267      * Returns a boolean value indicating whether the operation succeeded.
1268      *
1269      * Emits a {Transfer} event.
1270      */
1271     function transfer(address to, uint256 amount) external returns (bool);
1272 
1273     /**
1274      * @dev Returns the remaining number of tokens that `spender` will be
1275      * allowed to spend on behalf of `owner` through {transferFrom}. This is
1276      * zero by default.
1277      *
1278      * This value changes when {approve} or {transferFrom} are called.
1279      */
1280     function allowance(address owner, address spender) external view returns (uint256);
1281 
1282     /**
1283      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
1284      *
1285      * Returns a boolean value indicating whether the operation succeeded.
1286      *
1287      * IMPORTANT: Beware that changing an allowance with this method brings the risk
1288      * that someone may use both the old and the new allowance by unfortunate
1289      * transaction ordering. One possible solution to mitigate this race
1290      * condition is to first reduce the spender's allowance to 0 and set the
1291      * desired value afterwards:
1292      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
1293      *
1294      * Emits an {Approval} event.
1295      */
1296     function approve(address spender, uint256 amount) external returns (bool);
1297 
1298     /**
1299      * @dev Moves `amount` tokens from `from` to `to` using the
1300      * allowance mechanism. `amount` is then deducted from the caller's
1301      * allowance.
1302      *
1303      * Returns a boolean value indicating whether the operation succeeded.
1304      *
1305      * Emits a {Transfer} event.
1306      */
1307     function transferFrom(
1308         address from,
1309         address to,
1310         uint256 amount
1311     ) external returns (bool);
1312 
1313     /**
1314      * @dev Emitted when `value` tokens are moved from one account (`from`) to
1315      * another (`to`).
1316      *
1317      * Note that `value` may be zero.
1318      */
1319     event Transfer(address indexed from, address indexed to, uint256 value);
1320 
1321     /**
1322      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
1323      * a call to {approve}. `value` is the new allowance.
1324      */
1325     event Approval(address indexed owner, address indexed spender, uint256 value);
1326 }
1327 
1328 contract DreamBeatzGenesis is Ownable, ERC721A, ReentrancyGuard, DefaultOperatorFilterer  {
1329     using Strings for uint256;
1330     using SafeMath for uint256;
1331     uint256 public collectionSize = 5555;
1332     mapping(uint => uint) public level;
1333 
1334     string public uri = "https://bafkreic6isl34cafxhs64xy2owxujb5acnfmyt6uctdl7oaqwaj67qknqe.ipfs.nftstorage.link";
1335     function setURI(string memory u) public onlyOwner{
1336         uri = u;
1337     }
1338     
1339     address public beatzAddress;
1340     function setBeatzAddress(address a) public onlyOwner{
1341         beatzAddress = a;
1342     }
1343     
1344     address public beatz_vault;
1345     function setBeatzVault(address a) public onlyOwner{
1346         beatz_vault = a;
1347     }
1348 
1349     mapping(string => uint) public swapPrice;
1350     function set_swapPrice(string memory category, uint price_) public onlyOwner {
1351         swapPrice[category] = price_;
1352     }
1353 
1354     bool public reveal = false;
1355     function setReveal(bool set) public onlyOwner{
1356         reveal = set;
1357     }
1358 
1359     uint public status = 0; //0-stop 2-WL 3-PUBLIC
1360     function switch_status(uint Status) public onlyOwner {
1361         status = Status;
1362     }
1363 
1364     bool public status_trait_swap = false;
1365     function switch_status_trait_swap(bool Status) public onlyOwner {
1366         status_trait_swap = Status;
1367     }
1368     
1369     uint public mint_perAdd = 3;
1370     function set_mint_perAdd(uint new_) public onlyOwner {
1371         mint_perAdd = new_;
1372     }
1373     
1374     uint public price = 0.025 ether;
1375     function set_price(uint price_) public onlyOwner {
1376         price = price_;
1377     }
1378 
1379     bytes32 public merkleRoot_WL = 0x3e0e42f01476115c127a82967a00f112df4953c2cea3b4dc6b2421ac9251aa6a;
1380     function setMerkleRoot_WL(bytes32 m) public onlyOwner{
1381         merkleRoot_WL = m;
1382     }
1383     
1384     uint256 public reserve = 55;
1385     function setReserve(uint256 number) public onlyOwner {
1386         reserve = number;
1387     }
1388 
1389     ///////////////////////////////////////////////////////////////////////////
1390 
1391     constructor() ERC721A("DreamBeatz! Genesis", "DRMBTZ") {
1392         swapPrice["Background"] = 150 ether;
1393         swapPrice["Accessory 1"] = 200 ether;
1394         swapPrice["Accessory 2"] = 200 ether;
1395         swapPrice["Accessory 3"] = 200 ether;
1396         swapPrice["Accessory 4"] = 200 ether;
1397         swapPrice["Accessory 5"] = 200 ether;
1398         swapPrice["Body Trait"] = 200 ether;
1399         swapPrice["Clothes"] = 500 ether;
1400         swapPrice["Eyes"] = 300 ether;
1401         swapPrice["Hairstyle"] = 400 ether;
1402         swapPrice["Instrument Design"] = 500 ether;
1403         swapPrice["Mouth"] = 300 ether;
1404     }
1405 
1406     function giveaway(address recipient, uint256 quantity) public onlyOwner {
1407         require(totalSupply() + quantity <= collectionSize, "Giveaway exceeds current batch!!!");
1408         require(quantity <= reserve, "No more reserved remaining!!");
1409 
1410         _safeMint(recipient, quantity);
1411         reserve -= quantity;
1412     }
1413 
1414     function mint_list(uint256 quantity, bytes32[] calldata merkleproof) public payable {
1415         bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
1416 
1417         if(status == 2)
1418         require(MerkleProof.verify( merkleproof, merkleRoot_WL, leaf),"Not whitelisted");
1419 
1420         require(numberMinted(msg.sender).add(quantity) <= mint_perAdd && quantity > 0, "Invalid mint quantity!!");
1421         require(msg.value >= quantity.mul(price), "Insufficient eth sent for mint!!");
1422         require(totalSupply().add(quantity) + reserve <= collectionSize, "Mint exceeds Collection size!!");        
1423 
1424         _safeMint(msg.sender, quantity);
1425     }
1426 
1427     function mint(uint256 quantity) public payable {
1428         require(status == 3, "Minting not active!!");
1429         require(numberMinted(msg.sender).add(quantity) <= mint_perAdd && quantity > 0, "Invalid mint quantity!!");
1430         require(msg.value >= quantity.mul(price), "Insufficient eth sent for mint!!");
1431         require(totalSupply().add(quantity) + reserve <= collectionSize, "Mint exceeds Collection size!!");        
1432 
1433         _safeMint(msg.sender, quantity);
1434     }
1435 
1436     function swapTrait(uint id, string memory category) public {
1437       require(status_trait_swap ,"Trait Swap not Active!");
1438       require(_exists(id),"Invalid Token id!");
1439       require(ownerOf(id) == msg.sender, "Caller is not id owner!");
1440       require(IERC20(beatzAddress).balanceOf(msg.sender) >= swapPrice[category], "Insufficient balance to update trait!!");
1441       
1442       IERC20(beatzAddress).transferFrom(msg.sender, beatz_vault, swapPrice[category]);
1443       level[id] = level[id] + 1;
1444     }
1445 
1446     ///////////////////////////////////////////////////////////////////////////
1447 
1448     function numberMinted(address owner) public view returns (uint256) {
1449         return _numberMinted(owner);
1450     }
1451 
1452     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1453         require(_exists(tokenId),"ERC721Metadata: URI query for nonexistent token!");
1454 
1455         if(reveal)
1456             return bytes(baseURI()).length > 0 ? string(abi.encodePacked(baseURI(), tokenId.toString())) : "";
1457         else 
1458             return bytes(baseURI()).length > 0 ? baseURI() : "";
1459     }
1460 
1461     function baseURI() public view returns (string memory) {
1462         return uri;
1463     }
1464 
1465     function _startTokenId() pure internal override returns (uint256) {
1466         return 1;
1467     }
1468 
1469     function ownerTokens(address a) public view returns (uint[] memory){
1470         uint b = balanceOf(a);
1471         uint[] memory t= new uint[](b);
1472         for(uint i=0; i<b; i++) t[i] = tokenOfOwnerByIndex(a,i);
1473         return t;
1474     }
1475 
1476     function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
1477         super.setApprovalForAll(operator, approved);
1478     }
1479 
1480     function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {
1481         super.approve(operator, tokenId);
1482     }
1483 
1484     function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
1485         super.transferFrom(from, to, tokenId);
1486     }
1487 
1488     function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {
1489         super.safeTransferFrom(from, to, tokenId);
1490     }
1491 
1492     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)
1493         public
1494         override
1495         onlyAllowedOperator(from){
1496         super.safeTransferFrom(from, to, tokenId, data);
1497     }
1498 
1499     function withdrawMoney() external onlyOwner {
1500         (bool success, ) = msg.sender.call{value: address(this).balance}("");
1501         require(success, "Transfer failed.");
1502     }
1503 }