1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 pragma solidity ^0.4.23;
20 
21 
22 /**
23  * @title ERC20Basic
24  * @dev Simpler version of ERC20 interface
25  * @dev see https://github.com/ethereum/EIPs/issues/179
26  */
27 contract ERC20Basic {
28   function totalSupply() public view returns (uint256);
29   function balanceOf(address who) public view returns (uint256);
30   function transfer(address to, uint256 value) public returns (bool);
31   event Transfer(address indexed from, address indexed to, uint256 value);
32 }
33 
34 
35 /**
36  * @title ERC20 interface
37  * @dev see https://github.com/ethereum/EIPs/issues/20
38  */
39 contract ERC20 is ERC20Basic {
40   function allowance(address owner, address spender)
41     public view returns (uint256);
42 
43   function transferFrom(address from, address to, uint256 value)
44     public returns (bool);
45 
46   function approve(address spender, uint256 value) public returns (bool);
47   event Approval(
48     address indexed owner,
49     address indexed spender,
50     uint256 value
51   );
52 }
53 
54 
55 
56 /**
57  * @title SafeMath
58  * @dev Math operations with safety checks that throw on error
59  */
60 library SafeMath {
61 
62   /**
63   * @dev Multiplies two numbers, throws on overflow.
64   */
65   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
66     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
67     // benefit is lost if 'b' is also tested.
68     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
69     if (a == 0) {
70       return 0;
71     }
72 
73     c = a * b;
74     assert(c / a == b);
75     return c;
76   }
77 
78   /**
79   * @dev Integer division of two numbers, truncating the quotient.
80   */
81   function div(uint256 a, uint256 b) internal pure returns (uint256) {
82     // assert(b > 0); // Solidity automatically throws when dividing by 0
83     // uint256 c = a / b;
84     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
85     return a / b;
86   }
87 
88   /**
89   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
90   */
91   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
92     assert(b <= a);
93     return a - b;
94   }
95 
96   /**
97   * @dev Adds two numbers, throws on overflow.
98   */
99   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
100     c = a + b;
101     assert(c >= a);
102     return c;
103   }
104 }
105 
106 
107 /**
108  * @title Crowdsale
109  * @dev Crowdsale is a base contract for managing a token crowdsale,
110  * allowing investors to purchase tokens with ether. This contract implements
111  * such functionality in its most fundamental form and can be extended to provide additional
112  * functionality and/or custom behavior.
113  * The external interface represents the basic interface for purchasing tokens, and conform
114  * the base architecture for crowdsales. They are *not* intended to be modified / overriden.
115  * The internal interface conforms the extensible and modifiable surface of crowdsales. Override
116  * the methods to add functionality. Consider using 'super' where appropiate to concatenate
117  * behavior.
118  */
119 contract Crowdsale {
120   using SafeMath for uint256;
121 
122   // The token being sold
123   ERC20 public token;
124 
125   // Address where funds are collected
126   address public wallet;
127 
128   // How many token units a buyer gets per wei.
129   // The rate is the conversion between wei and the smallest and indivisible token unit.
130   // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK
131   // 1 wei will give you 1 unit, or 0.001 TOK.
132   uint256 public rate;
133 
134   // Amount of wei raised
135   uint256 public weiRaised;
136 
137   /**
138    * Event for token purchase logging
139    * @param purchaser who paid for the tokens
140    * @param beneficiary who got the tokens
141    * @param value weis paid for purchase
142    * @param amount amount of tokens purchased
143    */
144   event TokenPurchase(
145     address indexed purchaser,
146     address indexed beneficiary,
147     uint256 value,
148     uint256 amount
149   );
150 
151   /**
152    * @param _rate Number of token units a buyer gets per wei
153    * @param _wallet Address where collected funds will be forwarded to
154    * @param _token Address of the token being sold
155    */
156   constructor(uint256 _rate, address _wallet, ERC20 _token) public {
157     require(_rate > 0);
158     require(_wallet != address(0));
159     require(_token != address(0));
160 
161     rate = _rate;
162     wallet = _wallet;
163     token = _token;
164   }
165 
166   // -----------------------------------------
167   // Crowdsale external interface
168   // -----------------------------------------
169 
170   /**
171    * @dev fallback function ***DO NOT OVERRIDE***
172    */
173   function () external payable {
174     buyTokens(msg.sender);
175   }
176 
177   /**
178    * @dev low level token purchase ***DO NOT OVERRIDE***
179    * @param _beneficiary Address performing the token purchase
180    */
181   function buyTokens(address _beneficiary) public payable {
182 
183     uint256 weiAmount = msg.value;
184     _preValidatePurchase(_beneficiary, weiAmount);
185 
186     // calculate token amount to be created
187     uint256 tokens = _getTokenAmount(weiAmount);
188 
189     // update state
190     weiRaised = weiRaised.add(weiAmount);
191 
192     _processPurchase(_beneficiary, tokens);
193     emit TokenPurchase(
194       msg.sender,
195       _beneficiary,
196       weiAmount,
197       tokens
198     );
199 
200     _updatePurchasingState(_beneficiary, weiAmount);
201 
202     _forwardFunds();
203     _postValidatePurchase(_beneficiary, weiAmount);
204   }
205 
206   // -----------------------------------------
207   // Internal interface (extensible)
208   // -----------------------------------------
209 
210   /**
211    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.
212    * @param _beneficiary Address performing the token purchase
213    * @param _weiAmount Value in wei involved in the purchase
214    */
215   function _preValidatePurchase(
216     address _beneficiary,
217     uint256 _weiAmount
218   )
219     internal
220   {
221     require(_beneficiary != address(0));
222     require(_weiAmount != 0);
223   }
224 
225   /**
226    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.
227    * @param _beneficiary Address performing the token purchase
228    * @param _weiAmount Value in wei involved in the purchase
229    */
230   function _postValidatePurchase(
231     address _beneficiary,
232     uint256 _weiAmount
233   )
234     internal
235   {
236     // optional override
237   }
238 
239   /**
240    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
241    * @param _beneficiary Address performing the token purchase
242    * @param _tokenAmount Number of tokens to be emitted
243    */
244   function _deliverTokens(
245     address _beneficiary,
246     uint256 _tokenAmount
247   )
248     internal
249   {
250     token.transfer(_beneficiary, _tokenAmount);
251   }
252 
253   /**
254    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.
255    * @param _beneficiary Address receiving the tokens
256    * @param _tokenAmount Number of tokens to be purchased
257    */
258   function _processPurchase(
259     address _beneficiary,
260     uint256 _tokenAmount
261   )
262     internal
263   {
264     _deliverTokens(_beneficiary, _tokenAmount);
265   }
266 
267   /**
268    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)
269    * @param _beneficiary Address receiving the tokens
270    * @param _weiAmount Value in wei involved in the purchase
271    */
272   function _updatePurchasingState(
273     address _beneficiary,
274     uint256 _weiAmount
275   )
276     internal
277   {
278     // optional override
279   }
280 
281   /**
282    * @dev Override to extend the way in which ether is converted to tokens.
283    * @param _weiAmount Value in wei to be converted into tokens
284    * @return Number of tokens that can be purchased with the specified _weiAmount
285    */
286   function _getTokenAmount(uint256 _weiAmount)
287     internal view returns (uint256)
288   {
289     return _weiAmount.mul(rate);
290   }
291 
292   /**
293    * @dev Determines how ETH is stored/forwarded on purchases.
294    */
295   function _forwardFunds() internal {
296     wallet.transfer(msg.value);
297   }
298 }
299 
300 
301 
302 /**
303  * @title Ownable
304  * @dev The Ownable contract has an owner address, and provides basic authorization control
305  * functions, this simplifies the implementation of "user permissions".
306  */
307 contract Ownable {
308   address public owner;
309 
310 
311   event OwnershipRenounced(address indexed previousOwner);
312   event OwnershipTransferred(
313     address indexed previousOwner,
314     address indexed newOwner
315   );
316 
317 
318   /**
319    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
320    * account.
321    */
322   constructor() public {
323     owner = msg.sender;
324   }
325 
326   /**
327    * @dev Throws if called by any account other than the owner.
328    */
329   modifier onlyOwner() {
330     require(msg.sender == owner);
331     _;
332   }
333 
334   /**
335    * @dev Allows the current owner to relinquish control of the contract.
336    */
337   function renounceOwnership() public onlyOwner {
338     emit OwnershipRenounced(owner);
339     owner = address(0);
340   }
341 
342   /**
343    * @dev Allows the current owner to transfer control of the contract to a newOwner.
344    * @param _newOwner The address to transfer ownership to.
345    */
346   function transferOwnership(address _newOwner) public onlyOwner {
347     _transferOwnership(_newOwner);
348   }
349 
350   /**
351    * @dev Transfers control of the contract to a newOwner.
352    * @param _newOwner The address to transfer ownership to.
353    */
354   function _transferOwnership(address _newOwner) internal {
355     require(_newOwner != address(0));
356     emit OwnershipTransferred(owner, _newOwner);
357     owner = _newOwner;
358   }
359 }
360 
361 
362 /**
363  * @title TimedCrowdsale
364  * @dev Crowdsale accepting contributions only within a time frame.
365  */
366 contract TimedCrowdsale is Crowdsale {
367   using SafeMath for uint256;
368 
369   uint256 public openingTime;
370   uint256 public closingTime;
371 
372   /**
373    * @dev Reverts if not in crowdsale time range.
374    */
375   modifier onlyWhileOpen {
376     // solium-disable-next-line security/no-block-members
377     require(block.timestamp >= openingTime && block.timestamp <= closingTime);
378     _;
379   }
380 
381   /**
382    * @dev Constructor, takes crowdsale opening and closing times.
383    * @param _openingTime Crowdsale opening time
384    * @param _closingTime Crowdsale closing time
385    */
386   constructor(uint256 _openingTime, uint256 _closingTime) public {
387     // solium-disable-next-line security/no-block-members
388     require(_openingTime >= block.timestamp);
389     require(_closingTime >= _openingTime);
390 
391     openingTime = _openingTime;
392     closingTime = _closingTime;
393   }
394 
395   /**
396    * @dev Checks whether the period in which the crowdsale is open has already elapsed.
397    * @return Whether crowdsale period has elapsed
398    */
399   function hasClosed() public view returns (bool) {
400     // solium-disable-next-line security/no-block-members
401     return block.timestamp > closingTime;
402   }
403 
404   /**
405    * @dev Extend parent behavior requiring to be within contributing period
406    * @param _beneficiary Token purchaser
407    * @param _weiAmount Amount of wei contributed
408    */
409   function _preValidatePurchase(
410     address _beneficiary,
411     uint256 _weiAmount
412   )
413     internal
414     onlyWhileOpen
415   {
416     super._preValidatePurchase(_beneficiary, _weiAmount);
417   }
418 
419 }
420 
421 
422 /**
423  * @title FinalizableCrowdsale
424  * @dev Extension of Crowdsale where an owner can do extra work
425  * after finishing.
426  */
427 contract FinalizableCrowdsale is TimedCrowdsale, Ownable {
428   using SafeMath for uint256;
429 
430   bool public isFinalized = false;
431 
432   event Finalized();
433 
434   /**
435    * @dev Must be called after crowdsale ends, to do some extra finalization
436    * work. Calls the contract's finalization function.
437    */
438   function finalize() onlyOwner public {
439     require(!isFinalized);
440     require(hasClosed());
441 
442     finalization();
443     emit Finalized();
444 
445     isFinalized = true;
446   }
447 
448   /**
449    * @dev Can be overridden to add finalization logic. The overriding function
450    * should call super.finalization() to ensure the chain of finalization is
451    * executed entirely.
452    */
453   function finalization() internal {
454   }
455 
456 }
457 
458 
459 /**
460  * @title RefundVault
461  * @dev This contract is used for storing funds while a crowdsale
462  * is in progress. Supports refunding the money if crowdsale fails,
463  * and forwarding it if crowdsale is successful.
464  */
465 contract RefundVault is Ownable {
466   using SafeMath for uint256;
467 
468   enum State { Active, Refunding, Closed }
469 
470   mapping (address => uint256) public deposited;
471   address public wallet;
472   State public state;
473 
474   event Closed();
475   event RefundsEnabled();
476   event Refunded(address indexed beneficiary, uint256 weiAmount);
477 
478   /**
479    * @param _wallet Vault address
480    */
481   constructor(address _wallet) public {
482     require(_wallet != address(0));
483     wallet = _wallet;
484     state = State.Active;
485   }
486 
487   /**
488    * @param investor Investor address
489    */
490   function deposit(address investor) onlyOwner public payable {
491     require(state == State.Active);
492     deposited[investor] = deposited[investor].add(msg.value);
493   }
494 
495   function close() onlyOwner public {
496     require(state == State.Active);
497     state = State.Closed;
498     emit Closed();
499     wallet.transfer(address(this).balance);
500   }
501 
502   function enableRefunds() onlyOwner public {
503     require(state == State.Active);
504     state = State.Refunding;
505     emit RefundsEnabled();
506   }
507 
508   /**
509    * @param investor Investor address
510    */
511   function refund(address investor) public {
512     require(state == State.Refunding);
513     uint256 depositedValue = deposited[investor];
514     deposited[investor] = 0;
515     investor.transfer(depositedValue);
516     emit Refunded(investor, depositedValue);
517   }
518 }
519 
520 
521 
522 /**
523  * @title Basic token
524  * @dev Basic version of StandardToken, with no allowances.
525  */
526 contract BasicToken is ERC20Basic {
527   using SafeMath for uint256;
528 
529   mapping(address => uint256) balances;
530 
531   uint256 totalSupply_;
532 
533   /**
534   * @dev total number of tokens in existence
535   */
536   function totalSupply() public view returns (uint256) {
537     return totalSupply_;
538   }
539 
540   /**
541   * @dev transfer token for a specified address
542   * @param _to The address to transfer to.
543   * @param _value The amount to be transferred.
544   */
545   function transfer(address _to, uint256 _value) public returns (bool) {
546     require(_to != address(0));
547     require(_value <= balances[msg.sender]);
548 
549     balances[msg.sender] = balances[msg.sender].sub(_value);
550     balances[_to] = balances[_to].add(_value);
551     emit Transfer(msg.sender, _to, _value);
552     return true;
553   }
554 
555   /**
556   * @dev Gets the balance of the specified address.
557   * @param _owner The address to query the the balance of.
558   * @return An uint256 representing the amount owned by the passed address.
559   */
560   function balanceOf(address _owner) public view returns (uint256) {
561     return balances[_owner];
562   }
563 
564 }
565 
566 
567 /**
568  * @title Standard ERC20 token
569  *
570  * @dev Implementation of the basic standard token.
571  * @dev https://github.com/ethereum/EIPs/issues/20
572  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
573  */
574 contract StandardToken is ERC20, BasicToken {
575 
576   mapping (address => mapping (address => uint256)) internal allowed;
577 
578 
579   /**
580    * @dev Transfer tokens from one address to another
581    * @param _from address The address which you want to send tokens from
582    * @param _to address The address which you want to transfer to
583    * @param _value uint256 the amount of tokens to be transferred
584    */
585   function transferFrom(
586     address _from,
587     address _to,
588     uint256 _value
589   )
590     public
591     returns (bool)
592   {
593     require(_to != address(0));
594     require(_value <= balances[_from]);
595     require(_value <= allowed[_from][msg.sender]);
596 
597     balances[_from] = balances[_from].sub(_value);
598     balances[_to] = balances[_to].add(_value);
599     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
600     emit Transfer(_from, _to, _value);
601     return true;
602   }
603 
604   /**
605    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
606    *
607    * Beware that changing an allowance with this method brings the risk that someone may use both the old
608    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
609    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
610    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
611    * @param _spender The address which will spend the funds.
612    * @param _value The amount of tokens to be spent.
613    */
614   function approve(address _spender, uint256 _value) public returns (bool) {
615     allowed[msg.sender][_spender] = _value;
616     emit Approval(msg.sender, _spender, _value);
617     return true;
618   }
619 
620   /**
621    * @dev Function to check the amount of tokens that an owner allowed to a spender.
622    * @param _owner address The address which owns the funds.
623    * @param _spender address The address which will spend the funds.
624    * @return A uint256 specifying the amount of tokens still available for the spender.
625    */
626   function allowance(
627     address _owner,
628     address _spender
629    )
630     public
631     view
632     returns (uint256)
633   {
634     return allowed[_owner][_spender];
635   }
636 
637   /**
638    * @dev Increase the amount of tokens that an owner allowed to a spender.
639    *
640    * approve should be called when allowed[_spender] == 0. To increment
641    * allowed value is better to use this function to avoid 2 calls (and wait until
642    * the first transaction is mined)
643    * From MonolithDAO Token.sol
644    * @param _spender The address which will spend the funds.
645    * @param _addedValue The amount of tokens to increase the allowance by.
646    */
647   function increaseApproval(
648     address _spender,
649     uint _addedValue
650   )
651     public
652     returns (bool)
653   {
654     allowed[msg.sender][_spender] = (
655       allowed[msg.sender][_spender].add(_addedValue));
656     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
657     return true;
658   }
659 
660   /**
661    * @dev Decrease the amount of tokens that an owner allowed to a spender.
662    *
663    * approve should be called when allowed[_spender] == 0. To decrement
664    * allowed value is better to use this function to avoid 2 calls (and wait until
665    * the first transaction is mined)
666    * From MonolithDAO Token.sol
667    * @param _spender The address which will spend the funds.
668    * @param _subtractedValue The amount of tokens to decrease the allowance by.
669    */
670   function decreaseApproval(
671     address _spender,
672     uint _subtractedValue
673   )
674     public
675     returns (bool)
676   {
677     uint oldValue = allowed[msg.sender][_spender];
678     if (_subtractedValue > oldValue) {
679       allowed[msg.sender][_spender] = 0;
680     } else {
681       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
682     }
683     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
684     return true;
685   }
686 
687 }
688 
689 
690 /**
691  * @title Mintable token
692  * @dev Simple ERC20 Token example, with mintable token creation
693  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
694  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
695  */
696 contract MintableToken is StandardToken, Ownable {
697   event Mint(address indexed to, uint256 amount);
698   event MintFinished();
699 
700   bool public mintingFinished = false;
701 
702 
703   modifier canMint() {
704     require(!mintingFinished);
705     _;
706   }
707 
708   modifier hasMintPermission() {
709     require(msg.sender == owner);
710     _;
711   }
712 
713   /**
714    * @dev Function to mint tokens
715    * @param _to The address that will receive the minted tokens.
716    * @param _amount The amount of tokens to mint.
717    * @return A boolean that indicates if the operation was successful.
718    */
719   function mint(
720     address _to,
721     uint256 _amount
722   )
723     hasMintPermission
724     canMint
725     public
726     returns (bool)
727   {
728     totalSupply_ = totalSupply_.add(_amount);
729     balances[_to] = balances[_to].add(_amount);
730     emit Mint(_to, _amount);
731     emit Transfer(address(0), _to, _amount);
732     return true;
733   }
734 
735   /**
736    * @dev Function to stop minting new tokens.
737    * @return True if the operation was successful.
738    */
739   function finishMinting() onlyOwner canMint public returns (bool) {
740     mintingFinished = true;
741     emit MintFinished();
742     return true;
743   }
744 }
745 
746 
747 contract FreezableToken is StandardToken {
748     // freezing chains
749     mapping (bytes32 => uint64) internal chains;
750     // freezing amounts for each chain
751     mapping (bytes32 => uint) internal freezings;
752     // total freezing balance per address
753     mapping (address => uint) internal freezingBalance;
754 
755     event Freezed(address indexed to, uint64 release, uint amount);
756     event Released(address indexed owner, uint amount);
757 
758     /**
759      * @dev Gets the balance of the specified address include freezing tokens.
760      * @param _owner The address to query the the balance of.
761      * @return An uint256 representing the amount owned by the passed address.
762      */
763     function balanceOf(address _owner) public view returns (uint256 balance) {
764         return super.balanceOf(_owner) + freezingBalance[_owner];
765     }
766 
767     /**
768      * @dev Gets the balance of the specified address without freezing tokens.
769      * @param _owner The address to query the the balance of.
770      * @return An uint256 representing the amount owned by the passed address.
771      */
772     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
773         return super.balanceOf(_owner);
774     }
775 
776     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
777         return freezingBalance[_owner];
778     }
779 
780     /**
781      * @dev gets freezing count
782      * @param _addr Address of freeze tokens owner.
783      */
784     function freezingCount(address _addr) public view returns (uint count) {
785         uint64 release = chains[toKey(_addr, 0)];
786         while (release != 0) {
787             count++;
788             release = chains[toKey(_addr, release)];
789         }
790     }
791 
792     /**
793      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
794      * @param _addr Address of freeze tokens owner.
795      * @param _index Freezing portion index. It ordered by release date descending.
796      */
797     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
798         for (uint i = 0; i < _index + 1; i++) {
799             _release = chains[toKey(_addr, _release)];
800             if (_release == 0) {
801                 return;
802             }
803         }
804         _balance = freezings[toKey(_addr, _release)];
805     }
806 
807     /**
808      * @dev freeze your tokens to the specified address.
809      *      Be careful, gas usage is not deterministic,
810      *      and depends on how many freezes _to address already has.
811      * @param _to Address to which token will be freeze.
812      * @param _amount Amount of token to freeze.
813      * @param _until Release date, must be in future.
814      */
815     function freezeTo(address _to, uint _amount, uint64 _until) public {
816         require(_to != address(0));
817         require(_amount <= balances[msg.sender]);
818 
819         balances[msg.sender] = balances[msg.sender].sub(_amount);
820 
821         bytes32 currentKey = toKey(_to, _until);
822         freezings[currentKey] = freezings[currentKey].add(_amount);
823         freezingBalance[_to] = freezingBalance[_to].add(_amount);
824 
825         freeze(_to, _until);
826         emit Transfer(msg.sender, _to, _amount);
827         emit Freezed(_to, _until, _amount);
828     }
829 
830     /**
831      * @dev release first available freezing tokens.
832      */
833     function releaseOnce() public {
834         bytes32 headKey = toKey(msg.sender, 0);
835         uint64 head = chains[headKey];
836         require(head != 0);
837         require(uint64(block.timestamp) > head);
838         bytes32 currentKey = toKey(msg.sender, head);
839 
840         uint64 next = chains[currentKey];
841 
842         uint amount = freezings[currentKey];
843         delete freezings[currentKey];
844 
845         balances[msg.sender] = balances[msg.sender].add(amount);
846         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
847 
848         if (next == 0) {
849             delete chains[headKey];
850         } else {
851             chains[headKey] = next;
852             delete chains[currentKey];
853         }
854         emit Released(msg.sender, amount);
855     }
856 
857     /**
858      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
859      * @return how many tokens was released
860      */
861     function releaseAll() public returns (uint tokens) {
862         uint release;
863         uint balance;
864         (release, balance) = getFreezing(msg.sender, 0);
865         while (release != 0 && block.timestamp > release) {
866             releaseOnce();
867             tokens += balance;
868             (release, balance) = getFreezing(msg.sender, 0);
869         }
870     }
871 
872     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
873         // WISH masc to increase entropy
874         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
875         assembly {
876             result := or(result, mul(_addr, 0x10000000000000000))
877             result := or(result, _release)
878         }
879     }
880 
881     function freeze(address _to, uint64 _until) internal {
882         require(_until > block.timestamp);
883         bytes32 key = toKey(_to, _until);
884         bytes32 parentKey = toKey(_to, uint64(0));
885         uint64 next = chains[parentKey];
886 
887         if (next == 0) {
888             chains[parentKey] = _until;
889             return;
890         }
891 
892         bytes32 nextKey = toKey(_to, next);
893         uint parent;
894 
895         while (next != 0 && _until > next) {
896             parent = next;
897             parentKey = nextKey;
898 
899             next = chains[nextKey];
900             nextKey = toKey(_to, next);
901         }
902 
903         if (_until == next) {
904             return;
905         }
906 
907         if (next != 0) {
908             chains[key] = next;
909         }
910 
911         chains[parentKey] = _until;
912     }
913 }
914 
915 
916 /**
917  * @title Burnable Token
918  * @dev Token that can be irreversibly burned (destroyed).
919  */
920 contract BurnableToken is BasicToken {
921 
922   event Burn(address indexed burner, uint256 value);
923 
924   /**
925    * @dev Burns a specific amount of tokens.
926    * @param _value The amount of token to be burned.
927    */
928   function burn(uint256 _value) public {
929     _burn(msg.sender, _value);
930   }
931 
932   function _burn(address _who, uint256 _value) internal {
933     require(_value <= balances[_who]);
934     // no need to require value <= totalSupply, since that would imply the
935     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
936 
937     balances[_who] = balances[_who].sub(_value);
938     totalSupply_ = totalSupply_.sub(_value);
939     emit Burn(_who, _value);
940     emit Transfer(_who, address(0), _value);
941   }
942 }
943 
944 
945 
946 /**
947  * @title Pausable
948  * @dev Base contract which allows children to implement an emergency stop mechanism.
949  */
950 contract Pausable is Ownable {
951   event Pause();
952   event Unpause();
953 
954   bool public paused = false;
955 
956 
957   /**
958    * @dev Modifier to make a function callable only when the contract is not paused.
959    */
960   modifier whenNotPaused() {
961     require(!paused);
962     _;
963   }
964 
965   /**
966    * @dev Modifier to make a function callable only when the contract is paused.
967    */
968   modifier whenPaused() {
969     require(paused);
970     _;
971   }
972 
973   /**
974    * @dev called by the owner to pause, triggers stopped state
975    */
976   function pause() onlyOwner whenNotPaused public {
977     paused = true;
978     emit Pause();
979   }
980 
981   /**
982    * @dev called by the owner to unpause, returns to normal state
983    */
984   function unpause() onlyOwner whenPaused public {
985     paused = false;
986     emit Unpause();
987   }
988 }
989 
990 
991 contract FreezableMintableToken is FreezableToken, MintableToken {
992     /**
993      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
994      *      Be careful, gas usage is not deterministic,
995      *      and depends on how many freezes _to address already has.
996      * @param _to Address to which token will be freeze.
997      * @param _amount Amount of token to mint and freeze.
998      * @param _until Release date, must be in future.
999      * @return A boolean that indicates if the operation was successful.
1000      */
1001     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
1002         totalSupply_ = totalSupply_.add(_amount);
1003 
1004         bytes32 currentKey = toKey(_to, _until);
1005         freezings[currentKey] = freezings[currentKey].add(_amount);
1006         freezingBalance[_to] = freezingBalance[_to].add(_amount);
1007 
1008         freeze(_to, _until);
1009         emit Mint(_to, _amount);
1010         emit Freezed(_to, _until, _amount);
1011         emit Transfer(msg.sender, _to, _amount);
1012         return true;
1013     }
1014 }
1015 
1016 
1017 
1018 contract Consts {
1019     uint public constant TOKEN_DECIMALS = 18;
1020     uint8 public constant TOKEN_DECIMALS_UINT8 = 18;
1021     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
1022 
1023     string public constant TOKEN_NAME = "CPollo";
1024     string public constant TOKEN_SYMBOL = "CPLO";
1025     bool public constant PAUSED = true;
1026     address public constant TARGET_USER = 0x3374EB92854FF40c1E74a8FE2114d99b38214070;
1027     
1028     uint public constant START_TIME = 1534737600;
1029     
1030     bool public constant CONTINUE_MINTING = false;
1031 }
1032 
1033 
1034 
1035 
1036 /**
1037  * @title CappedCrowdsale
1038  * @dev Crowdsale with a limit for total contributions.
1039  */
1040 contract CappedCrowdsale is Crowdsale {
1041   using SafeMath for uint256;
1042 
1043   uint256 public cap;
1044 
1045   /**
1046    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.
1047    * @param _cap Max amount of wei to be contributed
1048    */
1049   constructor(uint256 _cap) public {
1050     require(_cap > 0);
1051     cap = _cap;
1052   }
1053 
1054   /**
1055    * @dev Checks whether the cap has been reached.
1056    * @return Whether the cap was reached
1057    */
1058   function capReached() public view returns (bool) {
1059     return weiRaised >= cap;
1060   }
1061 
1062   /**
1063    * @dev Extend parent behavior requiring purchase to respect the funding cap.
1064    * @param _beneficiary Token purchaser
1065    * @param _weiAmount Amount of wei contributed
1066    */
1067   function _preValidatePurchase(
1068     address _beneficiary,
1069     uint256 _weiAmount
1070   )
1071     internal
1072   {
1073     super._preValidatePurchase(_beneficiary, _weiAmount);
1074     require(weiRaised.add(_weiAmount) <= cap);
1075   }
1076 
1077 }
1078 
1079 
1080 /**
1081  * @title MintedCrowdsale
1082  * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.
1083  * Token ownership should be transferred to MintedCrowdsale for minting.
1084  */
1085 contract MintedCrowdsale is Crowdsale {
1086 
1087   /**
1088    * @dev Overrides delivery by minting tokens upon purchase.
1089    * @param _beneficiary Token purchaser
1090    * @param _tokenAmount Number of tokens to be minted
1091    */
1092   function _deliverTokens(
1093     address _beneficiary,
1094     uint256 _tokenAmount
1095   )
1096     internal
1097   {
1098     require(MintableToken(token).mint(_beneficiary, _tokenAmount));
1099   }
1100 }
1101 
1102 
1103 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
1104     
1105 {
1106     
1107 
1108     function name() public pure returns (string _name) {
1109         return TOKEN_NAME;
1110     }
1111 
1112     function symbol() public pure returns (string _symbol) {
1113         return TOKEN_SYMBOL;
1114     }
1115 
1116     function decimals() public pure returns (uint8 _decimals) {
1117         return TOKEN_DECIMALS_UINT8;
1118     }
1119 
1120     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
1121         require(!paused);
1122         return super.transferFrom(_from, _to, _value);
1123     }
1124 
1125     function transfer(address _to, uint256 _value) public returns (bool _success) {
1126         require(!paused);
1127         return super.transfer(_to, _value);
1128     }
1129 
1130     
1131 }
1132 
1133 
1134 
1135 
1136 
1137 /**
1138  * @title RefundableCrowdsale
1139  * @dev Extension of Crowdsale contract that adds a funding goal, and
1140  * the possibility of users getting a refund if goal is not met.
1141  * Uses a RefundVault as the crowdsale's vault.
1142  */
1143 contract RefundableCrowdsale is FinalizableCrowdsale {
1144   using SafeMath for uint256;
1145 
1146   // minimum amount of funds to be raised in weis
1147   uint256 public goal;
1148 
1149   // refund vault used to hold funds while crowdsale is running
1150   RefundVault public vault;
1151 
1152   /**
1153    * @dev Constructor, creates RefundVault.
1154    * @param _goal Funding goal
1155    */
1156   constructor(uint256 _goal) public {
1157     require(_goal > 0);
1158     vault = new RefundVault(wallet);
1159     goal = _goal;
1160   }
1161 
1162   /**
1163    * @dev Investors can claim refunds here if crowdsale is unsuccessful
1164    */
1165   function claimRefund() public {
1166     require(isFinalized);
1167     require(!goalReached());
1168 
1169     vault.refund(msg.sender);
1170   }
1171 
1172   /**
1173    * @dev Checks whether funding goal was reached.
1174    * @return Whether funding goal was reached
1175    */
1176   function goalReached() public view returns (bool) {
1177     return weiRaised >= goal;
1178   }
1179 
1180   /**
1181    * @dev vault finalization task, called when owner calls finalize()
1182    */
1183   function finalization() internal {
1184     if (goalReached()) {
1185       vault.close();
1186     } else {
1187       vault.enableRefunds();
1188     }
1189 
1190     super.finalization();
1191   }
1192 
1193   /**
1194    * @dev Overrides Crowdsale fund forwarding, sending funds to vault.
1195    */
1196   function _forwardFunds() internal {
1197     vault.deposit.value(msg.value)(msg.sender);
1198   }
1199 
1200 }
1201 
1202 
1203 contract MainCrowdsale is Consts, FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale {
1204     function hasStarted() public view returns (bool) {
1205         return now >= openingTime;
1206     }
1207 
1208     function startTime() public view returns (uint256) {
1209         return openingTime;
1210     }
1211 
1212     function endTime() public view returns (uint256) {
1213         return closingTime;
1214     }
1215 
1216     function hasClosed() public view returns (bool) {
1217         return super.hasClosed() || capReached();
1218     }
1219 
1220     function hasEnded() public view returns (bool) {
1221         return hasClosed();
1222     }
1223 
1224     function finalization() internal {
1225         super.finalization();
1226 
1227         if (PAUSED) {
1228             MainToken(token).unpause();
1229         }
1230 
1231         if (!CONTINUE_MINTING) {
1232             require(MintableToken(token).finishMinting());
1233         }
1234 
1235         Ownable(token).transferOwnership(TARGET_USER);
1236     }
1237 
1238     /**
1239      * @dev Override to extend the way in which ether is converted to tokens.
1240      * @param _weiAmount Value in wei to be converted into tokens
1241      * @return Number of tokens that can be purchased with the specified _weiAmount
1242      */
1243     function _getTokenAmount(uint256 _weiAmount)
1244         internal view returns (uint256)
1245     {
1246         return _weiAmount.mul(rate).div(1 ether);
1247     }
1248 }
1249 
1250 
1251 
1252 contract TemplateCrowdsale is Consts, MainCrowdsale
1253     
1254     
1255     , RefundableCrowdsale
1256     
1257     
1258     
1259 {
1260     event Initialized();
1261     event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);
1262     bool public initialized = false;
1263 
1264     constructor(MintableToken _token) public
1265         Crowdsale(200000 * TOKEN_DECIMAL_MULTIPLIER, 0x3374EB92854FF40c1E74a8FE2114d99b38214070, _token)
1266         TimedCrowdsale(START_TIME > now ? START_TIME : now, 1538366400)
1267         CappedCrowdsale(50000000000000000000000)
1268         
1269         RefundableCrowdsale(1000000000000000000000)
1270         
1271     {
1272     }
1273 
1274     function init() public onlyOwner {
1275         require(!initialized);
1276         initialized = true;
1277 
1278         if (PAUSED) {
1279             MainToken(token).pause();
1280         }
1281 
1282         
1283         address[4] memory addresses = [address(0x85efaea2ba17104a6fd41099cececf29dc6bcfe6),address(0x3681d701b8679c6adb866736d3e523e8856dfa7a),address(0xbb0cd3ab7cb7aff6298dc25ce710052a6c9cb764),address(0x7376a1b427693a78b741fac92824f0ad0988ec28)];
1284         uint[4] memory amounts = [uint(1500000000000000000000000000),uint(1500000000000000000000000000),uint(2000000000000000000000000000),uint(5000000000000000000000000000)];
1285         uint64[4] memory freezes = [uint64(0),uint64(0),uint64(0),uint64(0)];
1286 
1287         for (uint i = 0; i < addresses.length; i++) {
1288             if (freezes[i] == 0) {
1289                 MainToken(token).mint(addresses[i], amounts[i]);
1290             } else {
1291                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1292             }
1293         }
1294         
1295 
1296         transferOwnership(TARGET_USER);
1297 
1298         emit Initialized();
1299     }
1300 
1301     
1302 
1303     
1304 
1305     
1306 
1307     
1308 
1309     
1310 
1311     
1312 }