1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/PlatinumStaking.sol": {
5       "content": "/*  2022 Platinum Primates Staking Contract 10232022             \t\t\r\n                                                          .                     \r\n                                                                                \r\n                                                               .                \r\n                                       ,%%%@@@@@@#     ##@@@@@#                 \r\n                                      @@@@@,,,,,@@@@&*@@@,,,&@@@                \r\n                        %%%%         ,@@@@%@@@@@%@@@@@@%%@@@%%@@      \r\n                      @&    &@       ,@@@@     @@@@@@@@    @@@@@ \r\n                    &&&,*..*,,@@     ,@@@@     @@/@@@@     @@@@  \r\n                    @@&,*@&&* @@        @@@@@@@@@@@@@,,,,, @@@@        \r\n                      ,@&%%/%@&&          #@@@@@@@&&/,///// @@@#                \r\n                                       ,&@@@&@@@@@@@@&&&&,@@@@@@@               \r\n                   %%%%                @&&&@@@@@@@@@@@@@@&*@@@@@@##             \r\n                 @@@@@                 @@& @&&&@@&  *@@@@,@&*, * @@    \r\n               %%@@@@@                 *&&*&@@@@@@@@@%%%%#%%@@@%,@@  \r\n              @@@@@@@@@                **@&,***@&@@@&@@@&@@&&*&@@@            \r\n                 @@@@@@@@%%               /@@@@&%%%%%%%%%%%%%%@@@// @%        \r\n              .,., @@@@@@@@@@@              *,*&&&&&&&&&@@&@&&&*    @@  \r\n            ........,,@@@@@@@@@@%%                               %%@@@          \r\n         ,,....&&&&&,..  @@@@@@@@@@@@@@@                       @@@@@@        \r\n       ......#&&&&&&&&##.....,,,,@@@@@@@@@@%%%%        %%%%%@@@@@,,,.#          \r\n     .......&&&&&&&&&&&&&&@&&&&&&.....         @@@  @@         ,.%&&&&@@  \r\n   .......&&&&&&&&&&&&&&&&&&&&&&&&&&&&#########...,,..######## ..**&&&&@%     \r\n    ....,&&&&&&&&&&&&&&@ ..&&&&&&  && &&  &       && & && & &&@ ...&&&&&@       \r\n   ......&&&&&&&&&&&&&&&@  .&&&&& ,## & ,, & &&  &   &   &#&  @ ....&&&&&@ */\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC721A {\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    error MintToZeroAddress();\r\n\r\n    error MintZeroQuantity();\r\n\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    error TransferFromIncorrectOwner();\r\n\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    error TransferToZeroAddress();\r\n\r\n    error URIQueryForNonexistentToken();\r\n\r\n    error MintERC2309QuantityExceedsLimit();\r\n\r\n    error OwnershipNotInitializedForExtraData();\r\n\r\n    struct TokenOwnership {\r\n        address addr;\r\n        uint64 startTimestamp;\r\n        bool burned;\r\n        uint24 extraData;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function approve(address to, uint256 tokenId) external payable;\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    event ConsecutiveTransfer(\r\n        uint256 indexed fromTokenId,\r\n        uint256 toTokenId,\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n}\r\n\r\ninterface IERC721AQueryable is IERC721A {\r\n    error InvalidQueryRange();\r\n\r\n    function explicitOwnershipsOf(uint256[] memory tokenIds)\r\n        external\r\n        view\r\n        returns (TokenOwnership[] memory);\r\n\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function tokensOfOwner(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721A {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IAccessControl {\r\n    event RoleAdminChanged(\r\n        bytes32 indexed role,\r\n        bytes32 indexed previousAdminRole,\r\n        bytes32 indexed newAdminRole\r\n    );\r\n\r\n    event RoleGranted(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    event RoleRevoked(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    function hasRole(bytes32 role, address account)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IAccessControl).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function hasRole(bytes32 role, address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(account),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function getRoleAdmin(bytes32 role)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bytes32)\r\n    {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    function grantRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n        onlyRole(getRoleAdmin(role))\r\n    {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    function revokeRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n        onlyRole(getRoleAdmin(role))\r\n    {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function renounceRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(\r\n            account == _msgSender(),\r\n            \"AccessControl: can only renounce roles for self\"\r\n        );\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = valueIndex;\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            set._values.length > index,\r\n            \"EnumerableSet: index out of bounds\"\r\n        );\r\n        return set._values[index];\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            require(denominator > prod1);\r\n\r\n            uint256 remainder;\r\n            assembly {\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                denominator := div(denominator, twos)\r\n\r\n                prod0 := div(prod0, twos)\r\n\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            prod0 |= prod1 * twos;\r\n\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    function sqrt(uint256 a, Rounding rounding)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function log2(uint256 value, Rounding rounding)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function log10(uint256 value, Rounding rounding)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function log256(uint256 value, Rounding rounding)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\ncontract PlatinumStaking is Ownable, AccessControl {\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    bytes32 public constant TP_STAKER_ROLE = keccak256(\"TP_STAKER_ROLE\");\r\n\r\n    IERC721AQueryable public NFT;\r\n    IERC20 public token;\r\n\r\n    uint256 public REWARD_AMOUNT = 10 * 10**18;\r\n    uint256 public WITHDRAWAL_FEE_PLTNM = 45 * 10**18;\r\n\r\n    uint256 public LOCK_TIME = 0 days;\r\n    uint256 public REWARD_INTERVAL = 1 days;\r\n\r\n    uint256 private MAX_INT = 2**256 - 1;\r\n\r\n    mapping(address => EnumerableSet.UintSet) stakedNFTs;\r\n    mapping(uint256 => uint256) timestampOfNFTs;\r\n    mapping(address => uint256) rewards;\r\n    mapping(uint256 => address) ownerOfToken;\r\n    uint256 public TotalShares;\r\n\r\n    bool locked;\r\n    modifier lock() {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor(address _NFT, address _token) {\r\n        token = IERC20(_token);\r\n        NFT = IERC721AQueryable(_NFT);\r\n\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(TP_STAKER_ROLE, msg.sender);\r\n    }\r\n\r\n    function setTokenAddress(address _token) external onlyOwner {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    function setNFTAddress(address _NFT) external onlyOwner {\r\n        NFT = IERC721AQueryable(_NFT);\r\n    }\r\n\r\n    function setLockTime(uint256 _locktime) external onlyOwner {\r\n        LOCK_TIME = _locktime;\r\n    }\r\n\r\n    function setWithdrawalFeePltnm(uint256 _withdrawalFeePLTNM)\r\n        external\r\n        onlyOwner\r\n    {\r\n        WITHDRAWAL_FEE_PLTNM = _withdrawalFeePLTNM;\r\n    }\r\n\r\n    function setRewardAmount(uint256 _rewardAmount) external onlyOwner {\r\n        REWARD_AMOUNT = _rewardAmount;\r\n    }\r\n\r\n    function setRewardInterval(uint256 _rewardInterval) external onlyOwner {\r\n        REWARD_INTERVAL = _rewardInterval;\r\n    }\r\n\r\n    function DepositAll() external {\r\n        require(tx.origin == msg.sender, \"Contract can't access this function\");\r\n        require(\r\n            (NFT.tokensOfOwner(msg.sender)).length > 0,\r\n            \"No tokens available.\"\r\n        );\r\n\r\n        uint256[] memory tokensOfOwner = NFT.tokensOfOwner(msg.sender);\r\n\r\n        if (tokensOfOwner.length > 0) {\r\n            for (uint256 i = 0; i < tokensOfOwner.length; i++) {\r\n                Deposit(tokensOfOwner[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function Deposit(uint256 tokenID) public {\r\n        require(tx.origin == msg.sender, \"Contract can't access this function\");\r\n        NFT.transferFrom(msg.sender, address(this), tokenID);\r\n        stakedNFTs[msg.sender].add(tokenID);\r\n        timestampOfNFTs[tokenID] = block.timestamp;\r\n        ownerOfToken[tokenID] = msg.sender;\r\n        TotalShares += 1;\r\n    }\r\n\r\n    function DepositSpecific(uint256[] memory _tokenIDs) public {\r\n        require(\r\n            (NFT.tokensOfOwner(msg.sender)).length > 0,\r\n            \"No tokens available.\"\r\n        );\r\n        if (_tokenIDs.length > 0) {\r\n            for (uint256 i = 0; i < _tokenIDs.length; i++) {\r\n                Deposit(_tokenIDs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function DepositFrom(address _tokenSrc, uint256 _tokenID)\r\n        public\r\n        onlyRole(TP_STAKER_ROLE)\r\n    {\r\n        NFT.transferFrom(_tokenSrc, address(this), _tokenID);\r\n        stakedNFTs[_tokenSrc].add(_tokenID);\r\n        timestampOfNFTs[_tokenID] = block.timestamp;\r\n        ownerOfToken[_tokenID] = _tokenSrc;\r\n        TotalShares += 1;\r\n    }\r\n\r\n    function DepositSpecificFrom(address _tokenSrc, uint256[] memory _tokenIDs)\r\n        public\r\n        onlyRole(TP_STAKER_ROLE)\r\n    {\r\n        require(\r\n            (NFT.tokensOfOwner(_tokenSrc)).length > 0,\r\n            \"No tokens available.\"\r\n        );\r\n        if (_tokenIDs.length > 0) {\r\n            for (uint256 i = 0; i < _tokenIDs.length; i++) {\r\n                DepositFrom(_tokenSrc, _tokenIDs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function DepositAllFrom(address _tokenSrc) public onlyRole(TP_STAKER_ROLE) {\r\n        require(\r\n            (NFT.tokensOfOwner(_tokenSrc)).length > 0,\r\n            \"No tokens available.\"\r\n        );\r\n        uint256[] memory tokensOfOwner = NFT.tokensOfOwner(_tokenSrc);\r\n\r\n        if (tokensOfOwner.length > 0) {\r\n            for (uint256 i = 0; i < tokensOfOwner.length; i++) {\r\n                DepositFrom(_tokenSrc, tokensOfOwner[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function WithdrawSpecific(uint256[] memory _tokenIDs) public {\r\n        require(\r\n            stakedNFTs[msg.sender].length() > 0,\r\n            \"You do not have any staked NFTs\"\r\n        );\r\n        require(\r\n            token.balanceOf(msg.sender) >=\r\n                (WITHDRAWAL_FEE_PLTNM * _tokenIDs.length),\r\n            \"You do not have enough $PLTNM to withdraw your Primates\"\r\n        );\r\n\r\n        if (_tokenIDs.length > 0) {\r\n            for (uint256 i = 0; i < _tokenIDs.length; i++) {\r\n                WithdrawNFT(_tokenIDs[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function WithdrawAll() external {\r\n        require(\r\n            token.balanceOf(msg.sender) >=\r\n                (WITHDRAWAL_FEE_PLTNM *\r\n                    stakedNFTs[msg.sender].length()),\r\n            \"You do not have enough $PLTNM to withdraw your Primates\"\r\n        );\r\n        require(tx.origin == msg.sender, \"Contract can't access this function\");\r\n        while (stakedNFTs[msg.sender].length() > 0) {\r\n            uint256 ID = stakedNFTs[msg.sender].length() - 1;\r\n            WithdrawNFT(stakedNFTs[msg.sender].at(ID));\r\n        }\r\n    }\r\n\r\n    function WithdrawNFT(uint256 tokenId) public lock {\r\n        require(\r\n            token.balanceOf(msg.sender) >= WITHDRAWAL_FEE_PLTNM,\r\n            \"You do not have enough $PLTNM to withdraw your Primates\"\r\n        );\r\n\r\n        require(tx.origin == msg.sender, \"Contract can't access this function\");\r\n        require(\r\n            stakedNFTs[msg.sender].contains(tokenId),\r\n            \"NFT not staked by Account\"\r\n        );\r\n        require(\r\n            block.timestamp - timestampOfNFTs[tokenId] > LOCK_TIME,\r\n            \"NFT can't be unstaked now.\"\r\n        );\r\n\r\n        stakedNFTs[msg.sender].remove(tokenId);\r\n        timestampOfNFTs[tokenId] = 0;\r\n        ownerOfToken[tokenId] = address(0);\r\n        TotalShares -= 1;\r\n        NFT.transferFrom(address(this), msg.sender, tokenId);\r\n\r\n        \r\n            token.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                WITHDRAWAL_FEE_PLTNM\r\n            );\r\n        \r\n    }\r\n\r\n    function getLengthOfStakedNFTs(address _addr)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return stakedNFTs[_addr].length();\r\n    }\r\n\r\n    function getWithdrawalCostEstimate(address _address)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return WITHDRAWAL_FEE_PLTNM * stakedNFTs[_address].length();\r\n    }\r\n\r\n    function getOwnerOfStakedNFT(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return ownerOfToken[_tokenId];\r\n    }\r\n\r\n    function getStakedNFTByIndex(address _addr, uint256 id)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 length = stakedNFTs[_addr].length();\r\n        require(length > id, \"\");\r\n\r\n        return stakedNFTs[_addr].at(id);\r\n    }\r\n\r\n    function WithdrawDividents() external lock {\r\n        _withdrawDividents(msg.sender);\r\n    }\r\n\r\n    function _mintPlatinum(address recipient, uint256 amount) private {\r\n        token.mint(recipient, amount);\r\n    }\r\n\r\n    function _withdrawDividents(address recipient) private {\r\n        require(tx.origin == msg.sender, \"Contract can't access this function\");\r\n        uint256 amount = getDividents(recipient);\r\n\r\n        uint256 length = stakedNFTs[recipient].length();\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 tokenId = stakedNFTs[recipient].at(i);\r\n            timestampOfNFTs[tokenId] = block.timestamp;\r\n        }\r\n\r\n        if (amount == 0) return;\r\n        _mintPlatinum(recipient, amount);\r\n    }\r\n\r\n    function getStakedLengthOfTimeForToken(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.timestamp - timestampOfNFTs[_tokenId];\r\n    }\r\n\r\n\r\n\r\n    function getComulativeRewardRate(address recipient)\r\n        public\r\n        view\r\n        returns (uint256 dividents)\r\n    {\r\n        \r\n        uint256 length = stakedNFTs[recipient].length();\r\n        dividents = REWARD_AMOUNT * length;\r\n\r\n\r\n        if (length == 2) {\r\n            dividents = dividents + ((dividents * 20) / 100);\r\n        } else if (length >= 3 && length < 5) {\r\n            dividents = dividents + ((dividents * 25) / 100);\r\n        } else if (length >= 5 && length < 10) {\r\n            dividents = dividents + ((dividents * 35) / 100);\r\n        } else if (length >= 10) {\r\n            dividents = dividents + ((dividents * 45) / 100);\r\n        }\r\n\r\n    }\r\n\r\n    function getDividents(address recipient)\r\n        public\r\n        view\r\n        returns (uint256 dividents)\r\n    {\r\n        dividents = 0;\r\n        uint256 length = stakedNFTs[recipient].length();\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 tokenId = stakedNFTs[recipient].at(i);\r\n            if (timestampOfNFTs[tokenId] > 0) {\r\n                uint256 diff = block.timestamp - timestampOfNFTs[tokenId];\r\n\r\n                dividents += (diff * REWARD_AMOUNT) / REWARD_INTERVAL;\r\n            }\r\n        }\r\n\r\n        if (length == 2) {\r\n            dividents = dividents + ((dividents * 20) / 100);\r\n        } else if (length >= 3 && length < 5) {\r\n            dividents = dividents + ((dividents * 25) / 100);\r\n        } else if (length >= 5 && length < 10) {\r\n            dividents = dividents + ((dividents * 35) / 100);\r\n        } else if (length >= 10) {\r\n            dividents = dividents + ((dividents * 45) / 100);\r\n        }\r\n    }\r\n}\r\n"
6     }
7   },
8   "settings": {
9     "remappings": [],
10     "optimizer": {
11       "enabled": false,
12       "runs": 200
13     },
14     "evmVersion": "london",
15     "libraries": {},
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "devdoc",
22           "userdoc",
23           "metadata",
24           "abi"
25         ]
26       }
27     }
28   }
29 }}