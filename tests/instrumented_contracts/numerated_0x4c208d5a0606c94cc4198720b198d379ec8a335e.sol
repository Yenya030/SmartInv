1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/mutytes/Mutytes.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * #######################################   ######################################\n * #####################################       ####################################\n * ###################################           ##################################\n * #################################               ################################\n * ################################################################################\n * ################################################################################\n * ################       ####                           ###        ###############\n * ################      ####        #############        ####      ###############\n * ################     ####          ###########          ####     ###############\n * ################    ###     ##       #######       ##    ####    ###############\n * ################  ####    ######      #####      ######    ####  ###############\n * ################ ####                                       #### ###############\n * ####################                #########                ###################\n * ################                     #######                     ###############\n * ################   ###############             ##############   ################\n * #################   #############               ############   #################\n * ###################   ##########                 ##########   ##################\n * ####################    #######                   #######    ###################\n * ######################     ###                     ###    ######################\n * ##########################                             #########################\n * #############################                       ############################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n * ################################################################################\n *\n * The Mutytes have invaded Ethernia! We hereby extend access to the lab and its\n * facilities to any individual or party that may locate and retrieve a Mutyte sample.\n * We believe their mutated Bit Signatures hold the key to unraveling great mysteries.\n * Join our efforts in capturing and understanding these creatures!\n *\n * - For Ethernia!\n *\n * Founders: @tuyumoo & @nftyte\n */\n\nimport { MutytesTokenProxy } from \"./token/MutytesTokenProxy.sol\";\nimport { SafeOwnableProxy } from \"../core/access/ownable/safe/SafeOwnableProxy.sol\";\nimport { ProxyFacetedController as ProxyFaceted } from \"../core/proxy/faceted/ProxyFacetedController.sol\";\nimport { Proxy } from \"../core/proxy/Proxy.sol\";\n\ncontract Mutytes is MutytesTokenProxy, SafeOwnableProxy, ProxyFaceted, Proxy {\n    constructor(address init, bytes memory data) {\n        MutytesToken_();\n        Ownable_();\n        Proxy_(init, data);\n    }\n}\n"
6     },
7     "contracts/mutytes/token/MutytesTokenProxy.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IMutytesToken } from \"./IMutytesToken.sol\";\nimport { MutytesTokenController } from \"./MutytesTokenController.sol\";\nimport { ERC165Proxy } from \"../../core/introspection/ERC165Proxy.sol\";\nimport { ERC721Proxy } from \"../../core/token/ERC721/ERC721Proxy.sol\";\nimport { ERC721MetadataProxy } from \"../../core/token/ERC721/metadata/ERC721MetadataProxy.sol\";\nimport { ERC721EnumerableProxy } from \"../../core/token/ERC721/enumerable/ERC721EnumerableProxy.sol\";\nimport { ERC721MintableProxy } from \"../../core/token/ERC721/mintable/ERC721MintableProxy.sol\";\nimport { ERC721MintableController, ERC721MintableModel } from \"../../core/token/ERC721/mintable/ERC721MintableController.sol\";\nimport { ERC721BurnableProxy, ERC721BurnableController } from \"../../core/token/ERC721/burnable/ERC721BurnableProxy.sol\";\n\n/**\n * @title Mutytes token implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract MutytesTokenProxy is\n    IMutytesToken,\n    ERC165Proxy,\n    ERC721Proxy,\n    ERC721MetadataProxy,\n    ERC721EnumerableProxy,\n    ERC721MintableProxy,\n    ERC721BurnableProxy,\n    MutytesTokenController\n{\n    /**\n     * @inheritdoc IMutytesToken\n     */\n    function availableSupply() external virtual upgradable returns (uint256) {\n        return _availableSupply();\n    }\n\n    /**\n     * @inheritdoc IMutytesToken\n     */\n    function mintBalanceOf(address owner) external virtual upgradable returns (uint256) {\n        return mintBalanceOf_(owner);\n    }\n\n    function _burn_(address owner, uint256 tokenId)\n        internal\n        virtual\n        override(ERC721BurnableController, MutytesTokenController)\n    {\n        super._burn_(owner, tokenId);\n    }\n\n    function _maxMintBalance()\n        internal\n        pure\n        virtual\n        override(ERC721MintableModel, MutytesTokenController)\n        returns (uint256)\n    {\n        return super._maxMintBalance();\n    }\n}\n"
9     },
10     "contracts/core/access/ownable/safe/SafeOwnableProxy.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISafeOwnable } from \"./ISafeOwnable.sol\";\nimport { SafeOwnableController } from \"./SafeOwnableController.sol\";\nimport { OwnableProxy, IERC173 } from \"../OwnableProxy.sol\";\n\n/**\n * @title ERC173 safe ownership access control implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract SafeOwnableProxy is ISafeOwnable, OwnableProxy, SafeOwnableController {\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function nomineeOwner() external virtual upgradable returns (address) {\n        return nomineeOwner_();\n    }\n\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function acceptOwnership() external virtual upgradable onlyNomineeOwner {\n        acceptOwnership_();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address newOwner)\n        external\n        virtual\n        override(IERC173, OwnableProxy)\n        upgradable\n        onlyOwner\n    {\n        _setNomineeOwner(newOwner);\n    }\n}\n"
12     },
13     "contracts/core/proxy/faceted/ProxyFacetedController.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ProxyFacetedModel } from \"./ProxyFacetedModel.sol\";\nimport { ProxyController } from \"../ProxyController.sol\";\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\n\nabstract contract ProxyFacetedController is ProxyFacetedModel, ProxyController {\n    using AddressUtils for address;\n\n    function implementation_() internal view virtual override returns (address) {\n        return implementation_(msg.sig);\n    }\n\n    function implementation_(bytes4 selector)\n        internal\n        view\n        virtual\n        returns (address implementation)\n    {\n        implementation = _implementation(selector);\n        implementation.enforceIsNotZeroAddress();\n    }\n\n    function addFunctions_(\n        bytes4[] memory selectors,\n        address implementation,\n        bool isUpgradable\n    ) internal virtual {\n        _enforceCanAddFunctions(implementation);\n\n        unchecked {\n            for (uint256 i; i < selectors.length; i++) {\n                bytes4 selector = selectors[i];\n                _enforceCanAddFunction(selector, implementation);\n                _addFunction_(selector, implementation, isUpgradable);\n            }\n        }\n    }\n\n    function addFunction_(\n        bytes4 selector,\n        address implementation,\n        bool isUpgradable\n    ) internal virtual {\n        _enforceCanAddFunctions(implementation);\n        _enforceCanAddFunction(selector, implementation);\n        _addFunction_(selector, implementation, isUpgradable);\n    }\n\n    function replaceFunctions_(bytes4[] memory selectors, address implementation)\n        internal\n        virtual\n    {\n        _enforceCanAddFunctions(implementation);\n\n        unchecked {\n            for (uint256 i; i < selectors.length; i++) {\n                bytes4 selector = selectors[i];\n                _enforceCanReplaceFunction(selector, implementation);\n                _replaceFunction_(selector, implementation);\n            }\n        }\n    }\n\n    function replaceFunction_(bytes4 selector, address implementation) internal virtual {\n        _enforceCanAddFunctions(implementation);\n        _enforceCanReplaceFunction(selector, implementation);\n        _replaceFunction_(selector, implementation);\n    }\n\n    function removeFunctions_(bytes4[] memory selectors) internal virtual {\n        unchecked {\n            for (uint256 i; i < selectors.length; i++) {\n                removeFunction_(selectors[i]);\n            }\n        }\n    }\n\n    function removeFunction_(bytes4 selector) internal virtual {\n        address implementation = _implementation(selector);\n        _enforceCanRemoveFunction(selector, implementation);\n        _removeFunction_(selector, implementation);\n    }\n\n    function setUpgradableFunctions_(bytes4[] memory selectors, bool isUpgradable)\n        internal\n        virtual\n    {\n        unchecked {\n            for (uint256 i; i < selectors.length; i++) {\n                setUpgradableFunction_(selectors[i], isUpgradable);\n            }\n        }\n    }\n\n    function setUpgradableFunction_(bytes4 selector, bool isUpgradable) internal virtual {\n        _implementation(selector).enforceIsNotZeroAddress();\n        _setUpgradableFunction(selector, isUpgradable);\n    }\n\n    function _addFunction_(\n        bytes4 selector,\n        address implementation,\n        bool isUpgradable\n    ) internal virtual {\n        _addFunction(selector, implementation, isUpgradable);\n        _afterAddFunction(implementation);\n    }\n\n    function _replaceFunction_(bytes4 selector, address implementation) internal virtual {\n        address oldImplementation = _implementation(selector);\n        _replaceFunction(selector, implementation);\n        _afterRemoveFunction(oldImplementation);\n        _afterAddFunction(implementation);\n    }\n\n    function _removeFunction_(bytes4 selector, address implementation) internal virtual {\n        _removeFunction(selector);\n        _afterRemoveFunction(implementation);\n    }\n\n    function _enforceCanAddFunctions(address implementation) internal view virtual {\n        if (implementation != address(this)) {\n            implementation.enforceIsContract();\n        }\n    }\n\n    function _enforceCanAddFunction(bytes4 selector, address) internal view virtual {\n        _implementation(selector).enforceIsZeroAddress();\n    }\n\n    function _enforceCanReplaceFunction(bytes4 selector, address implementation)\n        internal\n        view\n        virtual\n    {\n        address oldImplementation = _implementation(selector);\n        oldImplementation.enforceNotEquals(implementation);\n        _enforceCanRemoveFunction(selector, oldImplementation);\n    }\n\n    function _enforceCanRemoveFunction(bytes4 selector, address implementation)\n        internal\n        view\n        virtual\n    {\n        implementation.enforceIsNotZeroAddress();\n\n        if (!_isUpgradable(selector)) {\n            implementation.enforceNotEquals(address(this));\n        }\n    }\n}\n"
15     },
16     "contracts/core/proxy/Proxy.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ProxyController } from \"./ProxyController.sol\";\n\n/**\n * @title Proxy delegatecall fallback implementation\n */\nabstract contract Proxy is ProxyController {\n    fallback() external payable virtual {\n        fallback_();\n    }\n\n    receive() external payable virtual {\n        fallback_();\n    }\n}\n"
18     },
19     "contracts/mutytes/token/IMutytesToken.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"../../core/introspection/IERC165.sol\";\nimport { IERC721 } from \"../../core/token/ERC721/IERC721.sol\";\nimport { IERC721Metadata } from \"../../core/token/ERC721/metadata/IERC721Metadata.sol\";\nimport { IERC721Enumerable } from \"../../core/token/ERC721/enumerable/IERC721Enumerable.sol\";\nimport { IERC721Mintable } from \"../../core/token/ERC721/mintable/IERC721Mintable.sol\";\nimport { IERC721Burnable } from \"../../core/token/ERC721/burnable/IERC721Burnable.sol\";\n\n/**\n * @title Mutytes token interface\n */\ninterface IMutytesToken is\n    IERC721Burnable,\n    IERC721Mintable,\n    IERC721Enumerable,\n    IERC721Metadata,\n    IERC721,\n    IERC165\n{\n    /**\n     * @notice Get the available supply\n     * @return supply The available supply amount\n     */\n    function availableSupply() external returns (uint256);\n\n    /**\n     * @notice Get the amount of tokens minted by an owner\n     * @param owner The owner's address\n     * @return balance The balance amount\n     */\n    function mintBalanceOf(address owner) external returns (uint256);\n}\n"
21     },
22     "contracts/mutytes/token/MutytesTokenController.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721MetadataController } from \"../../core/token/ERC721/metadata/ERC721MetadataController.sol\";\nimport { ERC721MintableController } from \"../../core/token/ERC721/mintable/ERC721MintableController.sol\";\nimport { ERC721BurnableController } from \"../../core/token/ERC721/burnable/ERC721BurnableController.sol\";\nimport { IntegerUtils } from \"../../core/utils/IntegerUtils.sol\";\n\nabstract contract MutytesTokenController is\n    ERC721BurnableController,\n    ERC721MintableController,\n    ERC721MetadataController\n{\n    using IntegerUtils for uint256;\n\n    function MutytesToken_() internal virtual {\n        ERC721Metadata_(\"Mutytes\", \"TYTE\");\n    }\n\n    function _burn_(address owner, uint256 tokenId) internal virtual override {\n        if (_tokenURIProvider(tokenId) != 0) {\n            _setTokenURIProvider(tokenId, 0);\n        }\n\n        super._burn_(owner, tokenId);\n    }\n\n    function _maxMintBalance() internal pure virtual override returns (uint256) {\n        return 10;\n    }\n}\n"
24     },
25     "contracts/core/introspection/ERC165Proxy.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from \"./IERC165.sol\";\nimport { ERC165Controller } from \"./ERC165Controller.sol\";\nimport { ProxyUpgradableController } from \"../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC165 implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC165Proxy is IERC165, ERC165Controller, ProxyUpgradableController {\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        virtual\n        upgradable\n        returns (bool)\n    {\n        return supportsInterface_(interfaceId);\n    }\n}\n"
27     },
28     "contracts/core/token/ERC721/ERC721Proxy.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721 } from \"./IERC721.sol\";\nimport { ERC721Controller } from \"./ERC721Controller.sol\";\nimport { ProxyUpgradableController } from \"../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC721 implementation, excluding optional extensions\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC721Proxy is IERC721, ERC721Controller, ProxyUpgradableController {\n    /**\n     * @inheritdoc IERC721\n     */\n    function balanceOf(address owner) external virtual upgradable returns (uint256) {\n        return balanceOf_(owner);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function ownerOf(uint256 tokenId) external virtual upgradable returns (address) {\n        return ownerOf_(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external virtual upgradable {\n        safeTransferFrom_(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual upgradable {\n        safeTransferFrom_(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual upgradable {\n        transferFrom_(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function approve(address to, uint256 tokenId) external virtual upgradable {\n        approve_(to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function setApprovalForAll(address operator, bool approved)\n        external\n        virtual\n        upgradable\n    {\n        setApprovalForAll_(operator, approved);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) external virtual upgradable returns (address) {\n        return getApproved_(tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        virtual\n        upgradable\n        returns (bool)\n    {\n        return isApprovedForAll_(owner, operator);\n    }\n}\n"
30     },
31     "contracts/core/token/ERC721/metadata/ERC721MetadataProxy.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Metadata } from \"./IERC721Metadata.sol\";\nimport { ERC721MetadataController } from \"./ERC721MetadataController.sol\";\nimport { ERC721TokenURIProxyController } from \"../tokenURI/ERC721TokenURIProxyController.sol\";\nimport { ProxyUpgradableController } from \"../../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC721 metadata extension implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC721MetadataProxy is\n    IERC721Metadata,\n    ERC721MetadataController,\n    ERC721TokenURIProxyController,\n    ProxyUpgradableController\n{\n    /**\n     * @inheritdoc IERC721Metadata\n     */\n    function name() external virtual upgradable returns (string memory) {\n        return name_();\n    }\n\n    /**\n     * @inheritdoc IERC721Metadata\n     */\n    function symbol() external virtual upgradable returns (string memory) {\n        return symbol_();\n    }\n\n    /**\n     * @inheritdoc IERC721Metadata\n     */\n    function tokenURI(uint256 tokenId)\n        external\n        virtual\n        upgradable\n        returns (string memory)\n    {\n        return tokenURIProxyable_(tokenId);\n    }\n}\n"
33     },
34     "contracts/core/token/ERC721/enumerable/ERC721EnumerableProxy.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Enumerable } from \"./IERC721Enumerable.sol\";\nimport { ERC721EnumerableController } from \"./ERC721EnumerableController.sol\";\nimport { ProxyUpgradableController } from \"../../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC721 enumerable extension implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC721EnumerableProxy is\n    IERC721Enumerable,\n    ERC721EnumerableController,\n    ProxyUpgradableController\n{\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function totalSupply() external virtual upgradable returns (uint256) {\n        return totalSupply_();\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenByIndex(uint256 index) external virtual upgradable returns (uint256) {\n        return tokenByIndex_(index);\n    }\n\n    /**\n     * @inheritdoc IERC721Enumerable\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        virtual\n        upgradable\n        returns (uint256)\n    {\n        return tokenOfOwnerByIndex_(owner, index);\n    }\n}\n"
36     },
37     "contracts/core/token/ERC721/mintable/ERC721MintableProxy.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Mintable } from \"./IERC721Mintable.sol\";\nimport { ERC721MintableController } from \"./ERC721MintableController.sol\";\nimport { ProxyUpgradableController } from \"../../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC721 token minting extension implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC721MintableProxy is\n    IERC721Mintable,\n    ERC721MintableController,\n    ProxyUpgradableController\n{\n    /**\n     * @inheritdoc IERC721Mintable\n     */\n    function mint(uint256 amount) external payable virtual override upgradable {\n        mint_(amount);\n    }\n}\n"
39     },
40     "contracts/core/token/ERC721/mintable/ERC721MintableController.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721MintableController } from \"./IERC721MintableController.sol\";\nimport { ERC721MintableModel } from \"./ERC721MintableModel.sol\";\nimport { ERC721SupplyController } from \"../supply/ERC721SupplyController.sol\";\nimport { ERC721TokenUtils } from \"../utils/ERC721TokenUtils.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\nimport { IntegerUtils } from \"../../../utils/IntegerUtils.sol\";\n\nabstract contract ERC721MintableController is\n    IERC721MintableController,\n    ERC721MintableModel,\n    ERC721SupplyController\n{\n    using ERC721TokenUtils for address;\n    using AddressUtils for address;\n    using IntegerUtils for uint256;\n\n    function mintBalanceOf_(address owner) internal view virtual returns (uint256) {\n        owner.enforceIsNotZeroAddress();\n        return _mintBalanceOf(owner);\n    }\n\n    function mint_(uint256 amount) internal virtual {\n        _enforceCanMint(amount);\n        (uint256 tokenId, uint256 maxTokenId) = _mint_(msg.sender, amount);\n\n        unchecked {\n            while (tokenId < maxTokenId) {\n                emit Transfer(address(0), msg.sender, tokenId++);\n            }\n        }\n    }\n\n    function _mint_(address to, uint256 amount)\n        internal\n        virtual\n        returns (uint256 tokenId, uint256 maxTokenId)\n    {\n        tokenId = to.toTokenId() | _mintBalanceOf(to);\n        maxTokenId = tokenId + amount;\n        _mint(to, amount);\n        _updateAvailableSupply(amount);\n    }\n\n    function _mintValue() internal view virtual returns (uint256) {\n        return 0 ether;\n    }\n\n    function _mintedSupply() internal view virtual returns (uint256) {\n        return _initialSupply() - _availableSupply();\n    }\n\n    function _enforceCanMint(uint256 amount) internal view virtual {\n        amount.enforceIsNotZero();\n        amount.enforceNotGreaterThan(_availableSupply());\n        msg.value.enforceEquals(amount * _mintValue());\n        (_mintBalanceOf(msg.sender) + amount).enforceNotGreaterThan(_maxMintBalance());\n    }\n}\n"
42     },
43     "contracts/core/token/ERC721/burnable/ERC721BurnableProxy.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Burnable } from \"./IERC721Burnable.sol\";\nimport { ERC721BurnableController } from \"./ERC721BurnableController.sol\";\nimport { ProxyUpgradableController } from \"../../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC721 token burning extension implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract ERC721BurnableProxy is\n    IERC721Burnable,\n    ERC721BurnableController,\n    ProxyUpgradableController\n{\n    /**\n     * @inheritdoc IERC721Burnable\n     */\n    function burn(uint256 tokenId) external virtual override upgradable {\n        burn_(tokenId);\n    }\n}\n"
45     },
46     "contracts/core/introspection/IERC165.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface\n * @dev See https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice Query whether contract supports an interface\n     * @param interfaceId The interface id\n     * @return isSupported Whether the interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external returns (bool);\n}\n"
48     },
49     "contracts/core/token/ERC721/IERC721.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Controller } from \"./IERC721Controller.sol\";\n\n/**\n * @title ERC721 interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721 is IERC721Controller {\n    /**\n     * @notice Get the balance of an owner\n     * @param owner The owner's address\n     * @return balance The balance amount\n     */\n    function balanceOf(address owner) external returns (uint256);\n\n    /**\n     * @notice Get the owner a token\n     * @param tokenId The token id\n     * @return owner The owner's address\n     */\n    function ownerOf(uint256 tokenId) external returns (address);\n\n    /**\n     * @notice Transfer a token between addresses\n     * @dev Preforms ERC721Receiver check if applicable\n     * @param from The token's owner address\n     * @param to The recipient address\n     * @param tokenId The token id\n     * @param data Additional data\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @notice Transfer a token between addresses\n     * @dev Preforms ERC721Receiver check if applicable\n     * @param from The token's owner address\n     * @param to The recipient address\n     * @param tokenId The token id\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @notice Transfer a token between addresses\n     * @param from The token's owner address\n     * @param to The recipient address\n     * @param tokenId The token id\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @notice Grant approval to a token\n     * @param approved The address to approve\n     * @param tokenId The token id\n     */\n    function approve(address approved, uint256 tokenId) external;\n\n    /**\n     * @notice Set operator approval\n     * @param operator The operator's address\n     * @param approved Whether to grant approval\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @notice Get the approved address of a token\n     * @param tokenId The token id\n     * @return approved The approved address\n     */\n    function getApproved(uint256 tokenId) external returns (address);\n\n    /**\n     * @notice Query whether the operator is approved for an address\n     * @param owner The address to query\n     * @param operator The operator's address\n     * @return isApproved Whether the operator is approved\n     */\n    function isApprovedForAll(address owner, address operator) external returns (bool);\n}\n"
51     },
52     "contracts/core/token/ERC721/metadata/IERC721Metadata.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 metadata extension interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata {\n    /**\n     * @notice Get the token name\n     * @return name The token name\n     */\n    function name() external returns (string memory);\n\n    /**\n     * @notice Get the token symbol\n     * @return symbol The token symbol\n     */\n    function symbol() external returns (string memory);\n\n    /**\n     * @notice Get the URI of a token\n     * @param tokenId The token id\n     * @return tokenURI The token URI\n     */\n    function tokenURI(uint256 tokenId) external returns (string memory);\n}\n"
54     },
55     "contracts/core/token/ERC721/enumerable/IERC721Enumerable.sol": {
56       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 enumerable extension interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable {\n    /**\n     * @notice Get the total token supply\n     * @return supply The total supply amount\n     */\n    function totalSupply() external returns (uint256);\n\n    /**\n     * @notice Get a token by global enumeration index\n     * @param index The token position\n     * @return tokenId The token id\n     */\n    function tokenByIndex(uint256 index) external returns (uint256);\n\n    /**\n     * @notice Get an owner's token by enumeration index\n     * @param owner The owner's address\n     * @param index The token position\n     * @return tokenId The token id\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external returns (uint256);\n}\n"
57     },
58     "contracts/core/token/ERC721/mintable/IERC721Mintable.sol": {
59       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721MintableController } from \"./IERC721MintableController.sol\";\n\n/**\n * @title ERC721 token minting extension interface\n */\ninterface IERC721Mintable is IERC721MintableController {\n    /**\n     * @notice Mint new tokens\n     * @param amount The amount to mint\n     */\n    function mint(uint256 amount) external payable;\n}\n"
60     },
61     "contracts/core/token/ERC721/burnable/IERC721Burnable.sol": {
62       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721BurnableController } from \"./IERC721BurnableController.sol\";\n\n/**\n * @title ERC721 token burning extension interface\n */\ninterface IERC721Burnable is IERC721BurnableController {\n    /**\n     * @notice Burn a token\n     * @param tokenId The token id\n     */\n    function burn(uint256 tokenId) external;\n}\n"
63     },
64     "contracts/core/token/ERC721/IERC721Controller.sol": {
65       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721BaseController } from \"./base/IERC721BaseController.sol\";\nimport { IERC721ApprovableController } from \"./approvable/IERC721ApprovableController.sol\";\nimport { IERC721TransferableController } from \"./transferable/IERC721TransferableController.sol\";\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721Controller is\n    IERC721TransferableController,\n    IERC721ApprovableController,\n    IERC721BaseController\n{}\n"
66     },
67     "contracts/core/token/ERC721/base/IERC721BaseController.sol": {
68       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721BaseController {\n    error NonExistentToken(uint256 tokenId);\n}\n"
69     },
70     "contracts/core/token/ERC721/approvable/IERC721ApprovableController.sol": {
71       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721ApprovableController {\n    error UnapprovedTokenAction(uint256 tokenId);\n    \n    error UnapprovedOperatorAction();\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n}\n"
72     },
73     "contracts/core/token/ERC721/transferable/IERC721TransferableController.sol": {
74       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721TransferableController {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n}\n"
75     },
76     "contracts/core/token/ERC721/mintable/IERC721MintableController.sol": {
77       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721TransferableController } from \"../transferable/IERC721TransferableController.sol\";\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721MintableController is IERC721TransferableController {}\n"
78     },
79     "contracts/core/token/ERC721/burnable/IERC721BurnableController.sol": {
80       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721TransferableController } from \"../transferable/IERC721TransferableController.sol\";\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721BurnableController is IERC721TransferableController {}\n"
81     },
82     "contracts/core/token/ERC721/metadata/ERC721MetadataController.sol": {
83       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721MetadataModel } from \"./ERC721MetadataModel.sol\";\nimport { ERC721TokenURIController } from \"../tokenURI/ERC721TokenURIController.sol\";\n\nabstract contract ERC721MetadataController is\n    ERC721MetadataModel,\n    ERC721TokenURIController\n{\n    function ERC721Metadata_(string memory name, string memory symbol) internal virtual {\n        _setName(name);\n        _setSymbol(symbol);\n    }\n\n    function name_() internal view virtual returns (string memory) {\n        return _name();\n    }\n\n    function symbol_() internal view virtual returns (string memory) {\n        return _symbol();\n    }\n}\n"
84     },
85     "contracts/core/token/ERC721/burnable/ERC721BurnableController.sol": {
86       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721BurnableController } from \"./IERC721BurnableController.sol\";\nimport { ERC721BurnableModel } from \"./ERC721BurnableModel.sol\";\nimport { ERC721SupplyController } from \"../supply/ERC721SupplyController.sol\";\nimport { ERC721ApprovableController } from \"../approvable/ERC721ApprovableController.sol\";\n\nabstract contract ERC721BurnableController is\n    IERC721BurnableController,\n    ERC721BurnableModel,\n    ERC721SupplyController,\n    ERC721ApprovableController\n{\n    function burn_(uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n        _enforceIsApproved(owner, msg.sender, tokenId);\n        _burn_(owner, tokenId);\n    }\n\n    function _burn_(address owner, uint256 tokenId) internal virtual {\n        if (_getApproved(tokenId) != address(0)) {\n            _approve_(owner, address(0), tokenId);\n        }\n\n        _burn(owner, tokenId);\n        _updateMaxSupply(1);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _burnedSupply() internal view virtual returns (uint256) {\n        return _initialSupply() - _maxSupply();\n    }\n}\n"
87     },
88     "contracts/core/utils/IntegerUtils.sol": {
89       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Integer utilities\n */\nlibrary IntegerUtils {\n    error UnexpectedZeroValue();\n    error UnexpectedNonZeroValue();\n    error OutOfBoundsValue(uint256 value, uint256 length);\n    error UnexpectedValue();\n\n    function enforceIsZero(uint256 i) internal pure {\n        if (i == 0) {\n            return;\n        }\n\n        revert UnexpectedNonZeroValue();\n    }\n\n    function enforceIsNotZero(uint256 i) internal pure {\n        if (i == 0) {\n            revert UnexpectedZeroValue();\n        }\n    }\n\n    function enforceLessThan(uint256 a, uint256 b) internal pure {\n        if (a < b) {\n            return;\n        }\n\n        revert OutOfBoundsValue(a, b);\n    }\n\n    function enforceNotLessThan(uint256 a, uint256 b) internal pure {\n        if (a < b) {\n            revert OutOfBoundsValue(b, a);\n        }\n    }\n\n    function enforceGreaterThan(uint256 a, uint256 b) internal pure {\n        if (a > b) {\n            return;\n        }\n\n        revert OutOfBoundsValue(b, a);\n    }\n\n    function enforceNotGreaterThan(uint256 a, uint256 b) internal pure {\n        if (a > b) {\n            revert OutOfBoundsValue(a, b);\n        }\n    }\n    \n    function enforceEquals(uint256 a, uint256 b) internal pure {\n        if (a == b) {\n            return;\n        }\n\n        revert UnexpectedValue();\n    }\n\n    function enforceNotEquals(uint256 a, uint256 b) internal pure {\n        if (a == b) {\n            revert UnexpectedValue();\n        }\n    }\n}\n"
90     },
91     "contracts/core/token/ERC721/metadata/ERC721MetadataModel.sol": {
92       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721MetadataStorage as es } from \"./ERC721MetadataStorage.sol\";\n\nabstract contract ERC721MetadataModel {\n    function _setName(string memory name) internal virtual {\n        es().name = name;\n    }\n\n    function _setSymbol(string memory symbol) internal virtual {\n        es().symbol = symbol;\n    }\n\n    function _name() internal view virtual returns (string memory) {\n        return es().name;\n    }\n\n    function _symbol() internal view virtual returns (string memory) {\n        return es().symbol;\n    }\n}\n"
93     },
94     "contracts/core/token/ERC721/tokenURI/ERC721TokenURIController.sol": {
95       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721TokenURIController } from \"./IERC721TokenURIController.sol\";\nimport { ERC721TokenURIModel } from \"./ERC721TokenURIModel.sol\";\nimport { ERC721BaseController } from \"../base/ERC721BaseController.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\n\nabstract contract ERC721TokenURIController is\n    IERC721TokenURIController,\n    ERC721TokenURIModel,\n    ERC721BaseController\n{\n    using AddressUtils for address;\n\n    function ERC721TokenURI_(\n        uint256 id,\n        address provider,\n        bool isProxyable\n    ) internal virtual {\n        _setTokenURIProviderInfo(id, provider, isProxyable);\n        _setDefaultTokenURIProvider(id);\n    }\n\n    function tokenURI_(uint256 tokenId) internal view virtual returns (string memory) {\n        uint256 providerId = tokenURIProvider_(tokenId);\n        (address provider, bool isProxyable) = _tokenURIProviderInfo(providerId);\n\n        if (isProxyable) {\n            revert UnexpectedTokenURIProvider(providerId);\n        }\n\n        return _tokenURI(tokenId, provider);\n    }\n\n    function tokenURIProvider_(uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (uint256 providerId)\n    {\n        _enforceTokenExists(tokenId);\n        providerId = _tokenURIProvider_(tokenId);\n        (address provider, ) = _tokenURIProviderInfo(providerId);\n        provider.enforceIsNotZeroAddress();\n    }\n\n    function tokenURIProviderInfo_(uint256 providerId)\n        internal\n        view\n        virtual\n        returns (address provider, bool isProxyable)\n    {\n        (provider, isProxyable) = _tokenURIProviderInfo_(providerId);\n        provider.enforceIsNotZeroAddress();\n    }\n\n    function _tokenURIProvider_(uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (uint256 providerId)\n    {\n        providerId = _tokenURIProvider(tokenId);\n        (address provider, ) = _tokenURIProviderInfo(providerId);\n\n        if (provider == address(0)) {\n            providerId = _defaultTokenURIProvider();\n        }\n    }\n\n    function _tokenURIProviderInfo_(uint256 providerId)\n        internal\n        view\n        virtual\n        returns (address provider, bool isProxyable)\n    {\n        (provider, isProxyable) = _tokenURIProviderInfo(providerId);\n\n        if (provider == address(0)) {\n            (provider, isProxyable) = _tokenURIProviderInfo(_defaultTokenURIProvider());\n        }\n    }\n}\n"
96     },
97     "contracts/core/token/ERC721/metadata/ERC721MetadataStorage.sol": {
98       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_METADATA_STORAGE_SLOT = keccak256(\"core.token.erc721.metadata.storage\");\n\nstruct ERC721MetadataStorage {\n    string name;\n    string symbol;\n}\n\nfunction erc721MetadataStorage() pure returns (ERC721MetadataStorage storage es) {\n    bytes32 slot = ERC721_METADATA_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
99     },
100     "contracts/core/token/ERC721/tokenURI/IERC721TokenURIController.sol": {
101       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC721 interface required by controller functions\n */\ninterface IERC721TokenURIController {\n    error UnexpectedTokenURIProvider(uint256 providerId);\n}\n"
102     },
103     "contracts/core/token/ERC721/tokenURI/ERC721TokenURIModel.sol": {
104       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721TokenURIProvider } from \"./IERC721TokenURIProvider.sol\";\nimport { erc721TokenURIStorage as es, ProviderInfo } from \"./ERC721TokenURIStorage.sol\";\n\nabstract contract ERC721TokenURIModel {\n    function _ERC721TokenURI(\n        uint256 id,\n        address provider,\n        bool isProxyable\n    ) internal virtual {\n        _setTokenURIProviderInfo(id, provider, isProxyable);\n        _setDefaultTokenURIProvider(id);\n    }\n\n    function _tokenURI(uint256 tokenId, address provider)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        return IERC721TokenURIProvider(provider).tokenURI(tokenId);\n    }\n\n    function _setTokenURIProvider(uint256 tokenId, uint256 providerId) internal virtual {\n        es().tokenURIProviders[tokenId] = providerId;\n    }\n\n    function _setTokenURIProviderInfo(\n        uint256 providerId,\n        address providerAddress,\n        bool isProxyable\n    ) internal virtual {\n        es().providerInfo[providerId] = ProviderInfo(isProxyable, providerAddress);\n    }\n\n    function _setDefaultTokenURIProvider(uint256 providerId) internal virtual {\n        es().defaultProvider = providerId;\n    }\n\n    function _tokenURIProvider(uint256 tokenId) internal view virtual returns (uint256) {\n        return es().tokenURIProviders[tokenId];\n    }\n\n    function _tokenURIProviderInfo(uint256 providerId)\n        internal\n        view\n        virtual\n        returns (address, bool)\n    {\n        ProviderInfo memory providerInfo = es().providerInfo[providerId];\n        return (providerInfo.providerAddress, providerInfo.isProxyable);\n    }\n\n    function _defaultTokenURIProvider() internal view virtual returns (uint256) {\n        return es().defaultProvider;\n    }\n}\n"
105     },
106     "contracts/core/token/ERC721/base/ERC721BaseController.sol": {
107       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721BaseController } from \"./IERC721BaseController.sol\";\nimport { ERC721BaseModel } from \"./ERC721BaseModel.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\n\nabstract contract ERC721BaseController is IERC721BaseController, ERC721BaseModel {\n    using AddressUtils for address;\n\n    function balanceOf_(address owner) internal view virtual returns (uint256) {\n        owner.enforceIsNotZeroAddress();\n        return _balanceOf(owner);\n    }\n\n    function ownerOf_(uint256 tokenId) internal view virtual returns (address owner) {\n        owner = _ownerOf(tokenId);\n        owner.enforceIsNotZeroAddress();\n    }\n\n    function _enforceTokenExists(uint256 tokenId) internal view virtual {\n        if (!_tokenExists(tokenId)) {\n            revert NonExistentToken(tokenId);\n        }\n    }\n}\n"
108     },
109     "contracts/core/utils/AddressUtils.sol": {
110       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Address utilities\n */\nlibrary AddressUtils {\n    error UnexpectedContractAddress();\n    error UnexpectedNonContractAddress();\n    error UnexpectedZeroAddress();\n    error UnexpectedNonZeroAddress();\n    error UnexpectedAddress();\n\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n\n    function enforceIsContract(address account) internal view {\n        if (isContract(account)) {\n            return;\n        }\n\n        revert UnexpectedNonContractAddress();\n    }\n\n    function enforceIsNotContract(address account) internal view {\n        if (isContract(account)) {\n            revert UnexpectedContractAddress();\n        }\n    }\n\n    function enforceIsZeroAddress(address account) internal pure {\n        if (account == address(0)) {\n            return;\n        }\n\n        revert UnexpectedNonZeroAddress();\n    }\n\n    function enforceIsNotZeroAddress(address account) internal pure {\n        if (account == address(0)) {\n            revert UnexpectedZeroAddress();\n        }\n    }\n\n    function enforceEquals(address a, address b) internal pure {\n        if (a == b) {\n            return;\n        }\n\n        revert UnexpectedAddress();\n    }\n\n    function enforceNotEquals(address a, address b) internal pure {\n        if (a == b) {\n            revert UnexpectedAddress();\n        }\n    }\n}\n"
111     },
112     "contracts/core/token/ERC721/tokenURI/IERC721TokenURIProvider.sol": {
113       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token URI provider interface\n */\ninterface IERC721TokenURIProvider {\n    /**\n     * @notice Get the URI of a token\n     * @param tokenId The token id\n     * @return tokenURI The token URI\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
114     },
115     "contracts/core/token/ERC721/tokenURI/ERC721TokenURIStorage.sol": {
116       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_TOKEN_URI_STORAGE_SLOT = keccak256(\"core.token.erc721.tokenURI.storage\");\n\nstruct ProviderInfo {\n    bool isProxyable;\n    address providerAddress;\n}\n\nstruct ERC721TokenURIStorage {\n    uint256 defaultProvider;\n    mapping(uint256 => uint256) tokenURIProviders;\n    mapping(uint256 => ProviderInfo) providerInfo;\n}\n\nfunction erc721TokenURIStorage() pure returns (ERC721TokenURIStorage storage es) {\n    bytes32 slot = ERC721_TOKEN_URI_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
117     },
118     "contracts/core/token/ERC721/base/ERC721BaseModel.sol": {
119       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721BaseStorage, ERC721BaseStorage } from \"./ERC721BaseStorage.sol\";\nimport { ERC721TokenUtils } from \"../utils/ERC721TokenUtils.sol\";\nimport { ERC721InventoryUtils } from \"../utils/ERC721InventoryUtils.sol\";\n\nabstract contract ERC721BaseModel {\n    using ERC721TokenUtils for uint256;\n    using ERC721InventoryUtils for uint256;\n    \n    function _balanceOf(address owner) internal view virtual returns (uint256) {\n        return erc721BaseStorage().inventories[owner].balance();\n    }\n    \n    function _ownerOf(uint256 tokenId) internal view virtual returns (address owner) {\n        ERC721BaseStorage storage es = erc721BaseStorage();\n        owner = es.owners[tokenId];\n\n        if (owner == address(0)) {\n            address holder = tokenId.holder();\n            if (es.inventories[holder].has(tokenId.index())) {\n                owner = holder;\n            }\n        }\n    }\n\n    function _tokenExists(uint256 tokenId) internal view virtual returns (bool) {\n        ERC721BaseStorage storage es = erc721BaseStorage();\n\n        if (es.owners[tokenId] == address(0)) {\n            return es.inventories[tokenId.holder()].has(tokenId.index());\n        }\n        \n        return true;\n    }\n}\n"
120     },
121     "contracts/core/token/ERC721/base/ERC721BaseStorage.sol": {
122       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_BASE_STORAGE_SLOT = keccak256(\"core.token.erc721.base.storage\");\n\nstruct ERC721BaseStorage {\n    mapping(uint256 => address) owners;\n    mapping(address => uint256) inventories;\n}\n\nfunction erc721BaseStorage() pure returns (ERC721BaseStorage storage es) {\n    bytes32 slot = ERC721_BASE_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
123     },
124     "contracts/core/token/ERC721/utils/ERC721TokenUtils.sol": {
125       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token utilities\n */\nlibrary ERC721TokenUtils {\n    uint256 constant HOLDER_OFFSET = 8;\n    uint256 constant INDEX_BITMASK = (1 << HOLDER_OFFSET) - 1; // = 0xFF\n\n    function toTokenId(address owner) internal pure returns (uint256) {\n        return uint256(uint160(owner)) << HOLDER_OFFSET;\n    }\n\n    function index(uint256 tokenId) internal pure returns (uint256) {\n        return tokenId & INDEX_BITMASK;\n    }\n\n    function holder(uint256 tokenId) internal pure returns (address) {\n        return address(uint160(tokenId >> HOLDER_OFFSET));\n    }\n}\n"
126     },
127     "contracts/core/token/ERC721/utils/ERC721InventoryUtils.sol": {
128       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { BitmapUtils } from \"../../../utils/BitmapUtils.sol\";\n\n/**\n * @title ERC721 token inventory utilities\n */\nlibrary ERC721InventoryUtils {\n    using BitmapUtils for uint256;\n\n    uint256 constant BALANCE_BITSIZE = 16;\n    uint256 constant BALANCE_BITMASK = (1 << BALANCE_BITSIZE) - 1;              // = 0xFFFF;\n    uint256 constant CURRENT_SLOT_BITSIZE = 8;\n    uint256 constant CURRENT_SLOT_BITMASK = (1 << CURRENT_SLOT_BITSIZE) - 1;    // = 0xFF;\n    uint256 constant BITMAP_OFFSET = BALANCE_BITSIZE + CURRENT_SLOT_BITSIZE;    // = 24\n    uint256 constant SLOTS_PER_INVENTORY = 256 - BITMAP_OFFSET;                 // = 232\n\n    function balance(uint256 inventory) internal pure returns (uint256) {\n        return inventory & BALANCE_BITMASK;\n    }\n\n    function current(uint256 inventory) internal pure returns (uint256) {\n        return (inventory >> BALANCE_BITSIZE) & CURRENT_SLOT_BITMASK;\n    }\n\n    function has(uint256 inventory, uint256 index) internal pure returns (bool) {\n        return inventory.isSet(BITMAP_OFFSET + index);\n    }\n\n    function add(uint256 inventory, uint256 amount) internal pure returns (uint256) {\n        return\n            inventory.setRange(BITMAP_OFFSET + current(inventory), amount) +\n            (amount << BALANCE_BITSIZE) +\n            amount;\n    }\n\n    function remove(uint256 inventory, uint256 index) internal pure returns (uint256) {\n        return inventory.unset(BITMAP_OFFSET + index) - 1;\n    }\n}\n"
129     },
130     "contracts/core/utils/BitmapUtils.sol": {
131       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Bitmap utilities\n */\nlibrary BitmapUtils {\n    function get(uint256 bitmap, uint256 index) internal pure returns (uint256) {\n        return (bitmap >> index) & 1;\n    }\n\n    function isSet(uint256 bitmap, uint256 index) internal pure returns (bool) {\n        return get(bitmap, index) == 1;\n    }\n\n    function set(uint256 bitmap, uint256 index) internal pure returns (uint256) {\n        return bitmap | (1 << index);\n    }\n\n    function setRange(uint256 bitmap, uint256 offset, uint256 amount) internal pure returns (uint256) {\n        return bitmap | (((1 << amount) - 1) << offset);\n    }\n\n    function unset(uint256 bitmap, uint256 index) internal pure returns (uint256) {\n        return bitmap & toggle(type(uint256).max, index);\n    }\n    \n    function unsetRange(uint256 bitmap, uint256 offset, uint256 amount) internal pure returns (uint256) {\n        return bitmap & toggleRange(type(uint256).max, offset, amount);\n    }\n\n    function toggle(uint256 bitmap, uint256 index) internal pure returns (uint256) {\n        return bitmap ^ (1 << index);\n    }\n\n    function toggleRange(uint256 bitmap, uint256 offset, uint256 amount) internal pure returns (uint256) {\n        return bitmap ^ (((1 << amount) - 1) << offset);\n    }\n}\n"
132     },
133     "contracts/core/token/ERC721/mintable/ERC721MintableModel.sol": {
134       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721BaseStorage, ERC721BaseStorage } from \"../base/ERC721BaseStorage.sol\";\nimport { ERC721InventoryUtils } from \"../utils/ERC721InventoryUtils.sol\";\n\nabstract contract ERC721MintableModel {\n    using ERC721InventoryUtils for uint256;\n\n    function _maxMintBalance() internal view virtual returns (uint256) {\n        return ERC721InventoryUtils.SLOTS_PER_INVENTORY;\n    }\n\n    function _mintBalanceOf(address owner) internal view virtual returns (uint256) {\n        return erc721BaseStorage().inventories[owner].current();\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        ERC721BaseStorage storage es = erc721BaseStorage();\n        es.inventories[to] = es.inventories[to].add(amount);\n    }\n}\n"
135     },
136     "contracts/core/token/ERC721/supply/ERC721SupplyController.sol": {
137       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721SupplyModel } from \"./ERC721SupplyModel.sol\";\n\nabstract contract ERC721SupplyController is ERC721SupplyModel {\n    function ERC721Supply_(uint256 supply) internal virtual {\n        _setInitialSupply(supply);\n        _setMaxSupply(supply);\n        _setAvailableSupply(supply);\n    }\n\n    function _updateSupply(uint256 supply) internal virtual {\n        _setInitialSupply(_initialSupply() + supply);\n        _setMaxSupply(_maxSupply() + supply);\n        _setAvailableSupply(_availableSupply() + supply);\n    }\n}\n"
138     },
139     "contracts/core/token/ERC721/supply/ERC721SupplyModel.sol": {
140       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721SupplyStorage as es } from \"./ERC721SupplyStorage.sol\";\n\nabstract contract ERC721SupplyModel {\n    function _initialSupply() internal view virtual returns (uint256) {\n        return es().initialSupply;\n    }\n\n    function _maxSupply() internal view virtual returns (uint256) {\n        return es().maxSupply;\n    }\n\n    function _availableSupply() internal view virtual returns (uint256) {\n        return es().availableSupply;\n    }\n\n    function _setInitialSupply(uint256 supply) internal virtual {\n        es().initialSupply = supply;\n    }\n\n    function _setMaxSupply(uint256 supply) internal virtual {\n        es().maxSupply = supply;\n    }\n\n    function _setAvailableSupply(uint256 supply) internal virtual {\n        es().availableSupply = supply;\n    }\n\n    function _updateInitialSupply(uint256 amount) internal virtual {\n        es().initialSupply -= amount;\n    }\n\n    function _updateMaxSupply(uint256 amount) internal virtual {\n        es().maxSupply -= amount;\n    }\n\n    function _updateAvailableSupply(uint256 amount) internal virtual {\n        es().availableSupply -= amount;\n    }\n}\n"
141     },
142     "contracts/core/token/ERC721/supply/ERC721SupplyStorage.sol": {
143       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_SUPPLY_STORAGE_SLOT = keccak256(\n    \"core.token.erc721.supply.storage\"\n);\n\nstruct ERC721SupplyStorage {\n    uint256 initialSupply;\n    uint256 maxSupply;\n    uint256 availableSupply;\n}\n\nfunction erc721SupplyStorage() pure returns (ERC721SupplyStorage storage es) {\n    bytes32 slot = ERC721_SUPPLY_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
144     },
145     "contracts/core/token/ERC721/burnable/ERC721BurnableModel.sol": {
146       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721BaseStorage, ERC721BaseStorage } from \"../base/ERC721BaseStorage.sol\";\nimport { ERC721TokenUtils } from \"../utils/ERC721TokenUtils.sol\";\nimport { ERC721InventoryUtils } from \"../utils/ERC721InventoryUtils.sol\";\n\nabstract contract ERC721BurnableModel {\n    using ERC721TokenUtils for uint256;\n    using ERC721InventoryUtils for uint256;\n\n    function _burn(address owner, uint256 tokenId) internal virtual {\n        ERC721BaseStorage storage es = erc721BaseStorage();\n\n        if (es.owners[tokenId] == owner) {\n            delete es.owners[tokenId];\n            es.inventories[owner]--;\n        } else {\n            es.inventories[owner] = es.inventories[owner].remove(\n                tokenId.index()\n            );\n        }\n    }\n}\n"
147     },
148     "contracts/core/token/ERC721/approvable/ERC721ApprovableController.sol": {
149       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721ApprovableController } from \"./IERC721ApprovableController.sol\";\nimport { ERC721ApprovableModel } from \"./ERC721ApprovableModel.sol\";\nimport { ERC721BaseController } from \"../base/ERC721BaseController.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\n\nabstract contract ERC721ApprovableController is\n    IERC721ApprovableController,\n    ERC721ApprovableModel,\n    ERC721BaseController\n{\n    using AddressUtils for address;\n\n    function approve_(address approved, uint256 tokenId) internal virtual {\n        address owner = _ownerOf(tokenId);\n        owner.enforceNotEquals(approved);\n        _enforceIsApproved(owner, msg.sender);\n        _approve_(owner, approved, tokenId);\n    }\n\n    function setApprovalForAll_(address operator, bool approved) internal virtual {\n        operator.enforceIsNotZeroAddress();\n        operator.enforceNotEquals(msg.sender);\n        _setApprovalForAll_(msg.sender, operator, approved);\n    }\n\n    function getApproved_(uint256 tokenId) internal view virtual returns (address) {\n        _enforceTokenExists(tokenId);\n        return _getApproved(tokenId);\n    }\n\n    function isApprovedForAll_(address owner, address operator)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _isApprovedForAll(owner, operator);\n    }\n\n    function _approve_(\n        address owner,\n        address approved,\n        uint256 tokenId\n    ) internal virtual {\n        _approve(approved, tokenId);\n        emit Approval(owner, approved, tokenId);\n    }\n\n    function _setApprovalForAll_(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        _setApprovalForAll(owner, operator, approved);\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _isApproved(address owner, address operator)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return owner == operator || _isApprovedForAll(owner, operator);\n    }\n\n    function _isApproved(\n        address owner,\n        address operator,\n        uint256 tokenId\n    ) internal view virtual returns (bool) {\n        return _isApproved(owner, operator) || _getApproved(tokenId) == operator;\n    }\n\n    function _enforceIsApproved(address owner, address operator) internal view virtual {\n        if (!_isApproved(owner, operator)) {\n            revert UnapprovedOperatorAction();\n        }\n    }\n\n    function _enforceIsApproved(\n        address owner,\n        address operator,\n        uint256 tokenId\n    ) internal view virtual {\n        if (!_isApproved(owner, operator, tokenId)) {\n            revert UnapprovedTokenAction(tokenId);\n        }\n    }\n}\n"
150     },
151     "contracts/core/token/ERC721/approvable/ERC721ApprovableModel.sol": {
152       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721ApprovableStorage as es } from \"./ERC721ApprovableStorage.sol\";\n\nabstract contract ERC721ApprovableModel {\n    function _approve(address approved, uint256 tokenId) internal virtual {\n        es().tokenApprovals[tokenId] = approved;\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        es().operatorApprovals[owner][operator] = approved;\n    }\n\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return es().tokenApprovals[tokenId];\n    }\n\n    function _isApprovedForAll(address owner, address operator)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return es().operatorApprovals[owner][operator];\n    }\n}\n"
153     },
154     "contracts/core/token/ERC721/approvable/ERC721ApprovableStorage.sol": {
155       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_APPROVABLE_STORAGE_SLOT = keccak256(\"core.token.erc721.approvable.storage\");\n\nstruct ERC721ApprovableStorage {\n    mapping(uint256 => address) tokenApprovals;\n    mapping(address => mapping(address => bool)) operatorApprovals;\n}\n\nfunction erc721ApprovableStorage() pure returns (ERC721ApprovableStorage storage es) {\n    bytes32 slot = ERC721_APPROVABLE_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
156     },
157     "contracts/core/introspection/ERC165Controller.sol": {
158       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC165Model } from \"./ERC165Model.sol\";\n\nabstract contract ERC165Controller is ERC165Model {\n    function supportsInterface_(bytes4 interfaceId) internal view virtual returns (bool) {\n        return _supportsInterface(interfaceId);\n    }\n\n    function _setSupportedInterfaces(bytes4[] memory interfaceIds, bool isSupported)\n        internal\n        virtual\n    {\n        unchecked {\n            for (uint256 i; i < interfaceIds.length; i++) {\n                _setSupportedInterface(interfaceIds[i], isSupported);\n            }\n        }\n    }\n}\n"
159     },
160     "contracts/core/proxy/upgradable/ProxyUpgradableController.sol": {
161       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ProxyController } from \"../ProxyController.sol\";\n\nabstract contract ProxyUpgradableController is ProxyController {\n    modifier upgradable() {\n        address implementation = implementation_();\n        \n         if (implementation == address(this)) {\n            _;\n        } else {\n            _delegate(implementation);\n        }\n    }\n}\n"
162     },
163     "contracts/core/introspection/ERC165Model.sol": {
164       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc165Storage as es } from \"./ERC165Storage.sol\";\n\nabstract contract ERC165Model {\n    function _supportsInterface(bytes4 interfaceId) internal view virtual returns (bool) {\n        return es().supportedInterfaces[interfaceId];\n    }\n\n    function _setSupportedInterface(bytes4 interfaceId, bool isSupported)\n        internal\n        virtual\n    {\n        es().supportedInterfaces[interfaceId] = isSupported;\n    }\n}\n"
165     },
166     "contracts/core/introspection/ERC165Storage.sol": {
167       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC165_STORAGE_SLOT = keccak256(\"core.introspection.erc165.storage\");\n\nstruct ERC165Storage {\n    mapping(bytes4 => bool) supportedInterfaces;\n}\n\nfunction erc165Storage() pure returns (ERC165Storage storage es) {\n    bytes32 slot = ERC165_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
168     },
169     "contracts/core/proxy/ProxyController.sol": {
170       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ProxyModel } from \"./ProxyModel.sol\";\nimport { AddressUtils } from \"../utils/AddressUtils.sol\";\nimport { IntegerUtils } from \"../utils/IntegerUtils.sol\";\n\nabstract contract ProxyController is ProxyModel {\n    using AddressUtils for address;\n    using IntegerUtils for uint256;\n\n    function Proxy_(address init, bytes memory data) internal virtual {\n        data.length.enforceIsNotZero();\n        init.enforceIsContract();\n        _Proxy(init, data);\n    }\n\n    function fallback_() internal virtual {\n        _delegate(implementation_());\n    }\n\n    function implementation_() internal view virtual returns (address);\n}\n"
171     },
172     "contracts/core/proxy/ProxyModel.sol": {
173       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract ProxyModel {\n    function _Proxy(address init, bytes memory data) internal virtual {\n        (bool success, bytes memory reason) = init.delegatecall(data);\n\n        if (!success) {\n            assembly {\n                revert(add(reason, 0x20), mload(reason))\n            }\n        }\n    }\n\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
174     },
175     "contracts/core/token/ERC721/ERC721Controller.sol": {
176       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Controller } from \"./IERC721Controller.sol\";\nimport { ERC721BaseController } from \"./base/ERC721BaseController.sol\";\nimport { ERC721ApprovableController } from \"./approvable/ERC721ApprovableController.sol\";\nimport { ERC721TransferableController } from \"./transferable/ERC721TransferableController.sol\";\n\nabstract contract ERC721Controller is\n    IERC721Controller,\n    ERC721BaseController,\n    ERC721ApprovableController,\n    ERC721TransferableController\n{}\n"
177     },
178     "contracts/core/token/ERC721/transferable/ERC721TransferableController.sol": {
179       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721TransferableController } from \"./IERC721TransferableController.sol\";\nimport { ERC721TransferableModel } from \"./ERC721TransferableModel.sol\";\nimport { ERC721ApprovableController } from \"../approvable/ERC721ApprovableController.sol\";\nimport { ERC721ReceiverUtils } from \"../utils/ERC721ReceiverUtils.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\n\nabstract contract ERC721TransferableController is\n    IERC721TransferableController,\n    ERC721TransferableModel,\n    ERC721ApprovableController\n{\n    using ERC721ReceiverUtils for address;\n    using AddressUtils for address;\n\n    function safeTransferFrom_(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        if (to.isContract()) {\n            to.enforceNotEquals(from);\n            _enforceCanTransferFrom(from, to, tokenId);\n            _transferFrom_(from, to, tokenId);\n            to.enforceOnReceived(msg.sender, from, tokenId, data);\n        } else {\n            transferFrom_(from, to, tokenId);\n        }\n    }\n\n    function transferFrom_(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        to.enforceIsNotZeroAddress();\n        to.enforceNotEquals(from);\n        _enforceCanTransferFrom(from, to, tokenId);\n        _transferFrom_(from, to, tokenId);\n    }\n\n    function _transferFrom_(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        if (_getApproved(tokenId) != address(0)) {\n            _approve_(from, address(0), tokenId);\n        }\n\n        _transferFrom(from, to, tokenId);\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _enforceCanTransferFrom(\n        address from,\n        address,\n        uint256 tokenId\n    ) internal view virtual {\n        from.enforceEquals(_ownerOf(tokenId));\n        _enforceIsApproved(from, msg.sender, tokenId);\n    }\n}\n"
180     },
181     "contracts/core/token/ERC721/transferable/ERC721TransferableModel.sol": {
182       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { erc721BaseStorage, ERC721BaseStorage } from \"../base/ERC721BaseStorage.sol\";\nimport { ERC721TokenUtils } from \"../utils/ERC721TokenUtils.sol\";\nimport { ERC721InventoryUtils } from \"../utils/ERC721InventoryUtils.sol\";\n\nabstract contract ERC721TransferableModel {\n    using ERC721TokenUtils for uint256;\n    using ERC721InventoryUtils for uint256;\n\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        ERC721BaseStorage storage es = erc721BaseStorage();\n\n        if (es.owners[tokenId] == from) {\n            es.inventories[from]--;\n        } else {\n            es.inventories[from] = es.inventories[from].remove(tokenId.index());\n        }\n\n        es.owners[tokenId] = to;\n        es.inventories[to]++;\n    }\n}\n"
183     },
184     "contracts/core/token/ERC721/utils/ERC721ReceiverUtils.sol": {
185       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721Receiver } from \"../IERC721Receiver.sol\";\n\n/**\n * @title ERC721 token receiver utilities\n */\nlibrary ERC721ReceiverUtils {\n    error UnexpectedNonERC721Receiver(address receiver);\n\n    function enforceOnReceived(\n        address to,\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        if (checkOnERC721Received(to, operator, from, tokenId, data)) {\n            return;\n        }\n\n        revert UnexpectedNonERC721Receiver(to);\n    }\n    \n    function checkOnERC721Received(\n        address to,\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) internal returns (bool) {\n        try\n            IERC721Receiver(to).onERC721Received(operator, from, tokenId, data)\n        returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n        } catch (bytes memory) {\n            return false;\n        }\n    }\n}"
186     },
187     "contracts/core/token/ERC721/IERC721Receiver.sol": {
188       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Receiver {\n    /**\n     * @notice Handle the receipt of a token\n     * @param operator The operator's address\n     * @param from The previous owner's address\n     * @param tokenId The token id\n     * @param data Additional data\n     * @return selector The function selector\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
189     },
190     "contracts/core/token/ERC721/tokenURI/ERC721TokenURIProxyController.sol": {
191       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721TokenURIController } from \"./ERC721TokenURIController.sol\";\nimport { ProxyController } from \"../../../proxy/ProxyController.sol\";\n\nabstract contract ERC721TokenURIProxyController is\n    ERC721TokenURIController,\n    ProxyController\n{\n    function tokenURIProxyable_(uint256 tokenId)\n        internal\n        virtual\n        returns (string memory)\n    {\n        uint256 providerId = tokenURIProvider_(tokenId);\n        (address provider, bool isProxyable) = _tokenURIProviderInfo(providerId);\n\n        if (isProxyable) {\n            _delegate(provider);\n        } else {\n            return _tokenURI(tokenId, provider);\n        }\n    }\n}\n"
192     },
193     "contracts/core/token/ERC721/enumerable/ERC721EnumerableController.sol": {
194       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ERC721EnumerableModel } from \"./ERC721EnumerableModel.sol\";\nimport { ERC721SupplyController } from \"../supply/ERC721SupplyController.sol\";\nimport { ERC721BaseController } from \"../base/ERC721BaseController.sol\";\nimport { IntegerUtils } from \"../../../utils/IntegerUtils.sol\";\n\nabstract contract ERC721EnumerableController is\n    ERC721EnumerableModel,\n    ERC721SupplyController,\n    ERC721BaseController\n{\n    using IntegerUtils for uint256;\n\n    function totalSupply_() internal view virtual returns (uint256) {\n        return _maxSupply() - _availableSupply();\n    }\n\n    function tokenByIndex_(uint256 index) internal view virtual returns (uint256) {\n        index.enforceLessThan(totalSupply_());\n        return _tokenByIndex_(index);\n    }\n\n    function tokenOfOwnerByIndex_(address owner, uint256 index)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        index.enforceLessThan(_balanceOf(owner));\n        return _tokenOfOwnerByIndex_(owner, index);\n    }\n\n    function _tokenOfOwnerByIndex_(address owner, uint256 index)\n        internal\n        view\n        virtual\n        returns (uint256 tokenId)\n    {\n        unchecked {\n            index++;\n            for (uint256 i; index > 0; i++) {\n                if (_ownerOf(tokenId = _tokenByIndex(i)) == owner) {\n                    index--;\n                }\n            }\n        }\n    }\n\n    function _tokenByIndex_(uint256 index) internal view returns (uint256 tokenId) {\n        unchecked {\n            index++;\n            for (uint256 i; index > 0; i++) {\n                if (_tokenExists(tokenId = _tokenByIndex(i))) {\n                    index--;\n                }\n            }\n        }\n    }\n}\n"
195     },
196     "contracts/core/token/ERC721/enumerable/ERC721EnumerableModel.sol": {
197       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC721EnumerablePage } from \"./IERC721EnumerablePage.sol\";\nimport { erc721EnumerableStorage, ERC721EnumerableStorage, PageInfo } from \"./ERC721EnumerableStorage.sol\";\n\nabstract contract ERC721EnumerableModel {\n    function _ERC721Enumerable(PageInfo[] memory pages) internal virtual {\n        erc721EnumerableStorage().pages = pages;\n    }\n\n    function _tokenByIndex(uint256 index)\n        internal\n        view\n        virtual\n        returns (uint256 tokenId)\n    {\n        ERC721EnumerableStorage storage es = erc721EnumerableStorage();\n\n        unchecked {\n            for (uint256 i; i < es.pages.length; i++) {\n                PageInfo memory page = es.pages[i];\n\n                if (index < page.length) {\n                    return IERC721EnumerablePage(page.pageAddress).tokenByIndex(index);\n                }\n                \n                index -= page.length;\n            }\n        }\n    }\n}\n"
198     },
199     "contracts/core/token/ERC721/enumerable/IERC721EnumerablePage.sol": {
200       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 enumerable page interface\n */\ninterface IERC721EnumerablePage {\n    /**\n     * @notice Get a token by enumeration index\n     * @param index The token position\n     * @return tokenId The token id\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
201     },
202     "contracts/core/token/ERC721/enumerable/ERC721EnumerableStorage.sol": {
203       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant ERC721_ENUMERABLE_STORAGE_SLOT = keccak256(\"core.token.erc721.enumerable.storage\");\n\nstruct PageInfo {\n    uint16 length;\n    address pageAddress;\n}\n\nstruct ERC721EnumerableStorage {\n    PageInfo[] pages;\n}\n\nfunction erc721EnumerableStorage() pure returns (ERC721EnumerableStorage storage es) {\n    bytes32 slot = ERC721_ENUMERABLE_STORAGE_SLOT;\n    assembly {\n        es.slot := slot\n    }\n}\n"
204     },
205     "contracts/core/access/ownable/safe/ISafeOwnable.sol": {
206       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from \"../../IERC173.sol\";\n\n/**\n * @title ERC173 safe ownership access control interface\n */\ninterface ISafeOwnable is IERC173 {\n    /**\n     * @notice Get the nominated owner\n     * @return nomineeOwner The nominated owner's address\n     */\n    function nomineeOwner() external returns (address);\n\n    /**\n     * @notice Accept contract ownership\n     */\n    function acceptOwnership() external;\n}\n"
207     },
208     "contracts/core/access/ownable/safe/SafeOwnableController.sol": {
209       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { SafeOwnableModel } from \"./SafeOwnableModel.sol\";\nimport { OwnableController } from \"../OwnableController.sol\";\nimport { AddressUtils } from \"../../../utils/AddressUtils.sol\";\n\nabstract contract SafeOwnableController is SafeOwnableModel, OwnableController {\n    using AddressUtils for address;\n\n    modifier onlyNomineeOwner() {\n        _enforceOnlyNomineeOwner();\n        _;\n    }\n\n    function nomineeOwner_() internal view virtual returns (address) {\n        return _nomineeOwner();\n    }\n\n    function acceptOwnership_() internal virtual {\n        transferOwnership_(_nomineeOwner());\n        _setNomineeOwner(address(0));\n    }\n\n    function _enforceOnlyNomineeOwner() internal view virtual {\n        msg.sender.enforceEquals(_nomineeOwner());\n    }\n}\n"
210     },
211     "contracts/core/access/ownable/OwnableProxy.sol": {
212       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from \"../IERC173.sol\";\nimport { OwnableController } from \"./OwnableController.sol\";\nimport { ProxyUpgradableController } from \"../../proxy/upgradable/ProxyUpgradableController.sol\";\n\n/**\n * @title ERC173 ownership access control implementation\n * @dev Note: Upgradable implementation\n */\nabstract contract OwnableProxy is IERC173, OwnableController, ProxyUpgradableController {\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() external virtual upgradable returns (address) {\n        return owner_();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address newOwner) external virtual upgradable onlyOwner {\n        transferOwnership_(newOwner);\n    }\n}\n"
213     },
214     "contracts/core/access/IERC173.sol": {
215       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173Controller } from \"./IERC173Controller.sol\";\n\n/**\n * @title ERC173 interface\n * @dev See https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Controller {\n    /**\n     * @notice Get the contract owner\n     * @return owner The owner's address\n     */\n    function owner() external returns (address);\n\n    /**\n     * @notice Transfer ownership to new owner\n     * @param newOwner The new owner's address\n     */\n    function transferOwnership(address newOwner) external;\n}\n"
216     },
217     "contracts/core/access/IERC173Controller.sol": {
218       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC173 interface required by controller functions\n */\ninterface IERC173Controller {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n}\n"
219     },
220     "contracts/core/access/ownable/safe/SafeOwnableModel.sol": {
221       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { safeOwnableStorage as os } from \"./SafeOwnableStorage.sol\";\n\nabstract contract SafeOwnableModel {\n    function _nomineeOwner() internal view virtual returns (address) {\n        return os().nomineeOwner;\n    }\n\n    function _setNomineeOwner(address nomineeOwner) internal virtual {\n        os().nomineeOwner = nomineeOwner;\n    }\n}\n"
222     },
223     "contracts/core/access/ownable/OwnableController.sol": {
224       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173Controller } from \"../IERC173Controller.sol\";\nimport { OwnableModel } from \"./OwnableModel.sol\";\nimport { AddressUtils } from \"../../utils/AddressUtils.sol\";\n\nabstract contract OwnableController is IERC173Controller, OwnableModel {\n    using AddressUtils for address;\n\n    modifier onlyOwner() {\n        _enforceOnlyOwner();\n        _;\n    }\n\n    function Ownable_() internal virtual {\n        Ownable_(msg.sender);\n    }\n\n    function Ownable_(address owner) internal virtual {\n        transferOwnership_(owner);\n    }\n\n    function owner_() internal view virtual returns (address) {\n        return _owner();\n    }\n\n    function transferOwnership_(address newOwner) internal virtual {\n        _transferOwnership(newOwner);\n        emit OwnershipTransferred(_owner(), newOwner);\n    }\n\n    function _enforceOnlyOwner() internal view virtual {\n        msg.sender.enforceEquals(_owner());\n    }\n}\n"
225     },
226     "contracts/core/access/ownable/safe/SafeOwnableStorage.sol": {
227       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant SAFE_OWNABLE_STORAGE_SLOT = keccak256(\"core.access.ownable.safe.storage\");\n\nstruct SafeOwnableStorage {\n    address nomineeOwner;\n}\n\nfunction safeOwnableStorage() pure returns (SafeOwnableStorage storage os) {\n    bytes32 slot = SAFE_OWNABLE_STORAGE_SLOT;\n    assembly {\n        os.slot := slot\n    }\n}\n"
228     },
229     "contracts/core/access/ownable/OwnableModel.sol": {
230       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ownableStorage as os } from \"./OwnableStorage.sol\";\n\nabstract contract OwnableModel {\n    function _owner() internal view virtual returns (address) {\n        return os().owner;\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        os().owner = newOwner;\n    }\n}\n"
231     },
232     "contracts/core/access/ownable/OwnableStorage.sol": {
233       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant OWNABLE_STORAGE_SLOT = keccak256(\"core.access.ownable.storage\");\n\nstruct OwnableStorage {\n    address owner;\n}\n\nfunction ownableStorage() pure returns (OwnableStorage storage os) {\n    bytes32 slot = OWNABLE_STORAGE_SLOT;\n    assembly {\n        os.slot := slot\n    }\n}\n"
234     },
235     "contracts/core/proxy/faceted/ProxyFacetedModel.sol": {
236       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { proxyFacetedStorage, ProxyFacetedStorage, SelectorInfo, ImplementationInfo } from \"./ProxyFacetedStorage.sol\";\n\nabstract contract ProxyFacetedModel {\n    function _implementation(bytes4 selector) internal view virtual returns (address) {\n        return proxyFacetedStorage().selectorInfo[selector].implementation;\n    }\n\n    function _addFunction(\n        bytes4 selector,\n        address implementation,\n        bool isUpgradable\n    ) internal virtual {\n        ProxyFacetedStorage storage ps = proxyFacetedStorage();\n        ps.selectorInfo[selector] = SelectorInfo(\n            isUpgradable,\n            uint16(ps.selectors.length),\n            implementation\n        );\n        ps.selectors.push(selector);\n    }\n\n    function _replaceFunction(bytes4 selector, address implementation) internal virtual {\n        proxyFacetedStorage().selectorInfo[selector].implementation = implementation;\n    }\n\n    function _removeFunction(bytes4 selector) internal virtual {\n        ProxyFacetedStorage storage ps = proxyFacetedStorage();\n        uint16 position = ps.selectorInfo[selector].position;\n        uint256 lastPosition = ps.selectors.length - 1;\n\n        if (position != lastPosition) {\n            bytes4 lastSelector = ps.selectors[lastPosition];\n            ps.selectors[position] = lastSelector;\n            ps.selectorInfo[lastSelector].position = position;\n        }\n\n        ps.selectors.pop();\n        delete ps.selectorInfo[selector];\n    }\n\n    function _afterAddFunction(address implementation) internal virtual {\n        ProxyFacetedStorage storage ps = proxyFacetedStorage();\n        ImplementationInfo memory info = ps.implementationInfo[implementation];\n\n        if (++info.selectorCount == 1) {\n            info.position = uint16(ps.implementations.length);\n            ps.implementations.push(implementation);\n        }\n\n        ps.implementationInfo[implementation] = info;\n    }\n\n    function _afterRemoveFunction(address implementation) internal virtual {\n        ProxyFacetedStorage storage ps = proxyFacetedStorage();\n        ImplementationInfo memory info = ps.implementationInfo[implementation];\n\n        if (--info.selectorCount == 0) {\n            uint16 position = info.position;\n            uint256 lastPosition = ps.implementations.length - 1;\n\n            if (position != lastPosition) {\n                address lastImplementation = ps.implementations[lastPosition];\n                ps.implementations[position] = lastImplementation;\n                ps.implementationInfo[lastImplementation].position = position;\n            }\n\n            ps.implementations.pop();\n            delete ps.implementationInfo[implementation];\n        } else {\n            ps.implementationInfo[implementation] = info;\n        }\n    }\n\n    function _setUpgradableFunction(bytes4 selector, bool isUpgradable) internal virtual {\n        proxyFacetedStorage().selectorInfo[selector].isUpgradable = isUpgradable;\n    }\n\n    function _isUpgradable(bytes4 selector) internal view virtual returns (bool) {\n        return proxyFacetedStorage().selectorInfo[selector].isUpgradable;\n    }\n}\n"
237     },
238     "contracts/core/proxy/faceted/ProxyFacetedStorage.sol": {
239       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nbytes32 constant FACETED_PROXY_STORAGE_SLOT = keccak256(\"core.proxy.faceted.storage\");\n\nstruct SelectorInfo {\n    bool isUpgradable;\n    uint16 position;\n    address implementation;\n}\n\nstruct ImplementationInfo {\n    uint16 position;\n    uint16 selectorCount;\n}\n\nstruct ProxyFacetedStorage {\n    mapping(bytes4 => SelectorInfo) selectorInfo;\n    bytes4[] selectors;\n    mapping(address => ImplementationInfo) implementationInfo;\n    address[] implementations;\n}\n\nfunction proxyFacetedStorage() pure returns (ProxyFacetedStorage storage ps) {\n    bytes32 slot = FACETED_PROXY_STORAGE_SLOT;\n    assembly {\n        ps.slot := slot\n    }\n}\n"
240     }
241   },
242   "settings": {
243     "viaIR": true,
244     "optimizer": {
245       "enabled": true,
246       "runs": 200
247     },
248     "outputSelection": {
249       "*": {
250         "*": [
251           "evm.bytecode",
252           "evm.deployedBytecode",
253           "devdoc",
254           "userdoc",
255           "metadata",
256           "abi"
257         ]
258       }
259     },
260     "libraries": {}
261   }
262 }}