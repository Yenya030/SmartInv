1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Simple.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.4;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n\nabstract contract Ownable {\n    error Ownable_NotOwner();\n    error Ownable_NewOwnerZeroAddress();\n\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @dev Returns the address of the current owner.\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert Ownable_NotOwner();\n        _;\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\n        _transferOwnership(newOwner);\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Internal function without access restriction.\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        unchecked {\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n\n/// @title SimpleERC721StakingPool\n/// @author defijesus.eth\n/// @notice Modified version of ERC721StakingPool created by zefram.eth \n/// Modifications: Added pausability, added emergency withdraw all rewardTokens\n/// A modern, gas optimized staking pool contract for rewarding ERC721 stakers\n/// with ERC20 tokens periodically and continuously\ncontract SimpleERC721StakingPool is Ownable, ERC721TokenReceiver {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for ERC20;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error Error_ZeroOwner();\n    error Error_AlreadyInitialized();\n    error Error_NotRewardDistributor();\n    error Error_AmountTooLarge();\n    error Error_NotTokenOwner();\n    error Error_NotStakeToken();\n    error Error_ContractIsPaused();\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256[] idList);\n    event Withdrawn(address indexed user, uint256[] idList);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    uint256 internal constant PRECISION = 1e30;\n    address internal constant BURN_ADDRESS = address(0xdead);\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @notice The last Unix timestamp (in seconds) when rewardPerTokenStored was updated\n    uint64 public lastUpdateTime;\n    /// @notice The Unix timestamp (in seconds) at which the current reward period ends\n    uint64 public periodFinish;\n\n    /// @notice The per-second rate at which rewardPerToken increases\n    uint256 public rewardRate;\n    /// @notice The last stored rewardPerToken value\n    uint256 public rewardPerTokenStored;\n    /// @notice The total tokens staked in the pool\n    uint256 public totalSupply;\n\n    /// @notice Tracks if an address can call notifyReward()\n    mapping(address => bool) public isRewardDistributor;\n    /// @notice The owner of a staked ERC721 token\n    mapping(uint256 => address) public ownerOf;\n\n    /// @notice The amount of tokens staked by an account\n    mapping(address => uint256) public balanceOf;\n    /// @notice The rewardPerToken value when an account last staked/withdrew/withdrew rewards\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    /// @notice The earned() value when an account last staked/withdrew/withdrew rewards\n    mapping(address => uint256) public rewards;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    uint64 public DURATION;\n    bool public paused;\n    ERC20 public rewardToken;\n    ERC721 public stakeToken;\n\n    /// -----------------------------------------------------------------------\n    /// Initialization\n    /// -----------------------------------------------------------------------\n    /// @param _rewardToken The token being rewarded to stakers\n    /// @param _stakeToken The token being staked in the pool\n    /// @param _DURATION The length of each reward period, in seconds\n    constructor (\n        ERC20 _rewardToken,\n        ERC721 _stakeToken,\n        uint64 _DURATION\n    ) {\n        DURATION = _DURATION;\n        rewardToken = _rewardToken;\n        stakeToken = _stakeToken;\n        paused = false;\n        _transferOwnership(msg.sender);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// User actions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Stakes a list of ERC721 tokens in the pool to earn rewards\n    /// @param idList The list of ERC721 token IDs to stake\n    function stake(uint256[] calldata idList) external {\n        if (paused) {\n            revert Error_ContractIsPaused();\n        }\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (idList.length == 0) {\n            return;\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 accountBalance = balanceOf[msg.sender];\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\n        uint256 totalSupply_ = totalSupply;\n        uint256 rewardPerToken_ = _rewardPerToken(\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate\n        );\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // accrue rewards\n        rewardPerTokenStored = rewardPerToken_;\n        lastUpdateTime = lastTimeRewardApplicable_;\n        rewards[msg.sender] = _earned(\n            msg.sender,\n            accountBalance,\n            rewardPerToken_,\n            rewards[msg.sender]\n        );\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\n\n        // stake\n        totalSupply = totalSupply_ + idList.length;\n        balanceOf[msg.sender] = accountBalance + idList.length;\n        unchecked {\n            for (uint256 i = 0; i < idList.length; i++) {\n                ownerOf[idList[i]] = msg.sender;\n            }\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Effects\n        /// -----------------------------------------------------------------------\n\n        unchecked {\n            for (uint256 i = 0; i < idList.length; i++) {\n                stakeToken.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    idList[i]\n                );\n            }\n        }\n\n        emit Staked(msg.sender, idList);\n    }\n\n    /// @notice Withdraws staked tokens from the pool\n    /// @param idList The list of ERC721 token IDs to stake\n    function withdraw(uint256[] calldata idList) external {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n        if (paused) {\n            revert Error_ContractIsPaused();\n        }\n        if (idList.length == 0) {\n            return;\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 accountBalance = balanceOf[msg.sender];\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\n        uint256 totalSupply_ = totalSupply;\n        uint256 rewardPerToken_ = _rewardPerToken(\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate\n        );\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // accrue rewards\n        rewardPerTokenStored = rewardPerToken_;\n        lastUpdateTime = lastTimeRewardApplicable_;\n        rewards[msg.sender] = _earned(\n            msg.sender,\n            accountBalance,\n            rewardPerToken_,\n            rewards[msg.sender]\n        );\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\n\n        // withdraw stake\n        balanceOf[msg.sender] = accountBalance - idList.length;\n        // total supply has 1:1 relationship with staked amounts\n        // so can't ever underflow\n        unchecked {\n            totalSupply = totalSupply_ - idList.length;\n            for (uint256 i = 0; i < idList.length; i++) {\n                // verify ownership\n                address tokenOwner = ownerOf[idList[i]];\n                if (tokenOwner != msg.sender || tokenOwner == BURN_ADDRESS) {\n                    revert Error_NotTokenOwner();\n                }\n\n                // keep the storage slot dirty to save gas\n                // if someone else stakes the same token again\n                ownerOf[idList[i]] = BURN_ADDRESS;\n            }\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Effects\n        /// -----------------------------------------------------------------------\n\n        unchecked {\n            for (uint256 i = 0; i < idList.length; i++) {\n                stakeToken.safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    idList[i]\n                );\n            }\n        }\n\n        emit Withdrawn(msg.sender, idList);\n    }\n\n    /// @notice Withdraws specified staked tokens and earned rewards\n    function exit(uint256[] calldata idList) external {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n        if (paused) {\n            revert Error_ContractIsPaused();\n        }\n        if (idList.length == 0) {\n            return;\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 accountBalance = balanceOf[msg.sender];\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\n        uint256 totalSupply_ = totalSupply;\n        uint256 rewardPerToken_ = _rewardPerToken(\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate\n        );\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // give rewards\n        uint256 reward = _earned(\n            msg.sender,\n            accountBalance,\n            rewardPerToken_,\n            rewards[msg.sender]\n        );\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n        }\n\n        // accrue rewards\n        rewardPerTokenStored = rewardPerToken_;\n        lastUpdateTime = lastTimeRewardApplicable_;\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\n\n        // withdraw stake\n        balanceOf[msg.sender] = accountBalance - idList.length;\n        // total supply has 1:1 relationship with staked amounts\n        // so can't ever underflow\n        unchecked {\n            totalSupply = totalSupply_ - idList.length;\n            for (uint256 i = 0; i < idList.length; i++) {\n                // verify ownership\n                address tokenOwner = ownerOf[idList[i]];\n                if (tokenOwner != msg.sender || tokenOwner == BURN_ADDRESS) {\n                    revert Error_NotTokenOwner();\n                }\n\n                // keep the storage slot dirty to save gas\n                // if someone else stakes the same token again\n                ownerOf[idList[i]] = BURN_ADDRESS;\n            }\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Effects\n        /// -----------------------------------------------------------------------\n\n        // transfer stake\n        unchecked {\n            for (uint256 i = 0; i < idList.length; i++) {\n                stakeToken.safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    idList[i]\n                );\n            }\n        }\n        emit Withdrawn(msg.sender, idList);\n\n        // transfer rewards\n        if (reward > 0) {\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /// @notice Withdraws all earned rewards\n    function getReward() external {\n        if (paused) {\n            revert Error_ContractIsPaused();\n        }\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 accountBalance = balanceOf[msg.sender];\n        uint64 lastTimeRewardApplicable_ = lastTimeRewardApplicable();\n        uint256 totalSupply_ = totalSupply;\n        uint256 rewardPerToken_ = _rewardPerToken(\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate\n        );\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        uint256 reward = _earned(\n            msg.sender,\n            accountBalance,\n            rewardPerToken_,\n            rewards[msg.sender]\n        );\n\n        // accrue rewards\n        rewardPerTokenStored = rewardPerToken_;\n        lastUpdateTime = lastTimeRewardApplicable_;\n        userRewardPerTokenPaid[msg.sender] = rewardPerToken_;\n\n        // withdraw rewards\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n\n            /// -----------------------------------------------------------------------\n            /// Effects\n            /// -----------------------------------------------------------------------\n\n            rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The latest time at which stakers are earning rewards.\n    function lastTimeRewardApplicable() public view returns (uint64) {\n        return\n            block.timestamp < periodFinish\n                ? uint64(block.timestamp)\n                : periodFinish;\n    }\n\n    /// @notice The amount of reward tokens each staked token has earned so far\n    function rewardPerToken() external view returns (uint256) {\n        return\n            _rewardPerToken(\n                totalSupply,\n                lastTimeRewardApplicable(),\n                rewardRate\n            );\n    }\n\n    /// @notice The amount of reward tokens an account has accrued so far. Does not\n    /// include already withdrawn rewards.\n    function earned(address account) external view returns (uint256) {\n        return\n            _earned(\n                account,\n                balanceOf[account],\n                _rewardPerToken(\n                    totalSupply,\n                    lastTimeRewardApplicable(),\n                    rewardRate\n                ),\n                rewards[account]\n            );\n    }\n\n    /// @dev ERC721 compliance\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external view override returns (bytes4) {\n        if (msg.sender != address(stakeToken)) {\n            revert Error_NotStakeToken();\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner actions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Lets a reward distributor start a new reward period. The reward tokens must have already\n    /// been transferred to this contract before calling this function. If it is called\n    /// when a reward period is still active, a new reward period will begin from the time\n    /// of calling this function, using the leftover rewards from the old reward period plus\n    /// the newly sent rewards as the reward.\n    /// @dev If the reward amount will cause an overflow when computing rewardPerToken, then\n    /// this function will revert.\n    /// @param reward The amount of reward tokens to use in the new reward period.\n    function notifyRewardAmount(uint256 reward) external {\n        /// -----------------------------------------------------------------------\n        /// Validation\n        /// -----------------------------------------------------------------------\n\n        if (reward == 0) {\n            return;\n        }\n        if (!isRewardDistributor[msg.sender]) {\n            revert Error_NotRewardDistributor();\n        }\n\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint256 rewardRate_ = rewardRate;\n        uint64 periodFinish_ = periodFinish;\n        uint64 lastTimeRewardApplicable_ = block.timestamp < periodFinish_\n            ? uint64(block.timestamp)\n            : periodFinish_;\n        uint64 DURATION_ = DURATION;\n        uint256 totalSupply_ = totalSupply;\n\n        /// -----------------------------------------------------------------------\n        /// State updates\n        /// -----------------------------------------------------------------------\n\n        // accrue rewards\n        rewardPerTokenStored = _rewardPerToken(\n            totalSupply_,\n            lastTimeRewardApplicable_,\n            rewardRate_\n        );\n        lastUpdateTime = lastTimeRewardApplicable_;\n\n        // record new reward\n        uint256 newRewardRate;\n        if (block.timestamp >= periodFinish_) {\n            newRewardRate = reward / DURATION_;\n        } else {\n            uint256 remaining = periodFinish_ - block.timestamp;\n            uint256 leftover = remaining * rewardRate_;\n            newRewardRate = (reward + leftover) / DURATION_;\n        }\n        // prevent overflow when computing rewardPerToken\n        if (newRewardRate >= ((type(uint256).max / PRECISION) / DURATION_)) {\n            revert Error_AmountTooLarge();\n        }\n        rewardRate = newRewardRate;\n        lastUpdateTime = uint64(block.timestamp);\n        periodFinish = uint64(block.timestamp + DURATION_);\n\n        emit RewardAdded(reward);\n    }\n\n    /// @notice Lets the owner add/remove accounts from the list of reward distributors.\n    /// Reward distributors can call notifyRewardAmount()\n    /// @param rewardDistributor The account to add/remove\n    /// @param isRewardDistributor_ True to add the account, false to remove the account\n    function setRewardDistributor(\n        address rewardDistributor,\n        bool isRewardDistributor_\n    ) external onlyOwner {\n        isRewardDistributor[rewardDistributor] = isRewardDistributor_;\n    }\n\n    function setPaused(bool _paused) external onlyOwner {\n        paused = _paused;\n    }\n\n    function emergencyWithdrawTokens(address to) external onlyOwner {\n        rewardToken.safeTransfer(to, rewardToken.balanceOf(address(this)));\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------------------\n\n    function _earned(\n        address account,\n        uint256 accountBalance,\n        uint256 rewardPerToken_,\n        uint256 accountRewards\n    ) internal view returns (uint256) {\n        return\n            FullMath.mulDiv(\n                accountBalance,\n                rewardPerToken_ - userRewardPerTokenPaid[account],\n                PRECISION\n            ) + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 totalSupply_,\n        uint256 lastTimeRewardApplicable_,\n        uint256 rewardRate_\n    ) internal view returns (uint256) {\n        if (totalSupply_ == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            FullMath.mulDiv(\n                (lastTimeRewardApplicable_ - lastUpdateTime) * PRECISION,\n                rewardRate_,\n                totalSupply_\n            );\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}