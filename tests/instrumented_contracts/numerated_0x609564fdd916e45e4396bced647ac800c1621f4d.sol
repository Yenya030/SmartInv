1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
6     },
7     "@openzeppelin-4.5/contracts/utils/math/SafeCast.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
9     },
10     "@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
12     },
13     "contracts/interfaces/0.8.x/IAdminACLV0.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IAdminACLV0 {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     * @param previousSuperAdmin The previous superAdmin address.\n     * @param newSuperAdmin The new superAdmin address.\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\n     * addresses to update to the new superAdmin, for indexing purposes only.\n     */\n    event SuperAdminTransferred(\n        address indexed previousSuperAdmin,\n        address indexed newSuperAdmin,\n        address[] genArt721CoreAddressesToUpdate\n    );\n\n    /// Type of the Admin ACL contract, e.g. \"AdminACLV0\"\n    function AdminACLType() external view returns (string memory);\n\n    /// super admin address\n    function superAdmin() external view returns (address);\n\n    /**\n     * @notice Calls transferOwnership on other contract from this contract.\n     * This is useful for updating to a new AdminACL contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function transferOwnershipOn(\n        address _contract,\n        address _newAdminACL\n    ) external;\n\n    /**\n     * @notice Calls renounceOwnership on other contract from this contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function renounceOwnershipOn(address _contract) external;\n\n    /**\n     * @notice Checks if sender `_sender` is allowed to call function with selector\n     * `_selector` on contract `_contract`.\n     */\n    function allowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n}\n"
15     },
16     "contracts/interfaces/0.8.x/IFilteredMinterDAExpV0.sol": {
17       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV0.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV0 interface in order to\n * add support for exponential descending auctions.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterDAExpV0 is IFilteredMinterV0 {\n    /// Auction details updated for project `projectId`.\n    event SetAuctionDetails(\n        uint256 indexed projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    );\n\n    /// Auction details cleared for project `projectId`.\n    event ResetAuctionDetails(uint256 indexed projectId);\n\n    /// Maximum and minimum allowed price decay half lifes updated.\n    event AuctionHalfLifeRangeSecondsUpdated(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    );\n\n    function minimumPriceDecayHalfLifeSeconds() external view returns (uint256);\n\n    function maximumPriceDecayHalfLifeSeconds() external view returns (uint256);\n}\n"
18     },
19     "contracts/interfaces/0.8.x/IFilteredMinterDAExpV1.sol": {
20       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterDAExpV0.sol\";\nimport \"./IFilteredMinterV2.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterDAExpV0 interface in order to\n * add support for manually setting project max invocations.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterDAExpV1 is IFilteredMinterDAExpV0, IFilteredMinterV2 {\n\n}\n"
21     },
22     "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
23       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(\n        address _to,\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
24     },
25     "contracts/interfaces/0.8.x/IFilteredMinterV1.sol": {
26       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV0.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV0 interface in order to\n * add support for generic project minter configuration updates.\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\n * gas.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\n    /// ANY\n    /**\n     * @notice Generic project minter configuration event. Removes key `_key`\n     * for project `_projectId`.\n     */\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\n\n    /// BOOL\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\n\n    /// UINT256\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of uint256 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /// ADDRESS\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of addresses at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /// BYTES32\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of bytes32 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @dev Strings not supported. Recommend conversion of (short) strings to\n     * bytes32 to remain gas-efficient.\n     */\n}\n"
27     },
28     "contracts/interfaces/0.8.x/IFilteredMinterV2.sol": {
29       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV1.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV1 interface in order to\n * add support for manually setting project max invocations.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\n    /**\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\n     * updated to `_maxInvocations`.\n     */\n    event ProjectMaxInvocationsLimitUpdated(\n        uint256 indexed _projectId,\n        uint256 _maxInvocations\n    );\n\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\n    // less than or equal to the global max invocations for the project set on the core contract.\n    // This does not impact the max invocations value defined on the core contract.\n    function manuallyLimitProjectMaxInvocations(\n        uint256 _projectId,\n        uint256 _maxInvocations\n    ) external;\n}\n"
30     },
31     "contracts/interfaces/0.8.x/IGenArt721CoreContractV3_Base.sol": {
32       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\n/// use the Royalty Registry's IManifold interface for token royalties\nimport \"./IManifold.sol\";\n\n/**\n * @title This interface is intended to house interface items that are common\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\n * This interface extends the IManifold royalty interface in order to\n * add support the Royalty Registry by default.\n * @author Art Blocks Inc.\n */\ninterface IGenArt721CoreContractV3_Base is IManifold {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     */\n    event Mint(address indexed _to, uint256 indexed _tokenId);\n\n    /**\n     * @notice currentMinter updated to `_currentMinter`.\n     * @dev Implemented starting with V3 core\n     */\n    event MinterUpdated(address indexed _currentMinter);\n\n    /**\n     * @notice Platform updated on bytes32-encoded field `_field`.\n     */\n    event PlatformUpdated(bytes32 indexed _field);\n\n    /**\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\n     * `_update`.\n     */\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\n\n    event ProposedArtistAddressesAndSplits(\n        uint256 indexed _projectId,\n        address _artistAddress,\n        address _additionalPayeePrimarySales,\n        uint256 _additionalPayeePrimarySalesPercentage,\n        address _additionalPayeeSecondarySales,\n        uint256 _additionalPayeeSecondarySalesPercentage\n    );\n\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\n\n    // version and type of the core contract\n    // coreVersion is a string of the form \"0.x.y\"\n    function coreVersion() external view returns (string memory);\n\n    // coreType is a string of the form \"GenArt721CoreV3\"\n    function coreType() external view returns (string memory);\n\n    // owner (pre-V3 was named admin) of contract\n    // this is expected to be an Admin ACL contract for V3\n    function owner() external view returns (address);\n\n    // Admin ACL contract for V3, will be at the address owner()\n    function adminACLContract() external returns (IAdminACLV0);\n\n    // backwards-compatible (pre-V3) admin - equal to owner()\n    function admin() external view returns (address);\n\n    /**\n     * Function determining if _sender is allowed to call function with\n     * selector _selector on contract `_contract`. Intended to be used with\n     * peripheral contracts such as minters, as well as internally by the\n     * core contract itself.\n     */\n    function adminACLAllowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(\n        uint256 tokenId\n    ) external view returns (uint256 projectId);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySales(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\n        uint256 _projectId\n    ) external view returns (uint256);\n\n    // @dev new function in V3\n    function projectStateData(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            uint256 invocations,\n            uint256 maxInvocations,\n            bool active,\n            bool paused,\n            uint256 completedTimestamp,\n            bool locked\n        );\n\n    // function to set a token's hash (must be guarded)\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\n\n    // @dev gas-optimized signature in V3 for `mint`\n    function mint_Ecf(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n}\n"
33     },
34     "contracts/interfaces/0.8.x/IGenArt721CoreContractV3_Engine.sol": {
35       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\nimport \"./IGenArt721CoreContractV3_Base.sol\";\n\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\n    // @dev new function in V3\n    function getPrimaryRevenueSplits(\n        uint256 _projectId,\n        uint256 _price\n    )\n        external\n        view\n        returns (\n            uint256 renderProviderRevenue_,\n            address payable renderProviderAddress_,\n            uint256 platformProviderRevenue_,\n            address payable platformProviderAddress_,\n            uint256 artistRevenue_,\n            address payable artistAddress_,\n            uint256 additionalPayeePrimaryRevenue_,\n            address payable additionalPayeePrimaryAddress_\n        );\n\n    // @dev The render provider primary sales payment address\n    function renderProviderPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev The platform provider primary sales payment address\n    function platformProviderPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Percentage of primary sales allocated to the render provider\n    function renderProviderPrimarySalesPercentage()\n        external\n        view\n        returns (uint256);\n\n    // @dev Percentage of primary sales allocated to the platform provider\n    function platformProviderPrimarySalesPercentage()\n        external\n        view\n        returns (uint256);\n\n    // @dev The render provider secondary sales royalties payment address\n    function renderProviderSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev The platform provider secondary sales royalties payment address\n    function platformProviderSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Basis points of secondary sales allocated to the render provider\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\n\n    // @dev Basis points of secondary sales allocated to the platform provider\n    function platformProviderSecondarySalesBPS()\n        external\n        view\n        returns (uint256);\n\n    // function to read the hash for a given tokenId\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\n\n    // function to read the hash-seed for a given tokenId\n    function tokenIdToHashSeed(\n        uint256 _tokenId\n    ) external view returns (bytes12);\n}\n"
36     },
37     "contracts/interfaces/0.8.x/IGenArt721CoreContractV3.sol": {
38       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\nimport \"./IGenArt721CoreContractV3_Base.sol\";\n\n/**\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\n * that are part of the Art Blocks Flagship core contract.\n * @author Art Blocks Inc.\n */\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\n// in part of the Art Blocks Flagship core contract.\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\n    // @dev new function in V3\n    function getPrimaryRevenueSplits(\n        uint256 _projectId,\n        uint256 _price\n    )\n        external\n        view\n        returns (\n            uint256 artblocksRevenue_,\n            address payable artblocksAddress_,\n            uint256 artistRevenue_,\n            address payable artistAddress_,\n            uint256 additionalPayeePrimaryRevenue_,\n            address payable additionalPayeePrimaryAddress_\n        );\n\n    // @dev Art Blocks primary sales payment address\n    function artblocksPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\n     */\n    function artblocksAddress() external view returns (address payable);\n\n    // @dev Percentage of primary sales allocated to Art Blocks\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\n     */\n    function artblocksPercentage() external view returns (uint256);\n\n    // @dev Art Blocks secondary sales royalties payment address\n    function artblocksSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Basis points of secondary sales allocated to Art Blocks\n    function artblocksSecondarySalesBPS() external view returns (uint256);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\n     * artist's additional payee royalty data for token ID `_tokenId`.\n     * WARNING: Does not include Art Blocks portion of royalties.\n     */\n    function getRoyaltyData(\n        uint256 _tokenId\n    )\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
39     },
40     "contracts/interfaces/0.8.x/IManifold.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\n\n/// @author: manifold.xyz\n\n/**\n * @dev Royalty interface for creator core classes\n */\ninterface IManifold {\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     *\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n     *\n     *  => 0xbb3bafd6 = 0xbb3bafd6\n     */\n    function getRoyalties(\n        uint256 tokenId\n    ) external view returns (address payable[] memory, uint256[] memory);\n}\n"
42     },
43     "contracts/interfaces/0.8.x/IMinterBaseV0.sol": {
44       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV2.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface defines any events or functions required for a minter\n * to conform to the MinterBase contract.\n * @dev The MinterBase contract was not implemented from the beginning of the\n * MinterSuite contract suite, therefore early versions of some minters may not\n * conform to this interface.\n * @author Art Blocks Inc.\n */\ninterface IMinterBaseV0 {\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\n    // Returns true only if the minter is configured to integrate with an engine contract.\n    function isEngine() external returns (bool isEngine);\n}\n"
45     },
46     "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
47       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
48     },
49     "contracts/minter-suite/Minters/MinterBase_v0_1_1.sol": {
50       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../../interfaces/0.8.x/IMinterBaseV0.sol\";\nimport \"../../interfaces/0.8.x/IGenArt721CoreContractV3_Base.sol\";\nimport \"../../interfaces/0.8.x/IGenArt721CoreContractV3.sol\";\nimport \"../../interfaces/0.8.x/IGenArt721CoreContractV3_Engine.sol\";\n\nimport \"@openzeppelin-4.7/contracts/token/ERC20/IERC20.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title Art Blocks Minter Base Class\n * @notice A base class for Art Blocks minter contracts that provides common\n * functionality used across minter contracts.\n * This contract is not intended to be deployed directly, but rather to be\n * inherited by other minter contracts.\n * From a design perspective, this contract is intended to remain simple and\n * easy to understand. It is not intended to cause a complex inheritance tree,\n * and instead should keep minter contracts as readable as possible for\n * collectors and developers.\n * @dev Semantic versioning is used in the solidity file name, and is therefore\n * controlled by contracts importing the appropriate filename version.\n * @author Art Blocks Inc.\n */\nabstract contract MinterBase is IMinterBaseV0 {\n    /// state variable that tracks whether this contract's associated core\n    /// contract is an Engine contract, where Engine contracts have an\n    /// additional revenue split for the platform provider\n    bool public immutable isEngine;\n\n    // @dev we do not track an initialization state, as the only state variable\n    // is immutable, which the compiler enforces to be assigned during\n    // construction.\n\n    /**\n     * @notice Initializes contract to ensure state variable `isEngine` is set\n     * appropriately based on the minter's associated core contract address.\n     * @param genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     */\n    constructor(address genArt721Address) {\n        // set state variable isEngine\n        isEngine = _getV3CoreIsEngine(genArt721Address);\n    }\n\n    /**\n     * @notice splits ETH funds between sender (if refund), providers,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * WARNING: This function uses msg.value and msg.sender to determine\n     * refund amounts, and therefore may not be applicable to all use cases\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     * @param projectId Project ID for which funds shall be split.\n     * @param pricePerTokenInWei Current price of token, in Wei.\n     */\n    function splitFundsETH(\n        uint256 projectId,\n        uint256 pricePerTokenInWei,\n        address genArt721CoreAddress\n    ) internal {\n        if (msg.value > 0) {\n            bool success_;\n            // send refund to sender\n            uint256 refund = msg.value - pricePerTokenInWei;\n            if (refund > 0) {\n                (success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            // split revenues\n            splitRevenuesETH(\n                projectId,\n                pricePerTokenInWei,\n                genArt721CoreAddress\n            );\n        }\n    }\n\n    /**\n     * @notice splits ETH revenues between providers, artist, and artist's\n     * additional payee for revenue generated by project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     * @param projectId Project ID for which funds shall be split.\n     * @param valueInWei Value to be split, in Wei.\n     */\n    function splitRevenuesETH(\n        uint256 projectId,\n        uint256 valueInWei,\n        address genArtCoreContract\n    ) internal {\n        if (valueInWei <= 0) {\n            return; // return early\n        }\n        bool success;\n        // split funds between platforms, artist, and artist's\n        // additional payee\n        uint256 renderProviderRevenue_;\n        address payable renderProviderAddress_;\n        uint256 artistRevenue_;\n        address payable artistAddress_;\n        uint256 additionalPayeePrimaryRevenue_;\n        address payable additionalPayeePrimaryAddress_;\n        if (isEngine) {\n            // get engine splits\n            uint256 platformProviderRevenue_;\n            address payable platformProviderAddress_;\n            (\n                renderProviderRevenue_,\n                renderProviderAddress_,\n                platformProviderRevenue_,\n                platformProviderAddress_,\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, valueInWei);\n            // Platform Provider payment (only possible if engine)\n            if (platformProviderRevenue_ > 0) {\n                (success, ) = platformProviderAddress_.call{\n                    value: platformProviderRevenue_\n                }(\"\");\n                require(success, \"Platform Provider payment failed\");\n            }\n        } else {\n            // get flagship splits\n            (\n                renderProviderRevenue_, // artblocks revenue\n                renderProviderAddress_, // artblocks address\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, valueInWei);\n        }\n        // Render Provider / Art Blocks payment\n        if (renderProviderRevenue_ > 0) {\n            (success, ) = renderProviderAddress_.call{\n                value: renderProviderRevenue_\n            }(\"\");\n            require(success, \"Render Provider payment failed\");\n        }\n        // artist payment\n        if (artistRevenue_ > 0) {\n            (success, ) = artistAddress_.call{value: artistRevenue_}(\"\");\n            require(success, \"Artist payment failed\");\n        }\n        // additional payee payment\n        if (additionalPayeePrimaryRevenue_ > 0) {\n            (success, ) = additionalPayeePrimaryAddress_.call{\n                value: additionalPayeePrimaryRevenue_\n            }(\"\");\n            require(success, \"Additional Payee payment failed\");\n        }\n    }\n\n    /**\n     * @notice splits ERC-20 funds between providers, artist, and artist's\n     * additional payee, for a token purchased on project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     */\n    function splitFundsERC20(\n        uint256 projectId,\n        uint256 pricePerTokenInWei,\n        address currencyAddress,\n        address genArtCoreContract\n    ) internal {\n        IERC20 _projectCurrency = IERC20(currencyAddress);\n        // split remaining funds between foundation, artist, and artist's\n        // additional payee\n        uint256 renderProviderRevenue_;\n        address payable renderProviderAddress_;\n        uint256 artistRevenue_;\n        address payable artistAddress_;\n        uint256 additionalPayeePrimaryRevenue_;\n        address payable additionalPayeePrimaryAddress_;\n        if (isEngine) {\n            // get engine splits\n            uint256 platformProviderRevenue_;\n            address payable platformProviderAddress_;\n            (\n                renderProviderRevenue_,\n                renderProviderAddress_,\n                platformProviderRevenue_,\n                platformProviderAddress_,\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\n            // Platform Provider payment (only possible if engine)\n            if (platformProviderRevenue_ > 0) {\n                _projectCurrency.transferFrom(\n                    msg.sender,\n                    platformProviderAddress_,\n                    platformProviderRevenue_\n                );\n            }\n        } else {\n            // get flagship splits\n            (\n                renderProviderRevenue_, // artblocks revenue\n                renderProviderAddress_, // artblocks address\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\n        }\n        // Art Blocks payment\n        if (renderProviderRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                renderProviderAddress_,\n                renderProviderRevenue_\n            );\n        }\n        // artist payment\n        if (artistRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                artistAddress_,\n                artistRevenue_\n            );\n        }\n        // additional payee payment\n        if (additionalPayeePrimaryRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                additionalPayeePrimaryAddress_,\n                additionalPayeePrimaryRevenue_\n            );\n        }\n    }\n\n    /**\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\n     * contract or not. Return value of false indicates that the core is a\n     * flagship contract.\n     * @dev this function reverts if a core contract does not return the\n     * expected number of return values from getPrimaryRevenueSplits() for\n     * either a flagship or engine core contract.\n     * @dev this function uses the length of the return data (in bytes) to\n     * determine whether the core is an engine or not.\n     * @param genArt721CoreV3 The address of the deployed core contract.\n     */\n    function _getV3CoreIsEngine(\n        address genArt721CoreV3\n    ) private returns (bool) {\n        // call getPrimaryRevenueSplits() on core contract\n        bytes memory payload = abi.encodeWithSignature(\n            \"getPrimaryRevenueSplits(uint256,uint256)\",\n            0,\n            0\n        );\n        (bool success, bytes memory returnData) = genArt721CoreV3.call(payload);\n        require(success, \"getPrimaryRevenueSplits() call failed\");\n        // determine whether core is engine or not, based on return data length\n        uint256 returnDataLength = returnData.length;\n        if (returnDataLength == 6 * 32) {\n            // 6 32-byte words returned if flagship (not engine)\n            // @dev 6 32-byte words are expected because the non-engine core\n            // contracts return a payout address and uint256 payment value for\n            // the artist, and artist's additional payee, and Art Blocks.\n            // also note that per Solidity ABI encoding, the address return\n            // values are padded to 32 bytes.\n            return false;\n        } else if (returnDataLength == 8 * 32) {\n            // 8 32-byte words returned if engine\n            // @dev 8 32-byte words are expected because the engine core\n            // contracts return a payout address and uint256 payment value for\n            // the artist, artist's additional payee, render provider\n            // typically Art Blocks, and platform provider (partner).\n            // also note that per Solidity ABI encoding, the address return\n            // values are padded to 32 bytes.\n            return true;\n        } else {\n            // unexpected return value length\n            revert(\"Unexpected revenue split bytes\");\n        }\n    }\n}\n"
51     },
52     "contracts/minter-suite/Minters/MinterDAExpV4.sol": {
53       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../../interfaces/0.8.x/IGenArt721CoreContractV3_Base.sol\";\nimport \"../../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../../interfaces/0.8.x/IFilteredMinterDAExpV1.sol\";\nimport \"./MinterBase_v0_1_1.sol\";\n\nimport \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-4.5/contracts/utils/math/SafeCast.sol\";\n\npragma solidity 0.8.17;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\n * Pricing is achieved using an automated Dutch-auction mechanism.\n * This is designed to be used with GenArt721CoreContractV3 flagship or\n * engine contracts.\n * @author Art Blocks Inc.\n * @notice Privileged Roles and Ownership:\n * This contract is designed to be managed, with limited powers.\n * Privileged roles and abilities are controlled by the core contract's Admin\n * ACL contract and a project's artist. Both of these roles hold extensive\n * power and can modify minter details.\n * Care must be taken to ensure that the admin ACL contract and artist\n * addresses are secure behind a multi-sig or other access control mechanism.\n * ----------------------------------------------------------------------------\n * The following functions are restricted to the core contract's Admin ACL\n * contract:\n * - setAllowablePriceDecayHalfLifeRangeSeconds (note: this range is only\n *   enforced when creating new auctions)\n * - resetAuctionDetails (note: this will prevent minting until a new auction\n *   is created)\n * ----------------------------------------------------------------------------\n * The following functions are restricted to a project's artist:\n * - setAuctionDetails (note: this may only be called when there is no active\n *   auction)\n * - setProjectMaxInvocations\n * - manuallyLimitProjectMaxInvocations\n * ----------------------------------------------------------------------------\n * Additional admin and artist privileged roles may be described on other\n * contracts that this minter integrates with.\n *\n * @dev Note that while this minter makes use of `block.timestamp` and it is\n * technically possible that this value is manipulated by block producers, such\n * manipulation will not have material impact on the price values of this minter\n * given the business practices for how pricing is congfigured for this minter\n * and that variations on the order of less than a minute should not\n * meaningfully impact price given the minimum allowable price decay rate that\n * this minter intends to support.\n */\ncontract MinterDAExpV4 is ReentrancyGuard, MinterBase, IFilteredMinterDAExpV1 {\n    using SafeCast for uint256;\n\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// The core contract integrates with V3 contracts\n    IGenArt721CoreContractV3_Base private immutable genArtCoreContract_Base;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterDAExpV4\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    struct ProjectConfig {\n        bool maxHasBeenInvoked;\n        uint24 maxInvocations;\n        // max uint64 ~= 1.8e19 sec ~= 570 billion years\n        uint64 timestampStart;\n        uint64 priceDecayHalfLifeSeconds;\n        uint256 startPrice;\n        uint256 basePrice;\n    }\n\n    mapping(uint256 => ProjectConfig) public projectConfig;\n\n    /// Minimum price decay half life: price must decay with a half life of at\n    /// least this amount (must cut in half at least every N seconds).\n    uint256 public minimumPriceDecayHalfLifeSeconds = 300; // 5 minutes\n    /// Maximum price decay half life: price may decay with a half life of no\n    /// more than this amount (may cut in half at no more than every N seconds).\n    uint256 public maximumPriceDecayHalfLifeSeconds = 3600; // 60 minutes\n\n    // modifier to restrict access to only AdminACL allowed calls\n    // @dev defers which ACL contract is used to the core contract\n    modifier onlyCoreAdminACL(bytes4 _selector) {\n        require(\n            genArtCoreContract_Base.adminACLAllowed(\n                msg.sender,\n                address(this),\n                _selector\n            ),\n            \"Only Core AdminACL allowed\"\n        );\n        _;\n    }\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            (msg.sender ==\n                genArtCoreContract_Base.projectIdToArtistAddress(_projectId)),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for which\n     * this will a filtered minter.\n     */\n    constructor(\n        address _genArt721Address,\n        address _minterFilter\n    ) ReentrancyGuard() MinterBase(_genArt721Address) {\n        genArt721CoreAddress = _genArt721Address;\n        // always populate immutable engine contracts, but only use appropriate\n        // interface based on isEngine in the rest of the contract\n        genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\n            _genArt721Address\n        );\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Syncs local maximum invocations of project `_projectId` based on\n     * the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(\n        uint256 _projectId\n    ) external onlyArtist(_projectId) {\n        uint256 maxInvocations;\n        uint256 invocations;\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\n            .projectStateData(_projectId);\n\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\n\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\n        // local maxInvocations value with the core contract's maxInvocations value.\n        // This synced value of maxInvocations from the core contract will always be greater\n        // than or equal to the previous value of maxInvocations stored locally.\n        projectConfig[_projectId].maxHasBeenInvoked =\n            invocations == maxInvocations;\n\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, maxInvocations);\n    }\n\n    /**\n     * @notice Manually sets the local maximum invocations of project `_projectId`\n     * with the provided `_maxInvocations`, checking that `_maxInvocations` is less\n     * than or equal to the value of project `_project_id`'s maximum invocations that is\n     * set on the core contract.\n     * @dev Note that a `_maxInvocations` of 0 can only be set if the current `invocations`\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @param _maxInvocations Maximum invocations to set for the project.\n     */\n    function manuallyLimitProjectMaxInvocations(\n        uint256 _projectId,\n        uint256 _maxInvocations\n    ) external onlyArtist(_projectId) {\n        // CHECKS\n        // ensure that the manually set maxInvocations is not greater than what is set on the core contract\n        uint256 maxInvocations;\n        uint256 invocations;\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\n            .projectStateData(_projectId);\n        require(\n            _maxInvocations <= maxInvocations,\n            \"Cannot increase project max invocations above core contract set project max invocations\"\n        );\n        require(\n            _maxInvocations >= invocations,\n            \"Cannot set project max invocations to less than current invocations\"\n        );\n        // EFFECTS\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(_maxInvocations);\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\n        // local maxInvocations value.\n        projectConfig[_projectId].maxHasBeenInvoked =\n            invocations == _maxInvocations;\n\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, _maxInvocations);\n    }\n\n    /**\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\n     * This method exists purely for interface-conformance purposes.\n     */\n    function togglePurchaseToDisabled(\n        uint256 _projectId\n    ) external view onlyArtist(_projectId) {\n        revert(\"Action not supported\");\n    }\n\n    /**\n     * @notice projectId => has project reached its maximum number of\n     * invocations? Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached. A false negative will\n     * only result in a gas cost increase, since the core contract will still\n     * enforce a maxInvocation check during minting. A false positive is not\n     * possible because the V3 core contract only allows maximum invocations\n     * to be reduced, not increased. Based on this rationale, we intentionally\n     * do not do input validation in this method as to whether or not the input\n     * `_projectId` is an existing project ID.\n     *\n     */\n    function projectMaxHasBeenInvoked(\n        uint256 _projectId\n    ) external view returns (bool) {\n        return projectConfig[_projectId].maxHasBeenInvoked;\n    }\n\n    /**\n     * @notice projectId => project's maximum number of invocations.\n     * Optionally synced with core contract value, for gas optimization.\n     * Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached.\n     * @dev A number greater than the core contract's project max invocations\n     * will only result in a gas cost increase, since the core contract will\n     * still enforce a maxInvocation check during minting. A number less than\n     * the core contract's project max invocations is only possible when the\n     * project's max invocations have not been synced on this minter, since the\n     * V3 core contract only allows maximum invocations to be reduced, not\n     * increased. When this happens, the minter will enable minting, allowing\n     * the core contract to enforce the max invocations check. Based on this\n     * rationale, we intentionally do not do input validation in this method as\n     * to whether or not the input `_projectId` is an existing project ID.\n     */\n    function projectMaxInvocations(\n        uint256 _projectId\n    ) external view returns (uint256) {\n        return uint256(projectConfig[_projectId].maxInvocations);\n    }\n\n    /**\n     * @notice projectId => auction parameters\n     */\n    function projectAuctionParameters(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            uint256 timestampStart,\n            uint256 priceDecayHalfLifeSeconds,\n            uint256 startPrice,\n            uint256 basePrice\n        )\n    {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        return (\n            _projectConfig.timestampStart,\n            _projectConfig.priceDecayHalfLifeSeconds,\n            _projectConfig.startPrice,\n            _projectConfig.basePrice\n        );\n    }\n\n    /**\n     * @notice Sets the minimum and maximum values that are settable for\n     * `_priceDecayHalfLifeSeconds` across all projects.\n     * @param _minimumPriceDecayHalfLifeSeconds Minimum price decay half life\n     * (in seconds).\n     * @param _maximumPriceDecayHalfLifeSeconds Maximum price decay half life\n     * (in seconds).\n     */\n    function setAllowablePriceDecayHalfLifeRangeSeconds(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    )\n        external\n        onlyCoreAdminACL(\n            this.setAllowablePriceDecayHalfLifeRangeSeconds.selector\n        )\n    {\n        require(\n            _maximumPriceDecayHalfLifeSeconds >\n                _minimumPriceDecayHalfLifeSeconds,\n            \"Maximum half life must be greater than minimum\"\n        );\n        require(\n            _minimumPriceDecayHalfLifeSeconds > 0,\n            \"Half life of zero not allowed\"\n        );\n        minimumPriceDecayHalfLifeSeconds = _minimumPriceDecayHalfLifeSeconds;\n        maximumPriceDecayHalfLifeSeconds = _maximumPriceDecayHalfLifeSeconds;\n        emit AuctionHalfLifeRangeSecondsUpdated(\n            _minimumPriceDecayHalfLifeSeconds,\n            _maximumPriceDecayHalfLifeSeconds\n        );\n    }\n\n    ////// Auction Functions\n    /**\n     * @notice Sets auction details for project `_projectId`.\n     * @param _projectId Project ID to set auction details for.\n     * @param _auctionTimestampStart Timestamp at which to start the auction.\n     * @param _priceDecayHalfLifeSeconds The half life with which to decay the\n     *  price (in seconds).\n     * @param _startPrice Price at which to start the auction, in Wei.\n     * @param _basePrice Resting price of the auction, in Wei.\n     * @dev Note that it is intentionally supported here that the configured\n     * price may be explicitly set to `0`.\n     */\n    function setAuctionDetails(\n        uint256 _projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    ) external onlyArtist(_projectId) {\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        require(\n            _projectConfig.timestampStart == 0 ||\n                block.timestamp < _projectConfig.timestampStart,\n            \"No modifications mid-auction\"\n        );\n        require(\n            block.timestamp < _auctionTimestampStart,\n            \"Only future auctions\"\n        );\n        require(\n            _startPrice > _basePrice,\n            \"Auction start price must be greater than auction end price\"\n        );\n        require(\n            (_priceDecayHalfLifeSeconds >= minimumPriceDecayHalfLifeSeconds) &&\n                (_priceDecayHalfLifeSeconds <=\n                    maximumPriceDecayHalfLifeSeconds),\n            \"Price decay half life must fall between min and max allowable values\"\n        );\n        // EFFECTS\n        _projectConfig.timestampStart = _auctionTimestampStart.toUint64();\n        _projectConfig.priceDecayHalfLifeSeconds = _priceDecayHalfLifeSeconds\n            .toUint64();\n        _projectConfig.startPrice = _startPrice;\n        _projectConfig.basePrice = _basePrice;\n\n        emit SetAuctionDetails(\n            _projectId,\n            _auctionTimestampStart,\n            _priceDecayHalfLifeSeconds,\n            _startPrice,\n            _basePrice\n        );\n    }\n\n    /**\n     * @notice Resets auction details for project `_projectId`, zero-ing out all\n     * relevant auction fields. Not intended to be used in normal auction\n     * operation, but rather only in case of the need to halt an auction.\n     * @param _projectId Project ID to set auction details for.\n     */\n    function resetAuctionDetails(\n        uint256 _projectId\n    ) external onlyCoreAdminACL(this.resetAuctionDetails.selector) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        // reset to initial values\n        _projectConfig.timestampStart = 0;\n        _projectConfig.priceDecayHalfLifeSeconds = 0;\n        _projectConfig.startPrice = 0;\n        _projectConfig.basePrice = 0;\n\n        emit ResetAuctionDetails(_projectId);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice gas-optimized version of purchase(uint256).\n     */\n    function purchase_H4M(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(\n        address _to,\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        return purchaseTo_do6(_to, _projectId);\n    }\n\n    /**\n     * @notice gas-optimized version of purchaseTo(address, uint256).\n     */\n    function purchaseTo_do6(\n        address _to,\n        uint256 _projectId\n    ) public payable nonReentrant returns (uint256 tokenId) {\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\n        // consumption after a project has been fully minted.\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\n        // gas consumption, but if not in sync with the core contract's value,\n        // the core contract also enforces its own max invocation check during\n        // minting.\n        require(\n            !_projectConfig.maxHasBeenInvoked,\n            \"Maximum number of invocations reached\"\n        );\n\n        // _getPrice reverts if auction is unconfigured or has not started\n        uint256 pricePerTokenInWei = _getPrice(_projectId);\n        require(\n            msg.value >= pricePerTokenInWei,\n            \"Must send minimum value to mint!\"\n        );\n\n        // EFFECTS\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n\n        // okay if this underflows because if statement will always eval false.\n        // this is only for gas optimization (core enforces maxInvocations).\n        unchecked {\n            if (tokenId % ONE_MILLION == _projectConfig.maxInvocations - 1) {\n                _projectConfig.maxHasBeenInvoked = true;\n            }\n        }\n\n        // INTERACTIONS\n        splitFundsETH(_projectId, pricePerTokenInWei, genArt721CoreAddress);\n\n        return tokenId;\n    }\n\n    /**\n     * @notice Gets price of minting a token on project `_projectId` given\n     * the project's AuctionParameters and current block timestamp.\n     * Reverts if auction has not yet started or auction is unconfigured.\n     * @param _projectId Project ID to get price of token for.\n     * @return current price of token in Wei\n     * @dev This method calculates price decay using a linear interpolation\n     * of exponential decay based on the artist-provided half-life for price\n     * decay, `_priceDecayHalfLifeSeconds`.\n     */\n    function _getPrice(uint256 _projectId) private view returns (uint256) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        // move parameters to memory if used more than once\n        uint256 _timestampStart = uint256(_projectConfig.timestampStart);\n        uint256 _priceDecayHalfLifeSeconds = uint256(\n            _projectConfig.priceDecayHalfLifeSeconds\n        );\n        uint256 _basePrice = _projectConfig.basePrice;\n\n        require(block.timestamp > _timestampStart, \"Auction not yet started\");\n        require(_priceDecayHalfLifeSeconds > 0, \"Only configured auctions\");\n        uint256 decayedPrice = _projectConfig.startPrice;\n        uint256 elapsedTimeSeconds;\n        unchecked {\n            // already checked that block.timestamp > _timestampStart above\n            elapsedTimeSeconds = block.timestamp - _timestampStart;\n        }\n        // Divide by two (via bit-shifting) for the number of entirely completed\n        // half-lives that have elapsed since auction start time.\n        unchecked {\n            // already required _priceDecayHalfLifeSeconds > 0\n            decayedPrice >>= elapsedTimeSeconds / _priceDecayHalfLifeSeconds;\n        }\n        // Perform a linear interpolation between partial half-life points, to\n        // approximate the current place on a perfect exponential decay curve.\n        unchecked {\n            // value of expression is provably always less than decayedPrice,\n            // so no underflow is possible when the subtraction assignment\n            // operator is used on decayedPrice.\n            decayedPrice -=\n                (decayedPrice *\n                    (elapsedTimeSeconds % _priceDecayHalfLifeSeconds)) /\n                _priceDecayHalfLifeSeconds /\n                2;\n        }\n        if (decayedPrice < _basePrice) {\n            // Price may not decay below stay `basePrice`.\n            return _basePrice;\n        }\n        return decayedPrice;\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if project's auction parameters have been\n     * configured on this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if auction has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n\n        isConfigured = (_projectConfig.startPrice > 0);\n        if (block.timestamp <= _projectConfig.timestampStart) {\n            // Provide a reasonable value for `tokenPriceInWei` when it would\n            // otherwise revert, using the starting price before auction starts.\n            tokenPriceInWei = _projectConfig.startPrice;\n        } else if (_projectConfig.startPrice == 0) {\n            // In the case of unconfigured auction, return price of zero when\n            // it would otherwise revert\n            tokenPriceInWei = 0;\n        } else {\n            tokenPriceInWei = _getPrice(_projectId);\n        }\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
54     }
55   },
56   "settings": {
57     "optimizer": {
58       "enabled": true,
59       "runs": 25
60     },
61     "outputSelection": {
62       "*": {
63         "*": [
64           "evm.bytecode",
65           "evm.deployedBytecode",
66           "devdoc",
67           "userdoc",
68           "metadata",
69           "abi"
70         ]
71       }
72     },
73     "libraries": {}
74   }
75 }}