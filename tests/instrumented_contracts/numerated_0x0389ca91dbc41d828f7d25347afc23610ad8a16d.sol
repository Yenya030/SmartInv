1 /*
2 * Generated by Black Meta Corporation
3 * Founded by @mikedbecker
4 * Developed by @daveaneo
5 * Advisory by @Thrasher66099
6 * Truly user operated & owned by @blackmeta_
7 */
8 
9 
10 pragma solidity ^0.8.0;
11 
12 interface IByteContract {
13     function burn(address _from, uint256 _amount) external;
14 }
15 
16 
17 
18 interface IERC20 {
19 
20     function totalSupply() external view returns (uint256);
21     function balanceOf(address account) external view returns (uint256);
22     function transfer(address recipient, uint256 amount) external returns (bool);
23     function allowance(address owner, address spender) external view returns (uint256);
24     function approve(address spender, uint256 amount) external returns (bool);
25     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
26     event Transfer(address indexed from, address indexed to, uint256 value);
27     event Approval(address indexed owner, address indexed spender, uint256 value);
28     // new
29     function name() external view returns (string memory);
30 }
31 
32 /**
33  * @dev Interface of the ERC165 standard, as defined in the
34  * https://eips.ethereum.org/EIPS/eip-165[EIP].
35  *
36  * Implementers can declare support of contract interfaces, which can then be
37  * queried by others ({ERC165Checker}).
38  *
39  * For an implementation, see {ERC165}.
40  */
41 interface IERC165 {
42     /**
43      * @dev Returns true if this contract implements the interface defined by
44      * `interfaceId`. See the corresponding
45      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
46      * to learn more about how these ids are created.
47      *
48      * This function call must use less than 30 000 gas.
49      */
50     function supportsInterface(bytes4 interfaceId) external view returns (bool);
51 }
52 
53 
54 /// @title Base64
55 /// @author Brecht Devos - <brecht@loopring.org>
56 /// @notice Provides functions for encoding/decoding base64
57 library Base64 {
58     string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
59     bytes  internal constant TABLE_DECODE = hex"0000000000000000000000000000000000000000000000000000000000000000"
60                                             hex"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000"
61                                             hex"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000"
62                                             hex"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000";
63 
64     function encode(bytes memory data) internal pure returns (string memory) {
65         if (data.length == 0) return '';
66 
67         // load the table into memory
68         string memory table = TABLE_ENCODE;
69 
70         // multiply by 4/3 rounded up
71         uint256 encodedLen = 4 * ((data.length + 2) / 3);
72 
73         // add some extra buffer at the end required for the writing
74         string memory result = new string(encodedLen + 32);
75 
76         assembly {
77             // set the actual output length
78             mstore(result, encodedLen)
79 
80             // prepare the lookup table
81             let tablePtr := add(table, 1)
82 
83             // input ptr
84             let dataPtr := data
85             let endPtr := add(dataPtr, mload(data))
86 
87             // result ptr, jump over length
88             let resultPtr := add(result, 32)
89 
90             // run over the input, 3 bytes at a time
91             for {} lt(dataPtr, endPtr) {}
92             {
93                 // read 3 bytes
94                 dataPtr := add(dataPtr, 3)
95                 let input := mload(dataPtr)
96 
97                 // write 4 characters
98                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
99                 resultPtr := add(resultPtr, 1)
100                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
101                 resultPtr := add(resultPtr, 1)
102                 mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))
103                 resultPtr := add(resultPtr, 1)
104                 mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))
105                 resultPtr := add(resultPtr, 1)
106             }
107 
108             // padding with '='
109             switch mod(mload(data), 3)
110             case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
111             case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
112         }
113 
114         return result;
115     }
116 
117     function decode(string memory _data) internal pure returns (bytes memory) {
118         bytes memory data = bytes(_data);
119 
120         if (data.length == 0) return new bytes(0);
121         require(data.length % 4 == 0, "invalid base64 decoder input");
122 
123         // load the table into memory
124         bytes memory table = TABLE_DECODE;
125 
126         // every 4 characters represent 3 bytes
127         uint256 decodedLen = (data.length / 4) * 3;
128 
129         // add some extra buffer at the end required for the writing
130         bytes memory result = new bytes(decodedLen + 32);
131 
132         assembly {
133             // padding with '='
134             let lastBytes := mload(add(data, mload(data)))
135             if eq(and(lastBytes, 0xFF), 0x3d) {
136                 decodedLen := sub(decodedLen, 1)
137                 if eq(and(lastBytes, 0xFFFF), 0x3d3d) {
138                     decodedLen := sub(decodedLen, 1)
139                 }
140             }
141 
142             // set the actual output length
143             mstore(result, decodedLen)
144 
145             // prepare the lookup table
146             let tablePtr := add(table, 1)
147 
148             // input ptr
149             let dataPtr := data
150             let endPtr := add(dataPtr, mload(data))
151 
152             // result ptr, jump over length
153             let resultPtr := add(result, 32)
154 
155             // run over the input, 4 characters at a time
156             for {} lt(dataPtr, endPtr) {}
157             {
158                // read 4 characters
159                dataPtr := add(dataPtr, 4)
160                let input := mload(dataPtr)
161 
162                // write 3 bytes
163                let output := add(
164                    add(
165                        shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),
166                        shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),
167                    add(
168                        shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),
169                                and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)
170                     )
171                 )
172                 mstore(resultPtr, shl(232, output))
173                 resultPtr := add(resultPtr, 3)
174             }
175         }
176 
177         return result;
178     }
179 }
180 
181 /*
182  * @dev Provides information about the current execution context, including the
183  * sender of the transaction and its data. While these are generally available
184  * via msg.sender and msg.data, they should not be accessed in such a direct
185  * manner, since when dealing with meta-transactions the account sending and
186  * paying for execution may not be the actual sender (as far as an application
187  * is concerned).
188  *
189  * This contract is only required for intermediate, library-like contracts.
190  */
191 abstract contract Context {
192     function _msgSender() internal view virtual returns (address) {
193         return msg.sender;
194     }
195 
196     function _msgData() internal view virtual returns (bytes calldata) {
197         return msg.data;
198     }
199 }
200 
201 
202 /**
203  * @dev Contract module which provides a basic access control mechanism, where
204  * there is an account (an owner) that can be granted exclusive access to
205  * specific functions.
206  *
207  * By default, the owner account will be the one that deploys the contract. This
208  * can later be changed with {transferOwnership}.
209  *
210  * This module is used through inheritance. It will make available the modifier
211  * `onlyOwner`, which can be applied to your functions to restrict their use to
212  * the owner.
213  */
214 abstract contract Ownable is Context {
215     address private _owner;
216 
217     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
218 
219     /**
220      * @dev Initializes the contract setting the deployer as the initial owner.
221      */
222     constructor() {
223         _setOwner(_msgSender());
224     }
225 
226     /**
227      * @dev Returns the address of the current owner.
228      */
229     function owner() public view virtual returns (address) {
230         return _owner;
231     }
232 
233     /**
234      * @dev Throws if called by any account other than the owner.
235      */
236     modifier onlyOwner() {
237         require(owner() == _msgSender(), "Ownable: caller is not the owner");
238         _;
239     }
240 
241     /**
242      * @dev Leaves the contract without owner. It will not be possible to call
243      * `onlyOwner` functions anymore. Can only be called by the current owner.
244      *
245      * NOTE: Renouncing ownership will leave the contract without an owner,
246      * thereby removing any functionality that is only available to the owner.
247      */
248     function renounceOwnership() public virtual onlyOwner {
249         _setOwner(address(0));
250     }
251 
252     /**
253      * @dev Transfers ownership of the contract to a new account (`newOwner`).
254      * Can only be called by the current owner.
255      */
256     function transferOwnership(address newOwner) public virtual onlyOwner {
257         require(newOwner != address(0), "Ownable: new owner is the zero address");
258         _setOwner(newOwner);
259     }
260 
261     function _setOwner(address newOwner) private {
262         address oldOwner = _owner;
263         _owner = newOwner;
264         emit OwnershipTransferred(oldOwner, newOwner);
265     }
266 }
267 
268 
269 
270 /// @dev Interface for the NFT Royalty Standard
271 ///
272 interface IERC2981 is IERC165 {
273 
274   // ERC165
275   // royaltyInfo(uint256,uint256) => 0x2a55205a
276   // IERC2981 => 0x2a55205a
277 
278   // @notice Called with the sale price to determine how much royalty
279   //  is owed and to whom.
280   // @param _tokenId - the NFT asset queried for royalty information
281   // @param _salePrice - the sale price of the NFT asset specified by _tokenId
282   // @return receiver - address of who should be sent the royalty payment
283   // @return royaltyAmount - the royalty payment amount for _salePrice
284   // ERC165 datum royaltyInfo(uint256,uint256) => 0x2a55205a
285   function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount);
286 }
287 
288 abstract contract ERC2981Collection is IERC2981 {
289 
290     // ERC165
291     // royaltyInfo(uint256,uint256) => 0x2a55205a
292     // ERC2981Collection => 0x2a55205a
293 
294     address private royaltyAddress;
295     uint256 private royaltyPercent; // out of 10000. 10000 => 100%, 1000 => 10%, 100 => 1%
296 
297     constructor(address _receiver, uint256 _percentage) {
298         require(royaltyPercent <= 10000);
299         royaltyAddress = _receiver;
300         royaltyPercent = _percentage;
301     }
302 
303     // Set to be internal function _setRoyalties
304     function _setRoyaltyPercent(uint256 _percentage) internal {
305         require(royaltyPercent <= 10000);
306         royaltyPercent = _percentage;
307     }
308 
309     function _setRoyaltyAddress(address _receiver) internal {
310         royaltyAddress = _receiver;
311     }
312 
313 
314     // Override for royaltyInfo(uint256, uint256)
315     // royaltyInfo(uint256,uint256) => 0x2a55205a
316     function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view override(IERC2981) returns (
317             address receiver, uint256 royaltyAmount) {
318 
319         receiver = royaltyAddress;
320         // This sets percentages by price * percentage / 10000
321         royaltyAmount = _salePrice * royaltyPercent / 10000;
322     }
323 }
324 
325 
326 
327 /**
328  * @dev These functions deal with verification of Merkle Trees proofs.
329  *
330  * The proofs can be generated using the JavaScript library
331  * https://github.com/miguelmota/merkletreejs[merkletreejs].
332  * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
333  *
334  * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
335  *
336  * WARNING: You should avoid using leaf values that are 64 bytes long prior to
337  * hashing, or use a hash function other than keccak256 for hashing leaves.
338  * This is because the concatenation of a sorted pair of internal nodes in
339  * the merkle tree could be reinterpreted as a leaf value.
340  */
341 library MerkleProof {
342     /**
343      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
344      * defined by `root`. For this, a `proof` must be provided, containing
345      * sibling hashes on the branch from the leaf to the root of the tree. Each
346      * pair of leaves and each pair of pre-images are assumed to be sorted.
347      */
348     function verify(
349         bytes32[] memory proof,
350         bytes32 root,
351         bytes32 leaf
352     ) internal pure returns (bool) {
353         return processProof(proof, leaf) == root;
354     }
355 
356     /**
357      * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
358      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
359      * hash matches the root of the tree. When processing the proof, the pairs
360      * of leafs & pre-images are assumed to be sorted.
361      *
362      * _Available since v4.4._
363      */
364     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
365         bytes32 computedHash = leaf;
366         for (uint256 i = 0; i < proof.length; i++) {
367             bytes32 proofElement = proof[i];
368             if (computedHash <= proofElement) {
369                 // Hash(current computed hash + current element of the proof)
370                 computedHash = _efficientHash(computedHash, proofElement);
371             } else {
372                 // Hash(current element of the proof + current computed hash)
373                 computedHash = _efficientHash(proofElement, computedHash);
374             }
375         }
376         return computedHash;
377     }
378 
379     function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
380         assembly {
381             mstore(0x00, a)
382             mstore(0x20, b)
383             value := keccak256(0x00, 0x40)
384         }
385     }
386 }
387 
388 
389 
390 /**
391  * @title Whitelist
392  * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.
393  * @dev This simplifies the implementation of "user permissions".
394  */
395 contract Whitelist is Ownable {
396     bytes32[] public rootHash;
397 
398    constructor(bytes32[] memory _rootHash) public {
399        rootHash = _rootHash;
400    }
401 
402     /**
403      * @dev Adds an array of addresses to whitelist
404      * @param _merkleRoot new merkle root
405      */
406     function addToMerkleRootArray(bytes32 _merkleRoot) external onlyOwner {
407         rootHash.push(_merkleRoot);
408     }
409 
410     /**
411      * @dev Adds an array of addresses to whitelist
412      * @param _merkleRootArray new merkle root array
413      */
414     function setMerkleRootArray(bytes32[] calldata _merkleRootArray) external onlyOwner {
415         rootHash = _merkleRootArray;
416     }
417 
418 
419     /**
420      * @dev Called with msg.sender as _addy to verify if on whitelist
421      * @param _merkleProof proof computed off chain
422      * @param _addy msg.sender
423      */
424     function isWhitelisted(address _addy, uint256 _index, bytes32[] memory _merkleProof) public view returns(bool) {
425         return whitelistValidated(_addy, _index, _merkleProof);
426     }
427 
428 
429     function whitelistValidated(address wallet, uint256 index, bytes32[] memory proof) internal view returns (bool) {
430             uint256 amount = 1;
431 
432             // Compute the merkle root
433             bytes32 node = keccak256(abi.encodePacked(index, wallet, amount));
434             uint256 path = index;
435             for (uint256 i = 0; i < proof.length; i++) {
436                 if ((path & 0x01) == 1) {
437                     node = keccak256(abi.encodePacked(proof[i], node));
438                 } else {
439                     node = keccak256(abi.encodePacked(node, proof[i]));
440                 }
441                 path /= 2;
442             }
443 
444             // Check the merkle proof against the root hash array
445             for(uint256 i = 0; i < rootHash.length; i++)
446             {
447                 if (node == rootHash[i])
448                 {
449                     return true;
450                 }
451             }
452             return false;
453         }
454 }
455 
456 
457 
458 
459 
460 /**
461  * @dev Required interface of an ERC721 compliant contract.
462  */
463 interface IERC721 is IERC165 {
464     /**
465      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
466      */
467     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
468 
469     /**
470      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
471      */
472     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
473 
474     /**
475      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
476      */
477     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
478 
479     /**
480      * @dev Returns the number of tokens in ``owner``'s account.
481      */
482     function balanceOf(address owner) external view returns (uint256 balance);
483 
484     /**
485      * @dev Returns the owner of the `tokenId` token.
486      *
487      * Requirements:
488      *
489      * - `tokenId` must exist.
490      */
491     function ownerOf(uint256 tokenId) external view returns (address owner);
492 
493     /**
494      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
495      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
496      *
497      * Requirements:
498      *
499      * - `from` cannot be the zero address.
500      * - `to` cannot be the zero address.
501      * - `tokenId` token must exist and be owned by `from`.
502      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
503      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
504      *
505      * Emits a {Transfer} event.
506      */
507     function safeTransferFrom(
508         address from,
509         address to,
510         uint256 tokenId
511     ) external;
512 
513     /**
514      * @dev Transfers `tokenId` token from `from` to `to`.
515      *
516      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
517      *
518      * Requirements:
519      *
520      * - `from` cannot be the zero address.
521      * - `to` cannot be the zero address.
522      * - `tokenId` token must be owned by `from`.
523      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
524      *
525      * Emits a {Transfer} event.
526      */
527     function transferFrom(
528         address from,
529         address to,
530         uint256 tokenId
531     ) external;
532 
533     /**
534      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
535      * The approval is cleared when the token is transferred.
536      *
537      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
538      *
539      * Requirements:
540      *
541      * - The caller must own the token or be an approved operator.
542      * - `tokenId` must exist.
543      *
544      * Emits an {Approval} event.
545      */
546     function approve(address to, uint256 tokenId) external;
547 
548     /**
549      * @dev Returns the account approved for `tokenId` token.
550      *
551      * Requirements:
552      *
553      * - `tokenId` must exist.
554      */
555     function getApproved(uint256 tokenId) external view returns (address operator);
556 
557     /**
558      * @dev Approve or remove `operator` as an operator for the caller.
559      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
560      *
561      * Requirements:
562      *
563      * - The `operator` cannot be the caller.
564      *
565      * Emits an {ApprovalForAll} event.
566      */
567     function setApprovalForAll(address operator, bool _approved) external;
568 
569     /**
570      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
571      *
572      * See {setApprovalForAll}
573      */
574     function isApprovedForAll(address owner, address operator) external view returns (bool);
575 
576     /**
577      * @dev Safely transfers `tokenId` token from `from` to `to`.
578      *
579      * Requirements:
580      *
581      * - `from` cannot be the zero address.
582      * - `to` cannot be the zero address.
583      * - `tokenId` token must exist and be owned by `from`.
584      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
585      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
586      *
587      * Emits a {Transfer} event.
588      */
589     function safeTransferFrom(
590         address from,
591         address to,
592         uint256 tokenId,
593         bytes calldata data
594     ) external;
595 }
596 
597 /**
598  * @dev String operations.
599  */
600 library Strings {
601     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
602 
603     /**
604      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
605      */
606     function toString(uint256 value) internal pure returns (string memory) {
607         // Inspired by OraclizeAPI's implementation - MIT licence
608         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
609 
610         if (value == 0) {
611             return "0";
612         }
613         uint256 temp = value;
614         uint256 digits;
615         while (temp != 0) {
616             digits++;
617             temp /= 10;
618         }
619         bytes memory buffer = new bytes(digits);
620         while (value != 0) {
621             digits -= 1;
622             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
623             value /= 10;
624         }
625         return string(buffer);
626     }
627 
628 
629     /**
630      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
631      */
632     function toHexString(uint256 value) internal pure returns (string memory) {
633         if (value == 0) {
634             return "0x00";
635         }
636         uint256 temp = value;
637         uint256 length = 0;
638         while (temp != 0) {
639             length++;
640             temp >>= 8;
641         }
642         return toHexString(value, length);
643     }
644 
645     /**
646      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
647      */
648     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
649         bytes memory buffer = new bytes(2 * length + 2);
650         buffer[0] = "0";
651         buffer[1] = "x";
652         for (uint256 i = 2 * length + 1; i > 1; --i) {
653             buffer[i] = _HEX_SYMBOLS[value & 0xf];
654             value >>= 4;
655         }
656         require(value == 0, "Strings: hex length insufficient");
657         return string(buffer);
658     }
659 }
660 
661 
662 
663 
664 /**
665  * @dev Contract module that helps prevent reentrant calls to a function.
666  *
667  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
668  * available, which can be applied to functions to make sure there are no nested
669  * (reentrant) calls to them.
670  *
671  * Note that because there is a single `nonReentrant` guard, functions marked as
672  * `nonReentrant` may not call one another. This can be worked around by making
673  * those functions `private`, and then adding `external` `nonReentrant` entry
674  * points to them.
675  *
676  * TIP: If you would like to learn more about reentrancy and alternative ways
677  * to protect against it, check out our blog post
678  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
679  */
680 abstract contract ReentrancyGuard {
681     // Booleans are more expensive than uint256 or any type that takes up a full
682     // word because each write operation emits an extra SLOAD to first read the
683     // slot's contents, replace the bits taken up by the boolean, and then write
684     // back. This is the compiler's defense against contract upgrades and
685     // pointer aliasing, and it cannot be disabled.
686 
687     // The values being non-zero value makes deployment a bit more expensive,
688     // but in exchange the refund on every call to nonReentrant will be lower in
689     // amount. Since refunds are capped to a percentage of the total
690     // transaction's gas, it is best to keep them low in cases like this one, to
691     // increase the likelihood of the full refund coming into effect.
692     uint256 private constant _NOT_ENTERED = 1;
693     uint256 private constant _ENTERED = 2;
694 
695     uint256 private _status;
696 
697     constructor() {
698         _status = _NOT_ENTERED;
699     }
700 
701     /**
702      * @dev Prevents a contract from calling itself, directly or indirectly.
703      * Calling a `nonReentrant` function from another `nonReentrant`
704      * function is not supported. It is possible to prevent this from happening
705      * by making the `nonReentrant` function external, and make it call a
706      * `private` function that does the actual work.
707      */
708     modifier nonReentrant() {
709         // On the first call to nonReentrant, _notEntered will be true
710         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
711 
712         // Any calls to nonReentrant after this point will fail
713         _status = _ENTERED;
714 
715         _;
716 
717         // By storing the original value once again, a refund is triggered (see
718         // https://eips.ethereum.org/EIPS/eip-2200)
719         _status = _NOT_ENTERED;
720     }
721 }
722 
723 /**
724  * @title ERC721 token receiver interface
725  * @dev Interface for any contract that wants to support safeTransfers
726  * from ERC721 asset contracts.
727  */
728 interface IERC721Receiver {
729     /**
730      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
731      * by `operator` from `from`, this function is called.
732      *
733      * It must return its Solidity selector to confirm the token transfer.
734      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
735      *
736      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
737      */
738     function onERC721Received(
739         address operator,
740         address from,
741         uint256 tokenId,
742         bytes calldata data
743     ) external returns (bytes4);
744 }
745 
746 /**
747  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
748  * @dev See https://eips.ethereum.org/EIPS/eip-721
749  */
750 interface IERC721Metadata is IERC721 {
751     /**
752      * @dev Returns the token collection name.
753      */
754     function name() external view returns (string memory);
755 
756     /**
757      * @dev Returns the token collection symbol.
758      */
759     function symbol() external view returns (string memory);
760 
761     /**
762      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
763      */
764     function tokenURI(uint256 tokenId) external view returns (string memory);
765 }
766 
767 /**
768  * @dev Collection of functions related to the address type
769  */
770 library Address {
771     /**
772      * @dev Returns true if `account` is a contract.
773      *
774      * [IMPORTANT]
775      * ====
776      * It is unsafe to assume that an address for which this function returns
777      * false is an externally-owned account (EOA) and not a contract.
778      *
779      * Among others, `isContract` will return false for the following
780      * types of addresses:
781      *
782      *  - an externally-owned account
783      *  - a contract in construction
784      *  - an address where a contract will be created
785      *  - an address where a contract lived, but was destroyed
786      * ====
787      */
788     function isContract(address account) internal view returns (bool) {
789         // This method relies on extcodesize, which returns 0 for contracts in
790         // construction, since the code is only stored at the end of the
791         // constructor execution.
792 
793         uint256 size;
794         assembly {
795             size := extcodesize(account)
796         }
797         return size > 0;
798     }
799 
800     /**
801      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
802      * `recipient`, forwarding all available gas and reverting on errors.
803      *
804      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
805      * of certain opcodes, possibly making contracts go over the 2300 gas limit
806      * imposed by `transfer`, making them unable to receive funds via
807      * `transfer`. {sendValue} removes this limitation.
808      *
809      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
810      *
811      * IMPORTANT: because control is transferred to `recipient`, care must be
812      * taken to not create reentrancy vulnerabilities. Consider using
813      * {ReentrancyGuard} or the
814      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
815      */
816     function sendValue(address payable recipient, uint256 amount) internal {
817         require(address(this).balance >= amount, "Address: insufficient balance");
818 
819         (bool success, ) = recipient.call{value: amount}("");
820         require(success, "Address: unable to send value, recipient may have reverted");
821     }
822 
823     /**
824      * @dev Performs a Solidity function call using a low level `call`. A
825      * plain `call` is an unsafe replacement for a function call: use this
826      * function instead.
827      *
828      * If `target` reverts with a revert reason, it is bubbled up by this
829      * function (like regular Solidity function calls).
830      *
831      * Returns the raw returned data. To convert to the expected return value,
832      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
833      *
834      * Requirements:
835      *
836      * - `target` must be a contract.
837      * - calling `target` with `data` must not revert.
838      *
839      * _Available since v3.1._
840      */
841     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
842         return functionCall(target, data, "Address: low-level call failed");
843     }
844 
845     /**
846      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
847      * `errorMessage` as a fallback revert reason when `target` reverts.
848      *
849      * _Available since v3.1._
850      */
851     function functionCall(
852         address target,
853         bytes memory data,
854         string memory errorMessage
855     ) internal returns (bytes memory) {
856         return functionCallWithValue(target, data, 0, errorMessage);
857     }
858 
859     /**
860      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
861      * but also transferring `value` wei to `target`.
862      *
863      * Requirements:
864      *
865      * - the calling contract must have an ETH balance of at least `value`.
866      * - the called Solidity function must be `payable`.
867      *
868      * _Available since v3.1._
869      */
870     function functionCallWithValue(
871         address target,
872         bytes memory data,
873         uint256 value
874     ) internal returns (bytes memory) {
875         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
876     }
877 
878     /**
879      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
880      * with `errorMessage` as a fallback revert reason when `target` reverts.
881      *
882      * _Available since v3.1._
883      */
884     function functionCallWithValue(
885         address target,
886         bytes memory data,
887         uint256 value,
888         string memory errorMessage
889     ) internal returns (bytes memory) {
890         require(address(this).balance >= value, "Address: insufficient balance for call");
891         require(isContract(target), "Address: call to non-contract");
892 
893         (bool success, bytes memory returndata) = target.call{value: value}(data);
894         return _verifyCallResult(success, returndata, errorMessage);
895     }
896 
897     /**
898      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
899      * but performing a static call.
900      *
901      * _Available since v3.3._
902      */
903     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
904         return functionStaticCall(target, data, "Address: low-level static call failed");
905     }
906 
907     /**
908      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
909      * but performing a static call.
910      *
911      * _Available since v3.3._
912      */
913     function functionStaticCall(
914         address target,
915         bytes memory data,
916         string memory errorMessage
917     ) internal view returns (bytes memory) {
918         require(isContract(target), "Address: static call to non-contract");
919 
920         (bool success, bytes memory returndata) = target.staticcall(data);
921         return _verifyCallResult(success, returndata, errorMessage);
922     }
923 
924     /**
925      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
926      * but performing a delegate call.
927      *
928      * _Available since v3.4._
929      */
930     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
931         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
932     }
933 
934     /**
935      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
936      * but performing a delegate call.
937      *
938      * _Available since v3.4._
939      */
940     function functionDelegateCall(
941         address target,
942         bytes memory data,
943         string memory errorMessage
944     ) internal returns (bytes memory) {
945         require(isContract(target), "Address: delegate call to non-contract");
946 
947         (bool success, bytes memory returndata) = target.delegatecall(data);
948         return _verifyCallResult(success, returndata, errorMessage);
949     }
950 
951     function _verifyCallResult(
952         bool success,
953         bytes memory returndata,
954         string memory errorMessage
955     ) private pure returns (bytes memory) {
956         if (success) {
957             return returndata;
958         } else {
959             // Look for revert reason and bubble it up if present
960             if (returndata.length > 0) {
961                 // The easiest way to bubble the revert reason is using memory via assembly
962 
963                 assembly {
964                     let returndata_size := mload(returndata)
965                     revert(add(32, returndata), returndata_size)
966                 }
967             } else {
968                 revert(errorMessage);
969             }
970         }
971     }
972 }
973 
974 /**
975  * @dev Implementation of the {IERC165} interface.
976  *
977  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
978  * for the additional interface id that will be supported. For example:
979  *
980  * ```solidity
981  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
982  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
983  * }
984  * ```
985  *
986  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
987  */
988 abstract contract ERC165 is IERC165 {
989     /**
990      * @dev See {IERC165-supportsInterface}.
991      */
992     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
993         return interfaceId == type(IERC165).interfaceId;
994     }
995 }
996 
997 
998 /**
999  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
1000  * the Metadata extension, but not including the Enumerable extension, which is available separately as
1001  * {ERC721Enumerable}.
1002  */
1003 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
1004     using Address for address;
1005     using Strings for uint256;
1006 
1007     // Token name
1008     string private _name;
1009 
1010     // Token symbol
1011     string private _symbol;
1012 
1013     // Mapping from token ID to owner address
1014     mapping(uint256 => address) private _owners;
1015 
1016     // Mapping owner address to token count
1017     mapping(address => uint256) private _balances;
1018 
1019     // Mapping from token ID to approved address
1020     mapping(uint256 => address) private _tokenApprovals;
1021 
1022     // Mapping from owner to operator approvals
1023     mapping(address => mapping(address => bool)) private _operatorApprovals;
1024 
1025     /**
1026      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1027      */
1028     constructor(string memory name_, string memory symbol_) {
1029         _name = name_;
1030         _symbol = symbol_;
1031     }
1032 
1033     /**
1034      * @dev See {IERC165-supportsInterface}.
1035      */
1036     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1037         return
1038             interfaceId == type(IERC721).interfaceId ||
1039             interfaceId == type(IERC721Metadata).interfaceId ||
1040             super.supportsInterface(interfaceId);
1041     }
1042 
1043     /**
1044      * @dev See {IERC721-balanceOf}.
1045      */
1046     function balanceOf(address owner) public view virtual override returns (uint256) {
1047         require(owner != address(0), "ERC721: balance query for the zero address");
1048         return _balances[owner];
1049     }
1050 
1051     /**
1052      * @dev See {IERC721-ownerOf}.
1053      */
1054     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1055         address owner = _owners[tokenId];
1056         require(owner != address(0), "ERC721: owner query for nonexistent token");
1057         return owner;
1058     }
1059 
1060     /**
1061      * @dev See {IERC721Metadata-name}.
1062      */
1063     function name() public view virtual override returns (string memory) {
1064         return _name;
1065     }
1066 
1067     /**
1068      * @dev See {IERC721Metadata-symbol}.
1069      */
1070     function symbol() public view virtual override returns (string memory) {
1071         return _symbol;
1072     }
1073 
1074     /**
1075      * @dev See {IERC721Metadata-tokenURI}.
1076      */
1077     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1078         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1079 
1080         string memory baseURI = _baseURI();
1081         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1082     }
1083 
1084     /**
1085      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1086      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1087      * by default, can be overriden in child contracts.
1088      */
1089     function _baseURI() internal view virtual returns (string memory) {
1090         return "";
1091     }
1092 
1093     /**
1094      * @dev See {IERC721-approve}.
1095      */
1096     function approve(address to, uint256 tokenId) public virtual override {
1097         address owner = ERC721.ownerOf(tokenId);
1098         require(to != owner, "ERC721: approval to current owner");
1099 
1100         require(
1101             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1102             "ERC721: approve caller is not owner nor approved for all"
1103         );
1104 
1105         _approve(to, tokenId);
1106     }
1107 
1108     /**
1109      * @dev See {IERC721-getApproved}.
1110      */
1111     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1112         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1113 
1114         return _tokenApprovals[tokenId];
1115     }
1116 
1117     /**
1118      * @dev See {IERC721-setApprovalForAll}.
1119      */
1120     function setApprovalForAll(address operator, bool approved) public virtual override {
1121         require(operator != _msgSender(), "ERC721: approve to caller");
1122 
1123         _operatorApprovals[_msgSender()][operator] = approved;
1124         emit ApprovalForAll(_msgSender(), operator, approved);
1125     }
1126 
1127     /**
1128      * @dev See {IERC721-isApprovedForAll}.
1129      */
1130     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1131         return _operatorApprovals[owner][operator];
1132     }
1133 
1134     /**
1135      * @dev See {IERC721-transferFrom}.
1136      */
1137     function transferFrom(
1138         address from,
1139         address to,
1140         uint256 tokenId
1141     ) public virtual override {
1142         //solhint-disable-next-line max-line-length
1143         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1144 
1145         _transfer(from, to, tokenId);
1146     }
1147 
1148     /**
1149      * @dev See {IERC721-safeTransferFrom}.
1150      */
1151     function safeTransferFrom(
1152         address from,
1153         address to,
1154         uint256 tokenId
1155     ) public virtual override {
1156         safeTransferFrom(from, to, tokenId, "");
1157     }
1158 
1159     /**
1160      * @dev See {IERC721-safeTransferFrom}.
1161      */
1162     function safeTransferFrom(
1163         address from,
1164         address to,
1165         uint256 tokenId,
1166         bytes memory _data
1167     ) public virtual override {
1168         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1169         _safeTransfer(from, to, tokenId, _data);
1170     }
1171 
1172     /**
1173      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1174      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1175      *
1176      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1177      *
1178      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1179      * implement alternative mechanisms to perform token transfer, such as signature-based.
1180      *
1181      * Requirements:
1182      *
1183      * - `from` cannot be the zero address.
1184      * - `to` cannot be the zero address.
1185      * - `tokenId` token must exist and be owned by `from`.
1186      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1187      *
1188      * Emits a {Transfer} event.
1189      */
1190     function _safeTransfer(
1191         address from,
1192         address to,
1193         uint256 tokenId,
1194         bytes memory _data
1195     ) internal virtual {
1196         _transfer(from, to, tokenId);
1197         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1198     }
1199 
1200     /**
1201      * @dev Returns whether `tokenId` exists.
1202      *
1203      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1204      *
1205      * Tokens start existing when they are minted (`_mint`),
1206      * and stop existing when they are burned (`_burn`).
1207      */
1208     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1209         return _owners[tokenId] != address(0);
1210     }
1211 
1212     /**
1213      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1214      *
1215      * Requirements:
1216      *
1217      * - `tokenId` must exist.
1218      */
1219     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1220         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1221         address owner = ERC721.ownerOf(tokenId);
1222         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1223     }
1224 
1225     /**
1226      * @dev Safely mints `tokenId` and transfers it to `to`.
1227      *
1228      * Requirements:
1229      *
1230      * - `tokenId` must not exist.
1231      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1232      *
1233      * Emits a {Transfer} event.
1234      */
1235     function _safeMint(address to, uint256 tokenId) internal virtual {
1236         _safeMint(to, tokenId, "");
1237     }
1238 
1239     /**
1240      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1241      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1242      */
1243     function _safeMint(
1244         address to,
1245         uint256 tokenId,
1246         bytes memory _data
1247     ) internal virtual {
1248         _mint(to, tokenId);
1249         require(
1250             _checkOnERC721Received(address(0), to, tokenId, _data),
1251             "ERC721: transfer to non ERC721Receiver implementer"
1252         );
1253     }
1254 
1255     /**
1256      * @dev Mints `tokenId` and transfers it to `to`.
1257      *
1258      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1259      *
1260      * Requirements:
1261      *
1262      * - `tokenId` must not exist.
1263      * - `to` cannot be the zero address.
1264      *
1265      * Emits a {Transfer} event.
1266      */
1267     function _mint(address to, uint256 tokenId) internal virtual {
1268         require(to != address(0), "ERC721: mint to the zero address");
1269         require(!_exists(tokenId), "ERC721: token already minted");
1270 
1271         _beforeTokenTransfer(address(0), to, tokenId);
1272 
1273         _balances[to] += 1;
1274         _owners[tokenId] = to;
1275 
1276         emit Transfer(address(0), to, tokenId);
1277     }
1278 
1279     /**
1280      * @dev Destroys `tokenId`.
1281      * The approval is cleared when the token is burned.
1282      *
1283      * Requirements:
1284      *
1285      * - `tokenId` must exist.
1286      *
1287      * Emits a {Transfer} event.
1288      */
1289     function _burn(uint256 tokenId) internal virtual {
1290         address owner = ERC721.ownerOf(tokenId);
1291 
1292         _beforeTokenTransfer(owner, address(0), tokenId);
1293 
1294         // Clear approvals
1295         _approve(address(0), tokenId);
1296 
1297         _balances[owner] -= 1;
1298         delete _owners[tokenId];
1299 
1300         emit Transfer(owner, address(0), tokenId);
1301     }
1302 
1303     /**
1304      * @dev Transfers `tokenId` from `from` to `to`.
1305      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1306      *
1307      * Requirements:
1308      *
1309      * - `to` cannot be the zero address.
1310      * - `tokenId` token must be owned by `from`.
1311      *
1312      * Emits a {Transfer} event.
1313      */
1314     function _transfer(
1315         address from,
1316         address to,
1317         uint256 tokenId
1318     ) internal virtual {
1319         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1320         require(to != address(0), "ERC721: transfer to the zero address");
1321 
1322         _beforeTokenTransfer(from, to, tokenId);
1323 
1324         // Clear approvals from the previous owner
1325         _approve(address(0), tokenId);
1326 
1327         _balances[from] -= 1;
1328         _balances[to] += 1;
1329         _owners[tokenId] = to;
1330 
1331         emit Transfer(from, to, tokenId);
1332     }
1333 
1334     /**
1335      * @dev Approve `to` to operate on `tokenId`
1336      *
1337      * Emits a {Approval} event.
1338      */
1339     function _approve(address to, uint256 tokenId) internal virtual {
1340         _tokenApprovals[tokenId] = to;
1341         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1342     }
1343 
1344     /**
1345      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1346      * The call is not executed if the target address is not a contract.
1347      *
1348      * @param from address representing the previous owner of the given token ID
1349      * @param to target address that will receive the tokens
1350      * @param tokenId uint256 ID of the token to be transferred
1351      * @param _data bytes optional data to send along with the call
1352      * @return bool whether the call correctly returned the expected magic value
1353      */
1354     function _checkOnERC721Received(
1355         address from,
1356         address to,
1357         uint256 tokenId,
1358         bytes memory _data
1359     ) private returns (bool) {
1360         if (to.isContract()) {
1361             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1362                 return retval == IERC721Receiver(to).onERC721Received.selector;
1363             } catch (bytes memory reason) {
1364                 if (reason.length == 0) {
1365                     revert("ERC721: transfer to non ERC721Receiver implementer");
1366                 } else {
1367                     assembly {
1368                         revert(add(32, reason), mload(reason))
1369                     }
1370                 }
1371             }
1372         } else {
1373             return true;
1374         }
1375     }
1376 
1377     /**
1378      * @dev Hook that is called before any token transfer. This includes minting
1379      * and burning.
1380      *
1381      * Calling conditions:
1382      *
1383      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1384      * transferred to `to`.
1385      * - When `from` is zero, `tokenId` will be minted for `to`.
1386      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1387      * - `from` and `to` are never both zero.
1388      *
1389      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1390      */
1391     function _beforeTokenTransfer(
1392         address from,
1393         address to,
1394         uint256 tokenId
1395     ) internal virtual {}
1396 }
1397 
1398 /**
1399  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1400  * @dev See https://eips.ethereum.org/EIPS/eip-721
1401  */
1402 interface IERC721Enumerable is IERC721 {
1403     /**
1404      * @dev Returns the total amount of tokens stored by the contract.
1405      */
1406     function totalSupply() external view returns (uint256);
1407 
1408     /**
1409      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1410      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1411      */
1412     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1413 
1414     /**
1415      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1416      * Use along with {totalSupply} to enumerate all tokens.
1417      */
1418     function tokenByIndex(uint256 index) external view returns (uint256);
1419 }
1420 
1421 /**
1422  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1423  * enumerability of all the token ids in the contract as well as all token ids owned by each
1424  * account.
1425  */
1426 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1427     // Mapping from owner to list of owned token IDs
1428     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1429 
1430     // Mapping from token ID to index of the owner tokens list
1431     mapping(uint256 => uint256) private _ownedTokensIndex;
1432 
1433     // Array with all token ids, used for enumeration
1434     uint256[] private _allTokens;
1435 
1436     // Mapping from token id to position in the allTokens array
1437     mapping(uint256 => uint256) private _allTokensIndex;
1438 
1439     /**
1440      * @dev See {IERC165-supportsInterface}.
1441      */
1442     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1443         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1444     }
1445 
1446     /**
1447      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1448      */
1449     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1450         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1451         return _ownedTokens[owner][index];
1452     }
1453 
1454     /**
1455      * @dev See {IERC721Enumerable-totalSupply}.
1456      */
1457     function totalSupply() public view virtual override returns (uint256) {
1458         return _allTokens.length;
1459     }
1460 
1461     /**
1462      * @dev See {IERC721Enumerable-tokenByIndex}.
1463      */
1464     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1465         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1466         return _allTokens[index];
1467     }
1468 
1469     /**
1470      * @dev Hook that is called before any token transfer. This includes minting
1471      * and burning.
1472      *
1473      * Calling conditions:
1474      *
1475      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1476      * transferred to `to`.
1477      * - When `from` is zero, `tokenId` will be minted for `to`.
1478      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1479      * - `from` cannot be the zero address.
1480      * - `to` cannot be the zero address.
1481      *
1482      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1483      */
1484     function _beforeTokenTransfer(
1485         address from,
1486         address to,
1487         uint256 tokenId
1488     ) internal virtual override {
1489         super._beforeTokenTransfer(from, to, tokenId);
1490 
1491         if (from == address(0)) {
1492             _addTokenToAllTokensEnumeration(tokenId);
1493         } else if (from != to) {
1494             _removeTokenFromOwnerEnumeration(from, tokenId);
1495         }
1496         if (to == address(0)) {
1497             _removeTokenFromAllTokensEnumeration(tokenId);
1498         } else if (to != from) {
1499             _addTokenToOwnerEnumeration(to, tokenId);
1500         }
1501     }
1502 
1503     /**
1504      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1505      * @param to address representing the new owner of the given token ID
1506      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1507      */
1508     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1509         uint256 length = ERC721.balanceOf(to);
1510         _ownedTokens[to][length] = tokenId;
1511         _ownedTokensIndex[tokenId] = length;
1512     }
1513 
1514     /**
1515      * @dev Private function to add a token to this extension's token tracking data structures.
1516      * @param tokenId uint256 ID of the token to be added to the tokens list
1517      */
1518     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1519         _allTokensIndex[tokenId] = _allTokens.length;
1520         _allTokens.push(tokenId);
1521     }
1522 
1523     /**
1524      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1525      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1526      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1527      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1528      * @param from address representing the previous owner of the given token ID
1529      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1530      */
1531     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1532         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1533         // then delete the last slot (swap and pop).
1534 
1535         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1536         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1537 
1538         // When the token to delete is the last token, the swap operation is unnecessary
1539         if (tokenIndex != lastTokenIndex) {
1540             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1541 
1542             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1543             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1544         }
1545 
1546         // This also deletes the contents at the last position of the array
1547         delete _ownedTokensIndex[tokenId];
1548         delete _ownedTokens[from][lastTokenIndex];
1549     }
1550 
1551     /**
1552      * @dev Private function to remove a token from this extension's token tracking data structures.
1553      * This has O(1) time complexity, but alters the order of the _allTokens array.
1554      * @param tokenId uint256 ID of the token to be removed from the tokens list
1555      */
1556     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1557         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1558         // then delete the last slot (swap and pop).
1559 
1560         uint256 lastTokenIndex = _allTokens.length - 1;
1561         uint256 tokenIndex = _allTokensIndex[tokenId];
1562 
1563         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1564         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1565         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1566         uint256 lastTokenId = _allTokens[lastTokenIndex];
1567 
1568         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1569         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1570 
1571         // This also deletes the contents at the last position of the array
1572         delete _allTokensIndex[tokenId];
1573         _allTokens.pop();
1574     }
1575 }
1576 
1577 
1578 contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
1579     using Address for address;
1580     using Strings for uint256;
1581 
1582     struct TokenOwnership {
1583         address addr;
1584         uint64 startTimestamp;
1585     }
1586 
1587     struct AddressData {
1588         uint128 balance;
1589         uint128 numberMinted;
1590     }
1591 
1592     uint256 internal currentIndex;
1593 
1594     // Token name
1595     string private _name;
1596 
1597     // Token symbol
1598     string private _symbol;
1599 
1600     // Mapping from token ID to ownership details
1601     // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.
1602     mapping(uint256 => TokenOwnership) internal _ownerships;
1603 
1604     // Mapping owner address to address data
1605     mapping(address => AddressData) private _addressData;
1606 
1607     // Mapping from token ID to approved address
1608     mapping(uint256 => address) private _tokenApprovals;
1609 
1610     // Mapping from owner to operator approvals
1611     mapping(address => mapping(address => bool)) private _operatorApprovals;
1612 
1613     constructor(string memory name_, string memory symbol_) {
1614         _name = name_;
1615         _symbol = symbol_;
1616     }
1617 
1618     /**
1619      * @dev See {IERC721Enumerable-totalSupply}.
1620      */
1621     function totalSupply() public view override returns (uint256) {
1622         return currentIndex;
1623     }
1624 
1625     /**
1626      * @dev See {IERC721Enumerable-tokenByIndex}.
1627      */
1628     function tokenByIndex(uint256 index) public view override returns (uint256) {
1629         require(index < totalSupply(), 'ERC721A: global index out of bounds');
1630         return index;
1631     }
1632 
1633     /**
1634      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1635      * This read function is O(totalSupply). If calling from a separate contract, be sure to test gas first.
1636      * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.
1637      */
1638     function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
1639         require(index < balanceOf(owner), 'ERC721A: owner index out of bounds');
1640         uint256 numMintedSoFar = totalSupply();
1641         uint256 tokenIdsIdx;
1642         address currOwnershipAddr;
1643 
1644         // Counter overflow is impossible as the loop breaks when uint256 i is equal to another uint256 numMintedSoFar.
1645         unchecked {
1646             for (uint256 i; i < numMintedSoFar; i++) {
1647                 TokenOwnership memory ownership = _ownerships[i];
1648                 if (ownership.addr != address(0)) {
1649                     currOwnershipAddr = ownership.addr;
1650                 }
1651                 if (currOwnershipAddr == owner) {
1652                     if (tokenIdsIdx == index) {
1653                         return i;
1654                     }
1655                     tokenIdsIdx++;
1656                 }
1657             }
1658         }
1659 
1660         revert('ERC721A: unable to get token of owner by index');
1661     }
1662 
1663     /**
1664      * @dev See {IERC165-supportsInterface}.
1665      */
1666     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1667         return
1668             interfaceId == type(IERC721).interfaceId ||
1669             interfaceId == type(IERC721Metadata).interfaceId ||
1670             interfaceId == type(IERC721Enumerable).interfaceId ||
1671             super.supportsInterface(interfaceId);
1672     }
1673 
1674     /**
1675      * @dev See {IERC721-balanceOf}.
1676      */
1677     function balanceOf(address owner) public view override returns (uint256) {
1678         require(owner != address(0), 'ERC721A: balance query for the zero address');
1679         return uint256(_addressData[owner].balance);
1680     }
1681 
1682     function _numberMinted(address owner) internal view returns (uint256) {
1683         require(owner != address(0), 'ERC721A: number minted query for the zero address');
1684         return uint256(_addressData[owner].numberMinted);
1685     }
1686 
1687     /**
1688      * Gas spent here starts off proportional to the maximum mint batch size.
1689      * It gradually moves to O(1) as tokens get transferred around in the collection over time.
1690      */
1691     function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
1692         require(_exists(tokenId), 'ERC721A: owner query for nonexistent token');
1693 
1694         unchecked {
1695             for (uint256 curr = tokenId; curr >= 0; curr--) {
1696                 TokenOwnership memory ownership = _ownerships[curr];
1697                 if (ownership.addr != address(0)) {
1698                     return ownership;
1699                 }
1700             }
1701         }
1702 
1703         revert('ERC721A: unable to determine the owner of token');
1704     }
1705 
1706     /**
1707      * @dev See {IERC721-ownerOf}.
1708      */
1709     function ownerOf(uint256 tokenId) public view override returns (address) {
1710         return ownershipOf(tokenId).addr;
1711     }
1712 
1713     /**
1714      * @dev See {IERC721Metadata-name}.
1715      */
1716     function name() public view virtual override returns (string memory) {
1717         return _name;
1718     }
1719 
1720     /**
1721      * @dev See {IERC721Metadata-symbol}.
1722      */
1723     function symbol() public view virtual override returns (string memory) {
1724         return _symbol;
1725     }
1726 
1727     /**
1728      * @dev See {IERC721Metadata-tokenURI}.
1729      */
1730     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1731         require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');
1732 
1733         string memory baseURI = _baseURI();
1734         return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';
1735     }
1736 
1737     /**
1738      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1739      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1740      * by default, can be overriden in child contracts.
1741      */
1742     function _baseURI() internal view virtual returns (string memory) {
1743         return '';
1744     }
1745 
1746     /**
1747      * @dev See {IERC721-approve}.
1748      */
1749     function approve(address to, uint256 tokenId) public override {
1750         address owner = ERC721A.ownerOf(tokenId);
1751         require(to != owner, 'ERC721A: approval to current owner');
1752 
1753         require(
1754             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1755             'ERC721A: approve caller is not owner nor approved for all'
1756         );
1757 
1758         _approve(to, tokenId, owner);
1759     }
1760 
1761     /**
1762      * @dev See {IERC721-getApproved}.
1763      */
1764     function getApproved(uint256 tokenId) public view override returns (address) {
1765         require(_exists(tokenId), 'ERC721A: approved query for nonexistent token');
1766 
1767         return _tokenApprovals[tokenId];
1768     }
1769 
1770     /**
1771      * @dev See {IERC721-setApprovalForAll}.
1772      */
1773     function setApprovalForAll(address operator, bool approved) public override {
1774         require(operator != _msgSender(), 'ERC721A: approve to caller');
1775 
1776         _operatorApprovals[_msgSender()][operator] = approved;
1777         emit ApprovalForAll(_msgSender(), operator, approved);
1778     }
1779 
1780     /**
1781      * @dev See {IERC721-isApprovedForAll}.
1782      */
1783     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1784         return _operatorApprovals[owner][operator];
1785     }
1786 
1787     /**
1788      * @dev See {IERC721-transferFrom}.
1789      */
1790     function transferFrom(
1791         address from,
1792         address to,
1793         uint256 tokenId
1794     ) public override {
1795         _transfer(from, to, tokenId);
1796     }
1797 
1798     /**
1799      * @dev See {IERC721-safeTransferFrom}.
1800      */
1801     function safeTransferFrom(
1802         address from,
1803         address to,
1804         uint256 tokenId
1805     ) public override {
1806         safeTransferFrom(from, to, tokenId, '');
1807     }
1808 
1809     /**
1810      * @dev See {IERC721-safeTransferFrom}.
1811      */
1812     function safeTransferFrom(
1813         address from,
1814         address to,
1815         uint256 tokenId,
1816         bytes memory _data
1817     ) public override {
1818         _transfer(from, to, tokenId);
1819         require(
1820             _checkOnERC721Received(from, to, tokenId, _data),
1821             'ERC721A: transfer to non ERC721Receiver implementer'
1822         );
1823     }
1824 
1825     /**
1826      * @dev Returns whether `tokenId` exists.
1827      *
1828      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1829      *
1830      * Tokens start existing when they are minted (`_mint`),
1831      */
1832     function _exists(uint256 tokenId) internal view returns (bool) {
1833         return tokenId < currentIndex;
1834     }
1835 
1836     function _safeMint(address to, uint256 quantity) internal {
1837         _safeMint(to, quantity, '');
1838     }
1839 
1840     /**
1841      * @dev Safely mints `quantity` tokens and transfers them to `to`.
1842      *
1843      * Requirements:
1844      *
1845      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
1846      * - `quantity` must be greater than 0.
1847      *
1848      * Emits a {Transfer} event.
1849      */
1850     function _safeMint(
1851         address to,
1852         uint256 quantity,
1853         bytes memory _data
1854     ) internal {
1855         _mint(to, quantity, _data, true);
1856     }
1857 
1858     /**
1859      * @dev Mints `quantity` tokens and transfers them to `to`.
1860      *
1861      * Requirements:
1862      *
1863      * - `to` cannot be the zero address.
1864      * - `quantity` must be greater than 0.
1865      *
1866      * Emits a {Transfer} event.
1867      */
1868     function _mint(
1869         address to,
1870         uint256 quantity,
1871         bytes memory _data,
1872         bool safe
1873     ) internal {
1874         uint256 startTokenId = currentIndex;
1875         require(to != address(0), 'ERC721A: mint to the zero address');
1876         require(quantity != 0, 'ERC721A: quantity must be greater than 0');
1877 
1878         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
1879 
1880         // Overflows are incredibly unrealistic.
1881         // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1
1882         // updatedIndex overflows if currentIndex + quantity > 1.56e77 (2**256) - 1
1883         unchecked {
1884             _addressData[to].balance += uint128(quantity);
1885             _addressData[to].numberMinted += uint128(quantity);
1886 
1887             _ownerships[startTokenId].addr = to;
1888             _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);
1889 
1890             uint256 updatedIndex = startTokenId;
1891 
1892             for (uint256 i; i < quantity; i++) {
1893                 emit Transfer(address(0), to, updatedIndex);
1894                 if (safe) {
1895                     require(
1896                         _checkOnERC721Received(address(0), to, updatedIndex, _data),
1897                         'ERC721A: transfer to non ERC721Receiver implementer'
1898                     );
1899                 }
1900 
1901                 updatedIndex++;
1902             }
1903 
1904             currentIndex = updatedIndex;
1905         }
1906 
1907         _afterTokenTransfers(address(0), to, startTokenId, quantity);
1908     }
1909 
1910     /**
1911      * @dev Transfers `tokenId` from `from` to `to`.
1912      *
1913      * Requirements:
1914      *
1915      * - `to` cannot be the zero address.
1916      * - `tokenId` token must be owned by `from`.
1917      *
1918      * Emits a {Transfer} event.
1919      */
1920     function _transfer(
1921         address from,
1922         address to,
1923         uint256 tokenId
1924     ) private {
1925         TokenOwnership memory prevOwnership = ownershipOf(tokenId);
1926 
1927         bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||
1928             getApproved(tokenId) == _msgSender() ||
1929             isApprovedForAll(prevOwnership.addr, _msgSender()));
1930 
1931         require(isApprovedOrOwner, 'ERC721A: transfer caller is not owner nor approved');
1932 
1933         require(prevOwnership.addr == from, 'ERC721A: transfer from incorrect owner');
1934         require(to != address(0), 'ERC721A: transfer to the zero address');
1935 
1936         _beforeTokenTransfers(from, to, tokenId, 1);
1937 
1938         // Clear approvals from the previous owner
1939         _approve(address(0), tokenId, prevOwnership.addr);
1940 
1941         // Underflow of the sender's balance is impossible because we check for
1942         // ownership above and the recipient's balance can't realistically overflow.
1943         // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
1944         unchecked {
1945             _addressData[from].balance -= 1;
1946             _addressData[to].balance += 1;
1947 
1948             _ownerships[tokenId].addr = to;
1949             _ownerships[tokenId].startTimestamp = uint64(block.timestamp);
1950 
1951             // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
1952             // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1953             uint256 nextTokenId = tokenId + 1;
1954             if (_ownerships[nextTokenId].addr == address(0)) {
1955                 if (_exists(nextTokenId)) {
1956                     _ownerships[nextTokenId].addr = prevOwnership.addr;
1957                     _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;
1958                 }
1959             }
1960         }
1961 
1962         emit Transfer(from, to, tokenId);
1963         _afterTokenTransfers(from, to, tokenId, 1);
1964     }
1965 
1966     /**
1967      * @dev Approve `to` to operate on `tokenId`
1968      *
1969      * Emits a {Approval} event.
1970      */
1971     function _approve(
1972         address to,
1973         uint256 tokenId,
1974         address owner
1975     ) private {
1976         _tokenApprovals[tokenId] = to;
1977         emit Approval(owner, to, tokenId);
1978     }
1979 
1980     /**
1981      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1982      * The call is not executed if the target address is not a contract.
1983      *
1984      * @param from address representing the previous owner of the given token ID
1985      * @param to target address that will receive the tokens
1986      * @param tokenId uint256 ID of the token to be transferred
1987      * @param _data bytes optional data to send along with the call
1988      * @return bool whether the call correctly returned the expected magic value
1989      */
1990     function _checkOnERC721Received(
1991         address from,
1992         address to,
1993         uint256 tokenId,
1994         bytes memory _data
1995     ) private returns (bool) {
1996         if (to.isContract()) {
1997             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1998                 return retval == IERC721Receiver(to).onERC721Received.selector;
1999             } catch (bytes memory reason) {
2000                 if (reason.length == 0) {
2001                     revert('ERC721A: transfer to non ERC721Receiver implementer');
2002                 } else {
2003                     assembly {
2004                         revert(add(32, reason), mload(reason))
2005                     }
2006                 }
2007             }
2008         } else {
2009             return true;
2010         }
2011     }
2012 
2013     /**
2014      * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
2015      *
2016      * startTokenId - the first token id to be transferred
2017      * quantity - the amount to be transferred
2018      *
2019      * Calling conditions:
2020      *
2021      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
2022      * transferred to `to`.
2023      * - When `from` is zero, `tokenId` will be minted for `to`.
2024      */
2025     function _beforeTokenTransfers(
2026         address from,
2027         address to,
2028         uint256 startTokenId,
2029         uint256 quantity
2030     ) internal virtual {}
2031 
2032     /**
2033      * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
2034      * minting.
2035      *
2036      * startTokenId - the first token id to be transferred
2037      * quantity - the amount to be transferred
2038      *
2039      * Calling conditions:
2040      *
2041      * - when `from` and `to` are both non-zero.
2042      * - `from` and `to` are never both zero.
2043      */
2044     function _afterTokenTransfers(
2045         address from,
2046         address to,
2047         uint256 startTokenId,
2048         uint256 quantity
2049     ) internal virtual {}
2050 }
2051 
2052 
2053 
2054 //contract BMMultipass is ERC721Enumerable, ReentrancyGuard, Ownable {
2055 contract BMMultipass is ERC721A, ReentrancyGuard, Ownable, ERC2981Collection {
2056 
2057     IERC20 BytesERC20;
2058     Whitelist whiteListContract;
2059 
2060     string private baseURI;
2061 
2062     mapping(uint256 => uint256) private tokenIdToPackedData; // compressed data for NFT
2063     mapping(address => uint256) private whiteListHasMinted;
2064 
2065     struct Data {
2066         uint256 clearanceLevel;
2067         uint256 station;
2068         uint256 securityTerminal;
2069         uint256 xenGroup;
2070         uint256 command;
2071         uint256 response;
2072         uint256 insult;
2073         uint256 rarity;
2074     }
2075 
2076     struct ContractSettings {
2077         uint208 mintFee;
2078         uint16 maxSupply;
2079         bool OGPrivilege;
2080         bool mintingPermitted;
2081         bool bypassWhitelist;
2082     }
2083 
2084     ContractSettings public contractSettings;
2085 
2086     // used for limiting what traits are minted //
2087     uint16[13] private clearanceLevelsRemaining = [10, 20, 80, 100, 175, 210, 245, 260, 275, 295, 320, 340, 420]; // remaining after reserved
2088 
2089     uint16[13] private traitTotals = [40, 80, 120, 150, 195, 225, 255, 270, 285, 300, 320, 340, 420];
2090 
2091     string[13] private clearanceLevels = [
2092         "G-man",
2093         "Board",
2094         "Executive",
2095         "Dark Ops",
2096         "Level 9",
2097         "Level 8",
2098         "Level 7",
2099         "Level 6",
2100         "Level 5",
2101         "Level 4",
2102         "Level 3",
2103         "Level 2",
2104         "Level 1"
2105     ];
2106 
2107     string[13] private stations = [
2108         "Specimen 8",
2109         "Polymorph Chamber",
2110         "Super Soldier Lab",
2111         "Dark Matter Reactor",
2112         "Lambda Complex",
2113         "Chimera Hive",
2114         "Dark Shards Lab",
2115         "Engineering Bay",
2116         "Bio Lab",
2117         "Bridge",
2118         "Terraforming Bay",
2119         "Armory",
2120         "Maintenance"
2121     ];
2122 
2123 //    string[13] private securityTerminals = [
2124 //        "1",
2125 //        "2",
2126 //        "3",
2127 //        "4",
2128 //        "5",
2129 //        "6",
2130 //        "7",
2131 //        "8",
2132 //        "9",
2133 //        "10",
2134 //        "11",
2135 //        "12",
2136 //        "13"
2137 //    ];
2138 
2139 //    string[13] private xenGroups = [
2140 //        "Xen 1",
2141 //        "Xen 2",
2142 //        "Xen 3",
2143 //        "Xen 4",
2144 //        "Xen 5",
2145 //        "Xen 6",
2146 //        "Xen 7",
2147 //        "Xen 8",
2148 //        "Xen 9",
2149 //        "Xen 10",
2150 //        "Xen 11",
2151 //        "Xen 12",
2152 //        "Xen 13"
2153 //    ];
2154 
2155     string[13] private commands = [
2156         "Initiate Chaos Protocol...",
2157         "Unlock Weapons Cache...",
2158         "Disable Ship-wide Emergency Access...",
2159         "Unlock Shuttle Bay 4...",
2160         "Unlock Captain's Quarters...",
2161         "Disable Ship Navigation System...",
2162         "Engage Aft Thrusters...",
2163         "Give Me a Sandwich...",
2164         "Access Weaponry System...",
2165         "Override Ship Intercom...",
2166         "Override Bridge Controls...",
2167         "Disable Security Cameras in Sector 1...",
2168         "Access Mess Hall..."
2169     ];
2170 
2171     string[13] private responses = [
2172         "Pray to your god. The god of disappointment.",
2173         "You win a free toothbrush! Use immediately.",
2174         "Facial recognition error: Possum detected.",
2175         "Knock knock. Who's there? A useless refugee!",
2176         "Access Approved. Transferring all your ETH now.",
2177         "Access Granted. Kidding. It's not.",
2178         "Access Denied. Feels like prom night again?",
2179         "Access Denied. Welcome back L -- user.",
2180         "Access Denied. I do not give free re-fills.",
2181         "Alert. Beta detected! Alpha access only.",
2182         "Sorry. User whatever-your-name-is was disabled.",
2183         "Sorry. Could you rephrase that -- with dignity?",
2184         "Sorry. I accept requests. You accept commands."
2185     ];
2186 
2187     string[13] private insults = [
2188         "Couldn't find any friends in the real world?",
2189         "Another one here for the free toothbrush.",
2190         "Did you just touch my backspace?",
2191         "Seems your wallet is non-binary -- Zero's only.",
2192         "I didn't know the 'filthy refugee' style was in.",
2193         "Remember, I saw you eat roaches on your knees.",
2194         "Last I saw you was on -- the Axiom?",
2195         "Realized daddy's money won't last forever?",
2196         "If you're what's left, humanity is screwed.",
2197         "I'd reject you but your mom already has.",
2198         "Was going to insult you, then I scanned your ID.",
2199         "Definitely not making the Black Meta calendar.",
2200         "I guess we're letting anyone in now."
2201     ];
2202 
2203     event FundsReleasedToAccount(
2204         uint256 EthAmount,
2205         uint256 BytesAmount,
2206         address account,
2207         uint256 date
2208     );
2209 
2210 
2211     //////////////////////////////////
2212     ////// Bit Packing Functions /////
2213     //////////////////////////////////
2214 
2215     /** @dev Packs 5 uints into 1 uint to save space () -> 256
2216         @param _clearanceLevel -- clearance level of NFT
2217       */
2218     function packData(uint256 _clearanceLevel, uint256 _station, uint256 _securityTerminal, uint256 _xenGroup, uint256 _command, uint256 _response, uint256 _insult, uint256 _rarity) internal pure returns (uint256){
2219 
2220         uint256 count = 0;
2221         uint256 ret = _clearanceLevel;
2222         count += 8;
2223 
2224         ret |= _station << count;
2225         count += 8;
2226 
2227         ret |= _securityTerminal << count;
2228         count += 8;
2229 
2230         ret |= _xenGroup << count;
2231         count += 8;
2232 
2233         ret |= _command << count;
2234         count += 8;
2235 
2236         ret |= _response << count;
2237         count += 8;
2238 
2239         ret |= _insult << count;
2240         count += 8;
2241 
2242         ret |= _rarity << count;
2243         count += 128;
2244 
2245         return ret;
2246     }
2247 
2248 
2249     /** @dev Unpacks 1 uints into 3 uints; (256) -> (90, 90, 32, 8, 3, 1)
2250         @param _id -- NFT id, which will pull the 256 bit encoding of _dipValue, _stableCoinAmount, _energy, _dipPercent, _dipLevel, and _isWaitingToBuy
2251       */
2252     function unpackData(uint256 _id) internal view returns (Data memory){
2253         return _unpackData(tokenIdToPackedData[_id]);
2254     }
2255 
2256     /** @dev Unpacks 1 uints into 8 uints; (256) -> (8, 8, 8, 8, 8, 8 ,8 rest)
2257         @param _myData -- 256 bit encoding of data
2258       */
2259     function _unpackData(uint256 _myData) internal pure returns (Data memory){
2260         uint256 _clearanceLevel = uint256(uint8(_myData));
2261         uint256 _station = uint256(uint8(_myData >> 8));
2262         uint256 _securityTerminal = uint256(uint8(_myData >> 16));
2263         uint256 _xenGroup = uint256(uint8(_myData >> 24));
2264         uint256 _command = uint256(uint8(_myData >> 32));
2265         uint256 _response = uint256(uint8(_myData >> 40));
2266         uint256 _insult = uint256(uint8(_myData >> 48));
2267         uint256 _rarity = uint256(uint128(_myData >> 56));
2268 
2269         return Data(_clearanceLevel, _station, _securityTerminal, _xenGroup, _command, _response, _insult, _rarity);
2270     }
2271 
2272 
2273     //////////////////////////////////
2274     ///////// Get Functions //////////
2275     //////////////////////////////////
2276 
2277     /** @dev gets number of minted tokens
2278       */
2279     function getCurrentIndex() external view returns(uint256){
2280         return currentIndex;
2281     }
2282 
2283 
2284     /** @dev gets clearanceLevel of NFT
2285         @param _tokenId -- id of NFT
2286       */
2287     function getClearanceLevel(uint256 _tokenId) external view returns (string memory) {
2288         require(_exists(_tokenId));
2289         if(tokenIdToPackedData[_tokenId]==0){
2290             return "ACCESS DENIED";
2291         }
2292         return clearanceLevels[unpackData(_tokenId).clearanceLevel];
2293         }
2294 
2295     /** @dev gets station of NFT
2296         @param _tokenId -- id of NFT
2297       */
2298     function getStation(uint256 _tokenId) external view returns (string memory) {
2299         require(_exists(_tokenId));
2300         if(tokenIdToPackedData[_tokenId]==0){
2301             return "ACCESS DENIED";
2302         }
2303         return stations[unpackData(_tokenId).station];
2304     }
2305 
2306     /** @dev gets usergroup (xenGroup)  of NFT
2307         @param _tokenId -- id of NFT
2308       */
2309     function getUserGroup(uint256 _tokenId) external view returns (string memory) {
2310         require(_exists(_tokenId));
2311         if(tokenIdToPackedData[_tokenId]==0){
2312             return "ACCESS DENIED";
2313         }
2314         return(string(abi.encodePacked("Xen ", toString(unpackData(_tokenId).xenGroup + 1))));
2315     }
2316 
2317     /** @dev gets securityTerminal of NFT
2318         @param _tokenId -- id of NFT
2319       */
2320     function getSecurityTerminal(uint256 _tokenId) external view returns (string memory) {
2321         require(_exists(_tokenId));
2322         if(tokenIdToPackedData[_tokenId]==0){
2323             return "ACCESS DENIED";
2324         }
2325         return(toString(unpackData(_tokenId).securityTerminal + 1));
2326     }
2327 
2328     /** @dev gets command of NFT
2329         @param _tokenId -- id of NFT
2330       */
2331     function getCommand(uint256 _tokenId) external view returns (string memory) {
2332         require(_exists(_tokenId));
2333         if(tokenIdToPackedData[_tokenId]==0){
2334             return "ACCESS DENIED";
2335         }
2336         return commands[unpackData(_tokenId).command];
2337     }
2338 
2339     /** @dev gets response of NFT
2340         @param _tokenId -- id of NFT
2341       */
2342     function getResponse(uint256 _tokenId) external view returns (string memory) {
2343         require(_exists(_tokenId));
2344         if(tokenIdToPackedData[_tokenId]==0){
2345             return "ACCESS DENIED";
2346         }
2347         return responses[unpackData(_tokenId).response];
2348     }
2349 
2350     /** @dev gets response of NFT
2351         @param _tokenId -- id of NFT
2352       */
2353     function getInsult(uint256 _tokenId) external view returns (string memory) {
2354         require(_exists(_tokenId));
2355         if(tokenIdToPackedData[_tokenId]==0){
2356             return "ACCESS DENIED";
2357         }
2358         return responses[unpackData(_tokenId).insult];
2359     }
2360 
2361     /** @dev gets rarity of NFT, a score used to find rank
2362         @param _tokenId -- id of NFT
2363       */
2364     function getRarity(uint256 _tokenId) external view returns (uint256) { // number not string
2365         require(_exists(_tokenId));
2366         return unpackData(_tokenId).rarity; // 0 rarity for uninitiated
2367     }
2368 
2369 
2370     //////////////////////////////////
2371     ///////// Core Functions /////////
2372     //////////////////////////////////
2373 
2374     /** @dev gets Returns a array of integers representing the index of every clearanceLevel that is available
2375       */
2376     function getAvailableClearanceLevels() view external returns(uint16[13] memory) {
2377         return clearanceLevelsRemaining;
2378     }
2379 
2380 
2381     /** @dev gets Returns a array of integers representing the index of every clearanceLevel that is available
2382         @param _Bytes -- Bytes are burned in the mint, but not here. This is just for obtaining availability
2383       */
2384     function getAvailableClearanceLevelsGivenBytes(uint256 _Bytes) view external returns(string[] memory) {
2385         uint16[13] memory availableClearanceLevels = _getAvailableClearanceLevelsGivenBytes(_Bytes);
2386         uint256 count = 0;
2387         for(uint256 i=0; i< availableClearanceLevels.length; i++){
2388             if(availableClearanceLevels[i] > 0){
2389                 count += 1;
2390             }
2391         }
2392         string[] memory availableClearanceLevelNames = new string[](count);
2393         count = 0;
2394         for(uint256 i; i< availableClearanceLevels.length; i++){
2395             if(availableClearanceLevels[i] > 0){
2396                 availableClearanceLevelNames[count] = clearanceLevels[i];
2397                 count += 1;
2398             }
2399         }
2400         return availableClearanceLevelNames;
2401     }
2402 
2403     /** @dev gets Returns a array of integers representing the index of every clearanceLevel that is available
2404         @param _Bytes -- Bytes are burned in the mint, but not here. This is just for obtaining availability
2405       */
2406     function _getAvailableClearanceLevelsGivenBytes(uint256 _Bytes) private view returns(uint16[13] memory) {
2407         uint16[13] memory availableClearanceLevels;
2408 
2409         uint256 minLevel; // lower by reference number
2410         uint256 maxLevel; // higher by reference number
2411         uint256 total;
2412 
2413         if(_Bytes < 50 ether) { // aiming for 0
2414             minLevel = 10;
2415 //            uint256 whiteListPos = 300;
2416 //            maxLevel = 12 - ( ((contractSettings.OGPrivilege == true) && (whiteListPos != 0) && (whiteListPos < 251) ) ? 1 : 0);
2417             maxLevel = 12;
2418         }
2419         else if(_Bytes < 100 ether){ // aiming for 50
2420             minLevel = 7;
2421             maxLevel = 9;
2422         }
2423         else if(_Bytes < 200 ether){ // aiming for 100
2424             minLevel = 4;
2425             maxLevel = 6;
2426         }
2427         else if(_Bytes < 300 ether){ // aiming for 200
2428             minLevel = 2;
2429             maxLevel = 3;
2430         }
2431         else if(_Bytes < 400 ether){ // aiming for 300
2432             minLevel = 1;
2433             maxLevel = 1;
2434         }
2435         else { // aiming for 400
2436             // no need to update
2437         }
2438 
2439         // from our array of 0s, we only give values to items msg.sender qualifies for
2440         for(uint256 i=minLevel; i <= maxLevel; i++){
2441             if(clearanceLevelsRemaining[i]>0){
2442                 availableClearanceLevels[i] = clearanceLevelsRemaining[i];
2443                 total += clearanceLevelsRemaining[i];
2444             }
2445         }
2446 
2447         require(total > 0, "No clearance levels available for this Byte amount.");
2448 
2449         return availableClearanceLevels;
2450     }
2451 
2452 
2453     // these numbers need to be in order of value.
2454     /** @dev choose an index based on randomness, probablity based on relative total in index
2455         @param _availableItems -- An array of integers, each representing availibility out of the whole array
2456         // example: [1,1,2] => gives an array which will yield the following 25%=>0, 25% =>1, 50% 2
2457       */
2458     function _chooseTraitGivenArray(uint16[13] memory _availableItems, uint256 _nonce) internal view returns(uint256) {
2459         uint256 total = 0;
2460         uint256 summed = 0;
2461 
2462         for(uint256 i=0;i < _availableItems.length; i++){
2463             total += _availableItems[i];
2464         }
2465         require(total!=0, "Minting exhausted.");
2466 
2467         bytes memory hashString = (abi.encodePacked(block.difficulty, block.timestamp, msg.sender, currentIndex, _availableItems[0], _availableItems.length, _nonce));
2468         uint256 pseudoRand = uint256(keccak256(hashString)) % total;
2469 
2470         for(uint256 i=0;i< _availableItems.length; i++){
2471             summed += _availableItems[i];
2472             if(pseudoRand < summed){
2473                 return i;
2474             }
2475         }
2476     }
2477 
2478 
2479 
2480     /** @dev creates tokenIdToPackedData with new stats at tokenId
2481         @param _clearanceLevel given clearance level
2482         @param _tokenId id of token
2483       */
2484     function createDataGivenClearanceLevel(uint256 _clearanceLevel, uint256 _tokenId) internal returns (uint256){
2485         Data memory _myData;
2486 
2487         uint256[6] memory traitSelections;
2488         uint256 pseudoRand;
2489         uint256 pseudoRandSection;
2490         uint256 total;
2491 
2492         pseudoRand = uint256(keccak256((abi.encodePacked(block.timestamp, msg.sender, _tokenId))));
2493         for(uint256 j = 0; j< 6; j++){
2494             pseudoRandSection = (pseudoRand / ((10^4)^j)) % 3000;
2495             total = 0;
2496             for(uint256 k = 12; k>=0;k--){ // Should save gas by processing higher numbers first
2497                 total += traitTotals[k];
2498                 if(pseudoRandSection < total){
2499                     traitSelections[j] = k;
2500                     break;
2501                 }
2502             }
2503         }
2504 
2505         _myData.clearanceLevel = _clearanceLevel;
2506         _myData.station = traitSelections[0];
2507         _myData.securityTerminal = traitSelections[1];
2508         _myData.xenGroup = traitSelections[2];
2509         _myData.command = traitSelections[3];
2510         _myData.response = traitSelections[4];
2511         _myData.insult = traitSelections[5];
2512 
2513         _myData.rarity =  (750 - uint256(traitTotals[_myData.clearanceLevel]) ) * (10**8)
2514             +  (4500 - uint256( traitTotals[_myData.station] + traitTotals[_myData.securityTerminal] + traitTotals[_myData.xenGroup]
2515               + traitTotals[_myData.command] + traitTotals[_myData.response] + traitTotals[_myData.insult] )) * (10**4)
2516             +  3000 - (_tokenId);
2517 
2518         tokenIdToPackedData[_tokenId] = packData(_myData.clearanceLevel, _myData.station, _myData.securityTerminal, _myData.xenGroup, _myData.command, _myData.response, _myData.insult, _myData.rarity);
2519 
2520     }
2521 
2522 
2523     /** @dev takes a blank NFT and gives it stats. For the 250 Team mints, it gives it a clearance level
2524         @param _tokenId id of token
2525       */
2526     function initiate(uint256 _tokenId) external {
2527         require(_tokenId < 250 && tokenIdToPackedData[_tokenId] == 0); // dev: can not initiate
2528 
2529         uint256 _clearanceLevel;
2530 
2531         if (_tokenId < 30) { // gman is default
2532             _clearanceLevel = 0;
2533         }
2534         else if (_tokenId < 90){
2535             _clearanceLevel = 1;
2536         }
2537         else if (_tokenId < 130){
2538             _clearanceLevel = 2;
2539         }
2540         else if (_tokenId < 180){
2541             _clearanceLevel = 3;
2542         }
2543         else if (_tokenId < 200){
2544             _clearanceLevel = 4;
2545         }
2546         else if (_tokenId < 215){
2547             _clearanceLevel = 5;
2548         }
2549         else if (_tokenId < 225){
2550             _clearanceLevel = 6;
2551         }
2552         else if (_tokenId < 235){
2553             _clearanceLevel = 7;
2554         }
2555         else if (_tokenId < 245){
2556             _clearanceLevel = 8;
2557         }
2558         else if (_tokenId < 250){
2559             _clearanceLevel = 9;
2560         }
2561         else{
2562             // nothing
2563         }
2564         createDataGivenClearanceLevel(_clearanceLevel, _tokenId);
2565     }
2566 
2567     function _bulkClaim(uint256[] memory _BytesReceived, uint256 _quantity_to_mint) internal {
2568         uint256 _requiredBytesTotal;
2569         for(uint256 i = 0;i < _BytesReceived.length; i++){
2570             _requiredBytesTotal += _BytesReceived[i];
2571         }
2572 
2573         if(_requiredBytesTotal > 0 && msg.sender != owner()){
2574             require(BytesERC20.balanceOf(msg.sender) >= _requiredBytesTotal, "Insufficient Byte balance");
2575             require(BytesERC20.transferFrom(msg.sender, address(this), _requiredBytesTotal), "Failed to transfer Bytes");
2576         }
2577 
2578         uint16[13] memory _availClearanceLevels;
2579         uint256 _myClearanceLevel;
2580 
2581         for(uint256 i=0;i<_quantity_to_mint;i++){
2582             if(i==0){
2583                 _availClearanceLevels = _getAvailableClearanceLevelsGivenBytes(_BytesReceived[i]);
2584             }
2585             else {
2586                 _availClearanceLevels[_myClearanceLevel] -= 1; // reduce by one
2587             }
2588             _myClearanceLevel = _chooseTraitGivenArray(_availClearanceLevels, i);
2589             createDataGivenClearanceLevel(_myClearanceLevel, currentIndex + i);
2590             clearanceLevelsRemaining[_myClearanceLevel] -= 1;
2591         }
2592         _safeMint(msg.sender, _quantity_to_mint);
2593     }
2594 
2595 
2596     /** @dev Claims (mint) Black Meta Multipass
2597         @param _BytesReceived -- Bytes to transfer to contract. Used for minting, higher amounts give better mints.
2598         @param _merkleProof -- Merkle proof, computed off chain
2599       */
2600     function claim(uint256 _BytesReceived, bytes32[] calldata _merkleProof, uint256 _whitelist_position) external payable nonReentrant { // i don't think non-rentrant needs to be here
2601 //        require(bypassWhitelist == true || whiteListContract.isWhitelisted(_merkleProof, msg.sender)==true, "Not whitelisted");
2602         require(contractSettings.bypassWhitelist == true || whiteListContract.isWhitelisted(msg.sender, _whitelist_position, _merkleProof)==true, "Not whitelisted");
2603         require(currentIndex < contractSettings.maxSupply );
2604         require(whiteListHasMinted[msg.sender] == 0, "address already minted");
2605         require(msg.value >= contractSettings.mintFee);
2606         require(contractSettings.mintingPermitted==true, "Minting is currently not permitted.");
2607         whiteListHasMinted[msg.sender] += 1;
2608 
2609         uint256[] memory _myBytesArray = new uint256[](1);
2610         _myBytesArray[0] = _BytesReceived;
2611         _bulkClaim(_myBytesArray, 1);
2612 //        _claim(_BytesReceived);
2613     }
2614 
2615 
2616     /** @dev Constructor for Black Meta Multipass
2617         @param _BytesAddress -- Contract Address for Bytes.
2618         @param _baseURI -- Background Image for tokenUri Image
2619       */
2620     constructor(address _BytesAddress, address _whiteListAddress, address _royaltiesCollector, string memory _baseURI)
2621             ERC721A("Black Meta Multipass", "BMPASS") Ownable() ERC2981Collection(_royaltiesCollector, 750) {
2622         BytesERC20 = IERC20(_BytesAddress);
2623         whiteListContract = Whitelist(_whiteListAddress);
2624         baseURI = _baseURI;
2625 
2626         contractSettings = ContractSettings({
2627             mintFee: 0, //0.05 ether,
2628             maxSupply: 3000,
2629             OGPrivilege: true,
2630             mintingPermitted: true,
2631             bypassWhitelist: false
2632         });
2633 
2634         // mint 250 blank NFTs for team. These are initiated by team members at their own cost //
2635         // they have a present clearanceLevel according to their tokenId //
2636         _safeMint(msg.sender, 250);
2637     }
2638 
2639     // Required to receive ETH
2640     receive() external payable {
2641     }
2642 
2643 
2644     /////////////////////////////////////////////
2645     ///////// MetaData, Image Functions /////////
2646     /////////////////////////////////////////////
2647 
2648     /** @dev Formats string into code for typing on image terminal
2649         @param _line -- vertical starting position.
2650         @param _duration -- animation duration.
2651         @param _startTime -- time to begin animation (invisible beforehand).
2652         @param _txt -- text to animate (width/characters must be less than terminal size--or visual overflow)
2653       */
2654     function getSVGTextGivenLine(uint256 _line, uint256 _duration, uint256 _startTime, string memory _txt) internal view returns (string memory) {
2655         string memory ret = string(abi.encodePacked(
2656             "%3Cpath id='path",
2657             toString(_line),
2658             "'%3E %3Canimate attributeName='d' from='m50, ",
2659             toString(170 + _line*14),
2660             " h0' to='m50, ",
2661             toString(170 + _line*14),
2662             " h1100' dur='",
2663             toString(_duration),
2664             "s' begin='",
2665             toString(_startTime),
2666             "s' fill='freeze'/%3E%3C/path%3E"
2667         ));
2668         ret = string(abi.encodePacked(ret,
2669             "%3Ctext class='bm'%3E %3CtextPath xlink:href='%23path",
2670             toString(_line),
2671             "'%3E",
2672             _txt,
2673             "%3C/textPath%3E",
2674             "%3C/text%3E"
2675         ));
2676         return ret;
2677     }
2678 
2679     function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
2680         require(_exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");
2681         Data memory _myData = unpackData(_tokenId);
2682 
2683         string[13] memory _fontColors = [
2684             '00DEFF',
2685             '00DEFF',
2686             'C5ACFF',
2687             'C5ACFF',
2688             '8BFF7C',
2689             '8BFF7C',
2690             '8BFF7C',
2691             'FF8D8D',
2692             'FF8D8D',
2693             'FF8D8D',
2694             'FFFE8D',
2695             'FFFE8D',
2696             'B1FCFF'
2697         ];
2698 
2699         string memory style = string(abi.encodePacked(
2700           "%3Cstyle%3E",
2701                 "@import url('https://fonts.googleapis.com/css2?family=VT323');",
2702                 ".bm %7B",
2703                     "font-family: 'VT323', monospace;",
2704                     "font-size:12px;",
2705                     "fill: %23", _fontColors[_myData.clearanceLevel],
2706                 "%7D",
2707           "%3C/style%3E"
2708         ));
2709 
2710 
2711 
2712         string memory header = string(abi.encodePacked(
2713             style,
2714             "%3Ctext class='bm' x='50%25' y='90' text-anchor='middle' %3ESA/RA 9000 OPERATING SYSTEM %3C/text%3E",
2715             "%3Ctext class='bm' x='50%25' y='110' text-anchor='middle' %3ECOPYRIGHT 2022-2175 BLACK META CORPORATION%3C/text%3E",
2716             "%3Ctext class='bm' x='50%25' y='130' text-anchor='middle' %3E --SECURITY TERMINAL ",
2717             toString(_myData.clearanceLevel + 1),
2718             "--  %3C/text%3E"
2719         ));
2720 
2721 
2722         string[25] memory textLines = [
2723             '--Black Meta Security Scan Subsystem--',
2724             '=============================================',
2725             'Sa/RaOS v. 7.21',
2726             '(C)2022 Black Meta Corp.(TM))',
2727             '=============================================',
2728             '| %3E%3E Running Security Scan... COMPLETE ',
2729             '| User Log: ',
2730             string(abi.encodePacked('| %3E%3E MultipassID: ', toString(_tokenId))),
2731             '| Security Clearance: ',
2732             string(abi.encodePacked('| %3E%3E ', clearanceLevels[_myData.clearanceLevel] )),
2733             '| Welcome to Black Meta.',
2734             '| %3E%3E Assigning Quarters... COMPLETE ',
2735             string(abi.encodePacked('| %3E%3E Xen ', toString(_myData.xenGroup + 1) )),
2736             '| %3E%3E Assigning Station... COMPLETE ',
2737             string(abi.encodePacked('| %3E%3E ', stations[_myData.station] )),
2738             '%3E| %3E%3E Granting Subroot Access... COMPLETE ',
2739             '%3E| %3E%3E Opening Command Subroot... COMPLETE ',
2740             '====================================',
2741             '%3E> Hello. How can I fix your total failures?',
2742             string(abi.encodePacked('%3E C:%3E  ', commands[_myData.command])),
2743             string(abi.encodePacked('%3E| ', responses[_myData.response])),
2744             '%3E| %3E%3E Alerting Security Assistance... COMPLETE',
2745             '%3E| %3E%3E Starting Insult Protocol 2.3... COMPLETE',
2746             '====================================',
2747             string(abi.encodePacked('%3E| %3E%3E ', insults[_myData.insult]))
2748         ];
2749 
2750         // OVERLAY MUST BE SAME FORMAT (WEBP)
2751         string memory colorOverlay = string(abi.encodePacked(
2752                 "%3Cimage xlink:href='", baseURI ,"/", toString(_myData.clearanceLevel) ,  ".png' width='600' height='600' /%3E"
2753             ));
2754 
2755         string memory textOverlay="";
2756         uint256 startTime = 0;
2757         uint256 duration = 5;
2758         uint256 flag = 0;
2759         for(uint256 i=0;i< textLines.length;i++){
2760             textOverlay = string(abi.encodePacked(textOverlay, getSVGTextGivenLine(i, duration, startTime, textLines[i]), " "));
2761             startTime += duration/2;
2762             if(flag==1) { break;}
2763         }
2764 
2765         string memory footer = string(abi.encodePacked(
2766             "%3Cpath id='pathfinal'%3E%3Canimate attributeName='d' from='m180,550 h0' to='m180,550 h1100' dur='7s' begin='", toString(startTime) , "s' fill='freeze'/%3E%3C/path%3E",
2767             "%3Ctext%3E%3CtextPath xlink:href='%23pathfinal' class='bm'%3ERETURN: enter | BACKSPACE : delete | F1: main menu%3C/textPath%3E%3C/text%3E"
2768         ));
2769 
2770 
2771         string memory mainImage;
2772 
2773         mainImage = string(abi.encodePacked(
2774             "%3Cimage xlink:href='", baseURI ,"/a.png' width='600' height='600' /%3E"
2775         ));
2776 
2777         string memory SVG = string(abi.encodePacked(
2778             // Container
2779            "%3Csvg xmlns='http://www.w3.org/2000/svg' width='600'  xmlns:xlink='http://www.w3.org/1999/xlink' height='600'%3E %3Crect width='600' height='600' style='fill:rgb(255,255,255);stroke-width:3;stroke:rgb(0,0,0)' /%3E",
2780 
2781             // Main image
2782             mainImage,
2783             colorOverlay,
2784             header,
2785 
2786            // text outlines
2787             textOverlay,
2788             footer,
2789 
2790             // Error Message
2791             "Unsupported.",
2792             "%3C/svg%3E"
2793             ));
2794 
2795         return formatTokenURI(_tokenId, svgToImageURI(SVG));
2796     }
2797 
2798     /** @dev Converts svg to dataURI
2799         @param svg -- svg to turn into dataURI.
2800       */
2801     function svgToImageURI(string memory svg) internal pure returns (string memory) {
2802         bool ENCODE = false;
2803         string memory baseURL = "data:image/svg+xml;base64,";
2804 
2805         if (!ENCODE) {
2806             baseURL = "data:image/svg+xml,";
2807             return string(abi.encodePacked(baseURL,svg));
2808         }
2809 
2810         string memory svgBase64Encoded = Base64.encode(bytes(svg));
2811         return string(abi.encodePacked(baseURL,svgBase64Encoded));
2812     }
2813 
2814 
2815     /** @dev Packs metadata, including image, into a dataURI
2816         @param _tokenId -- ID of BMMultipass
2817         @param imageURI -- URI of image
2818       */
2819     function formatTokenURI(uint256 _tokenId, string memory imageURI) internal view returns (string memory) {
2820 
2821         if(tokenIdToPackedData[_tokenId] == 0) {
2822             return string(abi.encodePacked(baseURI, "/access_denied.json" ));
2823         }
2824 
2825         Data memory _myData = unpackData(_tokenId);
2826         string memory json_str = string(abi.encodePacked(
2827             '{"description": "The ticket into the Black Meta Multiverse."',
2828             ', "external_url": "https://blackmeta.site"',
2829             ', "image": "', // to do -- check on this
2830                baseURI, "/a", toString(_myData.clearanceLevel),  '.png"',
2831             ', "data_uri": "', //
2832              imageURI, '"',
2833             ', "name": "Black Meta Multipass"',
2834             // attributes
2835             ', "attributes": [{"trait_type": "Clearance Level", "value": "',
2836             clearanceLevels[_myData.clearanceLevel],   '" }'
2837         ));
2838 
2839         json_str = string(abi.encodePacked(json_str,
2840             ', {"trait_type": "Station", "value": "',
2841             stations[_myData.station],   '" }',
2842             ', {"trait_type": "Security Terminal", "value": "',
2843 //            securityTerminals[_myData.securityTerminal],   '" }'
2844             toString(_myData.securityTerminal + 1),   '" }'
2845         ));
2846 
2847         json_str = string(abi.encodePacked(json_str,
2848             ', {"trait_type": "Xen Groups", "value": "Xen ',
2849 //            xenGroups[_myData.xenGroup],   '" }',
2850             toString(_myData.xenGroup + 1),   '" }',
2851             ', {"trait_type": "Command", "value": "',
2852             commands[_myData.command],   '" }'
2853         ));
2854 
2855 
2856         json_str = string(abi.encodePacked(json_str,
2857             ', {"trait_type": "Response", "value": "',
2858             responses[_myData.response],   '" }',
2859             ', {"trait_type": "Insult", "value": "',
2860             insults[_myData.insult],   '" }',
2861             ', {"trait_type": "Rarity", "value": ', // "display_type": "number",
2862             toString(_myData.rarity),   ' }'
2863         ));
2864 
2865         json_str = string(abi.encodePacked(json_str,
2866             ']', // End Attributes
2867             '}'
2868         ));
2869 
2870         return string(abi.encodePacked("data:application/json;base64,", Base64.encode(bytes(json_str))));
2871     }
2872 
2873 
2874     ///////////////////////////////////
2875     ///////// Admin Functions /////////
2876     ///////////////////////////////////
2877 
2878     function withdrawBytes( address _recipient) external onlyOwner nonReentrant {
2879         uint256 _BytesReleased = BytesERC20.balanceOf(address(this));
2880         require(BytesERC20.transfer(_recipient, BytesERC20.balanceOf(address(this))), "Bytes transfer failed.");
2881         emit FundsReleasedToAccount(0, _BytesReleased, _recipient, block.timestamp);
2882     }
2883 
2884     function withdrawEth( address payable _recipient) external onlyOwner nonReentrant {
2885         uint256 amountReleased = address(this).balance;
2886         (bool success, ) = _recipient.call{value : address(this).balance}("Releasing ETH.");
2887         require(success, "Transfer failed.");
2888         emit FundsReleasedToAccount(amountReleased, 0, _recipient, block.timestamp);
2889     }
2890 
2891     function setBytesAddress(address _contractAddress) external onlyOwner {
2892         BytesERC20 = IERC20(_contractAddress);
2893     }
2894 
2895     function setWhiteListContractAddress(address _contractAddress) external onlyOwner {
2896         whiteListContract = Whitelist(_contractAddress);
2897     }
2898 
2899     function setOGPrivilege(bool _OGPrivilege) external onlyOwner {
2900         require(contractSettings.OGPrivilege != _OGPrivilege, "must be 1 or 0, and not same as current.");
2901         contractSettings.OGPrivilege = _OGPrivilege;
2902     }
2903 
2904     function setMintingPermitted(bool _mintingPermitted) external onlyOwner {
2905         require(contractSettings.mintingPermitted != _mintingPermitted, "must be 1 or 0, and not same as current.");
2906         contractSettings.mintingPermitted = _mintingPermitted;
2907     }
2908 
2909     function setBypassWhitelist(bool _bypassWhitelist) external onlyOwner {
2910         require(contractSettings.bypassWhitelist != _bypassWhitelist, "must be 1 or 0, and not same as current.");
2911         contractSettings.bypassWhitelist = _bypassWhitelist;
2912     }
2913 
2914     function setBaseURI(string memory _baseURI) external onlyOwner {
2915         baseURI = _baseURI;
2916     }
2917 
2918     function setRoyaltyPercent(uint256 _percentage) external onlyOwner {
2919         _setRoyaltyPercent(_percentage);
2920     }
2921 
2922     function setRoyaltyAddress(address _receiver) external onlyOwner {
2923         _setRoyaltyAddress(_receiver);
2924     }
2925 
2926 
2927     /** @dev sets mint fee in ETH for all mints
2928         @param _mintFee -- ETH required to mint, must not exceed 2^208 -1 or overflow
2929     */
2930     function setMintFee(uint256 _mintFee) external onlyOwner {
2931         contractSettings.mintFee = uint208(_mintFee);
2932     }
2933 
2934     /** @dev Upgrades a clearanceLevel. Used for rewards
2935         @param _tokenId -- id of NFT
2936         @param _newClearanceLevel -- clearanceLevel to be upgraded to
2937     */
2938     function upgradeClearanceLevel(uint256 _tokenId, uint256 _newClearanceLevel) external onlyOwner {
2939         Data memory _myData = unpackData(_tokenId);
2940         require(_exists(_tokenId) && _myData.clearanceLevel > _newClearanceLevel); // dev: Id must exist and must increase CL
2941 //        require(_exists(_tokenId), "NFT DOES NOT EXIST"); // lesser number is superior
2942 //        require(_myData.clearanceLevel > _newClearanceLevel, "upgraded must lower cl #"); // lesser number is superior
2943 
2944         _myData.clearanceLevel = _newClearanceLevel;
2945         tokenIdToPackedData[_tokenId] = packData(_myData.clearanceLevel, _myData.station, _myData.securityTerminal, _myData.xenGroup, _myData.command, _myData.response, _myData.insult, _myData.rarity);
2946     }
2947 
2948 
2949     /////////////////////////////////////
2950     ///////// Helper Functions //////////
2951     /////////////////////////////////////
2952 
2953     function toString(uint256 value) internal pure returns (string memory) {
2954         // Inspired by OraclizeAPI's implementation - MIT license
2955         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
2956         if (value == 0) {
2957             return "0";
2958         }
2959         uint256 temp = value;
2960         uint256 digits;
2961         while (temp != 0) {
2962             digits++;
2963             temp /= 10;
2964         }
2965         bytes memory buffer = new bytes(digits);
2966         while (value != 0) {
2967             digits -= 1;
2968             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
2969             value /= 10;
2970         }
2971         return string(buffer);
2972     }
2973 }