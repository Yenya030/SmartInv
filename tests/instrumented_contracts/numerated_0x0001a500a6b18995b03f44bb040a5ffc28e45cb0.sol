1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/OLAS.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}\n"
6     },
7     "lib/solmate/src/tokens/ERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": true,
14       "runs": 1000000
15     },
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "devdoc",
22           "userdoc",
23           "metadata",
24           "abi"
25         ]
26       }
27     },
28     "metadata": {
29       "useLiteralContent": true
30     },
31     "libraries": {}
32   }
33 }}