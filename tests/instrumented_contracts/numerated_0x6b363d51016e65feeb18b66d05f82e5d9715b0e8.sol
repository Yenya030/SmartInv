1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/Marketplace.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\n\nimport {Choice} from \"./lib/Choice.sol\";\nimport {Ownable} from \"./lib/Ownable.sol\";\nimport {IGouda, IMadMouse} from \"./lib/interfaces.sol\";\n\nerror NoWhitelistRemaining();\nerror MaxEntriesReached();\nerror ContractCallNotAllowed();\nerror NotActive();\nerror RequirementNotFulfilled();\nerror RandomSeedAlreadyChosen();\n\ncontract Marketplace is Ownable {\n    event BurnForItem(address indexed user, bytes32 indexed id);\n\n    struct MarketItem {\n        uint32 totalSupply;\n        uint224 restingPrice;\n    }\n\n    mapping(bytes32 => MarketItem) public marketItems;\n    mapping(bytes32 => mapping(address => uint256)) public numEntries;\n\n    mapping(bytes32 => mapping(uint256 => address)) public raffleEntries;\n    mapping(bytes32 => uint256) public raffleRandomSeeds;\n\n    IGouda constant gouda = IGouda(0x3aD30C5E3496BE07968579169a96f00D56De4C1A);\n    IMadMouse constant genesis = IMadMouse(0x3aD30c5e2985e960E89F4a28eFc91BA73e104b77);\n    IMadMouse constant troupe = IMadMouse(0x74d9d90a7fc261FBe92eD47B606b6E0E00d75E70);\n\n    /* ------------- External ------------- */\n\n    function purchaseMarketItem(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxEntries,\n        uint256 maxSupply,\n        uint256 requirement,\n        uint256 requirementData\n    ) external onlyEOA {\n        unchecked {\n            bytes32 hash = keccak256(abi.encode(start, end, price, maxEntries, maxSupply, requirement));\n\n            if (block.timestamp < start || end < block.timestamp) revert NotActive();\n\n            MarketItem storage marketItem = marketItems[hash];\n            uint256 totalSupply = ++marketItem.totalSupply;\n\n            if (totalSupply > maxSupply) revert NoWhitelistRemaining();\n            if (++numEntries[hash][msg.sender] > maxEntries) revert MaxEntriesReached();\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n                revert RequirementNotFulfilled();\n\n            gouda.burnFrom(msg.sender, price);\n            emit BurnForItem(msg.sender, hash);\n        }\n    }\n\n    function purchaseMarketItemDutchAuction(\n        uint256 start,\n        uint256 end,\n        uint256 startPrice,\n        uint256 endPrice,\n        uint256 maxEntries,\n        uint256 maxSupply,\n        uint256 requirement,\n        uint256 requirementData\n    ) external onlyEOA {\n        unchecked {\n            bytes32 hash = keccak256(abi.encode(start, end, startPrice, endPrice, maxEntries, maxSupply, requirement));\n\n            uint256 price;\n            if (block.timestamp < start) revert NotActive();\n\n            // assumptions: endPrice < startPrice; timestamp >= start; start <= end\n            uint256 timestamp = block.timestamp > end ? end : block.timestamp;\n            price = startPrice - ((startPrice - endPrice) * (timestamp - start)) / (end - start); // overflow unlikely\n\n            MarketItem storage marketItem = marketItems[hash];\n\n            if (++marketItem.totalSupply > maxSupply) revert NoWhitelistRemaining();\n            if (++numEntries[hash][msg.sender] > maxEntries) revert MaxEntriesReached();\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n                revert RequirementNotFulfilled();\n\n            marketItem.restingPrice = uint224(price);\n\n            gouda.burnFrom(msg.sender, price);\n            emit BurnForItem(msg.sender, hash);\n        }\n    }\n\n    function purchaseMarketItemRaffle(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxEntries,\n        uint256 maxSupply,\n        uint256 numPrizes,\n        uint256 requirement,\n        uint256 requirementData\n    ) external onlyEOA {\n        unchecked {\n            bytes32 hash = keccak256(abi.encode(start, end, price, maxEntries, maxSupply, numPrizes, requirement));\n\n            if (block.timestamp < start || end < block.timestamp) revert NotActive();\n\n            MarketItem storage marketItem = marketItems[hash];\n\n            uint256 totalSupply = ++marketItem.totalSupply;\n\n            if (totalSupply > maxSupply) revert NoWhitelistRemaining();\n            if (++numEntries[hash][msg.sender] > maxEntries) revert MaxEntriesReached();\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\n                revert RequirementNotFulfilled();\n\n            raffleEntries[hash][totalSupply] = msg.sender;\n\n            gouda.burnFrom(msg.sender, price);\n            emit BurnForItem(msg.sender, hash);\n        }\n    }\n\n    /* ------------- View ------------- */\n\n    function getRaffleEntries(bytes32 hash) external view returns (address[] memory) {\n        uint256 totalSupply = marketItems[hash].totalSupply;\n\n        address[] memory entrants = new address[](totalSupply);\n\n        for (uint256 i; i < totalSupply; ++i) entrants[i] = raffleEntries[hash][i + 1];\n\n        return entrants;\n    }\n\n    function getRaffleWinners(bytes32 hash, uint256 numPrizes) public view returns (address[] memory winners) {\n        uint256 randomSeed = raffleRandomSeeds[hash];\n        if (randomSeed == 0) return winners;\n\n        uint256 totalSupply = marketItems[hash].totalSupply;\n\n        uint256[] memory winnerIds = Choice.selectNOfM(numPrizes, totalSupply, randomSeed);\n        uint256 numIds = winnerIds.length;\n\n        winners = new address[](numIds);\n\n        for (uint256 i; i < numIds; ++i) winners[i] = raffleEntries[hash][i + 1];\n    }\n\n    /* ------------- Owner ------------- */\n\n    function revealRaffle(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxEntries,\n        uint256 maxSupply,\n        uint256 numPrizes,\n        uint256 requirement\n    ) external onlyOwner {\n        bytes32 hash = keccak256(abi.encode(start, end, price, maxEntries, maxSupply, numPrizes, requirement));\n\n        if (block.timestamp < end) revert NotActive();\n\n        if (raffleRandomSeeds[hash] != 0) revert RandomSeedAlreadyChosen();\n\n        raffleRandomSeeds[hash] = uint256(blockhash(block.number - 1));\n    }\n\n    /* ------------- View ------------- */\n\n    // 1: genesis\n    // 2: troupe\n    // 3: genesis / troupe\n    // 4: level >= 2\n    // 5: level == 3\n    function fulfillsRequirement(\n        address user,\n        uint256 requirement,\n        uint256 data\n    ) public view returns (bool) {\n        unchecked {\n            if (requirement == 1 && genesis.numOwned(user) > 0) return true;\n            else if (requirement == 2 && troupe.numOwned(user) > 0) return true;\n            else if (\n                requirement == 3 &&\n                // specify data == 1 to direct that user is holding troupe and potentially save an sload;\n                // or leave unspecified and worst-case check both\n                ((data != 2 && troupe.numOwned(user) > 0) || (data != 1 && genesis.numOwned(user) > 0))\n            ) return true;\n            else if (\n                requirement == 4 &&\n                (\n                    data > 5000 // specify owner-held id: data > 5000 refers to genesis collection\n                        ? genesis.getLevel(data - 5000) > 1 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 1 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            else if (\n                requirement == 5 &&\n                (\n                    data > 5000\n                        ? genesis.getLevel(data - 5000) > 2 && genesis.ownerOf(data - 5000) == user\n                        : troupe.getLevel(data) > 2 && troupe.ownerOf(data) == user\n                )\n            ) return true;\n            return false;\n        }\n    }\n\n    /* ------------- Modifier ------------- */\n\n    modifier onlyEOA() {\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\n        _;\n    }\n}\n"
6     },
7     "src/lib/Choice.sol": {
8       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// author: phaze\n\n// assumption: n << m\n// caveats: splits random number into 16 parts for efficiency\n// this means that 65536 is the highest random number\n// (can skew uniform distributions when m is hight)\nlibrary Choice {\n    function selectNOfM(\n        uint256 n,\n        uint256 m,\n        uint256 r\n    ) internal pure returns (uint256[] memory) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = ((r >> slot) & 0xFFFF) % m;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                choice[i] = c;\n            }\n            return choice;\n        }\n    }\n\n    function selectNOfM(\n        uint256 n,\n        uint256 m,\n        uint256 r,\n        uint256 offset\n    ) internal pure returns (uint256[] memory) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = (((r >> slot) & 0xFFFF) % m) + offset;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                choice[i] = c;\n            }\n            return choice;\n        }\n    }\n\n    function indexOfSelectNOfM(\n        uint256 x,\n        uint256 n,\n        uint256 m,\n        uint256 r\n    ) internal pure returns (bool, uint256) {\n        unchecked {\n            if (n > m) n = m;\n\n            uint256[] memory choice = new uint256[](n);\n\n            uint256 s;\n            uint256 slot;\n\n            uint256 j;\n            uint256 c;\n\n            bool invalidChoice;\n\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = ((r >> slot) & 0xFFFF) % m;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                if (x == c) return (true, i);\n\n                choice[i] = c;\n            }\n            return (false, 0);\n        }\n    }\n}\n"
9     },
10     "src/lib/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nerror CallerNotOwner();\n\nabstract contract Ownable {\n    address _owner = msg.sender;\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner) revert CallerNotOwner();\n        _;\n    }\n}\n"
12     },
13     "src/lib/interfaces.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IGouda {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function transfer(address to, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address user, uint256 amount) external;\n\n    function burnFrom(address account, uint256 amount) external;\n}\n\ninterface IMadMouse {\n    function numStaked(address user) external view returns (uint256);\n\n    function numOwned(address user) external view returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function getLevel(uint256 tokenId) external view returns (uint256);\n\n    function getDNA(uint256 tokenId) external view returns (uint256);\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 10000
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     },
34     "libraries": {}
35   }
36 }}