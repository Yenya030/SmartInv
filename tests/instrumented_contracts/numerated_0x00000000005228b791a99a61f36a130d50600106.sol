1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/LooksRareAggregator.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {ReentrancyGuard} from \"@looksrare/contracts-libs/contracts/ReentrancyGuard.sol\";\nimport {LowLevelERC20Approve} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Approve.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelERC721Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\nimport {TokenReceiver} from \"./TokenReceiver.sol\";\nimport {ILooksRareAggregator} from \"./interfaces/ILooksRareAggregator.sol\";\nimport {TokenTransfer} from \"./libraries/OrderStructs.sol\";\nimport {InvalidOrderLength, TradeExecutionFailed, ZeroAddress} from \"./libraries/SharedErrors.sol\";\n\n/**\n * @title LooksRareAggregator\n * @notice This contract allows NFT sweepers to buy NFTs from\n *         different marketplaces by passing high-level structs\n *         + low-level bytes as calldata.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LooksRareAggregator is\n    ILooksRareAggregator,\n    TokenReceiver,\n    ReentrancyGuard,\n    LowLevelERC20Approve,\n    LowLevelERC20Transfer,\n    LowLevelERC721Transfer,\n    LowLevelERC1155Transfer,\n    OwnableTwoSteps\n{\n    /**\n     * @notice Transactions that only involve ETH orders should be submitted to\n     *         this contract directly. Transactions that involve ERC20 orders\n     *         should be submitted to the contract ERC20EnabledLooksRareAggregator\n     *         and it will call this contract's execution function. The purpose\n     *         is to prevent a malicious proxy from stealing users' ERC20 tokens\n     *         if this contract's ownership is compromised. By not providing any\n     *         allowances to this aggregator, even if a malicious proxy is added,\n     *         it cannot call token.transferFrom(victim, attacker, amount) inside\n     *         the proxy within the context of the aggregator.\n     */\n    address public erc20EnabledLooksRareAggregator;\n    mapping(address => mapping(bytes4 => uint256)) private _proxyFunctionSelectors;\n\n    constructor(address _owner) OwnableTwoSteps(_owner) {}\n\n    /**\n     * @inheritdoc ILooksRareAggregator\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable nonReentrant {\n        if (recipient == address(0)) {\n            revert ZeroAddress();\n        }\n        uint256 tradeDataLength = tradeData.length;\n        if (tradeDataLength == 0) {\n            revert InvalidOrderLength();\n        }\n\n        if (tokenTransfers.length == 0) {\n            originator = msg.sender;\n        } else if (msg.sender != erc20EnabledLooksRareAggregator) {\n            revert UseERC20EnabledLooksRareAggregator();\n        }\n\n        for (uint256 i; i < tradeDataLength; ) {\n            TradeData calldata singleTradeData = tradeData[i];\n            address proxy = singleTradeData.proxy;\n            if (_proxyFunctionSelectors[proxy][singleTradeData.selector] != 1) {\n                revert InvalidFunction();\n            }\n\n            (bool success, bytes memory returnData) = proxy.delegatecall(\n                abi.encodeWithSelector(\n                    singleTradeData.selector,\n                    singleTradeData.orders,\n                    singleTradeData.ordersExtraData,\n                    singleTradeData.extraData,\n                    recipient,\n                    isAtomic\n                )\n            );\n\n            if (!success) {\n                if (isAtomic) {\n                    if (returnData.length != 0) {\n                        assembly {\n                            let returnDataSize := mload(returnData)\n                            revert(add(32, returnData), returnDataSize)\n                        }\n                    } else {\n                        revert TradeExecutionFailed();\n                    }\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (tokenTransfers.length != 0) {\n            _returnERC20TokensIfAny(tokenTransfers, originator);\n        }\n\n        bool status = true;\n        assembly {\n            if gt(selfbalance(), 1) {\n                status := call(gas(), originator, sub(selfbalance(), 1), 0, 0, 0, 0)\n            }\n        }\n        if (!status) {\n            revert ETHTransferFail();\n        }\n\n        emit Sweep(originator);\n    }\n\n    /**\n     * @notice Enable making ERC20 trades by setting the ERC20 enabled LooksRare aggregator\n     * @dev Must be called by the current owner. It can only be set once to prevent\n     *      a malicious aggregator from being set in case of an ownership compromise.\n     * @param _erc20EnabledLooksRareAggregator The ERC20 enabled LooksRare aggregator's address\n     */\n    function setERC20EnabledLooksRareAggregator(address _erc20EnabledLooksRareAggregator) external onlyOwner {\n        if (erc20EnabledLooksRareAggregator != address(0)) {\n            revert AlreadySet();\n        }\n        erc20EnabledLooksRareAggregator = _erc20EnabledLooksRareAggregator;\n    }\n\n    /**\n     * @notice Enable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function addFunction(address proxy, bytes4 selector) external onlyOwner {\n        _proxyFunctionSelectors[proxy][selector] = 1;\n        emit FunctionAdded(proxy, selector);\n    }\n\n    /**\n     * @notice Disable calling the specified proxy's trade function\n     * @dev Must be called by the current owner\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    function removeFunction(address proxy, bytes4 selector) external onlyOwner {\n        delete _proxyFunctionSelectors[proxy][selector];\n        emit FunctionRemoved(proxy, selector);\n    }\n\n    /**\n     * @notice Approve marketplaces to transfer ERC20 tokens from the aggregator\n     * @param currency The ERC20 token address to approve\n     * @param marketplace The marketplace address to approve\n     * @param amount The amount of ERC20 token to approve\n     */\n    function approve(\n        address currency,\n        address marketplace,\n        uint256 amount\n    ) external onlyOwner {\n        _executeERC20Approve(currency, marketplace, amount);\n    }\n\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @return isSupported Whether the marketplace proxy's function can be called from the aggregator\n     */\n    function supportsProxyFunction(address proxy, bytes4 selector) external view returns (bool isSupported) {\n        isSupported = _proxyFunctionSelectors[proxy][selector] == 1;\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC721 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC721 token to rescue from the contract\n     * @param tokenId The token ID of the ERC721 token to rescue from the contract\n     * @param to Send the contract's specified ERC721 token ID to this address\n     */\n    function rescueERC721(\n        address collection,\n        address to,\n        uint256 tokenId\n    ) external onlyOwner {\n        _executeERC721TransferFrom(collection, address(this), to, tokenId);\n    }\n\n    /**\n     * @notice Rescue any of the contract's trapped ERC1155 tokens\n     * @dev Must be called by the current owner\n     * @param collection The address of the ERC1155 token to rescue from the contract\n     * @param tokenIds The token IDs of the ERC1155 token to rescue from the contract\n     * @param amounts The amount of each token ID to rescue\n     * @param to Send the contract's specified ERC1155 token ID to this address\n     */\n    function rescueERC1155(\n        address collection,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        _executeERC1155SafeBatchTransferFrom(collection, address(this), to, tokenIds, amounts);\n    }\n\n    /**\n     * @dev If any order fails, the ETH paid to the marketplace\n     *      is refunded to the aggregator contract. The aggregator then has to refund\n     *      the ETH back to the user through _returnETHIfAny.\n     */\n    receive() external payable {}\n\n    function _returnERC20TokensIfAny(TokenTransfer[] calldata tokenTransfers, address recipient) private {\n        uint256 tokenTransfersLength = tokenTransfers.length;\n        for (uint256 i; i < tokenTransfersLength; ) {\n            uint256 balance = IERC20(tokenTransfers[i].currency).balanceOf(address(this));\n            if (balance != 0) {\n                _executeERC20DirectTransfer(tokenTransfers[i].currency, recipient, balance);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
6     },
7     "contracts/TokenReceiver.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
9     },
10     "contracts/interfaces/ILooksRareAggregator.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {BasicOrder, TokenTransfer} from \"../libraries/OrderStructs.sol\";\n\ninterface ILooksRareAggregator {\n    /**\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     * @param orders Orders to be executed by the marketplace\n     * @param ordersExtraData Extra data for each order, specific for each marketplace\n     * @param extraData Extra data specific for each marketplace\n     */\n    struct TradeData {\n        address proxy;\n        bytes4 selector;\n        BasicOrder[] orders;\n        bytes[] ordersExtraData;\n        bytes extraData;\n    }\n\n    /**\n     * @notice Execute NFT sweeps in different marketplaces in a\n     *         single transaction\n     * @param tokenTransfers Aggregated ERC20 token transfers for all markets\n     * @param tradeData Data object to be passed downstream to each\n     *                  marketplace's proxy for execution\n     * @param originator The address that originated the transaction,\n     *                   hard coded as msg.sender if it is called directly\n     * @param recipient The address to receive the purchased NFTs\n     * @param isAtomic Flag to enable atomic trades (all or nothing)\n     *                 or partial trades\n     */\n    function execute(\n        TokenTransfer[] calldata tokenTransfers,\n        TradeData[] calldata tradeData,\n        address originator,\n        address recipient,\n        bool isAtomic\n    ) external payable;\n\n    /**\n     * @notice Emitted when a marketplace proxy's function is enabled.\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    event FunctionAdded(address proxy, bytes4 selector);\n\n    /**\n     * @notice Emitted when a marketplace proxy's function is disabled.\n     * @param proxy The marketplace proxy's address\n     * @param selector The marketplace proxy's function selector\n     */\n    event FunctionRemoved(address proxy, bytes4 selector);\n\n    /**\n     * @notice Emitted when execute is complete\n     * @param sweeper The address that submitted the transaction\n     */\n    event Sweep(address sweeper);\n\n    error AlreadySet();\n    error ETHTransferFail();\n    error InvalidFunction();\n    error UseERC20EnabledLooksRareAggregator();\n}\n"
12     },
13     "contracts/libraries/OrderEnums.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nenum CollectionType {\n    ERC721,\n    ERC1155\n}\n"
15     },
16     "contracts/libraries/OrderStructs.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {CollectionType} from \"./OrderEnums.sol\";\n\n/**\n * @param signer The order's maker\n * @param collection The address of the ERC721/ERC1155 token to be purchased\n * @param collectionType 0 for ERC721, 1 for ERC1155\n * @param tokenIds The IDs of the tokens to be purchased\n * @param amounts Always 1 when ERC721, can be > 1 if ERC1155\n * @param price The *taker bid* price to pay for the order\n * @param currency The order's currency, address(0) for ETH\n * @param startTime The timestamp when the order starts becoming valid\n * @param endTime The timestamp when the order stops becoming valid\n * @param signature split to v,r,s for LooksRare\n */\nstruct BasicOrder {\n    address signer;\n    address collection;\n    CollectionType collectionType;\n    uint256[] tokenIds;\n    uint256[] amounts;\n    uint256 price;\n    address currency;\n    uint256 startTime;\n    uint256 endTime;\n    bytes signature;\n}\n\n/**\n * @param amount ERC20 transfer amount\n * @param currency ERC20 transfer currency\n */\nstruct TokenTransfer {\n    uint256 amount;\n    address currency;\n}\n"
18     },
19     "contracts/libraries/SharedErrors.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror InvalidOrderLength();\nerror TradeExecutionFailed();\nerror ZeroAddress();\n"
21     },
22     "node_modules/@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IOwnableTwoSteps} from \"./interfaces/IOwnableTwoSteps.sol\";\n\n/**\n * @title OwnableTwoSteps\n * @notice This contract offers transfer of ownership in two steps with potential owner\n *         having to confirm the transaction to become the owner.\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\n    /**\n     * @notice Address of the current owner.\n     */\n    address public owner;\n\n    /**\n     * @notice Address of the potential owner.\n     */\n    address public potentialOwner;\n\n    /**\n     * @notice Ownership status.\n     */\n    Status public ownershipStatus;\n\n    /**\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\n     */\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param _owner The contract's owner\n     */\n    constructor(address _owner) {\n        owner = _owner;\n        emit NewOwner(_owner);\n    }\n\n    /**\n     * @notice This function is used to cancel the ownership transfer.\n     * @dev This function can be used for both cancelling a transfer to a new owner and\n     *      cancelling the renouncement of the ownership.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        Status _ownershipStatus = ownershipStatus;\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\n            revert NoOngoingTransferInProgress();\n        }\n\n        if (_ownershipStatus == Status.TransferInProgress) {\n            delete potentialOwner;\n        }\n\n        delete ownershipStatus;\n\n        emit CancelOwnershipTransfer();\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership renouncement.\n     */\n    function confirmOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.RenouncementInProgress) {\n            revert RenouncementNotInProgress();\n        }\n\n        delete owner;\n        delete ownershipStatus;\n\n        emit NewOwner(address(0));\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership transfer.\n     * @dev This function can only be called by the current potential owner.\n     */\n    function confirmOwnershipTransfer() external {\n        if (ownershipStatus != Status.TransferInProgress) {\n            revert TransferNotInProgress();\n        }\n\n        if (msg.sender != potentialOwner) {\n            revert WrongPotentialOwner();\n        }\n\n        owner = msg.sender;\n        delete ownershipStatus;\n        delete potentialOwner;\n\n        emit NewOwner(msg.sender);\n    }\n\n    /**\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\n     * @param newPotentialOwner New potential owner address\n     */\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.TransferInProgress;\n        potentialOwner = newPotentialOwner;\n\n        /**\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\n         *      We don't have to SLOAD the owner again.\n         */\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\n    }\n\n    /**\n     * @notice This function is used to initiate the ownership renouncement.\n     */\n    function initiateOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.RenouncementInProgress;\n\n        emit InitiateOwnershipRenouncement();\n    }\n\n    function _onlyOwner() private view {\n        if (msg.sender != owner) revert NotOwner();\n    }\n}\n"
24     },
25     "node_modules/@looksrare/contracts-libs/contracts/ReentrancyGuard.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IReentrancyGuard} from \"./interfaces/IReentrancyGuard.sol\";\n\n/**\n * @title ReentrancyGuard\n * @notice This contract protects against reentrancy attacks.\n *         It is adjusted from OpenZeppelin.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract ReentrancyGuard is IReentrancyGuard {\n    uint256 private _status;\n\n    /**\n     * @notice Modifier to wrap functions to prevent reentrancy calls.\n     */\n    modifier nonReentrant() {\n        if (_status == 2) {\n            revert ReentrancyFail();\n        }\n\n        _status = 2;\n        _;\n        _status = 1;\n    }\n\n    constructor() {\n        _status = 1;\n    }\n}\n"
27     },
28     "node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the call recipient is not a contract.\n */\nerror NotAContract();\n"
30     },
31     "node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the ETH transfer fails.\n */\nerror ETHTransferFail();\n\n/**\n * @notice It is emitted if the ERC20 approval fails.\n */\nerror ERC20ApprovalFail();\n\n/**\n * @notice It is emitted if the ERC20 transfer fails.\n */\nerror ERC20TransferFail();\n\n/**\n * @notice It is emitted if the ERC20 transferFrom fails.\n */\nerror ERC20TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC721 transferFrom fails.\n */\nerror ERC721TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\n */\nerror ERC1155SafeTransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\n */\nerror ERC1155SafeBatchTransferFromFail();\n"
33     },
34     "node_modules/@looksrare/contracts-libs/contracts/interfaces/IOwnableTwoSteps.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title IOwnableTwoSteps\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface IOwnableTwoSteps {\n    /**\n     * @notice This enum keeps track of the ownership status.\n     * @param NoOngoingTransfer The default status when the owner is set\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\n     */\n    enum Status {\n        NoOngoingTransfer,\n        TransferInProgress,\n        RenouncementInProgress\n    }\n\n    /**\n     * @notice This is returned when there is no transfer of ownership in progress.\n     */\n    error NoOngoingTransferInProgress();\n\n    /**\n     * @notice This is returned when the caller is not the owner.\n     */\n    error NotOwner();\n\n    /**\n     * @notice This is returned when there is no renouncement in progress but\n     *         the owner tries to validate the ownership renouncement.\n     */\n    error RenouncementNotInProgress();\n\n    /**\n     * @notice This is returned when the transfer is already in progress but the owner tries\n     *         initiate a new ownership transfer.\n     */\n    error TransferAlreadyInProgress();\n\n    /**\n     * @notice This is returned when there is no ownership transfer in progress but the\n     *         ownership change tries to be approved.\n     */\n    error TransferNotInProgress();\n\n    /**\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\n     *         a caller that is not the potential owner.\n     */\n    error WrongPotentialOwner();\n\n    /**\n     * @notice This is emitted if the ownership transfer is cancelled.\n     */\n    event CancelOwnershipTransfer();\n\n    /**\n     * @notice This is emitted if the ownership renouncement is initiated.\n     */\n    event InitiateOwnershipRenouncement();\n\n    /**\n     * @notice This is emitted if the ownership transfer is initiated.\n     * @param previousOwner Previous/current owner\n     * @param potentialOwner Potential/future owner\n     */\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\n\n    /**\n     * @notice This is emitted when there is a new owner.\n     */\n    event NewOwner(address newOwner);\n}\n"
36     },
37     "node_modules/@looksrare/contracts-libs/contracts/interfaces/IReentrancyGuard.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title IReentrancyGuard\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface IReentrancyGuard {\n    /**\n     * @notice This is returned when there is a reentrant call.\n     */\n    error ReentrancyFail();\n}\n"
39     },
40     "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
42     },
43     "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
45     },
46     "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC721.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
48     },
49     "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC1155} from \"../interfaces/generic/IERC1155.sol\";\n\n// Errors\nimport {ERC1155SafeTransferFromFail, ERC1155SafeBatchTransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC1155Transfer\n * @notice This contract contains low-level calls to transfer ERC1155 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC1155Transfer {\n    /**\n     * @notice Execute ERC1155 safeTransferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenId tokenId to transfer\n     * @param amount Amount to transfer\n     */\n    function _executeERC1155SafeTransferFrom(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, amount, \"\")));\n\n        if (!status) {\n            revert ERC1155SafeTransferFromFail();\n        }\n    }\n\n    /**\n     * @notice Execute ERC1155 safeBatchTransferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenIds Array of tokenIds to transfer\n     * @param amounts Array of amounts to transfer\n     */\n    function _executeERC1155SafeBatchTransferFrom(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(\n            abi.encodeCall(IERC1155.safeBatchTransferFrom, (from, to, tokenIds, amounts, \"\"))\n        );\n\n        if (!status) {\n            revert ERC1155SafeBatchTransferFromFail();\n        }\n    }\n}\n"
51     },
52     "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Approve.sol": {
53       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC20} from \"../interfaces/generic/IERC20.sol\";\n\n// Errors\nimport {ERC20ApprovalFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC20Approve\n * @notice This contract contains low-level calls to approve ERC20 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC20Approve {\n    /**\n     * @notice Execute ERC20 approve\n     * @param currency Currency address\n     * @param to Operator address\n     * @param amount Amount to approve\n     */\n    function _executeERC20Approve(address currency, address to, uint256 amount) internal {\n        if (currency.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.approve, (to, amount)));\n\n        if (!status) {\n            revert ERC20ApprovalFail();\n        }\n\n        if (data.length > 0) {\n            if (!abi.decode(data, (bool))) {\n                revert ERC20ApprovalFail();\n            }\n        }\n    }\n}\n"
54     },
55     "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol": {
56       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC20} from \"../interfaces/generic/IERC20.sol\";\n\n// Errors\nimport {ERC20TransferFail, ERC20TransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC20Transfer\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC20Transfer {\n    /**\n     * @notice Execute ERC20 transferFrom\n     * @param currency Currency address\n     * @param from Sender address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     */\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\n        if (currency.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\n\n        if (!status) {\n            revert ERC20TransferFromFail();\n        }\n\n        if (data.length > 0) {\n            if (!abi.decode(data, (bool))) {\n                revert ERC20TransferFromFail();\n            }\n        }\n    }\n\n    /**\n     * @notice Execute ERC20 (direct) transfer\n     * @param currency Currency address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     */\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\n        if (currency.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\n\n        if (!status) {\n            revert ERC20TransferFail();\n        }\n\n        if (data.length > 0) {\n            if (!abi.decode(data, (bool))) {\n                revert ERC20TransferFail();\n            }\n        }\n    }\n}\n"
57     },
58     "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol": {
59       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC721} from \"../interfaces/generic/IERC721.sol\";\n\n// Errors\nimport {ERC721TransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC721Transfer\n * @notice This contract contains low-level calls to transfer ERC721 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC721Transfer {\n    /**\n     * @notice Execute ERC721 transferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenId tokenId to transfer\n     */\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\n\n        if (!status) {\n            revert ERC721TransferFromFail();\n        }\n    }\n}\n"
60     }
61   },
62   "settings": {
63     "remappings": [
64       "@ensdomains/=node_modules/@ensdomains/",
65       "@looksrare/=node_modules/@looksrare/",
66       "@openzeppelin/=node_modules/@openzeppelin/",
67       "ds-test/=lib/forge-std/lib/ds-test/src/",
68       "eth-gas-reporter/=node_modules/eth-gas-reporter/",
69       "forge-std/=lib/forge-std/src/",
70       "hardhat/=node_modules/hardhat/",
71       "solmate/=node_modules/solmate/"
72     ],
73     "optimizer": {
74       "enabled": true,
75       "runs": 888888
76     },
77     "metadata": {
78       "bytecodeHash": "ipfs"
79     },
80     "outputSelection": {
81       "*": {
82         "*": [
83           "evm.bytecode",
84           "evm.deployedBytecode",
85           "devdoc",
86           "userdoc",
87           "metadata",
88           "abi"
89         ]
90       }
91     },
92     "evmVersion": "london",
93     "viaIR": true,
94     "libraries": {}
95   }
96 }}