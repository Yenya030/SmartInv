1 //SPDX-License-Identifier: MIT
2 
3 
4 /*
5 
6 Telegram: https://t.me/ProofOfWoof
7 
8 
9 You Can't Keep a Good Dog Down, or a Working dog infact.
10 History (or progress) moves ahead, no matter the criticism it may attract.
11 Everything I know I learned from dogs
12 Every dog has its day, Today is ours!
13 Money can buy you a fine dog, but only love can make him wag his tail
14 
15 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
16 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
17 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
18 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
19 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
20 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
21 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
22 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬œðŸŸ§â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œ
23 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§â¬œâ¬›â¬›â¬›â¬›â¬›â¬›
24 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§â¬œâ¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›
25 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›
26 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›
27 â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬›â¬›â¬œ
28 â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œ
29 â¬›ðŸŸ§â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œ
30 â¬›ðŸŸ§ðŸŸ§â¬›â¬œâ¬›â¬›â¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
31 â¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›â¬›â¬›â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œ
32 â¬›â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œ
33 â¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œ
34 â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œ
35 â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œ
36 â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œ
37 â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œ
38 â¬œâ¬œâ¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œ
39 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œ
40 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œ
41 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬œâ¬œâ¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
42 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›â¬›ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬œâ¬›â¬›â¬›â¬›ðŸŸ§â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
43 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬›â¬›â¬›â¬›â¬›â¬›â¬›â¬›ðŸŸ§ðŸŸ§â¬›â¬›â¬›â¬›ðŸŸ§ðŸŸ§â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œ
44 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬œâ¬›â¬œâ¬›ðŸŸ§ðŸŸ§â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œ
45 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬œâ¬œâ¬›â¬›â¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬œâ¬›â¬œâ¬œâ¬›ðŸŸ§â¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œ
46 â¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§ðŸŸ§â¬›â¬›â¬œâ¬›â¬œâ¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§ðŸŸ§â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œ
47 â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ§â¬œâ¬œâ¬›â¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬œâ¬œâ¬œâ¬›â¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œ
48 â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
49 
50 */
51 
52 
53 pragma solidity 0.8.17;
54 
55 interface IERC20 {
56     function totalSupply() external view returns (uint256);
57     function decimals() external view returns (uint8);
58     function symbol() external view returns (string memory);
59     function name() external view returns (string memory);
60     function balanceOf(address account) external view returns (uint256);
61     function transfer(address recipient, uint256 amount) external returns (bool);
62     function allowance(address __owner, address spender) external view returns (uint256);
63     function approve(address spender, uint256 amount) external returns (bool);
64     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
65     event Transfer(address indexed from, address indexed to, uint256 value);
66     event Approval(address indexed _owner, address indexed spender, uint256 value);
67 }
68 
69 abstract contract Auth {
70     address internal _owner;
71     constructor(address creatorOwner) { _owner = creatorOwner; }
72     modifier onlyOwner() { require(msg.sender == _owner, "Only contract _owner can call this function"); _; }
73     function transferOwnership(address payable newOwner) external onlyOwner { _owner = newOwner; emit OwnershipTransferred(newOwner); }
74     event OwnershipTransferred(address _owner);
75 }
76 
77 interface IUniswapV2Factory { function createPair(address tokenA, address tokenB) external returns (address pair); }
78 interface IUniswapV2Router02 {
79     function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;
80     function WETH() external pure returns (address);
81     function factory() external pure returns (address);
82     function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);
83 }
84 
85 contract POW is IERC20, Auth {
86     uint8 private constant _decimals      = 9;
87     uint256 private constant _totalSupply = 7_900_000 * (10**_decimals);
88     string private constant _name         = "Proof of Woof";
89     string private constant _symbol       = "POW";
90 
91     uint8 private _buyTaxRate  = 1;
92     uint8 private _sellTaxRate = 1;
93 
94     uint16 private _taxSharesMarketing   = 8;
95     uint16 private _taxSharesDevelopment = 1;
96     uint16 private _taxSharesBurn        = 1;
97     uint16 private _taxSharesLP          = 0;
98     uint16 private _totalTaxShares = _taxSharesMarketing + _taxSharesDevelopment + _taxSharesBurn + _taxSharesLP;
99 
100     address payable private _walletMarketing = payable(0x3D630A0cC6f44610a392837213dec4FcCF89c1Da); 
101     address payable private _walletDevelopment = payable(0xB5104070B007d2a33AA67f35C89948Cf5e66C936); 
102 
103     uint256 private _maxTxAmount     = _totalSupply; 
104     uint256 private _maxWalletAmount = _totalSupply;
105     uint256 private _taxSwapMin = _totalSupply * 10 / 100000;
106     uint256 private _taxSwapMax = _totalSupply * 80 / 100000;
107 
108     mapping (address => uint256) private _balances;
109     mapping (address => mapping (address => uint256)) private _allowances;
110     mapping (address => bool) private _noFees;
111     mapping (address => bool) private _noLimits;
112 
113     address constant private _burnWallet = address(0);
114     address private _lpOwner;
115 
116     address private constant _swapRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
117     IUniswapV2Router02 private _primarySwapRouter = IUniswapV2Router02(_swapRouterAddress);
118     address private _primaryLP;
119     mapping (address => bool) private _isLP;
120 
121     bool private _tradingOpen;
122 
123     bool private _inTaxSwap = false;
124     modifier lockTaxSwap { _inTaxSwap = true; _; _inTaxSwap = false; }
125 
126     event TokensAirdropped(uint256 totalWallets, uint256 totalTokens);
127     event TokensBurned(address indexed burnedByWallet, uint256 tokenAmount);
128 
129     constructor() Auth(msg.sender) {
130         _lpOwner = msg.sender;
131 
132         _balances[address(this)] =  7_900_000 * (10 ** _decimals);
133         emit Transfer(address(0), address(this), _balances[address(this)]);
134 
135         _balances[_owner] = _totalSupply - _balances[address(this)];
136         emit Transfer(address(0), _owner, _balances[_owner]);
137 
138         _noFees[_owner] = true;
139         _noFees[address(this)] = true;
140         _noFees[_swapRouterAddress] = true;
141         _noFees[_walletMarketing] = true;
142         _noFees[_walletDevelopment] = true;
143         _noFees[_burnWallet] = true;
144         _noLimits[_owner] = true;
145         _noLimits[address(this)] = true;
146         _noLimits[_swapRouterAddress] = true;
147         _noLimits[_walletMarketing] = true;
148         _noLimits[_walletDevelopment] = true;
149         _noLimits[_burnWallet] = true;  
150     }
151 
152     receive() external payable {}
153     
154     function totalSupply() external pure override returns (uint256) { return _totalSupply; }
155     function decimals() external pure override returns (uint8) { return _decimals; }
156     function symbol() external pure override returns (string memory) { return _symbol; }
157     function name() external pure override returns (string memory) { return _name; }
158     function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }
159     function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }
160 
161     function approve(address spender, uint256 amount) public override returns (bool) {
162         _allowances[msg.sender][spender] = amount;
163         emit Approval(msg.sender, spender, amount);
164         return true;
165     }
166 
167     function transfer(address recipient, uint256 amount) external override returns (bool) {
168         require(_checkTradingOpen(msg.sender), "Trading not open");
169         return _transferFrom(msg.sender, recipient, amount);
170     }
171 
172     function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
173         require(_checkTradingOpen(sender), "Trading not open");
174         if(_allowances[sender][msg.sender] != type(uint256).max){
175             _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
176         }
177         return _transferFrom(sender, recipient, amount);
178     }
179 
180     function openTrading() external onlyOwner {
181         require(!_tradingOpen, "trading already open");
182         _openTrading();
183     }
184 
185     function _approveRouter(uint256 _tokenAmount) internal {
186         if ( _allowances[address(this)][_swapRouterAddress] < _tokenAmount ) {
187             _allowances[address(this)][_swapRouterAddress] = type(uint256).max;
188             emit Approval(address(this), _swapRouterAddress, type(uint256).max);
189         }
190     }
191 
192     function addInitialLiquidity() external onlyOwner lockTaxSwap {
193         require(_primaryLP == address(0), "LP exists");
194         require(address(this).balance>0, "No ETH in contract");
195         require(_balances[address(this)]>0, "No tokens in contract");
196         _primaryLP = IUniswapV2Factory(_primarySwapRouter.factory()).createPair(address(this), _primarySwapRouter.WETH());
197         _addLiquidity(_balances[address(this)], address(this).balance, false);
198         _isLP[_primaryLP] = true;
199     }
200 
201     function _addLiquidity(uint256 _tokenAmount, uint256 _ethAmountWei, bool autoburn) internal {
202         address lpTokenRecipient = _lpOwner;
203         if ( autoburn ) { lpTokenRecipient = address(0); }
204         _approveRouter(_tokenAmount);
205         _primarySwapRouter.addLiquidityETH{value: _ethAmountWei} ( address(this), _tokenAmount, 0, 0, lpTokenRecipient, block.timestamp );
206     }
207 
208     function _openTrading() internal {
209         _maxTxAmount     = _totalSupply * 1 / 100; 
210         _maxWalletAmount = _totalSupply * 1 / 100;
211         _tradingOpen = true;
212     }
213 
214     function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
215         require(sender != address(0), "No transfers from Zero wallet");
216         if (!_tradingOpen) { require(_noFees[sender] && _noLimits[sender], "Trading not open"); }
217         if ( !_inTaxSwap && _isLP[recipient] ) { _swapTaxAndLiquify(); }
218         
219         if ( sender != address(this) && recipient != address(this) && sender != _owner ) { require(_checkLimits(sender, recipient, amount), "TX exceeds limits"); }
220         uint256 _taxAmount = _calculateTax(sender, recipient, amount);
221         uint256 _transferAmount = amount - _taxAmount;
222         _balances[sender] = _balances[sender] - amount;
223         if ( _taxAmount > 0 ) { _balances[address(this)] = _balances[address(this)] + _taxAmount; }
224         _balances[recipient] = _balances[recipient] + _transferAmount;
225         emit Transfer(sender, recipient, amount);
226         return true;
227     }
228 
229     function _checkLimits(address sender, address recipient, uint256 transferAmount) internal view returns (bool) {
230         bool limitCheckPassed = true;
231         if ( _tradingOpen && !_noLimits[sender] && !_noLimits[recipient] ) {
232             if ( transferAmount > _maxTxAmount ) { limitCheckPassed = false; }
233             else if ( !_isLP[recipient] && (_balances[recipient] + transferAmount > _maxWalletAmount) ) { limitCheckPassed = false; }
234         }
235         return limitCheckPassed;
236     }
237 
238     function _checkTradingOpen(address sender) private view returns (bool){
239         bool checkResult = false;
240         if ( _tradingOpen ) { checkResult = true; } 
241         else if (_noFees[sender] && _noLimits[sender]) { checkResult = true; } 
242 
243         return checkResult;
244     }
245 
246     function _calculateTax(address sender, address recipient, uint256 amount) internal view returns (uint256) {
247         uint256 taxAmount;
248         if ( !_tradingOpen || _noFees[sender] || _noFees[recipient] ) { taxAmount = 0; }
249         else if ( _isLP[sender] ) { taxAmount = amount * _buyTaxRate / 100; }
250         else if ( _isLP[recipient] ) { taxAmount = amount * _sellTaxRate / 100; }
251         return taxAmount;
252     }
253 
254 
255     function getExemptions(address wallet) external view returns (bool noFees, bool noLimits) {
256         return ( _noFees[wallet], _noLimits[wallet] );
257     }
258     function setExemptions(address wallet, bool noFees, bool noLimits) external onlyOwner {
259         if (noLimits || noFees) { require(!_isLP[wallet], "Cannot exempt LP"); }
260         _noFees[ wallet ] = noFees;
261         _noLimits[ wallet ] = noLimits;
262     }
263     function setExtraLP(address lpContractAddress, bool isLiquidityPool) external onlyOwner { 
264         require(lpContractAddress != _primaryLP, "Cannot change the primary LP");
265         _isLP[lpContractAddress] = isLiquidityPool; 
266         if (isLiquidityPool) { 
267             _noFees[lpContractAddress] = false; 
268             _noLimits[lpContractAddress] = false; 
269         }
270     }
271     function isLP(address wallet) external view returns (bool) {
272         return _isLP[wallet];
273     }
274 
275     function getTaxInfo() external view returns (uint8 buyTax, uint8 sellTax, uint16 sharesMarketing, uint16 sharesDevelopment, uint16 sharesLP, uint16 sharesTokenBurn ) {
276         return ( _buyTaxRate, _sellTaxRate, _taxSharesMarketing, _taxSharesDevelopment, _taxSharesLP, _taxSharesBurn);
277     }
278     function setTaxRates(uint8 newBuyTax, uint8 newSellTax) external onlyOwner {
279         require(newBuyTax + newSellTax <= 99, "Roundtrip too high");
280         _buyTaxRate = newBuyTax;
281         _sellTaxRate = newSellTax;
282     }  
283     function setTaxDistribution(uint16 sharesTokenBurn, uint16 sharesAutoLP, uint16 sharesMarketing, uint16 sharesDevelopment) external onlyOwner {
284         uint16 totalShares = sharesTokenBurn + sharesAutoLP + sharesMarketing + sharesDevelopment;
285         require( totalShares > 0, "All cannot be 0");
286         _taxSharesLP = sharesAutoLP;
287         _taxSharesMarketing = sharesMarketing;
288         _taxSharesDevelopment = sharesDevelopment;
289         _totalTaxShares = totalShares;
290     }
291 
292     function getAddresses() external view returns (address owner, address primaryLP, address marketing, address development, address LPowner ) {
293         return ( _owner, _primaryLP, _walletMarketing, _walletDevelopment, _lpOwner);
294     }
295     function setTaxWallets(address newMarketing, address newDevelopment, address newLpOwner) external onlyOwner {
296         require(!_isLP[newMarketing] && !_isLP[newDevelopment] && !_isLP[newLpOwner], "LP cannot be tax wallet");
297         _walletMarketing = payable(newMarketing);
298         _walletDevelopment = payable(newDevelopment);
299         _lpOwner = newLpOwner;
300         _noFees[newMarketing] = true;
301         _noFees[newDevelopment] = true;
302         _noLimits[newMarketing] = true;
303         _noLimits[newDevelopment] = true;
304     }
305 
306     function getLimitsInfo() external view returns (uint256 maxTX, uint256 maxWallet, uint256 taxSwapMin, uint256 taxSwapMax ) {
307         return ( _maxTxAmount, _maxWalletAmount, _taxSwapMin, _taxSwapMax);
308     }
309     function increaseLimits(uint16 maxTxAmtPermile, uint16 maxWalletAmtPermile) external onlyOwner {
310         uint256 newTxAmt = _totalSupply * maxTxAmtPermile / 1000 + 1;
311         require(newTxAmt >= _maxTxAmount, "tx limit too low");
312         _maxTxAmount = newTxAmt;
313         uint256 newWalletAmt = _totalSupply * maxWalletAmtPermile / 1000 + 1;
314         require(newWalletAmt >= _maxWalletAmount, "wallet limit too low");
315         _maxWalletAmount = newWalletAmt;
316     }
317     function setTaxSwapLimits(uint32 minValue, uint32 minDivider, uint32 maxValue, uint32 maxDivider) external onlyOwner {
318         _taxSwapMin = _totalSupply * minValue / minDivider;
319         _taxSwapMax = _totalSupply * maxValue / maxDivider;
320         require(_taxSwapMax>=_taxSwapMin, "MinMax error");
321         require(_taxSwapMax>_totalSupply / 100000, "Upper threshold too low");
322         require(_taxSwapMax<_totalSupply / 100, "Upper threshold too high");
323     }
324 
325     function _burnTokens(address fromWallet, uint256 amount) private {
326         if ( amount > 0 ) {
327             _balances[fromWallet] -= amount;
328             _balances[_burnWallet] += amount;
329             emit Transfer(fromWallet, _burnWallet, amount);
330         }
331     }
332 
333     function _swapTaxAndLiquify() private lockTaxSwap {
334         uint256 _taxTokensAvailable = balanceOf(address(this));
335 
336         if ( _taxTokensAvailable >= _taxSwapMin && _tradingOpen ) {
337             if ( _taxTokensAvailable >= _taxSwapMax ) { _taxTokensAvailable = _taxSwapMax; }
338 
339             uint256 _tokensForLP = _taxTokensAvailable * _taxSharesLP / _totalTaxShares / 2;
340             uint256 _tokensToBurn = _taxTokensAvailable * _taxSharesBurn / _totalTaxShares;
341             _burnTokens(address(this), _tokensToBurn);
342             
343             uint256 _tokensToSwap = _taxTokensAvailable - _tokensForLP - _tokensToBurn;
344             if( _tokensToSwap > 10**_decimals ) {
345                 uint256 _ethPreSwap = address(this).balance;
346                 _swapTaxTokensForEth(_tokensToSwap);
347                 uint256 _ethSwapped = address(this).balance - _ethPreSwap;
348                 if ( _taxSharesLP > 0 ) {
349                     uint256 _ethWeiAmount = _ethSwapped * _taxSharesLP / _totalTaxShares ;
350                     _approveRouter(_tokensForLP);
351                     _addLiquidity(_tokensForLP, _ethWeiAmount, false);
352                 }
353             }
354             uint256 _contractETHBalance = address(this).balance;
355             if(_contractETHBalance > 0) { _distributeTaxEth(_contractETHBalance); }
356         }
357     }
358 
359     function _swapTaxTokensForEth(uint256 tokenAmount) private {
360         _approveRouter(tokenAmount);
361         address[] memory path = new address[](2);
362         path[0] = address(this);
363         path[1] = _primarySwapRouter.WETH();
364         _primarySwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount,0,path,address(this),block.timestamp);
365     }
366 
367     function _distributeTaxEth(uint256 amount) private {
368         uint16 _taxShareTotal = _taxSharesMarketing + _taxSharesDevelopment;
369         if (_taxShareTotal > 0) {
370             uint256 marketingAmount = amount * _taxSharesMarketing / _taxShareTotal;
371             uint256 developmentAmount = amount * _taxSharesDevelopment / _taxShareTotal;
372             if ( marketingAmount > 0 ) { _walletMarketing.transfer(marketingAmount); }
373             if ( developmentAmount > 0 ) { _walletDevelopment.transfer(developmentAmount); }
374         }
375     }
376 
377     function manualTaxSwapAndSend(uint8 swapTokenPercent, bool sendEth) external onlyOwner lockTaxSwap {
378         require(swapTokenPercent <= 100, "Cannot swap more than 100%");
379         uint256 tokensToSwap = balanceOf(address(this)) * swapTokenPercent / 100;
380         if (tokensToSwap > 10 ** _decimals) {
381             _swapTaxTokensForEth(tokensToSwap);
382         }
383         if (sendEth) { 
384             uint256 ethBalance = address(this).balance;
385             require(ethBalance > 0, "No tokens");
386             _distributeTaxEth(address(this).balance); 
387         }
388     }
389 
390     function burnTokens(uint256 amount) external {
391         uint256 _tokensAvailable = balanceOf(msg.sender);
392         require(amount <= _tokensAvailable, "Token balance too low");
393         _burnTokens(msg.sender, amount);
394         emit TokensBurned(msg.sender, amount);
395     }
396 
397 
398 }