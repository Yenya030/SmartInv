1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/VRGDAs/src/LogisticToLinearVRGDA.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {unsafeWadDiv} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\nimport {LogisticVRGDA} from \"./LogisticVRGDA.sol\";\n\n/// @title Logistic To Linear Variable Rate Gradual Dutch Auction\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice VRGDA with a piecewise logistic and linear issuance curve.\nabstract contract LogisticToLinearVRGDA is LogisticVRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The number of tokens that must be sold for the switch to occur.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable soldBySwitch;\n\n    /// @dev The time soldBySwitch tokens were targeted to sell by.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable switchTime;\n\n    /// @dev The total number of tokens to target selling every full unit of time.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable perTimeUnit;\n\n    /// @notice Sets pricing parameters for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    /// @param _logisticAsymptote The asymptote (minus 1) of the pre-switch logistic curve, scaled by 1e18.\n    /// @param _timeScale The steepness of the pre-switch logistic curve, scaled by 1e18.\n    /// @param _soldBySwitch The number of tokens that must be sold for the switch to occur.\n    /// @param _switchTime The time soldBySwitch tokens were targeted to sell by, scaled by 1e18.\n    /// @param _perTimeUnit The number of tokens to target selling in 1 full unit of time, scaled by 1e18.\n    constructor(\n        int256 _targetPrice,\n        int256 _priceDecayPercent,\n        int256 _logisticAsymptote,\n        int256 _timeScale,\n        int256 _soldBySwitch,\n        int256 _switchTime,\n        int256 _perTimeUnit\n    ) LogisticVRGDA(_targetPrice, _priceDecayPercent, _logisticAsymptote, _timeScale) {\n        soldBySwitch = _soldBySwitch;\n\n        switchTime = _switchTime;\n\n        perTimeUnit = _perTimeUnit;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\n        // If we've not yet reached the number of sales required for the switch\n        // to occur, we'll continue using the standard logistic VRGDA schedule.\n        if (sold < soldBySwitch) return LogisticVRGDA.getTargetSaleTime(sold);\n\n        unchecked {\n            return unsafeWadDiv(sold - soldBySwitch, perTimeUnit) + switchTime;\n        }\n    }\n}\n"
6     },
7     "lib/VRGDAs/src/LogisticVRGDA.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadLn, unsafeDiv, unsafeWadDiv} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {VRGDA} from \"./VRGDA.sol\";\n\n/// @title Logistic Variable Rate Gradual Dutch Auction\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice VRGDA with a logistic issuance curve.\nabstract contract LogisticVRGDA is VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                           PRICING PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The maximum number of tokens of tokens to sell + 1. We add\n    /// 1 because the logistic function will never fully reach its limit.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable logisticLimit;\n\n    /// @dev The maximum number of tokens of tokens to sell + 1 multiplied\n    /// by 2. We could compute it on the fly each time but this saves gas.\n    /// @dev Represented as a 36 decimal fixed point number.\n    int256 internal immutable logisticLimitDoubled;\n\n    /// @dev Time scale controls the steepness of the logistic curve,\n    /// which affects how quickly we will reach the curve's asymptote.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable timeScale;\n\n    /// @notice Sets pricing parameters for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    /// @param _maxSellable The maximum number of tokens to sell, scaled by 1e18.\n    /// @param _timeScale The steepness of the logistic curve, scaled by 1e18.\n    constructor(\n        int256 _targetPrice,\n        int256 _priceDecayPercent,\n        int256 _maxSellable,\n        int256 _timeScale\n    ) VRGDA(_targetPrice, _priceDecayPercent) {\n        // Add 1 wad to make the limit inclusive of _maxSellable.\n        logisticLimit = _maxSellable + 1e18;\n\n        // Scale by 2e18 to both double it and give it 36 decimals.\n        logisticLimitDoubled = logisticLimit * 2e18;\n\n        timeScale = _timeScale;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\n    function getTargetSaleTime(int256 sold) public view virtual override returns (int256) {\n        unchecked {\n            return -unsafeWadDiv(wadLn(unsafeDiv(logisticLimitDoubled, sold + logisticLimit) - 1e18), timeScale);\n        }\n    }\n}\n"
9     },
10     "lib/VRGDAs/src/VRGDA.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {wadExp, wadLn, wadMul, unsafeWadMul, toWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\n/// @title Variable Rate Gradual Dutch Auction\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice Sell tokens roughly according to an issuance schedule.\nabstract contract VRGDA {\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Target price for a token, to be scaled according to sales pace.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 public immutable targetPrice;\n\n    /// @dev Precomputed constant that allows us to rewrite a pow() as an exp().\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal immutable decayConstant;\n\n    /// @notice Sets target price and per time unit price decay for the VRGDA.\n    /// @param _targetPrice The target price for a token if sold on pace, scaled by 1e18.\n    /// @param _priceDecayPercent The percent price decays per unit of time with no sales, scaled by 1e18.\n    constructor(int256 _targetPrice, int256 _priceDecayPercent) {\n        targetPrice = _targetPrice;\n\n        decayConstant = wadLn(1e18 - _priceDecayPercent);\n\n        // The decay constant must be negative for VRGDAs to work.\n        require(decayConstant < 0, \"NON_NEGATIVE_DECAY_CONSTANT\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              PRICING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate the price of a token according to the VRGDA formula.\n    /// @param timeSinceStart Time passed since the VRGDA began, scaled by 1e18.\n    /// @param sold The total number of tokens that have been sold so far.\n    /// @return The price of a token according to VRGDA, scaled by 1e18.\n    function getVRGDAPrice(int256 timeSinceStart, uint256 sold) public view virtual returns (uint256) {\n        unchecked {\n            // prettier-ignore\n            return uint256(wadMul(targetPrice, wadExp(unsafeWadMul(decayConstant,\n                // Theoretically calling toWadUnsafe with sold can silently overflow but under\n                // any reasonable circumstance it will never be large enough. We use sold + 1 as\n                // the VRGDA formula's n param represents the nth token and sold is the n-1th token.\n                timeSinceStart - getTargetSaleTime(toWadUnsafe(sold + 1))\n            ))));\n        }\n    }\n\n    /// @dev Given a number of tokens sold, return the target time that number of tokens should be sold by.\n    /// @param sold A number of tokens sold, scaled by 1e18, to get the corresponding target sale time for.\n    /// @return The target time the tokens should be sold by, scaled by 1e18, where the time is\n    /// relative, such that 0 means the tokens should be sold immediately when the VRGDA begins.\n    function getTargetSaleTime(int256 sold) public view virtual returns (int256);\n}\n"
12     },
13     "lib/goo-issuance/src/LibGOO.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @title GOO (Gradual Ownership Optimization) Issuance\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @notice Implementation of the GOO Issuance mechanism.\nlibrary LibGOO {\n    using FixedPointMathLib for uint256;\n\n    /// @notice Compute goo balance based on emission multiple, last balance, and time elapsed.\n    /// @param emissionMultiple The multiple on emissions to consider when computing the balance.\n    /// @param lastBalanceWad The last checkpointed balance to apply the emission multiple over time to, scaled by 1e18.\n    /// @param timeElapsedWad The time elapsed since the last checkpoint, scaled by 1e18.\n    function computeGOOBalance(\n        uint256 emissionMultiple,\n        uint256 lastBalanceWad,\n        uint256 timeElapsedWad\n    ) internal pure returns (uint256) {\n        unchecked {\n            // We use wad math here because timeElapsedWad is, as the name indicates, a wad.\n            uint256 timeElapsedSquaredWad = timeElapsedWad.mulWadDown(timeElapsedWad);\n\n            // prettier-ignore\n            return lastBalanceWad + // The last recorded balance.\n\n            // Don't need to do wad multiplication since we're\n            // multiplying by a plain integer with no decimals.\n            // Shift right by 2 is equivalent to division by 4.\n            ((emissionMultiple * timeElapsedSquaredWad) >> 2) +\n\n            timeElapsedWad.mulWadDown( // Terms are wads, so must mulWad.\n                // No wad multiplication for emissionMultiple * lastBalance\n                // because emissionMultiple is a plain integer with no decimals.\n                // We multiply the sqrt's radicand by 1e18 because it expects ints.\n                (emissionMultiple * lastBalanceWad * 1e18).sqrt()\n            );\n        }\n    }\n}\n"
15     },
16     "lib/solmate/src/auth/Owned.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
18     },
19     "lib/solmate/src/tokens/ERC1155.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
21     },
22     "lib/solmate/src/tokens/ERC20.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
24     },
25     "lib/solmate/src/tokens/ERC721.sol": {
26       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
27     },
28     "lib/solmate/src/utils/FixedPointMathLib.sol": {
29       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
30     },
31     "lib/solmate/src/utils/LibString.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"
33     },
34     "lib/solmate/src/utils/MerkleProofLib.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"
36     },
37     "lib/solmate/src/utils/SignedWadMath.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Signed 18 decimal fixed point (wad) arithmetic library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SignedWadMath.sol)\n/// @author Modified from Remco Bloemen (https://xn--2-umb.com/22/exp-ln/index.html)\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction toWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18.\n        r := mul(x, 1000000000000000000)\n    }\n}\n\n/// @dev Takes an integer amount of seconds and converts it to a wad amount of days.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative second amounts, it assumes x is positive.\nfunction toDaysWadUnsafe(uint256 x) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and then divide it by 86400.\n        r := div(mul(x, 1000000000000000000), 86400)\n    }\n}\n\n/// @dev Takes a wad amount of days and converts it to an integer amount of seconds.\n/// @dev Will not revert on overflow, only use where overflow is not possible.\n/// @dev Not meant for negative day amounts, it assumes x is positive.\nfunction fromDaysWadUnsafe(int256 x) pure returns (uint256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 86400 and then divide it by 1e18.\n        r := div(mul(x, 86400), 1000000000000000000)\n    }\n}\n\n/// @dev Will not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by y and divide by 1e18.\n        r := sdiv(mul(x, y), 1000000000000000000)\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero and will\n/// not revert on overflow, only use where overflow is not possible.\nfunction unsafeWadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Multiply x by 1e18 and divide it by y.\n        r := sdiv(mul(x, 1000000000000000000), y)\n    }\n}\n\nfunction wadMul(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * y in r for now.\n        r := mul(x, y)\n\n        // Equivalent to require(x == 0 || (x * y) / x == y)\n        if iszero(or(iszero(x), eq(sdiv(r, x), y))) {\n            revert(0, 0)\n        }\n\n        // Scale the result down by 1e18.\n        r := sdiv(r, 1000000000000000000)\n    }\n}\n\nfunction wadDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Store x * 1e18 in r for now.\n        r := mul(x, 1000000000000000000)\n\n        // Equivalent to require(y != 0 && ((x * 1e18) / 1e18 == x))\n        if iszero(and(iszero(iszero(y)), eq(sdiv(r, 1000000000000000000), x))) {\n            revert(0, 0)\n        }\n\n        // Divide r by y.\n        r := sdiv(r, y)\n    }\n}\n\nfunction wadExp(int256 x) pure returns (int256 r) {\n    unchecked {\n        // When the result is < 0.5 we return zero. This happens when\n        // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n        if (x <= -42139678854452767551) return 0;\n\n        // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n        // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n        if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n        // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n        // for more intermediate precision and a binary basis. This base conversion\n        // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n        x = (x << 78) / 5**18;\n\n        // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n        // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n        // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n        int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n        x = x - k * 54916777467707473351141471128;\n\n        // k is in the range [-61, 195].\n\n        // Evaluate using a (6, 7)-term rational approximation.\n        // p is made monic, we'll multiply by a scale factor later.\n        int256 y = x + 1346386616545796478920950773328;\n        y = ((y * x) >> 96) + 57155421227552351082224309758442;\n        int256 p = y + x - 94201549194550492254356042504812;\n        p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n        p = p * x + (4385272521454847904659076985693276 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        int256 q = x - 2855989394907223263936484059900;\n        q = ((q * x) >> 96) + 50020603652535783019961831881945;\n        q = ((q * x) >> 96) - 533845033583426703283633433725380;\n        q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n        q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n        q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial won't have zeros in the domain as all its roots are complex.\n            // No scaling is necessary because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r should be in the range (0.09, 0.25) * 2**96.\n\n        // We now need to multiply r by:\n        // * the scale factor s = ~6.031367120.\n        // * the 2**k factor from the range reduction.\n        // * the 1e18 / 2**96 factor for base conversion.\n        // We do this all at once, with an intermediate result in 2**213\n        // basis, so the final right shift is always by a positive amount.\n        r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n    }\n}\n\nfunction wadLn(int256 x) pure returns (int256 r) {\n    unchecked {\n        require(x > 0, \"UNDEFINED\");\n\n        // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n        // We do this by multiplying by 2**96 / 10**18. But since\n        // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n        // and add ln(2**96 / 10**18) at the end.\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n\n        // Reduce range of x to (1, 2) * 2**96\n        // ln(2^k * x) = k * ln(2) + ln(x)\n        int256 k = r - 96;\n        x <<= uint256(159 - k);\n        x = int256(uint256(x) >> 159);\n\n        // Evaluate using a (8, 8)-term rational approximation.\n        // p is made monic, we will multiply by a scale factor later.\n        int256 p = x + 3273285459638523848632254066296;\n        p = ((p * x) >> 96) + 24828157081833163892658089445524;\n        p = ((p * x) >> 96) + 43456485725739037958740375743393;\n        p = ((p * x) >> 96) - 11111509109440967052023855526967;\n        p = ((p * x) >> 96) - 45023709667254063763336534515857;\n        p = ((p * x) >> 96) - 14706773417378608786704636184526;\n        p = p * x - (795164235651350426258249787498 << 96);\n\n        // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n        // q is monic by convention.\n        int256 q = x + 5573035233440673466300451813936;\n        q = ((q * x) >> 96) + 71694874799317883764090561454958;\n        q = ((q * x) >> 96) + 283447036172924575727196451306956;\n        q = ((q * x) >> 96) + 401686690394027663651624208769553;\n        q = ((q * x) >> 96) + 204048457590392012362485061816622;\n        q = ((q * x) >> 96) + 31853899698501571402653359427138;\n        q = ((q * x) >> 96) + 909429971244387300277376558375;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Div in assembly because solidity adds a zero check despite the unchecked.\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already 2**96 too large.\n            r := sdiv(p, q)\n        }\n\n        // r is in the range (0, 0.125) * 2**96\n\n        // Finalization, we need to:\n        // * multiply by the scale factor s = 5.549…\n        // * add ln(2**96 / 10**18)\n        // * add k * ln(2)\n        // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n        // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n        r *= 1677202110996718588342820967067443963516166;\n        // add ln(2) * k * 5e18 * 2**192\n        r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n        // add ln(2**96 / 10**18) * 5e18 * 2**192\n        r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n        // base conversion: mul 2**18 / 2**192\n        r >>= 174;\n    }\n}\n\n/// @dev Will return 0 instead of reverting if y is zero.\nfunction unsafeDiv(int256 x, int256 y) pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Divide x by y.\n        r := sdiv(x, y)\n    }\n}\n"
39     },
40     "src/ArtGobblers.sol": {
41       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/*                                                                              **,/*,\n                                                                     *%@&%#/*,,..........,/(%&@@#*\n                                                                 %@%,..............................#@@%\n                                                              &&,.....,,...............................,/&@*\n                                                            (@*.....**............,/,.......................(@%\n                                                           &&......*,............./,.............**............&@\n                                                          @#......**.............**..............,*........,*,..,@/\n                                                         /@......,/............../,..............,*........../,..*@.\n                                                        #@,......................*.............../,..........**...#/\n                                                      ,@&,.......................................*..........,/....(@\n                                                  *@&(*...................................................../*....(@\n                                                 @(..*%@@&%#(#@@@%%%%%&&@@@@@@@@@&&#(///..........................#@\n                                                 @%/@@@&%&&&@@&%%%%%%%#(/(((/(/(/(/(/(/(/(/(%%&@@@%(/,............#&\n                                                  @@@#/**./@%%%&%#/*************./(%@@@@&(*********(@&&@@@%(.....,&@\n                                                 ,@/.//(&@@/.     .#@%/******./&&*,      ./@&********%@/**(@#@@#,..(@\n                                                 #%****%@.           %@/****./&@      ,.    %&********%@(**&@...(@#.#@\n                                                 &#**./@/  %@&&      .@#****./@*    &@@@@&  .@/******./@@((((@&....(@\n                                                 ##**./&@ ,&@@@,     #@/****./@@      @@.  .@&*******./@%****%@@@(,\n                                                 ,@/**./%@(.      .*@@/********(&@#*,,,,/&@%/*******./@@&&&@@@#\n                                                   @&/**@&/%&&&&&%/**.//////*********./************./@&******@*\n                                                     /@@@@&(////#%&@@&(**./#&@@&(//*************./&@(********#@\n                                                       .@#**.///*****************(#@@@&&&&&@@@@&%(**********./@,\n                                                       @(*****%@#*********************&@#*********************(@\n                                                       @****./@#*./@@#//***.///(%@%*****%@*********************#@\n                                                      #&****./@%************************&@**********************@%\n                                                     .@/******.//*******************./@@(************************@/\n                                                     /@**********************************************************(@,\n                                                     @#*****************************************************%@@@@@@@.\n                                                    *@/*************************************************************#@(\n                                                    @%***************************************************************./@(\n                     /@@&&&@@                     .@/*******************************************************************&@\n                    @%######%@.                   @#***************************./%&&&%(**************#%******************&#\n                    @%######&@%&@@.             ,@(***./&#********************#@&#####%@&*************&%****************./@,\n               &&*,/@%######&@@@*.*@&,         @@****./@&*******************./%@#######%@#***********./@&*****************(@\n              ((...*%@&##%@@,..........,,,,%@&@%/*****&%****************./&@#*%@#######&@*#@%*********./@&*****************(@,\n              (@#....(@%#&&,...,/...........@(*******(@(****************(@/...*%@@@@@@%*....&@@@@&@@@@@@%/%@@##(************(@.\n              ((./(((%@%#&@/,/&@/...........%&*******%@****************./@%,.................#,............/@%***************#@\n              *@@####@@%###%&@(@(...........%&*******%@****************%@,,#%/..............................#@/***************&/\n              (#.....,&&####&@..%%..........%%*****(@@#****************#@,...................................@(***************(@\n              .@@&%%&@@&####&&.............,@(***%@(**********./#%%%%%##&@&#(,...............................#@****************&.\n               &#.....(@%###&@*............%@**%@(*******(&@&%#/////////@%...................................#@***************&@\n                 #@@@@&%####&@&&&,........%@./@%*****(@@%////////////////@@@%,...............................#@**************#@\n                     @@&&&&@@(    /&@@&%%@&@@@%**./&@(///////////////////@%.................................,@(*********./%@&.\n                      (@//@%                @%***&&(//////////////////////(&@(**,,,,./(%&@@@%/*,,****,,***./@@&&&&&&&&#//%@\n                      (@//%@               (@(*#@#////////////////////////////%@@%%%&@@#////%@/***************************&&\n                      (@//%@  .,,,,/#&&&&&&@&*#@#///////////////////////////////@%//&&///////#@(***************************@&(#@@@@@&(*.\n               ,@@@@@&&@//%@,,.,,,,,.,..,,#@./@%////////////////////////////////%@**&&////////(@(**************************&#,,,,,,,,,,,,/(#&@&\n          &@%*,,,,,,,,#@//%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@**&&/////////&@**************************#@.,,,.,,.,,&#.,,...,%@\n       (@/,,,,,,,,,,,,(@(/%@,,,,,,,,,,,,,,&%*#@(////////////////////////////////%@./%@/////////#@(*************************&%,,,(%@@@@#*,.     .,/@.\n      &%..    *&@%/,.,#@(*#@*,,.,,,,,,,,,,%@/#@(////////////////////////////////%@**#@/////////#@(*****************.//#%@@@@%%(/,...        ...,,,%&\n     ,@*.,.       ../((%&&@@@&%#((///,,,,,/@&(@(////////////////////////////////@&**#@/////////%@%###%&&&&@@@@@@%%#(**,,,,,,.         ..,,,,,,,,,,%#\n      @(,,,,,..,            ,..   ..,,,**(%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%%(((,,.,.,,,,,,.,..,,,,.,.,,,,.,..,.,,.,,,,,.,,,,,,,,,.*@%\n       @%,,,,,,,,,,,,,,,.,.,,,      .,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,.,,,,,,#@@,\n        ,@@(,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,.,,.,.,./#%&@@@@@#\n         .@#&@@@@@%*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/&@@@@@%&@%((((#@@.\n          .@%((((#@@@/#&@@@@&%#/*,.,..,,,,.,,,,,.,.,,,,,,,,,,,,,,,,..,.,..,,...,,,...,,,,,,.,,,,,,,,,,,../#%&@@@@@@@&%((///*********./(((/&&\n             %@&%%#/***********./////(((((((####%%&&@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@&&%%%%%%%%#((((((((%@&#(((((#%@%/*******************./*/\n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC1155, ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {toWadUnsafe, toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {LibGOO} from \"goo-issuance/LibGOO.sol\";\nimport {LogisticVRGDA} from \"VRGDAs/LogisticVRGDA.sol\";\n\nimport {RandProvider} from \"./utils/rand/RandProvider.sol\";\nimport {GobblersERC721} from \"./utils/token/GobblersERC721.sol\";\n\nimport {Goo} from \"./Goo.sol\";\nimport {Pages} from \"./Pages.sol\";\n\n/// @title Art Gobblers NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice An experimental decentralized art factory by Justin Roiland and Paradigm.\ncontract ArtGobblers is GobblersERC721, LogisticVRGDA, Owned, ERC1155TokenReceiver {\n    using LibString for uint256;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address of the Pages ERC721 token contract.\n    Pages public immutable pages;\n\n    /// @notice The address which receives gobblers reserved for the team.\n    address public immutable team;\n\n    /// @notice The address which receives gobblers reserved for the community.\n    address public immutable community;\n\n    /// @notice The address of a randomness provider. This provider will initially be\n    /// a wrapper around Chainlink VRF v1, but can be changed in case it is fully sunset.\n    RandProvider public randProvider;\n\n    /*//////////////////////////////////////////////////////////////\n                            SUPPLY CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maximum number of mintable gobblers.\n    uint256 public constant MAX_SUPPLY = 10000;\n\n    /// @notice Maximum amount of gobblers mintable via mintlist.\n    uint256 public constant MINTLIST_SUPPLY = 2000;\n\n    /// @notice Maximum amount of mintable legendary gobblers.\n    uint256 public constant LEGENDARY_SUPPLY = 10;\n\n    /// @notice Maximum amount of gobblers split between the reserves.\n    /// @dev Set to comprise 20% of the sum of goo mintable gobblers + reserved gobblers.\n    uint256 public constant RESERVED_SUPPLY = (MAX_SUPPLY - MINTLIST_SUPPLY - LEGENDARY_SUPPLY) / 5;\n\n    /// @notice Maximum amount of gobblers that can be minted via VRGDA.\n    // prettier-ignore\n    uint256 public constant MAX_MINTABLE = MAX_SUPPLY\n        - MINTLIST_SUPPLY\n        - LEGENDARY_SUPPLY\n        - RESERVED_SUPPLY;\n\n    /*//////////////////////////////////////////////////////////////\n                           METADATA CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Provenance hash for gobbler metadata.\n    bytes32 public immutable PROVENANCE_HASH;\n\n    /// @notice URI for gobblers pending reveal.\n    string public UNREVEALED_URI;\n\n    /// @notice Base URI for minted gobblers.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                             MINTLIST STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Merkle root of mint mintlist.\n    bytes32 public immutable merkleRoot;\n\n    /// @notice Mapping to keep track of which addresses have claimed from mintlist.\n    mapping(address => bool) public hasClaimedMintlistGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of minting.\n    uint256 public immutable mintStart;\n\n    /// @notice Number of gobblers minted from goo.\n    uint128 public numMintedFromGoo;\n\n    /*//////////////////////////////////////////////////////////////\n                         STANDARD GOBBLER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Id of the most recently minted non legendary gobbler.\n    /// @dev Will be 0 if no non legendary gobblers have been minted yet.\n    uint128 public currentNonLegendaryId;\n\n    /// @notice The number of gobblers minted to the reserves.\n    uint256 public numMintedForReserves;\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initial legendary gobbler auction price.\n    uint256 public constant LEGENDARY_GOBBLER_INITIAL_START_PRICE = 69;\n\n    /// @notice The last LEGENDARY_SUPPLY ids are reserved for legendary gobblers.\n    uint256 public constant FIRST_LEGENDARY_GOBBLER_ID = MAX_SUPPLY - LEGENDARY_SUPPLY + 1;\n\n    /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted from goo.\n    /// @dev We add 1 to LEGENDARY_SUPPLY because legendary auctions begin only after the first interval.\n    uint256 public constant LEGENDARY_AUCTION_INTERVAL = MAX_MINTABLE / (LEGENDARY_SUPPLY + 1);\n\n    /// @notice Struct holding data required for legendary gobbler auctions.\n    struct LegendaryGobblerAuctionData {\n        // Start price of current legendary gobbler auction.\n        uint128 startPrice;\n        // Number of legendary gobblers sold so far.\n        uint128 numSold;\n    }\n\n    /// @notice Data about the current legendary gobbler auction.\n    LegendaryGobblerAuctionData public legendaryGobblerAuctionData;\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding data required for gobbler reveals.\n    struct GobblerRevealsData {\n        // Last randomness obtained from the rand provider.\n        uint64 randomSeed;\n        // Next reveal cannot happen before this timestamp.\n        uint64 nextRevealTimestamp;\n        // Id of latest gobbler which has been revealed so far.\n        uint64 lastRevealedId;\n        // Remaining gobblers to be revealed with the current seed.\n        uint56 toBeRevealed;\n        // Whether we are waiting to receive a seed from the provider.\n        bool waitingForSeed;\n    }\n\n    /// @notice Data about the current state of gobbler reveals.\n    GobblerRevealsData public gobblerRevealsData;\n\n    /*//////////////////////////////////////////////////////////////\n                            GOBBLED ART STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps gobbler ids to NFT contracts and their ids to the # of those NFT ids gobbled by the gobbler.\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) public getCopiesOfArtGobbledByGobbler;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event GooBalanceUpdated(address indexed user, uint256 newGooBalance);\n\n    event GobblerClaimed(address indexed user, uint256 indexed gobblerId);\n    event GobblerPurchased(address indexed user, uint256 indexed gobblerId, uint256 price);\n    event LegendaryGobblerMinted(address indexed user, uint256 indexed gobblerId, uint256[] burnedGobblerIds);\n    event ReservedGobblersMinted(address indexed user, uint256 lastMintedGobblerId, uint256 numGobblersEach);\n\n    event RandomnessFulfilled(uint256 randomness);\n    event RandomnessRequested(address indexed user, uint256 toBeRevealed);\n    event RandProviderUpgraded(address indexed user, RandProvider indexed newRandProvider);\n\n    event GobblersRevealed(address indexed user, uint256 numGobblers, uint256 lastRevealedId);\n\n    event ArtGobbled(address indexed user, uint256 indexed gobblerId, address indexed nft, uint256 id);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidProof();\n    error AlreadyClaimed();\n    error MintStartPending();\n\n    error SeedPending();\n    error RevealsPending();\n    error RequestTooEarly();\n    error ZeroToBeRevealed();\n    error NotRandProvider();\n\n    error ReserveImbalance();\n\n    error Cannibalism();\n    error OwnerMismatch(address owner);\n\n    error NoRemainingLegendaryGobblers();\n    error CannotBurnLegendary(uint256 gobblerId);\n    error InsufficientGobblerAmount(uint256 cost);\n    error LegendaryAuctionNotStarted(uint256 gobblersLeft);\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    error NotEnoughRemainingToBeRevealed(uint256 totalRemainingToBeRevealed);\n\n    error UnauthorizedCaller(address caller);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets VRGDA parameters, mint config, relevant addresses, and URIs.\n    /// @param _merkleRoot Merkle root of mint mintlist.\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\n    /// @param _goo Address of the Goo contract.\n    /// @param _team Address of the team reserve.\n    /// @param _community Address of the community reserve.\n    /// @param _randProvider Address of the randomness provider.\n    /// @param _baseUri Base URI for revealed gobblers.\n    /// @param _unrevealedUri URI for unrevealed gobblers.\n    /// @param _provenanceHash Provenance Hash for gobbler metadata.\n    constructor(\n        // Mint config:\n        bytes32 _merkleRoot,\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        Pages _pages,\n        address _team,\n        address _community,\n        RandProvider _randProvider,\n        // URIs:\n        string memory _baseUri,\n        string memory _unrevealedUri,\n        // Provenance:\n        bytes32 _provenanceHash\n    )\n        GobblersERC721(\"Art Gobblers\", \"GOBBLER\")\n        Owned(msg.sender)\n        LogisticVRGDA(\n            69.42e18, // Target price.\n            0.31e18, // Price decay percent.\n            // Max gobblers mintable via VRGDA.\n            toWadUnsafe(MAX_MINTABLE),\n            0.0023e18 // Time scale.\n        )\n    {\n        mintStart = _mintStart;\n        merkleRoot = _merkleRoot;\n\n        goo = _goo;\n        pages = _pages;\n        team = _team;\n        community = _community;\n        randProvider = _randProvider;\n\n        BASE_URI = _baseUri;\n        UNREVEALED_URI = _unrevealedUri;\n\n        PROVENANCE_HASH = _provenanceHash;\n\n        // Set the starting price for the first legendary gobbler auction.\n        legendaryGobblerAuctionData.startPrice = uint128(LEGENDARY_GOBBLER_INITIAL_START_PRICE);\n\n        // Reveal for initial mint must wait a day from the start of the mint.\n        gobblerRevealsData.nextRevealTimestamp = uint64(_mintStart + 1 days);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          MINTLIST CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Claim from mintlist, using a merkle proof.\n    /// @dev Function does not directly enforce the MINTLIST_SUPPLY limit for gas efficiency. The\n    /// limit is enforced during the creation of the merkle proof, which will be shared publicly.\n    /// @param proof Merkle proof to verify the sender is mintlisted.\n    /// @return gobblerId The id of the gobbler that was claimed.\n    function claimGobbler(bytes32[] calldata proof) external returns (uint256 gobblerId) {\n        // If minting has not yet begun, revert.\n        if (mintStart > block.timestamp) revert MintStartPending();\n\n        // If the user has already claimed, revert.\n        if (hasClaimedMintlistGobbler[msg.sender]) revert AlreadyClaimed();\n\n        // If the user's proof is invalid, revert.\n        if (!MerkleProofLib.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender)))) revert InvalidProof();\n\n        hasClaimedMintlistGobbler[msg.sender] = true;\n\n        unchecked {\n            // Overflow should be impossible due to supply cap of 10,000.\n            emit GobblerClaimed(msg.sender, gobblerId = ++currentNonLegendaryId);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a gobbler, paying with goo.\n    /// @param maxPrice Maximum price to pay to mint the gobbler.\n    /// @param useVirtualBalance Whether the cost is paid from the\n    /// user's virtual goo balance, or from their ERC20 goo balance.\n    /// @return gobblerId The id of the gobbler that was minted.\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 gobblerId) {\n        // No need to check if we're at MAX_MINTABLE,\n        // gobblerPrice() will revert once we reach it due to its\n        // logistic nature. It will also revert prior to the mint start.\n        uint256 currentPrice = gobblerPrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        // Decrement the user's goo balance by the current\n        // price, either from virtual balance or ERC20 balance.\n        useVirtualBalance\n            ? updateUserGooBalance(msg.sender, currentPrice, GooBalanceUpdateType.DECREASE)\n            : goo.burnForGobblers(msg.sender, currentPrice);\n\n        unchecked {\n            ++numMintedFromGoo; // Overflow should be impossible due to the supply cap.\n\n            emit GobblerPurchased(msg.sender, gobblerId = ++currentNonLegendaryId, currentPrice);\n        }\n\n        _mint(msg.sender, gobblerId);\n    }\n\n    /// @notice Gobbler pricing in terms of goo.\n    /// @dev Will revert if called before minting starts\n    /// or after all gobblers have been minted via VRGDA.\n    /// @return Current price of a gobbler in terms of goo.\n    function gobblerPrice() public view returns (uint256) {\n        // We need checked math here to cause underflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), numMintedFromGoo);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     LEGENDARY GOBBLER AUCTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a legendary gobbler by burning multiple standard gobblers.\n    /// @param gobblerIds The ids of the standard gobblers to burn.\n    /// @return gobblerId The id of the legendary gobbler that was minted.\n    function mintLegendaryGobbler(uint256[] calldata gobblerIds) external returns (uint256 gobblerId) {\n        // Get the number of legendary gobblers sold up until this point.\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n\n        gobblerId = FIRST_LEGENDARY_GOBBLER_ID + numSold; // Assign id.\n\n        // This will revert if the auction hasn't started yet or legendaries\n        // have sold out entirely, so there is no need to check here as well.\n        uint256 cost = legendaryGobblerPrice();\n\n        if (gobblerIds.length < cost) revert InsufficientGobblerAmount(cost);\n\n        // Overflow should not occur in here, as most math is on emission multiples, which are inherently small.\n        unchecked {\n            uint256 burnedMultipleTotal; // The legendary's emissionMultiple will be 2x the sum of the gobblers burned.\n\n            /*//////////////////////////////////////////////////////////////\n                                    BATCH BURN LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            uint256 id; // Storing outside the loop saves ~7 gas per iteration.\n\n            for (uint256 i = 0; i < cost; ++i) {\n                id = gobblerIds[i];\n\n                if (id >= FIRST_LEGENDARY_GOBBLER_ID) revert CannotBurnLegendary(id);\n\n                GobblerData storage gobbler = getGobblerData[id];\n\n                require(gobbler.owner == msg.sender, \"WRONG_FROM\");\n\n                burnedMultipleTotal += gobbler.emissionMultiple;\n\n                delete getApproved[id];\n\n                emit Transfer(msg.sender, gobbler.owner = address(0), id);\n            }\n\n            /*//////////////////////////////////////////////////////////////\n                                 LEGENDARY MINTING LOGIC\n            //////////////////////////////////////////////////////////////*/\n\n            // The legendary's emissionMultiple is 2x the sum of the multiples of the gobblers burned.\n            getGobblerData[gobblerId].emissionMultiple = uint32(burnedMultipleTotal * 2);\n\n            // Update the user's user data struct in one big batch. We add burnedMultipleTotal to their\n            // emission multiple (not burnedMultipleTotal * 2) to account for the standard gobblers that\n            // were burned and hence should have their multiples subtracted from the user's total multiple.\n            getUserData[msg.sender].lastBalance = uint128(gooBalance(msg.sender)); // Checkpoint balance.\n            getUserData[msg.sender].lastTimestamp = uint64(block.timestamp); // Store time alongside it.\n            getUserData[msg.sender].emissionMultiple += uint32(burnedMultipleTotal); // Update multiple.\n            // Update the total number of gobblers owned by the user. The call to _mint\n            // below will increase the count by 1 to account for the new legendary gobbler.\n            getUserData[msg.sender].gobblersOwned -= uint32(cost);\n\n            // New start price is the max of LEGENDARY_GOBBLER_INITIAL_START_PRICE and cost * 2.\n            legendaryGobblerAuctionData.startPrice = uint128(\n                cost <= LEGENDARY_GOBBLER_INITIAL_START_PRICE / 2 ? LEGENDARY_GOBBLER_INITIAL_START_PRICE : cost * 2\n            );\n            legendaryGobblerAuctionData.numSold = uint128(numSold + 1); // Increment the # of legendaries sold.\n\n            // If gobblerIds has 1,000 elements this should cost around ~270,000 gas.\n            emit LegendaryGobblerMinted(msg.sender, gobblerId, gobblerIds[:cost]);\n\n            _mint(msg.sender, gobblerId);\n        }\n    }\n\n    /// @notice Calculate the legendary gobbler price in terms of gobblers, according to a linear decay function.\n    /// @dev The price of a legendary gobbler decays as gobblers are minted. The first legendary auction begins when\n    /// 1 LEGENDARY_AUCTION_INTERVAL worth of gobblers are minted, and the price decays linearly while the next interval of\n    /// gobblers are minted. Every time an additional interval is minted, a new auction begins until all legendaries have been sold.\n    /// @dev Will revert if the auction hasn't started yet or legendaries have sold out entirely.\n    /// @return The current price of the legendary gobbler being auctioned, in terms of gobblers.\n    function legendaryGobblerPrice() public view returns (uint256) {\n        // Retrieve and cache various auction parameters and variables.\n        uint256 startPrice = legendaryGobblerAuctionData.startPrice;\n        uint256 numSold = legendaryGobblerAuctionData.numSold;\n\n        // If all legendary gobblers have been sold, there are none left to auction.\n        if (numSold == LEGENDARY_SUPPLY) revert NoRemainingLegendaryGobblers();\n\n        unchecked {\n            // Get and cache the number of standard gobblers sold via VRGDA up until this point.\n            uint256 mintedFromGoo = numMintedFromGoo;\n\n            // The number of gobblers minted at the start of the auction is computed by multiplying the # of\n            // intervals that must pass before the next auction begins by the number of gobblers in each interval.\n            uint256 numMintedAtStart = (numSold + 1) * LEGENDARY_AUCTION_INTERVAL;\n\n            // If not enough gobblers have been minted to start the auction yet, return how many need to be minted.\n            if (numMintedAtStart > mintedFromGoo) revert LegendaryAuctionNotStarted(numMintedAtStart - mintedFromGoo);\n\n            // Compute how many gobblers were minted since the auction began.\n            uint256 numMintedSinceStart = mintedFromGoo - numMintedAtStart;\n\n            // prettier-ignore\n            // If we've minted the full interval or beyond it, the price has decayed to 0.\n            if (numMintedSinceStart >= LEGENDARY_AUCTION_INTERVAL) return 0;\n            // Otherwise decay the price linearly based on what fraction of the interval has been minted.\n            else return FixedPointMathLib.unsafeDivUp(startPrice * (LEGENDARY_AUCTION_INTERVAL - numMintedSinceStart), LEGENDARY_AUCTION_INTERVAL);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            RANDOMNESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Request a new random seed for revealing gobblers.\n    function requestRandomSeed() external returns (bytes32) {\n        uint256 nextRevealTimestamp = gobblerRevealsData.nextRevealTimestamp;\n\n        // A new random seed cannot be requested before the next reveal timestamp.\n        if (block.timestamp < nextRevealTimestamp) revert RequestTooEarly();\n\n        // A random seed can only be requested when all gobblers from the previous seed have been revealed.\n        // This prevents a user from requesting additional randomness in hopes of a more favorable outcome.\n        if (gobblerRevealsData.toBeRevealed != 0) revert RevealsPending();\n\n        unchecked {\n            // Prevent revealing while we wait for the seed.\n            gobblerRevealsData.waitingForSeed = true;\n\n            // Compute the number of gobblers to be revealed with the seed.\n            uint256 toBeRevealed = currentNonLegendaryId - gobblerRevealsData.lastRevealedId;\n\n            // Ensure that there are more than 0 gobblers to be revealed,\n            // otherwise the contract could waste LINK revealing nothing.\n            if (toBeRevealed == 0) revert ZeroToBeRevealed();\n\n            // Lock in the number of gobblers to be revealed from seed.\n            gobblerRevealsData.toBeRevealed = uint56(toBeRevealed);\n\n            // We enable reveals for a set of gobblers every 24 hours.\n            // Timestamp overflow is impossible on human timescales.\n            gobblerRevealsData.nextRevealTimestamp = uint64(nextRevealTimestamp + 1 days);\n\n            emit RandomnessRequested(msg.sender, toBeRevealed);\n        }\n\n        // Call out to the randomness provider.\n        return randProvider.requestRandomBytes();\n    }\n\n    /// @notice Callback from rand provider. Sets randomSeed. Can only be called by the rand provider.\n    /// @param randomness The 256 bits of verifiable randomness provided by the rand provider.\n    function acceptRandomSeed(bytes32, uint256 randomness) external {\n        // The caller must be the randomness provider, revert in the case it's not.\n        if (msg.sender != address(randProvider)) revert NotRandProvider();\n\n        // The unchecked cast to uint64 is equivalent to moduloing the randomness by 2**64.\n        gobblerRevealsData.randomSeed = uint64(randomness); // 64 bits of randomness is plenty.\n\n        gobblerRevealsData.waitingForSeed = false; // We have the seed now, open up reveals.\n\n        emit RandomnessFulfilled(randomness);\n    }\n\n    /// @notice Upgrade the rand provider contract. Useful if current VRF is sunset.\n    /// @param newRandProvider The new randomness provider contract address.\n    function upgradeRandProvider(RandProvider newRandProvider) external onlyOwner {\n        // Reset reveal state when we upgrade while the seed is pending. This gives us a\n        // safeguard against malfunctions since we won't be stuck waiting for a seed forever.\n        if (gobblerRevealsData.waitingForSeed) {\n            gobblerRevealsData.waitingForSeed = false;\n            gobblerRevealsData.toBeRevealed = 0;\n            gobblerRevealsData.nextRevealTimestamp -= 1 days;\n        }\n\n        randProvider = newRandProvider; // Update the randomness provider.\n\n        emit RandProviderUpgraded(msg.sender, newRandProvider);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          GOBBLER REVEAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Knuth shuffle to progressively reveal\n    /// new gobblers using entropy from a random seed.\n    /// @param numGobblers The number of gobblers to reveal.\n    function revealGobblers(uint256 numGobblers) external {\n        uint256 randomSeed = gobblerRevealsData.randomSeed;\n\n        uint256 lastRevealedId = gobblerRevealsData.lastRevealedId;\n\n        uint256 totalRemainingToBeRevealed = gobblerRevealsData.toBeRevealed;\n\n        // Can't reveal if we're still waiting for a new seed.\n        if (gobblerRevealsData.waitingForSeed) revert SeedPending();\n\n        // Can't reveal more gobblers than are currently remaining to be revealed with the seed.\n        if (numGobblers > totalRemainingToBeRevealed) revert NotEnoughRemainingToBeRevealed(totalRemainingToBeRevealed);\n\n        // Implements a Knuth shuffle. If something in\n        // here can overflow, we've got bigger problems.\n        unchecked {\n            for (uint256 i = 0; i < numGobblers; ++i) {\n                /*//////////////////////////////////////////////////////////////\n                                      DETERMINE RANDOM SWAP\n                //////////////////////////////////////////////////////////////*/\n\n                // Number of ids that have not been revealed. Subtract 1\n                // because we don't want to include any legendaries in the swap.\n                uint256 remainingIds = FIRST_LEGENDARY_GOBBLER_ID - lastRevealedId - 1;\n\n                // Randomly pick distance for swap.\n                uint256 distance = randomSeed % remainingIds;\n\n                // Current id is consecutive to last reveal.\n                uint256 currentId = ++lastRevealedId;\n\n                // Select swap id, adding distance to next reveal id.\n                uint256 swapId = currentId + distance;\n\n                /*//////////////////////////////////////////////////////////////\n                                       GET INDICES FOR IDS\n                //////////////////////////////////////////////////////////////*/\n\n                // Get the index of the swap id.\n                uint64 swapIndex = getGobblerData[swapId].idx == 0\n                    ? uint64(swapId) // Hasn't been shuffled before.\n                    : getGobblerData[swapId].idx; // Shuffled before.\n\n                // Get the owner of the current id.\n                address currentIdOwner = getGobblerData[currentId].owner;\n\n                // Get the index of the current id.\n                uint64 currentIndex = getGobblerData[currentId].idx == 0\n                    ? uint64(currentId) // Hasn't been shuffled before.\n                    : getGobblerData[currentId].idx; // Shuffled before.\n\n                /*//////////////////////////////////////////////////////////////\n                                  SWAP INDICES AND SET MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Determine the current id's new emission multiple.\n                uint256 newCurrentIdMultiple = 9; // For beyond 7963.\n\n                // The branchless expression below is equivalent to:\n                //      if (swapIndex <= 3054) newCurrentIdMultiple = 6;\n                // else if (swapIndex <= 5672) newCurrentIdMultiple = 7;\n                // else if (swapIndex <= 7963) newCurrentIdMultiple = 8;\n                assembly {\n                    // prettier-ignore\n                    newCurrentIdMultiple := sub(sub(sub(\n                        newCurrentIdMultiple,\n                        lt(swapIndex, 7964)),\n                        lt(swapIndex, 5673)),\n                        lt(swapIndex, 3055)\n                    )\n                }\n\n                // Swap the index and multiple of the current id.\n                getGobblerData[currentId].idx = swapIndex;\n                getGobblerData[currentId].emissionMultiple = uint32(newCurrentIdMultiple);\n\n                // Swap the index of the swap id.\n                getGobblerData[swapId].idx = currentIndex;\n\n                /*//////////////////////////////////////////////////////////////\n                                   UPDATE CURRENT ID MULTIPLE\n                //////////////////////////////////////////////////////////////*/\n\n                // Update the user data for the owner of the current id.\n                getUserData[currentIdOwner].lastBalance = uint128(gooBalance(currentIdOwner));\n                getUserData[currentIdOwner].lastTimestamp = uint64(block.timestamp);\n                getUserData[currentIdOwner].emissionMultiple += uint32(newCurrentIdMultiple);\n\n                // Update the random seed to choose a new distance for the next iteration.\n                // It is critical that we cast to uint64 here, as otherwise the random seed\n                // set after calling revealGobblers(1) thrice would differ from the seed set\n                // after calling revealGobblers(3) a single time. This would enable an attacker\n                // to choose from a number of different seeds and use whichever is most favorable.\n                // Equivalent to randomSeed = uint64(uint256(keccak256(abi.encodePacked(randomSeed))))\n                assembly {\n                    mstore(0, randomSeed) // Store the random seed in scratch space.\n\n                    // Moduloing by 2 ** 64 is equivalent to a uint64 cast.\n                    randomSeed := mod(keccak256(0, 32), exp(2, 64))\n                }\n            }\n\n            // Update all relevant reveal state.\n            gobblerRevealsData.randomSeed = uint64(randomSeed);\n            gobblerRevealsData.lastRevealedId = uint64(lastRevealedId);\n            gobblerRevealsData.toBeRevealed = uint56(totalRemainingToBeRevealed - numGobblers);\n\n            emit GobblersRevealed(msg.sender, numGobblers, lastRevealedId);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a token's URI if it has been minted.\n    /// @param gobblerId The id of the token to get the URI for.\n    function tokenURI(uint256 gobblerId) public view virtual override returns (string memory) {\n        // Between 0 and lastRevealed are revealed normal gobblers.\n        if (gobblerId <= gobblerRevealsData.lastRevealedId) {\n            if (gobblerId == 0) revert(\"NOT_MINTED\"); // 0 is not a valid id for Art Gobblers.\n\n            return string.concat(BASE_URI, uint256(getGobblerData[gobblerId].idx).toString());\n        }\n\n        // Between lastRevealed + 1 and currentNonLegendaryId are minted but not revealed.\n        if (gobblerId <= currentNonLegendaryId) return UNREVEALED_URI;\n\n        // Between currentNonLegendaryId and FIRST_LEGENDARY_GOBBLER_ID are unminted.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID) revert(\"NOT_MINTED\");\n\n        // Between FIRST_LEGENDARY_GOBBLER_ID and FIRST_LEGENDARY_GOBBLER_ID + numSold are minted legendaries.\n        if (gobblerId < FIRST_LEGENDARY_GOBBLER_ID + legendaryGobblerAuctionData.numSold)\n            return string.concat(BASE_URI, gobblerId.toString());\n\n        revert(\"NOT_MINTED\"); // Unminted legendaries and invalid token ids.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            GOBBLE ART LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Feed a gobbler a work of art.\n    /// @param gobblerId The gobbler to feed the work of art.\n    /// @param nft The ERC721 or ERC1155 contract of the work of art.\n    /// @param id The id of the work of art.\n    /// @param isERC1155 Whether the work of art is an ERC1155 token.\n    function gobble(\n        uint256 gobblerId,\n        address nft,\n        uint256 id,\n        bool isERC1155\n    ) external {\n        // Get the owner of the gobbler to feed.\n        address owner = getGobblerData[gobblerId].owner;\n\n        // The caller must own the gobbler they're feeding.\n        if (owner != msg.sender) revert OwnerMismatch(owner);\n\n        // Gobblers have taken a vow not to eat other gobblers.\n        if (nft == address(this)) revert Cannibalism();\n\n        unchecked {\n            // Increment the # of copies gobbled by the gobbler. Unchecked is\n            // safe, as an NFT can't have more than type(uint256).max copies.\n            ++getCopiesOfArtGobbledByGobbler[gobblerId][nft][id];\n        }\n\n        emit ArtGobbled(msg.sender, gobblerId, nft, id);\n\n        isERC1155\n            ? ERC1155(nft).safeTransferFrom(msg.sender, address(this), id, 1, \"\")\n            : ERC721(nft).transferFrom(msg.sender, address(this), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                GOO LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Calculate a user's virtual goo balance.\n    /// @param user The user to query balance for.\n    function gooBalance(address user) public view returns (uint256) {\n        // Compute the user's virtual goo balance using LibGOO.\n        // prettier-ignore\n        return LibGOO.computeGOOBalance(\n            getUserData[user].emissionMultiple,\n            getUserData[user].lastBalance,\n            uint256(toDaysWadUnsafe(block.timestamp - getUserData[user].lastTimestamp))\n        );\n    }\n\n    /// @notice Add goo to your emission balance,\n    /// burning the corresponding ERC20 balance.\n    /// @param gooAmount The amount of goo to add.\n    function addGoo(uint256 gooAmount) external {\n        // Burn goo being added to gobbler.\n        goo.burnForGobblers(msg.sender, gooAmount);\n\n        // Increase msg.sender's virtual goo balance.\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.INCREASE);\n    }\n\n    /// @notice Remove goo from your emission balance, and\n    /// add the corresponding amount to your ERC20 balance.\n    /// @param gooAmount The amount of goo to remove.\n    function removeGoo(uint256 gooAmount) external {\n        // Decrease msg.sender's virtual goo balance.\n        updateUserGooBalance(msg.sender, gooAmount, GooBalanceUpdateType.DECREASE);\n\n        // Mint the corresponding amount of ERC20 goo.\n        goo.mintForGobblers(msg.sender, gooAmount);\n    }\n\n    /// @notice Burn an amount of a user's virtual goo balance. Only callable\n    /// by the Pages contract to enable purchasing pages with virtual balance.\n    /// @param user The user whose virtual goo balance we should burn from.\n    /// @param gooAmount The amount of goo to burn from the user's virtual balance.\n    function burnGooForPages(address user, uint256 gooAmount) external {\n        // The caller must be the Pages contract, revert otherwise.\n        if (msg.sender != address(pages)) revert UnauthorizedCaller(msg.sender);\n\n        // Burn the requested amount of goo from the user's virtual goo balance.\n        // Will revert if the user doesn't have enough goo in their virtual balance.\n        updateUserGooBalance(user, gooAmount, GooBalanceUpdateType.DECREASE);\n    }\n\n    /// @dev An enum for representing whether to\n    /// increase or decrease a user's goo balance.\n    enum GooBalanceUpdateType {\n        INCREASE,\n        DECREASE\n    }\n\n    /// @notice Update a user's virtual goo balance.\n    /// @param user The user whose virtual goo balance we should update.\n    /// @param gooAmount The amount of goo to update the user's virtual balance by.\n    /// @param updateType Whether to increase or decrease the user's balance by gooAmount.\n    function updateUserGooBalance(\n        address user,\n        uint256 gooAmount,\n        GooBalanceUpdateType updateType\n    ) internal {\n        // Will revert due to underflow if we're decreasing by more than the user's current balance.\n        // Don't need to do checked addition in the increase case, but we do it anyway for convenience.\n        uint256 updatedBalance = updateType == GooBalanceUpdateType.INCREASE\n            ? gooBalance(user) + gooAmount\n            : gooBalance(user) - gooAmount;\n\n        // Snapshot the user's new goo balance with the current timestamp.\n        getUserData[user].lastBalance = uint128(updatedBalance);\n        getUserData[user].lastTimestamp = uint64(block.timestamp);\n\n        emit GooBalanceUpdated(user, updatedBalance);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     RESERVED GOBBLERS MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of gobblers to the reserves.\n    /// @param numGobblersEach The number of gobblers to mint to each reserve.\n    /// @dev Gobblers minted to reserves cannot comprise more than 20% of the sum of\n    /// the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n    function mintReservedGobblers(uint256 numGobblersEach) external returns (uint256 lastMintedGobblerId) {\n        unchecked {\n            // Optimistically increment numMintedForReserves, may be reverted below.\n            // Overflow in this calculation is possible but numGobblersEach would have to\n            // be so large that it would cause the loop in _batchMint to run out of gas quickly.\n            uint256 newNumMintedForReserves = numMintedForReserves += (numGobblersEach * 2);\n\n            // Ensure that after this mint gobblers minted to reserves won't comprise more than 20% of\n            // the sum of the supply of goo minted gobblers and the supply of gobblers minted to reserves.\n            if (newNumMintedForReserves > (numMintedFromGoo + newNumMintedForReserves) / 5) revert ReserveImbalance();\n        }\n\n        // Mint numGobblersEach gobblers to both the team and community reserve.\n        lastMintedGobblerId = _batchMint(team, numGobblersEach, currentNonLegendaryId);\n        lastMintedGobblerId = _batchMint(community, numGobblersEach, lastMintedGobblerId);\n\n        currentNonLegendaryId = uint128(lastMintedGobblerId); // Set currentNonLegendaryId.\n\n        emit ReservedGobblersMinted(msg.sender, lastMintedGobblerId, numGobblersEach);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          CONVENIENCE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Convenience function to get emissionMultiple for a gobbler.\n    /// @param gobblerId The gobbler to get emissionMultiple for.\n    function getGobblerEmissionMultiple(uint256 gobblerId) external view returns (uint256) {\n        return getGobblerData[gobblerId].emissionMultiple;\n    }\n\n    /// @notice Convenience function to get emissionMultiple for a user.\n    /// @param user The user to get emissionMultiple for.\n    function getUserEmissionMultiple(address user) external view returns (uint256) {\n        return getUserData[user].emissionMultiple;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        require(from == getGobblerData[id].owner, \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        delete getApproved[id];\n\n        getGobblerData[id].owner = to;\n\n        unchecked {\n            uint32 emissionMultiple = getGobblerData[id].emissionMultiple; // Caching saves gas.\n\n            // We update their last balance before updating their emission multiple to avoid\n            // penalizing them by retroactively applying their new (lower) emission multiple.\n            getUserData[from].lastBalance = uint128(gooBalance(from));\n            getUserData[from].lastTimestamp = uint64(block.timestamp);\n            getUserData[from].emissionMultiple -= emissionMultiple;\n            getUserData[from].gobblersOwned -= 1;\n\n            // We update their last balance before updating their emission multiple to avoid\n            // overpaying them by retroactively applying their new (higher) emission multiple.\n            getUserData[to].lastBalance = uint128(gooBalance(to));\n            getUserData[to].lastTimestamp = uint64(block.timestamp);\n            getUserData[to].emissionMultiple += emissionMultiple;\n            getUserData[to].gobblersOwned += 1;\n        }\n\n        emit Transfer(from, to, id);\n    }\n}\n"
42     },
43     "src/Goo.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/*                                                                %#/*********(&,\n                                                              .#*********************#.\n                                                            #****./*********************%\n                                                          %*******************************%\n                                                        &**********************************,((\n                                                       @(*,***********************************#&\n                                                    (*********************#***********************(\n                                                  ,%@/**************#%***%**&***%*******************,\n                                                  /********************#****#*#******,**************%\n                                                 ,************,#(*****************(#/&(*,*,*********#\n                                                 **************(%%(&************#@%(///************(\n                                                ./**************,*./##****************************#*%\n                                               #**&**************************************************&@@@@@&@&%#((./.\n                                              (*******************@&%&@@@.   /    %  &********(@/,****,,,*,,,****,,*,**********,*,\n                                             &******************#  /    *     /   /    .. %/****(******************,**&***********./\n                                  /%(*******************&***./#    #.#%%    .,    .,   ##&&@****#***********************************.\n                         *#(*,**************************(***(///.*     *     #     #   .  %*****(/*************************************&\n                 *(***********************************.//****&    #     #    (#&((%@*,*&(******(%************./@#*   *%&%(/&*************(\n               #,**************************************,&******&..*#&(*****,,,,/********************************             (/******,**,**,\n              %*****************************************.//**************#**************************************               .(***********#\n             (*************************./************************************************************************              @**************\n             ,**********&@@@&&%#        &,**********************************************************************@             ./*,%*,********./\n            ***********                .************@(*************(&#///////////////.//#&%/*****************&*,,                &************%\n           (**********.                 .%********************(&./////////////////////////////(%******************                *(**&,&##*\n          #**********(,                &,*./***************%(///////////////////////////////////*&****************\n        (************%                %,*****************&///////////////////////////////////////*(***************.\n      .(***************(             #******************&//////////////////////////////////////////****************\n     .&*************%*./            .*******************%/////////////////////////////////////////****************##\n      .*************%*%             (********************#(///////////////////////////////////(#*****************&**,***,.\n           #***./,***%              #**********************,%%*./////////////////////////*(@*******************(/****./********,((\n           @@,                    &**@*****************************./(%@&%%((((((%&&%(*********************************&,**********.\n                         .   .#,,*****./&/*****************************************************************************************\n                          %,******************************************************************************************************#\n                       %*******@*****************************************************./#%%,...((,           .,********************(\n                     ,*******************************@&(**./%&%*        .,//(//////////,                           ,************./\n                      /**************************&*                      ////*(/////////                            ***(*********%\n                       (*********************(#                         ..///////////(//(                          .***********./\n                         #******************%                       *..,,,(//////////(//(*.//,                     %***************&\n                           %*****************                   ////////&&&&&&&&%#(//(&@&#(#@@                    &*********************#\n                             #****************.                 ,//(//////(@@%%%%%///////****&                   &************************(\n                           .**&***(************./               .@.,(///(/(.//(***((*(//*****@/&                ,*************************./\n                            &********************#             .(#(@#//(****(//(*****(/(&(..&(                  ./*********************(#.\n                        #/***********************./          /,,./*((#%@(%&%(((((((#%&&&/(#(#@(\n                      #*,***********************,*&                 .%@@@&#,  ///(/*\n                     (*************************%                             ..(/,./(,.,*\n                      /#/*./(%&(.*/\n\n/// @title Goo Token (GOO)\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Goo is the in-game token for ArtGobblers. It's a standard ERC20\n/// token that can be burned and minted by the gobblers and pages contract.\ncontract Goo is ERC20(\"Goo\", \"GOO\", 18) {\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the Art Gobblers contract.\n    address public immutable artGobblers;\n\n    /// @notice The address of the Pages contract.\n    address public immutable pages;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error Unauthorized();\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the addresses of relevant contracts.\n    /// @param _artGobblers Address of the ArtGobblers contract.\n    /// @param _pages Address of the Pages contract.\n    constructor(address _artGobblers, address _pages) {\n        artGobblers = _artGobblers;\n        pages = _pages;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Requires caller address to match user address.\n    modifier only(address user) {\n        if (msg.sender != user) revert Unauthorized();\n\n        _;\n    }\n\n    /// @notice Mint any amount of goo to a user. Can only be called by ArtGobblers.\n    /// @param to The address of the user to mint goo to.\n    /// @param amount The amount of goo to mint.\n    function mintForGobblers(address to, uint256 amount) external only(artGobblers) {\n        _mint(to, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by ArtGobblers.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForGobblers(address from, uint256 amount) external only(artGobblers) {\n        _burn(from, amount);\n    }\n\n    /// @notice Burn any amount of goo from a user. Can only be called by Pages.\n    /// @param from The address of the user to burn goo from.\n    /// @param amount The amount of goo to burn.\n    function burnForPages(address from, uint256 amount) external only(pages) {\n        _burn(from, amount);\n    }\n}\n"
45     },
46     "src/Pages.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {toDaysWadUnsafe} from \"solmate/utils/SignedWadMath.sol\";\n\nimport {LogisticToLinearVRGDA} from \"VRGDAs/LogisticToLinearVRGDA.sol\";\n\nimport {PagesERC721} from \"./utils/token/PagesERC721.sol\";\n\nimport {Goo} from \"./Goo.sol\";\nimport {ArtGobblers} from \"./ArtGobblers.sol\";\n\n/*                                                                                   &@./(\n                                                                                    &//*&\n                                                                                   @/*.&\n                                                                                 (#/./%\n                                                             .,(#%%&@@&%#(/,    *#./#,                   .*(%@@@@&%#((//////(#&@%.\n                                                      #&@&/*./*************.///&@%&@@@@@@@@&%#(///**********./********************#&\n                                                  &@(/*****************************************************************************#/\n                                               (&**********************************************************************************@\n                                              @**********************************************************************************(&\n                                             &/*******************************************************************************%@.\n           ,(                                *&/***********************************************************************./#@@%(((#@%\n            .//                                (@/***./*****************************************************.///#&@@@&##(((#(##((##%&\n             /*.//                                 *@@&#(/////(#&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&&%%%%%####(#(((((((##(((##((#(###((((#@&\n              (****./                               @###(###(((((###(##((#(((((#(#####((((#(((((((#((((((((((((((((((((#(##(####((((#(#@\n              /******./                            &#((#########(############((#(######(########(####(##(###%&&&%########%&&%###((((####@\n              ,********./                         /&((((#(#((##(((#(((#((########(###((((((((((((((((#((%&#((#((#((((((((((#((((((((((((#@\n              .**********(                        @#(#(#####(###(#&&&#(((((((((#(((%@%##########(######&#((#&#(((##((((%&@%#((##(#(((#((#%&\n               /**********(                      /%(#(((((#((#&%(((#(###(#########(((###(((#####(###((#(%@%###(###((((##(((##&%#(##(((##(#@,\n               (**********./                     @#(#(((((###((#(#((#(((((###(((#(#%@@###((#####(###((#&%&&/.              .*#&&@#((((((((%@\n               ./**********(                    ,%((((((((##((((#&@#(##((((((##%%&&&&%%#&##((###(##((%*                          .@#(##((##@.\n                ./********./                    %#((#(((((#####@##(##%@&(.                %#((#((###%*            *(,.             %#((#(((@,\n                  /********(                    @#((#((((####@#%@#                         .&((((##(&           &@@@@@@%            &#((#&#&,\n                    /******(                   ,&(#(#((((###@&                              .&##(###&            /@@@@@@            (%((((#@%\n                      ./*#@@@@*                (%#(((((#((#&           #@@@@@&.              (%#(#((&.            /#.               ##(#(#(##@&\n                       @%(/((((&               &####(((((#@            .@@@@@@@               &((##(#@@(.                      .#&%#&(#####((##@.\n                      /#(((((((##         (#*  @##(#(((((#@             ,@@@/*               @&((####(&&#(##%%&&&%%##%&&&&&%##(((#%%(###((####((&&\n                       #((((%@@@@@.    @#(((#@*&##(((((((#@                              .%&#@#((####(((#((#(((((((((((((((((((##%((#(###((#####(#@\n                       #@/,,,@#((#%(  @((&%,,,&&%((((((#(#&,                        .%@%#((#@%(((###((((#(((##%&&&&&&&&&&&%#((((####(###(###(###((#@%\n                   #@##&(,,,(&(##(#@ &###@**#@@@@(((((((##(@@@#,            ,(@@&##(((((((((#((((#####((#%@@@@@@@@@@@@@@@@@&&%%################%%(##@&\n                %&##((((#&@@%(((((%# &##(####(#&@&(((((((#(##@#((((((((##((###(#(#(((#%&##(#####(####(##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%##(((#((%@\n             *&#((#######((((###(%&@ (#(####(((#&@%(((((####(##%&##(#((((###(###%@@%###(##%%%###(#(####@@@@&%###((##((((((((##((((((((##((((((#((##(#@\n           (&((((((((((((((((##@&/((@@&####(((((((#&&%#(#((((((((#(((((#((###(#((#&@&&@@@@@@@@%((((((#((((#((((((((((((((((((((((((((((((((((((((((((#\n         .@#(##((((((((((#((&@#%@@&%%&@&##(((###(#####(#@%##(###((#######(((#(#%@#(((#((#(######(###############(###############(###############(##(##\n        (%(#((#((((((((((#&@%#(%%,,,,&#(#@######(####(((((%%(#(#(###(#(((#%@@@@@&##(####(((#(#(#(#######(#######(#######(#######(#######(#######(##((#\n       (%((####((###(#&@########@*,,,@#(#%@(((#((#######(((#&(##(###(%@@@@@%##((#@&%####&@@%(###(###############(###############(###############(###(#\n       @((##(##(((#@%#(#((##(#(#(#&@&#(##@&&@@@&##(#(###(#((&##%&@@%##(#(#(((####((((&%((###((#&####(###(###(###(###(###(###(###(###(###(###(###(####(\n       @((#(((##@%(((((((######((###(#&@%#(#(#(#(##########(%%((((#((((#(((((((((((((#&&#(###&&(((##############(###############(###############(#####\n       .%(#(#%@#((###(#((########&@@((((&#(#####((######(##(%&#((#######(#######(#####(#####((##(#######(#######(#######(#######(#######(#######(#####\n         &##@#(#((##((#####(#&&#(((#&(((@#######(##########(&%%#(#((##(#########(############((((###############(###############(###############(#####\n          *%(((#(#(#(#(#(#%@#(((((((((##(((((((#(#(#(#(#(#(#@###(((#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#\n         ,&(##(#(#####((%@#(###((((((((####((###(########((%@&##(###############(###############(###############(###############(###############(#####\n         &#((((#(##(####&%(##(((((%@%((#(#######(######(##%@&#((((######(#######(#######(#######(#######(#######(#######(#######(#######(#######(#####\n         %###((#(##########((###((##((##########(####(#((&&###(((###############(###############(###############(###############(###############(#####\n          &#(#(#(###(###(##((###(###((##(###(###(###((#&&#######(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(###(#\n           %%(#(###(#(#(########(#####(#########(###((#&%#(#####(###############(###############(###############(###############(#############(((#####\n              (&%%#%#%#((#(#####(#######(#######(######((#&%(###(#######(#######(#######(#######(#######(#######(#######(#######((##(##((#(#(###(((###\n                       ##(#(####(###############(######(((((####(###############(###############(###############(#############(##(#((##%%&@@@@&&&%%%%%\n                         &((((((((((((((((((((((((((((((((((((##((((((((((((((((((((((((((((((((((((((((((((((((((((((((##(((##&@@&&%%%%%%%%%%%%%%%%%%\n                          &#(((#(###############(#############%&((((############(###############(###############(#######%&@&%%%%%%%%%%%%%%%%%%%%%%%%%%\n                           @####(#######(#######(#######(##(%&(((#(#####(#######(#######(#######(#######(#######((##%@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                            @#(((###############(#######((#@#(##(###############(###############(##############(%@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                             &(#(###(###(###(###(###(##((#&###(((###(###(###(###(###(###(###(###(###(###(#####@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                             /%((###############(#####((#&######(###############(###############(#(########&&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                              &#(#######(#######(######(%%##((##(#######(#######(#######(#######(####(((#@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                               @################(######(%%##((##((##############(###############(##(###@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                                &##((#(#(#(#(#(#(#(#(#(#(@##(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(#(##@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                                (%(((###########(#######(#&&##(#(###############(################(#@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                                 ##(####(#######(#######(#(#%&#((#######(#######(#######(#######(&@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                                  /%(((###(#####(########(###(#&%###############(############((#@&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/\n\n/// @title Pages NFT\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Pages is an ERC721 that can hold custom art.\ncontract Pages is PagesERC721, LogisticToLinearVRGDA {\n    using LibString for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The address of the goo ERC20 token contract.\n    Goo public immutable goo;\n\n    /// @notice The address which receives pages reserved for the community.\n    address public immutable community;\n\n    /*//////////////////////////////////////////////////////////////\n                                  URIS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI for minted pages.\n    string public BASE_URI;\n\n    /*//////////////////////////////////////////////////////////////\n                            VRGDA INPUT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Timestamp for the start of the VRGDA mint.\n    uint256 public immutable mintStart;\n\n    /// @notice Id of the most recently minted page.\n    /// @dev Will be 0 if no pages have been minted yet.\n    uint128 public currentId;\n\n    /*//////////////////////////////////////////////////////////////\n                          COMMUNITY PAGES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The number of pages minted to the community reserve.\n    uint128 public numMintedForCommunity;\n\n    /*//////////////////////////////////////////////////////////////\n                            PRICING CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev The day the switch from a logistic to translated linear VRGDA is targeted to occur.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SWITCH_DAY_WAD = 233e18;\n\n    /// @notice The minimum amount of pages that must be sold for the VRGDA issuance\n    /// schedule to switch from logistic to the \"post switch\" translated linear formula.\n    /// @dev Computed off-chain by plugging SWITCH_DAY_WAD into the uninverted pacing formula.\n    /// @dev Represented as an 18 decimal fixed point number.\n    int256 internal constant SOLD_BY_SWITCH_WAD = 8336.760939794622713006e18;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PagePurchased(address indexed user, uint256 indexed pageId, uint256 price);\n\n    event CommunityPagesMinted(address indexed user, uint256 lastMintedPageId, uint256 numPages);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error ReserveImbalance();\n\n    error PriceExceededMax(uint256 currentPrice);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets VRGDA parameters, mint start, relevant addresses, and base URI.\n    /// @param _mintStart Timestamp for the start of the VRGDA mint.\n    /// @param _goo Address of the Goo contract.\n    /// @param _community Address of the community reserve.\n    /// @param _artGobblers Address of the ArtGobblers contract.\n    /// @param _baseUri Base URI for token metadata.\n    constructor(\n        // Mint config:\n        uint256 _mintStart,\n        // Addresses:\n        Goo _goo,\n        address _community,\n        ArtGobblers _artGobblers,\n        // URIs:\n        string memory _baseUri\n    )\n        PagesERC721(_artGobblers, \"Pages\", \"PAGE\")\n        LogisticToLinearVRGDA(\n            4.2069e18, // Target price.\n            0.31e18, // Price decay percent.\n            9000e18, // Logistic asymptote.\n            0.014e18, // Logistic time scale.\n            SOLD_BY_SWITCH_WAD, // Sold by switch.\n            SWITCH_DAY_WAD, // Target switch day.\n            9e18 // Pages to target per day.\n        )\n    {\n        mintStart = _mintStart;\n\n        goo = _goo;\n\n        community = _community;\n\n        BASE_URI = _baseUri;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a page with goo, burning the cost.\n    /// @param maxPrice Maximum price to pay to mint the page.\n    /// @param useVirtualBalance Whether the cost is paid from the\n    /// user's virtual goo balance, or from their ERC20 goo balance.\n    /// @return pageId The id of the page that was minted.\n    function mintFromGoo(uint256 maxPrice, bool useVirtualBalance) external returns (uint256 pageId) {\n        // Will revert if prior to mint start.\n        uint256 currentPrice = pagePrice();\n\n        // If the current price is above the user's specified max, revert.\n        if (currentPrice > maxPrice) revert PriceExceededMax(currentPrice);\n\n        // Decrement the user's goo balance by the current\n        // price, either from virtual balance or ERC20 balance.\n        useVirtualBalance\n            ? artGobblers.burnGooForPages(msg.sender, currentPrice)\n            : goo.burnForPages(msg.sender, currentPrice);\n\n        unchecked {\n            emit PagePurchased(msg.sender, pageId = ++currentId, currentPrice);\n\n            _mint(msg.sender, pageId);\n        }\n    }\n\n    /// @notice Calculate the mint cost of a page.\n    /// @dev If the number of sales is below a pre-defined threshold, we use the\n    /// VRGDA pricing algorithm, otherwise we use the post-switch pricing formula.\n    /// @dev Reverts due to underflow if minting hasn't started yet. Done to save gas.\n    function pagePrice() public view returns (uint256) {\n        // We need checked math here to cause overflow\n        // before minting has begun, preventing mints.\n        uint256 timeSinceStart = block.timestamp - mintStart;\n\n        unchecked {\n            // The number of pages minted for the community reserve\n            // should never exceed 10% of the total supply of pages.\n            return getVRGDAPrice(toDaysWadUnsafe(timeSinceStart), currentId - numMintedForCommunity);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      COMMUNITY PAGES MINTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mint a number of pages to the community reserve.\n    /// @param numPages The number of pages to mint to the reserve.\n    /// @dev Pages minted to the reserve cannot comprise more than 10% of the sum of the\n    /// supply of goo minted pages and the supply of pages minted to the community reserve.\n    function mintCommunityPages(uint256 numPages) external returns (uint256 lastMintedPageId) {\n        unchecked {\n            // Optimistically increment numMintedForCommunity, may be reverted below.\n            // Overflow in this calculation is possible but numPages would have to be so\n            // large that it would cause the loop in _batchMint to run out of gas quickly.\n            uint256 newNumMintedForCommunity = numMintedForCommunity += uint128(numPages);\n\n            // Ensure that after this mint pages minted to the community reserve won't comprise more than\n            // 10% of the new total page supply. currentId is equivalent to the current total supply of pages.\n            if (newNumMintedForCommunity > ((lastMintedPageId = currentId) + numPages) / 10) revert ReserveImbalance();\n\n            // Mint the pages to the community reserve and update lastMintedPageId once minting is complete.\n            lastMintedPageId = _batchMint(community, numPages, lastMintedPageId);\n\n            currentId = uint128(lastMintedPageId); // Update currentId with the last minted page id.\n\n            emit CommunityPagesMinted(msg.sender, lastMintedPageId, numPages);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             TOKEN URI LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns a page's URI if it has been minted.\n    /// @param pageId The id of the page to get the URI for.\n    function tokenURI(uint256 pageId) public view virtual override returns (string memory) {\n        if (pageId == 0 || pageId > currentId) revert(\"NOT_MINTED\");\n\n        return string.concat(BASE_URI, pageId.toString());\n    }\n}\n"
48     },
49     "src/utils/rand/RandProvider.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Randomness Provider Interface.\n/// @author FrankieIsLost <frankie@paradigm.xyz>\n/// @author transmissions11 <t11s@paradigm.xyz>\n/// @notice Generic asynchronous randomness provider interface.\ninterface RandProvider {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event RandomBytesRequested(bytes32 requestId);\n    event RandomBytesReturned(bytes32 requestId, uint256 randomness);\n\n    /*//////////////////////////////////////////////////////////////\n                                FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Request random bytes from the randomness provider.\n    function requestRandomBytes() external returns (bytes32 requestId);\n}\n"
51     },
52     "src/utils/token/GobblersERC721.sol": {
53       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\n\n/// @notice ERC721 implementation optimized for ArtGobblers by packing balanceOf/ownerOf with user/attribute data.\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract GobblersERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) external view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                         GOBBLERS/ERC721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct holding gobbler data.\n    struct GobblerData {\n        // The current owner of the gobbler.\n        address owner;\n        // Index of token after shuffle.\n        uint64 idx;\n        // Multiple on goo issuance.\n        uint32 emissionMultiple;\n    }\n\n    /// @notice Maps gobbler ids to their data.\n    mapping(uint256 => GobblerData) public getGobblerData;\n\n    /// @notice Struct holding data relevant to each user's account.\n    struct UserData {\n        // The total number of gobblers currently owned by the user.\n        uint32 gobblersOwned;\n        // The sum of the multiples of all gobblers the user holds.\n        uint32 emissionMultiple;\n        // User's goo balance at time of last checkpointing.\n        uint128 lastBalance;\n        // Timestamp of the last goo balance checkpoint.\n        uint64 lastTimestamp;\n    }\n\n    /// @notice Maps user addresses to their account data.\n    mapping(address => UserData) public getUserData;\n\n    function ownerOf(uint256 id) external view returns (address owner) {\n        require((owner = getGobblerData[id].owner) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return getUserData[owner].gobblersOwned;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) external {\n        address owner = getGobblerData[id].owner;\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal {\n        // Does not check if the token was already minted or the recipient is address(0)\n        // because ArtGobblers.sol manages its ids in such a way that it ensures it won't\n        // double mint and will only mint to safe addresses or msg.sender who cannot be zero.\n\n        unchecked {\n            ++getUserData[to].gobblersOwned;\n        }\n\n        getGobblerData[id].owner = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId\n    ) internal returns (uint256) {\n        // Doesn't check if the tokens were already minted or the recipient is address(0)\n        // because ArtGobblers.sol manages its ids in such a way that it ensures it won't\n        // double mint and will only mint to safe addresses or msg.sender who cannot be zero.\n\n        unchecked {\n            getUserData[to].gobblersOwned += uint32(amount);\n\n            for (uint256 i = 0; i < amount; ++i) {\n                getGobblerData[++lastMintedId].owner = to;\n\n                emit Transfer(address(0), to, lastMintedId);\n            }\n        }\n\n        return lastMintedId;\n    }\n}\n"
54     },
55     "src/utils/token/PagesERC721.sol": {
56       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {ArtGobblers} from \"../../ArtGobblers.sol\";\n\n/// @notice ERC721 implementation optimized for Pages by pre-approving them to the ArtGobblers contract.\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract PagesERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) external view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    ArtGobblers public immutable artGobblers;\n\n    constructor(\n        ArtGobblers _artGobblers,\n        string memory _name,\n        string memory _symbol\n    ) {\n        name = _name;\n        symbol = _symbol;\n        artGobblers = _artGobblers;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) external view returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool isApproved) {\n        if (operator == address(artGobblers)) return true; // Skip approvals for the ArtGobblers contract.\n\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) external {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll(from, msg.sender) || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) external {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal {\n        // Does not check the token has not been already minted\n        // or is being minted to address(0) because ids in Pages.sol\n        // are set using a monotonically increasing counter and only\n        // minted to safe addresses or msg.sender who cannot be zero.\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _batchMint(\n        address to,\n        uint256 amount,\n        uint256 lastMintedId\n    ) internal returns (uint256) {\n        // Doesn't check if the tokens were already minted or the recipient is address(0)\n        // because Pages.sol manages its ids in a way that it ensures it won't double\n        // mint and will only mint to safe addresses or msg.sender who cannot be zero.\n\n        unchecked {\n            _balanceOf[to] += amount;\n\n            for (uint256 i = 0; i < amount; ++i) {\n                _ownerOf[++lastMintedId] = to;\n\n                emit Transfer(address(0), to, lastMintedId);\n            }\n        }\n\n        return lastMintedId;\n    }\n}\n"
57     }
58   },
59   "settings": {
60     "remappings": [
61       "VRGDAs/=lib/VRGDAs/src/",
62       "chainlink/=lib/chainlink/contracts/src/",
63       "ds-test/=lib/ds-test/src/",
64       "forge-std/=lib/forge-std/src/",
65       "goo-issuance/=lib/goo-issuance/src/",
66       "solmate/=lib/solmate/src/"
67     ],
68     "optimizer": {
69       "enabled": true,
70       "runs": 1000000
71     },
72     "metadata": {
73       "bytecodeHash": "none"
74     },
75     "outputSelection": {
76       "*": {
77         "*": [
78           "evm.bytecode",
79           "evm.deployedBytecode",
80           "devdoc",
81           "userdoc",
82           "metadata",
83           "abi"
84         ]
85       }
86     },
87     "evmVersion": "london",
88     "libraries": {}
89   }
90 }}