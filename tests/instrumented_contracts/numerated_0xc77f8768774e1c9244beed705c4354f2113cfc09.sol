1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/0.8.9/DepositSecurityModule.sol": {
5       "content": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport {ECDSA} from \"../common/lib/ECDSA.sol\";\n\ninterface ILido {\n    function deposit(\n        uint256 _maxDepositsCount,\n        uint256 _stakingModuleId,\n        bytes calldata _depositCalldata\n    ) external;\n    function canDeposit() external view returns (bool);\n}\n\ninterface IDepositContract {\n    function get_deposit_root() external view returns (bytes32 rootHash);\n}\n\ninterface IStakingRouter {\n    function pauseStakingModule(uint256 _stakingModuleId) external;\n    function resumeStakingModule(uint256 _stakingModuleId) external;\n    function getStakingModuleIsDepositsPaused(uint256 _stakingModuleId) external view returns (bool);\n    function getStakingModuleIsActive(uint256 _stakingModuleId) external view returns (bool);\n    function getStakingModuleNonce(uint256 _stakingModuleId) external view returns (uint256);\n    function getStakingModuleLastDepositBlock(uint256 _stakingModuleId) external view returns (uint256);\n    function hasStakingModule(uint256 _stakingModuleId) external view returns (bool);\n}\n\n\n\ncontract DepositSecurityModule {\n    /**\n     * Short ECDSA signature as defined in https://eips.ethereum.org/EIPS/eip-2098.\n     */\n    struct Signature {\n        bytes32 r;\n        bytes32 vs;\n    }\n\n    event OwnerChanged(address newValue);\n    event PauseIntentValidityPeriodBlocksChanged(uint256 newValue);\n    event MaxDepositsChanged(uint256 newValue);\n    event MinDepositBlockDistanceChanged(uint256 newValue);\n    event GuardianQuorumChanged(uint256 newValue);\n    event GuardianAdded(address guardian);\n    event GuardianRemoved(address guardian);\n    event DepositsPaused(address indexed guardian, uint24 indexed stakingModuleId);\n    event DepositsUnpaused(uint24 indexed stakingModuleId);\n\n    error ZeroAddress(string field);\n    error DuplicateAddress(address addr);\n    error NotAnOwner(address caller);\n    error InvalidSignature();\n    error SignaturesNotSorted();\n    error DepositNoQuorum();\n    error DepositRootChanged();\n    error DepositInactiveModule();\n    error DepositTooFrequent();\n    error DepositUnexpectedBlockHash();\n    error DepositNonceChanged();\n    error PauseIntentExpired();\n    error NotAGuardian(address addr);\n    error ZeroParameter(string parameter);\n\n    bytes32 public immutable ATTEST_MESSAGE_PREFIX;\n    bytes32 public immutable PAUSE_MESSAGE_PREFIX;\n\n    ILido public immutable LIDO;\n    IStakingRouter public immutable STAKING_ROUTER;\n    IDepositContract public immutable DEPOSIT_CONTRACT;\n\n    /**\n     * NB: both `maxDepositsPerBlock` and `minDepositBlockDistance` values\n     * must be harmonized with `OracleReportSanityChecker.churnValidatorsPerDayLimit`\n     * (see docs for the `OracleReportSanityChecker.setChurnValidatorsPerDayLimit` function)\n     */\n    uint256 internal maxDepositsPerBlock;\n    uint256 internal minDepositBlockDistance;\n    uint256 internal pauseIntentValidityPeriodBlocks;\n\n    address internal owner;\n\n    uint256 internal quorum;\n    address[] internal guardians;\n    mapping(address => uint256) internal guardianIndicesOneBased; // 1-based\n\n    constructor(\n        address _lido,\n        address _depositContract,\n        address _stakingRouter,\n        uint256 _maxDepositsPerBlock,\n        uint256 _minDepositBlockDistance,\n        uint256 _pauseIntentValidityPeriodBlocks\n    ) {\n        if (_lido == address(0)) revert ZeroAddress(\"_lido\");\n        if (_depositContract == address(0)) revert ZeroAddress (\"_depositContract\");\n        if (_stakingRouter == address(0)) revert ZeroAddress (\"_stakingRouter\");\n\n        LIDO = ILido(_lido);\n        STAKING_ROUTER = IStakingRouter(_stakingRouter);\n        DEPOSIT_CONTRACT = IDepositContract(_depositContract);\n\n        ATTEST_MESSAGE_PREFIX = keccak256(\n            abi.encodePacked(\n                // keccak256(\"lido.DepositSecurityModule.ATTEST_MESSAGE\")\n                bytes32(0x1085395a994e25b1b3d0ea7937b7395495fb405b31c7d22dbc3976a6bd01f2bf),\n                block.chainid,\n                address(this)\n            )\n        );\n\n        PAUSE_MESSAGE_PREFIX = keccak256(\n            abi.encodePacked(\n                // keccak256(\"lido.DepositSecurityModule.PAUSE_MESSAGE\")\n                bytes32(0x9c4c40205558f12027f21204d6218b8006985b7a6359bcab15404bcc3e3fa122),\n                block.chainid,\n                address(this)\n            )\n        );\n\n        _setOwner(msg.sender);\n        _setMaxDeposits(_maxDepositsPerBlock);\n        _setMinDepositBlockDistance(_minDepositBlockDistance);\n        _setPauseIntentValidityPeriodBlocks(_pauseIntentValidityPeriodBlocks);\n    }\n\n    /**\n     * Returns the owner address.\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert NotAnOwner(msg.sender);\n        _;\n    }\n\n    /**\n     * Sets new owner. Only callable by the current owner.\n     */\n    function setOwner(address newValue) external onlyOwner {\n        _setOwner(newValue);\n    }\n\n    function _setOwner(address _newOwner) internal {\n        if (_newOwner == address(0)) revert ZeroAddress(\"_newOwner\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n\n    /**\n     * Returns current `pauseIntentValidityPeriodBlocks` contract parameter (see `pauseDeposits`).\n     */\n    function getPauseIntentValidityPeriodBlocks() external view returns (uint256) {\n        return pauseIntentValidityPeriodBlocks;\n    }\n\n    /**\n     * Sets `pauseIntentValidityPeriodBlocks`. Only callable by the owner.\n     */\n    function setPauseIntentValidityPeriodBlocks(uint256 newValue) external onlyOwner {\n        _setPauseIntentValidityPeriodBlocks(newValue);\n    }\n\n    function _setPauseIntentValidityPeriodBlocks(uint256 newValue) internal {\n        if (newValue == 0) revert ZeroParameter(\"pauseIntentValidityPeriodBlocks\");\n        pauseIntentValidityPeriodBlocks = newValue;\n        emit PauseIntentValidityPeriodBlocksChanged(newValue);\n    }\n\n    /**\n     * Returns `maxDepositsPerBlock` (see `depositBufferedEther`).\n     */\n    function getMaxDeposits() external view returns (uint256) {\n        return maxDepositsPerBlock;\n    }\n\n    /**\n     * Sets `maxDepositsPerBlock`. Only callable by the owner.\n     *\n     * NB: the value must be harmonized with `OracleReportSanityChecker.churnValidatorsPerDayLimit`\n     * (see docs for the `OracleReportSanityChecker.setChurnValidatorsPerDayLimit` function)\n     */\n    function setMaxDeposits(uint256 newValue) external onlyOwner {\n        _setMaxDeposits(newValue);\n    }\n\n    function _setMaxDeposits(uint256 newValue) internal {\n        maxDepositsPerBlock = newValue;\n        emit MaxDepositsChanged(newValue);\n    }\n\n    /**\n     * Returns `minDepositBlockDistance`  (see `depositBufferedEther`).\n     */\n    function getMinDepositBlockDistance() external view returns (uint256) {\n        return minDepositBlockDistance;\n    }\n\n    /**\n     * Sets `minDepositBlockDistance`. Only callable by the owner.\n     *\n     * NB: the value must be harmonized with `OracleReportSanityChecker.churnValidatorsPerDayLimit`\n     * (see docs for the `OracleReportSanityChecker.setChurnValidatorsPerDayLimit` function)\n     */\n    function setMinDepositBlockDistance(uint256 newValue) external onlyOwner {\n        _setMinDepositBlockDistance(newValue);\n    }\n\n    function _setMinDepositBlockDistance(uint256 newValue) internal {\n        if (newValue == 0) revert ZeroParameter(\"minDepositBlockDistance\");\n        if (newValue != minDepositBlockDistance) {\n            minDepositBlockDistance = newValue;\n            emit MinDepositBlockDistanceChanged(newValue);\n        }\n    }\n\n    /**\n     * Returns number of valid guardian signatures required to vet (depositRoot, nonce) pair.\n     */\n    function getGuardianQuorum() external view returns (uint256) {\n        return quorum;\n    }\n\n    function setGuardianQuorum(uint256 newValue) external onlyOwner {\n        _setGuardianQuorum(newValue);\n    }\n\n    function _setGuardianQuorum(uint256 newValue) internal {\n        // we're intentionally allowing setting quorum value higher than the number of guardians\n        if (quorum != newValue) {\n            quorum = newValue;\n            emit GuardianQuorumChanged(newValue);\n        }\n    }\n\n    /**\n     * Returns guardian committee member list.\n     */\n    function getGuardians() external view returns (address[] memory) {\n        return guardians;\n    }\n\n    /**\n     * Checks whether the given address is a guardian.\n     */\n    function isGuardian(address addr) external view returns (bool) {\n        return _isGuardian(addr);\n    }\n\n    function _isGuardian(address addr) internal view returns (bool) {\n        return guardianIndicesOneBased[addr] > 0;\n    }\n\n    /**\n     * Returns index of the guardian, or -1 if the address is not a guardian.\n     */\n    function getGuardianIndex(address addr) external view returns (int256) {\n        return _getGuardianIndex(addr);\n    }\n\n    function _getGuardianIndex(address addr) internal view returns (int256) {\n        return int256(guardianIndicesOneBased[addr]) - 1;\n    }\n\n    /**\n     * Adds a guardian address and sets a new quorum value.\n     * Reverts if the address is already a guardian.\n     *\n     * Only callable by the owner.\n     */\n    function addGuardian(address addr, uint256 newQuorum) external onlyOwner {\n        _addGuardian(addr);\n        _setGuardianQuorum(newQuorum);\n    }\n\n    /**\n     * Adds a set of guardian addresses and sets a new quorum value.\n     * Reverts any of them is already a guardian.\n     *\n     * Only callable by the owner.\n     */\n    function addGuardians(address[] memory addresses, uint256 newQuorum) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _addGuardian(addresses[i]);\n        }\n        _setGuardianQuorum(newQuorum);\n    }\n\n    function _addGuardian(address _newGuardian) internal {\n        if (_newGuardian == address(0)) revert ZeroAddress(\"_newGuardian\");\n        if (_isGuardian(_newGuardian)) revert DuplicateAddress(_newGuardian);\n        guardians.push(_newGuardian);\n        guardianIndicesOneBased[_newGuardian] = guardians.length;\n        emit GuardianAdded(_newGuardian);\n    }\n\n    /**\n     * Removes a guardian with the given address and sets a new quorum value.\n     *\n     * Only callable by the owner.\n     */\n    function removeGuardian(address addr, uint256 newQuorum) external onlyOwner {\n        uint256 indexOneBased = guardianIndicesOneBased[addr];\n        if (indexOneBased == 0) revert NotAGuardian(addr);\n\n        uint256 totalGuardians = guardians.length;\n        assert(indexOneBased <= totalGuardians);\n\n        if (indexOneBased != totalGuardians) {\n            address addrToMove = guardians[totalGuardians - 1];\n            guardians[indexOneBased - 1] = addrToMove;\n            guardianIndicesOneBased[addrToMove] = indexOneBased;\n        }\n\n        guardianIndicesOneBased[addr] = 0;\n        guardians.pop();\n\n        _setGuardianQuorum(newQuorum);\n\n        emit GuardianRemoved(addr);\n    }\n\n    /**\n     * Pauses deposits for staking module given that both conditions are satisfied (reverts otherwise):\n     *\n     *   1. The function is called by the guardian with index guardianIndex OR sig\n     *      is a valid signature by the guardian with index guardianIndex of the data\n     *      defined below.\n     *\n     *   2. block.number - blockNumber <= pauseIntentValidityPeriodBlocks\n     *\n     * The signature, if present, must be produced for keccak256 hash of the following\n     * message (each component taking 32 bytes):\n     *\n     * | PAUSE_MESSAGE_PREFIX | blockNumber | stakingModuleId |\n     */\n    function pauseDeposits(\n        uint256 blockNumber,\n        uint256 stakingModuleId,\n        Signature memory sig\n    ) external {\n        // In case of an emergency function `pauseDeposits` is supposed to be called\n        // by all guardians. Thus only the first call will do the actual change. But\n        // the other calls would be OK operations from the point of view of protocol’s logic.\n        // Thus we prefer not to use “error” semantics which is implied by `require`.\n\n        /// @dev pause only active modules (not already paused, nor full stopped)\n        if (!STAKING_ROUTER.getStakingModuleIsActive(stakingModuleId)) {\n            return;\n        }\n\n        address guardianAddr = msg.sender;\n        int256 guardianIndex = _getGuardianIndex(msg.sender);\n\n        if (guardianIndex == -1) {\n            bytes32 msgHash = keccak256(abi.encodePacked(PAUSE_MESSAGE_PREFIX, blockNumber, stakingModuleId));\n            guardianAddr = ECDSA.recover(msgHash, sig.r, sig.vs);\n            guardianIndex = _getGuardianIndex(guardianAddr);\n            if (guardianIndex == -1) revert InvalidSignature();\n        }\n\n        if (block.number - blockNumber >  pauseIntentValidityPeriodBlocks) revert PauseIntentExpired();\n\n        STAKING_ROUTER.pauseStakingModule(stakingModuleId);\n        emit DepositsPaused(guardianAddr, uint24(stakingModuleId));\n    }\n\n    /**\n     * Unpauses deposits for staking module\n     *\n     * Only callable by the owner.\n     */\n    function unpauseDeposits(uint256 stakingModuleId) external onlyOwner {\n         /// @dev unpause only paused modules (skip stopped)\n        if (STAKING_ROUTER.getStakingModuleIsDepositsPaused(stakingModuleId)) {\n            STAKING_ROUTER.resumeStakingModule(stakingModuleId);\n            emit DepositsUnpaused(uint24(stakingModuleId));\n        }\n    }\n\n    /**\n     * Returns whether LIDO.deposit() can be called, given that the caller will provide\n     * guardian attestations of non-stale deposit root and `nonce`, and the number of\n     * such attestations will be enough to reach quorum.\n     */\n    function canDeposit(uint256 stakingModuleId) external view returns (bool) {\n        if (!STAKING_ROUTER.hasStakingModule(stakingModuleId)) return false;\n\n        bool isModuleActive = STAKING_ROUTER.getStakingModuleIsActive(stakingModuleId);\n        uint256 lastDepositBlock = STAKING_ROUTER.getStakingModuleLastDepositBlock(stakingModuleId);\n        bool isLidoCanDeposit = LIDO.canDeposit();\n        return (\n            isModuleActive\n            && quorum > 0\n            && block.number - lastDepositBlock >= minDepositBlockDistance\n            && isLidoCanDeposit\n        );\n    }\n\n    /**\n     * Calls LIDO.deposit(maxDepositsPerBlock, stakingModuleId, depositCalldata).\n     *\n     * Reverts if any of the following is true:\n     *   1. IDepositContract.get_deposit_root() != depositRoot.\n     *   2. StakingModule.getNonce() != nonce.\n     *   3. The number of guardian signatures is less than getGuardianQuorum().\n     *   4. An invalid or non-guardian signature received.\n     *   5. block.number - StakingModule.getLastDepositBlock() < minDepositBlockDistance.\n     *   6. blockhash(blockNumber) != blockHash.\n     *\n     * Signatures must be sorted in ascending order by address of the guardian. Each signature must\n     * be produced for the keccak256 hash of the following message (each component taking 32 bytes):\n     *\n     * | ATTEST_MESSAGE_PREFIX | blockNumber | blockHash | depositRoot | stakingModuleId | nonce |\n     */\n    function depositBufferedEther(\n        uint256 blockNumber,\n        bytes32 blockHash,\n        bytes32 depositRoot,\n        uint256 stakingModuleId,\n        uint256 nonce,\n        bytes calldata depositCalldata,\n        Signature[] calldata sortedGuardianSignatures\n    ) external {\n        if (quorum == 0 || sortedGuardianSignatures.length < quorum) revert DepositNoQuorum();\n\n        bytes32 onchainDepositRoot = IDepositContract(DEPOSIT_CONTRACT).get_deposit_root();\n        if (depositRoot != onchainDepositRoot) revert DepositRootChanged();\n\n        if (!STAKING_ROUTER.getStakingModuleIsActive(stakingModuleId)) revert DepositInactiveModule();\n\n        uint256 lastDepositBlock = STAKING_ROUTER.getStakingModuleLastDepositBlock(stakingModuleId);\n        if (block.number - lastDepositBlock < minDepositBlockDistance) revert DepositTooFrequent();\n        if (blockHash == bytes32(0) || blockhash(blockNumber) != blockHash) revert DepositUnexpectedBlockHash();\n\n        uint256 onchainNonce = STAKING_ROUTER.getStakingModuleNonce(stakingModuleId);\n        if (nonce != onchainNonce) revert DepositNonceChanged();\n\n        _verifySignatures(depositRoot, blockNumber, blockHash, stakingModuleId, nonce, sortedGuardianSignatures);\n\n        LIDO.deposit(maxDepositsPerBlock, stakingModuleId, depositCalldata);\n    }\n\n    function _verifySignatures(\n        bytes32 depositRoot,\n        uint256 blockNumber,\n        bytes32 blockHash,\n        uint256 stakingModuleId,\n        uint256 nonce,\n        Signature[] memory sigs\n    ) internal view {\n        bytes32 msgHash = keccak256(\n            abi.encodePacked(ATTEST_MESSAGE_PREFIX, blockNumber, blockHash, depositRoot, stakingModuleId, nonce)\n        );\n\n        address prevSignerAddr = address(0);\n\n        for (uint256 i = 0; i < sigs.length; ++i) {\n            address signerAddr = ECDSA.recover(msgHash, sigs[i].r, sigs[i].vs);\n            if (!_isGuardian(signerAddr)) revert InvalidSignature();\n            if (signerAddr <= prevSignerAddr) revert SignaturesNotSorted();\n            prevSignerAddr = signerAddr;\n        }\n    }\n}\n"
6     },
7     "contracts/common/lib/ECDSA.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\n// Extracted from:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L53\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/541e821/contracts/utils/cryptography/ECDSA.sol#L112\n\n/* See contracts/COMPILERS.md */\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\n\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`).\n     * This address can then be used for verification purposes.\n     * Receives the `v`, `r` and `s` signature fields separately.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Overload of `recover` that receives the `r` and `vs` short-signature fields separately.\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n}\n"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": true,
14       "runs": 200
15     },
16     "evmVersion": "istanbul",
17     "outputSelection": {
18       "*": {
19         "*": [
20           "evm.bytecode",
21           "evm.deployedBytecode",
22           "devdoc",
23           "userdoc",
24           "metadata",
25           "abi"
26         ]
27       }
28     },
29     "libraries": {}
30   }
31 }}