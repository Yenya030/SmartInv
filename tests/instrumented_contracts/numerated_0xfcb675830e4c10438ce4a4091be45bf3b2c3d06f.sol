1 pragma solidity ^0.4.2;
2 
3 
4 // Etheroll Functions
5 contract DSSafeAddSub {
6     function safeToAdd(uint a, uint b) internal returns (bool) {
7         return (a + b >= a);
8     }
9     function safeAdd(uint a, uint b) internal returns (uint) {
10         require(safeToAdd(a, b));
11         return a + b;
12     }
13 
14     function safeToSubtract(uint a, uint b) internal returns (bool) {
15         return (b <= a);
16     }
17 
18     function safeSub(uint a, uint b) internal returns (uint) {
19         require(safeToSubtract(a, b));
20         return a - b;
21     }
22 }
23 
24 contract MyDice is DSSafeAddSub {
25 
26     /*
27      * checks player profit and number is within range
28     */
29     modifier betIsValid(uint _betSize, uint _playerNumber) {
30         
31     require(((((_betSize * (10000-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize <= maxProfit);
32 
33     require(_playerNumber < maxNumber);
34     require(_betSize >= minBet);
35     _;
36     }
37 
38     /*
39      * checks game is currently active
40     */
41     modifier gameIsActive {
42       require(gamePaused == false);
43         _;
44     }
45 
46     /*
47      * checks payouts are currently active
48     */
49     modifier payoutsAreActive {
50         require(payoutsPaused == false);
51         _;
52     }
53 
54  
55     /*
56      * checks only owner address is calling
57     */
58     modifier onlyOwner {
59         require(msg.sender == owner);
60          _;
61     }
62 
63     /*
64      * game vars
65     */
66 
67     uint constant public maxBetDivisor = 1000000;
68     uint constant public houseEdgeDivisor = 1000;
69     bool public gamePaused;
70     address public owner;
71     bool public payoutsPaused;
72     uint public contractBalance;
73     uint public houseEdge;
74     uint public maxProfit;
75     uint public maxProfitAsPercentOfHouse;
76     uint public minBet;
77     uint public totalBets;
78     uint public totalUserProfit;
79 
80 
81     uint private randomNumber;          
82     uint private maxNumber = 10000;
83     uint private underNumber = 5000;
84 
85     struct Bet
86     {
87         address bettorAddress;
88         uint    betSize;
89         uint    betID;
90     }
91 
92     uint public numElements = 0;
93     Bet[] pendingBets;
94 
95     mapping (address => uint) playerPendingWithdrawals;
96 
97     /*
98      * events
99     */
100     event LogBetStart(uint indexed betID);
101 
102     /* Status: 0=lose, 1=win, 2=win + failed send,*/
103     event LogResult(uint indexed BetID, address indexed PlayerAddress, uint indexed PlayerNumber, uint DiceResult, uint Value, int Status,uint BetValue,uint targetNumber);
104     /* log owner transfers */
105     event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);
106 
107     /*
108      * init
109     */
110     function MyDice() {
111 
112         owner = msg.sender;
113 
114         ownerSetHouseEdge(935);
115 
116         ownerSetMaxProfitAsPercentOfHouse(20000);
117      
118         ownerSetMinBet(20000000000000000);
119     }
120 
121     /*The generation of random numbers is generated by the banker's seed + current block of information
122     *1,The banker's seed is untrustworthy, but the current block information banker can not manipulate, in order to ensure that the banker can not manipulate the final random number results
123     *2,Block information because the whole network is open, there will be malicious players to use this point to attack the banker, so with the banker issued the seeds to ensure that the banker will not be attacked by malicious players
124     */
125    
126     function GetRandomNumber(uint32 seed) internal 
127         returns(uint randomNum)
128     {
129         randomNumber = randomNumber % block.timestamp + uint256(block.blockhash(block.number - 1));
130         randomNumber = randomNumber + block.timestamp * block.difficulty * block.number + 1;
131 
132         randomNumber = uint(sha3(randomNumber,seed));
133 
134         return (maxNumber - randomNumber % maxNumber);
135     }
136 
137 
138     function StartRollDice(uint32 seed) public
139         gameIsActive
140         onlyOwner
141     {
142         if(numElements == 0)
143           return;
144 
145         uint i = numElements - 1;
146         uint randResult = GetRandomNumber(seed);
147         /*
148         * pay winner
149         * update contract balance to calculate new max bet
150         * send reward
151         * if send of reward fails save value to playerPendingWithdrawals
152         */
153         if(randResult < underNumber){
154 
155             uint playerProfit = ((((pendingBets[i].betSize * (maxNumber-(safeSub(underNumber,1)))) / (safeSub(underNumber,1))+pendingBets[i].betSize))*houseEdge/houseEdgeDivisor)-pendingBets[i].betSize;
156 
157             /* safely reduce contract balance by player profit */
158             contractBalance = safeSub(contractBalance, playerProfit);
159 
160             /* safely calculate total payout as player profit plus original wager */
161             uint reward = safeAdd(playerProfit, pendingBets[i].betSize);
162 
163             totalUserProfit = totalUserProfit + playerProfit; // total profits
164 
165             LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, reward, 1, pendingBets[i].betSize,underNumber);
166 
167             /* update maximum profit */
168             setMaxProfit();
169 
170             /*
171             * send win - external call to an untrusted contract
172             * if send fails map reward value to playerPendingWithdrawals[address]
173             * for withdrawal later via playerWithdrawPendingTransactions
174             */
175             if(!pendingBets[i].bettorAddress.send(reward)){
176                 LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, reward, 2, pendingBets[i].betSize,underNumber);
177 
178                 /* if send failed let player withdraw via playerWithdrawPendingTransactions */
179                 playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], reward);
180             }
181 
182             numElements -= 1;
183             return;
184         }
185 
186         /*
187         * no win
188         * send 1 wei to a losing bet
189         * update contract balance to calculate new max bet
190         */
191         if(randResult >= underNumber){
192 
193             LogResult(pendingBets[i].betID, pendingBets[i].bettorAddress, underNumber, randResult, pendingBets[i].betSize, 0, pendingBets[i].betSize,underNumber);
194 
195             /*
196             *  safe adjust contractBalance
197             *  setMaxProfit
198             *  send 1 wei to losing bet
199             */
200             contractBalance = safeAdd(contractBalance, pendingBets[i].betSize-1);
201 
202             /* update maximum profit */
203             setMaxProfit();
204 
205             /*
206             * send 1 wei - external call to an untrusted contract
207             */
208             if(!pendingBets[i].bettorAddress.send(1)){
209                 /* if send failed let player withdraw via playerWithdrawPendingTransactions */
210                 playerPendingWithdrawals[pendingBets[i].bettorAddress] = safeAdd(playerPendingWithdrawals[pendingBets[i].bettorAddress], 1);
211             }
212 
213             numElements -= 1;
214             return;
215         }
216     }
217 
218     /*
219      * public function
220      * player submit bet
221      * only if game is active & bet is valid can query and set player vars
222     */
223     function playerRollDice() public
224         payable
225         gameIsActive
226         betIsValid(msg.value, underNumber)
227     {
228         totalBets++;
229 
230         Bet memory b = Bet(msg.sender,msg.value,totalBets);
231         if(numElements == pendingBets.length) {
232             pendingBets.length += 1;
233         }
234 
235         pendingBets[numElements++] = b;
236 
237         /*
238         Notice that someone has betting that the banker receives LogBetStart and must start StartRollDice immediately to ensure that the banker (if the banker is a miner) can not manipulate the current block information in order to achieve manipulation of the random number results. You can view the time difference between the betting transaction and the banker StartRollDice by etherscan.io (the difference in the number of blocks)
239         */
240         LogBetStart(totalBets); 
241     }
242 
243 
244     /*
245     * public function
246     * in case of a failed refund or win send
247     */
248     function playerWithdrawPendingTransactions() public
249         payoutsAreActive
250         returns (bool)
251      {
252         uint withdrawAmount = playerPendingWithdrawals[msg.sender];
253         playerPendingWithdrawals[msg.sender] = 0;
254         /* external call to untrusted contract */
255         if (msg.sender.call.value(withdrawAmount)()) {
256             return true;
257         } else {
258             /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */
259             /* player can try to withdraw again later */
260             playerPendingWithdrawals[msg.sender] = withdrawAmount;
261             return false;
262         }
263     }
264 
265     /* check for pending withdrawals  */
266     function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {
267         return playerPendingWithdrawals[addressToCheck];
268     }
269 
270     /*
271     * internal function
272     * sets max profit
273     */
274     function setMaxProfit() internal {
275         maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxBetDivisor;
276     }
277 
278     /*
279     * owner address only functions
280     */
281     function ()
282         payable
283     {
284         playerRollDice();
285     }
286 
287     function ownerAddBankroll()
288     payable
289     onlyOwner
290     {
291         /* safely update contract balance */
292         contractBalance = safeAdd(contractBalance, msg.value);
293         /* update the maximum profit */
294         setMaxProfit();
295     }
296 
297     function getcontractBalance() public 
298     onlyOwner 
299     returns(uint)
300     {
301         return contractBalance;
302     }
303 
304 
305     /* only owner address can set houseEdge */
306     function ownerSetHouseEdge(uint newHouseEdge) public
307         onlyOwner
308     {
309         houseEdge = newHouseEdge;
310     }
311 
312     function getHouseEdge() public 
313     onlyOwner 
314     returns(uint)
315     {
316         return houseEdge;
317     }
318 
319     /* only owner address can set maxProfitAsPercentOfHouse */
320     function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public
321         onlyOwner
322     {
323         /* restrict to maximum profit of 5% of total house balance*/
324         require(newMaxProfitAsPercent <= 50000);
325         maxProfitAsPercentOfHouse = newMaxProfitAsPercent;
326         setMaxProfit();
327     }
328 
329     function getMaxProfitAsPercentOfHouse() public 
330     onlyOwner 
331     returns(uint)
332     {
333         return maxProfitAsPercentOfHouse;
334     }
335 
336     /* only owner address can set minBet */
337     function ownerSetMinBet(uint newMinimumBet) public
338         onlyOwner
339     {
340         minBet = newMinimumBet;
341     }
342 
343     function getMinBet() public 
344     onlyOwner 
345     returns(uint)
346     {
347         return minBet;
348     }
349 
350     /* only owner address can transfer ether */
351     function ownerTransferEther(address sendTo, uint amount) public
352         onlyOwner
353     {
354         /* safely update contract balance when sending out funds*/
355         contractBalance = safeSub(contractBalance, amount);
356         /* update max profit */
357         setMaxProfit();
358         require(sendTo.send(amount));
359         LogOwnerTransfer(sendTo, amount);
360     }
361 
362     /* only owner address can set emergency pause #1 */
363     function ownerPauseGame(bool newStatus) public
364         onlyOwner
365     {
366         gamePaused = newStatus;
367     }
368 
369     /* only owner address can set emergency pause #2 */
370     function ownerPausePayouts(bool newPayoutStatus) public
371         onlyOwner
372     {
373         payoutsPaused = newPayoutStatus;
374     }
375 
376 
377     /* only owner address can set owner address */
378     function ownerChangeOwner(address newOwner) public
379         onlyOwner
380     {
381         owner = newOwner;
382     }
383 
384     /* only owner address can suicide - emergency */
385     function ownerkill() public
386         onlyOwner
387     {
388         suicide(owner);
389     }
390 
391 }