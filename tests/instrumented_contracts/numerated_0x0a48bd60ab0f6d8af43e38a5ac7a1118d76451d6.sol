1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/actions/DEXSwapperV2.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\n\nimport './DEXSwapper.sol';\n\ncontract DEXSwapperV2 is DEXSwapper {\n    using FixedPoint for uint256;\n\n    struct SwapLimit {\n        address token;\n        uint256 amount;\n        uint256 accrued;\n        uint256 period;\n        uint256 nextResetTime;\n    }\n\n    SwapLimit public swapLimit;\n\n    event SwapLimitSet(address indexed token, uint256 amount, uint256 period);\n\n    struct DEXSwapperV2Params {\n        address smartVault;\n        address tokenIn;\n        address tokenOut;\n        uint256 maxSlippage;\n        address swapLimitToken;\n        uint256 swapLimitAmount;\n        uint256 swapLimitPeriod;\n        address thresholdToken;\n        uint256 thresholdAmount;\n        address relayer;\n        uint256 gasPriceLimit;\n        uint256 totalCostLimit;\n        address payingGasToken;\n        address admin;\n        address registry;\n    }\n\n    constructor(DEXSwapperV2Params memory params) DEXSwapper(params.admin, params.registry) {\n        require(params.smartVault != address(0), 'SWAPPER_SMART_VAULT_ZERO');\n        smartVault = ISmartVault(params.smartVault);\n        emit SmartVaultSet(params.smartVault);\n\n        require(params.tokenIn != address(0), 'SWAPPER_TOKEN_IN_ZERO');\n        tokenIn = params.tokenIn;\n        emit TokenInSet(params.tokenIn);\n\n        require(params.tokenOut != address(0), 'SWAPPER_TOKEN_OUT_ZERO');\n        require(params.tokenIn != params.tokenOut, 'SWAPPER_TOKEN_OUT_EQ_IN');\n        tokenOut = params.tokenOut;\n        emit TokenOutSet(params.tokenOut);\n\n        _setSwapLimit(params.swapLimitToken, params.swapLimitAmount, params.swapLimitPeriod);\n\n        if (params.maxSlippage > 0) {\n            require(params.maxSlippage <= FixedPoint.ONE, 'SWAPPER_SLIPPAGE_ABOVE_ONE');\n            maxSlippage = params.maxSlippage;\n            emit MaxSlippageSet(params.maxSlippage);\n        }\n\n        if (params.thresholdToken != address(0) && params.thresholdAmount > 0) {\n            thresholdToken = params.thresholdToken;\n            thresholdAmount = params.thresholdAmount;\n            emit ThresholdSet(params.thresholdToken, params.thresholdAmount);\n        }\n\n        if (params.relayer != address(0)) {\n            isRelayer[params.relayer] = true;\n            _authorize(params.relayer, DEXSwapper.call.selector);\n            emit RelayerSet(params.relayer, true);\n        }\n\n        if (params.payingGasToken != address(0) && (params.gasPriceLimit > 0 || params.totalCostLimit > 0)) {\n            gasPriceLimit = params.gasPriceLimit;\n            totalCostLimit = params.totalCostLimit;\n            payingGasToken = params.payingGasToken;\n            emit LimitsSet(params.gasPriceLimit, params.totalCostLimit, params.payingGasToken);\n        }\n    }\n\n    function setSwapLimit(address token, uint256 amount, uint256 period) external auth {\n        _setSwapLimit(token, amount, period);\n    }\n\n    function canExecute(uint256 amountIn, uint256 slippage) public view override returns (bool) {\n        if (!super.canExecute(amountIn, slippage)) return false;\n        (bool exceedsLimit, ) = _computeSwappedAmount(amountIn);\n        return !exceedsLimit;\n    }\n\n    function _computeSwappedAmount(uint256 amountIn) internal view returns (bool exceedsLimit, uint256 swappedAmount) {\n        if (swapLimit.amount == 0 || swapLimit.token == address(0)) return (false, 0);\n\n        if (tokenIn == swapLimit.token) {\n            swappedAmount = amountIn;\n        } else {\n            uint256 price = smartVault.getPrice(tokenIn, swapLimit.token);\n            swappedAmount = amountIn.mulDown(price);\n        }\n\n        uint256 totalSwapped = swappedAmount + (block.timestamp < swapLimit.nextResetTime ? swapLimit.accrued : 0);\n        exceedsLimit = totalSwapped > swapLimit.amount;\n    }\n\n    function _validateSwap(uint256 amountIn, uint256 slippage) internal override {\n        super._validateSwap(amountIn, slippage);\n\n        (bool exceedsLimit, uint256 swappedAmount) = _computeSwappedAmount(amountIn);\n        require(!exceedsLimit, 'SWAPPER_SWAP_LIMIT_EXCEEDED');\n\n        if (block.timestamp >= swapLimit.nextResetTime) {\n            swapLimit.accrued = 0;\n            swapLimit.nextResetTime = block.timestamp + swapLimit.period;\n        }\n\n        swapLimit.accrued += swappedAmount;\n    }\n\n    function _setSwapLimit(address token, uint256 amount, uint256 period) internal {\n        // If there is no limit, all values must be zero\n        bool isZeroLimit = token == address(0) && amount == 0 && period == 0;\n        bool isNonZeroLimit = token != address(0) && amount > 0 && period > 0;\n        require(isZeroLimit || isNonZeroLimit, 'SWAPPER_INVALID_SWAP_LIMIT_INPUT');\n\n        // Changing the period only affects the end time of the next period, but not the end date of the current one\n        swapLimit.period = period;\n\n        // Changing the amount does not affect the totalizator, it only applies when changing the accrued amount.\n        // Note that it can happen that the new amount is lower than the accrued amount if the amount is lowered.\n        // However, there shouldn't be any accounting issues with that.\n        swapLimit.amount = amount;\n\n        // Therefore, only clean the totalizators if the limit is being removed\n        if (isZeroLimit) {\n            swapLimit.accrued = 0;\n            swapLimit.nextResetTime = 0;\n        } else {\n            // If limit is not zero, set the next reset time if it wasn't set already\n            // Otherwise, if the token is being changed the accrued amount must be updated accordingly\n            if (swapLimit.nextResetTime == 0) {\n                swapLimit.accrued = 0;\n                swapLimit.nextResetTime = block.timestamp + period;\n            } else if (swapLimit.token != token) {\n                uint256 price = smartVault.getPrice(swapLimit.token, token);\n                swapLimit.accrued = swapLimit.accrued.mulDown(price);\n            }\n        }\n\n        // Finally simply set the new requested token\n        swapLimit.token = token;\n        emit SwapLimitSet(token, amount, period);\n    }\n}\n"
6     },
7     "contracts/actions/DEXSwapper.sol": {
8       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport './BaseSwapper.sol';\n\ncontract DEXSwapper is BaseSwapper {\n    // Base gas amount charged to cover gas payment\n    uint256 public constant override BASE_GAS = 35e3;\n\n    constructor(address admin, address registry) BaseAction(admin, registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function canExecute(uint256 amountIn, uint256 slippage) public view virtual returns (bool) {\n        return\n            tokenIn != address(0) &&\n            tokenOut != address(0) &&\n            slippage <= maxSlippage &&\n            _passesThreshold(tokenIn, amountIn);\n    }\n\n    function call(uint8 source, uint256 amountIn, uint256 slippage, bytes memory data) external auth {\n        (isRelayer[msg.sender] ? _relayedCall : _call)(source, amountIn, slippage, data);\n    }\n\n    function _relayedCall(uint8 source, uint256 amountIn, uint256 slippage, bytes memory data) internal redeemGas {\n        _call(source, amountIn, slippage, data);\n    }\n\n    function _call(uint8 source, uint256 amountIn, uint256 slippage, bytes memory data) internal {\n        _validateSwap(amountIn, slippage);\n        smartVault.swap(source, tokenIn, tokenOut, amountIn, ISmartVault.SwapLimit.Slippage, slippage, data);\n        emit Executed();\n    }\n\n    function _validateSwap(uint256 amountIn, uint256 slippage) internal virtual {\n        require(tokenIn != address(0), 'SWAPPER_TOKEN_IN_NOT_SET');\n        require(tokenOut != address(0), 'SWAPPER_TOKEN_OUT_NOT_SET');\n        require(slippage <= maxSlippage, 'SWAPPER_SLIPPAGE_ABOVE_MAX');\n        _validateThreshold(tokenIn, amountIn);\n    }\n}\n"
9     },
10     "@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title FixedPoint\n * @dev Math library to operate with fixed point values with 18 decimals\n */\nlibrary FixedPoint {\n    // 1 in fixed point value: 18 decimal places\n    uint256 internal constant ONE = 1e18;\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding down\n     */\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product / ONE;\n        }\n    }\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding up\n     */\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product == 0 ? 0 : (((product - 1) / ONE) + 1);\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding down\n     */\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return aInflated / b;\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding up\n     */\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n}\n"
12     },
13     "contracts/actions/BaseSwapper.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\n\nabstract contract BaseSwapper is BaseAction, TokenThresholdAction, RelayedAction {\n    address public tokenIn;\n    address public tokenOut;\n    uint256 public maxSlippage;\n\n    event TokenInSet(address indexed tokenIn);\n    event TokenOutSet(address indexed tokenOut);\n    event MaxSlippageSet(uint256 maxSlippage);\n\n    function setTokenIn(address token) external auth {\n        require(token == address(0) || token != tokenOut, 'SWAPPER_TOKEN_IN_EQ_OUT');\n        tokenIn = token;\n        emit TokenInSet(token);\n    }\n\n    function setTokenOut(address token) external auth {\n        require(token == address(0) || token != tokenIn, 'SWAPPER_TOKEN_OUT_EQ_IN');\n        tokenOut = token;\n        emit TokenOutSet(token);\n    }\n\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\n        require(newMaxSlippage <= FixedPoint.ONE, 'SWAPPER_SLIPPAGE_ABOVE_ONE');\n        maxSlippage = newMaxSlippage;\n        emit MaxSlippageSet(newMaxSlippage);\n    }\n}\n"
15     },
16     "@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol": {
17       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISwapConnector\n * @dev Swap Connector interface to perform token swaps. It must follow the IImplementation interface.\n */\ninterface ISwapConnector is IImplementation {\n    /**\n     * @dev Enum identifying the sources proposed: Uniswap V2, Uniswap V3, Balancer V2, Paraswap V5, and 1inch V5.\n     */\n    enum Source {\n        UniswapV2,\n        UniswapV3,\n        BalancerV2,\n        ParaswapV5,\n        OneInchV5\n    }\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to execute the requested swap\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param minAmountOut Minimum amount of tokenOut willing to receive\n     * @param data Encoded data to specify different swap parameters depending on the source picked\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n}\n"
18     },
19     "@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol": {
20       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol';\n\nimport './IAction.sol';\n\n/**\n * @title BaseAction\n * @dev Simple action implementation with a Smart Vault reference and using the Authorizer mixin\n */\ncontract BaseAction is IAction, BaseAuthorizedImplementation {\n    bytes32 public constant override NAMESPACE = keccak256('ACTION');\n\n    // Smart Vault reference\n    ISmartVault public override smartVault;\n\n    /**\n     * @dev Emitted every time a new smart vault is set\n     */\n    event SmartVaultSet(address indexed smartVault);\n\n    /**\n     * @dev Creates a new BaseAction\n     * @param admin Address to be granted authorize and unauthorize permissions\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address admin, address registry) BaseAuthorizedImplementation(admin, registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Sets the Smart Vault tied to the Action. Sender must be authorized. It can be set only once.\n     * @param newSmartVault Address of the smart vault to be set\n     */\n    function setSmartVault(address newSmartVault) external auth {\n        require(address(smartVault) == address(0), 'SMART_VAULT_ALREADY_SET');\n        _validateStatefulDependency(newSmartVault);\n        smartVault = ISmartVault(newSmartVault);\n        emit SmartVaultSet(newSmartVault);\n    }\n\n    function _balanceOf(address token) internal view returns (uint256) {\n        bool isNative = Denominations.isNativeToken(token);\n        return isNative ? address(smartVault).balance : IERC20(token).balanceOf(address(smartVault));\n    }\n\n    function _isWrappedOrNativeToken(address token) internal view returns (bool) {\n        return Denominations.isNativeToken(token) || token == smartVault.wrappedNativeToken();\n    }\n}\n"
21     },
22     "@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title TokenThresholdAction\n * @dev Action that offers a token threshold limit. It can be used for minimum swap amounts, or minimum withdrawal\n * amounts, etc. This type of action does not require any specific permission on the Smart Vault.\n */\nabstract contract TokenThresholdAction is BaseAction {\n    using FixedPoint for uint256;\n\n    address public thresholdToken;\n    uint256 public thresholdAmount;\n\n    event ThresholdSet(address indexed token, uint256 amount);\n\n    /**\n     * @dev Sets a new threshold configuration. Sender must be authorized.\n     * @param token New token threshold to be set\n     * @param amount New amount threshold to be set\n     */\n    function setThreshold(address token, uint256 amount) external auth {\n        thresholdToken = token;\n        thresholdAmount = amount;\n        emit ThresholdSet(token, amount);\n    }\n\n    /**\n     * @dev Internal function to check the set threshold\n     * @param token Token address of the given amount to evaluate the threshold\n     * @param amount Amount of tokens to validate the threshold\n     */\n    function _passesThreshold(address token, uint256 amount) internal view returns (bool) {\n        uint256 price = smartVault.getPrice(token, thresholdToken);\n        // Result balance is rounded down to make sure we always match at least the threshold\n        return amount.mulDown(price) >= thresholdAmount;\n    }\n\n    /**\n     * @dev Internal function to validate the set threshold\n     * @param token Token address of the given amount to evaluate the threshold\n     * @param amount Amount of tokens to validate the threshold\n     */\n    function _validateThreshold(address token, uint256 amount) internal view {\n        require(_passesThreshold(token, amount), 'MIN_THRESHOLD_NOT_MET');\n    }\n}\n"
24     },
25     "@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title RelayedAction\n * @dev Action that offers a relayed mechanism to allow reimbursing tx costs after execution in any ERC20 token.\n * This type of action at least require having withdraw permissions from the Smart Vault tied to it.\n */\nabstract contract RelayedAction is BaseAction {\n    using FixedPoint for uint256;\n\n    // Base gas amount charged to cover default amounts\n    // solhint-disable-next-line func-name-mixedcase\n    function BASE_GAS() external view virtual returns (uint256);\n\n    // Note to be used to mark tx cost payments\n    bytes private constant REDEEM_GAS_NOTE = bytes('RELAYER');\n\n    // Internal variable used to allow a better developer experience to reimburse tx gas cost\n    uint256 internal _initialGas;\n\n    // Allows relaying transactions even if there is not enough balance in the Smart Vault to pay for the tx gas cost\n    bool public isPermissiveModeActive;\n\n    // Gas price limit, if surpassed it wont relay the transaction\n    uint256 public gasPriceLimit;\n\n    // Total cost limit expressed in `payingGasToken`, if surpassed it wont relay the transaction\n    uint256 public totalCostLimit;\n\n    // Address of the ERC20 token that will be used to pay the total tx cost\n    address public payingGasToken;\n\n    // List of allowed relayers indexed by address\n    mapping (address => bool) public isRelayer;\n\n    /**\n     * @dev Emitted every time the permissive mode is changed\n     */\n    event PermissiveModeSet(bool active);\n\n    /**\n     * @dev Emitted every time the relayers list is changed\n     */\n    event RelayerSet(address indexed relayer, bool allowed);\n\n    /**\n     * @dev Emitted every time the relayer limits are set\n     */\n    event LimitsSet(uint256 gasPriceLimit, uint256 totalCostLimit, address payingGasToken);\n\n    /**\n     * @dev Modifier that can be used to reimburse the gas cost of the tagged function\n     */\n    modifier redeemGas() {\n        _beforeCall();\n        _;\n        _afterCall();\n    }\n\n    /**\n     * @dev Sets the relayed action permissive mode. If active,  relayer address. Sender must be authorized.\n     * @param active Whether the permissive mode should be active or not\n     */\n    function setPermissiveMode(bool active) external auth {\n        isPermissiveModeActive = active;\n        emit PermissiveModeSet(active);\n    }\n\n    /**\n     * @dev Sets a relayer address. Sender must be authorized.\n     * @param relayer Address of the relayer to be set\n     * @param allowed Whether it should be allowed or not\n     */\n    function setRelayer(address relayer, bool allowed) external auth {\n        isRelayer[relayer] = allowed;\n        emit RelayerSet(relayer, allowed);\n    }\n\n    /**\n     * @dev Sets the relayer limits. Sender must be authorized.\n     * @param _gasPriceLimit New gas price limit to be set\n     * @param _totalCostLimit New total cost limit to be set\n     * @param _payingGasToken New paying gas token to be set\n     */\n    function setLimits(uint256 _gasPriceLimit, uint256 _totalCostLimit, address _payingGasToken) external auth {\n        require(_payingGasToken != address(0), 'PAYING_GAS_TOKEN_ZERO');\n        gasPriceLimit = _gasPriceLimit;\n        totalCostLimit = _totalCostLimit;\n        payingGasToken = _payingGasToken;\n        emit LimitsSet(_gasPriceLimit, _totalCostLimit, _payingGasToken);\n    }\n\n    /**\n     * @dev Internal before call hook where limit validations are checked\n     */\n    function _beforeCall() internal {\n        _initialGas = gasleft();\n        require(isRelayer[msg.sender], 'SENDER_NOT_RELAYER');\n        uint256 limit = gasPriceLimit;\n        require(limit == 0 || tx.gasprice <= limit, 'GAS_PRICE_ABOVE_LIMIT');\n    }\n\n    /**\n     * @dev Internal after call hook where tx cost is reimburse\n     */\n    function _afterCall() internal {\n        uint256 totalGas = _initialGas - gasleft();\n        uint256 totalCostNative = (totalGas + RelayedAction(this).BASE_GAS()) * tx.gasprice;\n\n        uint256 limit = totalCostLimit;\n        address payingToken = payingGasToken;\n        // Total cost is rounded down to make sure we always match at least the threshold\n        uint256 totalCostToken = totalCostNative.mulDown(_getPayingGasTokenPrice(payingToken));\n        require(limit == 0 || totalCostToken <= limit, 'TX_COST_ABOVE_LIMIT');\n\n        if (_shouldTryRedeemFromSmartVault(payingToken, totalCostToken)) {\n            smartVault.withdraw(payingToken, totalCostToken, smartVault.feeCollector(), REDEEM_GAS_NOTE);\n        }\n\n        delete _initialGas;\n    }\n\n    /**\n     * @dev Internal function to fetch the paying gas token rate from the Smart Vault's price oracle\n     */\n    function _getPayingGasTokenPrice(address token) private view returns (uint256) {\n        bool isUsingNativeToken = _isWrappedOrNativeToken(token);\n        return isUsingNativeToken ? FixedPoint.ONE : smartVault.getPrice(smartVault.wrappedNativeToken(), token);\n    }\n\n    /**\n     * @dev Internal function to tell if the relayed action should try to redeem the gas cost from the Smart Vault\n     * @param token Address of the token to pay the relayed gas cost\n     * @param amount Amount of tokens to pay for the relayed gas cost\n     */\n    function _shouldTryRedeemFromSmartVault(address token, uint256 amount) private view returns (bool) {\n        if (!isPermissiveModeActive) return true;\n        return _balanceOf(token) >= amount;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
30     },
31     "@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n// solhint-disable func-name-mixedcase\n\n/**\n * @title IImplementation\n * @dev Implementation interface that must be followed for implementations to be registered in the Mimic Registry\n */\ninterface IImplementation {\n    /**\n     * @dev Tells the namespace under which the implementation is registered in the Mimic Registry\n     */\n    function NAMESPACE() external view returns (bytes32);\n\n    /**\n     * @dev Tells the address of the Mimic Registry\n     */\n    function registry() external view returns (address);\n}\n"
33     },
34     "@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol": {
35       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISmartVault\n * @dev Mimic Smart Vault interface to manage assets. It must support also `IImplementation` and `IAuthorizer`\n */\ninterface ISmartVault is IPriceFeedProvider, IImplementation, IAuthorizer {\n    enum SwapLimit {\n        Slippage,\n        MinAmountOut\n    }\n\n    /**\n     * @dev Emitted every time a new strategy is set for the Smart Vault\n     */\n    event StrategySet(address indexed strategy, bool allowed);\n\n    /**\n     * @dev Emitted every time a new price oracle is set for the Smart Vault\n     */\n    event PriceOracleSet(address indexed priceOracle);\n\n    /**\n     * @dev Emitted every time a new swap connector is set for the Smart Vault\n     */\n    event SwapConnectorSet(address indexed swapConnector);\n\n    /**\n     * @dev Emitted every time a new fee collector is set\n     */\n    event FeeCollectorSet(address indexed feeCollector);\n\n    /**\n     * @dev Emitted every time the withdraw fee percentage is set\n     */\n    event WithdrawFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the performance fee percentage is set\n     */\n    event PerformanceFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the swap fee percentage is set\n     */\n    event SwapFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time `call` is called\n     */\n    event Call(address indexed target, bytes callData, uint256 value, bytes result, bytes data);\n\n    /**\n     * @dev Emitted every time `collect` is called\n     */\n    event Collect(address indexed token, address indexed from, uint256 collected, bytes data);\n\n    /**\n     * @dev Emitted every time `withdraw` is called\n     */\n    event Withdraw(address indexed token, address indexed recipient, uint256 withdrawn, uint256 fee, bytes data);\n\n    /**\n     * @dev Emitted every time `wrap` is called\n     */\n    event Wrap(uint256 amount, uint256 wrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `unwrap` is called\n     */\n    event Unwrap(uint256 amount, uint256 unwrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `claim` is called\n     */\n    event Claim(address indexed strategy, address[] tokens, uint256[] amounts, bytes data);\n\n    /**\n     * @dev Emitted every time `join` is called\n     */\n    event Join(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `exit` is called\n     */\n    event Exit(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256[] fees,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `swap` is called\n     */\n    event Swap(\n        uint8 indexed source,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 minAmountOut,\n        uint256 fee,\n        bytes data\n    );\n\n    /**\n     * @dev Tells a strategy is allowed or not\n     * @param strategy Address of the strategy being queried\n     */\n    function isStrategyAllowed(address strategy) external view returns (bool);\n\n    /**\n     * @dev Tells the invested value for a strategy\n     * @param strategy Address of the strategy querying the invested value of\n     */\n    function investedValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\n     * @param strategy Address of the strategy querying the last value of\n     */\n    function lastValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the price oracle associated to a Smart Vault\n     */\n    function priceOracle() external view returns (address);\n\n    /**\n     * @dev Tells the swap connector associated to a Smart Vault\n     */\n    function swapConnector() external view returns (address);\n\n    /**\n     * @dev Tells the address where fees will be deposited\n     */\n    function feeCollector() external view returns (address);\n\n    /**\n     * @dev Tells the withdraw fee configuration\n     */\n    function withdrawFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the performance fee configuration\n     */\n    function performanceFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the swap fee configuration\n     */\n    function swapFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the address of the wrapped native token\n     */\n    function wrappedNativeToken() external view returns (address);\n\n    /**\n     * @dev Sets a new strategy as allowed or not for a Smart Vault\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function setStrategy(address strategy, bool allowed) external;\n\n    /**\n     * @dev Sets a new price oracle to a Smart Vault\n     * @param newPriceOracle Address of the new price oracle to be set\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @dev Sets a new swap connector to a Smart Vault\n     * @param newSwapConnector Address of the new swap connector to be set\n     */\n    function setSwapConnector(address newSwapConnector) external;\n\n    /**\n     * @dev Sets a new fee collector\n     * @param newFeeCollector Address of the new fee collector to be set\n     */\n    function setFeeCollector(address newFeeCollector) external;\n\n    /**\n     * @dev Sets a new withdraw fee configuration\n     * @param pct Withdraw fee percentage to be set\n     * @param cap New maximum amount of withdraw fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the withdraw fee\n     */\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new performance fee configuration\n     * @param pct Performance fee percentage to be set\n     * @param cap New maximum amount of performance fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the performance fee\n     */\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new swap fee configuration\n     * @param pct Swap fee percentage to be set\n     * @param cap New maximum amount of swap fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the swap fee\n     */\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Tells the price of a token (base) in a given quote\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address base, address quote) external view returns (uint256);\n\n    /**\n     * @dev Execute an arbitrary call from a Smart Vault\n     * @param target Address where the call will be sent\n     * @param callData Calldata to be used for the call\n     * @param value Value in wei that will be attached to the call\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return result Call response if it was successful, otherwise it reverts\n     */\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\n        external\n        returns (bytes memory result);\n\n    /**\n     * @dev Collect tokens from a sender to a Smart Vault\n     * @param token Address of the token to be collected\n     * @param from Address where the tokens will be transfer from\n     * @param amount Amount of tokens to be transferred\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return collected Amount of tokens assigned to the Smart Vault\n     */\n    function collect(address token, address from, uint256 amount, bytes memory data)\n        external\n        returns (uint256 collected);\n\n    /**\n     * @dev Withdraw tokens to an external account\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to withdraw\n     * @param recipient Address where the tokens will be transferred to\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return withdrawn Amount of tokens transferred to the recipient address\n     */\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\n        external\n        returns (uint256 withdrawn);\n\n    /**\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it\n     * @param amount Amount of native tokens to be wrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return wrapped Amount of tokens wrapped\n     */\n    function wrap(uint256 amount, bytes memory data) external returns (uint256 wrapped);\n\n    /**\n     * @dev Unwrap an amount of wrapped native tokens\n     * @param amount Amount of wrapped native tokens to unwrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return unwrapped Amount of tokens unwrapped\n     */\n    function unwrap(uint256 amount, bytes memory data) external returns (uint256 unwrapped);\n\n    /**\n     * @dev Claim strategy rewards\n     * @param strategy Address of the strategy to claim rewards\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(address strategy, bytes memory data)\n        external\n        returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n     * @dev Join a strategy with an amount of tokens\n     * @param strategy Address of the strategy to join\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage that will be used to compute the join\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Exit a strategy\n     * @param strategy Address of the strategy to exit\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage that will be used to compute the exit\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to request the swap. It depends on the Swap Connector attached to a Smart Vault.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return amountOut Received amount of tokens out\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        SwapLimit limitType,\n        uint256 limitAmount,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n}\n"
36     },
37     "@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol": {
38       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport './IAuthorizer.sol';\n\n/**\n * @title Authorizer\n * @dev Authorization module to be used by contracts that need to implement permissions for their methods.\n * It provides a permissions model to list who is allowed to call what function in a contract. And only accounts\n * authorized to manage those permissions are the ones that are allowed to authorize or unauthorize accounts.\n */\ncontract Authorizer is IAuthorizer {\n    // Constant used to denote that a permission is open to anyone\n    address public constant ANY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    // Internal mapping to tell who is allowed to do what indexed by (account, function selector)\n    mapping (address => mapping (bytes4 => bool)) private authorized;\n\n    /**\n     * @dev Modifier that should be used to tag protected functions\n     */\n    modifier auth() {\n        _authenticate(msg.sender, msg.sig);\n        _;\n    }\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) public view override returns (bool) {\n        return authorized[ANY_ADDRESS][what] || authorized[who][what];\n    }\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external override auth {\n        _authorize(who, what);\n    }\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external override auth {\n        _unauthorize(who, what);\n    }\n\n    /**\n     * @dev Internal function to authenticate someone over a function.\n     * It reverts if the given account is not authorized to call the requested function.\n     * @param who Address to be authenticated\n     * @param what Function selector to be authenticated\n     */\n    function _authenticate(address who, bytes4 what) internal view {\n        require(isAuthorized(who, what), 'AUTH_SENDER_NOT_ALLOWED');\n    }\n\n    /**\n     * @dev Internal function to authorize someone to call a function\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function _authorize(address who, bytes4 what) internal {\n        authorized[who][what] = true;\n        emit Authorized(who, what);\n    }\n\n    /**\n     * @dev Internal function to unauthorize someone to call a function\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function _unauthorize(address who, bytes4 what) internal {\n        authorized[who][what] = false;\n        emit Unauthorized(who, what);\n    }\n}\n"
39     },
40     "@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol": {
41       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\n\nimport './BaseImplementation.sol';\n\n/**\n * @title BaseAuthorizedImplementation\n * @dev BaseImplementation using the Authorizer mixin. Base implementations that want to use the Authorizer\n * permissions mechanism should inherit from this contract instead.\n */\nabstract contract BaseAuthorizedImplementation is BaseImplementation, Authorizer {\n    /**\n     * @dev Creates a new BaseAuthorizedImplementation\n     * @param admin Address to be granted authorize and unauthorize permissions\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address admin, address registry) BaseImplementation(registry) {\n        _authorize(admin, Authorizer.authorize.selector);\n        _authorize(admin, Authorizer.unauthorize.selector);\n    }\n}\n"
42     },
43     "@mimic-fi/v2-helpers/contracts/utils/Denominations.sol": {
44       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title Denominations\n * @dev Provides a list of ground denominations for those tokens that cannot be represented by an ERC20.\n * For now, the only needed is the native token that could be ETH, MATIC, or other depending on the layer being operated.\n */\nlibrary Denominations {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    function isNativeToken(address token) internal pure returns (bool) {\n        return token == NATIVE_TOKEN;\n    }\n}\n"
45     },
46     "@mimic-fi/v2-smart-vaults-base/contracts/actions/IAction.sol": {
47       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @title IAction\n * @dev Action interface it must follow the IAuthorizer interface\n */\ninterface IAction is IAuthorizer {\n    /**\n     * @dev Emitted every time an action is executed\n     */\n    event Executed();\n\n    /**\n     * @dev Tells the address of the Smart Vault tied to it, it cannot be changed\n     */\n    function smartVault() external view returns (ISmartVault);\n}\n"
48     },
49     "@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol": {
50       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IAuthorizer\n */\ninterface IAuthorizer {\n    /**\n     * @dev Emitted when an account is authorized to call a function\n     */\n    event Authorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Emitted when an account is unauthorized to call a function\n     */\n    event Unauthorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) external view returns (bool);\n}\n"
51     },
52     "@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol": {
53       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IPriceFeedProvider\n * @dev Contract providing price feed references for (base, quote) token pairs\n */\ninterface IPriceFeedProvider {\n    /**\n     * @dev Emitted every time a price feed is set for (base, quote) pair\n     */\n    event PriceFeedSet(address indexed base, address indexed quote, address feed);\n\n    /**\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\n     * @param base Token to be rated\n     * @param quote Token used for the price rate\n     */\n    function getPriceFeed(address base, address quote) external view returns (address);\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed) external;\n\n    /**\n     * @dev Sets a list of price feeds\n     * @param bases List of token bases to be set\n     * @param quotes List of token quotes to be set\n     * @param feeds List of price feeds to be set\n     */\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds) external;\n}\n"
54     },
55     "@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol": {
56       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\n\nimport './IImplementation.sol';\nimport '../registry/IRegistry.sol';\n\n/**\n * @title BaseImplementation\n * @dev This implementation contract comes with an immutable reference to an implementations registry where it should\n * be registered as well (checked during initialization). It allows requesting new instances of other registered\n * implementations to as another safety check to make sure valid instances are referenced in case it's needed.\n */\nabstract contract BaseImplementation is IImplementation {\n    // Immutable implementations registry reference\n    address public immutable override registry;\n\n    /**\n     * @dev Creates a new BaseImplementation\n     * @param _registry Address of the Mimic Registry where dependencies will be validated against\n     */\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that must be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and stateless.\n     * @param dependency New stateless dependency to be set\n     */\n    function _validateStatelessDependency(address dependency) internal view {\n        require(_validateDependency(dependency), 'DEPENDENCY_NOT_STATELESS');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that cannot be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and not stateful.\n     * @param dependency New stateful dependency to be set\n     */\n    function _validateStatefulDependency(address dependency) internal view {\n        require(!_validateDependency(dependency), 'DEPENDENCY_NOT_STATEFUL');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency. It checks the dependency is registered and not deprecated.\n     * @param dependency New dependency to be set\n     * @return Whether the dependency is stateless or not\n     */\n    function _validateDependency(address dependency) private view returns (bool) {\n        // If there is an implementation registered for the dependency, check the dependency as an instance.\n        // Otherwise, treat the dependency as an implementation.\n        address dependencyImplementation = IRegistry(registry).implementationOf(dependency);\n        address implementation = dependencyImplementation != address(0) ? dependencyImplementation : dependency;\n\n        (bool stateless, bool deprecated, bytes32 namespace) = IRegistry(registry).implementationData(implementation);\n        require(namespace != bytes32(0), 'DEPENDENCY_NOT_REGISTERED');\n        require(!deprecated, 'DEPENDENCY_DEPRECATED');\n        return stateless;\n    }\n}\n"
57     },
58     "@mimic-fi/v2-registry/contracts/registry/IRegistry.sol": {
59       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @title IRegistry\n * @dev Registry interface, it must follow the IAuthorizer interface.\n */\ninterface IRegistry is IAuthorizer {\n    /**\n     * @dev Emitted every time a new implementation is registered\n     */\n    event Registered(bytes32 indexed namespace, address indexed implementation, bool stateless);\n\n    /**\n     * @dev Emitted every time an implementation is deprecated\n     */\n    event Deprecated(bytes32 indexed namespace, address indexed implementation);\n\n    /**\n     * @dev Emitted every time an implementation is cloned\n     */\n    event Cloned(bytes32 indexed namespace, address indexed implementation, address instance, bytes initResult);\n\n    /**\n     * @dev Tells the implementation associated to a contract instance\n     * @param instance Address of the instance to request it's implementation\n     */\n    function implementationOf(address instance) external view returns (address);\n\n    /**\n     * @dev Tells the data of an implementation:\n     * @param implementation Address of the implementation to request it's data\n     */\n    function implementationData(address implementation)\n        external\n        view\n        returns (bool stateless, bool deprecated, bytes32 namespace);\n\n    /**\n     * @dev Tells if a specific implementation is registered under a certain namespace and it's not deprecated\n     * @param namespace Namespace asking for\n     * @param implementation Address of the implementation to be checked\n     */\n    function isActive(bytes32 namespace, address implementation) external view returns (bool);\n\n    /**\n     * @dev Registers a new implementation for a given namespace\n     * @param namespace Namespace to be used for the implementation\n     * @param implementation Address of the implementation to be registered\n     * @param stateless Whether the implementation is stateless or not\n     */\n    function register(bytes32 namespace, address implementation, bool stateless) external;\n\n    /**\n     * @dev Deprecates a registered implementation\n     * @param implementation Address of the implementation to be deprecated\n     */\n    function deprecate(address implementation) external;\n\n    /**\n     * @dev Clones a registered implementation\n     * @param implementation Address of the implementation to be cloned\n     * @param initializeData Arbitrary data to be sent after deployment\n     * @return instance Address of the new instance created\n     */\n    function clone(address implementation, bytes memory initializeData) external returns (address);\n}\n"
60     },
61     "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
62       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
63     },
64     "@openzeppelin/contracts/utils/Address.sol": {
65       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
66     }
67   },
68   "settings": {
69     "optimizer": {
70       "enabled": true,
71       "runs": 10000
72     },
73     "outputSelection": {
74       "*": {
75         "*": [
76           "evm.bytecode",
77           "evm.deployedBytecode",
78           "devdoc",
79           "userdoc",
80           "metadata",
81           "abi"
82         ]
83       }
84     },
85     "libraries": {}
86   }
87 }}