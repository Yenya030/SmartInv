1 /* This source code is part of CACIB DocChain registered trademark
2 *  It is provided becaused published in the public blockchain of Ethereum.
3 *  Reusing this code is forbidden without approbation of CACIB first (idea@ca-cib.com)
4 *  Providing this code in public repository is meant to provide clarity to the mechanism by which the DocChain product works
5 */
6 pragma solidity ^0.4.11;
7 
8 /**
9  * The IEthIdentity interface defines fundamental functionnalities
10  * that every Ethereum identity in this framework must implement to be 
11  * usable with DocChain principles.
12  * 
13  * The purpose of implementing IEthIdentity interface is to prove its own identity
14  * and let others checking whether any proof has been made by its identity.
15  */
16 interface IEthIdentity {
17     
18     /**
19      * Add proof if it does not exist yet
20      *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)
21      *  - bytes32: the attribute id or proof id for which the identity owner has made a proof
22      */
23     function addProof(address, bytes32) public returns(bool);
24     
25     /**
26      * Remove proof of a source if existed
27      *  - address: the smart contract address where the identity proof has been stored (see eSignature contract)
28      *  - bytes32: the attribute id or proof id to be removed
29      */
30     function removeProof(address, bytes32) public returns(bool);
31 
32     /**
33      * Check whether the provided address is the controlling wallet (owner) of the identity
34      */
35     function checkOwner(address) public constant returns(bool);
36     
37     /**
38      * Get the identity owner name
39      */
40     function getIdentityName() public constant returns(bytes32);
41     
42 }
43 
44 /**
45  * The implementation of IEthIdentity interface.
46  * 
47  * This is just an implementation of IEthIdentity interface, other implementation
48  * may be different. However, the fundamental functionnalities defined in IEthIdentity
49  * interface must be fully implemented to be compatible with the framework.
50  */
51 contract EthIdentity is IEthIdentity {
52     
53     /**
54      * The EthIdentity contract is a prudent identity proof of its owner
55      * When contract is created, it assigns the sender of creating contract
56      * transaction as its owner. 
57      * The contract owner can only be changed by the override owner.
58      * The override owner can only be changed by the override owner.
59      * Although set as private but they can always be read via the getStorageAt. It saves bytecode in the final structure
60      */
61     address public owner;
62     address private override;
63     
64     /**
65      * The identity name is a string for human readability and visibility
66      * but is stored as 32 bytes in order to be used between contract calls.
67      */
68     bytes32 private identityName;
69     
70     /**
71      * Constructor of EthIdentity contract
72      * Only execute once.
73      * receives the Name of the identity
74      */
75     function EthIdentity(bytes32 _name) public {
76         owner = msg.sender;
77         override = msg.sender;
78         identityName = _name;
79     }
80     
81     /**
82      * Constants for event type & notifications
83      */
84     uint constant ERROR_EVENT = 119;
85     uint constant INFO_EVENT = 115;
86     
87     /**
88      * This event is used for change notification and outputs the following:
89      * - event sender (indexed for filter)
90      * - event status (indexed for filter)
91      * - event message
92      */
93     event EventNotification(address indexed sender, uint indexed status, bytes32 message);
94     
95     /**
96      * The list of proofs stored by this identity owner
97      * The identity owner can store several proofs for a particular source, hence
98      * is defined as a mapping list that use the proof value (attribute) as key
99      * Hence the attribute value must be unique accross all sources.
100      * 
101      * For the eSignature contract, the proof is defined as the document id
102      * generated by this contract when the document hash is added/signed by an identity owner.
103      * For a wider use, it can be any attribute that is stored by this identity owner, but must be a bytes32 for optimisation.
104      */
105     mapping(bytes32 => address) proofList;
106     
107     /**
108      * Add a proof ONLY if not already present and ONLY by the identity owner
109      * 
110      * _source: address of the source (e.g. eSignature contract) where the proof has been stored
111      * _attribute: a bytes32 representing the attribute at the source identifying the proof
112      * 
113      * For eSignature case, _attribute is the document id generated when the identity adds/signs the document
114      */
115     function addProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {
116         // Check input
117         require(_source != address(0x0));
118         
119         // Check proof existence
120         bool existed = checkProof(_attribute);
121         
122         // Returns and do nothing except emitting event if the proof already exists
123         if (existed == true) {
124             EventNotification(msg.sender, ERROR_EVENT, "Proof already exist");
125             return false;
126         }
127         
128         // Add new proof
129         proofList[_attribute] = _source;
130         
131         EventNotification(msg.sender, INFO_EVENT, "New proof added");
132         return true;
133     }
134     
135     /**
136      * Remove proof of a source ONLY if present and ONLY by the identity owner
137      * 
138      * _source: address of the source (e.g. eSignature contract) where the proof has been stored
139      * _attribute: a bytes32 representing the attribute at the source identifying the proof
140      * 
141      * For eSignature case, _attribute is the document id generated when the identity adds/signs the document
142      */
143     function removeProof(address _source, bytes32 _attribute) public onlyBy(owner) returns(bool) {
144         // Check proof existence
145         bool existed = checkProof(_attribute);
146         
147         // Return and do nothing except emitting event if the proof does not exist
148         if (existed == false) {
149             EventNotification(msg.sender, ERROR_EVENT, "Proof not found");
150             return false;
151         }
152         
153         // Return and do nothing except emitting event if the source is not correct
154         if (proofList[_attribute] != _source) {
155             EventNotification(msg.sender, ERROR_EVENT, "Incorrect source");
156             return false;
157         }
158         
159         // Delete existing proof
160         delete proofList[_attribute];
161         
162         EventNotification(msg.sender, INFO_EVENT, "Proof removed");
163         return true;
164     }
165     
166     /**
167      * Check whether the identity owner has stored a proof with a  source
168      * Return true if proof is found
169      * 
170      * _attribute: a string representing the attribute of the source for which the proof has been made
171      * 
172      * For eSignature case, _attribute is the document id generated when the identity create/sign the document
173      */
174     function checkProof(bytes32 _attribute) public constant returns(bool) {
175         var source = proofList[_attribute];
176         // Check if proof source is assigned & matched
177         if (source != address(0x0))
178             return true;
179         // Proof not exists since its source is not matched    
180         return false;
181     }
182     
183     /**
184      * Check whether the provided address is the controlling wallet of the identity
185      * Return true if yes
186      */
187     function checkOwner(address _check) public constant returns(bool) {
188         return _check == owner;
189     }
190     
191     /**
192      * Get the identity owner name, usable inside contract call
193      */
194     function getIdentityName() public constant returns(bytes32) {
195         return identityName;
196     }
197     
198     /**
199      * Show the name of the identity in string 
200      * (for Etherscan read-only function)
201      */
202     function nameOfIdentity() public constant returns(string) {
203         return bytes32ToString(identityName);
204     }
205     
206     /**
207      * Get the identity detail information
208      */
209     function getIdentityInfo() public constant returns(address, address, string) {
210         return (override, owner, bytes32ToString(identityName));
211     }
212     
213      /**
214      * Only the identity owner can set its name
215      */
216     function setIdentityName(bytes32 _newName) public onlyBy(owner) returns(bool) {
217         identityName = _newName;
218         EventNotification(msg.sender, INFO_EVENT, "Set owner name");
219         return true;
220     }
221     
222     /**
223      * Only the override address is allowed to change the owner address.
224      */
225     function setOwner(address _newOwner) public onlyBy(override) returns(bool) {
226         owner = _newOwner;
227         EventNotification(msg.sender, INFO_EVENT, "Set new owner");
228         return true;
229     }
230 
231     /**
232      * Only the override address is allowed to change the override address.
233      */
234     function setOverride(address _newOverride) public onlyBy(override) returns(bool) {
235         override = _newOverride;
236         EventNotification(msg.sender, INFO_EVENT, "Set new override");
237         return true;
238     }
239     
240     /**
241      * Convert bytes32 to string. Set modifier pure which means cannot
242      * access the contract storage.
243      */
244     function bytes32ToString(bytes32 data) internal pure returns (string) {
245         bytes memory bytesString = new bytes(32);
246         for (uint j=0; j<32; j++){
247             if (data[j] != 0) {
248                 bytesString[j] = data[j];
249             }
250         }
251         return string(bytesString);
252     }
253     
254     /**
255      * Modifier to make a constraint on who is permitted
256      * to execute a function
257      */
258     modifier onlyBy(address _authorized) {
259         assert(msg.sender == _authorized);
260         _;
261     }
262 }