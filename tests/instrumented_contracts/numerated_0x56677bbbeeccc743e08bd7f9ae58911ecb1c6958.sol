1 /**
2 
3 Greetings, fellow denizens of Gensokyo, and welcome to the mystical realm of NASDAQ.jp, where ancient spellcraft melds with the magic of crypto autism entusiasts
4 
5 https://twitter.com/Nasdaq420
6 
7 https://t.me/NasdaqToken
8 
9 https://nasdaq.jp/
10 
11 
12                                                                                                            .:::.....                                  
13                                         ~PGGGGGPPP555YYJ~                                                 !BBBBBBGBGGGGPP5?                           
14                                         G@Y77???JJJJJ5G@#.                                               .B@?~!!!!7777?YG@#.                          
15               ^7???????????????????????Y@#~~~~~~^^^^Y#&@G?????????????????????7~                         !&B~~~~~~~~~^5&BJ:                           
16              ^#&PPPPPPPPPPPPPPPPPPPPPPPP5J~~~~~~~~~~Y5555PPPPPPPPPPPPPPPPPPPPP#@!                        5@Y^~~~~~~~~!#&^                             
17              Y@5^^^^^^^^^^^^^^^^^^^^^^^^^~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^~#&~ ......................^#&7~~~~~~~~^J@G........................      
18             .B&7~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^J&&BBBBBGBBGBBBBGBBGBBBBGBGB&P~~~~~~~~~~G&#GBBBBGBGGBBBBGBGGBBBBBBGGY.   
19             !@B~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~G&&J!!7!!!!!!!7!!!!!!!7!!!!!!!~~~~~~~~~~!!!!!!7!!!!!!!7!!!!!!!7!!!?&&:   
20             P@5!7!!!!!!!!!!!!!!!!!!!!!!!~~~~~~~~~~!!!!!!!!!!!!!!!!!!!!!!!77!?&&B~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^Y@5    
21             7GBBB#&&&&&&&&&&&&&&&&&&&&&5^~~~~~~~~~G&&&&&&&&&&&&&&&&&&&&&#BBBB&&Y^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~B@!    
22               ...G@5???????????????????!~~~~~~~~~~???????????????????7P@P.. ~&#!^^^^^^^^^^^^^^^^^^~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^?&B.    
23                 ^&#!^~~^^^~~~~~^^^~~~~~~~~~~~~~~~~~~~~~^^^~~~~~^^^~~^^G@7   7@#5YY555555YY55555YYJ~~~~~~~~~~!Y5555555555555555555555555555555YB@J     
24                 J@P^~~~~~~~~~~^^^^~~~~~~~~~~~~~~~~~~~^^^^~^~~~~~~~~~~7&#.   .7JYYYYYYYYYYYYYYY5&@Y^~~~~~~~~^5@GJJJJJJJJJJJJJJJJJJJJJJJJJJJYJJJJ!      
25                .B&?^~~~^^^^^~7JJJJ?!!!^~~~~~~~^^~!!~!JJJ???~~~^^^^^^^J#Y                      ~&B^^^^^^^~~^7&#:                                       
26                !&B~~~~~^GGGBGJ5PPP75BBP:~~~~~^7BBBBBJYGP#&G~^!JPB####BG^  :PGBB###BGPY7:      G@75BGGGG^^~~G@&GY!?5G##&#BPJ!!?JYPGGP5Y?:              
27                5@Y^~~~^^@@@@@&7    B@@&:~~~~~^#@@&@@&^  P@J:Y@@@#PPPG#P   ^@@@@P55PB@@@@G~   ?@5?@@@@@@5:^J&57?5&@@@G55G&@@@P!~~~7?JJG@5              
28               :#&7^~~~^^&@@B&@@Y   B@@#:~~~~:5@@#~&@@G :&#~~@@@&^..:7J^   ^@@@&.    :Y@@@@! ~&B!&@@?Y@@@7~##~:G@@@P^.::::Y@@@#^^~^^^!#&~              
29               ?@G~~~~~^^&@@5!@@@P.^G@@#:~~~^7@@@?.J@@@?7@P^:P@@@&GY?5P.   ^@@@&.      Y@@@B:#&!G@@#.:#@@#7&@??@@@#.:~~~~^.G@@@P:~~~^P@J               
30               G@J^~~~~~^&@@P !&@@B:P@@#:~~~^#@@G~^:B@@&7#?^~:!5B&@@@&BY.  ^@@@&.      ?@@@#7&7?@@@7::?@@@P?#JP@@@P.^^^^~~:Y@@@B:~~^7&#:               
31              ~&#!~~~~~^^&@@5757#@@GP@@#:~~:5@@@@&&&@@@@G!!~~~^::^!?B@@@B  ^@@@&.     .B@@@5!7^&@@@&&&&@@@@7~?J@@@#~JYJJY7:B@@@J:~~^P@?                
32              Y@5^~~~~~^^&@@P^?!^G@@@@@#:~^7@@@B?????#@@@J:~^!!~^^::?@@@&. ^@@@&:  .:7B@@@P^^.G@@@Y????Y@@@&::^G@@@B?~^??!P@@@P:^~^?&B.                
33             .B&7^~~~~~^^@@@P.^^^:5@@@@&:^^&@@@!.:::.!@@@@!:^@@&#B#&@@@B~  ^@@@@#B#&@@@&G?^^.J@@@G ...:^P@@@G   J#@@@#BB#@@@G7.:~~~G@7                 
34             !@B!!!!!!!!~555?:~^^^:?555Y::!555?.^^^^^:JP55?^!J5PGGGG5?~    :Y55PPPP5J7!!!^:::Y555^:^^?57:5555^   .~?5PG#&@@@B557:^J@G                  
35             ^PBBBGG#&&&#Y~::^~~~~~^::::^~^::::^~~~~~~!7YY5BGY??777!^               ^JG57^~~~:::::^!G&Y.             7J~^!?5G#&!^!#&~                  
36                .:!Y#&GY7~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~7P#&G?^.  .              .!P&BJ~~~~~~~~~~~?#&7              ?@G~^^::::::^P@Y                   
37             :!JPBBPJ!~^~~~~~~~~^!!~~~~~~~~~~?~~~~~~~~~~~^~?P##PJ~.            ~YB#P?~^~~~~~~~~^!P@P:              7&#!~~~~~~~~^J@B.                   
38       .:~?5BBBPJ7~^^~~~~~~~~^~75#7~~~~~~~~~?&G?~^~~~~~~~~~~^~7YG#BPJ!:.   :!YB#GJ!~~~~~~~~~~^~Y&#7......        .?&B7^~~~~~~~^7&&~                    
39   .!JPBBBPY?!~^^~~~~~~~~~^~7YB&@G~~~~~~~~~^P&#&G?~^~~~~~~~~~~~^~~7YPB#BPYG##PJ!~^~~~~~~~~~^~Y#&J~PBBBBBGGGGGGGGGB#5!~~~~~~~~~!B@7                     
40   7@&Y7!~^^^~~~~~~~~~~^~7YB#G?B@J^~~~~~~~~!#&^~P&BJ~^~~~~~~~~~~~~^^^^!YGPY7~^^~~~~~~~~~^~!5##J: :#&J!!77777777777~^~~~~~~~~^!B@?                      
41    7##J~~~~~~~~~~^^~!?5B#G?: :##!~~~~~~~~^Y@P   ^Y##57~^^~~~~~~~~~^!Y#&Y~^~~~~~~~~~~^^~?G&B?.    ~&B!^~~~~~~~~~~~~~~~~~~~~^?#&7                       
42     .5@G!^~~~^^~!?YG#B5!:    J@P^~~~~~~~~~B@!     .7P#B57~^^~~~~^!5&#JJ&#?~~~~~~~^^~?P##5~        P@Y^~~~~~~~~~~~~~~~~~^^7P&G^                        
43       ?&#7^~!?5G#BP?^.      .B&7^^^^^^^^^7&#.        :7P##PJ!~^!5&#?.  ^G@5~~^^~!JG#B5!.          J@P^^^^^^^^^^^^^^^~!7YG&B7                          
44        !#&GBBG57^.          ~@&JJJJJJJJJJG@Y            .!YG#BP##?.      5@P7JPB#GY~.             ?@BYYYYYYYYYYY55PGBBBPJ^                            
45         :!7~.               .?5PPPPPPPPPP5J.                :!?7:         YBBGY!:                 .7Y555555555YYJJ7!~:.                               
46                                                                            ..                                                                         
47                                                                                                                                                       
48 
49 
50 */
51 
52 // SPDX-License-Identifier: MIT
53 
54 pragma solidity 0.8.17;
55 
56 abstract contract Context {
57     function _msgSender() internal view virtual returns (address) {
58         return msg.sender;
59     }
60 
61     function _msgData() internal view virtual returns (bytes calldata) {
62         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
63         return msg.data;
64     }
65 }
66 
67 interface IERC20 {
68     /**
69      * @dev Returns the amount of tokens in existence.
70      */
71     function totalSupply() external view returns (uint256);
72 
73     /**
74      * @dev Returns the amount of tokens owned by `account`.
75      */
76     function balanceOf(address account) external view returns (uint256);
77 
78     /**
79      * @dev Moves `amount` tokens from the caller's account to `recipient`.
80      *
81      * Returns a boolean value indicating whether the operation succeeded.
82      *
83      * Emits a {Transfer} event.
84      */
85     function transfer(address recipient, uint256 amount) external returns (bool);
86 
87     /**
88      * @dev Returns the remaining number of tokens that `spender` will be
89      * allowed to spend on behalf of `owner` through {transferFrom}. This is
90      * zero by default.
91      *
92      * This value changes when {approve} or {transferFrom} are called.
93      */
94     function allowance(address owner, address spender) external view returns (uint256);
95 
96     /**
97      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
98      *
99      * Returns a boolean value indicating whether the operation succeeded.
100      *
101      * IMPORTANT: Beware that changing an allowance with this method brings the risk
102      * that someone may use both the old and the new allowance by unfortunate
103      * transaction ordering. One possible solution to mitigate this race
104      * condition is to first reduce the spender's allowance to 0 and set the
105      * desired value afterwards:
106      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
107      *
108      * Emits an {Approval} event.
109      */
110     function approve(address spender, uint256 amount) external returns (bool);
111 
112     /**
113      * @dev Moves `amount` tokens from `sender` to `recipient` using the
114      * allowance mechanism. `amount` is then deducted from the caller's
115      * allowance.
116      *
117      * Returns a boolean value indicating whether the operation succeeded.
118      *
119      * Emits a {Transfer} event.
120      */
121     function transferFrom(
122         address sender,
123         address recipient,
124         uint256 amount
125     ) external returns (bool);
126 
127     /**
128      * @dev Emitted when `value` tokens are moved from one account (`from`) to
129      * another (`to`).
130      *
131      * Note that `value` may be zero.
132      */
133     event Transfer(address indexed from, address indexed to, uint256 value);
134 
135     /**
136      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
137      * a call to {approve}. `value` is the new allowance.
138      */
139     event Approval(address indexed owner, address indexed spender, uint256 value);
140 }
141 
142 interface IERC20Metadata is IERC20 {
143     /**
144      * @dev Returns the name of the token.
145      */
146     function name() external view returns (string memory);
147 
148     /**
149      * @dev Returns the symbol of the token.
150      */
151     function symbol() external view returns (string memory);
152 
153     /**
154      * @dev Returns the decimals places of the token.
155      */
156     function decimals() external view returns (uint8);
157 }
158 
159 contract ERC20 is Context, IERC20, IERC20Metadata {
160     mapping(address => uint256) private _balances;
161 
162     mapping(address => mapping(address => uint256)) private _allowances;
163 
164     uint256 private _totalSupply;
165 
166     string private _name;
167     string private _symbol;
168 
169     constructor(string memory name_, string memory symbol_) {
170         _name = name_;
171         _symbol = symbol_;
172     }
173 
174     function name() public view virtual override returns (string memory) {
175         return _name;
176     }
177 
178     function symbol() public view virtual override returns (string memory) {
179         return _symbol;
180     }
181 
182     function decimals() public view virtual override returns (uint8) {
183         return 18;
184     }
185 
186     function totalSupply() public view virtual override returns (uint256) {
187         return _totalSupply;
188     }
189 
190     function balanceOf(address account) public view virtual override returns (uint256) {
191         return _balances[account];
192     }
193 
194     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
195         _transfer(_msgSender(), recipient, amount);
196         return true;
197     }
198 
199     function allowance(address owner, address spender) public view virtual override returns (uint256) {
200         return _allowances[owner][spender];
201     }
202 
203     function approve(address spender, uint256 amount) public virtual override returns (bool) {
204         _approve(_msgSender(), spender, amount);
205         return true;
206     }
207 
208     function transferFrom(
209         address sender,
210         address recipient,
211         uint256 amount
212     ) public virtual override returns (bool) {
213         _transfer(sender, recipient, amount);
214 
215         uint256 currentAllowance = _allowances[sender][_msgSender()];
216         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
217         unchecked {
218             _approve(sender, _msgSender(), currentAllowance - amount);
219         }
220 
221         return true;
222     }
223 
224     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
225         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
226         return true;
227     }
228 
229     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
230         uint256 currentAllowance = _allowances[_msgSender()][spender];
231         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
232         unchecked {
233             _approve(_msgSender(), spender, currentAllowance - subtractedValue);
234         }
235 
236         return true;
237     }
238 
239     function _transfer(
240         address sender,
241         address recipient,
242         uint256 amount
243     ) internal virtual {
244         require(sender != address(0), "ERC20: transfer from the zero address");
245         require(recipient != address(0), "ERC20: transfer to the zero address");
246 
247         uint256 senderBalance = _balances[sender];
248         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
249         unchecked {
250             _balances[sender] = senderBalance - amount;
251         }
252         _balances[recipient] += amount;
253 
254         emit Transfer(sender, recipient, amount);
255     }
256 
257     function _createInitialSupply(address account, uint256 amount) internal virtual {
258         require(account != address(0), "ERC20: mint to the zero address");
259 
260         _totalSupply += amount;
261         _balances[account] += amount;
262         emit Transfer(address(0), account, amount);
263     }
264 
265     function _approve(
266         address owner,
267         address spender,
268         uint256 amount
269     ) internal virtual {
270         require(owner != address(0), "ERC20: approve from the zero address");
271         require(spender != address(0), "ERC20: approve to the zero address");
272 
273         _allowances[owner][spender] = amount;
274         emit Approval(owner, spender, amount);
275     }
276 }
277 
278 contract Ownable is Context {
279     address private _owner;
280 
281     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
282 
283     constructor () {
284         address msgSender = _msgSender();
285         _owner = msgSender;
286         emit OwnershipTransferred(address(0), msgSender);
287     }
288 
289     function owner() public view returns (address) {
290         return _owner;
291     }
292 
293     modifier onlyOwner() {
294         require(_owner == _msgSender(), "Ownable: caller is not the owner");
295         _;
296     }
297 
298     function renounceOwnership() external virtual onlyOwner {
299         emit OwnershipTransferred(_owner, address(0));
300         _owner = address(0);
301     }
302 
303     function transferOwnership(address newOwner) public virtual onlyOwner {
304         require(newOwner != address(0), "Ownable: new owner is the zero address");
305         emit OwnershipTransferred(_owner, newOwner);
306         _owner = newOwner;
307     }
308 }
309 
310 interface IDexRouter {
311     function factory() external pure returns (address);
312     function WETH() external pure returns (address);
313 
314     function swapExactTokensForETHSupportingFeeOnTransferTokens(
315         uint amountIn,
316         uint amountOutMin,
317         address[] calldata path,
318         address to,
319         uint deadline
320     ) external;
321 
322     function swapExactETHForTokensSupportingFeeOnTransferTokens(
323         uint amountOutMin,
324         address[] calldata path,
325         address to,
326         uint deadline
327     ) external payable;
328 
329     function addLiquidityETH(
330         address token,
331         uint256 amountTokenDesired,
332         uint256 amountTokenMin,
333         uint256 amountETHMin,
334         address to,
335         uint256 deadline
336     )
337         external
338         payable
339         returns (
340             uint256 amountToken,
341             uint256 amountETH,
342             uint256 liquidity
343         );
344 }
345 
346 interface IDexFactory {
347     function createPair(address tokenA, address tokenB)
348         external
349         returns (address pair);
350 }
351 
352 contract Contract is ERC20, Ownable {
353 
354     uint256 public maxBuyAmount;
355     uint256 public maxSellAmount;
356     uint256 public maxWalletAmount;
357 
358     IDexRouter public dexRouter;
359     address public lpPair;
360 
361     bool private swapping;
362     uint256 public swapTokensAtAmount;
363 
364     address operationsAddress;
365 
366     uint256 public tradingActiveBlock = 0; // 0 means trading is not active
367     mapping (address => bool) public bot;
368     uint256 public botsCaught;
369 
370     bool public limitsInEffect = true;
371     bool public tradingActive = false;
372     bool public swapEnabled = false;
373 
374      // Anti-bot and anti-whale mappings and variables
375     mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch
376     bool public transferDelayEnabled = true;
377 
378     uint256 public buyTotalFees;
379     uint256 public buyOperationsFee;
380     uint256 public buyLiquidityFee;
381 
382     uint256 public sellTotalFees;
383     uint256 public sellOperationsFee;
384     uint256 public sellLiquidityFee;
385 
386     uint256 public tokensForOperations;
387     uint256 public tokensForLiquidity;
388 
389     /******************/
390 
391     // exlcude from fees and max transaction amount
392     mapping (address => bool) private _isExcludedFromFees;
393     mapping (address => bool) public _isExcludedMaxTransactionAmount;
394 
395     // store addresses that a automatic market maker pairs. Any transfer *to* these addresses
396     // could be subject to a maximum transfer amount
397     mapping (address => bool) public automatedMarketMakerPairs;
398 
399     event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
400 
401     event EnabledTrading();
402 
403     event RemovedLimits();
404 
405     event ExcludeFromFees(address indexed account, bool isExcluded);
406 
407     event UpdatedMaxBuyAmount(uint256 newAmount);
408 
409     event UpdatedMaxSellAmount(uint256 newAmount);
410 
411     event UpdatedMaxWalletAmount(uint256 newAmount);
412 
413     event UpdatedOperationsAddress(address indexed newWallet);
414 
415     event MaxTransactionExclusion(address _address, bool excluded);
416 
417     event BuyBackTriggered(uint256 amount);
418 
419     event OwnerForcedSwapBack(uint256 timestamp);
420  
421     event CaughtEarlyBuyer(address sniper);
422 
423     event SwapAndLiquify(
424         uint256 tokensSwapped,
425         uint256 ethReceived,
426         uint256 tokensIntoLiquidity
427     );
428 
429     event TransferForeignToken(address token, uint256 amount);
430 
431     constructor() ERC20(unicode"Nasdaq420", unicode"NASDAQ") {
432 
433         address newOwner = msg.sender; // can leave alone if owner is deployer.
434 
435         IDexRouter _dexRouter = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
436         dexRouter = _dexRouter;
437 
438         // create pair
439         lpPair = IDexFactory(_dexRouter.factory()).createPair(address(this), _dexRouter.WETH());
440         _excludeFromMaxTransaction(address(lpPair), true);
441         _setAutomatedMarketMakerPair(address(lpPair), true);
442 
443         uint256 totalSupply = 1 * 1e9 * 1e18;
444 
445         maxBuyAmount = totalSupply * 1 / 100;
446         maxSellAmount = totalSupply * 1 / 100;
447         maxWalletAmount = totalSupply * 1 / 100;
448         swapTokensAtAmount = totalSupply * 1 / 1000;
449 
450         buyOperationsFee = 30;
451         buyLiquidityFee = 0;
452         buyTotalFees = buyOperationsFee + buyLiquidityFee;
453 
454         sellOperationsFee = 30;
455         sellLiquidityFee = 0;
456         sellTotalFees = sellOperationsFee + sellLiquidityFee;
457 
458         _excludeFromMaxTransaction(newOwner, true);
459         _excludeFromMaxTransaction(address(this), true);
460         _excludeFromMaxTransaction(address(0xdead), true);
461 
462         excludeFromFees(newOwner, true);
463         excludeFromFees(address(this), true);
464         excludeFromFees(address(0xdead), true);
465 
466         operationsAddress = address(newOwner);
467 
468         _createInitialSupply(newOwner, totalSupply);
469         transferOwnership(newOwner);
470     }
471 
472     receive() external payable {}
473 
474     // only enable if no plan to airdrop
475 
476     function enableTrading() external onlyOwner {
477         require(!tradingActive, "Cannot reenable trading");
478         tradingActive = true;
479         swapEnabled = true;
480         tradingActiveBlock = block.number;
481         emit EnabledTrading();
482     }
483 
484     // remove limits after token is stable
485     function removeLimits() external onlyOwner {
486         limitsInEffect = false;
487         transferDelayEnabled = false;
488         emit RemovedLimits();
489     }
490 
491     function manageBoughtEarly(address wallet, bool flag) external onlyOwner {
492         bot[wallet] = flag;
493     }
494 
495     function massManageBoughtEarly(address[] calldata wallets, bool flag) external onlyOwner {
496         for(uint256 i = 0; i < wallets.length; i++){
497             bot[wallets[i]] = flag;
498         }
499     }
500 
501     // disable Transfer delay - cannot be reenabled
502     function disableTransferDelay() external onlyOwner {
503         transferDelayEnabled = false;
504     }
505 
506     function updateMaxBuyAmount(uint256 newNum) external onlyOwner {
507         require(newNum >= (totalSupply() * 2 / 1000)/1e18, "Cannot set max buy amount lower than 0.2%");
508         maxBuyAmount = newNum * (10**18);
509         emit UpdatedMaxBuyAmount(maxBuyAmount);
510     }
511 
512     function updateMaxSellAmount(uint256 newNum) external onlyOwner {
513         require(newNum >= (totalSupply() * 2 / 1000)/1e18, "Cannot set max sell amount lower than 0.2%");
514         maxSellAmount = newNum * (10**18);
515         emit UpdatedMaxSellAmount(maxSellAmount);
516     }
517 
518     function updateMaxWalletAmount(uint256 newNum) external onlyOwner {
519         require(newNum >= (totalSupply() * 3 / 1000)/1e18, "Cannot set max wallet amount lower than 0.3%");
520         maxWalletAmount = newNum * (10**18);
521         emit UpdatedMaxWalletAmount(maxWalletAmount);
522     }
523 
524     // change the minimum amount of tokens to sell from fees
525     function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {
526   	    require(newAmount >= totalSupply() * 1 / 100000, "Swap amount cannot be lower than 0.001% total supply.");
527   	    require(newAmount <= totalSupply() * 1 / 1000, "Swap amount cannot be higher than 0.1% total supply.");
528   	    swapTokensAtAmount = newAmount;
529   	}
530 
531     function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {
532         _isExcludedMaxTransactionAmount[updAds] = isExcluded;
533         emit MaxTransactionExclusion(updAds, isExcluded);
534     }
535 
536     function airdropToWallets(address[] memory wallets, uint256[] memory amountsInTokens) external onlyOwner {
537         require(wallets.length == amountsInTokens.length, "arrays must be the same length");
538         require(wallets.length < 600, "Can only airdrop 600 wallets per txn due to gas limits"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.
539         for(uint256 i = 0; i < wallets.length; i++){
540             address wallet = wallets[i];
541             uint256 amount = amountsInTokens[i];
542             super._transfer(msg.sender, wallet, amount);
543         }
544     }
545 
546     function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {
547         if(!isEx){
548             require(updAds != lpPair, "Cannot remove uniswap pair from max txn");
549         }
550         _isExcludedMaxTransactionAmount[updAds] = isEx;
551     }
552 
553     function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {
554         require(pair != lpPair, "The pair cannot be removed from automatedMarketMakerPairs");
555 
556         _setAutomatedMarketMakerPair(pair, value);
557         emit SetAutomatedMarketMakerPair(pair, value);
558     }
559 
560     function _setAutomatedMarketMakerPair(address pair, bool value) private {
561         automatedMarketMakerPairs[pair] = value;
562 
563         _excludeFromMaxTransaction(pair, value);
564 
565         emit SetAutomatedMarketMakerPair(pair, value);
566     }
567 
568     function updateBuyFees(uint256 _operationsFee, uint256 _liquidityFee) external onlyOwner {
569         buyOperationsFee = _operationsFee;
570         buyLiquidityFee = _liquidityFee;
571         buyTotalFees = buyOperationsFee + buyLiquidityFee;
572         require(buyTotalFees <= 30, "Must keep fees at 30% or less");
573     }
574 
575     function updateSellFees(uint256 _operationsFee, uint256 _liquidityFee) external onlyOwner {
576         sellOperationsFee = _operationsFee;
577         sellLiquidityFee = _liquidityFee;
578         sellTotalFees = sellOperationsFee + sellLiquidityFee;
579         require(sellTotalFees <= 30, "Must keep fees at 30% or less");
580     }
581 
582     function excludeFromFees(address account, bool excluded) public onlyOwner {
583         _isExcludedFromFees[account] = excluded;
584         emit ExcludeFromFees(account, excluded);
585     }
586 
587     function _transfer(address from, address to, uint256 amount) internal override {
588 
589         require(from != address(0), "ERC20: transfer from the zero address");
590         require(to != address(0), "ERC20: transfer to the zero address");
591         require(amount > 0, "amount must be greater than 0");
592 
593         if(!tradingActive){
594             require(_isExcludedFromFees[from] || _isExcludedFromFees[to], "Trading is not active.");
595         }
596 
597         require(!bot[from] && !bot[to], "Bots cannot transfer tokens in or out except to owner or dead address.");
598 
599         if(limitsInEffect){
600             if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){
601 
602                 // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.
603                 if (transferDelayEnabled){
604                     if (to != address(dexRouter) && to != address(lpPair)){
605                         require(_holderLastTransferTimestamp[tx.origin] < block.number - 2 && _holderLastTransferTimestamp[to] < block.number - 2, "_transfer:: Transfer Delay enabled.  Try again later.");
606                         _holderLastTransferTimestamp[tx.origin] = block.number;
607                         _holderLastTransferTimestamp[to] = block.number;
608                     }
609                 }
610     
611                 //when buy
612                 if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {
613                         require(amount <= maxBuyAmount, "Buy transfer amount exceeds the max buy.");
614                         require(amount + balanceOf(to) <= maxWalletAmount, "Cannot Exceed max wallet");
615                 }
616                 //when sell
617                 else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {
618                         require(amount <= maxSellAmount, "Sell transfer amount exceeds the max sell.");
619                 }
620                 else if (!_isExcludedMaxTransactionAmount[to]){
621                     require(amount + balanceOf(to) <= maxWalletAmount, "Cannot Exceed max wallet");
622                 }
623             }
624         }
625 
626         uint256 contractTokenBalance = balanceOf(address(this));
627 
628         bool canSwap = contractTokenBalance >= swapTokensAtAmount;
629 
630         if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {
631             swapping = true;
632 
633             swapBack();
634 
635             swapping = false;
636         }
637 
638         bool takeFee = true;
639         // if any account belongs to _isExcludedFromFee account then remove the fee
640         if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {
641             takeFee = false;
642         }
643 
644         uint256 fees = 0;
645         // only take fees on buys/sells, do not take on wallet transfers
646         if(takeFee){
647             // on sell
648             if (automatedMarketMakerPairs[to] && sellTotalFees > 0){
649                 fees = amount * sellTotalFees / 100;
650                 tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;
651                 tokensForOperations += fees * sellOperationsFee / sellTotalFees;
652             }
653 
654             // on buy
655             else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {
656         	    fees = amount * buyTotalFees / 100;
657         	    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;
658                 tokensForOperations += fees * buyOperationsFee / buyTotalFees;
659             }
660 
661             if(fees > 0){
662                 super._transfer(from, address(this), fees);
663             }
664 
665         	amount -= fees;
666         }
667 
668         super._transfer(from, to, amount);
669     }
670     function swapTokensForEth(uint256 tokenAmount) private {
671 
672         // generate the uniswap pair path of token -> weth
673         address[] memory path = new address[](2);
674         path[0] = address(this);
675         path[1] = dexRouter.WETH();
676 
677         _approve(address(this), address(dexRouter), tokenAmount);
678 
679         // make the swap
680         dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
681             tokenAmount,
682             0, // accept any amount of ETH
683             path,
684             address(this),
685             block.timestamp
686         );
687     }
688 
689     function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
690         // approve token transfer to cover all possible scenarios
691         _approve(address(this), address(dexRouter), tokenAmount);
692 
693         // add the liquidity
694         dexRouter.addLiquidityETH{value: ethAmount}(
695             address(this),
696             tokenAmount,
697             0, // slippage is unavoidable
698             0, // slippage is unavoidable
699             address(0xdead),
700             block.timestamp
701         );
702     }
703 
704     function swapBack() private {
705         uint256 contractBalance = balanceOf(address(this));
706         uint256 totalTokensToSwap = tokensForLiquidity + tokensForOperations;
707 
708         if(contractBalance == 0 || totalTokensToSwap == 0) {return;}
709 
710         if(contractBalance > swapTokensAtAmount * 60){
711             contractBalance = swapTokensAtAmount * 60;
712         }
713 
714         bool success;
715 
716         // Halve the amount of liquidity tokens
717         uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;
718 
719         swapTokensForEth(contractBalance - liquidityTokens);
720 
721         uint256 ethBalance = address(this).balance;
722         uint256 ethForLiquidity = ethBalance;
723 
724         uint256 ethForOperations = ethBalance * tokensForOperations / (totalTokensToSwap - (tokensForLiquidity/2));
725 
726         ethForLiquidity -= ethForOperations;
727 
728         tokensForLiquidity = 0;
729         tokensForOperations = 0;
730 
731         if(liquidityTokens > 0 && ethForLiquidity > 0){
732             addLiquidity(liquidityTokens, ethForLiquidity);
733         }
734 
735         if(address(this).balance > 0){
736             (success,) = address(operationsAddress).call{value: address(this).balance}("");
737         }
738     }
739 
740     function transferForeignToken(address _token, address _to) external onlyOwner returns (bool _sent) {
741         require(_token != address(0), "_token address cannot be 0");
742         uint256 _contractBalance = IERC20(_token).balanceOf(address(this));
743         _sent = IERC20(_token).transfer(_to, _contractBalance);
744         emit TransferForeignToken(_token, _contractBalance);
745     }
746 
747     // withdraw ETH if stuck or someone sends to the address
748     function withdrawStuckETH() external onlyOwner {
749         bool success;
750         (success,) = address(msg.sender).call{value: address(this).balance}("");
751     }
752 
753     function setOperationsAddress(address _operationsAddress) external onlyOwner {
754         require(_operationsAddress != address(0), "_operationsAddress address cannot be 0");
755         operationsAddress = payable(_operationsAddress);
756     }
757 
758     // force Swap back if slippage issues.
759     function forceSwapBack() external onlyOwner {
760         require(balanceOf(address(this)) >= 0, "No tokens to swap");
761         swapping = true;
762         swapBack();
763         swapping = false;
764         emit OwnerForcedSwapBack(block.timestamp);
765     }
766 
767 }