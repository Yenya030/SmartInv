1 {{
2   "language": "Solidity",
3   "sources": {
4     "@thirdweb-dev/contracts/extension/interface/IPermissions.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IPermissions {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
6     },
7     "@thirdweb-dev/contracts/extension/Permissions.sol": {
8       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./interface/IPermissions.sol\";\nimport \"../lib/TWStrings.sol\";\n\n/**\n *  @title   Permissions\n *  @dev     This contracts provides extending-contracts with role-based access control mechanisms\n */\ncontract Permissions is IPermissions {\n    /// @dev Map from keccak256 hash of a role => a map from address => whether address has role.\n    mapping(bytes32 => mapping(address => bool)) private _hasRole;\n\n    /// @dev Map from keccak256 hash of a role to role admin. See {getRoleAdmin}.\n    mapping(bytes32 => bytes32) private _getRoleAdmin;\n\n    /// @dev Default admin role for all roles. Only accounts with this role can grant/revoke other roles.\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /// @dev Modifier that checks if an account has the specified role; reverts otherwise.\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     *  @notice         Checks whether an account has a particular role.\n     *  @dev            Returns `true` if `account` has been granted `role`.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     *  @param account  Address of the account for which the role is being checked.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _hasRole[role][account];\n    }\n\n    /**\n     *  @notice         Checks whether an account has a particular role;\n     *                  role restrictions can be swtiched on and off.\n     *\n     *  @dev            Returns `true` if `account` has been granted `role`.\n     *                  Role restrictions can be swtiched on and off:\n     *                      - If address(0) has ROLE, then the ROLE restrictions\n     *                        don't apply.\n     *                      - If address(0) does not have ROLE, then the ROLE\n     *                        restrictions will apply.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     *  @param account  Address of the account for which the role is being checked.\n     */\n    function hasRoleWithSwitch(bytes32 role, address account) public view returns (bool) {\n        if (!_hasRole[role][address(0)]) {\n            return _hasRole[role][account];\n        }\n\n        return true;\n    }\n\n    /**\n     *  @notice         Returns the admin role that controls the specified role.\n     *  @dev            See {grantRole} and {revokeRole}.\n     *                  To change a role's admin, use {_setRoleAdmin}.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     */\n    function getRoleAdmin(bytes32 role) external view override returns (bytes32) {\n        return _getRoleAdmin[role];\n    }\n\n    /**\n     *  @notice         Grants a role to an account, if not previously granted.\n     *  @dev            Caller must have admin role for the `role`.\n     *                  Emits {RoleGranted Event}.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     *  @param account  Address of the account to which the role is being granted.\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        _checkRole(_getRoleAdmin[role], msg.sender);\n        if (_hasRole[role][account]) {\n            revert(\"Can only grant to non holders\");\n        }\n        _setupRole(role, account);\n    }\n\n    /**\n     *  @notice         Revokes role from an account.\n     *  @dev            Caller must have admin role for the `role`.\n     *                  Emits {RoleRevoked Event}.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     *  @param account  Address of the account from which the role is being revoked.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        _checkRole(_getRoleAdmin[role], msg.sender);\n        _revokeRole(role, account);\n    }\n\n    /**\n     *  @notice         Revokes role from the account.\n     *  @dev            Caller must have the `role`, with caller being the same as `account`.\n     *                  Emits {RoleRevoked Event}.\n     *\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     *  @param account  Address of the account from which the role is being revoked.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        if (msg.sender != account) {\n            revert(\"Can only renounce for self\");\n        }\n        _revokeRole(role, account);\n    }\n\n    /// @dev Sets `adminRole` as `role`'s admin role.\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin[role];\n        _getRoleAdmin[role] = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /// @dev Sets up `role` for `account`\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _hasRole[role][account] = true;\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /// @dev Revokes `role` from `account`\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        _checkRole(role, account);\n        delete _hasRole[role][account];\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /// @dev Checks `role` for `account`. Reverts with a message including the required role.\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole[role][account]) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Permissions: account \",\n                        TWStrings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        TWStrings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /// @dev Checks `role` for `account`. Reverts with a message including the required role.\n    function _checkRoleWithSwitch(bytes32 role, address account) internal view virtual {\n        if (!hasRoleWithSwitch(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Permissions: account \",\n                        TWStrings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        TWStrings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n}\n"
9     },
10     "@thirdweb-dev/contracts/lib/TWStrings.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary TWStrings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
12     },
13     "@thirdweb-dev/contracts/openzeppelin-presets/security/ReentrancyGuard.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
15     },
16     "@thirdweb-dev/contracts/openzeppelin-presets/utils/Context.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
18     },
19     "@thirdweb-dev/contracts/openzeppelin-presets/utils/cryptography/ECDSA.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../lib/TWStrings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", TWStrings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
21     },
22     "@thirdweb-dev/contracts/openzeppelin-presets/utils/cryptography/EIP712.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
24     },
25     "contracts/Bonfire.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@thirdweb-dev/contracts/extension/Permissions.sol\";\r\nimport \"@thirdweb-dev/contracts/openzeppelin-presets/security/ReentrancyGuard.sol\";\r\nimport \"@thirdweb-dev/contracts/openzeppelin-presets/utils/cryptography/EIP712.sol\";\r\nimport \"./extensions/Pausable.sol\";\r\nimport \"./interfaces/IBonfire.sol\";\r\n\r\nimport \"./interfaces/original/IOldWorldPass.sol\"; // old WP\r\nimport \"./interfaces/original/IOldDiceNFT.sol\"; // old Dice\r\nimport \"./interfaces/IDiceNFT.sol\"; // new Dice\r\nimport \"./interfaces/IWorldPassNFT.sol\"; // new WP\r\n\r\ncontract Bonfire is EIP712, ReentrancyGuard, Pausable, Permissions, IBonfire {\r\n    using ECDSA for bytes32;\r\n\r\n    bytes32 private constant TYPEHASH =\r\n        keccak256(\r\n            \"BurnRequest(address to,uint128 wpBurnAmount,uint256[] diceIds,uint8[] diceResults,uint8[] wpHouses,uint128 validityStartTimestamp,uint128 validityEndTimestamp,bytes32 uid)\"\r\n        );\r\n\r\n    /// @dev Mapping from burn request UID => whether the request is processed.\r\n    mapping(bytes32 => bool) private requestIdProcessed;\r\n\r\n    address public allowedSigner;\r\n\r\n    address public immutable originalDice;\r\n    address public immutable originalWP;\r\n    address public immutable reforgedDice;\r\n    address public immutable reforgedWP;\r\n\r\n    IOldWorldPass internal immutable oldWP;\r\n    IOldDiceNFT internal immutable oldDice;\r\n    IDiceNFT internal immutable newDice;\r\n    IWorldPassNFT internal immutable newWP;\r\n\r\n    // Allows pausing/unpausing\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n    constructor(\r\n        address _originalDice,\r\n        address _originalWP,\r\n        address _reforgedDice,\r\n        address _reforgedWP,\r\n        address _allowedSigner\r\n    ) EIP712(\"Bonfire\", \"1\") {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _setupRole(PAUSER_ROLE, msg.sender);\r\n\r\n        allowedSigner = _allowedSigner;\r\n\r\n        originalDice = _originalDice;\r\n        originalWP = _originalWP;\r\n        reforgedDice = _reforgedDice;\r\n        reforgedWP = _reforgedWP;\r\n\r\n        oldWP = IOldWorldPass(originalWP);\r\n        oldDice = IOldDiceNFT(originalDice);\r\n        newDice = IDiceNFT(reforgedDice);\r\n        newWP = IWorldPassNFT(reforgedWP);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        Our custom logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function bonfireBurn(BurnRequest calldata _req, bytes calldata _signature)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        returns (address signer)\r\n    {\r\n        require(\r\n            _req.wpBurnAmount == _req.wpHouses.length,\r\n            \"Unequal wpBurnAmount & wpHouses\"\r\n        );\r\n\r\n        require(\r\n            _req.wpBurnAmount > 0 || _req.diceIds.length > 0,\r\n            \"Nothing to burn\"\r\n        );\r\n\r\n        // Verify and process payload.\r\n        signer = _processRequest(_req, _signature);\r\n\r\n        // Burn the requested amount of original WPs\r\n        // User needs to first approveAll on original WP for this Bonfire contract\r\n        if (_req.wpBurnAmount > 0) {\r\n            oldWP.burn(_req.to, 0, _req.wpBurnAmount);\r\n        }\r\n\r\n        // Burn the requested original dice NFTs & ensure req.to is the owner of the diceIDs\r\n        // User needs to first approveAll on original Dice for this Bonfire contract\r\n        uint256 diceBurnAmount = _req.diceIds.length;\r\n        for (uint256 i = 0; i < diceBurnAmount; ) {\r\n            if (oldDice.ownerOf(_req.diceIds[i]) != _req.to) {\r\n                revert(\"Only the owner of the dice can burn them\");\r\n            }\r\n\r\n            oldDice.burn(_req.diceIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint the new WP NFTs\r\n        for (uint256 i = 0; i < _req.wpHouses.length; ) {\r\n            newWP.mintWithHouseTo(_req.to, House(_req.wpHouses[i]));\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint the new Dice NFTs\r\n        if (diceBurnAmount > 0) {\r\n            if (diceBurnAmount == 1) {\r\n                newDice.mint(_req.to, _req.diceIds[0]);\r\n            } else {\r\n                newDice.batchMint(_req.to, _req.diceIds);\r\n            }\r\n        }\r\n\r\n        emit BonfireBurn(_req.to, _req);\r\n    }\r\n\r\n    /**\r\n     *  @notice Allows caller to burn their old dice to mint new ones.\r\n     *\r\n     *  @param diceIds The diceIds to burn & re-mint from new contract.\r\n     */\r\n    function burnDiceOnly(uint256[] calldata diceIds)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        require(diceIds.length > 0, \"Nothing to burn\");\r\n\r\n        // Burn the requested original dice NFTs\r\n        // User needs to first approveAll on original Dice for this Bonfire contract\r\n        uint256 diceBurnAmount = diceIds.length;\r\n        for (uint256 i = 0; i < diceBurnAmount; ) {\r\n            if (oldDice.ownerOf(diceIds[i]) != msg.sender) {\r\n                revert(\"Only the owner of the dice can burn them\");\r\n            }\r\n\r\n            oldDice.burn(diceIds[i]);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // Mint the new Dice NFTs\r\n        if (diceBurnAmount == 1) {\r\n            newDice.mint(msg.sender, diceIds[0]);\r\n        } else {\r\n            newDice.batchMint(msg.sender, diceIds);\r\n        }\r\n\r\n        emit BonfireBurnDiceOnly(msg.sender, diceIds);\r\n    }\r\n\r\n    /**\r\n     *  @notice Allows caller to burn their old wp to mint new WPs with \"Scarred\" attribute.\r\n     *\r\n     *  @param burnAmount The amount of old WPs to burn & re-mint from new contract.\r\n     */\r\n    function joinScarred(uint256 burnAmount)\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n    {\r\n        require(burnAmount > 0, \"Cannot burn nothing\");\r\n\r\n        oldWP.burn(msg.sender, 0, burnAmount);\r\n\r\n        if (burnAmount == 1) {\r\n            newWP.mintWithHouseTo(msg.sender, House.Scarred);\r\n        } else {\r\n            newWP.batchMintWithHouseTo(msg.sender, burnAmount, House.Scarred);\r\n        }\r\n\r\n        emit BonfireJoinScarred(msg.sender, burnAmount);\r\n    }\r\n\r\n    function setAllowedSigner(address _allowedSigner)\r\n        public\r\n        onlyRole(DEFAULT_ADMIN_ROLE)\r\n    {\r\n        require(_allowedSigner != address(0), \"allowedSigner undefined\");\r\n\r\n        allowedSigner = _allowedSigner;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        EIP712 related logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Verifies that a burn request is signed by an authorized account.\r\n    function verify(BurnRequest calldata _req, bytes calldata _signature)\r\n        public\r\n        view\r\n        returns (bool success, address signer)\r\n    {\r\n        signer = _recoverAddress(_req, _signature);\r\n        success = !requestIdProcessed[_req.uid] && _canSignBurnRequest(signer);\r\n    }\r\n\r\n    /// @dev Returns whether a given address is authorized to sign burn requests.\r\n    function _canSignBurnRequest(address _signer) internal view returns (bool) {\r\n        return _signer == allowedSigner;\r\n    }\r\n\r\n    /// @dev Verifies a burn request and marks the request as processed.\r\n    function _processRequest(\r\n        BurnRequest calldata _req,\r\n        bytes calldata _signature\r\n    ) internal returns (address signer) {\r\n        bool success;\r\n        (success, signer) = verify(_req, _signature);\r\n\r\n        if (!success) {\r\n            revert(\"Invalid req\");\r\n        }\r\n\r\n        if (\r\n            _req.validityStartTimestamp > block.timestamp ||\r\n            block.timestamp > _req.validityEndTimestamp\r\n        ) {\r\n            revert(\"Req expired\");\r\n        }\r\n        require(_req.to != address(0), \"recipient undefined\");\r\n\r\n        requestIdProcessed[_req.uid] = true;\r\n    }\r\n\r\n    /// @dev Returns the address of the signer of the burn request.\r\n    function _recoverAddress(\r\n        BurnRequest calldata _req,\r\n        bytes calldata _signature\r\n    ) internal view returns (address) {\r\n        return\r\n            _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(\r\n                _signature\r\n            );\r\n    }\r\n\r\n    /// @dev Resolves 'stack too deep' error in `recoverAddress`.\r\n    function _encodeRequest(BurnRequest calldata _req)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encode(\r\n                TYPEHASH,\r\n                _req.to,\r\n                _req.wpBurnAmount,\r\n                keccak256(abi.encodePacked(_req.diceIds)),\r\n                keccak256(abi.encodePacked(_req.diceResults)),\r\n                keccak256(abi.encodePacked(_req.wpHouses)),\r\n                _req.validityStartTimestamp,\r\n                _req.validityEndTimestamp,\r\n                _req.uid\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            Pausable Logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function pause() external onlyRole(PAUSER_ROLE) whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyRole(PAUSER_ROLE) whenPaused {\r\n        _unpause();\r\n    }\r\n}\r\n"
27     },
28     "contracts/extensions/Pausable.sol": {
29       "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n// Modified context dependency to work with thirdweb's ecosystem\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@thirdweb-dev/contracts/openzeppelin-presets/utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n"
30     },
31     "contracts/interfaces/IBonfire.sol": {
32       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IWorldPassNFT.sol\";\r\n\r\ninterface IBonfire {\r\n    /**\r\n     *  @notice The body of a request to burn old WP & mint new, including dice roll.\r\n     *\r\n     *  @param to The owner of rolled dice & burnt WPs, and receiver of the WP tokens to mint.\r\n     *  @param wpBurnAmount The amount of 1155 WPs to burn. Needs to be <= the amount of WPs owned by `to` address.\r\n     *  @param diceIds Array of original Dice NFT IDs to be reforged (burn old & mint new).\r\n     *  @param diceResults Array of the dice roll results (totals).\r\n     *  @param wpIds Array of the new WP IDs to mint.\r\n     *  @param validityStartTimestamp The unix timestamp after which the payload is valid.\r\n     *  @param validityEndTimestamp The unix timestamp at which the payload expires.\r\n     *  @param uid A unique identifier for the payload.\r\n     */\r\n    struct BurnRequest {\r\n        address to;\r\n        uint128 wpBurnAmount;\r\n        uint256[] diceIds;\r\n        uint8[] diceResults;\r\n        uint8[] wpHouses;\r\n        uint128 validityStartTimestamp;\r\n        uint128 validityEndTimestamp;\r\n        bytes32 uid;\r\n    }\r\n\r\n    /// @dev Emitted on Bonfire Burn call.\r\n    event BonfireBurn(address indexed mintedTo, BurnRequest burnRequest);\r\n\r\n    /// @dev Emitted on Bonfire burnDiceOnly call.\r\n    event BonfireBurnDiceOnly(\r\n        address indexed mintedTo,\r\n        uint256[] indexed burntDiceIDs\r\n    );\r\n\r\n    /// @dev Emitted on Bonfire joinScarred call.\r\n    event BonfireJoinScarred(\r\n        address indexed mintedTo,\r\n        uint256 indexed burnAmount\r\n    );\r\n\r\n    /**\r\n     *  @notice Verifies that a burn request is signed by a specific account\r\n     *\r\n     *  @param req The payload / burn request.\r\n     *  @param signature The signature produced by an account signing the burn request.\r\n     *\r\n     *  returns (success, signer) Result of verification and the recovered address.\r\n     */\r\n    function verify(BurnRequest calldata req, bytes calldata signature)\r\n        external\r\n        view\r\n        returns (bool success, address signer);\r\n\r\n    /**\r\n     *  @notice Mints tokens according to the provided mint request.\r\n     *\r\n     *  @param req The payload / mint request.\r\n     *  @param signature The signature produced by an account signing the mint request.\r\n     *\r\n     *  returns (signer) the recovered address.\r\n     */\r\n    function bonfireBurn(BurnRequest calldata req, bytes calldata signature)\r\n        external\r\n        returns (address signer);\r\n\r\n    /**\r\n     *  @notice Allows caller to burn their old dice to mint new ones.\r\n     *\r\n     *  @param diceIds The diceIds to burn & re-mint from new contract.\r\n     */\r\n    function burnDiceOnly(uint256[] calldata diceIds) external;\r\n\r\n    /**\r\n     *  @notice Allows caller to burn their old wp to mint new WPs with \"Scarred\" attribute.\r\n     *\r\n     *  @param burnAmount The amount of old WPs to burn & re-mint from new contract.\r\n     */\r\n    function joinScarred(uint256 burnAmount) external;\r\n}\r\n"
33     },
34     "contracts/interfaces/IDiceNFT.sol": {
35       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nenum Material {\r\n    Amber,\r\n    Amethyst,\r\n    Ruby,\r\n    Sapphire,\r\n    Spinel,\r\n    Topaz\r\n}\r\n\r\nenum DieType {\r\n    D4,\r\n    D6,\r\n    D8,\r\n    D10,\r\n    D12,\r\n    D20\r\n}\r\n\r\nenum ElementalType {\r\n    Dark,\r\n    Space,\r\n    Time,\r\n    Psychic,\r\n    Light\r\n}\r\n\r\nlibrary MaterialUtil {\r\n    function toString(Material _material)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (_material == Material.Amber) {\r\n            return \"Amber\";\r\n        } else if (_material == Material.Amethyst) {\r\n            return \"Amethyst\";\r\n        } else if (_material == Material.Ruby) {\r\n            return \"Ruby\";\r\n        } else if (_material == Material.Sapphire) {\r\n            return \"Sapphire\";\r\n        } else if (_material == Material.Spinel) {\r\n            return \"Spinel\";\r\n        } else {\r\n            return \"Topaz\";\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DiceTypeUtil {\r\n    function toString(DieType _type) internal pure returns (string memory) {\r\n        if (_type == DieType.D4) {\r\n            return \"D4\";\r\n        } else if (_type == DieType.D6) {\r\n            return \"D6\";\r\n        } else if (_type == DieType.D8) {\r\n            return \"D8\";\r\n        } else if (_type == DieType.D10) {\r\n            return \"D10\";\r\n        } else if (_type == DieType.D12) {\r\n            return \"D12\";\r\n        } else {\r\n            return \"D20\";\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ElementalTypeUtil {\r\n    function toString(ElementalType _el) internal pure returns (string memory) {\r\n        if (_el == ElementalType.Dark) {\r\n            return \"Dark\";\r\n        } else if (_el == ElementalType.Space) {\r\n            return \"Space\";\r\n        } else if (_el == ElementalType.Time) {\r\n            return \"Time\";\r\n        } else if (_el == ElementalType.Psychic) {\r\n            return \"Psychic\";\r\n        } else {\r\n            return \"Light\";\r\n        }\r\n    }\r\n}\r\n\r\nlibrary DiceBitmapUtil {\r\n    function getDiceType(uint48 bitmap, uint8 diceIdx)\r\n        internal\r\n        pure\r\n        returns (DieType)\r\n    {\r\n        // 3 bits type, then 3 bits material. This is repeated 7 times perDiceIdx\r\n        uint256 shiftAmount = diceIdx * 6;\r\n        // 7 as mask, which is 111, to get three bits\r\n        uint8 typeBit = uint8((bitmap & (7 << shiftAmount)) >> shiftAmount);\r\n        return DieType(typeBit);\r\n    }\r\n\r\n    function getDiceMaterial(uint48 bitmap, uint8 diceIdx)\r\n        internal\r\n        pure\r\n        returns (Material)\r\n    {\r\n        uint256 shiftAmount = diceIdx * 6 + 3;\r\n        uint8 typeBit = uint8((bitmap & (7 << shiftAmount)) >> shiftAmount);\r\n        return Material(typeBit);\r\n    }\r\n\r\n    function getElementType(uint48 bitmap)\r\n        internal\r\n        pure\r\n        returns (ElementalType)\r\n    {\r\n        uint256 shiftAmount = 7 * 6; // after last/7th dice\r\n        uint8 typeBit = uint8((bitmap & (7 << shiftAmount)) >> shiftAmount);\r\n        return ElementalType(typeBit);\r\n    }\r\n}\r\n\r\ninterface IDiceNFT {\r\n    struct DiceMetadata {\r\n        uint48 bitmap;\r\n        uint8 amount;\r\n        uint8 power;\r\n    }\r\n\r\n    event BoostUpdated(uint256 indexed tokenId, uint256 newBoostCount);\r\n\r\n    function setOriginalMetadata(\r\n        DiceMetadata[] calldata originalMetadata,\r\n        uint128 _startIndex,\r\n        uint128 _endIndex\r\n    ) external;\r\n\r\n    function resetBoosts(uint256 _newDefaultBoostCount) external;\r\n\r\n    function useBoost(uint256 tokenId, uint256 count) external;\r\n\r\n    function setBoostCount(uint256 tokenId, uint16 boostCount) external;\r\n\r\n    function mint(address _to, uint256 _oldTokenId) external;\r\n\r\n    function batchMint(address _to, uint256[] calldata _oldTokenIds) external;\r\n\r\n    function getDiceBoosts(uint256 _tokenId) external view returns (uint256);\r\n\r\n    function getDiceMaterials(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (string[] memory);\r\n\r\n    function getDiceMetadata(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (DiceMetadata memory);\r\n}\r\n"
36     },
37     "contracts/interfaces/IWorldPassNFT.sol": {
38       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nenum House {\r\n    Scarred,\r\n    Arms,\r\n    Hearts,\r\n    Sight,\r\n    Hearing,\r\n    Shadows\r\n}\r\n\r\nlibrary HouseUtil {\r\n    function toString(House _house) internal pure returns (string memory) {\r\n        if (_house == House.Arms) {\r\n            return \"Arms\";\r\n        } else if (_house == House.Hearts) {\r\n            return \"Hearts\";\r\n        } else if (_house == House.Sight) {\r\n            return \"Sight\";\r\n        } else if (_house == House.Hearing) {\r\n            return \"Hearing\";\r\n        } else if (_house == House.Shadows) {\r\n            return \"Shadows\";\r\n        } else {\r\n            return \"Scarred\";\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWorldPassNFT {\r\n    struct TokenData {\r\n        bool __exists;\r\n\r\n        House house;\r\n    }\r\n\r\n    function setTokenHouse(uint256 _tokenId, House _house) external;\r\n\r\n    function getTokenHouse(uint256 _tokenId) external view returns (House);\r\n\r\n    function getRemainingHouseSupply(House _house) external view returns (uint256);\r\n\r\n    function mintWithHouseTo(address _to, House _house) external;\r\n\r\n    function batchMintWithHouseTo(\r\n        address _to,\r\n        uint256 _quantity,\r\n        House _house\r\n    ) external;\r\n}\r\n"
39     },
40     "contracts/interfaces/original/IOldDiceNFT.sol": {
41       "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\ninterface IOldDiceNFT {\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n    error ApprovalQueryForNonexistentToken();\r\n    error ApprovalToCurrentOwner();\r\n    error ApproveToCaller();\r\n    error BalanceQueryForZeroAddress();\r\n    error MintToZeroAddress();\r\n    error MintZeroQuantity();\r\n    error OwnerQueryForNonexistentToken();\r\n    error TransferCallerNotOwnerNorApproved();\r\n    error TransferFromIncorrectOwner();\r\n    error TransferToNonERC721ReceiverImplementer();\r\n    error TransferToZeroAddress();\r\n    error URIQueryForNonexistentToken();\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    event ContractURIUpdated(string prevURI, string newURI);\r\n    event DefaultRoyalty(\r\n        address indexed newRoyaltyRecipient,\r\n        uint256 newRoyaltyBps\r\n    );\r\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\r\n    event RoyaltyForToken(\r\n        uint256 indexed tokenId,\r\n        address indexed royaltyRecipient,\r\n        uint256 royaltyBps\r\n    );\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    function airdrop(address[] memory _addresses, uint256[] memory _amounts)\r\n        external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function burn(uint256 _tokenId) external;\r\n\r\n    function contractURI() external view returns (string memory);\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function getDefaultRoyaltyInfo() external view returns (address, uint16);\r\n\r\n    function getRoyaltyInfoForToken(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address, uint16);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function multicall(bytes[] memory data)\r\n        external\r\n        returns (bytes[] memory results);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function setBaseURI(string memory _uri) external;\r\n\r\n    function setContractURI(string memory _uri) external;\r\n\r\n    function setDefaultRoyaltyInfo(\r\n        address _royaltyRecipient,\r\n        uint256 _royaltyBps\r\n    ) external;\r\n\r\n    function setOwner(address _newOwner) external;\r\n\r\n    function setRoyaltyInfoForToken(\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _bps\r\n    ) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n}\r\n"
42     },
43     "contracts/interfaces/original/IOldWorldPass.sol": {
44       "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\ninterface IOldWorldPass {\r\n    error Ownable__NotAuthorized();\r\n    error PlatformFee__ExceedsMaxBps(uint256 platformFeeBps);\r\n    error PlatformFee__NotAuthorized();\r\n    error PrimarySale__NotAuthorized();\r\n    error Royalty__ExceedsMaxBps(uint256 royaltyBps);\r\n    error Royalty__NotAuthorized();\r\n    event ApprovalForAll(\r\n        address indexed account,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n    event ClaimConditionsUpdated(\r\n        uint256 indexed tokenId,\r\n        IDropClaimCondition.ClaimCondition[] claimConditions\r\n    );\r\n    event DefaultRoyalty(\r\n        address indexed newRoyaltyRecipient,\r\n        uint256 newRoyaltyBps\r\n    );\r\n    event MaxTotalSupplyUpdated(uint256 tokenId, uint256 maxTotalSupply);\r\n    event MaxWalletClaimCountUpdated(uint256 tokenId, uint256 count);\r\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\r\n    event PlatformFeeInfoUpdated(\r\n        address indexed platformFeeRecipient,\r\n        uint256 platformFeeBps\r\n    );\r\n    event PrimarySaleRecipientUpdated(address indexed recipient);\r\n    event RoleAdminChanged(\r\n        bytes32 indexed role,\r\n        bytes32 indexed previousAdminRole,\r\n        bytes32 indexed newAdminRole\r\n    );\r\n    event RoleGranted(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n    event RoleRevoked(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n    event RoyaltyForToken(\r\n        uint256 indexed tokenId,\r\n        address indexed royaltyRecipient,\r\n        uint256 royaltyBps\r\n    );\r\n    event SaleRecipientForTokenUpdated(\r\n        uint256 indexed tokenId,\r\n        address saleRecipient\r\n    );\r\n    event TokensClaimed(\r\n        uint256 indexed claimConditionIndex,\r\n        uint256 indexed tokenId,\r\n        address indexed claimer,\r\n        address receiver,\r\n        uint256 quantityClaimed\r\n    );\r\n    event TokensLazyMinted(\r\n        uint256 startTokenId,\r\n        uint256 endTokenId,\r\n        string baseURI\r\n    );\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n    event URI(string value, uint256 indexed id);\r\n    event WalletClaimCountUpdated(\r\n        uint256 tokenId,\r\n        address indexed wallet,\r\n        uint256 count\r\n    );\r\n\r\n    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    function balanceOf(address account, uint256 id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 value\r\n    ) external;\r\n\r\n    function burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory values\r\n    ) external;\r\n\r\n    function claim(\r\n        address _receiver,\r\n        uint256 _tokenId,\r\n        uint256 _quantity,\r\n        address _currency,\r\n        uint256 _pricePerToken,\r\n        bytes32[] memory _proofs,\r\n        uint256 _proofMaxQuantityPerTransaction\r\n    ) external payable;\r\n\r\n    function claimCondition(uint256)\r\n        external\r\n        view\r\n        returns (uint256 currentStartId, uint256 count);\r\n\r\n    function contractType() external pure returns (bytes32);\r\n\r\n    function contractURI() external view returns (string memory);\r\n\r\n    function contractVersion() external pure returns (uint8);\r\n\r\n    function getActiveClaimConditionId(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getClaimConditionById(uint256 _tokenId, uint256 _conditionId)\r\n        external\r\n        view\r\n        returns (IDropClaimCondition.ClaimCondition memory condition);\r\n\r\n    function getClaimTimestamp(\r\n        uint256 _tokenId,\r\n        uint256 _conditionId,\r\n        address _claimer\r\n    )\r\n        external\r\n        view\r\n        returns (uint256 lastClaimTimestamp, uint256 nextValidClaimTimestamp);\r\n\r\n    function getDefaultRoyaltyInfo() external view returns (address, uint16);\r\n\r\n    function getPlatformFeeInfo() external view returns (address, uint16);\r\n\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    function getRoleMember(bytes32 role, uint256 index)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\r\n\r\n    function getRoyaltyInfoForToken(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address, uint16);\r\n\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    function hasRole(bytes32 role, address account)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function initialize(\r\n        address _defaultAdmin,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _contractURI,\r\n        address[] memory _trustedForwarders,\r\n        address _saleRecipient,\r\n        address _royaltyRecipient,\r\n        uint128 _royaltyBps,\r\n        uint128 _platformFeeBps,\r\n        address _platformFeeRecipient\r\n    ) external;\r\n\r\n    function isApprovedForAll(address account, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isTrustedForwarder(address forwarder) external view returns (bool);\r\n\r\n    function lazyMint(uint256 _amount, string memory _baseURIForTokens)\r\n        external;\r\n\r\n    function maxTotalSupply(uint256) external view returns (uint256);\r\n\r\n    function maxWalletClaimCount(uint256) external view returns (uint256);\r\n\r\n    function multicall(bytes[] memory data)\r\n        external\r\n        returns (bytes[] memory results);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function nextTokenIdToMint() external view returns (uint256);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function primarySaleRecipient() external view returns (address);\r\n\r\n    function renounceRole(bytes32 role, address account) external;\r\n\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function saleRecipient(uint256) external view returns (address);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function setClaimConditions(\r\n        uint256 _tokenId,\r\n        IDropClaimCondition.ClaimCondition[] memory _phases,\r\n        bool _resetClaimEligibility\r\n    ) external;\r\n\r\n    function setContractURI(string memory _uri) external;\r\n\r\n    function setDefaultRoyaltyInfo(\r\n        address _royaltyRecipient,\r\n        uint256 _royaltyBps\r\n    ) external;\r\n\r\n    function setMaxTotalSupply(uint256 _tokenId, uint256 _maxTotalSupply)\r\n        external;\r\n\r\n    function setMaxWalletClaimCount(uint256 _tokenId, uint256 _count) external;\r\n\r\n    function setOwner(address _newOwner) external;\r\n\r\n    function setPlatformFeeInfo(\r\n        address _platformFeeRecipient,\r\n        uint256 _platformFeeBps\r\n    ) external;\r\n\r\n    function setPrimarySaleRecipient(address _saleRecipient) external;\r\n\r\n    function setRoyaltyInfoForToken(\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _bps\r\n    ) external;\r\n\r\n    function setSaleRecipientForToken(uint256 _tokenId, address _saleRecipient)\r\n        external;\r\n\r\n    function setWalletClaimCount(\r\n        uint256 _tokenId,\r\n        address _claimer,\r\n        uint256 _count\r\n    ) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply(uint256) external view returns (uint256);\r\n\r\n    function uri(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (string memory _tokenURI);\r\n\r\n    function verifyClaim(\r\n        uint256 _conditionId,\r\n        address _claimer,\r\n        uint256 _tokenId,\r\n        uint256 _quantity,\r\n        address _currency,\r\n        uint256 _pricePerToken,\r\n        bool verifyMaxQuantityPerTransaction\r\n    ) external view;\r\n\r\n    function verifyClaimMerkleProof(\r\n        uint256 _conditionId,\r\n        address _claimer,\r\n        uint256 _tokenId,\r\n        uint256 _quantity,\r\n        bytes32[] memory _proofs,\r\n        uint256 _proofMaxQuantityPerTransaction\r\n    ) external view returns (bool validMerkleProof, uint256 merkleProofIndex);\r\n\r\n    function walletClaimCount(uint256, address) external view returns (uint256);\r\n}\r\n\r\ninterface IDropClaimCondition {\r\n    struct ClaimCondition {\r\n        uint256 startTimestamp;\r\n        uint256 maxClaimableSupply;\r\n        uint256 supplyClaimed;\r\n        uint256 quantityLimitPerTransaction;\r\n        uint256 waitTimeInSecondsBetweenClaims;\r\n        bytes32 merkleRoot;\r\n        uint256 pricePerToken;\r\n        address currency;\r\n    }\r\n}\r\n"
45     }
46   },
47   "settings": {
48     "optimizer": {
49       "enabled": true,
50       "runs": 200
51     },
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     },
64     "metadata": {
65       "useLiteralContent": true
66     },
67     "libraries": {}
68   }
69 }}