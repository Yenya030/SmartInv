1 {{
2   "language": "Solidity",
3   "sources": {
4     "siren/contracts/contracts/SirenAirDrop_online/MicDollAirDrop.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\nimport './IERC721MicDollFreeMint.sol';\n\ncontract MicDollAirdrop is Pausable {\n  uint constant  public totalAirDropMicDoll = 5000;\n  address public micDollContractAdress;\n  address public operator;\n  uint public micDollClaimedCount;\n  mapping(address => bool) public recipientsPhase1;\n  mapping(address => bool) public recipientsPhase2;\n\n  event claimedInfo(address indexed account, uint indexed tokenId);\n  event OperatorTransferred(address indexed oldOperator, address indexed newOperator);\n\n  constructor() {\n    operator = msg.sender;\n    micDollContractAdress = address(0);\n    micDollClaimedCount = 0;\n    _pause();\n  }\n\n\n  //must initialize MicDoll address firstly before tranfer micdoll into this airdrop contract\n  function initMicDollContractAddress(address _micDollContractAddress) external {\n    require(msg.sender == operator, 'only operator');\n    require(micDollContractAdress  == address(0), 'MicDoll address have been initialized');\n    micDollContractAdress=_micDollContractAddress;\n  }\n\n  //add user into RecipientsPhase1 list\n  function addRecipientsPhase1(address[] memory _recipientsPhase1) external {\n    require(msg.sender == operator, 'only operator');\n    for(uint i = 0; i < _recipientsPhase1.length; i++) {\n      recipientsPhase1[_recipientsPhase1[i]] = true;\n    }\n  }\n\n  //remove user from RecipientsPhase1 list\n  function removeRecipientsPhase1(address[] memory _recipientsPhase1) external {\n    require(msg.sender == operator, 'only operator');\n    for(uint i = 0; i < _recipientsPhase1.length; i++) {\n      recipientsPhase1[_recipientsPhase1[i]] = false;\n    }\n  }\n\n  //add user into RecipientsPhase2 list\n    function addRecipientsPhase2(address[] memory _recipientsPhase2) external {\n    require(msg.sender == operator, 'only operator');\n    for(uint i = 0; i < _recipientsPhase2.length; i++) {\n      recipientsPhase2[_recipientsPhase2[i]] = true;\n    }\n  }\n\n  //remove user from RecipientsPhase2 list\n  function removeRecipientsPhase2(address[] memory _recipientsPhase2) external {\n    require(msg.sender == operator, 'only operator');\n    for(uint i = 0; i < _recipientsPhase2.length; i++) {\n      recipientsPhase2[_recipientsPhase2[i]] = false;\n    }\n  }\n  \n  //get the Remainder DropNum which can be claimed from now\n  function getMicDollRemainCount() external view returns (uint){\n    if(micDollContractAdress == address(0)){\n      return 0;\n    } else {\n      return totalAirDropMicDoll - micDollClaimedCount;\n    }\n  }\n\n\n  //claim MicDoll\n  function claim() external whenNotPaused returns(uint){\n    require(msg.sender.code.length == 0, \"only EOA allowed\");\n    require(micDollContractAdress  != address(0), 'MicDoll address have not  been initialized by operator');\n    require(totalAirDropMicDoll - micDollClaimedCount > 0, 'There are no airdrop micdoll is available now');\n\n    if(micDollClaimedCount < 4000){\n      require(recipientsPhase1[msg.sender] == true, 'recipient is not in the whitelist');\n      recipientsPhase1[msg.sender] = false;\n    } else {\n      require(recipientsPhase2[msg.sender] == true, 'recipient is not in the whitelist');\n      recipientsPhase2[msg.sender] = false;\n    }\n\n    uint tokenId = IERC721MicDollFreeMint(micDollContractAdress).freemint(msg.sender);\n    emit claimedInfo(msg.sender,tokenId);\n    micDollClaimedCount++;\n\n    if(micDollClaimedCount==4000){\n      _pause();\n    }\n    return tokenId;\n  }\n  \n  //transfer operator\n  function transferOperator(address newOperator) public {\n      require(msg.sender == operator, 'only operator');\n      require(newOperator != address(0), \"new newOperator is the zero address\");\n      address oldOperator = operator;\n      operator = newOperator;\n      emit OperatorTransferred(oldOperator, newOperator);\n  }\n\n  //stop airdrop claim\n  function pause() public {\n    require(msg.sender == operator, 'only operator');\n    _pause();\n  }\n\n  //start airdrop claim\n  function unpause() public {\n    require(msg.sender == operator, 'only operator');\n    _unpause();\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n}"
6     },
7     "siren/contracts/contracts/SirenAirDrop_online/IERC721MicDollFreeMint.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MicDollFreeMint is IERC721Enumerable {\n\n    function freemint(address to) external returns (uint256);\n\n}"
9     },
10     "@openzeppelin/contracts/security/Pausable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
18     },
19     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
21     },
22     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
24     },
25     "@openzeppelin/contracts/utils/Context.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": false,
32       "runs": 200
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "abi"
40         ]
41       }
42     }
43   }
44 }}