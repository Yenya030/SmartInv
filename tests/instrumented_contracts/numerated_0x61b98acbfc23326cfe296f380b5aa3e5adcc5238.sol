1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/NinfaFactory.sol": {
5       "content": "/*----------------------------------------------------------*|\n|*          ███    ██ ██ ███    ██ ███████  █████           *|\n|*          ████   ██ ██ ████   ██ ██      ██   ██          *|\n|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|\n|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|\n|*          ██   ████ ██ ██   ████ ██      ██   ██          *|\n|*----------------------------------------------------------*/\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./proxy/Clones.sol\";\nimport \"./access/AccessControl.sol\";\n\n/*************************************************************\n * @title NinfaFactory                                       *\n *                                                           *\n * @notice Clone factory pattern contract                    *\n *                                                           *\n * @custom:security-contact tech@ninfa.io                    *\n ************************************************************/\n\ncontract NinfaFactory is AccessControl {\n    using Clones for address;\n\n    bytes32 private constant MINTER_ROLE =\n        0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; // keccak256(\"MINTER_ROLE\"); one or more smart contracts allowed to call the mint function, eg. the Marketplace contract\n\n    bytes32 private constant CURATOR_ROLE =\n        0x850d585eb7f024ccee5e68e55f2c26cc72e1e6ee456acf62135757a5eb9d4a10; // keccak256(\"CURATOR_ROLE\"); one or more smart contracts allowed to call the clone function, eg. the Marketplace contract\n\n    mapping(address => bool) private _instances; // a mapping that contains all ERC1155 cloneed _instances address. Use events for enumerating clones, this mapping is only used for access control in extists()\n    mapping(address => bool) private _collectionsWhitelist;\n    mapping(address => bool) private _contractsWhitelist;\n\n    /**\n     * @param data if ERC-721 `abi.encodePacked(_ethUnitPrice, _commissionBps, _commissionReceiver)` see {NinfaMarketplace-onErc721Received}\n     * @param data if ERC-1155 `abi.encodePacked(_orderId, _ethUnitPrice, _commissionBps, _commissionReceiver)` see {NinfaMarketplace-onErc1155Received}\n     * @param data contains the address of the clonePaymentSplitter to be cloneed therefore clonePaymentSplitter deterministic MUST be used in order to predict its address\n     */\n    struct _Order {\n        address collection;\n        uint256 tokenId;\n        uint256 ethUnitPrice;\n        uint256 erc1155Amount;\n        address commissionReceiver;\n        bytes data;\n    }\n\n    event NewClone(address master, address instance, address owner); // owner is needed in order to keep a local database of owners to instance addresses; this avoids keeping track of them on-chain via a mapping\n\n    /**\n     * @param _salt _salt is a random number of our choice. generated with https://web3js.readthedocs.io/en/v1.2.11/web3-utils.html#randomhex\n     * _salt could also be dynamically calculated in order to avoid duplicate clones and for a way of finding predictable clones if salt the parameters are known, for example:\n     * `address _clone = erc1155Minter.cloneDeterministic(†bytes32(keccak256(abi.encode(_name, _symbol, _msgSender))));`\n     * @dev \"Using the same implementation and salt multiple time will revert, since the clones cannot be cloneed twice at the same address.\" - https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones-cloneDeterministic-address-bytes32-\n     * @param _master MUST be one of this factory's whhitelisted collections\n     *\n     */\n    function cloneCollection(\n        address _master,\n        bytes32 _salt,\n        bytes calldata _data\n    ) public returns (address clone_) {\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        require(\n            _collectionsWhitelist[_master] == true,\n            \"Collection not whitelisted\"\n        );\n\n        clone_ = _master.cloneDeterministic(_salt);\n\n        (bool success, ) = clone_.call(\n            abi.encodeWithSelector(\n                0x439fab91, // bytes4(keccak256('initialize(bytes)')) == 0x439fab91\n                _data\n            )\n        );\n        require(success);\n\n        _instances[clone_] = true;\n\n        emit NewClone(_master, clone_, msg.sender);\n    }\n\n    /**\n     * @notice the only difference between clonePaymentSplitter and cloneCollection is that the former does not require `msg.sender` to have `MINTER_ROLE`\n     * @param _salt _salt is a random number of our choice. generated with https://web3js.readthedocs.io/en/v1.2.11/web3-utils.html#randomhex\n     * _salt could also be dynamically calculated in order to avoid duplicate clones and for a way of finding predictable clones if salt the parameters are known, for example:\n     * `address _clone = erc1155Minter.cloneDeterministic(†bytes32(keccak256(abi.encode(_name, _symbol, _msgSender))));`\n     * @dev \"Using the same implementation and salt multiple time will revert, since the clones cannot be cloneed twice at the same address.\" - https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones-cloneDeterministic-address-bytes32-\n     * @param _master MUST be one of this factory's whitelisted collections\n     *\n     */\n    function clonePaymentSplitter(\n        address _master,\n        bytes32 _salt,\n        bytes calldata _data\n    ) public returns (address clone_) {\n        require(_contractsWhitelist[_master] == true);\n\n        clone_ = _master.cloneDeterministic(_salt);\n\n        (bool success, ) = clone_.call(\n            abi.encodeWithSelector(\n                0x439fab91, // bytes4(keccak256('initialize(bytes)')) == 0x439fab91\n                _data\n            )\n        );\n        require(success);\n\n        emit NewClone(_master, clone_, msg.sender);\n    }\n\n    /**\n     * @dev this function should only be called if minting an ERC1155 AND transfering it to a gallery, while also setting the royalty recipient to an address different from the artist's own.\n     *\n     * Require:\n     *\n     * - `_royaltyReceivers[]` must contain at least 2 addresses, if more than 1 address is specified a payment splitter contract is deployed and used in order to receive royalty payments.\n     * - caller must be collection owner/artist\n     *\n     */\n    function cloneCollectionCloneSplitter(\n        bytes calldata _splitterData,\n        bytes calldata _collectionData,\n        address _splitterMaster,\n        address _collectionMaster,\n        bytes32 _salt\n    ) external {\n        clonePaymentSplitter(_splitterMaster, _salt, _splitterData);\n\n        cloneCollection(_collectionMaster, _salt, _collectionData);\n    }\n\n    function exists(address _instance) external view returns (bool) {\n        return _instances[_instance];\n    }\n\n    function whitelistCollection(\n        address _master,\n        bool _isWhitelisted\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isContract(_master);\n        _collectionsWhitelist[_master] = _isWhitelisted;\n    }\n\n    function whitelistPaymentSplitter(\n        address _master,\n        bool _isWhitelisted\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _isContract(_master);\n        _contractsWhitelist[_master] = _isWhitelisted;\n    }\n\n    function predictDeterministicAddress(\n        address _master,\n        uint256 _salt\n    ) external view returns (address predicted) {\n        predicted = Clones.predictDeterministicAddress(_master, bytes32(_salt));\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `_isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function _isContract(address _account) private view {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        assembly {\n            size := extcodesize(_account)\n        }\n        require(size > 0);\n    }\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setRoleAdmin(MINTER_ROLE, CURATOR_ROLE);\n    }\n}\n"
6     },
7     "/contracts/utils/Strings.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
9     },
10     "/contracts/proxy/Clones.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000\n            )\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
12     },
13     "/contracts/access/AccessControl.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity 0.8.17;\n\nimport \"../utils/Strings.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external {\n        require(\n            account == msg.sender,\n            \"AccessControl: can only renounce roles for self\"\n        );\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}\n"
15     }
16   },
17   "settings": {
18     "remappings": [],
19     "optimizer": {
20       "enabled": false,
21       "runs": 200
22     },
23     "evmVersion": "london",
24     "libraries": {},
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     }
37   }
38 }}