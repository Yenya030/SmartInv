1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/TrainingGround.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {Portal} from \"./Portal.sol\";\n\ninterface ILegionFighter {\n    function isCore(uint256 tokenId) external view returns (bool, uint256);\n\n    function Equipped(uint256 tokenId) external view returns (uint8);\n}\n\ncontract TrainingGround is Portal {\n    bool public trainingActive = false;\n\n    struct Permission {\n        uint8 allowLevel;\n        uint248 index;\n    }\n\n    mapping(address => Permission) allowedCollections; // collection address => Permission struct\n    mapping(uint256 => address) allowedCollectionsLookup; // allowedCollections index => collection address (reverse lookup)\n    uint256 allowedCollectionsCount = 0;\n\n    struct State {\n        uint8 status; // 0 or 1 - Boolean for whether currently training\n        uint8 programme; // Programme Id\n        uint208 progress; // Progress (104 x 2 bits)\n        uint32 startBlock; // Block started training in current programme\n    }\n\n    mapping(uint256 => uint32[3]) public durationsByProgramme; // programme id => durations[]\n    mapping(uint256 => uint256) public participantsByProgramme; // programme id => count of participants\n    uint256 public programmesCount = 0;\n\n    mapping(uint256 => State) stateByMetaToken; // metaToken => State struct\n\n    event NewProgramme(uint8 indexed programme, uint32[3] durations);\n    event StartTraining(uint256 indexed metaToken, uint8 indexed programme, uint8 level);\n    event Claim(uint256 indexed metaToken, uint8 indexed programme, uint8 level);\n\n    constructor(address jumpPortAddress) Portal(jumpPortAddress) {}\n\n    /* Helper / View functions */\n\n    /**\n     * @dev Get a metaToken (a unique id representing a specific tokenId in a specific collection)\n     * @param tokenAddress the collection contract address\n     * @param tokenId the fighter tokenId\n     */\n    function getMetaToken(address tokenAddress, uint256 tokenId) public view returns (uint256 metaToken) {\n        uint256 tokenAddressIndex = uint256(allowedCollections[tokenAddress].index);\n        metaToken = (tokenAddressIndex << 240) | tokenId;\n    }\n\n    /**\n     * @dev Get the contract address and tokenId of a given metaToken\n     * @param metaToken a unique id representing a specific tokenId in a specific collection\n     */\n    function getTokenDetails(uint256 metaToken) public view returns (address tokenAddress, uint256 tokenId) {\n        uint256 tokenAddressIndex = metaToken >> 240;\n        tokenAddress = allowedCollectionsLookup[tokenAddressIndex];\n        tokenId = metaToken & 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    /**\n     * @dev Check whether a given collection address is allowed into Training Ground\n     */\n    function isAllowed(address tokenAddress) external view returns (bool allowed) {\n        return allowedCollections[tokenAddress].allowLevel > 0;\n    }\n\n    /**\n     * @dev Check whether a given fighter is currently training (by metaToken)\n     */\n    function isTraining(uint256 metaToken) public view returns (bool training) {\n        return stateByMetaToken[metaToken].status > 0;\n    }\n\n    /**\n     * @dev Check whether a given fighter is currently training (by contract address and tokenId)\n     */\n    function isTraining(address tokenAddress, uint256 tokenId) public view returns (bool training) {\n        return isTraining(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /**\n     * @dev Get the full progress (represented by a uint208) of a given fighter (by metaToken)\n     */\n    function getFullProgress(uint256 metaToken) public view returns (uint208 progress) {\n        return stateByMetaToken[metaToken].progress;\n    }\n\n    /**\n     * @dev Get the full progress (represented by a uint208) of a given fighter (by contract address and tokenId)\n     */\n    function getFullProgress(address tokenAddress, uint256 tokenId) public view returns (uint208 progress) {\n        return getFullProgress(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /**\n     * @dev Get a count of each level achieved for a given fighter (by metaToken)\n     * Returns level counts as named Taunts, Fighting styles and Combos\n     */\n    function getSkillCounts(uint256 metaToken)\n        public\n        view\n        returns (\n            uint256 taunts,\n            uint256 styles,\n            uint256 combos\n        )\n    {\n        unchecked {\n            State storage state = stateByMetaToken[metaToken];\n\n            for (uint8 i = 1; i <= programmesCount; i++) {\n                uint256 level = uint8(state.progress >> (208 - (i * 2))) & 3;\n\n                if (level >= 1) {\n                    taunts++;\n                }\n                if (level >= 2) {\n                    styles++;\n                }\n                if (level == 3) {\n                    combos++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get a count of each level achieved for a given fighter (by contract address and tokenId)\n     * Returns level counts as named Taunts, Fighting styles and Combos\n     */\n    function getSkillCounts(address tokenAddress, uint256 tokenId)\n        public\n        view\n        returns (\n            uint256 taunts,\n            uint256 styles,\n            uint256 combos\n        )\n    {\n        return getSkillCounts(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /**\n     * @dev Get the status of a fighter during training in their current programme (by metaToken)\n     * Returns the current programme id, the block they started and the duration\n     */\n    function getTrainingStatus(uint256 metaToken)\n        public\n        view\n        returns (\n            uint8 programme,\n            uint32 startBlock,\n            uint32 duration\n        )\n    {\n        require(stateByMetaToken[metaToken].status > 0, \"Token is not training\");\n\n        State storage state = stateByMetaToken[metaToken];\n        programme = state.programme;\n        startBlock = state.startBlock;\n        duration = uint32(block.number - uint256(state.startBlock));\n    }\n\n    /**\n     * @dev Get the status of a fighter during training in their current programme (by contract address and tokenId)\n     * Returns the current programme id, the block they started and the duration\n     */\n    function getTrainingStatus(address tokenAddress, uint256 tokenId)\n        public\n        view\n        returns (\n            uint8 programme,\n            uint32 startBlock,\n            uint32 duration\n        )\n    {\n        return getTrainingStatus(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /**\n     * @dev Get the current level achieved by a fighter in their current programme (by metaToken)\n     */\n    function getCurrentLevel(uint256 metaToken) public view returns (uint8 level) {\n        unchecked {\n            (uint8 programme, , uint32 blocksDuration) = getTrainingStatus(metaToken);\n            uint32[3] storage durations = durationsByProgramme[programme];\n\n            if (durations[2] <= blocksDuration) {\n                return 3;\n            } else if (durations[1] <= blocksDuration) {\n                return 2;\n            } else if (durations[0] <= blocksDuration) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * @dev Get the current level achieved by a fighter in their current programme (by contract address and tokenId)\n     */\n    function getCurrentLevel(address tokenAddress, uint256 tokenId) public view returns (uint8 level) {\n        level = getCurrentLevel(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /**\n     * @dev Get the level claimed by a fighter in a given programme (by metaToken)\n     */\n    function getClaimedLevel(uint256 metaToken, uint8 programme) public view returns (uint8 level) {\n        State storage state = stateByMetaToken[metaToken];\n        level = uint8(state.progress >> (208 - (programme * 2))) & 3;\n    }\n\n    /**\n     * @dev Get the level claimed by a fighter in a given programme (by contract address and tokenId)\n     */\n    function getClaimedLevel(\n        address tokenAddress,\n        uint256 tokenId,\n        uint8 programme\n    ) public view returns (uint8 level) {\n        return getClaimedLevel(getMetaToken(tokenAddress, tokenId), programme);\n    }\n\n    /* Programme actions */\n\n    /**\n     * @dev Internal helper function used for starting a fighter on a new programme\n     */\n    function _startProgramme(uint256 metaToken, uint8 programme) internal {\n        State storage state = stateByMetaToken[metaToken];\n        uint8 startLevel = getClaimedLevel(metaToken, programme);\n\n        require(startLevel < 3, \"Programme already completed\");\n\n        state.programme = programme;\n\n        unchecked {\n            state.startBlock = uint32(block.number);\n\n            if (startLevel > 0) {\n                uint32[3] storage durations = durationsByProgramme[programme];\n                state.startBlock = uint32(block.number) - durations[startLevel - 1];\n            }\n\n            participantsByProgramme[programme]++;\n        }\n\n        emit StartTraining(metaToken, programme, startLevel);\n    }\n\n    /**\n     * @dev Join a fighter onto a training programme\n     * @param tokenAddress the collection contract address\n     * @param tokenId the fighter tokenId\n     * @param programme the id of the programme to join\n     */\n    function joinProgramme(\n        address tokenAddress,\n        uint256 tokenId,\n        uint8 programme\n    ) public isActive onlyOperator(tokenAddress, tokenId) tokenAllowed(tokenAddress, tokenId) {\n        require(programme > 0 && programme <= programmesCount, \"Programme does not exist\");\n\n        uint256 metaToken = getMetaToken(tokenAddress, tokenId);\n        State storage state = stateByMetaToken[metaToken];\n\n        require(state.status == 0, \"Already training\");\n\n        _startProgramme(metaToken, programme);\n        state.status = 1;\n\n        JumpPort.lockToken(tokenAddress, tokenId);\n    }\n\n    /**\n     * @dev Switch a fighter onto a different training programme\n     * @param tokenAddress the collection contract address\n     * @param tokenId the fighter tokenId\n     * @param programme the id of the programme to join\n     */\n    function switchProgramme(\n        address tokenAddress,\n        uint256 tokenId,\n        uint8 programme\n    ) public isActive onlyOperator(tokenAddress, tokenId) {\n        require(allowedCollections[tokenAddress].allowLevel > 0, \"Token not allowed\");\n        require(programme > 0 && programme <= programmesCount, \"Programme does not exist\");\n\n        uint256 metaToken = getMetaToken(tokenAddress, tokenId);\n        State storage state = stateByMetaToken[metaToken];\n        uint8 currentProgramme = state.programme;\n\n        require(state.status == 1, \"Token is not training\");\n        require(currentProgramme != programme, \"Token is already in the programme\");\n\n        claimLevel(metaToken);\n\n        participantsByProgramme[currentProgramme]--;\n\n        _startProgramme(metaToken, programme);\n    }\n\n    /**\n     * @dev Remove a fighter from their current programme\n     * @param tokenAddress the collection contract address\n     * @param tokenId the fighter tokenId\n     */\n    function leaveCurrentProgramme(address tokenAddress, uint256 tokenId) public onlyOperator(tokenAddress, tokenId) {\n        uint256 metaToken = getMetaToken(tokenAddress, tokenId);\n        State storage state = stateByMetaToken[metaToken];\n\n        require(state.status == 1, \"Token is not training\");\n\n        claimLevel(metaToken);\n\n        participantsByProgramme[state.programme]--;\n\n        state.status = 0;\n        state.programme = 0;\n\n        JumpPort.unlockToken(tokenAddress, tokenId);\n    }\n\n    /**\n     * @dev Claim a level achieved for a given fighter in their current programme (by metaToken)\n     * This function is public so can be called anytime by anyone if they wish to pay the gas\n     */\n    function claimLevel(uint256 metaToken) public {\n        State storage state = stateByMetaToken[metaToken];\n        uint8 currentProgramme = state.programme;\n\n        uint8 claimedLevel = getClaimedLevel(metaToken, currentProgramme);\n        uint8 currentLevel = getCurrentLevel(metaToken);\n\n        if (currentLevel > claimedLevel) {\n            uint208 mask = uint208(claimedLevel ^ currentLevel) << (208 - currentProgramme * 2);\n            state.progress = (state.progress ^ mask);\n            emit Claim(metaToken, currentProgramme, currentLevel);\n        }\n    }\n\n    /**\n     * @dev Claim a level achieved for a given fighter in their current programme (by contract address and tokenId)\n     * This function is public so can be called anytime by anyone if they wish to pay the gas\n     */\n    function claimLevel(address tokenAddress, uint256 tokenId) public {\n        claimLevel(getMetaToken(tokenAddress, tokenId));\n    }\n\n    /* Modifiers */\n\n    /**\n     * @dev Prevent execution if training is not currently active\n     */\n    modifier isActive() {\n        require(trainingActive == true, \"Training not active\");\n        _;\n    }\n\n    /**\n     * @dev Prevent execution if the specified token is not in the JumpPort or msg.sender is not owner or approved\n     */\n    modifier onlyOperator(address tokenAddress, uint256 tokenId) {\n        require(JumpPort.isDeposited(tokenAddress, tokenId) == true, \"Token not in JumpPort\");\n        address tokenOwner = JumpPort.ownerOf(tokenAddress, tokenId);\n        require(tokenOwner == msg.sender || JumpPort.getApproved(tokenAddress, tokenId) == msg.sender || JumpPort.isApprovedForAll(tokenOwner, msg.sender) == true, \"Not an operator of that token\");\n        _;\n    }\n\n    /**\n     * @dev Prevent execution if the Legion like fighter is a core or is not equipped\n     */\n    modifier tokenAllowed(address tokenAddress, uint256 tokenId) {\n        require(allowedCollections[tokenAddress].allowLevel > 0, \"Token not allowed\");\n        ILegionFighter LF = ILegionFighter(tokenAddress);\n        (bool core, ) = LF.isCore(tokenId);\n        require(core == false, \"Not a Legion Fighter\");\n        require(LF.Equipped(tokenId) > 0, \"Fighter not equipped\");\n        _;\n    }\n\n    /* Administration */\n\n    /**\n     * @dev Toggle training active state\n     * @param active desired state of training active (true/false)\n     */\n    function setTraining(bool active) external onlyRole(ADMIN_ROLE) {\n        trainingActive = active;\n    }\n\n    /**\n     * @dev Add a new token collection to the allowed list\n     * @param tokenAddress the collection contract address\n     */\n    function addAllowedCollection(address tokenAddress) external onlyRole(ADMIN_ROLE) {\n        require(allowedCollections[tokenAddress].index == 0, \"Collection permissions already exist\");\n\n        allowedCollectionsCount++;\n        allowedCollections[tokenAddress] = Permission(1, uint248(allowedCollectionsCount));\n        allowedCollectionsLookup[allowedCollectionsCount] = tokenAddress;\n    }\n\n    /**\n     * @dev Update a token collections permission level\n     * @param tokenAddress the collection contract address\n     * @param allowLevel an integer (0-255) for allowed permission level. Anything greater than 0 is allowed.\n     */\n    function updateAllowedCollection(address tokenAddress, uint8 allowLevel) external onlyRole(ADMIN_ROLE) {\n        require(allowedCollections[tokenAddress].index > 0, \"Collection permissions do not exist\");\n\n        allowedCollections[tokenAddress].allowLevel = allowLevel;\n    }\n\n    /**\n     * @dev Add a new programme with associated level durations\n     * @param durations an array of block heights for each level duration\n     */\n    function addProgramme(uint32[3] calldata durations) public onlyRole(ADMIN_ROLE) {\n        require(durations[1] > durations[0] && durations[2] > durations[1], \"Durations not in ascending order\");\n        require(programmesCount < 104, \"Max programmes exist\");\n\n        programmesCount++;\n        durationsByProgramme[programmesCount] = durations;\n        emit NewProgramme(uint8(programmesCount), durations);\n    }\n\n    /**\n     * @dev Add a batch of new programmes with associated level durations\n     * @param programmes an array of programme duration arrays (block heights for each level duration)\n     */\n    function addProgrammes(uint32[3][] calldata programmes) external onlyRole(ADMIN_ROLE) {\n        for (uint8 i = 0; i < programmes.length; i++) {\n            addProgramme(programmes[i]);\n        }\n    }\n\n    /**\n     * @dev Update an existing programmes level durations\n     * @param programme the id of the programme\n     * @param durations an array of block heights for each level duration\n     */\n    function updateProgramme(uint8 programme, uint32[3] calldata durations) external onlyRole(ADMIN_ROLE) {\n        require(programme > 0 && programme <= programmesCount, \"Programme does not exist\");\n        require(durations[1] > durations[0] && durations[2] > durations[1], \"Durations not in ascending order\");\n\n        durationsByProgramme[programme] = durations;\n    }\n\n    /**\n     * @dev Eject a fighter from their current programme\n     * @param tokenAddress the collection contract address\n     * @param tokenId the fighter tokenId\n     */\n    function ejectFighter(address tokenAddress, uint256 tokenId) external onlyRole(ADMIN_ROLE) {\n        uint256 metaToken = getMetaToken(tokenAddress, tokenId);\n        State storage state = stateByMetaToken[metaToken];\n\n        require(state.status == 1, \"Token is not training\");\n\n        participantsByProgramme[state.programme]--;\n\n        state.status = 0;\n        state.programme = 0;\n\n        JumpPort.unlockToken(tokenAddress, tokenId);\n    }\n}\n"
6     },
7     "contracts/Portal.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {OwnableBase} from \"./OwnableBase.sol\";\n\ninterface IJumpPort {\n    function ownerOf(address tokenAddress, uint256 tokenId) external view returns (address owner);\n\n    function isDeposited(address tokenAddress, uint256 tokenId) external view returns (bool);\n\n    function getApproved(address tokenAddress, uint256 tokenId) external view returns (address copilot);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function lockToken(address tokenAddress, uint256 tokenId) external;\n\n    function unlockToken(address tokenAddress, uint256 tokenId) external;\n\n    function unlockAllTokens(bool isOverridden) external;\n\n    function blockExecution(bool isBlocked) external;\n}\n\nabstract contract Portal is OwnableBase {\n    IJumpPort public JumpPort;\n    bytes32 public constant UNLOCK_ROLE = keccak256(\"UNLOCK_ROLE\");\n\n    constructor(address jumpPortAddress) {\n        JumpPort = IJumpPort(jumpPortAddress);\n    }\n\n    /**\n     * @dev Allow current administrators to be able to grant/revoke unlock role to other addresses.\n     */\n    function setUnlockRole(address account, bool canUnlock) public onlyRole(ADMIN_ROLE) {\n        roles[UNLOCK_ROLE][account] = canUnlock;\n        emit RoleChange(UNLOCK_ROLE, account, canUnlock, msg.sender);\n    }\n\n    /**\n     * @dev Mark locks held by this portal as void or not.\n     * Allows for portals to have a degree of self-governance; if the administrator(s) of a portal\n     * realize something is wrong and wish to allow all tokens locked by that portal as void, they're\n     * able to indicate that to the JumpPort, without needing to invlove JumpPort governance.\n     */\n    function unlockAllTokens(bool isOverridden) public onlyRole(ADMIN_ROLE) {\n        JumpPort.unlockAllTokens(isOverridden);\n    }\n\n    /**\n     * @dev Prevent this Portal from calling `executeAction` on the JumpPort.\n     * Intended to be called in the situation of a large failure of an individual Portal's operation,\n     * as a way for the Portal itself to indicate it has failed, and arbitrary contract calls should not\n     * be allowed to originate from it.\n     *\n     * This function only allows Portals to enable/disable their own execution right.\n     */\n    function blockExecution(bool isBlocked) public onlyRole(ADMIN_ROLE) {\n        JumpPort.blockExecution(isBlocked);\n    }\n}\n"
9     },
10     "contracts/OwnableBase.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\ninterface IReverseResolver {\n    function claim(address owner) external returns (bytes32);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IERC721 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface IDocumentationRepository {\n    function doc(address contractAddress)\n        external\n        view\n        returns (\n            string memory name,\n            string memory description,\n            string memory details\n        );\n}\n\nerror MissingRole(bytes32 role, address operator);\n\nabstract contract OwnableBase {\n    bytes32 public constant ADMIN_ROLE = 0x00;\n    mapping(bytes32 => mapping(address => bool)) internal roles; // role => operator => hasRole\n    mapping(bytes32 => uint256) internal validSignatures; // message hash => expiration block height\n    IDocumentationRepository public DocumentationRepository;\n\n    event RoleChange(bytes32 indexed role, address indexed account, bool indexed isGranted, address sender);\n\n    constructor() {\n        roles[ADMIN_ROLE][msg.sender] = true;\n    }\n\n    function doc()\n        public\n        view\n        returns (\n            string memory name,\n            string memory description,\n            string memory details\n        )\n    {\n        return DocumentationRepository.doc(address(this));\n    }\n\n    /**\n     * @dev See {ERC1271-isValidSignature}.\n     */\n    function isValidSignature(bytes32 hash, bytes memory) external view returns (bytes4 magicValue) {\n        if (validSignatures[hash] >= block.number) {\n            return 0x1626ba7e; // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    /**\n     * @dev Inspect whether a specific address has a specific role.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return roles[role][account];\n    }\n\n    /* Modifiers */\n\n    modifier onlyRole(bytes32 role) {\n        if (roles[role][msg.sender] != true) revert MissingRole(role, msg.sender);\n        _;\n    }\n\n    /* Administration */\n\n    /**\n     * @dev Allow current administrators to be able to grant/revoke admin role to other addresses.\n     */\n    function setAdmin(address account, bool isAdmin) public onlyRole(ADMIN_ROLE) {\n        roles[ADMIN_ROLE][account] = isAdmin;\n        emit RoleChange(ADMIN_ROLE, account, isAdmin, msg.sender);\n    }\n\n    /**\n     * @dev Claim ENS reverse-resolver rights for this contract.\n     * https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\n     */\n    function setReverseResolver(address registrar) public onlyRole(ADMIN_ROLE) {\n        IReverseResolver(registrar).claim(msg.sender);\n    }\n\n    /**\n     * @dev Update address for on-chain documentation lookup.\n     */\n    function setDocumentationRepository(address documentationAddress) public onlyRole(ADMIN_ROLE) {\n        DocumentationRepository = IDocumentationRepository(documentationAddress);\n    }\n\n    /**\n     * @dev Set a message as valid, to be queried by ERC1271 clients.\n     */\n    function markMessageSigned(bytes32 hash, uint256 expirationLength) public onlyRole(ADMIN_ROLE) {\n        validSignatures[hash] = block.number + expirationLength;\n    }\n\n    /**\n     * @dev Rescue ERC20 assets sent directly to this contract.\n     */\n    function withdrawForeignERC20(address tokenContract) public onlyRole(ADMIN_ROLE) {\n        IERC20 token = IERC20(tokenContract);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Rescue ERC721 assets sent directly to this contract.\n     */\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public virtual onlyRole(ADMIN_ROLE) {\n        IERC721(tokenContract).safeTransferFrom(address(this), msg.sender, tokenId);\n    }\n\n    function withdrawEth() public onlyRole(ADMIN_ROLE) {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": true,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     },
31     "libraries": {}
32   }
33 }}