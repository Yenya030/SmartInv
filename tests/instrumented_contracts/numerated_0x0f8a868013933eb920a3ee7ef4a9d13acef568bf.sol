1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 pragma solidity ^0.4.23;
20 
21 
22 /**
23  * @title ERC20Basic
24  * @dev Simpler version of ERC20 interface
25  * @dev see https://github.com/ethereum/EIPs/issues/179
26  */
27 contract ERC20Basic {
28   function totalSupply() public view returns (uint256);
29   function balanceOf(address who) public view returns (uint256);
30   function transfer(address to, uint256 value) public returns (bool);
31   event Transfer(address indexed from, address indexed to, uint256 value);
32 }
33 
34 
35 /**
36  * @title ERC20 interface
37  * @dev see https://github.com/ethereum/EIPs/issues/20
38  */
39 contract ERC20 is ERC20Basic {
40   function allowance(address owner, address spender)
41     public view returns (uint256);
42 
43   function transferFrom(address from, address to, uint256 value)
44     public returns (bool);
45 
46   function approve(address spender, uint256 value) public returns (bool);
47   event Approval(
48     address indexed owner,
49     address indexed spender,
50     uint256 value
51   );
52 }
53 
54 
55 
56 /**
57  * @title SafeMath
58  * @dev Math operations with safety checks that throw on error
59  */
60 library SafeMath {
61 
62   /**
63   * @dev Multiplies two numbers, throws on overflow.
64   */
65   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
66     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
67     // benefit is lost if 'b' is also tested.
68     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
69     if (a == 0) {
70       return 0;
71     }
72 
73     c = a * b;
74     assert(c / a == b);
75     return c;
76   }
77 
78   /**
79   * @dev Integer division of two numbers, truncating the quotient.
80   */
81   function div(uint256 a, uint256 b) internal pure returns (uint256) {
82     // assert(b > 0); // Solidity automatically throws when dividing by 0
83     // uint256 c = a / b;
84     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
85     return a / b;
86   }
87 
88   /**
89   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
90   */
91   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
92     assert(b <= a);
93     return a - b;
94   }
95 
96   /**
97   * @dev Adds two numbers, throws on overflow.
98   */
99   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
100     c = a + b;
101     assert(c >= a);
102     return c;
103   }
104 }
105 
106 
107 /**
108  * @title Crowdsale
109  * @dev Crowdsale is a base contract for managing a token crowdsale,
110  * allowing investors to purchase tokens with ether. This contract implements
111  * such functionality in its most fundamental form and can be extended to provide additional
112  * functionality and/or custom behavior.
113  * The external interface represents the basic interface for purchasing tokens, and conform
114  * the base architecture for crowdsales. They are *not* intended to be modified / overriden.
115  * The internal interface conforms the extensible and modifiable surface of crowdsales. Override
116  * the methods to add functionality. Consider using 'super' where appropiate to concatenate
117  * behavior.
118  */
119 contract Crowdsale {
120   using SafeMath for uint256;
121 
122   // The token being sold
123   ERC20 public token;
124 
125   // Address where funds are collected
126   address public wallet;
127 
128   // How many token units a buyer gets per wei.
129   // The rate is the conversion between wei and the smallest and indivisible token unit.
130   // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK
131   // 1 wei will give you 1 unit, or 0.001 TOK.
132   uint256 public rate;
133 
134   // Amount of wei raised
135   uint256 public weiRaised;
136 
137   /**
138    * Event for token purchase logging
139    * @param purchaser who paid for the tokens
140    * @param beneficiary who got the tokens
141    * @param value weis paid for purchase
142    * @param amount amount of tokens purchased
143    */
144   event TokenPurchase(
145     address indexed purchaser,
146     address indexed beneficiary,
147     uint256 value,
148     uint256 amount
149   );
150 
151   /**
152    * @param _rate Number of token units a buyer gets per wei
153    * @param _wallet Address where collected funds will be forwarded to
154    * @param _token Address of the token being sold
155    */
156   constructor(uint256 _rate, address _wallet, ERC20 _token) public {
157     require(_rate > 0);
158     require(_wallet != address(0));
159     require(_token != address(0));
160 
161     rate = _rate;
162     wallet = _wallet;
163     token = _token;
164   }
165 
166   // -----------------------------------------
167   // Crowdsale external interface
168   // -----------------------------------------
169 
170   /**
171    * @dev fallback function ***DO NOT OVERRIDE***
172    */
173   function () external payable {
174     buyTokens(msg.sender);
175   }
176 
177   /**
178    * @dev low level token purchase ***DO NOT OVERRIDE***
179    * @param _beneficiary Address performing the token purchase
180    */
181   function buyTokens(address _beneficiary) public payable {
182 
183     uint256 weiAmount = msg.value;
184     _preValidatePurchase(_beneficiary, weiAmount);
185 
186     // calculate token amount to be created
187     uint256 tokens = _getTokenAmount(weiAmount);
188 
189     // update state
190     weiRaised = weiRaised.add(weiAmount);
191 
192     _processPurchase(_beneficiary, tokens);
193     emit TokenPurchase(
194       msg.sender,
195       _beneficiary,
196       weiAmount,
197       tokens
198     );
199 
200     _updatePurchasingState(_beneficiary, weiAmount);
201 
202     _forwardFunds();
203     _postValidatePurchase(_beneficiary, weiAmount);
204   }
205 
206   // -----------------------------------------
207   // Internal interface (extensible)
208   // -----------------------------------------
209 
210   /**
211    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.
212    * @param _beneficiary Address performing the token purchase
213    * @param _weiAmount Value in wei involved in the purchase
214    */
215   function _preValidatePurchase(
216     address _beneficiary,
217     uint256 _weiAmount
218   )
219     internal
220   {
221     require(_beneficiary != address(0));
222     require(_weiAmount != 0);
223   }
224 
225   /**
226    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.
227    * @param _beneficiary Address performing the token purchase
228    * @param _weiAmount Value in wei involved in the purchase
229    */
230   function _postValidatePurchase(
231     address _beneficiary,
232     uint256 _weiAmount
233   )
234     internal
235   {
236     // optional override
237   }
238 
239   /**
240    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
241    * @param _beneficiary Address performing the token purchase
242    * @param _tokenAmount Number of tokens to be emitted
243    */
244   function _deliverTokens(
245     address _beneficiary,
246     uint256 _tokenAmount
247   )
248     internal
249   {
250     token.transfer(_beneficiary, _tokenAmount);
251   }
252 
253   /**
254    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.
255    * @param _beneficiary Address receiving the tokens
256    * @param _tokenAmount Number of tokens to be purchased
257    */
258   function _processPurchase(
259     address _beneficiary,
260     uint256 _tokenAmount
261   )
262     internal
263   {
264     _deliverTokens(_beneficiary, _tokenAmount);
265   }
266 
267   /**
268    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)
269    * @param _beneficiary Address receiving the tokens
270    * @param _weiAmount Value in wei involved in the purchase
271    */
272   function _updatePurchasingState(
273     address _beneficiary,
274     uint256 _weiAmount
275   )
276     internal
277   {
278     // optional override
279   }
280 
281   /**
282    * @dev Override to extend the way in which ether is converted to tokens.
283    * @param _weiAmount Value in wei to be converted into tokens
284    * @return Number of tokens that can be purchased with the specified _weiAmount
285    */
286   function _getTokenAmount(uint256 _weiAmount)
287     internal view returns (uint256)
288   {
289     return _weiAmount.mul(rate);
290   }
291 
292   /**
293    * @dev Determines how ETH is stored/forwarded on purchases.
294    */
295   function _forwardFunds() internal {
296     wallet.transfer(msg.value);
297   }
298 }
299 
300 
301 
302 /**
303  * @title Ownable
304  * @dev The Ownable contract has an owner address, and provides basic authorization control
305  * functions, this simplifies the implementation of "user permissions".
306  */
307 contract Ownable {
308   address public owner;
309 
310 
311   event OwnershipRenounced(address indexed previousOwner);
312   event OwnershipTransferred(
313     address indexed previousOwner,
314     address indexed newOwner
315   );
316 
317 
318   /**
319    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
320    * account.
321    */
322   constructor() public {
323     owner = msg.sender;
324   }
325 
326   /**
327    * @dev Throws if called by any account other than the owner.
328    */
329   modifier onlyOwner() {
330     require(msg.sender == owner);
331     _;
332   }
333 
334   /**
335    * @dev Allows the current owner to relinquish control of the contract.
336    */
337   function renounceOwnership() public onlyOwner {
338     emit OwnershipRenounced(owner);
339     owner = address(0);
340   }
341 
342   /**
343    * @dev Allows the current owner to transfer control of the contract to a newOwner.
344    * @param _newOwner The address to transfer ownership to.
345    */
346   function transferOwnership(address _newOwner) public onlyOwner {
347     _transferOwnership(_newOwner);
348   }
349 
350   /**
351    * @dev Transfers control of the contract to a newOwner.
352    * @param _newOwner The address to transfer ownership to.
353    */
354   function _transferOwnership(address _newOwner) internal {
355     require(_newOwner != address(0));
356     emit OwnershipTransferred(owner, _newOwner);
357     owner = _newOwner;
358   }
359 }
360 
361 
362 /**
363  * @title TimedCrowdsale
364  * @dev Crowdsale accepting contributions only within a time frame.
365  */
366 contract TimedCrowdsale is Crowdsale {
367   using SafeMath for uint256;
368 
369   uint256 public openingTime;
370   uint256 public closingTime;
371 
372   /**
373    * @dev Reverts if not in crowdsale time range.
374    */
375   modifier onlyWhileOpen {
376     // solium-disable-next-line security/no-block-members
377     require(block.timestamp >= openingTime && block.timestamp <= closingTime);
378     _;
379   }
380 
381   /**
382    * @dev Constructor, takes crowdsale opening and closing times.
383    * @param _openingTime Crowdsale opening time
384    * @param _closingTime Crowdsale closing time
385    */
386   constructor(uint256 _openingTime, uint256 _closingTime) public {
387     // solium-disable-next-line security/no-block-members
388     require(_openingTime >= block.timestamp);
389     require(_closingTime >= _openingTime);
390 
391     openingTime = _openingTime;
392     closingTime = _closingTime;
393   }
394 
395   /**
396    * @dev Checks whether the period in which the crowdsale is open has already elapsed.
397    * @return Whether crowdsale period has elapsed
398    */
399   function hasClosed() public view returns (bool) {
400     // solium-disable-next-line security/no-block-members
401     return block.timestamp > closingTime;
402   }
403 
404   /**
405    * @dev Extend parent behavior requiring to be within contributing period
406    * @param _beneficiary Token purchaser
407    * @param _weiAmount Amount of wei contributed
408    */
409   function _preValidatePurchase(
410     address _beneficiary,
411     uint256 _weiAmount
412   )
413     internal
414     onlyWhileOpen
415   {
416     super._preValidatePurchase(_beneficiary, _weiAmount);
417   }
418 
419 }
420 
421 
422 
423 /**
424  * @title Basic token
425  * @dev Basic version of StandardToken, with no allowances.
426  */
427 contract BasicToken is ERC20Basic {
428   using SafeMath for uint256;
429 
430   mapping(address => uint256) balances;
431 
432   uint256 totalSupply_;
433 
434   /**
435   * @dev total number of tokens in existence
436   */
437   function totalSupply() public view returns (uint256) {
438     return totalSupply_;
439   }
440 
441   /**
442   * @dev transfer token for a specified address
443   * @param _to The address to transfer to.
444   * @param _value The amount to be transferred.
445   */
446   function transfer(address _to, uint256 _value) public returns (bool) {
447     require(_to != address(0));
448     require(_value <= balances[msg.sender]);
449 
450     balances[msg.sender] = balances[msg.sender].sub(_value);
451     balances[_to] = balances[_to].add(_value);
452     emit Transfer(msg.sender, _to, _value);
453     return true;
454   }
455 
456   /**
457   * @dev Gets the balance of the specified address.
458   * @param _owner The address to query the the balance of.
459   * @return An uint256 representing the amount owned by the passed address.
460   */
461   function balanceOf(address _owner) public view returns (uint256) {
462     return balances[_owner];
463   }
464 
465 }
466 
467 
468 /**
469  * @title Standard ERC20 token
470  *
471  * @dev Implementation of the basic standard token.
472  * @dev https://github.com/ethereum/EIPs/issues/20
473  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
474  */
475 contract StandardToken is ERC20, BasicToken {
476 
477   mapping (address => mapping (address => uint256)) internal allowed;
478 
479 
480   /**
481    * @dev Transfer tokens from one address to another
482    * @param _from address The address which you want to send tokens from
483    * @param _to address The address which you want to transfer to
484    * @param _value uint256 the amount of tokens to be transferred
485    */
486   function transferFrom(
487     address _from,
488     address _to,
489     uint256 _value
490   )
491     public
492     returns (bool)
493   {
494     require(_to != address(0));
495     require(_value <= balances[_from]);
496     require(_value <= allowed[_from][msg.sender]);
497 
498     balances[_from] = balances[_from].sub(_value);
499     balances[_to] = balances[_to].add(_value);
500     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
501     emit Transfer(_from, _to, _value);
502     return true;
503   }
504 
505   /**
506    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
507    *
508    * Beware that changing an allowance with this method brings the risk that someone may use both the old
509    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
510    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
511    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
512    * @param _spender The address which will spend the funds.
513    * @param _value The amount of tokens to be spent.
514    */
515   function approve(address _spender, uint256 _value) public returns (bool) {
516     allowed[msg.sender][_spender] = _value;
517     emit Approval(msg.sender, _spender, _value);
518     return true;
519   }
520 
521   /**
522    * @dev Function to check the amount of tokens that an owner allowed to a spender.
523    * @param _owner address The address which owns the funds.
524    * @param _spender address The address which will spend the funds.
525    * @return A uint256 specifying the amount of tokens still available for the spender.
526    */
527   function allowance(
528     address _owner,
529     address _spender
530    )
531     public
532     view
533     returns (uint256)
534   {
535     return allowed[_owner][_spender];
536   }
537 
538   /**
539    * @dev Increase the amount of tokens that an owner allowed to a spender.
540    *
541    * approve should be called when allowed[_spender] == 0. To increment
542    * allowed value is better to use this function to avoid 2 calls (and wait until
543    * the first transaction is mined)
544    * From MonolithDAO Token.sol
545    * @param _spender The address which will spend the funds.
546    * @param _addedValue The amount of tokens to increase the allowance by.
547    */
548   function increaseApproval(
549     address _spender,
550     uint _addedValue
551   )
552     public
553     returns (bool)
554   {
555     allowed[msg.sender][_spender] = (
556       allowed[msg.sender][_spender].add(_addedValue));
557     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
558     return true;
559   }
560 
561   /**
562    * @dev Decrease the amount of tokens that an owner allowed to a spender.
563    *
564    * approve should be called when allowed[_spender] == 0. To decrement
565    * allowed value is better to use this function to avoid 2 calls (and wait until
566    * the first transaction is mined)
567    * From MonolithDAO Token.sol
568    * @param _spender The address which will spend the funds.
569    * @param _subtractedValue The amount of tokens to decrease the allowance by.
570    */
571   function decreaseApproval(
572     address _spender,
573     uint _subtractedValue
574   )
575     public
576     returns (bool)
577   {
578     uint oldValue = allowed[msg.sender][_spender];
579     if (_subtractedValue > oldValue) {
580       allowed[msg.sender][_spender] = 0;
581     } else {
582       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
583     }
584     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
585     return true;
586   }
587 
588 }
589 
590 
591 /**
592  * @title Mintable token
593  * @dev Simple ERC20 Token example, with mintable token creation
594  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
595  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
596  */
597 contract MintableToken is StandardToken, Ownable {
598   event Mint(address indexed to, uint256 amount);
599   event MintFinished();
600 
601   bool public mintingFinished = false;
602 
603 
604   modifier canMint() {
605     require(!mintingFinished);
606     _;
607   }
608 
609   modifier hasMintPermission() {
610     require(msg.sender == owner);
611     _;
612   }
613 
614   /**
615    * @dev Function to mint tokens
616    * @param _to The address that will receive the minted tokens.
617    * @param _amount The amount of tokens to mint.
618    * @return A boolean that indicates if the operation was successful.
619    */
620   function mint(
621     address _to,
622     uint256 _amount
623   )
624     hasMintPermission
625     canMint
626     public
627     returns (bool)
628   {
629     totalSupply_ = totalSupply_.add(_amount);
630     balances[_to] = balances[_to].add(_amount);
631     emit Mint(_to, _amount);
632     emit Transfer(address(0), _to, _amount);
633     return true;
634   }
635 
636   /**
637    * @dev Function to stop minting new tokens.
638    * @return True if the operation was successful.
639    */
640   function finishMinting() onlyOwner canMint public returns (bool) {
641     mintingFinished = true;
642     emit MintFinished();
643     return true;
644   }
645 }
646 
647 
648 contract FreezableToken is StandardToken {
649     // freezing chains
650     mapping (bytes32 => uint64) internal chains;
651     // freezing amounts for each chain
652     mapping (bytes32 => uint) internal freezings;
653     // total freezing balance per address
654     mapping (address => uint) internal freezingBalance;
655 
656     event Freezed(address indexed to, uint64 release, uint amount);
657     event Released(address indexed owner, uint amount);
658 
659     /**
660      * @dev Gets the balance of the specified address include freezing tokens.
661      * @param _owner The address to query the the balance of.
662      * @return An uint256 representing the amount owned by the passed address.
663      */
664     function balanceOf(address _owner) public view returns (uint256 balance) {
665         return super.balanceOf(_owner) + freezingBalance[_owner];
666     }
667 
668     /**
669      * @dev Gets the balance of the specified address without freezing tokens.
670      * @param _owner The address to query the the balance of.
671      * @return An uint256 representing the amount owned by the passed address.
672      */
673     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
674         return super.balanceOf(_owner);
675     }
676 
677     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
678         return freezingBalance[_owner];
679     }
680 
681     /**
682      * @dev gets freezing count
683      * @param _addr Address of freeze tokens owner.
684      */
685     function freezingCount(address _addr) public view returns (uint count) {
686         uint64 release = chains[toKey(_addr, 0)];
687         while (release != 0) {
688             count++;
689             release = chains[toKey(_addr, release)];
690         }
691     }
692 
693     /**
694      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
695      * @param _addr Address of freeze tokens owner.
696      * @param _index Freezing portion index. It ordered by release date descending.
697      */
698     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
699         for (uint i = 0; i < _index + 1; i++) {
700             _release = chains[toKey(_addr, _release)];
701             if (_release == 0) {
702                 return;
703             }
704         }
705         _balance = freezings[toKey(_addr, _release)];
706     }
707 
708     /**
709      * @dev freeze your tokens to the specified address.
710      *      Be careful, gas usage is not deterministic,
711      *      and depends on how many freezes _to address already has.
712      * @param _to Address to which token will be freeze.
713      * @param _amount Amount of token to freeze.
714      * @param _until Release date, must be in future.
715      */
716     function freezeTo(address _to, uint _amount, uint64 _until) public {
717         require(_to != address(0));
718         require(_amount <= balances[msg.sender]);
719 
720         balances[msg.sender] = balances[msg.sender].sub(_amount);
721 
722         bytes32 currentKey = toKey(_to, _until);
723         freezings[currentKey] = freezings[currentKey].add(_amount);
724         freezingBalance[_to] = freezingBalance[_to].add(_amount);
725 
726         freeze(_to, _until);
727         emit Transfer(msg.sender, _to, _amount);
728         emit Freezed(_to, _until, _amount);
729     }
730 
731     /**
732      * @dev release first available freezing tokens.
733      */
734     function releaseOnce() public {
735         bytes32 headKey = toKey(msg.sender, 0);
736         uint64 head = chains[headKey];
737         require(head != 0);
738         require(uint64(block.timestamp) > head);
739         bytes32 currentKey = toKey(msg.sender, head);
740 
741         uint64 next = chains[currentKey];
742 
743         uint amount = freezings[currentKey];
744         delete freezings[currentKey];
745 
746         balances[msg.sender] = balances[msg.sender].add(amount);
747         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
748 
749         if (next == 0) {
750             delete chains[headKey];
751         } else {
752             chains[headKey] = next;
753             delete chains[currentKey];
754         }
755         emit Released(msg.sender, amount);
756     }
757 
758     /**
759      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
760      * @return how many tokens was released
761      */
762     function releaseAll() public returns (uint tokens) {
763         uint release;
764         uint balance;
765         (release, balance) = getFreezing(msg.sender, 0);
766         while (release != 0 && block.timestamp > release) {
767             releaseOnce();
768             tokens += balance;
769             (release, balance) = getFreezing(msg.sender, 0);
770         }
771     }
772 
773     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
774         // WISH masc to increase entropy
775         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
776         assembly {
777             result := or(result, mul(_addr, 0x10000000000000000))
778             result := or(result, _release)
779         }
780     }
781 
782     function freeze(address _to, uint64 _until) internal {
783         require(_until > block.timestamp);
784         bytes32 key = toKey(_to, _until);
785         bytes32 parentKey = toKey(_to, uint64(0));
786         uint64 next = chains[parentKey];
787 
788         if (next == 0) {
789             chains[parentKey] = _until;
790             return;
791         }
792 
793         bytes32 nextKey = toKey(_to, next);
794         uint parent;
795 
796         while (next != 0 && _until > next) {
797             parent = next;
798             parentKey = nextKey;
799 
800             next = chains[nextKey];
801             nextKey = toKey(_to, next);
802         }
803 
804         if (_until == next) {
805             return;
806         }
807 
808         if (next != 0) {
809             chains[key] = next;
810         }
811 
812         chains[parentKey] = _until;
813     }
814 }
815 
816 
817 /**
818  * @title Burnable Token
819  * @dev Token that can be irreversibly burned (destroyed).
820  */
821 contract BurnableToken is BasicToken {
822 
823   event Burn(address indexed burner, uint256 value);
824 
825   /**
826    * @dev Burns a specific amount of tokens.
827    * @param _value The amount of token to be burned.
828    */
829   function burn(uint256 _value) public {
830     _burn(msg.sender, _value);
831   }
832 
833   function _burn(address _who, uint256 _value) internal {
834     require(_value <= balances[_who]);
835     // no need to require value <= totalSupply, since that would imply the
836     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
837 
838     balances[_who] = balances[_who].sub(_value);
839     totalSupply_ = totalSupply_.sub(_value);
840     emit Burn(_who, _value);
841     emit Transfer(_who, address(0), _value);
842   }
843 }
844 
845 
846 
847 /**
848  * @title Pausable
849  * @dev Base contract which allows children to implement an emergency stop mechanism.
850  */
851 contract Pausable is Ownable {
852   event Pause();
853   event Unpause();
854 
855   bool public paused = false;
856 
857 
858   /**
859    * @dev Modifier to make a function callable only when the contract is not paused.
860    */
861   modifier whenNotPaused() {
862     require(!paused);
863     _;
864   }
865 
866   /**
867    * @dev Modifier to make a function callable only when the contract is paused.
868    */
869   modifier whenPaused() {
870     require(paused);
871     _;
872   }
873 
874   /**
875    * @dev called by the owner to pause, triggers stopped state
876    */
877   function pause() onlyOwner whenNotPaused public {
878     paused = true;
879     emit Pause();
880   }
881 
882   /**
883    * @dev called by the owner to unpause, returns to normal state
884    */
885   function unpause() onlyOwner whenPaused public {
886     paused = false;
887     emit Unpause();
888   }
889 }
890 
891 
892 contract FreezableMintableToken is FreezableToken, MintableToken {
893     /**
894      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
895      *      Be careful, gas usage is not deterministic,
896      *      and depends on how many freezes _to address already has.
897      * @param _to Address to which token will be freeze.
898      * @param _amount Amount of token to mint and freeze.
899      * @param _until Release date, must be in future.
900      * @return A boolean that indicates if the operation was successful.
901      */
902     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
903         totalSupply_ = totalSupply_.add(_amount);
904 
905         bytes32 currentKey = toKey(_to, _until);
906         freezings[currentKey] = freezings[currentKey].add(_amount);
907         freezingBalance[_to] = freezingBalance[_to].add(_amount);
908 
909         freeze(_to, _until);
910         emit Mint(_to, _amount);
911         emit Freezed(_to, _until, _amount);
912         emit Transfer(msg.sender, _to, _amount);
913         return true;
914     }
915 }
916 
917 
918 
919 contract Consts {
920     uint public constant TOKEN_DECIMALS = 18;
921     uint8 public constant TOKEN_DECIMALS_UINT8 = 18;
922     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
923 
924     string public constant TOKEN_NAME = "PalladiumTokenMagic";
925     string public constant TOKEN_SYMBOL = "PTMX";
926     bool public constant PAUSED = true;
927     address public constant TARGET_USER = 0xdF15E9399B9F325D161c38F7f2aFd72C11a19500;
928     
929     uint public constant START_TIME = 1533081600;
930     
931     bool public constant CONTINUE_MINTING = true;
932 }
933 
934 
935 
936 
937 /**
938  * @title FinalizableCrowdsale
939  * @dev Extension of Crowdsale where an owner can do extra work
940  * after finishing.
941  */
942 contract FinalizableCrowdsale is TimedCrowdsale, Ownable {
943   using SafeMath for uint256;
944 
945   bool public isFinalized = false;
946 
947   event Finalized();
948 
949   /**
950    * @dev Must be called after crowdsale ends, to do some extra finalization
951    * work. Calls the contract's finalization function.
952    */
953   function finalize() onlyOwner public {
954     require(!isFinalized);
955     require(hasClosed());
956 
957     finalization();
958     emit Finalized();
959 
960     isFinalized = true;
961   }
962 
963   /**
964    * @dev Can be overridden to add finalization logic. The overriding function
965    * should call super.finalization() to ensure the chain of finalization is
966    * executed entirely.
967    */
968   function finalization() internal {
969   }
970 
971 }
972 
973 
974 /**
975  * @title CappedCrowdsale
976  * @dev Crowdsale with a limit for total contributions.
977  */
978 contract CappedCrowdsale is Crowdsale {
979   using SafeMath for uint256;
980 
981   uint256 public cap;
982 
983   /**
984    * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.
985    * @param _cap Max amount of wei to be contributed
986    */
987   constructor(uint256 _cap) public {
988     require(_cap > 0);
989     cap = _cap;
990   }
991 
992   /**
993    * @dev Checks whether the cap has been reached.
994    * @return Whether the cap was reached
995    */
996   function capReached() public view returns (bool) {
997     return weiRaised >= cap;
998   }
999 
1000   /**
1001    * @dev Extend parent behavior requiring purchase to respect the funding cap.
1002    * @param _beneficiary Token purchaser
1003    * @param _weiAmount Amount of wei contributed
1004    */
1005   function _preValidatePurchase(
1006     address _beneficiary,
1007     uint256 _weiAmount
1008   )
1009     internal
1010   {
1011     super._preValidatePurchase(_beneficiary, _weiAmount);
1012     require(weiRaised.add(_weiAmount) <= cap);
1013   }
1014 
1015 }
1016 
1017 
1018 /**
1019  * @title MintedCrowdsale
1020  * @dev Extension of Crowdsale contract whose tokens are minted in each purchase.
1021  * Token ownership should be transferred to MintedCrowdsale for minting.
1022  */
1023 contract MintedCrowdsale is Crowdsale {
1024 
1025   /**
1026    * @dev Overrides delivery by minting tokens upon purchase.
1027    * @param _beneficiary Token purchaser
1028    * @param _tokenAmount Number of tokens to be minted
1029    */
1030   function _deliverTokens(
1031     address _beneficiary,
1032     uint256 _tokenAmount
1033   )
1034     internal
1035   {
1036     require(MintableToken(token).mint(_beneficiary, _tokenAmount));
1037   }
1038 }
1039 
1040 
1041 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
1042     
1043 {
1044     
1045 
1046     function name() public pure returns (string _name) {
1047         return TOKEN_NAME;
1048     }
1049 
1050     function symbol() public pure returns (string _symbol) {
1051         return TOKEN_SYMBOL;
1052     }
1053 
1054     function decimals() public pure returns (uint8 _decimals) {
1055         return TOKEN_DECIMALS_UINT8;
1056     }
1057 
1058     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
1059         require(!paused);
1060         return super.transferFrom(_from, _to, _value);
1061     }
1062 
1063     function transfer(address _to, uint256 _value) public returns (bool _success) {
1064         require(!paused);
1065         return super.transfer(_to, _value);
1066     }
1067 
1068     
1069 }
1070 
1071 
1072 
1073 
1074 contract MainCrowdsale is Consts, FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale {
1075     function hasStarted() public view returns (bool) {
1076         return now >= openingTime;
1077     }
1078 
1079     function startTime() public view returns (uint256) {
1080         return openingTime;
1081     }
1082 
1083     function endTime() public view returns (uint256) {
1084         return closingTime;
1085     }
1086 
1087     function hasClosed() public view returns (bool) {
1088         return super.hasClosed() || capReached();
1089     }
1090 
1091     function hasEnded() public view returns (bool) {
1092         return hasClosed();
1093     }
1094 
1095     function finalization() internal {
1096         super.finalization();
1097 
1098         if (PAUSED) {
1099             MainToken(token).unpause();
1100         }
1101 
1102         if (!CONTINUE_MINTING) {
1103             require(MintableToken(token).finishMinting());
1104         }
1105 
1106         Ownable(token).transferOwnership(TARGET_USER);
1107     }
1108 
1109     /**
1110      * @dev Override to extend the way in which ether is converted to tokens.
1111      * @param _weiAmount Value in wei to be converted into tokens
1112      * @return Number of tokens that can be purchased with the specified _weiAmount
1113      */
1114     function _getTokenAmount(uint256 _weiAmount)
1115         internal view returns (uint256)
1116     {
1117         return _weiAmount.mul(rate).div(1 ether);
1118     }
1119 }
1120 
1121 
1122 
1123 contract Checkable {
1124     address private serviceAccount;
1125     /**
1126      * Flag means that contract accident already occurs.
1127      */
1128     bool private triggered = false;
1129 
1130     /**
1131      * Occurs when accident happened.
1132      */
1133     event Triggered(uint balance);
1134     /**
1135      * Occurs when check finished.
1136      * isAccident is accident occurred
1137      */
1138     event Checked(bool isAccident);
1139 
1140     constructor() public {
1141         serviceAccount = msg.sender;
1142     }
1143 
1144     /**
1145      * @dev Replace service account with new one.
1146      * @param _account Valid service account address.
1147      */
1148     function changeServiceAccount(address _account) public onlyService {
1149         require(_account != 0);
1150         serviceAccount = _account;
1151     }
1152 
1153     /**
1154      * @dev Is caller (sender) service account.
1155      */
1156     function isServiceAccount() public view returns (bool) {
1157         return msg.sender == serviceAccount;
1158     }
1159 
1160     /**
1161      * Public check method.
1162      */
1163     function check() public payable onlyService notTriggered {
1164         if (internalCheck()) {
1165             emit Triggered(address(this).balance);
1166             triggered = true;
1167             internalAction();
1168         }
1169     }
1170 
1171     /**
1172      * @dev Do inner check.
1173      * @return bool true of accident triggered, false otherwise.
1174      */
1175     function internalCheck() internal returns (bool);
1176 
1177     /**
1178      * @dev Do inner action if check was success.
1179      */
1180     function internalAction() internal;
1181 
1182     modifier onlyService {
1183         require(msg.sender == serviceAccount);
1184         _;
1185     }
1186 
1187     modifier notTriggered {
1188         require(!triggered);
1189         _;
1190     }
1191 }
1192 
1193 
1194 contract BonusableCrowdsale is Consts, Crowdsale {
1195     /**
1196      * @dev Override to extend the way in which ether is converted to tokens.
1197      * @param _weiAmount Value in wei to be converted into tokens
1198      * @return Number of tokens that can be purchased with the specified _weiAmount
1199      */
1200     function _getTokenAmount(uint256 _weiAmount)
1201         internal view returns (uint256)
1202     {
1203         uint256 bonusRate = getBonusRate(_weiAmount);
1204         return _weiAmount.mul(bonusRate).div(1 ether);
1205     }
1206 
1207     function getBonusRate(uint256 _weiAmount) internal view returns (uint256) {
1208         uint256 bonusRate = rate;
1209 
1210         
1211         // apply bonus for time & weiRaised
1212         uint[1] memory weiRaisedStartsBounds = [uint(0)];
1213         uint[1] memory weiRaisedEndsBounds = [uint(115170575000000000000000)];
1214         uint64[1] memory timeStartsBounds = [uint64(1533081600)];
1215         uint64[1] memory timeEndsBounds = [uint64(1537027080)];
1216         uint[1] memory weiRaisedAndTimeRates = [uint(50)];
1217 
1218         for (uint i = 0; i < 1; i++) {
1219             bool weiRaisedInBound = (weiRaisedStartsBounds[i] <= weiRaised) && (weiRaised < weiRaisedEndsBounds[i]);
1220             bool timeInBound = (timeStartsBounds[i] <= now) && (now < timeEndsBounds[i]);
1221             if (weiRaisedInBound && timeInBound) {
1222                 bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;
1223             }
1224         }
1225         
1226 
1227         
1228         // apply amount
1229         uint[6] memory weiAmountBounds = [uint(200000000000000000000),uint(80000000000000000000),uint(30000000000000000000),uint(10000000000000000000),uint(8000000000000000000),uint(5000000000000000000)];
1230         uint[6] memory weiAmountRates = [uint(0),uint(250),uint(0),uint(150),uint(0),uint(50)];
1231 
1232         for (uint j = 0; j < 6; j++) {
1233             if (_weiAmount >= weiAmountBounds[j]) {
1234                 bonusRate += bonusRate * weiAmountRates[j] / 1000;
1235                 break;
1236             }
1237         }
1238         
1239 
1240         return bonusRate;
1241     }
1242 }
1243 
1244 
1245 
1246 
1247 
1248 contract TemplateCrowdsale is Consts, MainCrowdsale
1249     
1250     , BonusableCrowdsale
1251     
1252     
1253     
1254     , Checkable
1255     
1256     
1257 {
1258     event Initialized();
1259     event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);
1260     bool public initialized = false;
1261 
1262     constructor(MintableToken _token) public
1263         Crowdsale(2000 * TOKEN_DECIMAL_MULTIPLIER, 0xa7c7e82a53BAEBe36f95B7Df4c447B21eADfB60B, _token)
1264         TimedCrowdsale(START_TIME > now ? START_TIME : now, 1541001480)
1265         CappedCrowdsale(115170575000000000000000)
1266         
1267     {
1268     }
1269 
1270     function init() public onlyOwner {
1271         require(!initialized);
1272         initialized = true;
1273 
1274         if (PAUSED) {
1275             MainToken(token).pause();
1276         }
1277 
1278         
1279         address[5] memory addresses = [address(0xa7c7e82a53baebe36f95b7df4c447b21eadfb60b),address(0xa7c7e82a53baebe36f95b7df4c447b21eadfb60b),address(0xf3dec80a2d514096027a56110b3fc2b155838679),address(0x5eb83c9f93eeb6bf6eb02a1aa9a0815a03c53b2a),address(0xd3841ac09b2fe75e3d0486bce88d1f41298ada41)];
1280         uint[5] memory amounts = [uint(13100000000000000000000000),uint(29800000000000000000000000),uint(600000000000000000000000),uint(58850000000000000000000),uint(14100000000000000000000000)];
1281         uint64[5] memory freezes = [uint64(1604073601),uint64(0),uint64(1572451201),uint64(0),uint64(1572451201)];
1282 
1283         for (uint i = 0; i < addresses.length; i++) {
1284             if (freezes[i] == 0) {
1285                 MainToken(token).mint(addresses[i], amounts[i]);
1286             } else {
1287                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1288             }
1289         }
1290         
1291 
1292         transferOwnership(TARGET_USER);
1293 
1294         emit Initialized();
1295     }
1296 
1297     
1298     /**
1299      * @dev override hasClosed to add minimal value logic
1300      * @return true if remained to achieve less than minimal
1301      */
1302     function hasClosed() public view returns (bool) {
1303         bool remainValue = cap.sub(weiRaised) < 3000000000000000000;
1304         return super.hasClosed() || remainValue;
1305     }
1306     
1307 
1308     
1309 
1310     
1311 
1312     
1313 
1314     
1315     /**
1316      * @dev Do inner check.
1317      * @return bool true of accident triggered, false otherwise.
1318      */
1319     function internalCheck() internal returns (bool) {
1320         bool result = !isFinalized && hasClosed();
1321         emit Checked(result);
1322         return result;
1323     }
1324 
1325     /**
1326      * @dev Do inner action if check was success.
1327      */
1328     function internalAction() internal {
1329         finalization();
1330         emit Finalized();
1331 
1332         isFinalized = true;
1333     }
1334     
1335 
1336     
1337     /**
1338      * @dev override purchase validation to add extra value logic.
1339      * @return true if sended more than minimal value
1340      */
1341     function _preValidatePurchase(
1342         address _beneficiary,
1343         uint256 _weiAmount
1344     )
1345         internal
1346     {
1347         
1348         require(msg.value >= 3000000000000000000);
1349         
1350         
1351         require(msg.value <= 200000000000000000000);
1352         
1353         super._preValidatePurchase(_beneficiary, _weiAmount);
1354     }
1355     
1356 }