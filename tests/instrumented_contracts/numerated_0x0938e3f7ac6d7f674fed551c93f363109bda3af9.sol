1 /*
2 * Generated by @Thrasher66099
3 * Email thrasher66099@gmail.com for your NFT launch needs
4 */
5 
6 pragma solidity ^0.8.0;
7 
8 interface IByteContract {
9     function burn(address _from, uint256 _amount) external;
10 }
11 
12 /**
13  * @dev Interface of the ERC165 standard, as defined in the
14  * https://eips.ethereum.org/EIPS/eip-165[EIP].
15  *
16  * Implementers can declare support of contract interfaces, which can then be
17  * queried by others ({ERC165Checker}).
18  *
19  * For an implementation, see {ERC165}.
20  */
21 interface IERC165 {
22     /**
23      * @dev Returns true if this contract implements the interface defined by
24      * `interfaceId`. See the corresponding
25      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
26      * to learn more about how these ids are created.
27      *
28      * This function call must use less than 30 000 gas.
29      */
30     function supportsInterface(bytes4 interfaceId) external view returns (bool);
31 }
32 
33 /**
34  * @dev Required interface of an ERC721 compliant contract.
35  */
36 interface IERC721 is IERC165 {
37     /**
38      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
39      */
40     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
41 
42     /**
43      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
44      */
45     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
46 
47     /**
48      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
49      */
50     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
51 
52     /**
53      * @dev Returns the number of tokens in ``owner``'s account.
54      */
55     function balanceOf(address owner) external view returns (uint256 balance);
56 
57     /**
58      * @dev Returns the owner of the `tokenId` token.
59      *
60      * Requirements:
61      *
62      * - `tokenId` must exist.
63      */
64     function ownerOf(uint256 tokenId) external view returns (address owner);
65 
66     /**
67      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
68      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
69      *
70      * Requirements:
71      *
72      * - `from` cannot be the zero address.
73      * - `to` cannot be the zero address.
74      * - `tokenId` token must exist and be owned by `from`.
75      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
76      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
77      *
78      * Emits a {Transfer} event.
79      */
80     function safeTransferFrom(
81         address from,
82         address to,
83         uint256 tokenId
84     ) external;
85 
86     /**
87      * @dev Transfers `tokenId` token from `from` to `to`.
88      *
89      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
90      *
91      * Requirements:
92      *
93      * - `from` cannot be the zero address.
94      * - `to` cannot be the zero address.
95      * - `tokenId` token must be owned by `from`.
96      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
97      *
98      * Emits a {Transfer} event.
99      */
100     function transferFrom(
101         address from,
102         address to,
103         uint256 tokenId
104     ) external;
105 
106     /**
107      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
108      * The approval is cleared when the token is transferred.
109      *
110      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
111      *
112      * Requirements:
113      *
114      * - The caller must own the token or be an approved operator.
115      * - `tokenId` must exist.
116      *
117      * Emits an {Approval} event.
118      */
119     function approve(address to, uint256 tokenId) external;
120 
121     /**
122      * @dev Returns the account approved for `tokenId` token.
123      *
124      * Requirements:
125      *
126      * - `tokenId` must exist.
127      */
128     function getApproved(uint256 tokenId) external view returns (address operator);
129 
130     /**
131      * @dev Approve or remove `operator` as an operator for the caller.
132      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
133      *
134      * Requirements:
135      *
136      * - The `operator` cannot be the caller.
137      *
138      * Emits an {ApprovalForAll} event.
139      */
140     function setApprovalForAll(address operator, bool _approved) external;
141 
142     /**
143      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
144      *
145      * See {setApprovalForAll}
146      */
147     function isApprovedForAll(address owner, address operator) external view returns (bool);
148 
149     /**
150      * @dev Safely transfers `tokenId` token from `from` to `to`.
151      *
152      * Requirements:
153      *
154      * - `from` cannot be the zero address.
155      * - `to` cannot be the zero address.
156      * - `tokenId` token must exist and be owned by `from`.
157      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
158      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
159      *
160      * Emits a {Transfer} event.
161      */
162     function safeTransferFrom(
163         address from,
164         address to,
165         uint256 tokenId,
166         bytes calldata data
167     ) external;
168 }
169 
170 
171 
172 /**
173  * @dev String operations.
174  */
175 library Strings {
176     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
177 
178     /**
179      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
180      */
181     function toString(uint256 value) internal pure returns (string memory) {
182         // Inspired by OraclizeAPI's implementation - MIT licence
183         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
184 
185         if (value == 0) {
186             return "0";
187         }
188         uint256 temp = value;
189         uint256 digits;
190         while (temp != 0) {
191             digits++;
192             temp /= 10;
193         }
194         bytes memory buffer = new bytes(digits);
195         while (value != 0) {
196             digits -= 1;
197             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
198             value /= 10;
199         }
200         return string(buffer);
201     }
202 
203 
204     /**
205      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation. 
206      */
207     function toHexString(uint256 value) internal pure returns (string memory) {
208         if (value == 0) {
209             return "0x00";
210         }
211         uint256 temp = value;
212         uint256 length = 0;
213         while (temp != 0) {
214             length++;
215             temp >>= 8;
216         }
217         return toHexString(value, length);
218     }
219 
220     /**
221      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
222      */
223     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
224         bytes memory buffer = new bytes(2 * length + 2);
225         buffer[0] = "0";
226         buffer[1] = "x";
227         for (uint256 i = 2 * length + 1; i > 1; --i) {
228             buffer[i] = _HEX_SYMBOLS[value & 0xf];
229             value >>= 4;
230         }
231         require(value == 0, "Strings: hex length insufficient");
232         return string(buffer);
233     }
234 }
235 
236 
237 /*
238  * @dev Provides information about the current execution context, including the
239  * sender of the transaction and its data. While these are generally available
240  * via msg.sender and msg.data, they should not be accessed in such a direct
241  * manner, since when dealing with meta-transactions the account sending and
242  * paying for execution may not be the actual sender (as far as an application
243  * is concerned).
244  *
245  * This contract is only required for intermediate, library-like contracts.
246  */
247 abstract contract Context {
248     function _msgSender() internal view virtual returns (address) {
249         return msg.sender;
250     }
251 
252     function _msgData() internal view virtual returns (bytes calldata) {
253         return msg.data;
254     }
255 }
256 
257 
258 /**
259  * @dev Contract module which provides a basic access control mechanism, where
260  * there is an account (an owner) that can be granted exclusive access to
261  * specific functions.
262  *
263  * By default, the owner account will be the one that deploys the contract. This
264  * can later be changed with {transferOwnership}.
265  *
266  * This module is used through inheritance. It will make available the modifier
267  * `onlyOwner`, which can be applied to your functions to restrict their use to
268  * the owner.
269  */
270 abstract contract Ownable is Context {
271     address private _owner;
272 
273     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
274 
275     /**
276      * @dev Initializes the contract setting the deployer as the initial owner.
277      */
278     constructor() {
279         _setOwner(_msgSender());
280     }
281 
282     /**
283      * @dev Returns the address of the current owner.
284      */
285     function owner() public view virtual returns (address) {
286         return _owner;
287     }
288 
289     /**
290      * @dev Throws if called by any account other than the owner.
291      */
292     modifier onlyOwner() {
293         require(owner() == _msgSender(), "Ownable: caller is not the owner");
294         _;
295     }
296 
297     /**
298      * @dev Leaves the contract without owner. It will not be possible to call
299      * `onlyOwner` functions anymore. Can only be called by the current owner.
300      *
301      * NOTE: Renouncing ownership will leave the contract without an owner,
302      * thereby removing any functionality that is only available to the owner.
303      */
304     function renounceOwnership() public virtual onlyOwner {
305         _setOwner(address(0));
306     }
307 
308     /**
309      * @dev Transfers ownership of the contract to a new account (`newOwner`).
310      * Can only be called by the current owner.
311      */
312     function transferOwnership(address newOwner) public virtual onlyOwner {
313         require(newOwner != address(0), "Ownable: new owner is the zero address");
314         _setOwner(newOwner);
315     }
316 
317     function _setOwner(address newOwner) private {
318         address oldOwner = _owner;
319         _owner = newOwner;
320         emit OwnershipTransferred(oldOwner, newOwner);
321     }
322 }
323 
324 
325 /**
326  * @dev Contract module that helps prevent reentrant calls to a function.
327  *
328  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
329  * available, which can be applied to functions to make sure there are no nested
330  * (reentrant) calls to them.
331  *
332  * Note that because there is a single `nonReentrant` guard, functions marked as
333  * `nonReentrant` may not call one another. This can be worked around by making
334  * those functions `private`, and then adding `external` `nonReentrant` entry
335  * points to them.
336  *
337  * TIP: If you would like to learn more about reentrancy and alternative ways
338  * to protect against it, check out our blog post
339  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
340  */
341 abstract contract ReentrancyGuard {
342     // Booleans are more expensive than uint256 or any type that takes up a full
343     // word because each write operation emits an extra SLOAD to first read the
344     // slot's contents, replace the bits taken up by the boolean, and then write
345     // back. This is the compiler's defense against contract upgrades and
346     // pointer aliasing, and it cannot be disabled.
347 
348     // The values being non-zero value makes deployment a bit more expensive,
349     // but in exchange the refund on every call to nonReentrant will be lower in
350     // amount. Since refunds are capped to a percentage of the total
351     // transaction's gas, it is best to keep them low in cases like this one, to
352     // increase the likelihood of the full refund coming into effect.
353     uint256 private constant _NOT_ENTERED = 1;
354     uint256 private constant _ENTERED = 2;
355 
356     uint256 private _status;
357 
358     constructor() {
359         _status = _NOT_ENTERED;
360     }
361 
362     /**
363      * @dev Prevents a contract from calling itself, directly or indirectly.
364      * Calling a `nonReentrant` function from another `nonReentrant`
365      * function is not supported. It is possible to prevent this from happening
366      * by making the `nonReentrant` function external, and make it call a
367      * `private` function that does the actual work.
368      */
369     modifier nonReentrant() {
370         // On the first call to nonReentrant, _notEntered will be true
371         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
372 
373         // Any calls to nonReentrant after this point will fail
374         _status = _ENTERED;
375 
376         _;
377 
378         // By storing the original value once again, a refund is triggered (see
379         // https://eips.ethereum.org/EIPS/eip-2200)
380         _status = _NOT_ENTERED;
381     }
382 }
383 
384 
385 
386 /**
387  * @title ERC721 token receiver interface
388  * @dev Interface for any contract that wants to support safeTransfers
389  * from ERC721 asset contracts.
390  */
391 interface IERC721Receiver {
392     /**
393      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
394      * by `operator` from `from`, this function is called.
395      *
396      * It must return its Solidity selector to confirm the token transfer.
397      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
398      *
399      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
400      */
401     function onERC721Received(
402         address operator,
403         address from,
404         uint256 tokenId,
405         bytes calldata data
406     ) external returns (bytes4);
407 }
408 
409 
410 /**
411  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
412  * @dev See https://eips.ethereum.org/EIPS/eip-721
413  */
414 interface IERC721Metadata is IERC721 {
415     /**
416      * @dev Returns the token collection name.
417      */
418     function name() external view returns (string memory);
419 
420     /**
421      * @dev Returns the token collection symbol.
422      */
423     function symbol() external view returns (string memory);
424 
425     /**
426      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
427      */
428     function tokenURI(uint256 tokenId) external view returns (string memory);
429 }
430 
431 
432 /**
433  * @dev Collection of functions related to the address type
434  */
435 library Address {
436     /**
437      * @dev Returns true if `account` is a contract.
438      *
439      * [IMPORTANT]
440      * ====
441      * It is unsafe to assume that an address for which this function returns
442      * false is an externally-owned account (EOA) and not a contract.
443      *
444      * Among others, `isContract` will return false for the following
445      * types of addresses:
446      *
447      *  - an externally-owned account
448      *  - a contract in construction
449      *  - an address where a contract will be created
450      *  - an address where a contract lived, but was destroyed
451      * ====
452      */
453     function isContract(address account) internal view returns (bool) {
454         // This method relies on extcodesize, which returns 0 for contracts in
455         // construction, since the code is only stored at the end of the
456         // constructor execution.
457 
458         uint256 size;
459         assembly {
460             size := extcodesize(account)
461         }
462         return size > 0;
463     }
464 
465     /**
466      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
467      * `recipient`, forwarding all available gas and reverting on errors.
468      *
469      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
470      * of certain opcodes, possibly making contracts go over the 2300 gas limit
471      * imposed by `transfer`, making them unable to receive funds via
472      * `transfer`. {sendValue} removes this limitation.
473      *
474      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
475      *
476      * IMPORTANT: because control is transferred to `recipient`, care must be
477      * taken to not create reentrancy vulnerabilities. Consider using
478      * {ReentrancyGuard} or the
479      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
480      */
481     function sendValue(address payable recipient, uint256 amount) internal {
482         require(address(this).balance >= amount, "Address: insufficient balance");
483 
484         (bool success, ) = recipient.call{value: amount}("");
485         require(success, "Address: unable to send value, recipient may have reverted");
486     }
487 
488     /**
489      * @dev Performs a Solidity function call using a low level `call`. A
490      * plain `call` is an unsafe replacement for a function call: use this
491      * function instead.
492      *
493      * If `target` reverts with a revert reason, it is bubbled up by this
494      * function (like regular Solidity function calls).
495      *
496      * Returns the raw returned data. To convert to the expected return value,
497      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
498      *
499      * Requirements:
500      *
501      * - `target` must be a contract.
502      * - calling `target` with `data` must not revert.
503      *
504      * _Available since v3.1._
505      */
506     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
507         return functionCall(target, data, "Address: low-level call failed");
508     }
509 
510     /**
511      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
512      * `errorMessage` as a fallback revert reason when `target` reverts.
513      *
514      * _Available since v3.1._
515      */
516     function functionCall(
517         address target,
518         bytes memory data,
519         string memory errorMessage
520     ) internal returns (bytes memory) {
521         return functionCallWithValue(target, data, 0, errorMessage);
522     }
523 
524     /**
525      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
526      * but also transferring `value` wei to `target`.
527      *
528      * Requirements:
529      *
530      * - the calling contract must have an ETH balance of at least `value`.
531      * - the called Solidity function must be `payable`.
532      *
533      * _Available since v3.1._
534      */
535     function functionCallWithValue(
536         address target,
537         bytes memory data,
538         uint256 value
539     ) internal returns (bytes memory) {
540         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
541     }
542 
543     /**
544      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
545      * with `errorMessage` as a fallback revert reason when `target` reverts.
546      *
547      * _Available since v3.1._
548      */
549     function functionCallWithValue(
550         address target,
551         bytes memory data,
552         uint256 value,
553         string memory errorMessage
554     ) internal returns (bytes memory) {
555         require(address(this).balance >= value, "Address: insufficient balance for call");
556         require(isContract(target), "Address: call to non-contract");
557 
558         (bool success, bytes memory returndata) = target.call{value: value}(data);
559         return _verifyCallResult(success, returndata, errorMessage);
560     }
561 
562     /**
563      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
564      * but performing a static call.
565      *
566      * _Available since v3.3._
567      */
568     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
569         return functionStaticCall(target, data, "Address: low-level static call failed");
570     }
571 
572     /**
573      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
574      * but performing a static call.
575      *
576      * _Available since v3.3._
577      */
578     function functionStaticCall(
579         address target,
580         bytes memory data,
581         string memory errorMessage
582     ) internal view returns (bytes memory) {
583         require(isContract(target), "Address: static call to non-contract");
584 
585         (bool success, bytes memory returndata) = target.staticcall(data);
586         return _verifyCallResult(success, returndata, errorMessage);
587     }
588 
589     /**
590      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
591      * but performing a delegate call.
592      *
593      * _Available since v3.4._
594      */
595     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
596         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
597     }
598 
599     /**
600      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
601      * but performing a delegate call.
602      *
603      * _Available since v3.4._
604      */
605     function functionDelegateCall(
606         address target,
607         bytes memory data,
608         string memory errorMessage
609     ) internal returns (bytes memory) {
610         require(isContract(target), "Address: delegate call to non-contract");
611 
612         (bool success, bytes memory returndata) = target.delegatecall(data);
613         return _verifyCallResult(success, returndata, errorMessage);
614     }
615 
616     function _verifyCallResult(
617         bool success,
618         bytes memory returndata,
619         string memory errorMessage
620     ) private pure returns (bytes memory) {
621         if (success) {
622             return returndata;
623         } else {
624             // Look for revert reason and bubble it up if present
625             if (returndata.length > 0) {
626                 // The easiest way to bubble the revert reason is using memory via assembly
627 
628                 assembly {
629                     let returndata_size := mload(returndata)
630                     revert(add(32, returndata), returndata_size)
631                 }
632             } else {
633                 revert(errorMessage);
634             }
635         }
636     }
637 }
638 
639 
640 
641 
642 /**
643  * @dev Implementation of the {IERC165} interface.
644  *
645  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
646  * for the additional interface id that will be supported. For example:
647  *
648  * ```solidity
649  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
650  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
651  * }
652  * ```
653  *
654  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
655  */
656 abstract contract ERC165 is IERC165 {
657     /**
658      * @dev See {IERC165-supportsInterface}.
659      */
660     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
661         return interfaceId == type(IERC165).interfaceId;
662     }
663 }
664 
665 
666 /**
667  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
668  * the Metadata extension, but not including the Enumerable extension, which is available separately as
669  * {ERC721Enumerable}.
670  */
671 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
672     using Address for address;
673     using Strings for uint256;
674 
675     // Token name
676     string private _name;
677 
678     // Token symbol
679     string private _symbol;
680 
681     // Mapping from token ID to owner address
682     mapping(uint256 => address) private _owners;
683 
684     // Mapping owner address to token count
685     mapping(address => uint256) private _balances;
686 
687     // Mapping from token ID to approved address
688     mapping(uint256 => address) private _tokenApprovals;
689 
690     // Mapping from owner to operator approvals
691     mapping(address => mapping(address => bool)) private _operatorApprovals;
692 
693     /**
694      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
695      */
696     constructor(string memory name_, string memory symbol_) {
697         _name = name_;
698         _symbol = symbol_;
699     }
700 
701     /**
702      * @dev See {IERC165-supportsInterface}.
703      */
704     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
705         return
706             interfaceId == type(IERC721).interfaceId ||
707             interfaceId == type(IERC721Metadata).interfaceId ||
708             super.supportsInterface(interfaceId);
709     }
710 
711     /**
712      * @dev See {IERC721-balanceOf}.
713      */
714     function balanceOf(address owner) public view virtual override returns (uint256) {
715         require(owner != address(0), "ERC721: balance query for the zero address");
716         return _balances[owner];
717     }
718 
719     /**
720      * @dev See {IERC721-ownerOf}.
721      */
722     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
723         address owner = _owners[tokenId];
724         require(owner != address(0), "ERC721: owner query for nonexistent token");
725         return owner;
726     }
727 
728     /**
729      * @dev See {IERC721Metadata-name}.
730      */
731     function name() public view virtual override returns (string memory) {
732         return _name;
733     }
734 
735     /**
736      * @dev See {IERC721Metadata-symbol}.
737      */
738     function symbol() public view virtual override returns (string memory) {
739         return _symbol;
740     }
741 
742     /**
743      * @dev See {IERC721Metadata-tokenURI}.
744      */
745     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
746         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
747 
748         string memory baseURI = _baseURI();
749         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
750     }
751 
752     /**
753      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
754      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
755      * by default, can be overriden in child contracts.
756      */
757     function _baseURI() internal view virtual returns (string memory) {
758         return "";
759     }
760 
761     /**
762      * @dev See {IERC721-approve}.
763      */
764     function approve(address to, uint256 tokenId) public virtual override {
765         address owner = ERC721.ownerOf(tokenId);
766         require(to != owner, "ERC721: approval to current owner");
767 
768         require(
769             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
770             "ERC721: approve caller is not owner nor approved for all"
771         );
772 
773         _approve(to, tokenId);
774     }
775 
776     /**
777      * @dev See {IERC721-getApproved}.
778      */
779     function getApproved(uint256 tokenId) public view virtual override returns (address) {
780         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
781 
782         return _tokenApprovals[tokenId];
783     }
784 
785     /**
786      * @dev See {IERC721-setApprovalForAll}.
787      */
788     function setApprovalForAll(address operator, bool approved) public virtual override {
789         require(operator != _msgSender(), "ERC721: approve to caller");
790 
791         _operatorApprovals[_msgSender()][operator] = approved;
792         emit ApprovalForAll(_msgSender(), operator, approved);
793     }
794 
795     /**
796      * @dev See {IERC721-isApprovedForAll}.
797      */
798     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
799         return _operatorApprovals[owner][operator];
800     }
801 
802     /**
803      * @dev See {IERC721-transferFrom}.
804      */
805     function transferFrom(
806         address from,
807         address to,
808         uint256 tokenId
809     ) public virtual override {
810         //solhint-disable-next-line max-line-length
811         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
812 
813         _transfer(from, to, tokenId);
814     }
815 
816     /**
817      * @dev See {IERC721-safeTransferFrom}.
818      */
819     function safeTransferFrom(
820         address from,
821         address to,
822         uint256 tokenId
823     ) public virtual override {
824         safeTransferFrom(from, to, tokenId, "");
825     }
826 
827     /**
828      * @dev See {IERC721-safeTransferFrom}.
829      */
830     function safeTransferFrom(
831         address from,
832         address to,
833         uint256 tokenId,
834         bytes memory _data
835     ) public virtual override {
836         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
837         _safeTransfer(from, to, tokenId, _data);
838     }
839 
840     /**
841      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
842      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
843      *
844      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
845      *
846      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
847      * implement alternative mechanisms to perform token transfer, such as signature-based.
848      *
849      * Requirements:
850      *
851      * - `from` cannot be the zero address.
852      * - `to` cannot be the zero address.
853      * - `tokenId` token must exist and be owned by `from`.
854      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
855      *
856      * Emits a {Transfer} event.
857      */
858     function _safeTransfer(
859         address from,
860         address to,
861         uint256 tokenId,
862         bytes memory _data
863     ) internal virtual {
864         _transfer(from, to, tokenId);
865         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
866     }
867 
868     /**
869      * @dev Returns whether `tokenId` exists.
870      *
871      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
872      *
873      * Tokens start existing when they are minted (`_mint`),
874      * and stop existing when they are burned (`_burn`).
875      */
876     function _exists(uint256 tokenId) internal view virtual returns (bool) {
877         return _owners[tokenId] != address(0);
878     }
879 
880     /**
881      * @dev Returns whether `spender` is allowed to manage `tokenId`.
882      *
883      * Requirements:
884      *
885      * - `tokenId` must exist.
886      */
887     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
888         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
889         address owner = ERC721.ownerOf(tokenId);
890         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
891     }
892 
893     /**
894      * @dev Safely mints `tokenId` and transfers it to `to`.
895      *
896      * Requirements:
897      *
898      * - `tokenId` must not exist.
899      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
900      *
901      * Emits a {Transfer} event.
902      */
903     function _safeMint(address to, uint256 tokenId) internal virtual {
904         _safeMint(to, tokenId, "");
905     }
906 
907     /**
908      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
909      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
910      */
911     function _safeMint(
912         address to,
913         uint256 tokenId,
914         bytes memory _data
915     ) internal virtual {
916         _mint(to, tokenId);
917         require(
918             _checkOnERC721Received(address(0), to, tokenId, _data),
919             "ERC721: transfer to non ERC721Receiver implementer"
920         );
921     }
922 
923     /**
924      * @dev Mints `tokenId` and transfers it to `to`.
925      *
926      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
927      *
928      * Requirements:
929      *
930      * - `tokenId` must not exist.
931      * - `to` cannot be the zero address.
932      *
933      * Emits a {Transfer} event.
934      */
935     function _mint(address to, uint256 tokenId) internal virtual {
936         require(to != address(0), "ERC721: mint to the zero address");
937         require(!_exists(tokenId), "ERC721: token already minted");
938 
939         _beforeTokenTransfer(address(0), to, tokenId);
940 
941         _balances[to] += 1;
942         _owners[tokenId] = to;
943 
944         emit Transfer(address(0), to, tokenId);
945     }
946 
947     /**
948      * @dev Destroys `tokenId`.
949      * The approval is cleared when the token is burned.
950      *
951      * Requirements:
952      *
953      * - `tokenId` must exist.
954      *
955      * Emits a {Transfer} event.
956      */
957     function _burn(uint256 tokenId) internal virtual {
958         address owner = ERC721.ownerOf(tokenId);
959 
960         _beforeTokenTransfer(owner, address(0), tokenId);
961 
962         // Clear approvals
963         _approve(address(0), tokenId);
964 
965         _balances[owner] -= 1;
966         delete _owners[tokenId];
967 
968         emit Transfer(owner, address(0), tokenId);
969     }
970 
971     /**
972      * @dev Transfers `tokenId` from `from` to `to`.
973      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
974      *
975      * Requirements:
976      *
977      * - `to` cannot be the zero address.
978      * - `tokenId` token must be owned by `from`.
979      *
980      * Emits a {Transfer} event.
981      */
982     function _transfer(
983         address from,
984         address to,
985         uint256 tokenId
986     ) internal virtual {
987         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
988         require(to != address(0), "ERC721: transfer to the zero address");
989 
990         _beforeTokenTransfer(from, to, tokenId);
991 
992         // Clear approvals from the previous owner
993         _approve(address(0), tokenId);
994 
995         _balances[from] -= 1;
996         _balances[to] += 1;
997         _owners[tokenId] = to;
998 
999         emit Transfer(from, to, tokenId);
1000     }
1001 
1002     /**
1003      * @dev Approve `to` to operate on `tokenId`
1004      *
1005      * Emits a {Approval} event.
1006      */
1007     function _approve(address to, uint256 tokenId) internal virtual {
1008         _tokenApprovals[tokenId] = to;
1009         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1010     }
1011 
1012     /**
1013      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1014      * The call is not executed if the target address is not a contract.
1015      *
1016      * @param from address representing the previous owner of the given token ID
1017      * @param to target address that will receive the tokens
1018      * @param tokenId uint256 ID of the token to be transferred
1019      * @param _data bytes optional data to send along with the call
1020      * @return bool whether the call correctly returned the expected magic value
1021      */
1022     function _checkOnERC721Received(
1023         address from,
1024         address to,
1025         uint256 tokenId,
1026         bytes memory _data
1027     ) private returns (bool) {
1028         if (to.isContract()) {
1029             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1030                 return retval == IERC721Receiver(to).onERC721Received.selector;
1031             } catch (bytes memory reason) {
1032                 if (reason.length == 0) {
1033                     revert("ERC721: transfer to non ERC721Receiver implementer");
1034                 } else {
1035                     assembly {
1036                         revert(add(32, reason), mload(reason))
1037                     }
1038                 }
1039             }
1040         } else {
1041             return true;
1042         }
1043     }
1044 
1045     /**
1046      * @dev Hook that is called before any token transfer. This includes minting
1047      * and burning.
1048      *
1049      * Calling conditions:
1050      *
1051      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1052      * transferred to `to`.
1053      * - When `from` is zero, `tokenId` will be minted for `to`.
1054      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1055      * - `from` and `to` are never both zero.
1056      *
1057      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1058      */
1059     function _beforeTokenTransfer(
1060         address from,
1061         address to,
1062         uint256 tokenId
1063     ) internal virtual {}
1064 }
1065 
1066 
1067 
1068 /**
1069  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1070  * @dev See https://eips.ethereum.org/EIPS/eip-721
1071  */
1072 interface IERC721Enumerable is IERC721 {
1073     /**
1074      * @dev Returns the total amount of tokens stored by the contract.
1075      */
1076     function totalSupply() external view returns (uint256);
1077 
1078     /**
1079      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1080      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1081      */
1082     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1083 
1084     /**
1085      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1086      * Use along with {totalSupply} to enumerate all tokens.
1087      */
1088     function tokenByIndex(uint256 index) external view returns (uint256);
1089 }
1090 
1091 
1092 /**
1093  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1094  * enumerability of all the token ids in the contract as well as all token ids owned by each
1095  * account.
1096  */
1097 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1098     // Mapping from owner to list of owned token IDs
1099     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1100 
1101     // Mapping from token ID to index of the owner tokens list
1102     mapping(uint256 => uint256) private _ownedTokensIndex;
1103 
1104     // Array with all token ids, used for enumeration
1105     uint256[] private _allTokens;
1106 
1107     // Mapping from token id to position in the allTokens array
1108     mapping(uint256 => uint256) private _allTokensIndex;
1109 
1110     /**
1111      * @dev See {IERC165-supportsInterface}.
1112      */
1113     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1114         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1115     }
1116 
1117     /**
1118      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1119      */
1120     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1121         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1122         return _ownedTokens[owner][index];
1123     }
1124 
1125     /**
1126      * @dev See {IERC721Enumerable-totalSupply}.
1127      */
1128     function totalSupply() public view virtual override returns (uint256) {
1129         return _allTokens.length;
1130     }
1131 
1132     /**
1133      * @dev See {IERC721Enumerable-tokenByIndex}.
1134      */
1135     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1136         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1137         return _allTokens[index];
1138     }
1139 
1140     /**
1141      * @dev Hook that is called before any token transfer. This includes minting
1142      * and burning.
1143      *
1144      * Calling conditions:
1145      *
1146      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1147      * transferred to `to`.
1148      * - When `from` is zero, `tokenId` will be minted for `to`.
1149      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1150      * - `from` cannot be the zero address.
1151      * - `to` cannot be the zero address.
1152      *
1153      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1154      */
1155     function _beforeTokenTransfer(
1156         address from,
1157         address to,
1158         uint256 tokenId
1159     ) internal virtual override {
1160         super._beforeTokenTransfer(from, to, tokenId);
1161 
1162         if (from == address(0)) {
1163             _addTokenToAllTokensEnumeration(tokenId);
1164         } else if (from != to) {
1165             _removeTokenFromOwnerEnumeration(from, tokenId);
1166         }
1167         if (to == address(0)) {
1168             _removeTokenFromAllTokensEnumeration(tokenId);
1169         } else if (to != from) {
1170             _addTokenToOwnerEnumeration(to, tokenId);
1171         }
1172     }
1173 
1174     /**
1175      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1176      * @param to address representing the new owner of the given token ID
1177      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1178      */
1179     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1180         uint256 length = ERC721.balanceOf(to);
1181         _ownedTokens[to][length] = tokenId;
1182         _ownedTokensIndex[tokenId] = length;
1183     }
1184 
1185     /**
1186      * @dev Private function to add a token to this extension's token tracking data structures.
1187      * @param tokenId uint256 ID of the token to be added to the tokens list
1188      */
1189     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1190         _allTokensIndex[tokenId] = _allTokens.length;
1191         _allTokens.push(tokenId);
1192     }
1193 
1194     /**
1195      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1196      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1197      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1198      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1199      * @param from address representing the previous owner of the given token ID
1200      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1201      */
1202     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1203         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1204         // then delete the last slot (swap and pop).
1205 
1206         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1207         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1208 
1209         // When the token to delete is the last token, the swap operation is unnecessary
1210         if (tokenIndex != lastTokenIndex) {
1211             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1212 
1213             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1214             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1215         }
1216 
1217         // This also deletes the contents at the last position of the array
1218         delete _ownedTokensIndex[tokenId];
1219         delete _ownedTokens[from][lastTokenIndex];
1220     }
1221 
1222     /**
1223      * @dev Private function to remove a token from this extension's token tracking data structures.
1224      * This has O(1) time complexity, but alters the order of the _allTokens array.
1225      * @param tokenId uint256 ID of the token to be removed from the tokens list
1226      */
1227     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1228         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1229         // then delete the last slot (swap and pop).
1230 
1231         uint256 lastTokenIndex = _allTokens.length - 1;
1232         uint256 tokenIndex = _allTokensIndex[tokenId];
1233 
1234         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1235         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1236         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1237         uint256 lastTokenId = _allTokens[lastTokenIndex];
1238 
1239         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1240         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1241 
1242         // This also deletes the contents at the last position of the array
1243         delete _allTokensIndex[tokenId];
1244         _allTokens.pop();
1245     }
1246 }
1247 
1248 contract NTItems is ERC721Enumerable, ReentrancyGuard, Ownable {
1249 
1250     bool itemMintActive;
1251     address boxContract;
1252     address itemMint;
1253     address bytesContract;
1254     uint256 boughtItemsCount;
1255     uint256 specialItemCount;
1256     uint256 itemCost = 500 ether;
1257 
1258     bytes32[] _rootHash;
1259 
1260     mapping(uint256 => string) private _specialItems;
1261 
1262     // Mapping for identity tokenIds that have previously claimed
1263     mapping(uint256 => uint256) private _boxClaims;
1264 
1265     // Mapping to look up what identity minted a specific token
1266     mapping(uint256 => uint256) private _tokenMintedByBox;
1267 
1268     string[] private weapon = [
1269         "Pocket Knife",
1270         "Pea Shooter",
1271         "Rolled Up Newspaper",
1272         "Brass Knuckles",
1273         "Taser",
1274         "Sword",
1275         "Pistol",
1276         "Rifle",
1277         "Shield",
1278         "Cyber Katana",
1279         "Plasma Rifle",
1280         "50 Cal Magnum",
1281         "Missile Launcher",
1282         "Minigun",
1283         "Super Shotgun",
1284         "Charge Blade",
1285         "Light Saber",
1286         "Golden Sock",
1287         "Gravity Gun",
1288         "Golden Hilt Red Light Saber",
1289         "Sword of Masters",
1290         "Energy Sword",
1291         "BFG 9000",
1292         "Buster Sword",
1293         "Metraid Hand Blaster",
1294         "Blades of Chaos"
1295     ];
1296 
1297     string[] private apparel = [
1298         "Work Clothes 1",
1299         "Work Clothes 2",
1300         "Work Clothes 3",
1301         "Bar Outfit 1",
1302         "Bar Outfit 2",
1303         "Bar Outfit 3",
1304         "Scavenger 1",
1305         "Scavenger 2",
1306         "Scavenger 3",
1307         "Grunt 1",
1308         "Grunt 2",
1309         "Tee Shirt 1",
1310         "Tee Shirt 2",
1311         "Tee Shirt 3",
1312         "Suit 1",
1313         "Suit 2",
1314         "Suit 3",
1315         "Hoodie 1",
1316         "Hoodie 2",
1317         "Hoodie 3",
1318         "Rave",
1319         "Kimono",
1320         "No Shirt",
1321         "Armor",
1322         "Ninja Garb",
1323         "Service",
1324         "Hawaiian",
1325         "Rave Hoodie",
1326         "School",
1327         "Cyber Samurai",
1328         "Cyber Suit",
1329         "Neo Armor",
1330         "Zombie Robot",
1331         "Onesie",
1332         "Power Suit",
1333         "Demon Suit",
1334         "Mecha Ninja",
1335         "Giant Mech",
1336         "Ape",
1337         "Space Suit",
1338         "Akira Jacket",
1339         "Angel with Wings",
1340         "Translucent",
1341         "No Skin",
1342         "Devil 1",
1343         "Devil 2",
1344         "Devil 3",
1345         "Angel 1",
1346         "Angel 2",
1347         "Angel 3",
1348         "Dark Space Wizard",
1349         "Tri-Angle Hero",
1350         "Chief Master",
1351         "Doom Man",
1352         "Ichigo",
1353         "Metraidish",
1354         "Super Italian Guy"
1355     ];
1356 
1357     string[] private vehicle = [
1358         "Bicycle",
1359         "Scooter",
1360         "Roller Blades",
1361         "Car 1",
1362         "Car 2",
1363         "Car 3",
1364         "Car 4",
1365         "Car 5",
1366         "Car 6",
1367         "Cyber Bike",
1368         "Cyber Car 1",
1369         "Cyber Car 2",
1370         "Cyber Car 3",
1371         "Hover Car",
1372         "Jet Pack",
1373         "Gamborghini",
1374         "Epic Mount"
1375     ];
1376 
1377     string[] private helm = [
1378         "VR Visor",
1379         "Motocross Helmet",
1380         "Gas Mask",
1381         "Typical Cyber Helm 1",
1382         "Typical Cyber Helm 2",
1383         "Typical Cyber Helm 3",
1384         "Business Helmet 1",
1385         "Business Helmet 2",
1386         "Business Helmet 3",
1387         "Trash Helmet",
1388         "Robot Head",
1389         "Cyber Football 1",
1390         "Cyber Football 2",
1391         "Blitz Ball Fan Helmet 1",
1392         "Blitz Ball Fan Helmet 2",
1393         "Rave Helmet 1",
1394         "Rave Helmet 2",
1395         "Middle Class Helm 1",
1396         "Middle Class Helm 2",
1397         "Construction Helmet",
1398         "VIP Robot Head",
1399         "Blitz Ball Player",
1400         "Shark Helm",
1401         "Medieval",
1402         "Soldier 1",
1403         "Soldier 2",
1404         "Pilot Helm",
1405         "Beer Hat helm",
1406         "DJ Helm",
1407         "Ghost Robot",
1408         "Samurai Mask",
1409         "Fire Helm",
1410         "Ice Helm",
1411         "Electric Helm",
1412         "Water Helm",
1413         "Ape Helm",
1414         "Zombie Robot",
1415         "Luxury Robot",
1416         "Dwemer Robot",
1417         "Skull",
1418         "Gold Skull",
1419         "Gold Robot",
1420         "Diamond Multi Color Samurai",
1421         "Demon",
1422         "Laser Eyes",
1423         "Giant Mech",
1424         "Bored Ape",
1425         "Crypto Punk"
1426     ];
1427 
1428     function setItemMint() external onlyOwner
1429     {
1430         itemMintActive = !itemMintActive;
1431     }
1432 
1433     function checkSpecialItems(uint256 tokenId) external view returns (string memory)
1434     {
1435         return _specialItems[tokenId];
1436     }
1437 
1438     function getWeapon(uint256 tokenId) public view returns (string memory)
1439     {
1440         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1441         string memory output;
1442 
1443         NTItems dataContract = NTItems(itemMint);
1444         output = dataContract.getWeapon(tokenId);
1445 
1446         return output;
1447     }
1448 
1449     function getVehicle(uint256 tokenId) external view returns (string memory)
1450     {
1451         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1452         string memory output;
1453 
1454         NTItems dataContract = NTItems(itemMint);
1455         output = dataContract.getVehicle(tokenId);
1456 
1457         return output;
1458     }
1459     
1460     function getApparel(uint256 tokenId) public view returns (string memory) {
1461         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1462         string memory output;
1463         
1464         NTItems dataContract = NTItems(itemMint);
1465         output = dataContract.getApparel(tokenId);
1466 
1467         return output;
1468     }
1469 
1470     function getHelm(uint256 tokenId) public view returns (string memory) {
1471         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1472         string memory output;
1473         
1474         NTItems dataContract = NTItems(itemMint);
1475         output = dataContract.getHelm(tokenId);
1476 
1477         return output;
1478     }
1479 
1480     function getTokenClaimedByBoxTokenId(uint256 boxTokenId) public view returns (uint256) {
1481         return _boxClaims[boxTokenId];
1482     }
1483 
1484     function getClaimantBoxIdByTokenId(uint256 tokenId) public view returns (uint256) {
1485         return _tokenMintedByBox[tokenId];
1486     }
1487 
1488     function tokenURI(uint256 tokenId) override public view returns (string memory) {
1489         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1490         
1491         string memory output;
1492 
1493         NTItems dataContract = NTItems(itemMint);
1494         output = dataContract.tokenURI(tokenId);
1495 
1496 
1497         return output;
1498     }
1499 
1500     function boxClaim(uint256 boxTokenId, uint256 spotOnLeaderboard, uint256 spotInWhitelist, bytes32[] memory proof) public nonReentrant {
1501         require(itemMintActive, "Minting is not currently active");
1502         require(boxTokenId > 0 && boxTokenId < 2501, "That is not a claimable item");
1503         require(whitelistValidated(toString(boxTokenId), spotOnLeaderboard, spotInWhitelist, proof), "That box cannot claim that item");
1504         require(boxValidated(boxTokenId), "You are not the owner of that vault box");
1505 
1506         _safeMint(_msgSender(), spotOnLeaderboard);
1507 
1508         if(specialItemCount < 18 && spotOnLeaderboard > 7)
1509         {
1510             specialItemCheck(spotOnLeaderboard);
1511         }
1512 
1513         //Set the identityMinters value to tokenId for this address so the identity cannot mint again
1514         _boxClaims[boxTokenId] = spotOnLeaderboard;
1515 
1516         //Set the box that minted this token for reverse lookup
1517         _tokenMintedByBox[spotOnLeaderboard] = boxTokenId;
1518     }
1519 
1520     function specialItemCheck(uint256 spotOnLeaderboard) internal
1521     {
1522         if(specialItemCount < 18)
1523         {
1524             uint256 rand = uint256(keccak256(abi.encodePacked(spotOnLeaderboard))) % 100;
1525             if(rand > 40)
1526             {
1527                 _specialItems[spotOnLeaderboard] = apparel[(specialItemCount % 6) + 44];
1528                 specialItemCount++;
1529             }
1530           
1531         }
1532     }
1533 
1534     function buyItems() public nonReentrant
1535     {
1536         require(address(bytesContract) != address(0), "Items cannot be bought yet");
1537         IByteContract iBytes = IByteContract(bytesContract);
1538         iBytes.burn(_msgSender(), itemCost);
1539         _safeMint(_msgSender(), boughtItemsCount + 2501);
1540         boughtItemsCount++;
1541     }
1542 
1543     //Used only in cases where the original box owner does not or cannot claim an item
1544     function emergencyClaim(uint256 boxId, uint256 tokenId) public onlyOwner {
1545         require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
1546         require(!_exists(tokenId), "That token already exists");
1547         require(_boxClaims[boxId] == 0, "That box has already claimed");
1548 
1549         _safeMint(owner(), tokenId);
1550         _boxClaims[boxId] = tokenId;
1551     }
1552 
1553     function boxValidated(uint256 boxId) internal view returns (bool) {
1554         require(_boxClaims[boxId] == 0, "This box has minted");
1555         ERC721Enumerable boxEnumerable = ERC721Enumerable(boxContract);
1556         return(boxEnumerable.ownerOf(boxId) == _msgSender());
1557     }
1558 
1559     function whitelistValidated(string memory vaultTokenId, uint256 leaderboardSpot,uint256 index, bytes32[] memory proof) internal view returns (bool) {
1560 
1561         // Compute the merkle root
1562         bytes32 node = keccak256(abi.encodePacked(index, vaultTokenId, leaderboardSpot));
1563         uint256 path = index;
1564         for (uint16 i = 0; i < proof.length; i++) {
1565             if ((path & 0x01) == 1) {
1566                 node = keccak256(abi.encodePacked(proof[i], node));
1567             } else {
1568                 node = keccak256(abi.encodePacked(node, proof[i]));
1569             }
1570             path /= 2;
1571         }
1572 
1573         // Check the merkle proof against the root hash array
1574         for(uint i = 0; i < _rootHash.length; i++)
1575         {
1576             if (node == _rootHash[i])
1577             {
1578                 return true;
1579             }
1580         }
1581 
1582         return false;
1583     }
1584 
1585     function setItemMintActive() public onlyOwner {
1586         itemMintActive = !itemMintActive;
1587     }
1588 
1589     function setItemCost(uint256 _cost) public onlyOwner {
1590         itemCost = _cost;
1591     }
1592 
1593     function setContract(address contractAddress) public onlyOwner {
1594         itemMint = contractAddress;
1595     }
1596 
1597     function setBoxAddress(address contractAddress) public onlyOwner {
1598         boxContract = contractAddress;
1599     }
1600 
1601     function setBytesAddress(address contractAddress) public onlyOwner {
1602         bytesContract = contractAddress;
1603     }
1604     
1605     
1606     function toString(uint256 value) internal pure returns (string memory) {
1607     // Inspired by OraclizeAPI's implementation - MIT license
1608     // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
1609 
1610         if (value == 0) {
1611             return "0";
1612         }
1613         uint256 temp = value;
1614         uint256 digits;
1615         while (temp != 0) {
1616             digits++;
1617             temp /= 10;
1618         }
1619         bytes memory buffer = new bytes(digits);
1620         while (value != 0) {
1621             digits -= 1;
1622             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
1623             value /= 10;
1624         }
1625         return string(buffer);
1626     }
1627     
1628     constructor() ERC721("Neo Tokyo Part 3 Item Caches", "NTITEM") Ownable() {
1629         _rootHash = new bytes32[](3);
1630         _rootHash[0] = 0x520402e709a474aba20b76bd83a0dc2a80e637a2204dfa9f3ed7a7eb4ddcda6f;
1631         _rootHash[1] = 0x929639dcc824d76951c3f59f3c3af3952c62a4e94aef417a3eeed7ea100bcb2c;
1632         _rootHash[2] = 0x5209c4408bdde0b10da4a48db3899e1ab25059a880db1ead8c05747f0ec3ae30;
1633 
1634         bytesContract = 0x7d647b1A0dcD5525e9C6B3D14BE58f27674f8c95;
1635         boxContract = 0xab0b0dD7e4EaB0F9e31a539074a03f1C1Be80879;
1636         itemMint = 0x2d87a68C9A34D434b14F9eadB5582aDC9E973bf6;
1637     }
1638 }