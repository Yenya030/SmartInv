1 // SPDX-License-Identifier: Apache-2.0
2 // Copyright 2017 Loopring Technology Limited.
3 pragma solidity ^0.7.0;
4 
5 
6 /// @title Poseidon hash function
7 ///        See: https://eprint.iacr.org/2019/458.pdf
8 ///        Code auto-generated by generate_poseidon_EVM_code.py
9 /// @author Brecht Devos - <brecht@loopring.org>
10 library Poseidon
11 {
12     //
13     // hash_t5f6p52
14     //
15 
16     struct HashInputs5
17     {
18         uint t0;
19         uint t1;
20         uint t2;
21         uint t3;
22         uint t4;
23     }
24 
25     function hash_t5f6p52_internal(
26         uint t0,
27         uint t1,
28         uint t2,
29         uint t3,
30         uint t4,
31         uint q
32         )
33         internal
34         pure
35         returns (uint)
36     {
37         assembly {
38             function mix(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {
39                 nt0 := mulmod(_t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, _q)
40                 nt0 := addmod(nt0, mulmod(_t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, _q), _q)
41                 nt0 := addmod(nt0, mulmod(_t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, _q), _q)
42                 nt0 := addmod(nt0, mulmod(_t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, _q), _q)
43                 nt0 := addmod(nt0, mulmod(_t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, _q), _q)
44                 nt1 := mulmod(_t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, _q)
45                 nt1 := addmod(nt1, mulmod(_t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, _q), _q)
46                 nt1 := addmod(nt1, mulmod(_t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, _q), _q)
47                 nt1 := addmod(nt1, mulmod(_t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, _q), _q)
48                 nt1 := addmod(nt1, mulmod(_t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, _q), _q)
49                 nt2 := mulmod(_t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, _q)
50                 nt2 := addmod(nt2, mulmod(_t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, _q), _q)
51                 nt2 := addmod(nt2, mulmod(_t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, _q), _q)
52                 nt2 := addmod(nt2, mulmod(_t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, _q), _q)
53                 nt2 := addmod(nt2, mulmod(_t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, _q), _q)
54                 nt3 := mulmod(_t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, _q)
55                 nt3 := addmod(nt3, mulmod(_t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, _q), _q)
56                 nt3 := addmod(nt3, mulmod(_t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, _q), _q)
57                 nt3 := addmod(nt3, mulmod(_t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, _q), _q)
58                 nt3 := addmod(nt3, mulmod(_t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, _q), _q)
59                 nt4 := mulmod(_t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, _q)
60                 nt4 := addmod(nt4, mulmod(_t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, _q), _q)
61                 nt4 := addmod(nt4, mulmod(_t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, _q), _q)
62                 nt4 := addmod(nt4, mulmod(_t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, _q), _q)
63                 nt4 := addmod(nt4, mulmod(_t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, _q), _q)
64             }
65 
66             function ark(_t0, _t1, _t2, _t3, _t4, _q, c) -> nt0, nt1, nt2, nt3, nt4 {
67                 nt0 := addmod(_t0, c, _q)
68                 nt1 := addmod(_t1, c, _q)
69                 nt2 := addmod(_t2, c, _q)
70                 nt3 := addmod(_t3, c, _q)
71                 nt4 := addmod(_t4, c, _q)
72             }
73 
74             function sbox_full(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {
75                 nt0 := mulmod(_t0, _t0, _q)
76                 nt0 := mulmod(nt0, nt0, _q)
77                 nt0 := mulmod(_t0, nt0, _q)
78                 nt1 := mulmod(_t1, _t1, _q)
79                 nt1 := mulmod(nt1, nt1, _q)
80                 nt1 := mulmod(_t1, nt1, _q)
81                 nt2 := mulmod(_t2, _t2, _q)
82                 nt2 := mulmod(nt2, nt2, _q)
83                 nt2 := mulmod(_t2, nt2, _q)
84                 nt3 := mulmod(_t3, _t3, _q)
85                 nt3 := mulmod(nt3, nt3, _q)
86                 nt3 := mulmod(_t3, nt3, _q)
87                 nt4 := mulmod(_t4, _t4, _q)
88                 nt4 := mulmod(nt4, nt4, _q)
89                 nt4 := mulmod(_t4, nt4, _q)
90             }
91 
92             function sbox_partial(_t, _q) -> nt {
93                 nt := mulmod(_t, _t, _q)
94                 nt := mulmod(nt, nt, _q)
95                 nt := mulmod(_t, nt, _q)
96             }
97 
98             // round 0
99             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)
100             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
101             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
102             // round 1
103             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)
104             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
105             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
106             // round 2
107             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)
108             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
109             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
110             // round 3
111             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)
112             t0 := sbox_partial(t0, q)
113             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
114             // round 4
115             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)
116             t0 := sbox_partial(t0, q)
117             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
118             // round 5
119             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)
120             t0 := sbox_partial(t0, q)
121             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
122             // round 6
123             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)
124             t0 := sbox_partial(t0, q)
125             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
126             // round 7
127             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)
128             t0 := sbox_partial(t0, q)
129             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
130             // round 8
131             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)
132             t0 := sbox_partial(t0, q)
133             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
134             // round 9
135             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)
136             t0 := sbox_partial(t0, q)
137             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
138             // round 10
139             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)
140             t0 := sbox_partial(t0, q)
141             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
142             // round 11
143             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)
144             t0 := sbox_partial(t0, q)
145             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
146             // round 12
147             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)
148             t0 := sbox_partial(t0, q)
149             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
150             // round 13
151             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)
152             t0 := sbox_partial(t0, q)
153             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
154             // round 14
155             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)
156             t0 := sbox_partial(t0, q)
157             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
158             // round 15
159             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)
160             t0 := sbox_partial(t0, q)
161             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
162             // round 16
163             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)
164             t0 := sbox_partial(t0, q)
165             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
166             // round 17
167             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)
168             t0 := sbox_partial(t0, q)
169             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
170             // round 18
171             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)
172             t0 := sbox_partial(t0, q)
173             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
174             // round 19
175             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)
176             t0 := sbox_partial(t0, q)
177             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
178             // round 20
179             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)
180             t0 := sbox_partial(t0, q)
181             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
182             // round 21
183             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)
184             t0 := sbox_partial(t0, q)
185             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
186             // round 22
187             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)
188             t0 := sbox_partial(t0, q)
189             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
190             // round 23
191             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)
192             t0 := sbox_partial(t0, q)
193             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
194             // round 24
195             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)
196             t0 := sbox_partial(t0, q)
197             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
198             // round 25
199             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)
200             t0 := sbox_partial(t0, q)
201             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
202             // round 26
203             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)
204             t0 := sbox_partial(t0, q)
205             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
206             // round 27
207             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)
208             t0 := sbox_partial(t0, q)
209             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
210             // round 28
211             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)
212             t0 := sbox_partial(t0, q)
213             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
214             // round 29
215             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)
216             t0 := sbox_partial(t0, q)
217             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
218             // round 30
219             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)
220             t0 := sbox_partial(t0, q)
221             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
222             // round 31
223             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)
224             t0 := sbox_partial(t0, q)
225             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
226             // round 32
227             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)
228             t0 := sbox_partial(t0, q)
229             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
230             // round 33
231             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)
232             t0 := sbox_partial(t0, q)
233             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
234             // round 34
235             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)
236             t0 := sbox_partial(t0, q)
237             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
238             // round 35
239             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)
240             t0 := sbox_partial(t0, q)
241             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
242             // round 36
243             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)
244             t0 := sbox_partial(t0, q)
245             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
246             // round 37
247             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)
248             t0 := sbox_partial(t0, q)
249             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
250             // round 38
251             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)
252             t0 := sbox_partial(t0, q)
253             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
254             // round 39
255             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)
256             t0 := sbox_partial(t0, q)
257             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
258             // round 40
259             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)
260             t0 := sbox_partial(t0, q)
261             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
262             // round 41
263             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)
264             t0 := sbox_partial(t0, q)
265             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
266             // round 42
267             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)
268             t0 := sbox_partial(t0, q)
269             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
270             // round 43
271             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)
272             t0 := sbox_partial(t0, q)
273             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
274             // round 44
275             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)
276             t0 := sbox_partial(t0, q)
277             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
278             // round 45
279             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)
280             t0 := sbox_partial(t0, q)
281             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
282             // round 46
283             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)
284             t0 := sbox_partial(t0, q)
285             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
286             // round 47
287             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)
288             t0 := sbox_partial(t0, q)
289             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
290             // round 48
291             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)
292             t0 := sbox_partial(t0, q)
293             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
294             // round 49
295             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)
296             t0 := sbox_partial(t0, q)
297             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
298             // round 50
299             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)
300             t0 := sbox_partial(t0, q)
301             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
302             // round 51
303             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)
304             t0 := sbox_partial(t0, q)
305             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
306             // round 52
307             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)
308             t0 := sbox_partial(t0, q)
309             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
310             // round 53
311             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)
312             t0 := sbox_partial(t0, q)
313             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
314             // round 54
315             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)
316             t0 := sbox_partial(t0, q)
317             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
318             // round 55
319             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)
320             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
321             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
322             // round 56
323             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)
324             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
325             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
326             // round 57
327             t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)
328             t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)
329             t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)
330         }
331         return t0;
332     }
333 
334     function hash_t5f6p52(HashInputs5 memory i, uint q) internal pure returns (uint)
335     {
336         // validate inputs
337         require(i.t0 < q, "INVALID_INPUT");
338         require(i.t1 < q, "INVALID_INPUT");
339         require(i.t2 < q, "INVALID_INPUT");
340         require(i.t3 < q, "INVALID_INPUT");
341         require(i.t4 < q, "INVALID_INPUT");
342 
343         return hash_t5f6p52_internal(i.t0, i.t1, i.t2, i.t3, i.t4, q);
344     }
345 
346 
347     //
348     // hash_t7f6p52
349     //
350 
351     struct HashInputs7
352     {
353         uint t0;
354         uint t1;
355         uint t2;
356         uint t3;
357         uint t4;
358         uint t5;
359         uint t6;
360     }
361 
362     function mix(HashInputs7 memory i, uint q) internal pure
363     {
364         HashInputs7 memory o;
365         o.t0 = mulmod(i.t0, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q);
366         o.t0 = addmod(o.t0, mulmod(i.t1, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q);
367         o.t0 = addmod(o.t0, mulmod(i.t2, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q);
368         o.t0 = addmod(o.t0, mulmod(i.t3, 12968540216479938138647596899147650021419273189336843725176422194136033835172, q), q);
369         o.t0 = addmod(o.t0, mulmod(i.t4, 3636162562566338420490575570584278737093584021456168183289112789616069756675, q), q);
370         o.t0 = addmod(o.t0, mulmod(i.t5, 8949952361235797771659501126471156178804092479420606597426318793013844305422, q), q);
371         o.t0 = addmod(o.t0, mulmod(i.t6, 13586657904816433080148729258697725609063090799921401830545410130405357110367, q), q);
372         o.t1 = mulmod(i.t0, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q);
373         o.t1 = addmod(o.t1, mulmod(i.t1, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q);
374         o.t1 = addmod(o.t1, mulmod(i.t2, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q);
375         o.t1 = addmod(o.t1, mulmod(i.t3, 10468644849657689537028565510142839489302836569811003546969773105463051947124, q), q);
376         o.t1 = addmod(o.t1, mulmod(i.t4, 3328913364598498171733622353010907641674136720305714432354138807013088636408, q), q);
377         o.t1 = addmod(o.t1, mulmod(i.t5, 8642889650254799419576843603477253661899356105675006557919250564400804756641, q), q);
378         o.t1 = addmod(o.t1, mulmod(i.t6, 14300697791556510113764686242794463641010174685800128469053974698256194076125, q), q);
379         o.t2 = mulmod(i.t0, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q);
380         o.t2 = addmod(o.t2, mulmod(i.t1, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q);
381         o.t2 = addmod(o.t2, mulmod(i.t2, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q);
382         o.t2 = addmod(o.t2, mulmod(i.t3, 17049854690034965250221386317058877242629221002521630573756355118745574274967, q), q);
383         o.t2 = addmod(o.t2, mulmod(i.t4, 4964394613021008685803675656098849539153699842663541444414978877928878266244, q), q);
384         o.t2 = addmod(o.t2, mulmod(i.t5, 15474947305445649466370538888925567099067120578851553103424183520405650587995, q), q);
385         o.t2 = addmod(o.t2, mulmod(i.t6, 1016119095639665978105768933448186152078842964810837543326777554729232767846, q), q);
386         o.t3 = mulmod(i.t0, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q);
387         o.t3 = addmod(o.t3, mulmod(i.t1, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q);
388         o.t3 = addmod(o.t3, mulmod(i.t2, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q);
389         o.t3 = addmod(o.t3, mulmod(i.t3, 6905514380186323693285869145872115273350947784558995755916362330070690839131, q), q);
390         o.t3 = addmod(o.t3, mulmod(i.t4, 4783343257810358393326889022942241108539824540285247795235499223017138301952, q), q);
391         o.t3 = addmod(o.t3, mulmod(i.t5, 1420772902128122367335354247676760257656541121773854204774788519230732373317, q), q);
392         o.t3 = addmod(o.t3, mulmod(i.t6, 14172871439045259377975734198064051992755748777535789572469924335100006948373, q), q);
393         o.t4 = mulmod(i.t0, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q);
394         o.t4 = addmod(o.t4, mulmod(i.t1, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q);
395         o.t4 = addmod(o.t4, mulmod(i.t2, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q);
396         o.t4 = addmod(o.t4, mulmod(i.t3, 13001155522144542028910638547179410124467185319212645031214919884423841839406, q), q);
397         o.t4 = addmod(o.t4, mulmod(i.t4, 16037892369576300958623292723740289861626299352695838577330319504984091062115, q), q);
398         o.t4 = addmod(o.t4, mulmod(i.t5, 19189494548480259335554606182055502469831573298885662881571444557262020106898, q), q);
399         o.t4 = addmod(o.t4, mulmod(i.t6, 19032687447778391106390582750185144485341165205399984747451318330476859342654, q), q);
400         o.t5 = mulmod(i.t0, 13272957914179340594010910867091459756043436017766464331915862093201960540910, q);
401         o.t5 = addmod(o.t5, mulmod(i.t1, 9416416589114508529880440146952102328470363729880726115521103179442988482948, q), q);
402         o.t5 = addmod(o.t5, mulmod(i.t2, 8035240799672199706102747147502951589635001418759394863664434079699838251138, q), q);
403         o.t5 = addmod(o.t5, mulmod(i.t3, 21642389080762222565487157652540372010968704000567605990102641816691459811717, q), q);
404         o.t5 = addmod(o.t5, mulmod(i.t4, 20261355950827657195644012399234591122288573679402601053407151083849785332516, q), q);
405         o.t5 = addmod(o.t5, mulmod(i.t5, 14514189384576734449268559374569145463190040567900950075547616936149781403109, q), q);
406         o.t5 = addmod(o.t5, mulmod(i.t6, 19038036134886073991945204537416211699632292792787812530208911676638479944765, q), q);
407         o.t6 = mulmod(i.t0, 15627836782263662543041758927100784213807648787083018234961118439434298020664, q);
408         o.t6 = addmod(o.t6, mulmod(i.t1, 5655785191024506056588710805596292231240948371113351452712848652644610823632, q), q);
409         o.t6 = addmod(o.t6, mulmod(i.t2, 8265264721707292643644260517162050867559314081394556886644673791575065394002, q), q);
410         o.t6 = addmod(o.t6, mulmod(i.t3, 17151144681903609082202835646026478898625761142991787335302962548605510241586, q), q);
411         o.t6 = addmod(o.t6, mulmod(i.t4, 18731644709777529787185361516475509623264209648904603914668024590231177708831, q), q);
412         o.t6 = addmod(o.t6, mulmod(i.t5, 20697789991623248954020701081488146717484139720322034504511115160686216223641, q), q);
413         o.t6 = addmod(o.t6, mulmod(i.t6, 6200020095464686209289974437830528853749866001482481427982839122465470640886, q), q);
414         i.t0 = o.t0;
415         i.t1 = o.t1;
416         i.t2 = o.t2;
417         i.t3 = o.t3;
418         i.t4 = o.t4;
419         i.t5 = o.t5;
420         i.t6 = o.t6;
421     }
422 
423     function ark(HashInputs7 memory i, uint q, uint c) internal pure
424     {
425         HashInputs7 memory o;
426         o.t0 = addmod(i.t0, c, q);
427         o.t1 = addmod(i.t1, c, q);
428         o.t2 = addmod(i.t2, c, q);
429         o.t3 = addmod(i.t3, c, q);
430         o.t4 = addmod(i.t4, c, q);
431         o.t5 = addmod(i.t5, c, q);
432         o.t6 = addmod(i.t6, c, q);
433         i.t0 = o.t0;
434         i.t1 = o.t1;
435         i.t2 = o.t2;
436         i.t3 = o.t3;
437         i.t4 = o.t4;
438         i.t5 = o.t5;
439         i.t6 = o.t6;
440     }
441 
442     function sbox_full(HashInputs7 memory i, uint q) internal pure
443     {
444         HashInputs7 memory o;
445         o.t0 = mulmod(i.t0, i.t0, q);
446         o.t0 = mulmod(o.t0, o.t0, q);
447         o.t0 = mulmod(i.t0, o.t0, q);
448         o.t1 = mulmod(i.t1, i.t1, q);
449         o.t1 = mulmod(o.t1, o.t1, q);
450         o.t1 = mulmod(i.t1, o.t1, q);
451         o.t2 = mulmod(i.t2, i.t2, q);
452         o.t2 = mulmod(o.t2, o.t2, q);
453         o.t2 = mulmod(i.t2, o.t2, q);
454         o.t3 = mulmod(i.t3, i.t3, q);
455         o.t3 = mulmod(o.t3, o.t3, q);
456         o.t3 = mulmod(i.t3, o.t3, q);
457         o.t4 = mulmod(i.t4, i.t4, q);
458         o.t4 = mulmod(o.t4, o.t4, q);
459         o.t4 = mulmod(i.t4, o.t4, q);
460         o.t5 = mulmod(i.t5, i.t5, q);
461         o.t5 = mulmod(o.t5, o.t5, q);
462         o.t5 = mulmod(i.t5, o.t5, q);
463         o.t6 = mulmod(i.t6, i.t6, q);
464         o.t6 = mulmod(o.t6, o.t6, q);
465         o.t6 = mulmod(i.t6, o.t6, q);
466         i.t0 = o.t0;
467         i.t1 = o.t1;
468         i.t2 = o.t2;
469         i.t3 = o.t3;
470         i.t4 = o.t4;
471         i.t5 = o.t5;
472         i.t6 = o.t6;
473     }
474 
475     function sbox_partial(HashInputs7 memory i, uint q) internal pure
476     {
477         HashInputs7 memory o;
478         o.t0 = mulmod(i.t0, i.t0, q);
479         o.t0 = mulmod(o.t0, o.t0, q);
480         o.t0 = mulmod(i.t0, o.t0, q);
481         i.t0 = o.t0;
482     }
483 
484     function hash_t7f6p52(HashInputs7 memory i, uint q) internal pure returns (uint)
485     {
486         // validate inputs
487         require(i.t0 < q, "INVALID_INPUT");
488         require(i.t1 < q, "INVALID_INPUT");
489         require(i.t2 < q, "INVALID_INPUT");
490         require(i.t3 < q, "INVALID_INPUT");
491         require(i.t4 < q, "INVALID_INPUT");
492         require(i.t5 < q, "INVALID_INPUT");
493         require(i.t6 < q, "INVALID_INPUT");
494 
495         // round 0
496         ark(i, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522);
497         sbox_full(i, q);
498         mix(i, q);
499         // round 1
500         ark(i, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128);
501         sbox_full(i, q);
502         mix(i, q);
503         // round 2
504         ark(i, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509);
505         sbox_full(i, q);
506         mix(i, q);
507         // round 3
508         ark(i, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615);
509         sbox_partial(i, q);
510         mix(i, q);
511         // round 4
512         ark(i, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514);
513         sbox_partial(i, q);
514         mix(i, q);
515         // round 5
516         ark(i, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619);
517         sbox_partial(i, q);
518         mix(i, q);
519         // round 6
520         ark(i, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153);
521         sbox_partial(i, q);
522         mix(i, q);
523         // round 7
524         ark(i, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608);
525         sbox_partial(i, q);
526         mix(i, q);
527         // round 8
528         ark(i, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567);
529         sbox_partial(i, q);
530         mix(i, q);
531         // round 9
532         ark(i, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471);
533         sbox_partial(i, q);
534         mix(i, q);
535         // round 10
536         ark(i, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765);
537         sbox_partial(i, q);
538         mix(i, q);
539         // round 11
540         ark(i, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772);
541         sbox_partial(i, q);
542         mix(i, q);
543         // round 12
544         ark(i, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850);
545         sbox_partial(i, q);
546         mix(i, q);
547         // round 13
548         ark(i, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375);
549         sbox_partial(i, q);
550         mix(i, q);
551         // round 14
552         ark(i, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136);
553         sbox_partial(i, q);
554         mix(i, q);
555         // round 15
556         ark(i, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374);
557         sbox_partial(i, q);
558         mix(i, q);
559         // round 16
560         ark(i, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107);
561         sbox_partial(i, q);
562         mix(i, q);
563         // round 17
564         ark(i, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214);
565         sbox_partial(i, q);
566         mix(i, q);
567         // round 18
568         ark(i, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455);
569         sbox_partial(i, q);
570         mix(i, q);
571         // round 19
572         ark(i, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212);
573         sbox_partial(i, q);
574         mix(i, q);
575         // round 20
576         ark(i, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626);
577         sbox_partial(i, q);
578         mix(i, q);
579         // round 21
580         ark(i, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417);
581         sbox_partial(i, q);
582         mix(i, q);
583         // round 22
584         ark(i, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006);
585         sbox_partial(i, q);
586         mix(i, q);
587         // round 23
588         ark(i, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766);
589         sbox_partial(i, q);
590         mix(i, q);
591         // round 24
592         ark(i, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832);
593         sbox_partial(i, q);
594         mix(i, q);
595         // round 25
596         ark(i, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231);
597         sbox_partial(i, q);
598         mix(i, q);
599         // round 26
600         ark(i, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114);
601         sbox_partial(i, q);
602         mix(i, q);
603         // round 27
604         ark(i, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719);
605         sbox_partial(i, q);
606         mix(i, q);
607         // round 28
608         ark(i, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018);
609         sbox_partial(i, q);
610         mix(i, q);
611         // round 29
612         ark(i, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562);
613         sbox_partial(i, q);
614         mix(i, q);
615         // round 30
616         ark(i, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826);
617         sbox_partial(i, q);
618         mix(i, q);
619         // round 31
620         ark(i, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245);
621         sbox_partial(i, q);
622         mix(i, q);
623         // round 32
624         ark(i, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748);
625         sbox_partial(i, q);
626         mix(i, q);
627         // round 33
628         ark(i, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508);
629         sbox_partial(i, q);
630         mix(i, q);
631         // round 34
632         ark(i, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523);
633         sbox_partial(i, q);
634         mix(i, q);
635         // round 35
636         ark(i, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410);
637         sbox_partial(i, q);
638         mix(i, q);
639         // round 36
640         ark(i, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935);
641         sbox_partial(i, q);
642         mix(i, q);
643         // round 37
644         ark(i, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643);
645         sbox_partial(i, q);
646         mix(i, q);
647         // round 38
648         ark(i, q, 71447649211767888770311304010816315780740050029903404046389165015534756512);
649         sbox_partial(i, q);
650         mix(i, q);
651         // round 39
652         ark(i, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393);
653         sbox_partial(i, q);
654         mix(i, q);
655         // round 40
656         ark(i, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525);
657         sbox_partial(i, q);
658         mix(i, q);
659         // round 41
660         ark(i, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006);
661         sbox_partial(i, q);
662         mix(i, q);
663         // round 42
664         ark(i, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058);
665         sbox_partial(i, q);
666         mix(i, q);
667         // round 43
668         ark(i, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739);
669         sbox_partial(i, q);
670         mix(i, q);
671         // round 44
672         ark(i, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548);
673         sbox_partial(i, q);
674         mix(i, q);
675         // round 45
676         ark(i, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311);
677         sbox_partial(i, q);
678         mix(i, q);
679         // round 46
680         ark(i, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208);
681         sbox_partial(i, q);
682         mix(i, q);
683         // round 47
684         ark(i, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706);
685         sbox_partial(i, q);
686         mix(i, q);
687         // round 48
688         ark(i, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232);
689         sbox_partial(i, q);
690         mix(i, q);
691         // round 49
692         ark(i, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524);
693         sbox_partial(i, q);
694         mix(i, q);
695         // round 50
696         ark(i, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266);
697         sbox_partial(i, q);
698         mix(i, q);
699         // round 51
700         ark(i, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210);
701         sbox_partial(i, q);
702         mix(i, q);
703         // round 52
704         ark(i, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743);
705         sbox_partial(i, q);
706         mix(i, q);
707         // round 53
708         ark(i, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373);
709         sbox_partial(i, q);
710         mix(i, q);
711         // round 54
712         ark(i, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849);
713         sbox_partial(i, q);
714         mix(i, q);
715         // round 55
716         ark(i, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076);
717         sbox_full(i, q);
718         mix(i, q);
719         // round 56
720         ark(i, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047);
721         sbox_full(i, q);
722         mix(i, q);
723         // round 57
724         ark(i, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544);
725         sbox_full(i, q);
726         mix(i, q);
727 
728         return i.t0;
729     }
730 }
731 
732 // Copyright 2017 Loopring Technology Limited.
733 
734 
735 
736 /// @title Utility Functions for uint
737 /// @author Daniel Wang - <daniel@loopring.org>
738 library MathUint
739 {
740     using MathUint for uint;
741 
742     function mul(
743         uint a,
744         uint b
745         )
746         internal
747         pure
748         returns (uint c)
749     {
750         c = a * b;
751         require(a == 0 || c / a == b, "MUL_OVERFLOW");
752     }
753 
754     function sub(
755         uint a,
756         uint b
757         )
758         internal
759         pure
760         returns (uint)
761     {
762         require(b <= a, "SUB_UNDERFLOW");
763         return a - b;
764     }
765 
766     function add(
767         uint a,
768         uint b
769         )
770         internal
771         pure
772         returns (uint c)
773     {
774         c = a + b;
775         require(c >= a, "ADD_OVERFLOW");
776     }
777 
778     function add64(
779         uint64 a,
780         uint64 b
781         )
782         internal
783         pure
784         returns (uint64 c)
785     {
786         c = a + b;
787         require(c >= a, "ADD_OVERFLOW");
788     }
789 }
790 
791 // Copyright 2017 Loopring Technology Limited.
792 
793 
794 
795 /// @title ERC20 safe transfer
796 /// @dev see https://github.com/sec-bit/badERC20Fix
797 /// @author Brecht Devos - <brecht@loopring.org>
798 library ERC20SafeTransfer
799 {
800     function safeTransferAndVerify(
801         address token,
802         address to,
803         uint    value
804         )
805         internal
806     {
807         safeTransferWithGasLimitAndVerify(
808             token,
809             to,
810             value,
811             gasleft()
812         );
813     }
814 
815     function safeTransfer(
816         address token,
817         address to,
818         uint    value
819         )
820         internal
821         returns (bool)
822     {
823         return safeTransferWithGasLimit(
824             token,
825             to,
826             value,
827             gasleft()
828         );
829     }
830 
831     function safeTransferWithGasLimitAndVerify(
832         address token,
833         address to,
834         uint    value,
835         uint    gasLimit
836         )
837         internal
838     {
839         require(
840             safeTransferWithGasLimit(token, to, value, gasLimit),
841             "TRANSFER_FAILURE"
842         );
843     }
844 
845     function safeTransferWithGasLimit(
846         address token,
847         address to,
848         uint    value,
849         uint    gasLimit
850         )
851         internal
852         returns (bool)
853     {
854         // A transfer is successful when 'call' is successful and depending on the token:
855         // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)
856         // - A single boolean is returned: this boolean needs to be true (non-zero)
857 
858         // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb
859         bytes memory callData = abi.encodeWithSelector(
860             bytes4(0xa9059cbb),
861             to,
862             value
863         );
864         (bool success, ) = token.call{gas: gasLimit}(callData);
865         return checkReturnValue(success);
866     }
867 
868     function safeTransferFromAndVerify(
869         address token,
870         address from,
871         address to,
872         uint    value
873         )
874         internal
875     {
876         safeTransferFromWithGasLimitAndVerify(
877             token,
878             from,
879             to,
880             value,
881             gasleft()
882         );
883     }
884 
885     function safeTransferFrom(
886         address token,
887         address from,
888         address to,
889         uint    value
890         )
891         internal
892         returns (bool)
893     {
894         return safeTransferFromWithGasLimit(
895             token,
896             from,
897             to,
898             value,
899             gasleft()
900         );
901     }
902 
903     function safeTransferFromWithGasLimitAndVerify(
904         address token,
905         address from,
906         address to,
907         uint    value,
908         uint    gasLimit
909         )
910         internal
911     {
912         bool result = safeTransferFromWithGasLimit(
913             token,
914             from,
915             to,
916             value,
917             gasLimit
918         );
919         require(result, "TRANSFER_FAILURE");
920     }
921 
922     function safeTransferFromWithGasLimit(
923         address token,
924         address from,
925         address to,
926         uint    value,
927         uint    gasLimit
928         )
929         internal
930         returns (bool)
931     {
932         // A transferFrom is successful when 'call' is successful and depending on the token:
933         // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)
934         // - A single boolean is returned: this boolean needs to be true (non-zero)
935 
936         // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd
937         bytes memory callData = abi.encodeWithSelector(
938             bytes4(0x23b872dd),
939             from,
940             to,
941             value
942         );
943         (bool success, ) = token.call{gas: gasLimit}(callData);
944         return checkReturnValue(success);
945     }
946 
947     function checkReturnValue(
948         bool success
949         )
950         internal
951         pure
952         returns (bool)
953     {
954         // A transfer/transferFrom is successful when 'call' is successful and depending on the token:
955         // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)
956         // - A single boolean is returned: this boolean needs to be true (non-zero)
957         if (success) {
958             assembly {
959                 switch returndatasize()
960                 // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded
961                 case 0 {
962                     success := 1
963                 }
964                 // Standard ERC20: a single boolean value is returned which needs to be true
965                 case 32 {
966                     returndatacopy(0, 0, 32)
967                     success := mload(0)
968                 }
969                 // None of the above: not successful
970                 default {
971                     success := 0
972                 }
973             }
974         }
975         return success;
976     }
977 }
978 // Copyright 2017 Loopring Technology Limited.
979 
980 pragma experimental ABIEncoderV2;
981 
982 
983 
984 
985 
986 
987 
988 /// @title ExchangeTokens.
989 /// @author Daniel Wang  - <daniel@loopring.org>
990 /// @author Brecht Devos - <brecht@loopring.org>
991 library ExchangeTokens
992 {
993     using MathUint          for uint;
994     using ERC20SafeTransfer for address;
995     using ExchangeMode      for ExchangeData.State;
996 
997     event TokenRegistered(
998         address token,
999         uint16  tokenId
1000     );
1001 
1002     function getTokenAddress(
1003         ExchangeData.State storage S,
1004         uint16 tokenID
1005         )
1006         public
1007         view
1008         returns (address)
1009     {
1010         require(tokenID < S.tokens.length, "INVALID_TOKEN_ID");
1011         return S.tokens[tokenID].token;
1012     }
1013 
1014     function registerToken(
1015         ExchangeData.State storage S,
1016         address tokenAddress
1017         )
1018         public
1019         returns (uint16 tokenID)
1020     {
1021         require(!S.isInWithdrawalMode(), "INVALID_MODE");
1022         require(S.tokenToTokenId[tokenAddress] == 0, "TOKEN_ALREADY_EXIST");
1023         require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS(), "TOKEN_REGISTRY_FULL");
1024 
1025         if (S.depositContract != IDepositContract(0)) {
1026             require(
1027                 S.depositContract.isTokenSupported(tokenAddress),
1028                 "UNSUPPORTED_TOKEN"
1029             );
1030         }
1031 
1032         ExchangeData.Token memory token = ExchangeData.Token(
1033             tokenAddress
1034         );
1035         tokenID = uint16(S.tokens.length);
1036         S.tokens.push(token);
1037         S.tokenToTokenId[tokenAddress] = tokenID + 1;
1038 
1039         emit TokenRegistered(tokenAddress, tokenID);
1040     }
1041 
1042     function getTokenID(
1043         ExchangeData.State storage S,
1044         address tokenAddress
1045         )
1046         internal  // inline call
1047         view
1048         returns (uint16 tokenID)
1049     {
1050         tokenID = S.tokenToTokenId[tokenAddress];
1051         require(tokenID != 0, "TOKEN_NOT_FOUND");
1052         tokenID = tokenID - 1;
1053     }
1054 }
1055 
1056 // Copyright 2017 Loopring Technology Limited.
1057 
1058 
1059 
1060 
1061 
1062 
1063 
1064 
1065 /// @title ExchangeBalances.
1066 /// @author Daniel Wang  - <daniel@loopring.org>
1067 /// @author Brecht Devos - <brecht@loopring.org>
1068 library ExchangeBalances
1069 {
1070     using MathUint  for uint;
1071 
1072     function verifyAccountBalance(
1073         uint                              merkleRoot,
1074         ExchangeData.MerkleProof calldata merkleProof
1075         )
1076         public
1077         pure
1078     {
1079         require(
1080             isAccountBalanceCorrect(merkleRoot, merkleProof),
1081             "INVALID_MERKLE_TREE_DATA"
1082         );
1083     }
1084 
1085     function isAccountBalanceCorrect(
1086         uint                            merkleRoot,
1087         ExchangeData.MerkleProof memory merkleProof
1088         )
1089         public
1090         pure
1091         returns (bool)
1092     {
1093         // Verify data
1094         uint calculatedRoot = getBalancesRoot(
1095             merkleProof.balanceLeaf.tokenID,
1096             merkleProof.balanceLeaf.balance,
1097             merkleProof.balanceLeaf.weightAMM,
1098             merkleProof.balanceLeaf.storageRoot,
1099             merkleProof.balanceMerkleProof
1100         );
1101         calculatedRoot = getAccountInternalsRoot(
1102             merkleProof.accountLeaf.accountID,
1103             merkleProof.accountLeaf.owner,
1104             merkleProof.accountLeaf.pubKeyX,
1105             merkleProof.accountLeaf.pubKeyY,
1106             merkleProof.accountLeaf.nonce,
1107             merkleProof.accountLeaf.feeBipsAMM,
1108             calculatedRoot,
1109             merkleProof.accountMerkleProof
1110         );
1111         return (calculatedRoot == merkleRoot);
1112     }
1113 
1114     function getBalancesRoot(
1115         uint16   tokenID,
1116         uint     balance,
1117         uint     weightAMM,
1118         uint     storageRoot,
1119         uint[24] memory balanceMerkleProof
1120         )
1121         private
1122         pure
1123         returns (uint)
1124     {
1125         uint balanceItem = hashImpl(balance, weightAMM, storageRoot, 0);
1126         uint _id = tokenID;
1127         for (uint depth = 0; depth < 8; depth++) {
1128             uint base = depth * 3;
1129             if (_id & 3 == 0) {
1130                 balanceItem = hashImpl(
1131                     balanceItem,
1132                     balanceMerkleProof[base],
1133                     balanceMerkleProof[base + 1],
1134                     balanceMerkleProof[base + 2]
1135                 );
1136             } else if (_id & 3 == 1) {
1137                 balanceItem = hashImpl(
1138                     balanceMerkleProof[base],
1139                     balanceItem,
1140                     balanceMerkleProof[base + 1],
1141                     balanceMerkleProof[base + 2]
1142                 );
1143             } else if (_id & 3 == 2) {
1144                 balanceItem = hashImpl(
1145                     balanceMerkleProof[base],
1146                     balanceMerkleProof[base + 1],
1147                     balanceItem,
1148                     balanceMerkleProof[base + 2]
1149                 );
1150             } else if (_id & 3 == 3) {
1151                 balanceItem = hashImpl(
1152                     balanceMerkleProof[base],
1153                     balanceMerkleProof[base + 1],
1154                     balanceMerkleProof[base + 2],
1155                     balanceItem
1156                 );
1157             }
1158             _id = _id >> 2;
1159         }
1160         return balanceItem;
1161     }
1162 
1163     function getAccountInternalsRoot(
1164         uint32   accountID,
1165         address  owner,
1166         uint     pubKeyX,
1167         uint     pubKeyY,
1168         uint     nonce,
1169         uint     feeBipsAMM,
1170         uint     balancesRoot,
1171         uint[48] memory accountMerkleProof
1172         )
1173         private
1174         pure
1175         returns (uint)
1176     {
1177         uint accountItem = hashAccountLeaf(uint(owner), pubKeyX, pubKeyY, nonce, feeBipsAMM, balancesRoot);
1178         uint _id = accountID;
1179         for (uint depth = 0; depth < 16; depth++) {
1180             uint base = depth * 3;
1181             if (_id & 3 == 0) {
1182                 accountItem = hashImpl(
1183                     accountItem,
1184                     accountMerkleProof[base],
1185                     accountMerkleProof[base + 1],
1186                     accountMerkleProof[base + 2]
1187                 );
1188             } else if (_id & 3 == 1) {
1189                 accountItem = hashImpl(
1190                     accountMerkleProof[base],
1191                     accountItem,
1192                     accountMerkleProof[base + 1],
1193                     accountMerkleProof[base + 2]
1194                 );
1195             } else if (_id & 3 == 2) {
1196                 accountItem = hashImpl(
1197                     accountMerkleProof[base],
1198                     accountMerkleProof[base + 1],
1199                     accountItem,
1200                     accountMerkleProof[base + 2]
1201                 );
1202             } else if (_id & 3 == 3) {
1203                 accountItem = hashImpl(
1204                     accountMerkleProof[base],
1205                     accountMerkleProof[base + 1],
1206                     accountMerkleProof[base + 2],
1207                     accountItem
1208                 );
1209             }
1210             _id = _id >> 2;
1211         }
1212         return accountItem;
1213     }
1214 
1215     function hashAccountLeaf(
1216         uint t0,
1217         uint t1,
1218         uint t2,
1219         uint t3,
1220         uint t4,
1221         uint t5
1222         )
1223         public
1224         pure
1225         returns (uint)
1226     {
1227         Poseidon.HashInputs7 memory inputs = Poseidon.HashInputs7(t0, t1, t2, t3, t4, t5, 0);
1228         return Poseidon.hash_t7f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD());
1229     }
1230 
1231     function hashImpl(
1232         uint t0,
1233         uint t1,
1234         uint t2,
1235         uint t3
1236         )
1237         private
1238         pure
1239         returns (uint)
1240     {
1241         Poseidon.HashInputs5 memory inputs = Poseidon.HashInputs5(t0, t1, t2, t3, 0);
1242         return Poseidon.hash_t5f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD());
1243     }
1244 }
1245 
1246 //Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol
1247 
1248 
1249 library BytesUtil {
1250 
1251     function concat(
1252         bytes memory _preBytes,
1253         bytes memory _postBytes
1254     )
1255         internal
1256         pure
1257         returns (bytes memory)
1258     {
1259         bytes memory tempBytes;
1260 
1261         assembly {
1262             // Get a location of some free memory and store it in tempBytes as
1263             // Solidity does for memory variables.
1264             tempBytes := mload(0x40)
1265 
1266             // Store the length of the first bytes array at the beginning of
1267             // the memory for tempBytes.
1268             let length := mload(_preBytes)
1269             mstore(tempBytes, length)
1270 
1271             // Maintain a memory counter for the current write location in the
1272             // temp bytes array by adding the 32 bytes for the array length to
1273             // the starting location.
1274             let mc := add(tempBytes, 0x20)
1275             // Stop copying when the memory counter reaches the length of the
1276             // first bytes array.
1277             let end := add(mc, length)
1278 
1279             for {
1280                 // Initialize a copy counter to the start of the _preBytes data,
1281                 // 32 bytes into its memory.
1282                 let cc := add(_preBytes, 0x20)
1283             } lt(mc, end) {
1284                 // Increase both counters by 32 bytes each iteration.
1285                 mc := add(mc, 0x20)
1286                 cc := add(cc, 0x20)
1287             } {
1288                 // Write the _preBytes data into the tempBytes memory 32 bytes
1289                 // at a time.
1290                 mstore(mc, mload(cc))
1291             }
1292 
1293             // Add the length of _postBytes to the current length of tempBytes
1294             // and store it as the new length in the first 32 bytes of the
1295             // tempBytes memory.
1296             length := mload(_postBytes)
1297             mstore(tempBytes, add(length, mload(tempBytes)))
1298 
1299             // Move the memory counter back from a multiple of 0x20 to the
1300             // actual end of the _preBytes data.
1301             mc := end
1302             // Stop copying when the memory counter reaches the new combined
1303             // length of the arrays.
1304             end := add(mc, length)
1305 
1306             for {
1307                 let cc := add(_postBytes, 0x20)
1308             } lt(mc, end) {
1309                 mc := add(mc, 0x20)
1310                 cc := add(cc, 0x20)
1311             } {
1312                 mstore(mc, mload(cc))
1313             }
1314 
1315             // Update the free-memory pointer by padding our last write location
1316             // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
1317             // next 32 byte block, then round down to the nearest multiple of
1318             // 32. If the sum of the length of the two arrays is zero then add
1319             // one before rounding down to leave a blank 32 bytes (the length block with 0).
1320             mstore(0x40, and(
1321               add(add(end, iszero(add(length, mload(_preBytes)))), 31),
1322               not(31) // Round down to the nearest 32 bytes.
1323             ))
1324         }
1325 
1326         return tempBytes;
1327     }
1328 
1329     function slice(
1330         bytes memory _bytes,
1331         uint _start,
1332         uint _length
1333     )
1334         internal
1335         pure
1336         returns (bytes memory)
1337     {
1338         require(_bytes.length >= (_start + _length));
1339 
1340         bytes memory tempBytes;
1341 
1342         assembly {
1343             switch iszero(_length)
1344             case 0 {
1345                 // Get a location of some free memory and store it in tempBytes as
1346                 // Solidity does for memory variables.
1347                 tempBytes := mload(0x40)
1348 
1349                 // The first word of the slice result is potentially a partial
1350                 // word read from the original array. To read it, we calculate
1351                 // the length of that partial word and start copying that many
1352                 // bytes into the array. The first word we copy will start with
1353                 // data we don't care about, but the last `lengthmod` bytes will
1354                 // land at the beginning of the contents of the new array. When
1355                 // we're done copying, we overwrite the full first word with
1356                 // the actual length of the slice.
1357                 let lengthmod := and(_length, 31)
1358 
1359                 // The multiplication in the next line is necessary
1360                 // because when slicing multiples of 32 bytes (lengthmod == 0)
1361                 // the following copy loop was copying the origin's length
1362                 // and then ending prematurely not copying everything it should.
1363                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
1364                 let end := add(mc, _length)
1365 
1366                 for {
1367                     // The multiplication in the next line has the same exact purpose
1368                     // as the one above.
1369                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
1370                 } lt(mc, end) {
1371                     mc := add(mc, 0x20)
1372                     cc := add(cc, 0x20)
1373                 } {
1374                     mstore(mc, mload(cc))
1375                 }
1376 
1377                 mstore(tempBytes, _length)
1378 
1379                 //update free-memory pointer
1380                 //allocating the array padded to 32 bytes like the compiler does now
1381                 mstore(0x40, and(add(mc, 31), not(31)))
1382             }
1383             //if we want a zero-length slice let's just return a zero-length array
1384             default {
1385                 tempBytes := mload(0x40)
1386 
1387                 mstore(0x40, add(tempBytes, 0x20))
1388             }
1389         }
1390 
1391         return tempBytes;
1392     }
1393 
1394     function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {
1395         require(_bytes.length >= (_start + 20));
1396         address tempAddress;
1397 
1398         assembly {
1399             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
1400         }
1401 
1402         return tempAddress;
1403     }
1404 
1405     function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {
1406         require(_bytes.length >= (_start + 1));
1407         uint8 tempUint;
1408 
1409         assembly {
1410             tempUint := mload(add(add(_bytes, 0x1), _start))
1411         }
1412 
1413         return tempUint;
1414     }
1415 
1416     function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {
1417         require(_bytes.length >= (_start + 2));
1418         uint16 tempUint;
1419 
1420         assembly {
1421             tempUint := mload(add(add(_bytes, 0x2), _start))
1422         }
1423 
1424         return tempUint;
1425     }
1426 
1427     function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {
1428         require(_bytes.length >= (_start + 3));
1429         uint24 tempUint;
1430 
1431         assembly {
1432             tempUint := mload(add(add(_bytes, 0x3), _start))
1433         }
1434 
1435         return tempUint;
1436     }
1437 
1438     function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {
1439         require(_bytes.length >= (_start + 4));
1440         uint32 tempUint;
1441 
1442         assembly {
1443             tempUint := mload(add(add(_bytes, 0x4), _start))
1444         }
1445 
1446         return tempUint;
1447     }
1448 
1449     function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {
1450         require(_bytes.length >= (_start + 8));
1451         uint64 tempUint;
1452 
1453         assembly {
1454             tempUint := mload(add(add(_bytes, 0x8), _start))
1455         }
1456 
1457         return tempUint;
1458     }
1459 
1460     function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {
1461         require(_bytes.length >= (_start + 12));
1462         uint96 tempUint;
1463 
1464         assembly {
1465             tempUint := mload(add(add(_bytes, 0xc), _start))
1466         }
1467 
1468         return tempUint;
1469     }
1470 
1471     function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {
1472         require(_bytes.length >= (_start + 16));
1473         uint128 tempUint;
1474 
1475         assembly {
1476             tempUint := mload(add(add(_bytes, 0x10), _start))
1477         }
1478 
1479         return tempUint;
1480     }
1481 
1482     function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {
1483         require(_bytes.length >= (_start + 32));
1484         uint256 tempUint;
1485 
1486         assembly {
1487             tempUint := mload(add(add(_bytes, 0x20), _start))
1488         }
1489 
1490         return tempUint;
1491     }
1492 
1493     function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {
1494         require(_bytes.length >= (_start + 4));
1495         bytes4 tempBytes4;
1496 
1497         assembly {
1498             tempBytes4 := mload(add(add(_bytes, 0x20), _start))
1499         }
1500 
1501         return tempBytes4;
1502     }
1503 
1504     function toBytes20(bytes memory _bytes, uint _start) internal  pure returns (bytes20) {
1505         require(_bytes.length >= (_start + 20));
1506         bytes20 tempBytes20;
1507 
1508         assembly {
1509             tempBytes20 := mload(add(add(_bytes, 0x20), _start))
1510         }
1511 
1512         return tempBytes20;
1513     }
1514 
1515     function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {
1516         require(_bytes.length >= (_start + 32));
1517         bytes32 tempBytes32;
1518 
1519         assembly {
1520             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
1521         }
1522 
1523         return tempBytes32;
1524     }
1525 
1526     function fastSHA256(
1527         bytes memory data
1528         )
1529         internal
1530         view
1531         returns (bytes32)
1532     {
1533         bytes32[] memory result = new bytes32[](1);
1534         bool success;
1535         assembly {
1536              let ptr := add(data, 32)
1537              success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)
1538         }
1539         require(success, "SHA256_FAILED");
1540         return result[0];
1541     }
1542 }
1543 // Copyright 2017 Loopring Technology Limited.
1544 
1545 
1546 
1547 /// @title Utility Functions for addresses
1548 /// @author Daniel Wang - <daniel@loopring.org>
1549 /// @author Brecht Devos - <brecht@loopring.org>
1550 library AddressUtil
1551 {
1552     using AddressUtil for *;
1553 
1554     function isContract(
1555         address addr
1556         )
1557         internal
1558         view
1559         returns (bool)
1560     {
1561         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
1562         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
1563         // for accounts without code, i.e. `keccak256('')`
1564         bytes32 codehash;
1565         // solhint-disable-next-line no-inline-assembly
1566         assembly { codehash := extcodehash(addr) }
1567         return (codehash != 0x0 &&
1568                 codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);
1569     }
1570 
1571     function toPayable(
1572         address addr
1573         )
1574         internal
1575         pure
1576         returns (address payable)
1577     {
1578         return payable(addr);
1579     }
1580 
1581     // Works like address.send but with a customizable gas limit
1582     // Make sure your code is safe for reentrancy when using this function!
1583     function sendETH(
1584         address to,
1585         uint    amount,
1586         uint    gasLimit
1587         )
1588         internal
1589         returns (bool success)
1590     {
1591         if (amount == 0) {
1592             return true;
1593         }
1594         address payable recipient = to.toPayable();
1595         /* solium-disable-next-line */
1596         (success, ) = recipient.call{value: amount, gas: gasLimit}("");
1597     }
1598 
1599     // Works like address.transfer but with a customizable gas limit
1600     // Make sure your code is safe for reentrancy when using this function!
1601     function sendETHAndVerify(
1602         address to,
1603         uint    amount,
1604         uint    gasLimit
1605         )
1606         internal
1607         returns (bool success)
1608     {
1609         success = to.sendETH(amount, gasLimit);
1610         require(success, "TRANSFER_FAILURE");
1611     }
1612 
1613     // Works like call but is slightly more efficient when data
1614     // needs to be copied from memory to do the call.
1615     function fastCall(
1616         address to,
1617         uint    gasLimit,
1618         uint    value,
1619         bytes   memory data
1620         )
1621         internal
1622         returns (bool success, bytes memory returnData)
1623     {
1624         if (to != address(0)) {
1625             assembly {
1626                 // Do the call
1627                 success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)
1628                 // Copy the return data
1629                 let size := returndatasize()
1630                 returnData := mload(0x40)
1631                 mstore(returnData, size)
1632                 returndatacopy(add(returnData, 32), 0, size)
1633                 // Update free memory pointer
1634                 mstore(0x40, add(returnData, add(32, size)))
1635             }
1636         }
1637     }
1638 
1639     // Like fastCall, but throws when the call is unsuccessful.
1640     function fastCallAndVerify(
1641         address to,
1642         uint    gasLimit,
1643         uint    value,
1644         bytes   memory data
1645         )
1646         internal
1647         returns (bytes memory returnData)
1648     {
1649         bool success;
1650         (success, returnData) = fastCall(to, gasLimit, value, data);
1651         if (!success) {
1652             assembly {
1653                 revert(add(returnData, 32), mload(returnData))
1654             }
1655         }
1656     }
1657 }
1658 
1659 // Copyright 2017 Loopring Technology Limited.
1660 
1661 
1662 
1663 
1664 // Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol
1665 
1666 
1667 
1668 
1669 /**
1670  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
1671  * checks.
1672  *
1673  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
1674  * easily result in undesired exploitation or bugs, since developers usually
1675  * assume that overflows raise errors. `SafeCast` restores this intuition by
1676  * reverting the transaction when such an operation overflows.
1677  *
1678  * Using this library instead of the unchecked operations eliminates an entire
1679  * class of bugs, so it's recommended to use it always.
1680  *
1681  * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
1682  * all math on `uint256` and `int256` and then downcasting.
1683  */
1684 library SafeCast {
1685 
1686     /**
1687      * @dev Returns the downcasted uint128 from uint256, reverting on
1688      * overflow (when the input is greater than largest uint128).
1689      *
1690      * Counterpart to Solidity's `uint128` operator.
1691      *
1692      * Requirements:
1693      *
1694      * - input must fit into 128 bits
1695      */
1696     function toUint128(uint256 value) internal pure returns (uint128) {
1697         require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");
1698         return uint128(value);
1699     }
1700 
1701     /**
1702      * @dev Returns the downcasted uint96 from uint256, reverting on
1703      * overflow (when the input is greater than largest uint96).
1704      *
1705      * Counterpart to Solidity's `uint96` operator.
1706      *
1707      * Requirements:
1708      *
1709      * - input must fit into 96 bits
1710      */
1711     function toUint96(uint256 value) internal pure returns (uint96) {
1712         require(value < 2**96, "SafeCast: value doesn\'t fit in 96 bits");
1713         return uint96(value);
1714     }
1715 
1716     /**
1717      * @dev Returns the downcasted uint64 from uint256, reverting on
1718      * overflow (when the input is greater than largest uint64).
1719      *
1720      * Counterpart to Solidity's `uint64` operator.
1721      *
1722      * Requirements:
1723      *
1724      * - input must fit into 64 bits
1725      */
1726     function toUint64(uint256 value) internal pure returns (uint64) {
1727         require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");
1728         return uint64(value);
1729     }
1730 
1731     /**
1732      * @dev Returns the downcasted uint32 from uint256, reverting on
1733      * overflow (when the input is greater than largest uint32).
1734      *
1735      * Counterpart to Solidity's `uint32` operator.
1736      *
1737      * Requirements:
1738      *
1739      * - input must fit into 32 bits
1740      */
1741     function toUint32(uint256 value) internal pure returns (uint32) {
1742         require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");
1743         return uint32(value);
1744     }
1745 
1746     /**
1747      * @dev Returns the downcasted uint40 from uint256, reverting on
1748      * overflow (when the input is greater than largest uint40).
1749      *
1750      * Counterpart to Solidity's `uint32` operator.
1751      *
1752      * Requirements:
1753      *
1754      * - input must fit into 40 bits
1755      */
1756     function toUint40(uint256 value) internal pure returns (uint40) {
1757         require(value < 2**40, "SafeCast: value doesn\'t fit in 40 bits");
1758         return uint40(value);
1759     }
1760 
1761     /**
1762      * @dev Returns the downcasted uint16 from uint256, reverting on
1763      * overflow (when the input is greater than largest uint16).
1764      *
1765      * Counterpart to Solidity's `uint16` operator.
1766      *
1767      * Requirements:
1768      *
1769      * - input must fit into 16 bits
1770      */
1771     function toUint16(uint256 value) internal pure returns (uint16) {
1772         require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");
1773         return uint16(value);
1774     }
1775 
1776     /**
1777      * @dev Returns the downcasted uint8 from uint256, reverting on
1778      * overflow (when the input is greater than largest uint8).
1779      *
1780      * Counterpart to Solidity's `uint8` operator.
1781      *
1782      * Requirements:
1783      *
1784      * - input must fit into 8 bits.
1785      */
1786     function toUint8(uint256 value) internal pure returns (uint8) {
1787         require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");
1788         return uint8(value);
1789     }
1790 
1791     /**
1792      * @dev Converts a signed int256 into an unsigned uint256.
1793      *
1794      * Requirements:
1795      *
1796      * - input must be greater than or equal to 0.
1797      */
1798     function toUint256(int256 value) internal pure returns (uint256) {
1799         require(value >= 0, "SafeCast: value must be positive");
1800         return uint256(value);
1801     }
1802 
1803     /**
1804      * @dev Returns the downcasted int128 from int256, reverting on
1805      * overflow (when the input is less than smallest int128 or
1806      * greater than largest int128).
1807      *
1808      * Counterpart to Solidity's `int128` operator.
1809      *
1810      * Requirements:
1811      *
1812      * - input must fit into 128 bits
1813      *
1814      * _Available since v3.1._
1815      */
1816     function toInt128(int256 value) internal pure returns (int128) {
1817         require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits");
1818         return int128(value);
1819     }
1820 
1821     /**
1822      * @dev Returns the downcasted int64 from int256, reverting on
1823      * overflow (when the input is less than smallest int64 or
1824      * greater than largest int64).
1825      *
1826      * Counterpart to Solidity's `int64` operator.
1827      *
1828      * Requirements:
1829      *
1830      * - input must fit into 64 bits
1831      *
1832      * _Available since v3.1._
1833      */
1834     function toInt64(int256 value) internal pure returns (int64) {
1835         require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits");
1836         return int64(value);
1837     }
1838 
1839     /**
1840      * @dev Returns the downcasted int32 from int256, reverting on
1841      * overflow (when the input is less than smallest int32 or
1842      * greater than largest int32).
1843      *
1844      * Counterpart to Solidity's `int32` operator.
1845      *
1846      * Requirements:
1847      *
1848      * - input must fit into 32 bits
1849      *
1850      * _Available since v3.1._
1851      */
1852     function toInt32(int256 value) internal pure returns (int32) {
1853         require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits");
1854         return int32(value);
1855     }
1856 
1857     /**
1858      * @dev Returns the downcasted int16 from int256, reverting on
1859      * overflow (when the input is less than smallest int16 or
1860      * greater than largest int16).
1861      *
1862      * Counterpart to Solidity's `int16` operator.
1863      *
1864      * Requirements:
1865      *
1866      * - input must fit into 16 bits
1867      *
1868      * _Available since v3.1._
1869      */
1870     function toInt16(int256 value) internal pure returns (int16) {
1871         require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits");
1872         return int16(value);
1873     }
1874 
1875     /**
1876      * @dev Returns the downcasted int8 from int256, reverting on
1877      * overflow (when the input is less than smallest int8 or
1878      * greater than largest int8).
1879      *
1880      * Counterpart to Solidity's `int8` operator.
1881      *
1882      * Requirements:
1883      *
1884      * - input must fit into 8 bits.
1885      *
1886      * _Available since v3.1._
1887      */
1888     function toInt8(int256 value) internal pure returns (int8) {
1889         require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits");
1890         return int8(value);
1891     }
1892 
1893     /**
1894      * @dev Converts an unsigned uint256 into a signed int256.
1895      *
1896      * Requirements:
1897      *
1898      * - input must be less than or equal to maxInt256.
1899      */
1900     function toInt256(uint256 value) internal pure returns (int256) {
1901         require(value < 2**255, "SafeCast: value doesn't fit in an int256");
1902         return int256(value);
1903     }
1904 }
1905 
1906 
1907 /// @title Utility Functions for floats
1908 /// @author Brecht Devos - <brecht@loopring.org>
1909 library FloatUtil
1910 {
1911     using MathUint for uint;
1912     using SafeCast for uint;
1913 
1914     // Decodes a decimal float value that is encoded like `exponent | mantissa`.
1915     // Both exponent and mantissa are in base 10.
1916     // Decoding to an integer is as simple as `mantissa * (10 ** exponent)`
1917     // Will throw when the decoded value overflows an uint96
1918     /// @param f The float value with 5 bits for the exponent
1919     /// @param numBits The total number of bits (numBitsMantissa := numBits - numBitsExponent)
1920     /// @return value The decoded integer value.
1921     function decodeFloat(
1922         uint f,
1923         uint numBits
1924         )
1925         internal
1926         pure
1927         returns (uint96 value)
1928     {
1929         uint numBitsMantissa = numBits.sub(5);
1930         uint exponent = f >> numBitsMantissa;
1931         // log2(10**77) = 255.79 < 256
1932         require(exponent <= 77, "EXPONENT_TOO_LARGE");
1933         uint mantissa = f & ((1 << numBitsMantissa) - 1);
1934         value = mantissa.mul(10 ** exponent).toUint96();
1935     }
1936 }
1937 
1938 // Copyright 2017 Loopring Technology Limited.
1939 
1940 
1941 
1942 
1943 library EIP712
1944 {
1945     struct Domain {
1946         string  name;
1947         string  version;
1948         address verifyingContract;
1949     }
1950 
1951     bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(
1952         "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
1953     );
1954 
1955     string constant internal EIP191_HEADER = "\x19\x01";
1956 
1957     function hash(Domain memory domain)
1958         internal
1959         pure
1960         returns (bytes32)
1961     {
1962         uint _chainid;
1963         assembly { _chainid := chainid() }
1964 
1965         return keccak256(
1966             abi.encode(
1967                 EIP712_DOMAIN_TYPEHASH,
1968                 keccak256(bytes(domain.name)),
1969                 keccak256(bytes(domain.version)),
1970                 _chainid,
1971                 domain.verifyingContract
1972             )
1973         );
1974     }
1975 
1976     function hashPacked(
1977         bytes32 domainHash,
1978         bytes32 dataHash
1979         )
1980         internal
1981         pure
1982         returns (bytes32)
1983     {
1984         return keccak256(
1985             abi.encodePacked(
1986                 EIP191_HEADER,
1987                 domainHash,
1988                 dataHash
1989             )
1990         );
1991     }
1992 }
1993 // Copyright 2017 Loopring Technology Limited.
1994 
1995 
1996 
1997 /// @title Utility Functions for uint
1998 /// @author Daniel Wang - <daniel@loopring.org>
1999 library MathUint96
2000 {
2001     function add(
2002         uint96 a,
2003         uint96 b
2004         )
2005         internal
2006         pure
2007         returns (uint96 c)
2008     {
2009         c = a + b;
2010         require(c >= a, "ADD_OVERFLOW");
2011     }
2012 
2013     function sub(
2014         uint96 a,
2015         uint96 b
2016         )
2017         internal
2018         pure
2019         returns (uint96 c)
2020     {
2021         require(b <= a, "SUB_UNDERFLOW");
2022         return a - b;
2023     }
2024 }
2025 
2026 // Copyright 2017 Loopring Technology Limited.
2027 
2028 
2029 
2030 interface IAmmSharedConfig
2031 {
2032     function maxForcedExitAge() external view returns (uint);
2033     function maxForcedExitCount() external view returns (uint);
2034     function forcedExitFee() external view returns (uint);
2035 }
2036 // Copyright 2017 Loopring Technology Limited.
2037 
2038 
2039 
2040 /// @title Ownable
2041 /// @author Brecht Devos - <brecht@loopring.org>
2042 /// @dev The Ownable contract has an owner address, and provides basic
2043 ///      authorization control functions, this simplifies the implementation of
2044 ///      "user permissions".
2045 contract Ownable
2046 {
2047     address public owner;
2048 
2049     event OwnershipTransferred(
2050         address indexed previousOwner,
2051         address indexed newOwner
2052     );
2053 
2054     /// @dev The Ownable constructor sets the original `owner` of the contract
2055     ///      to the sender.
2056     constructor()
2057     {
2058         owner = msg.sender;
2059     }
2060 
2061     /// @dev Throws if called by any account other than the owner.
2062     modifier onlyOwner()
2063     {
2064         require(msg.sender == owner, "UNAUTHORIZED");
2065         _;
2066     }
2067 
2068     /// @dev Allows the current owner to transfer control of the contract to a
2069     ///      new owner.
2070     /// @param newOwner The address to transfer ownership to.
2071     function transferOwnership(
2072         address newOwner
2073         )
2074         public
2075         virtual
2076         onlyOwner
2077     {
2078         require(newOwner != address(0), "ZERO_ADDRESS");
2079         emit OwnershipTransferred(owner, newOwner);
2080         owner = newOwner;
2081     }
2082 
2083     function renounceOwnership()
2084         public
2085         onlyOwner
2086     {
2087         emit OwnershipTransferred(owner, address(0));
2088         owner = address(0);
2089     }
2090 }
2091 
2092 // Copyright 2017 Loopring Technology Limited.
2093 
2094 
2095 
2096 
2097 
2098 /// @title Claimable
2099 /// @author Brecht Devos - <brecht@loopring.org>
2100 /// @dev Extension for the Ownable contract, where the ownership needs
2101 ///      to be claimed. This allows the new owner to accept the transfer.
2102 contract Claimable is Ownable
2103 {
2104     address public pendingOwner;
2105 
2106     /// @dev Modifier throws if called by any account other than the pendingOwner.
2107     modifier onlyPendingOwner() {
2108         require(msg.sender == pendingOwner, "UNAUTHORIZED");
2109         _;
2110     }
2111 
2112     /// @dev Allows the current owner to set the pendingOwner address.
2113     /// @param newOwner The address to transfer ownership to.
2114     function transferOwnership(
2115         address newOwner
2116         )
2117         public
2118         override
2119         onlyOwner
2120     {
2121         require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");
2122         pendingOwner = newOwner;
2123     }
2124 
2125     /// @dev Allows the pendingOwner address to finalize the transfer.
2126     function claimOwnership()
2127         public
2128         onlyPendingOwner
2129     {
2130         emit OwnershipTransferred(owner, pendingOwner);
2131         owner = pendingOwner;
2132         pendingOwner = address(0);
2133     }
2134 }
2135 
2136 // Copyright 2017 Loopring Technology Limited.
2137 
2138 
2139 
2140 /// @title ERC20 Token Interface
2141 /// @dev see https://github.com/ethereum/EIPs/issues/20
2142 /// @author Daniel Wang - <daniel@loopring.org>
2143 abstract contract ERC20
2144 {
2145     function totalSupply()
2146         public
2147         virtual
2148         view
2149         returns (uint);
2150 
2151     function balanceOf(
2152         address who
2153         )
2154         public
2155         virtual
2156         view
2157         returns (uint);
2158 
2159     function allowance(
2160         address owner,
2161         address spender
2162         )
2163         public
2164         virtual
2165         view
2166         returns (uint);
2167 
2168     function transfer(
2169         address to,
2170         uint value
2171         )
2172         public
2173         virtual
2174         returns (bool);
2175 
2176     function transferFrom(
2177         address from,
2178         address to,
2179         uint    value
2180         )
2181         public
2182         virtual
2183         returns (bool);
2184 
2185     function approve(
2186         address spender,
2187         uint    value
2188         )
2189         public
2190         virtual
2191         returns (bool);
2192 }
2193 
2194 // Copyright 2017 Loopring Technology Limited.
2195 
2196 
2197 
2198 
2199 // Copyright 2017 Loopring Technology Limited.
2200 
2201 
2202 interface IAgent{}
2203 
2204 interface IAgentRegistry
2205 {
2206     /// @dev Returns whether an agent address is an agent of an account owner
2207     /// @param owner The account owner.
2208     /// @param agent The agent address
2209     /// @return True if the agent address is an agent for the account owner, else false
2210     function isAgent(
2211         address owner,
2212         address agent
2213         )
2214         external
2215         view
2216         returns (bool);
2217 
2218     /// @dev Returns whether an agent address is an agent of all account owners
2219     /// @param owners The account owners.
2220     /// @param agent The agent address
2221     /// @return True if the agent address is an agent for the account owner, else false
2222     function isAgent(
2223         address[] calldata owners,
2224         address            agent
2225         )
2226         external
2227         view
2228         returns (bool);
2229 }
2230 
2231 
2232 // Copyright 2017 Loopring Technology Limited.
2233 
2234 
2235 
2236 
2237 
2238 
2239 /// @title IBlockVerifier
2240 /// @author Brecht Devos - <brecht@loopring.org>
2241 abstract contract IBlockVerifier is Claimable
2242 {
2243     // -- Events --
2244 
2245     event CircuitRegistered(
2246         uint8  indexed blockType,
2247         uint16         blockSize,
2248         uint8          blockVersion
2249     );
2250 
2251     event CircuitDisabled(
2252         uint8  indexed blockType,
2253         uint16         blockSize,
2254         uint8          blockVersion
2255     );
2256 
2257     // -- Public functions --
2258 
2259     /// @dev Sets the verifying key for the specified circuit.
2260     ///      Every block permutation needs its own circuit and thus its own set of
2261     ///      verification keys. Only a limited number of block sizes per block
2262     ///      type are supported.
2263     /// @param blockType The type of the block
2264     /// @param blockSize The number of requests handled in the block
2265     /// @param blockVersion The block version (i.e. which circuit version needs to be used)
2266     /// @param vk The verification key
2267     function registerCircuit(
2268         uint8    blockType,
2269         uint16   blockSize,
2270         uint8    blockVersion,
2271         uint[18] calldata vk
2272         )
2273         external
2274         virtual;
2275 
2276     /// @dev Disables the use of the specified circuit.
2277     ///      This will stop NEW blocks from using the given circuit, blocks that were already committed
2278     ///      can still be verified.
2279     /// @param blockType The type of the block
2280     /// @param blockSize The number of requests handled in the block
2281     /// @param blockVersion The block version (i.e. which circuit version needs to be used)
2282     function disableCircuit(
2283         uint8  blockType,
2284         uint16 blockSize,
2285         uint8  blockVersion
2286         )
2287         external
2288         virtual;
2289 
2290     /// @dev Verifies blocks with the given public data and proofs.
2291     ///      Verifying a block makes sure all requests handled in the block
2292     ///      are correctly handled by the operator.
2293     /// @param blockType The type of block
2294     /// @param blockSize The number of requests handled in the block
2295     /// @param blockVersion The block version (i.e. which circuit version needs to be used)
2296     /// @param publicInputs The hash of all the public data of the blocks
2297     /// @param proofs The ZK proofs proving that the blocks are correct
2298     /// @return True if the block is valid, false otherwise
2299     function verifyProofs(
2300         uint8  blockType,
2301         uint16 blockSize,
2302         uint8  blockVersion,
2303         uint[] calldata publicInputs,
2304         uint[] calldata proofs
2305         )
2306         external
2307         virtual
2308         view
2309         returns (bool);
2310 
2311     /// @dev Checks if a circuit with the specified parameters is registered.
2312     /// @param blockType The type of the block
2313     /// @param blockSize The number of requests handled in the block
2314     /// @param blockVersion The block version (i.e. which circuit version needs to be used)
2315     /// @return True if the circuit is registered, false otherwise
2316     function isCircuitRegistered(
2317         uint8  blockType,
2318         uint16 blockSize,
2319         uint8  blockVersion
2320         )
2321         external
2322         virtual
2323         view
2324         returns (bool);
2325 
2326     /// @dev Checks if a circuit can still be used to commit new blocks.
2327     /// @param blockType The type of the block
2328     /// @param blockSize The number of requests handled in the block
2329     /// @param blockVersion The block version (i.e. which circuit version needs to be used)
2330     /// @return True if the circuit is enabled, false otherwise
2331     function isCircuitEnabled(
2332         uint8  blockType,
2333         uint16 blockSize,
2334         uint8  blockVersion
2335         )
2336         external
2337         virtual
2338         view
2339         returns (bool);
2340 }
2341 
2342 
2343 // Copyright 2017 Loopring Technology Limited.
2344 
2345 
2346 
2347 /// @title IDepositContract.
2348 /// @dev   Contract storing and transferring funds for an exchange.
2349 ///
2350 ///        ERC1155 tokens can be supported by registering pseudo token addresses calculated
2351 ///        as `address(keccak256(real_token_address, token_params))`. Then the custom
2352 ///        deposit contract can look up the real token address and paramsters with the
2353 ///        pseudo token address before doing the transfers.
2354 /// @author Brecht Devos - <brecht@loopring.org>
2355 interface IDepositContract
2356 {
2357     /// @dev Returns if a token is suppoprted by this contract.
2358     function isTokenSupported(address token)
2359         external
2360         view
2361         returns (bool);
2362 
2363     /// @dev Transfers tokens from a user to the exchange. This function will
2364     ///      be called when a user deposits funds to the exchange.
2365     ///      In a simple implementation the funds are simply stored inside the
2366     ///      deposit contract directly. More advanced implementations may store the funds
2367     ///      in some DeFi application to earn interest, so this function could directly
2368     ///      call the necessary functions to store the funds there.
2369     ///
2370     ///      This function needs to throw when an error occurred!
2371     ///
2372     ///      This function can only be called by the exchange.
2373     ///
2374     /// @param from The address of the account that sends the tokens.
2375     /// @param token The address of the token to transfer (`0x0` for ETH).
2376     /// @param amount The amount of tokens to transfer.
2377     /// @param extraData Opaque data that can be used by the contract to handle the deposit
2378     /// @return amountReceived The amount to deposit to the user's account in the Merkle tree
2379     function deposit(
2380         address from,
2381         address token,
2382         uint96  amount,
2383         bytes   calldata extraData
2384         )
2385         external
2386         payable
2387         returns (uint96 amountReceived);
2388 
2389     /// @dev Transfers tokens from the exchange to a user. This function will
2390     ///      be called when a withdrawal is done for a user on the exchange.
2391     ///      In the simplest implementation the funds are simply stored inside the
2392     ///      deposit contract directly so this simply transfers the requested tokens back
2393     ///      to the user. More advanced implementations may store the funds
2394     ///      in some DeFi application to earn interest so the function would
2395     ///      need to get those tokens back from the DeFi application first before they
2396     ///      can be transferred to the user.
2397     ///
2398     ///      This function needs to throw when an error occurred!
2399     ///
2400     ///      This function can only be called by the exchange.
2401     ///
2402     /// @param from The address from which 'amount' tokens are transferred.
2403     /// @param to The address to which 'amount' tokens are transferred.
2404     /// @param token The address of the token to transfer (`0x0` for ETH).
2405     /// @param amount The amount of tokens transferred.
2406     /// @param extraData Opaque data that can be used by the contract to handle the withdrawal
2407     function withdraw(
2408         address from,
2409         address to,
2410         address token,
2411         uint    amount,
2412         bytes   calldata extraData
2413         )
2414         external
2415         payable;
2416 
2417     /// @dev Transfers tokens (ETH not supported) for a user using the allowance set
2418     ///      for the exchange. This way the approval can be used for all functionality (and
2419     ///      extended functionality) of the exchange.
2420     ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`
2421     ///      should be used for that as they will contain specialised logic for those operations.
2422     ///      This function can be called by the exchange to transfer onchain funds of users
2423     ///      necessary for Agent functionality.
2424     ///
2425     ///      This function needs to throw when an error occurred!
2426     ///
2427     ///      This function can only be called by the exchange.
2428     ///
2429     /// @param from The address of the account that sends the tokens.
2430     /// @param to The address to which 'amount' tokens are transferred.
2431     /// @param token The address of the token to transfer (ETH is and cannot be suppported).
2432     /// @param amount The amount of tokens transferred.
2433     function transfer(
2434         address from,
2435         address to,
2436         address token,
2437         uint    amount
2438         )
2439         external
2440         payable;
2441 
2442     /// @dev Checks if the given address is used for depositing ETH or not.
2443     ///      Is used while depositing to send the correct ETH amount to the deposit contract.
2444     ///
2445     ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!
2446     ///      This function allows additional addresses to be used for depositing ETH, the deposit
2447     ///      contract can implement different behaviour based on the address value.
2448     ///
2449     /// @param addr The address to check
2450     /// @return True if the address is used for depositing ETH, else false.
2451     function isETH(address addr)
2452         external
2453         view
2454         returns (bool);
2455 }
2456 
2457 // Copyright 2017 Loopring Technology Limited.
2458 
2459 
2460 
2461 
2462 
2463 /// @title ILoopringV3
2464 /// @author Brecht Devos - <brecht@loopring.org>
2465 /// @author Daniel Wang  - <daniel@loopring.org>
2466 abstract contract ILoopringV3 is Claimable
2467 {
2468     // == Events ==
2469     event ExchangeStakeDeposited(address exchangeAddr, uint amount);
2470     event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);
2471     event ExchangeStakeBurned(address exchangeAddr, uint amount);
2472     event SettingsUpdated(uint time);
2473 
2474     // == Public Variables ==
2475     mapping (address => uint) internal exchangeStake;
2476 
2477     address public lrcAddress;
2478     uint    public totalStake;
2479     address public blockVerifierAddress;
2480     uint    public forcedWithdrawalFee;
2481     uint    public tokenRegistrationFeeLRCBase;
2482     uint    public tokenRegistrationFeeLRCDelta;
2483     uint8   public protocolTakerFeeBips;
2484     uint8   public protocolMakerFeeBips;
2485 
2486     address payable public protocolFeeVault;
2487 
2488     // == Public Functions ==
2489     /// @dev Updates the global exchange settings.
2490     ///      This function can only be called by the owner of this contract.
2491     ///
2492     ///      Warning: these new values will be used by existing and
2493     ///      new Loopring exchanges.
2494     function updateSettings(
2495         address payable _protocolFeeVault,   // address(0) not allowed
2496         address _blockVerifierAddress,       // address(0) not allowed
2497         uint    _forcedWithdrawalFee
2498         )
2499         external
2500         virtual;
2501 
2502     /// @dev Updates the global protocol fee settings.
2503     ///      This function can only be called by the owner of this contract.
2504     ///
2505     ///      Warning: these new values will be used by existing and
2506     ///      new Loopring exchanges.
2507     function updateProtocolFeeSettings(
2508         uint8 _protocolTakerFeeBips,
2509         uint8 _protocolMakerFeeBips
2510         )
2511         external
2512         virtual;
2513 
2514     /// @dev Gets the amount of staked LRC for an exchange.
2515     /// @param exchangeAddr The address of the exchange
2516     /// @return stakedLRC The amount of LRC
2517     function getExchangeStake(
2518         address exchangeAddr
2519         )
2520         public
2521         virtual
2522         view
2523         returns (uint stakedLRC);
2524 
2525     /// @dev Burns a certain amount of staked LRC for a specific exchange.
2526     ///      This function is meant to be called only from exchange contracts.
2527     /// @return burnedLRC The amount of LRC burned. If the amount is greater than
2528     ///         the staked amount, all staked LRC will be burned.
2529     function burnExchangeStake(
2530         uint amount
2531         )
2532         external
2533         virtual
2534         returns (uint burnedLRC);
2535 
2536     /// @dev Stakes more LRC for an exchange.
2537     /// @param  exchangeAddr The address of the exchange
2538     /// @param  amountLRC The amount of LRC to stake
2539     /// @return stakedLRC The total amount of LRC staked for the exchange
2540     function depositExchangeStake(
2541         address exchangeAddr,
2542         uint    amountLRC
2543         )
2544         external
2545         virtual
2546         returns (uint stakedLRC);
2547 
2548     /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.
2549     ///      This function is meant to be called only from within exchange contracts.
2550     /// @param  recipient The address to receive LRC
2551     /// @param  requestedAmount The amount of LRC to withdraw
2552     /// @return amountLRC The amount of LRC withdrawn
2553     function withdrawExchangeStake(
2554         address recipient,
2555         uint    requestedAmount
2556         )
2557         external
2558         virtual
2559         returns (uint amountLRC);
2560 
2561     /// @dev Gets the protocol fee values for an exchange.
2562     /// @return takerFeeBips The protocol taker fee
2563     /// @return makerFeeBips The protocol maker fee
2564     function getProtocolFeeValues(
2565         )
2566         public
2567         virtual
2568         view
2569         returns (
2570             uint8 takerFeeBips,
2571             uint8 makerFeeBips
2572         );
2573 }
2574 
2575 
2576 
2577 /// @title ExchangeData
2578 /// @dev All methods in this lib are internal, therefore, there is no need
2579 ///      to deploy this library independently.
2580 /// @author Daniel Wang  - <daniel@loopring.org>
2581 /// @author Brecht Devos - <brecht@loopring.org>
2582 library ExchangeData
2583 {
2584     // -- Enums --
2585     enum TransactionType
2586     {
2587         NOOP,
2588         DEPOSIT,
2589         WITHDRAWAL,
2590         TRANSFER,
2591         SPOT_TRADE,
2592         ACCOUNT_UPDATE,
2593         AMM_UPDATE
2594     }
2595 
2596     // -- Structs --
2597     struct Token
2598     {
2599         address token;
2600     }
2601 
2602     struct ProtocolFeeData
2603     {
2604         uint32 syncedAt; // only valid before 2105 (85 years to go)
2605         uint8  takerFeeBips;
2606         uint8  makerFeeBips;
2607         uint8  previousTakerFeeBips;
2608         uint8  previousMakerFeeBips;
2609     }
2610 
2611     // General auxiliary data for each conditional transaction
2612     struct AuxiliaryData
2613     {
2614         uint  txIndex;
2615         bytes data;
2616     }
2617 
2618     // This is the (virtual) block the owner  needs to submit onchain to maintain the
2619     // per-exchange (virtual) blockchain.
2620     struct Block
2621     {
2622         uint8      blockType;
2623         uint16     blockSize;
2624         uint8      blockVersion;
2625         bytes      data;
2626         uint256[8] proof;
2627 
2628         // Whether we should store the @BlockInfo for this block on-chain.
2629         bool storeBlockInfoOnchain;
2630 
2631         // Block specific data that is only used to help process the block on-chain.
2632         // It is not used as input for the circuits and it is not necessary for data-availability.
2633         AuxiliaryData[] auxiliaryData;
2634 
2635         // Arbitrary data, mainly for off-chain data-availability, i.e.,
2636         // the multihash of the IPFS file that contains the block data.
2637         bytes offchainData;
2638     }
2639 
2640     struct BlockInfo
2641     {
2642         // The time the block was submitted on-chain.
2643         uint32  timestamp;
2644         // The public data hash of the block (the 28 most significant bytes).
2645         bytes28 blockDataHash;
2646     }
2647 
2648     // Represents an onchain deposit request.
2649     struct Deposit
2650     {
2651         uint96 amount;
2652         uint64 timestamp;
2653     }
2654 
2655     // A forced withdrawal request.
2656     // If the actual owner of the account initiated the request (we don't know who the owner is
2657     // at the time the request is being made) the full balance will be withdrawn.
2658     struct ForcedWithdrawal
2659     {
2660         address owner;
2661         uint64  timestamp;
2662     }
2663 
2664     struct Constants
2665     {
2666         uint SNARK_SCALAR_FIELD;
2667         uint MAX_OPEN_FORCED_REQUESTS;
2668         uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;
2669         uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;
2670         uint MAX_NUM_ACCOUNTS;
2671         uint MAX_NUM_TOKENS;
2672         uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;
2673         uint MIN_TIME_IN_SHUTDOWN;
2674         uint TX_DATA_AVAILABILITY_SIZE;
2675         uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;
2676     }
2677 
2678     function SNARK_SCALAR_FIELD() internal pure returns (uint) {
2679         // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.
2680         return 21888242871839275222246405745257275088548364400416034343698204186575808495617;
2681     }
2682     function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }
2683     function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }
2684     function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }
2685     function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }
2686     function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }
2687     function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }
2688     function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }
2689     // The amount of bytes each rollup transaction uses in the block data for data-availability.
2690     // This is the maximum amount of bytes of all different transaction types.
2691     function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }
2692     function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }
2693     function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }
2694 
2695     function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }
2696     function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }
2697 
2698     struct AccountLeaf
2699     {
2700         uint32   accountID;
2701         address  owner;
2702         uint     pubKeyX;
2703         uint     pubKeyY;
2704         uint32   nonce;
2705         uint     feeBipsAMM;
2706     }
2707 
2708     struct BalanceLeaf
2709     {
2710         uint16   tokenID;
2711         uint96   balance;
2712         uint96   weightAMM;
2713         uint     storageRoot;
2714     }
2715 
2716     struct MerkleProof
2717     {
2718         ExchangeData.AccountLeaf accountLeaf;
2719         ExchangeData.BalanceLeaf balanceLeaf;
2720         uint[48]                 accountMerkleProof;
2721         uint[24]                 balanceMerkleProof;
2722     }
2723 
2724     struct BlockContext
2725     {
2726         bytes32 DOMAIN_SEPARATOR;
2727         uint32  timestamp;
2728     }
2729 
2730     // Represents the entire exchange state except the owner of the exchange.
2731     struct State
2732     {
2733         uint32  maxAgeDepositUntilWithdrawable;
2734         bytes32 DOMAIN_SEPARATOR;
2735 
2736         ILoopringV3      loopring;
2737         IBlockVerifier   blockVerifier;
2738         IAgentRegistry   agentRegistry;
2739         IDepositContract depositContract;
2740 
2741 
2742         // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree
2743         // stores balances for users using an account model.
2744         bytes32 merkleRoot;
2745 
2746         // List of all blocks
2747         mapping(uint => BlockInfo) blocks;
2748         uint  numBlocks;
2749 
2750         // List of all tokens
2751         Token[] tokens;
2752 
2753         // A map from a token to its tokenID + 1
2754         mapping (address => uint16) tokenToTokenId;
2755 
2756         // A map from an accountID to a tokenID to if the balance is withdrawn
2757         mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;
2758 
2759         // A map from an account to a token to the amount withdrawable for that account.
2760         // This is only used when the automatic distribution of the withdrawal failed.
2761         mapping (address => mapping (uint16 => uint)) amountWithdrawable;
2762 
2763         // A map from an account to a token to the forced withdrawal (always full balance)
2764         mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;
2765 
2766         // A map from an address to a token to a deposit
2767         mapping (address => mapping (uint16 => Deposit)) pendingDeposits;
2768 
2769         // A map from an account owner to an approved transaction hash to if the transaction is approved or not
2770         mapping (address => mapping (bytes32 => bool)) approvedTx;
2771 
2772         // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address
2773         mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;
2774 
2775 
2776         // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner
2777         uint32 numPendingForcedTransactions;
2778 
2779         // Cached data for the protocol fee
2780         ProtocolFeeData protocolFeeData;
2781 
2782         // Time when the exchange was shutdown
2783         uint shutdownModeStartTime;
2784 
2785         // Time when the exchange has entered withdrawal mode
2786         uint withdrawalModeStartTime;
2787 
2788         // Last time the protocol fee was withdrawn for a specific token
2789         mapping (address => uint) protocolFeeLastWithdrawnTime;
2790     }
2791 }
2792 
2793 // Copyright 2017 Loopring Technology Limited.
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 // Copyright 2017 Loopring Technology Limited.
2804 
2805 
2806 
2807 
2808 
2809 
2810 
2811 /// @title ExchangeSignatures.
2812 /// @dev All methods in this lib are internal, therefore, there is no need
2813 ///      to deploy this library independently.
2814 /// @author Brecht Devos - <brecht@loopring.org>
2815 /// @author Daniel Wang  - <daniel@loopring.org>
2816 library ExchangeSignatures
2817 {
2818     using SignatureUtil for bytes32;
2819 
2820     function requireAuthorizedTx(
2821         ExchangeData.State storage S,
2822         address signer,
2823         bytes memory signature,
2824         bytes32 txHash
2825         )
2826         internal // inline call
2827     {
2828         require(signer != address(0), "INVALID_SIGNER");
2829         // Verify the signature if one is provided, otherwise fall back to an approved tx
2830         if (signature.length > 0) {
2831             require(txHash.verifySignature(signer, signature), "INVALID_SIGNATURE");
2832         } else {
2833             require(S.approvedTx[signer][txHash], "TX_NOT_APPROVED");
2834             delete S.approvedTx[signer][txHash];
2835         }
2836     }
2837 }
2838 
2839 
2840 
2841 /// @title AmmUpdateTransaction
2842 /// @author Brecht Devos - <brecht@loopring.org>
2843 library AmmUpdateTransaction
2844 {
2845     using BytesUtil            for bytes;
2846     using MathUint             for uint;
2847     using ExchangeSignatures   for ExchangeData.State;
2848 
2849     bytes32 constant public AMMUPDATE_TYPEHASH = keccak256(
2850         "AmmUpdate(address owner,uint32 accountID,uint16 tokenID,uint8 feeBips,uint96 tokenWeight,uint32 validUntil,uint32 nonce)"
2851     );
2852 
2853     struct AmmUpdate
2854     {
2855         address owner;
2856         uint32  accountID;
2857         uint16  tokenID;
2858         uint8   feeBips;
2859         uint96  tokenWeight;
2860         uint32  validUntil;
2861         uint32  nonce;
2862         uint96  balance;
2863     }
2864 
2865     // Auxiliary data for each AMM update
2866     struct AmmUpdateAuxiliaryData
2867     {
2868         bytes  signature;
2869         uint32 validUntil;
2870     }
2871 
2872     function process(
2873         ExchangeData.State        storage S,
2874         ExchangeData.BlockContext memory  ctx,
2875         bytes                     memory  data,
2876         uint                              offset,
2877         bytes                     memory  auxiliaryData
2878         )
2879         internal
2880     {
2881         // Read in the AMM update
2882         AmmUpdate memory update = readTx(data, offset);
2883         AmmUpdateAuxiliaryData memory auxData = abi.decode(auxiliaryData, (AmmUpdateAuxiliaryData));
2884 
2885         // Check validUntil
2886         require(ctx.timestamp < auxData.validUntil, "AMM_UPDATE_EXPIRED");
2887         update.validUntil = auxData.validUntil;
2888 
2889         // Calculate the tx hash
2890         bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, update);
2891 
2892         // Check the on-chain authorization
2893         S.requireAuthorizedTx(update.owner, auxData.signature, txHash);
2894     }
2895 
2896     function readTx(
2897         bytes memory data,
2898         uint         offset
2899         )
2900         internal
2901         pure
2902         returns (AmmUpdate memory update)
2903     {
2904         uint _offset = offset;
2905         // We don't use abi.decode for this because of the large amount of zero-padding
2906         // bytes the circuit would also have to hash.
2907         update.owner = data.toAddress(_offset);
2908         _offset += 20;
2909         update.accountID = data.toUint32(_offset);
2910         _offset += 4;
2911         update.tokenID = data.toUint16(_offset);
2912         _offset += 2;
2913         update.feeBips = data.toUint8(_offset);
2914         _offset += 1;
2915         update.tokenWeight = data.toUint96(_offset);
2916         _offset += 12;
2917         update.nonce = data.toUint32(_offset);
2918         _offset += 4;
2919         update.balance = data.toUint96(_offset);
2920         _offset += 12;
2921     }
2922 
2923     function hashTx(
2924         bytes32 DOMAIN_SEPARATOR,
2925         AmmUpdate memory update
2926         )
2927         internal
2928         pure
2929         returns (bytes32)
2930     {
2931         return EIP712.hashPacked(
2932             DOMAIN_SEPARATOR,
2933             keccak256(
2934                 abi.encode(
2935                     AMMUPDATE_TYPEHASH,
2936                     update.owner,
2937                     update.accountID,
2938                     update.tokenID,
2939                     update.feeBips,
2940                     update.tokenWeight,
2941                     update.validUntil,
2942                     update.nonce
2943                 )
2944             )
2945         );
2946     }
2947 }
2948 
2949 // Copyright 2017 Loopring Technology Limited.
2950 
2951 
2952 
2953 
2954 
2955 
2956 /// @title BlockReader
2957 /// @author Brecht Devos - <brecht@loopring.org>
2958 /// @dev Utility library to read block data.
2959 library BlockReader {
2960     using BlockReader       for ExchangeData.Block;
2961     using BytesUtil         for bytes;
2962 
2963     uint public constant OFFSET_TO_TRANSACTIONS = 20 + 32 + 32 + 4 + 1 + 1 + 4 + 4;
2964 
2965     struct BlockHeader
2966     {
2967         address exchange;
2968         bytes32 merkleRootBefore;
2969         bytes32 merkleRootAfter;
2970         uint32  timestamp;
2971         uint8   protocolTakerFeeBips;
2972         uint8   protocolMakerFeeBips;
2973         uint32  numConditionalTransactions;
2974         uint32  operatorAccountID;
2975     }
2976 
2977     function readHeader(
2978         ExchangeData.Block memory _block
2979         )
2980         internal
2981         pure
2982         returns (BlockHeader memory header)
2983     {
2984         uint offset = 0;
2985         header.exchange = _block.data.toAddress(offset);
2986         offset += 20;
2987         header.merkleRootBefore = _block.data.toBytes32(offset);
2988         offset += 32;
2989         header.merkleRootAfter = _block.data.toBytes32(offset);
2990         offset += 32;
2991         header.timestamp = _block.data.toUint32(offset);
2992         offset += 4;
2993         header.protocolTakerFeeBips = _block.data.toUint8(offset);
2994         offset += 1;
2995         header.protocolMakerFeeBips = _block.data.toUint8(offset);
2996         offset += 1;
2997         header.numConditionalTransactions = _block.data.toUint32(offset);
2998         offset += 4;
2999         header.operatorAccountID = _block.data.toUint32(offset);
3000         offset += 4;
3001         assert(offset == OFFSET_TO_TRANSACTIONS);
3002     }
3003 
3004     function readTransactionData(
3005         ExchangeData.Block memory _block,
3006         uint txIdx
3007         )
3008         internal
3009         pure
3010         returns (bytes memory)
3011     {
3012         require(txIdx < _block.blockSize, "INVALID_TX_IDX");
3013 
3014         bytes memory data = _block.data;
3015 
3016         bytes memory txData = new bytes(ExchangeData.TX_DATA_AVAILABILITY_SIZE());
3017         // Part 1
3018         uint txDataOffset = OFFSET_TO_TRANSACTIONS +
3019             txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1();
3020         assembly {
3021             mstore(add(txData, 32), mload(add(data, add(txDataOffset, 32))))
3022         }
3023         // Part 2
3024         txDataOffset = OFFSET_TO_TRANSACTIONS +
3025             _block.blockSize * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1() +
3026             txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2();
3027         assembly {
3028             mstore(add(txData, 61 /*32 + 29*/), mload(add(data, add(txDataOffset, 32))))
3029             mstore(add(txData, 68            ), mload(add(data, add(txDataOffset, 39))))
3030         }
3031         return txData;
3032     }
3033 }
3034 
3035 // Copyright 2017 Loopring Technology Limited.
3036 
3037 
3038 abstract contract ERC1271 {
3039     // bytes4(keccak256("isValidSignature(bytes32,bytes)")
3040     bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;
3041 
3042     function isValidSignature(
3043         bytes32      _hash,
3044         bytes memory _signature)
3045         public
3046         view
3047         virtual
3048         returns (bytes4 magicValueB32);
3049 
3050 }
3051 
3052 // Copyright 2017 Loopring Technology Limited.
3053 
3054 
3055 
3056 
3057 
3058 
3059 
3060 
3061 /// @title AmmData
3062 library AmmData
3063 {
3064     function POOL_TOKEN_BASE() internal pure returns (uint) { return 100 * (10 ** 8); }
3065     function POOL_TOKEN_MINTED_SUPPLY() internal pure returns (uint) { return uint96(-1); }
3066 
3067     enum PoolTxType
3068     {
3069         NOOP,
3070         JOIN,
3071         EXIT
3072     }
3073 
3074     struct PoolConfig
3075     {
3076         address   sharedConfig;
3077         address   exchange;
3078         string    poolName;
3079         uint32    accountID;
3080         address[] tokens;
3081         uint96[]  weights;
3082         uint8     feeBips;
3083         string    tokenSymbol;
3084     }
3085 
3086     struct PoolJoin
3087     {
3088         address   owner;
3089         uint96[]  joinAmounts;
3090         uint32[]  joinStorageIDs;
3091         uint96    mintMinAmount;
3092         uint32    validUntil;
3093     }
3094 
3095     struct PoolExit
3096     {
3097         address   owner;
3098         uint96    burnAmount;
3099         uint32    burnStorageID; // for pool token withdrawal from user to the pool
3100         uint96[]  exitMinAmounts; // the amount to receive BEFORE paying the fee.
3101         uint96    fee;
3102         uint32    validUntil;
3103     }
3104 
3105     struct PoolTx
3106     {
3107         PoolTxType txType;
3108         bytes      data;
3109         bytes      signature;
3110     }
3111 
3112     struct Token
3113     {
3114         address addr;
3115         uint96  weight;
3116         uint16  tokenID;
3117     }
3118 
3119     struct Context
3120     {
3121         // functional parameters
3122         uint txIdx;
3123 
3124         // Exchange state variables
3125         IExchangeV3 exchange;
3126         bytes32     exchangeDomainSeparator;
3127 
3128         // AMM pool state variables
3129         bytes32 domainSeparator;
3130         uint32  accountID;
3131 
3132         uint16  poolTokenID;
3133         uint    totalSupply;
3134 
3135         Token[]  tokens;
3136         uint96[] tokenBalancesL2;
3137 
3138         TransactionBuffer transactionBuffer;
3139     }
3140 
3141     struct TransactionBuffer
3142     {
3143         uint      size;
3144         address[] owners;
3145         bytes32[] txHashes;
3146     }
3147 
3148     struct State {
3149         // Pool token state variables
3150         string poolName;
3151         string symbol;
3152         uint   _totalSupply;
3153 
3154         mapping(address => uint) balanceOf;
3155         mapping(address => mapping(address => uint)) allowance;
3156         mapping(address => uint) nonces;
3157 
3158         // AMM pool state variables
3159         IAmmSharedConfig sharedConfig;
3160 
3161         Token[]     tokens;
3162 
3163         // The order of the following variables important to minimize loads
3164         bytes32     exchangeDomainSeparator;
3165         bytes32     domainSeparator;
3166         IExchangeV3 exchange;
3167         uint32      accountID;
3168         uint16      poolTokenID;
3169         uint8       feeBips;
3170 
3171         address     exchangeOwner;
3172 
3173         uint64      shutdownTimestamp;
3174         uint16      forcedExitCount;
3175 
3176         // A map from a user to the forced exit.
3177         mapping (address => PoolExit) forcedExit;
3178         mapping (bytes32 => bool) approvedTx;
3179     }
3180 }
3181 
3182 // Copyright 2017 Loopring Technology Limited.
3183 
3184 
3185 
3186 
3187 
3188 
3189 /// @title IBlockReceiver
3190 /// @author Brecht Devos - <brecht@loopring.org>
3191 abstract contract IBlockReceiver
3192 {
3193     function beforeBlockSubmission(
3194         ExchangeData.Block memory _block,
3195         bytes              memory data,
3196         uint                      txIdx,
3197         uint                      numTxs
3198         )
3199         external
3200         virtual;
3201 }
3202 
3203 // Copyright 2017 Loopring Technology Limited.
3204 
3205 
3206 
3207 
3208 
3209 
3210 
3211 
3212 
3213 /// @title SignatureUtil
3214 /// @author Daniel Wang - <daniel@loopring.org>
3215 /// @dev This method supports multihash standard. Each signature's last byte indicates
3216 ///      the signature's type.
3217 library SignatureUtil
3218 {
3219     using BytesUtil     for bytes;
3220     using MathUint      for uint;
3221     using AddressUtil   for address;
3222 
3223     enum SignatureType {
3224         ILLEGAL,
3225         INVALID,
3226         EIP_712,
3227         ETH_SIGN,
3228         WALLET   // deprecated
3229     }
3230 
3231     bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;
3232 
3233     function verifySignatures(
3234         bytes32          signHash,
3235         address[] memory signers,
3236         bytes[]   memory signatures
3237         )
3238         internal
3239         view
3240         returns (bool)
3241     {
3242         require(signers.length == signatures.length, "BAD_SIGNATURE_DATA");
3243         address lastSigner;
3244         for (uint i = 0; i < signers.length; i++) {
3245             require(signers[i] > lastSigner, "INVALID_SIGNERS_ORDER");
3246             lastSigner = signers[i];
3247             if (!verifySignature(signHash, signers[i], signatures[i])) {
3248                 return false;
3249             }
3250         }
3251         return true;
3252     }
3253 
3254     function verifySignature(
3255         bytes32        signHash,
3256         address        signer,
3257         bytes   memory signature
3258         )
3259         internal
3260         view
3261         returns (bool)
3262     {
3263         if (signer == address(0)) {
3264             return false;
3265         }
3266 
3267         return signer.isContract()?
3268             verifyERC1271Signature(signHash, signer, signature):
3269             verifyEOASignature(signHash, signer, signature);
3270     }
3271 
3272     function recoverECDSASigner(
3273         bytes32      signHash,
3274         bytes memory signature
3275         )
3276         internal
3277         pure
3278         returns (address)
3279     {
3280         if (signature.length != 65) {
3281             return address(0);
3282         }
3283 
3284         bytes32 r;
3285         bytes32 s;
3286         uint8   v;
3287         // we jump 32 (0x20) as the first slot of bytes contains the length
3288         // we jump 65 (0x41) per signature
3289         // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask
3290         assembly {
3291             r := mload(add(signature, 0x20))
3292             s := mload(add(signature, 0x40))
3293             v := and(mload(add(signature, 0x41)), 0xff)
3294         }
3295         // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol
3296         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
3297             return address(0);
3298         }
3299         if (v == 27 || v == 28) {
3300             return ecrecover(signHash, v, r, s);
3301         } else {
3302             return address(0);
3303         }
3304     }
3305 
3306     function verifyEOASignature(
3307         bytes32        signHash,
3308         address        signer,
3309         bytes   memory signature
3310         )
3311         private
3312         pure
3313         returns (bool success)
3314     {
3315         if (signer == address(0)) {
3316             return false;
3317         }
3318 
3319         uint signatureTypeOffset = signature.length.sub(1);
3320         SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));
3321 
3322         // Strip off the last byte of the signature by updating the length
3323         assembly {
3324             mstore(signature, signatureTypeOffset)
3325         }
3326 
3327         if (signatureType == SignatureType.EIP_712) {
3328             success = (signer == recoverECDSASigner(signHash, signature));
3329         } else if (signatureType == SignatureType.ETH_SIGN) {
3330             bytes32 hash = keccak256(
3331                 abi.encodePacked("\x19Ethereum Signed Message:\n32", signHash)
3332             );
3333             success = (signer == recoverECDSASigner(hash, signature));
3334         } else {
3335             success = false;
3336         }
3337 
3338         // Restore the signature length
3339         assembly {
3340             mstore(signature, add(signatureTypeOffset, 1))
3341         }
3342 
3343         return success;
3344     }
3345 
3346     function verifyERC1271Signature(
3347         bytes32 signHash,
3348         address signer,
3349         bytes   memory signature
3350         )
3351         private
3352         view
3353         returns (bool)
3354     {
3355         bytes memory callData = abi.encodeWithSelector(
3356             ERC1271.isValidSignature.selector,
3357             signHash,
3358             signature
3359         );
3360         (bool success, bytes memory result) = signer.staticcall(callData);
3361         return (
3362             success &&
3363             result.length == 32 &&
3364             result.toBytes4(0) == ERC1271_MAGICVALUE
3365         );
3366     }
3367 }
3368 
3369 // Copyright 2017 Loopring Technology Limited.
3370 
3371 
3372 
3373 
3374 
3375 
3376 
3377 // Copyright 2017 Loopring Technology Limited.
3378 
3379 
3380 
3381 
3382 
3383 
3384 
3385 
3386 
3387 
3388 /// @title DepositTransaction
3389 /// @author Brecht Devos - <brecht@loopring.org>
3390 library DepositTransaction
3391 {
3392     using BytesUtil   for bytes;
3393     using MathUint96  for uint96;
3394 
3395     struct Deposit
3396     {
3397         address to;
3398         uint32  toAccountID;
3399         uint16  tokenID;
3400         uint96  amount;
3401     }
3402 
3403     /*event DepositProcessed(
3404         address to,
3405         uint32  toAccountId,
3406         uint16  token,
3407         uint    amount
3408     );*/
3409 
3410     function process(
3411         ExchangeData.State        storage S,
3412         ExchangeData.BlockContext memory  /*ctx*/,
3413         bytes                     memory  data,
3414         uint                              offset,
3415         bytes                     memory  /*auxiliaryData*/
3416         )
3417         internal
3418     {
3419         // Read in the deposit
3420         Deposit memory deposit = readTx(data, offset);
3421 
3422         // Process the deposit
3423         ExchangeData.Deposit memory pendingDeposit = S.pendingDeposits[deposit.to][deposit.tokenID];
3424         // Make sure the deposit was actually done
3425         require(pendingDeposit.timestamp > 0, "DEPOSIT_DOESNT_EXIST");
3426         // Processing partial amounts of the deposited amount is allowed.
3427         // This is done to ensure the user can do multiple deposits after each other
3428         // without invalidating work done by the exchange owner for previous deposit amounts.
3429 
3430         // Also note the original deposit.amount can be zero!
3431         if (deposit.amount > 0) {
3432             require(pendingDeposit.amount >= deposit.amount, "INVALID_AMOUNT");
3433             pendingDeposit.amount = pendingDeposit.amount.sub(deposit.amount);
3434         }
3435 
3436         // If the deposit was fully consumed, reset it so the storage is freed up
3437         // and the owner receives a gas refund.
3438         if (pendingDeposit.amount == 0) {
3439             delete S.pendingDeposits[deposit.to][deposit.tokenID];
3440         } else {
3441             S.pendingDeposits[deposit.to][deposit.tokenID] = pendingDeposit;
3442         }
3443 
3444         //emit DepositProcessed(deposit.to, deposit.toAccountID, deposit.tokenID, deposit.amount);
3445     }
3446 
3447     function readTx(
3448         bytes memory data,
3449         uint         offset
3450         )
3451         internal
3452         pure
3453         returns (Deposit memory deposit)
3454     {
3455         uint _offset = offset;
3456         // We don't use abi.decode for this because of the large amount of zero-padding
3457         // bytes the circuit would also have to hash.
3458         deposit.to = data.toAddress(_offset);
3459         _offset += 20;
3460         deposit.toAccountID = data.toUint32(_offset);
3461         _offset += 4;
3462         deposit.tokenID = data.toUint16(_offset);
3463         _offset += 2;
3464         deposit.amount = data.toUint96(_offset);
3465         _offset += 12;
3466     }
3467 }
3468 
3469 
3470 // Copyright 2017 Loopring Technology Limited.
3471 
3472 
3473 
3474 
3475 
3476 
3477 
3478 
3479 
3480 
3481 
3482 /// @title TransferTransaction
3483 /// @author Brecht Devos - <brecht@loopring.org>
3484 library TransferTransaction
3485 {
3486     using BytesUtil            for bytes;
3487     using FloatUtil            for uint;
3488     using MathUint             for uint;
3489     using ExchangeSignatures   for ExchangeData.State;
3490 
3491     bytes32 constant public TRANSFER_TYPEHASH = keccak256(
3492         "Transfer(address from,address to,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,uint32 validUntil,uint32 storageID)"
3493     );
3494 
3495     struct Transfer
3496     {
3497         uint32  fromAccountID;
3498         uint32  toAccountID;
3499         address from;
3500         address to;
3501         uint16  tokenID;
3502         uint96  amount;
3503         uint16  feeTokenID;
3504         uint96  maxFee;
3505         uint96  fee;
3506         uint32  validUntil;
3507         uint32  storageID;
3508     }
3509 
3510     // Auxiliary data for each transfer
3511     struct TransferAuxiliaryData
3512     {
3513         bytes  signature;
3514         uint96 maxFee;
3515         uint32 validUntil;
3516     }
3517 
3518     /*event ConditionalTransferProcessed(
3519         address from,
3520         address to,
3521         uint16  token,
3522         uint    amount
3523     );*/
3524 
3525     function process(
3526         ExchangeData.State        storage S,
3527         ExchangeData.BlockContext memory  ctx,
3528         bytes                     memory  data,
3529         uint                              offset,
3530         bytes                     memory  auxiliaryData
3531         )
3532         internal
3533     {
3534         // Read the transfer
3535         Transfer memory transfer = readTx(data, offset);
3536         TransferAuxiliaryData memory auxData = abi.decode(auxiliaryData, (TransferAuxiliaryData));
3537 
3538         // Fill in withdrawal data missing from DA
3539         transfer.validUntil = auxData.validUntil;
3540         transfer.maxFee = auxData.maxFee == 0 ? transfer.fee : auxData.maxFee;
3541         // Validate
3542         require(ctx.timestamp < transfer.validUntil, "TRANSFER_EXPIRED");
3543         require(transfer.fee <= transfer.maxFee, "TRANSFER_FEE_TOO_HIGH");
3544 
3545         // Calculate the tx hash
3546         bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, transfer);
3547 
3548         // Check the on-chain authorization
3549         S.requireAuthorizedTx(transfer.from, auxData.signature, txHash);
3550 
3551         //emit ConditionalTransferProcessed(from, to, tokenID, amount);
3552     }
3553 
3554     function readTx(
3555         bytes memory data,
3556         uint         offset
3557         )
3558         internal
3559         pure
3560         returns (Transfer memory transfer)
3561     {
3562         uint _offset = offset;
3563         // Check that this is a conditional transfer
3564         require(data.toUint8(_offset) == 1, "INVALID_AUXILIARYDATA_DATA");
3565         _offset += 1;
3566 
3567         // Extract the transfer data
3568         // We don't use abi.decode for this because of the large amount of zero-padding
3569         // bytes the circuit would also have to hash.
3570         transfer.fromAccountID = data.toUint32(_offset);
3571         _offset += 4;
3572         transfer.toAccountID = data.toUint32(_offset);
3573         _offset += 4;
3574         transfer.tokenID = data.toUint16(_offset);
3575         _offset += 2;
3576         transfer.amount = uint(data.toUint24(_offset)).decodeFloat(24);
3577         _offset += 3;
3578         transfer.feeTokenID = data.toUint16(_offset);
3579         _offset += 2;
3580         transfer.fee = uint(data.toUint16(_offset)).decodeFloat(16);
3581         _offset += 2;
3582         transfer.storageID = data.toUint32(_offset);
3583         _offset += 4;
3584         transfer.to = data.toAddress(_offset);
3585         _offset += 20;
3586         transfer.from = data.toAddress(_offset);
3587         _offset += 20;
3588     }
3589 
3590     function hashTx(
3591         bytes32 DOMAIN_SEPARATOR,
3592         Transfer memory transfer
3593         )
3594         internal
3595         pure
3596         returns (bytes32)
3597     {
3598         return EIP712.hashPacked(
3599             DOMAIN_SEPARATOR,
3600             keccak256(
3601                 abi.encode(
3602                     TRANSFER_TYPEHASH,
3603                     transfer.from,
3604                     transfer.to,
3605                     transfer.tokenID,
3606                     transfer.amount,
3607                     transfer.feeTokenID,
3608                     transfer.maxFee,
3609                     transfer.validUntil,
3610                     transfer.storageID
3611                 )
3612             )
3613         );
3614     }
3615 }
3616 
3617 
3618 // Copyright 2017 Loopring Technology Limited.
3619 
3620 
3621 
3622 
3623 
3624 
3625 
3626 
3627 
3628 
3629 // Copyright 2017 Loopring Technology Limited.
3630 
3631 
3632 
3633 
3634 
3635 
3636 
3637 /// @title ExchangeMode.
3638 /// @dev All methods in this lib are internal, therefore, there is no need
3639 ///      to deploy this library independently.
3640 /// @author Brecht Devos - <brecht@loopring.org>
3641 /// @author Daniel Wang  - <daniel@loopring.org>
3642 library ExchangeMode
3643 {
3644     using MathUint  for uint;
3645 
3646     function isInWithdrawalMode(
3647         ExchangeData.State storage S
3648         )
3649         internal // inline call
3650         view
3651         returns (bool result)
3652     {
3653         result = S.withdrawalModeStartTime > 0;
3654     }
3655 
3656     function isShutdown(
3657         ExchangeData.State storage S
3658         )
3659         internal // inline call
3660         view
3661         returns (bool)
3662     {
3663         return S.shutdownModeStartTime > 0;
3664     }
3665 
3666     function getNumAvailableForcedSlots(
3667         ExchangeData.State storage S
3668         )
3669         internal
3670         view
3671         returns (uint)
3672     {
3673         return ExchangeData.MAX_OPEN_FORCED_REQUESTS() - S.numPendingForcedTransactions;
3674     }
3675 }
3676 
3677 
3678 
3679 // Copyright 2017 Loopring Technology Limited.
3680 
3681 
3682 
3683 
3684 
3685 
3686 
3687 
3688 
3689 
3690 
3691 /// @title ExchangeWithdrawals.
3692 /// @author Brecht Devos - <brecht@loopring.org>
3693 /// @author Daniel Wang  - <daniel@loopring.org>
3694 library ExchangeWithdrawals
3695 {
3696     enum WithdrawalCategory
3697     {
3698         DISTRIBUTION,
3699         FROM_MERKLE_TREE,
3700         FROM_DEPOSIT_REQUEST,
3701         FROM_APPROVED_WITHDRAWAL
3702     }
3703 
3704     using AddressUtil       for address;
3705     using AddressUtil       for address payable;
3706     using BytesUtil         for bytes;
3707     using MathUint          for uint;
3708     using ExchangeBalances  for ExchangeData.State;
3709     using ExchangeMode      for ExchangeData.State;
3710     using ExchangeTokens    for ExchangeData.State;
3711 
3712     event ForcedWithdrawalRequested(
3713         address owner,
3714         address token,
3715         uint32  accountID
3716     );
3717 
3718     event WithdrawalCompleted(
3719         uint8   category,
3720         address from,
3721         address to,
3722         address token,
3723         uint    amount
3724     );
3725 
3726     event WithdrawalFailed(
3727         uint8   category,
3728         address from,
3729         address to,
3730         address token,
3731         uint    amount
3732     );
3733 
3734     function forceWithdraw(
3735         ExchangeData.State storage S,
3736         address owner,
3737         address token,
3738         uint32  accountID
3739         )
3740         public
3741     {
3742         require(!S.isInWithdrawalMode(), "INVALID_MODE");
3743         require(S.getNumAvailableForcedSlots() > 0, "TOO_MANY_REQUESTS_OPEN");
3744         require(accountID < ExchangeData.MAX_NUM_ACCOUNTS(), "INVALID_ACCOUNTID");
3745 
3746         uint16 tokenID = S.getTokenID(token);
3747 
3748         uint withdrawalFeeETH = S.loopring.forcedWithdrawalFee();
3749 
3750         // Check ETH value sent, can be larger than the expected withdraw fee
3751         require(msg.value >= withdrawalFeeETH, "INSUFFICIENT_FEE");
3752 
3753         // Send surplus of ETH back to the sender
3754         uint feeSurplus = msg.value.sub(withdrawalFeeETH);
3755         if (feeSurplus > 0) {
3756             msg.sender.sendETHAndVerify(feeSurplus, gasleft());
3757         }
3758 
3759         require(
3760             S.pendingForcedWithdrawals[accountID][tokenID].timestamp == 0,
3761             "WITHDRAWAL_ALREADY_PENDING"
3762         );
3763 
3764         S.pendingForcedWithdrawals[accountID][tokenID] = ExchangeData.ForcedWithdrawal({
3765             owner: owner,
3766             timestamp: uint64(block.timestamp)
3767         });
3768 
3769         S.numPendingForcedTransactions++;
3770 
3771         emit ForcedWithdrawalRequested(
3772             owner,
3773             token,
3774             accountID
3775         );
3776     }
3777 
3778     // We still alow anyone to withdraw these funds for the account owner
3779     function withdrawFromMerkleTree(
3780         ExchangeData.State       storage S,
3781         ExchangeData.MerkleProof calldata merkleProof
3782         )
3783         public
3784     {
3785         require(S.isInWithdrawalMode(), "NOT_IN_WITHDRAW_MODE");
3786 
3787         address owner = merkleProof.accountLeaf.owner;
3788         uint32 accountID = merkleProof.accountLeaf.accountID;
3789         uint16 tokenID = merkleProof.balanceLeaf.tokenID;
3790         uint96 balance = merkleProof.balanceLeaf.balance;
3791 
3792         require(S.withdrawnInWithdrawMode[accountID][tokenID] == false, "WITHDRAWN_ALREADY");
3793 
3794         ExchangeBalances.verifyAccountBalance(
3795             uint(S.merkleRoot),
3796             merkleProof
3797         );
3798 
3799         // Make sure the balance can only be withdrawn once
3800         S.withdrawnInWithdrawMode[accountID][tokenID] = true;
3801 
3802         // Transfer the tokens
3803         transferTokens(
3804             S,
3805             uint8(WithdrawalCategory.FROM_MERKLE_TREE),
3806             owner,
3807             owner,
3808             tokenID,
3809             balance,
3810             new bytes(0),
3811             gasleft(),
3812             false
3813         );
3814     }
3815 
3816     function withdrawFromDepositRequest(
3817         ExchangeData.State storage S,
3818         address owner,
3819         address token
3820         )
3821         public
3822     {
3823         uint16 tokenID = S.getTokenID(token);
3824         ExchangeData.Deposit storage deposit = S.pendingDeposits[owner][tokenID];
3825         require(deposit.timestamp != 0, "DEPOSIT_NOT_WITHDRAWABLE_YET");
3826 
3827         // Check if the deposit has indeed exceeded the time limit of if the exchange is in withdrawal mode
3828         require(
3829             block.timestamp >= deposit.timestamp + S.maxAgeDepositUntilWithdrawable ||
3830             S.isInWithdrawalMode(),
3831             "DEPOSIT_NOT_WITHDRAWABLE_YET"
3832         );
3833 
3834         uint amount = deposit.amount;
3835 
3836         // Reset the deposit request
3837         delete S.pendingDeposits[owner][tokenID];
3838 
3839         // Transfer the tokens
3840         transferTokens(
3841             S,
3842             uint8(WithdrawalCategory.FROM_DEPOSIT_REQUEST),
3843             owner,
3844             owner,
3845             tokenID,
3846             amount,
3847             new bytes(0),
3848             gasleft(),
3849             false
3850         );
3851     }
3852 
3853     function withdrawFromApprovedWithdrawals(
3854         ExchangeData.State storage S,
3855         address[] memory owners,
3856         address[] memory tokens
3857         )
3858         public
3859     {
3860         require(owners.length == tokens.length, "INVALID_INPUT_DATA");
3861         for (uint i = 0; i < owners.length; i++) {
3862             address owner = owners[i];
3863             uint16 tokenID = S.getTokenID(tokens[i]);
3864             uint amount = S.amountWithdrawable[owner][tokenID];
3865 
3866             // Make sure this amount can't be withdrawn again
3867             delete S.amountWithdrawable[owner][tokenID];
3868 
3869             // Transfer the tokens
3870             transferTokens(
3871                 S,
3872                 uint8(WithdrawalCategory.FROM_APPROVED_WITHDRAWAL),
3873                 owner,
3874                 owner,
3875                 tokenID,
3876                 amount,
3877                 new bytes(0),
3878                 gasleft(),
3879                 false
3880             );
3881         }
3882     }
3883 
3884     function distributeWithdrawal(
3885         ExchangeData.State storage S,
3886         address from,
3887         address to,
3888         uint16  tokenID,
3889         uint    amount,
3890         bytes   memory extraData,
3891         uint    gasLimit
3892         )
3893         public
3894     {
3895         // Try to transfer the tokens
3896         bool success = transferTokens(
3897             S,
3898             uint8(WithdrawalCategory.DISTRIBUTION),
3899             from,
3900             to,
3901             tokenID,
3902             amount,
3903             extraData,
3904             gasLimit,
3905             true
3906         );
3907         if (!success) {
3908             // Allow the amount to be withdrawn using `withdrawFromApprovedWithdrawal`.
3909             S.amountWithdrawable[to][tokenID] = S.amountWithdrawable[to][tokenID].add(amount);
3910         }
3911     }
3912 
3913     // == Internal and Private Functions ==
3914 
3915     // If allowFailure is true the transfer can fail because of a transfer error or
3916     // because the transfer uses more than `gasLimit` gas. The function
3917     // will return true when successful, false otherwise.
3918     // If allowFailure is false the transfer is guaranteed to succeed using
3919     // as much gas as needed, otherwise it throws. The function always returns true.
3920     function transferTokens(
3921         ExchangeData.State storage S,
3922         uint8   category,
3923         address from,
3924         address to,
3925         uint16  tokenID,
3926         uint    amount,
3927         bytes   memory extraData,
3928         uint    gasLimit,
3929         bool    allowFailure
3930         )
3931         private
3932         returns (bool success)
3933     {
3934         if (to == address(0)) {
3935             to = S.loopring.protocolFeeVault();
3936         }
3937         address token = S.getTokenAddress(tokenID);
3938 
3939         // Transfer the tokens from the deposit contract to the owner
3940         if (gasLimit > 0) {
3941             try S.depositContract.withdraw{gas: gasLimit}(from, to, token, amount, extraData) {
3942                 success = true;
3943             } catch {
3944                 success = false;
3945             }
3946         } else {
3947             success = false;
3948         }
3949 
3950         require(allowFailure || success, "TRANSFER_FAILURE");
3951 
3952         if (success) {
3953             emit WithdrawalCompleted(category, from, to, token, amount);
3954 
3955             if (from == address(0)) {
3956                 S.protocolFeeLastWithdrawnTime[token] = block.timestamp;
3957             }
3958         } else {
3959             emit WithdrawalFailed(category, from, to, token, amount);
3960         }
3961     }
3962 }
3963 
3964 
3965 
3966 /// @title WithdrawTransaction
3967 /// @author Brecht Devos - <brecht@loopring.org>
3968 /// @dev The following 4 types of withdrawals are supported:
3969 ///      - withdrawType = 0: offchain withdrawals with EdDSA signatures
3970 ///      - withdrawType = 1: offchain withdrawals with ECDSA signatures or onchain appprovals
3971 ///      - withdrawType = 2: onchain valid forced withdrawals (owner and accountID match), or
3972 ///                          offchain operator-initiated withdrawals for protocol fees or for
3973 ///                          users in shutdown mode
3974 ///      - withdrawType = 3: onchain invalid forced withdrawals (owner and accountID mismatch)
3975 library WithdrawTransaction
3976 {
3977     using BytesUtil            for bytes;
3978     using FloatUtil            for uint;
3979     using MathUint             for uint;
3980     using ExchangeMode         for ExchangeData.State;
3981     using ExchangeSignatures   for ExchangeData.State;
3982     using ExchangeWithdrawals  for ExchangeData.State;
3983 
3984     bytes32 constant public WITHDRAWAL_TYPEHASH = keccak256(
3985         "Withdrawal(address owner,uint32 accountID,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,address to,bytes extraData,uint256 minGas,uint32 validUntil,uint32 storageID)"
3986     );
3987 
3988     struct Withdrawal
3989     {
3990         uint    withdrawalType;
3991         address from;
3992         uint32  fromAccountID;
3993         uint16  tokenID;
3994         uint96  amount;
3995         uint16  feeTokenID;
3996         uint96  maxFee;
3997         uint96  fee;
3998         address to;
3999         bytes   extraData;
4000         uint    minGas;
4001         uint32  validUntil;
4002         uint32  storageID;
4003         bytes20 onchainDataHash;
4004     }
4005 
4006     // Auxiliary data for each withdrawal
4007     struct WithdrawalAuxiliaryData
4008     {
4009         bool  storeRecipient;
4010         uint  gasLimit;
4011         bytes signature;
4012 
4013         uint    minGas;
4014         address to;
4015         bytes   extraData;
4016         uint96  maxFee;
4017         uint32  validUntil;
4018     }
4019 
4020     /*event ForcedWithdrawalProcessed(
4021         uint32 accountID,
4022         uint16 tokenID,
4023         uint   amount
4024     );*/
4025 
4026     function process(
4027         ExchangeData.State        storage S,
4028         ExchangeData.BlockContext memory  ctx,
4029         bytes                     memory  data,
4030         uint                              offset,
4031         bytes                     memory  auxiliaryData
4032         )
4033         internal
4034     {
4035         Withdrawal memory withdrawal = readTx(data, offset);
4036         WithdrawalAuxiliaryData memory auxData = abi.decode(auxiliaryData, (WithdrawalAuxiliaryData));
4037 
4038         // Validate the withdrawal data not directly part of the DA
4039         bytes20 onchainDataHash = hashOnchainData(
4040             auxData.minGas,
4041             auxData.to,
4042             auxData.extraData
4043         );
4044         // Only the 20 MSB are used, which is still 80-bit of security, which is more
4045         // than enough, especially when combined with validUntil.
4046         require(withdrawal.onchainDataHash == onchainDataHash, "INVALID_WITHDRAWAL_DATA");
4047 
4048         // Fill in withdrawal data missing from DA
4049         withdrawal.to = auxData.to;
4050         withdrawal.minGas = auxData.minGas;
4051         withdrawal.extraData = auxData.extraData;
4052         withdrawal.maxFee = auxData.maxFee == 0 ? withdrawal.fee : auxData.maxFee;
4053         withdrawal.validUntil = auxData.validUntil;
4054 
4055         if (withdrawal.withdrawalType == 0) {
4056             // Signature checked offchain, nothing to do
4057         } else if (withdrawal.withdrawalType == 1) {
4058             // Validate
4059             require(ctx.timestamp < withdrawal.validUntil, "WITHDRAWAL_EXPIRED");
4060             require(withdrawal.fee <= withdrawal.maxFee, "WITHDRAWAL_FEE_TOO_HIGH");
4061 
4062             // Check appproval onchain
4063             // Calculate the tx hash
4064             bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, withdrawal);
4065             // Check onchain authorization
4066             S.requireAuthorizedTx(withdrawal.from, auxData.signature, txHash);
4067         } else if (withdrawal.withdrawalType == 2 || withdrawal.withdrawalType == 3) {
4068             // Forced withdrawals cannot make use of certain features because the
4069             // necessary data is not authorized by the account owner.
4070             // For protocol fee withdrawals, `owner` and `to` are both address(0).
4071             require(withdrawal.from == withdrawal.to, "INVALID_WITHDRAWAL_ADDRESS");
4072 
4073             // Forced withdrawal fees are charged when the request is submitted.
4074             require(withdrawal.fee == 0, "FEE_NOT_ZERO");
4075 
4076             require(withdrawal.extraData.length == 0, "AUXILIARY_DATA_NOT_ALLOWED");
4077 
4078             ExchangeData.ForcedWithdrawal memory forcedWithdrawal =
4079                 S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];
4080 
4081             if (forcedWithdrawal.timestamp != 0) {
4082                 if (withdrawal.withdrawalType == 2) {
4083                     require(withdrawal.from == forcedWithdrawal.owner, "INCONSISENT_OWNER");
4084                 } else { //withdrawal.withdrawalType == 3
4085                     require(withdrawal.from != forcedWithdrawal.owner, "INCONSISENT_OWNER");
4086                     require(withdrawal.amount == 0, "UNAUTHORIZED_WITHDRAWAL");
4087                 }
4088 
4089                 // delete the withdrawal request and free a slot
4090                 delete S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];
4091                 S.numPendingForcedTransactions--;
4092 
4093                 /*emit ForcedWithdrawalProcessed(
4094                     withdrawal.fromAccountID,
4095                     withdrawal.tokenID,
4096                     withdrawal.amount
4097                 );*/
4098             } else {
4099                 // Allow the owner to submit full withdrawals without authorization
4100                 // - when in shutdown mode
4101                 // - to withdraw protocol fees
4102                 require(
4103                     withdrawal.fromAccountID == ExchangeData.ACCOUNTID_PROTOCOLFEE() ||
4104                     S.isShutdown(),
4105                     "FULL_WITHDRAWAL_UNAUTHORIZED"
4106                 );
4107             }
4108         } else {
4109             revert("INVALID_WITHDRAWAL_TYPE");
4110         }
4111 
4112         // Check if there is a withdrawal recipient
4113         address recipient = S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];
4114         if (recipient != address(0)) {
4115             // Auxiliary data is not supported
4116             require (withdrawal.extraData.length == 0, "AUXILIARY_DATA_NOT_ALLOWED");
4117 
4118             // Set the new recipient address
4119             withdrawal.to = recipient;
4120             // Allow any amount of gas to be used on this withdrawal (which allows the transfer to be skipped)
4121             withdrawal.minGas = 0;
4122 
4123             // Do NOT delete the recipient to prevent replay attack
4124             // delete S.withdrawalRecipient[withdrawal.owner][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];
4125         } else if (auxData.storeRecipient) {
4126             // Store the destination address to mark the withdrawal as done
4127             require(withdrawal.to != address(0), "INVALID_DESTINATION_ADDRESS");
4128             S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID] = withdrawal.to;
4129         }
4130 
4131         // Validate gas provided
4132         require(auxData.gasLimit >= withdrawal.minGas, "OUT_OF_GAS_FOR_WITHDRAWAL");
4133 
4134         // Try to transfer the tokens with the provided gas limit
4135         S.distributeWithdrawal(
4136             withdrawal.from,
4137             withdrawal.to,
4138             withdrawal.tokenID,
4139             withdrawal.amount,
4140             withdrawal.extraData,
4141             auxData.gasLimit
4142         );
4143     }
4144 
4145     function readTx(
4146         bytes memory data,
4147         uint         offset
4148         )
4149         internal
4150         pure
4151         returns (Withdrawal memory withdrawal)
4152     {
4153         uint _offset = offset;
4154         // Extract the transfer data
4155         // We don't use abi.decode for this because of the large amount of zero-padding
4156         // bytes the circuit would also have to hash.
4157         withdrawal.withdrawalType = data.toUint8(_offset);
4158         _offset += 1;
4159         withdrawal.from = data.toAddress(_offset);
4160         _offset += 20;
4161         withdrawal.fromAccountID = data.toUint32(_offset);
4162         _offset += 4;
4163         withdrawal.tokenID = data.toUint16(_offset);
4164         _offset += 2;
4165         withdrawal.amount = data.toUint96(_offset);
4166         _offset += 12;
4167         withdrawal.feeTokenID = data.toUint16(_offset);
4168         _offset += 2;
4169         withdrawal.fee = uint(data.toUint16(_offset)).decodeFloat(16);
4170         _offset += 2;
4171         withdrawal.storageID = data.toUint32(_offset);
4172         _offset += 4;
4173         withdrawal.onchainDataHash = data.toBytes20(_offset);
4174         _offset += 20;
4175     }
4176 
4177     function hashTx(
4178         bytes32 DOMAIN_SEPARATOR,
4179         Withdrawal memory withdrawal
4180         )
4181         internal
4182         pure
4183         returns (bytes32)
4184     {
4185         return EIP712.hashPacked(
4186             DOMAIN_SEPARATOR,
4187             keccak256(
4188                 abi.encode(
4189                     WITHDRAWAL_TYPEHASH,
4190                     withdrawal.from,
4191                     withdrawal.fromAccountID,
4192                     withdrawal.tokenID,
4193                     withdrawal.amount,
4194                     withdrawal.feeTokenID,
4195                     withdrawal.maxFee,
4196                     withdrawal.to,
4197                     keccak256(withdrawal.extraData),
4198                     withdrawal.minGas,
4199                     withdrawal.validUntil,
4200                     withdrawal.storageID
4201                 )
4202             )
4203         );
4204     }
4205 
4206     function hashOnchainData(
4207         uint    minGas,
4208         address to,
4209         bytes   memory extraData
4210         )
4211         internal
4212         pure
4213         returns (bytes20)
4214     {
4215         // Only the 20 MSB are used, which is still 80-bit of security, which is more
4216         // than enough, especially when combined with validUntil.
4217         return bytes20(keccak256(
4218             abi.encodePacked(
4219                 minGas,
4220                 to,
4221                 extraData
4222             )
4223         ));
4224     }
4225 }
4226 
4227 
4228 /// @title TransactionReader
4229 /// @author Brecht Devos - <brecht@loopring.org>
4230 /// @dev Utility library to read transactions.
4231 library TransactionReader {
4232     using BlockReader       for ExchangeData.Block;
4233     using TransactionReader for ExchangeData.Block;
4234     using BytesUtil         for bytes;
4235 
4236     function readDeposit(
4237         ExchangeData.Block memory _block,
4238         uint txIdx
4239         )
4240         internal
4241         pure
4242         returns (DepositTransaction.Deposit memory)
4243     {
4244         bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.DEPOSIT);
4245         return DepositTransaction.readTx(data, 1);
4246     }
4247 
4248     function readWithdrawal(
4249         ExchangeData.Block memory _block,
4250         uint txIdx
4251         )
4252         internal
4253         pure
4254         returns (WithdrawTransaction.Withdrawal memory)
4255     {
4256         bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.WITHDRAWAL);
4257         return WithdrawTransaction.readTx(data, 1);
4258     }
4259 
4260     function readAmmUpdate(
4261         ExchangeData.Block memory _block,
4262         uint txIdx
4263         )
4264         internal
4265         pure
4266         returns (AmmUpdateTransaction.AmmUpdate memory)
4267     {
4268         bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.AMM_UPDATE);
4269         return AmmUpdateTransaction.readTx(data, 1);
4270     }
4271 
4272     function readTransfer(
4273         ExchangeData.Block memory _block,
4274         uint txIdx
4275         )
4276         internal
4277         pure
4278         returns (TransferTransaction.Transfer memory)
4279     {
4280         bytes memory data = _block.readTx(txIdx, ExchangeData.TransactionType.TRANSFER);
4281         return TransferTransaction.readTx(data, 1);
4282     }
4283 
4284     function readTx(
4285         ExchangeData.Block memory _block,
4286         uint txIdx,
4287         ExchangeData.TransactionType txType
4288         )
4289         internal
4290         pure
4291         returns (bytes memory data)
4292     {
4293         data = _block.readTransactionData(txIdx);
4294         require(txType == ExchangeData.TransactionType(data.toUint8(0)), "UNEXPTECTED_TX_TYPE");
4295     }
4296 
4297     function createMinimalBlock(
4298         ExchangeData.Block memory _block,
4299         uint txIdx,
4300         uint16 numTransactions
4301         )
4302         internal
4303         pure
4304         returns (ExchangeData.Block memory)
4305     {
4306         ExchangeData.Block memory minimalBlock = ExchangeData.Block({
4307             blockType: _block.blockType,
4308             blockSize: numTransactions,
4309             blockVersion: _block.blockVersion,
4310             data: new bytes(0),
4311             proof: _block.proof,
4312             storeBlockInfoOnchain: _block.storeBlockInfoOnchain,
4313             auxiliaryData: new ExchangeData.AuxiliaryData[](0),
4314             offchainData: new bytes(0)
4315         });
4316 
4317         bytes memory header = _block.data.slice(0, BlockReader.OFFSET_TO_TRANSACTIONS);
4318 
4319         // Extract the data of the transactions we want
4320         // Part 1
4321         uint txDataOffset = BlockReader.OFFSET_TO_TRANSACTIONS +
4322             txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1();
4323         bytes memory dataPart1 = _block.data.slice(txDataOffset, numTransactions * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1());
4324         // Part 2
4325         txDataOffset = BlockReader.OFFSET_TO_TRANSACTIONS +
4326             _block.blockSize * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1() +
4327             txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2();
4328         bytes memory dataPart2 = _block.data.slice(txDataOffset, numTransactions * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2());
4329 
4330         // Set the data on the block in the standard format
4331         minimalBlock.data = header.concat(dataPart1).concat(dataPart2);
4332 
4333         return minimalBlock;
4334     }
4335 }
4336 
4337 // Copyright 2017 Loopring Technology Limited.
4338 
4339 
4340 
4341 
4342 // Copyright 2017 Loopring Technology Limited.
4343 
4344 
4345 
4346 /// @title ZeroDecompressor
4347 /// @author Brecht Devos - <brecht@loopring.org>
4348 /// @dev Easy decompressor that compresses runs of zeros.
4349 /// The format is very simple. Each entry consists of
4350 /// (uint16 numDataBytes, uint16 numZeroBytes) which will
4351 /// copy `numDataBytes` data bytes from `data` and will
4352 /// add an additional `numZeroBytes` after it.
4353 library ZeroDecompressor
4354 {
4355     function decompress(
4356         bytes calldata /*data*/,
4357         uint  parameterIdx
4358         )
4359         internal
4360         pure
4361         returns (bytes memory)
4362     {
4363         bytes memory uncompressed;
4364         uint offsetPos = 4 + 32 * parameterIdx;
4365         assembly {
4366             uncompressed := mload(0x40)
4367             let ptr := add(uncompressed, 32)
4368             let offset := add(4, calldataload(offsetPos))
4369             let pos := add(offset, 4)
4370             let dataLength := add(calldataload(offset), pos)
4371             let tupple := 0
4372             let numDataBytes := 0
4373             let numZeroBytes := 0
4374 
4375             for {} lt(pos, dataLength) {} {
4376                 tupple := and(calldataload(pos), 0xFFFFFFFF)
4377                 numDataBytes := shr(16, tupple)
4378                 numZeroBytes := and(tupple, 0xFFFF)
4379                 calldatacopy(ptr, add(32, pos), numDataBytes)
4380                 pos := add(pos, add(4, numDataBytes))
4381                 ptr := add(ptr, add(numDataBytes, numZeroBytes))
4382             }
4383 
4384             // Store data length
4385             mstore(uncompressed, sub(sub(ptr, uncompressed), 32))
4386 
4387             // Update free memory pointer
4388             mstore(0x40, add(ptr, 0x20))
4389         }
4390         return uncompressed;
4391     }
4392 }
4393 
4394 
4395 
4396 // Copyright 2017 Loopring Technology Limited.
4397 
4398 
4399 
4400 
4401 
4402 
4403 
4404 /// @title IExchangeV3
4405 /// @dev Note that Claimable and RentrancyGuard are inherited here to
4406 ///      ensure all data members are declared on IExchangeV3 to make it
4407 ///      easy to support upgradability through proxies.
4408 ///
4409 ///      Subclasses of this contract must NOT define constructor to
4410 ///      initialize data.
4411 ///
4412 /// @author Brecht Devos - <brecht@loopring.org>
4413 /// @author Daniel Wang  - <daniel@loopring.org>
4414 abstract contract IExchangeV3 is Claimable
4415 {
4416     // -- Events --
4417 
4418     event ExchangeCloned(
4419         address exchangeAddress,
4420         address owner,
4421         bytes32 genesisMerkleRoot
4422     );
4423 
4424     event TokenRegistered(
4425         address token,
4426         uint16  tokenId
4427     );
4428 
4429     event Shutdown(
4430         uint timestamp
4431     );
4432 
4433     event WithdrawalModeActivated(
4434         uint timestamp
4435     );
4436 
4437     event BlockSubmitted(
4438         uint    indexed blockIdx,
4439         bytes32         merkleRoot,
4440         bytes32         publicDataHash
4441     );
4442 
4443     event DepositRequested(
4444         address from,
4445         address to,
4446         address token,
4447         uint16  tokenId,
4448         uint96  amount
4449     );
4450 
4451     event ForcedWithdrawalRequested(
4452         address owner,
4453         address token,
4454         uint32  accountID
4455     );
4456 
4457     event WithdrawalCompleted(
4458         uint8   category,
4459         address from,
4460         address to,
4461         address token,
4462         uint    amount
4463     );
4464 
4465     event WithdrawalFailed(
4466         uint8   category,
4467         address from,
4468         address to,
4469         address token,
4470         uint    amount
4471     );
4472 
4473     event ProtocolFeesUpdated(
4474         uint8 takerFeeBips,
4475         uint8 makerFeeBips,
4476         uint8 previousTakerFeeBips,
4477         uint8 previousMakerFeeBips
4478     );
4479 
4480     event TransactionApproved(
4481         address owner,
4482         bytes32 transactionHash
4483     );
4484 
4485     // events from libraries
4486     /*event DepositProcessed(
4487         address to,
4488         uint32  toAccountId,
4489         uint16  token,
4490         uint    amount
4491     );*/
4492 
4493     /*event ForcedWithdrawalProcessed(
4494         uint32 fromAccountID,
4495         uint16 tokenID,
4496         uint   amount
4497     );*/
4498 
4499     /*event ConditionalTransferProcessed(
4500         address from,
4501         address to,
4502         uint16  token,
4503         uint    amount
4504     );*/
4505 
4506     /*event AccountUpdated(
4507         uint32 owner,
4508         uint   publicKey
4509     );*/
4510 
4511 
4512     // -- Initialization --
4513     /// @dev Initializes this exchange. This method can only be called once.
4514     /// @param  loopring The LoopringV3 contract address.
4515     /// @param  owner The owner of this exchange.
4516     /// @param  genesisMerkleRoot The initial Merkle tree state.
4517     function initialize(
4518         address loopring,
4519         address owner,
4520         bytes32 genesisMerkleRoot
4521         )
4522         virtual
4523         external;
4524 
4525     /// @dev Initialized the agent registry contract used by the exchange.
4526     ///      Can only be called by the exchange owner once.
4527     /// @param agentRegistry The agent registry contract to be used
4528     function setAgentRegistry(address agentRegistry)
4529         external
4530         virtual;
4531 
4532     /// @dev Gets the agent registry contract used by the exchange.
4533     /// @return the agent registry contract
4534     function getAgentRegistry()
4535         external
4536         virtual
4537         view
4538         returns (IAgentRegistry);
4539 
4540     ///      Can only be called by the exchange owner once.
4541     /// @param depositContract The deposit contract to be used
4542     function setDepositContract(address depositContract)
4543         external
4544         virtual;
4545 
4546     /// @dev Gets the deposit contract used by the exchange.
4547     /// @return the deposit contract
4548     function getDepositContract()
4549         external
4550         virtual
4551         view
4552         returns (IDepositContract);
4553 
4554     // @dev Exchange owner withdraws fees from the exchange.
4555     // @param token Fee token address
4556     // @param feeRecipient Fee recipient address
4557     function withdrawExchangeFees(
4558         address token,
4559         address feeRecipient
4560         )
4561         external
4562         virtual;
4563 
4564     // -- Constants --
4565     /// @dev Returns a list of constants used by the exchange.
4566     /// @return constants The list of constants.
4567     function getConstants()
4568         external
4569         virtual
4570         pure
4571         returns(ExchangeData.Constants memory);
4572 
4573     // -- Mode --
4574     /// @dev Returns hether the exchange is in withdrawal mode.
4575     /// @return Returns true if the exchange is in withdrawal mode, else false.
4576     function isInWithdrawalMode()
4577         external
4578         virtual
4579         view
4580         returns (bool);
4581 
4582     /// @dev Returns whether the exchange is shutdown.
4583     /// @return Returns true if the exchange is shutdown, else false.
4584     function isShutdown()
4585         external
4586         virtual
4587         view
4588         returns (bool);
4589 
4590     // -- Tokens --
4591     /// @dev Registers an ERC20 token for a token id. Note that different exchanges may have
4592     ///      different ids for the same ERC20 token.
4593     ///
4594     ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),
4595     ///      and 3 is reserved for Loopring Token (LRC).
4596     ///
4597     ///      This function is only callable by the exchange owner.
4598     ///
4599     /// @param  tokenAddress The token's address
4600     /// @return tokenID The token's ID in this exchanges.
4601     function registerToken(
4602         address tokenAddress
4603         )
4604         external
4605         virtual
4606         returns (uint16 tokenID);
4607 
4608     /// @dev Returns the id of a registered token.
4609     /// @param  tokenAddress The token's address
4610     /// @return tokenID The token's ID in this exchanges.
4611     function getTokenID(
4612         address tokenAddress
4613         )
4614         external
4615         virtual
4616         view
4617         returns (uint16 tokenID);
4618 
4619     /// @dev Returns the address of a registered token.
4620     /// @param  tokenID The token's ID in this exchanges.
4621     /// @return tokenAddress The token's address
4622     function getTokenAddress(
4623         uint16 tokenID
4624         )
4625         external
4626         virtual
4627         view
4628         returns (address tokenAddress);
4629 
4630     // -- Stakes --
4631     /// @dev Gets the amount of LRC the owner has staked onchain for this exchange.
4632     ///      The stake will be burned if the exchange does not fulfill its duty by
4633     ///      processing user requests in time. Please note that order matching may potentially
4634     ///      performed by another party and is not part of the exchange's duty.
4635     ///
4636     /// @return The amount of LRC staked
4637     function getExchangeStake()
4638         external
4639         virtual
4640         view
4641         returns (uint);
4642 
4643     /// @dev Withdraws the amount staked for this exchange.
4644     ///      This can only be done if the exchange has been correctly shutdown:
4645     ///      - The exchange owner has shutdown the exchange
4646     ///      - All deposit requests are processed
4647     ///      - All funds are returned to the users (merkle root is reset to initial state)
4648     ///
4649     ///      Can only be called by the exchange owner.
4650     ///
4651     /// @return amountLRC The amount of LRC withdrawn
4652     function withdrawExchangeStake(
4653         address recipient
4654         )
4655         external
4656         virtual
4657         returns (uint amountLRC);
4658 
4659     /// @dev Can by called by anyone to burn the stake of the exchange when certain
4660     ///      conditions are fulfilled.
4661     ///
4662     ///      Currently this will only burn the stake of the exchange if
4663     ///      the exchange is in withdrawal mode.
4664     function burnExchangeStake()
4665         external
4666         virtual;
4667 
4668     // -- Blocks --
4669 
4670     /// @dev Gets the current Merkle root of this exchange's virtual blockchain.
4671     /// @return The current Merkle root.
4672     function getMerkleRoot()
4673         external
4674         virtual
4675         view
4676         returns (bytes32);
4677 
4678     /// @dev Gets the height of this exchange's virtual blockchain. The block height for a
4679     ///      new exchange is 1.
4680     /// @return The virtual blockchain height which is the index of the last block.
4681     function getBlockHeight()
4682         external
4683         virtual
4684         view
4685         returns (uint);
4686 
4687     /// @dev Gets some minimal info of a previously submitted block that's kept onchain.
4688     ///      A DEX can use this function to implement a payment receipt verification
4689     ///      contract with a challange-response scheme.
4690     /// @param blockIdx The block index.
4691     function getBlockInfo(uint blockIdx)
4692         external
4693         virtual
4694         view
4695         returns (ExchangeData.BlockInfo memory);
4696 
4697     /// @dev Sumbits new blocks to the rollup blockchain.
4698     ///
4699     ///      This function can only be called by the exchange operator.
4700     ///
4701     /// @param blocks The blocks being submitted
4702     ///      - blockType: The type of the new block
4703     ///      - blockSize: The number of onchain or offchain requests/settlements
4704     ///        that have been processed in this block
4705     ///      - blockVersion: The circuit version to use for verifying the block
4706     ///      - storeBlockInfoOnchain: If the block info for this block needs to be stored on-chain
4707     ///      - data: The data for this block
4708     ///      - offchainData: Arbitrary data, mainly for off-chain data-availability, i.e.,
4709     ///        the multihash of the IPFS file that contains the block data.
4710     function submitBlocks(ExchangeData.Block[] calldata blocks)
4711         external
4712         virtual;
4713 
4714     /// @dev Gets the number of available forced request slots.
4715     /// @return The number of available slots.
4716     function getNumAvailableForcedSlots()
4717         external
4718         virtual
4719         view
4720         returns (uint);
4721 
4722     // -- Deposits --
4723 
4724     /// @dev Deposits Ether or ERC20 tokens to the specified account.
4725     ///
4726     ///      This function is only callable by an agent of 'from'.
4727     ///
4728     ///      A fee to the owner is paid in ETH to process the deposit.
4729     ///      The operator is not forced to do the deposit and the user can send
4730     ///      any fee amount.
4731     ///
4732     /// @param from The address that deposits the funds to the exchange
4733     /// @param to The account owner's address receiving the funds
4734     /// @param tokenAddress The address of the token, use `0x0` for Ether.
4735     /// @param amount The amount of tokens to deposit
4736     /// @param auxiliaryData Optional extra data used by the deposit contract
4737     function deposit(
4738         address from,
4739         address to,
4740         address tokenAddress,
4741         uint96  amount,
4742         bytes   calldata auxiliaryData
4743         )
4744         external
4745         virtual
4746         payable;
4747 
4748     /// @dev Gets the amount of tokens that may be added to the owner's account.
4749     /// @param owner The destination address for the amount deposited.
4750     /// @param tokenAddress The address of the token, use `0x0` for Ether.
4751     /// @return The amount of tokens pending.
4752     function getPendingDepositAmount(
4753         address owner,
4754         address tokenAddress
4755         )
4756         external
4757         virtual
4758         view
4759         returns (uint96);
4760 
4761     // -- Withdrawals --
4762     /// @dev Submits an onchain request to force withdraw Ether or ERC20 tokens.
4763     ///      This request always withdraws the full balance.
4764     ///
4765     ///      This function is only callable by an agent of the account.
4766     ///
4767     ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.
4768     ///      If the user sends too much ETH the surplus is sent back immediately.
4769     ///
4770     ///      Note that after such an operation, it will take the owner some
4771     ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request
4772     ///      and create the deposit to the offchain account.
4773     ///
4774     /// @param owner The expected owner of the account
4775     /// @param tokenAddress The address of the token, use `0x0` for Ether.
4776     /// @param accountID The address the account in the Merkle tree.
4777     function forceWithdraw(
4778         address owner,
4779         address tokenAddress,
4780         uint32  accountID
4781         )
4782         external
4783         virtual
4784         payable;
4785 
4786     /// @dev Checks if a forced withdrawal is pending for an account balance.
4787     /// @param  accountID The accountID of the account to check.
4788     /// @param  token The token address
4789     /// @return True if a request is pending, false otherwise
4790     function isForcedWithdrawalPending(
4791         uint32  accountID,
4792         address token
4793         )
4794         external
4795         virtual
4796         view
4797         returns (bool);
4798 
4799     /// @dev Submits an onchain request to withdraw Ether or ERC20 tokens from the
4800     ///      protocol fees account. The complete balance is always withdrawn.
4801     ///
4802     ///      Anyone can request a withdrawal of the protocol fees.
4803     ///
4804     ///      Note that after such an operation, it will take the owner some
4805     ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request
4806     ///      and create the deposit to the offchain account.
4807     ///
4808     /// @param tokenAddress The address of the token, use `0x0` for Ether.
4809     function withdrawProtocolFees(
4810         address tokenAddress
4811         )
4812         external
4813         virtual
4814         payable;
4815 
4816     /// @dev Gets the time the protocol fee for a token was last withdrawn.
4817     /// @param tokenAddress The address of the token, use `0x0` for Ether.
4818     /// @return The time the protocol fee was last withdrawn.
4819     function getProtocolFeeLastWithdrawnTime(
4820         address tokenAddress
4821         )
4822         external
4823         virtual
4824         view
4825         returns (uint);
4826 
4827     /// @dev Allows anyone to withdraw funds for a specified user using the balances stored
4828     ///      in the Merkle tree. The funds will be sent to the owner of the acount.
4829     ///
4830     ///      Can only be used in withdrawal mode (i.e. when the owner has stopped
4831     ///      committing blocks and is not able to commit any more blocks).
4832     ///
4833     ///      This will NOT modify the onchain merkle root! The merkle root stored
4834     ///      onchain will remain the same after the withdrawal. We store if the user
4835     ///      has withdrawn the balance in State.withdrawnInWithdrawMode.
4836     ///
4837     /// @param  merkleProof The Merkle inclusion proof
4838     function withdrawFromMerkleTree(
4839         ExchangeData.MerkleProof calldata merkleProof
4840         )
4841         external
4842         virtual;
4843 
4844     /// @dev Checks if the balance for the account was withdrawn with `withdrawFromMerkleTree`.
4845     /// @param  accountID The accountID of the balance to check.
4846     /// @param  token The token address
4847     /// @return True if it was already withdrawn, false otherwise
4848     function isWithdrawnInWithdrawalMode(
4849         uint32  accountID,
4850         address token
4851         )
4852         external
4853         virtual
4854         view
4855         returns (bool);
4856 
4857     /// @dev Allows withdrawing funds deposited to the contract in a deposit request when
4858     ///      it was never processed by the owner within the maximum time allowed.
4859     ///
4860     ///      Can be called by anyone. The deposited tokens will be sent back to
4861     ///      the owner of the account they were deposited in.
4862     ///
4863     /// @param  owner The address of the account the withdrawal was done for.
4864     /// @param  token The token address
4865     function withdrawFromDepositRequest(
4866         address owner,
4867         address token
4868         )
4869         external
4870         virtual;
4871 
4872     /// @dev Allows withdrawing funds after a withdrawal request (either onchain
4873     ///      or offchain) was submitted in a block by the operator.
4874     ///
4875     ///      Can be called by anyone. The withdrawn tokens will be sent to
4876     ///      the owner of the account they were withdrawn out.
4877     ///
4878     ///      Normally it is should not be needed for users to call this manually.
4879     ///      Funds from withdrawal requests will be sent to the account owner
4880     ///      immediately by the owner when the block is submitted.
4881     ///      The user will however need to call this manually if the transfer failed.
4882     ///
4883     ///      Tokens and owners must have the same size.
4884     ///
4885     /// @param  owners The addresses of the account the withdrawal was done for.
4886     /// @param  tokens The token addresses
4887     function withdrawFromApprovedWithdrawals(
4888         address[] calldata owners,
4889         address[] calldata tokens
4890         )
4891         external
4892         virtual;
4893 
4894     /// @dev Gets the amount that can be withdrawn immediately with `withdrawFromApprovedWithdrawals`.
4895     /// @param  owner The address of the account the withdrawal was done for.
4896     /// @param  token The token address
4897     /// @return The amount withdrawable
4898     function getAmountWithdrawable(
4899         address owner,
4900         address token
4901         )
4902         external
4903         virtual
4904         view
4905         returns (uint);
4906 
4907     /// @dev Notifies the exchange that the owner did not process a forced request.
4908     ///      If this is indeed the case, the exchange will enter withdrawal mode.
4909     ///
4910     ///      Can be called by anyone.
4911     ///
4912     /// @param  accountID The accountID the forced request was made for
4913     /// @param  token The token address of the the forced request
4914     function notifyForcedRequestTooOld(
4915         uint32  accountID,
4916         address token
4917         )
4918         external
4919         virtual;
4920 
4921     /// @dev Allows a withdrawal to be done to an adddresss that is different
4922     ///      than initialy specified in the withdrawal request. This can be used to
4923     ///      implement functionality like fast withdrawals.
4924     ///
4925     ///      This function can only be called by an agent.
4926     ///
4927     /// @param from The address of the account that does the withdrawal.
4928     /// @param to The address to which 'amount' tokens were going to be withdrawn.
4929     /// @param token The address of the token that is withdrawn ('0x0' for ETH).
4930     /// @param amount The amount of tokens that are going to be withdrawn.
4931     /// @param storageID The storageID of the withdrawal request.
4932     /// @param newRecipient The new recipient address of the withdrawal.
4933     function setWithdrawalRecipient(
4934         address from,
4935         address to,
4936         address token,
4937         uint96  amount,
4938         uint32  storageID,
4939         address newRecipient
4940         )
4941         external
4942         virtual;
4943 
4944     /// @dev Gets the withdrawal recipient.
4945     ///
4946     /// @param from The address of the account that does the withdrawal.
4947     /// @param to The address to which 'amount' tokens were going to be withdrawn.
4948     /// @param token The address of the token that is withdrawn ('0x0' for ETH).
4949     /// @param amount The amount of tokens that are going to be withdrawn.
4950     /// @param storageID The storageID of the withdrawal request.
4951     function getWithdrawalRecipient(
4952         address from,
4953         address to,
4954         address token,
4955         uint96  amount,
4956         uint32  storageID
4957         )
4958         external
4959         virtual
4960         view
4961         returns (address);
4962 
4963     /// @dev Allows an agent to transfer ERC-20 tokens for a user using the allowance
4964     ///      the user has set for the exchange. This way the user only needs to approve a single exchange contract
4965     ///      for all exchange/agent features, which allows for a more seamless user experience.
4966     ///
4967     ///      This function can only be called by an agent.
4968     ///
4969     /// @param from The address of the account that sends the tokens.
4970     /// @param to The address to which 'amount' tokens are transferred.
4971     /// @param token The address of the token to transfer (ETH is and cannot be suppported).
4972     /// @param amount The amount of tokens transferred.
4973     function onchainTransferFrom(
4974         address from,
4975         address to,
4976         address token,
4977         uint    amount
4978         )
4979         external
4980         virtual;
4981 
4982     /// @dev Allows an agent to approve a rollup tx.
4983     ///
4984     ///      This function can only be called by an agent.
4985     ///
4986     /// @param owner The owner of the account
4987     /// @param txHash The hash of the transaction
4988     function approveTransaction(
4989         address owner,
4990         bytes32 txHash
4991         )
4992         external
4993         virtual;
4994 
4995     /// @dev Allows an agent to approve multiple rollup txs.
4996     ///
4997     ///      This function can only be called by an agent.
4998     ///
4999     /// @param owners The account owners
5000     /// @param txHashes The hashes of the transactions
5001     function approveTransactions(
5002         address[] calldata owners,
5003         bytes32[] calldata txHashes
5004         )
5005         external
5006         virtual;
5007 
5008     /// @dev Checks if a rollup tx is approved using the tx's hash.
5009     ///
5010     /// @param owner The owner of the account that needs to authorize the tx
5011     /// @param txHash The hash of the transaction
5012     /// @return True if the tx is approved, else false
5013     function isTransactionApproved(
5014         address owner,
5015         bytes32 txHash
5016         )
5017         external
5018         virtual
5019         view
5020         returns (bool);
5021 
5022     // -- Admins --
5023     /// @dev Sets the max time deposits have to wait before becoming withdrawable.
5024     /// @param newValue The new value.
5025     /// @return  The old value.
5026     function setMaxAgeDepositUntilWithdrawable(
5027         uint32 newValue
5028         )
5029         external
5030         virtual
5031         returns (uint32);
5032 
5033     /// @dev Returns the max time deposits have to wait before becoming withdrawable.
5034     /// @return The value.
5035     function getMaxAgeDepositUntilWithdrawable()
5036         external
5037         virtual
5038         view
5039         returns (uint32);
5040 
5041     /// @dev Shuts down the exchange.
5042     ///      Once the exchange is shutdown all onchain requests are permanently disabled.
5043     ///      When all requirements are fulfilled the exchange owner can withdraw
5044     ///      the exchange stake with withdrawStake.
5045     ///
5046     ///      Note that the exchange can still enter the withdrawal mode after this function
5047     ///      has been invoked successfully. To prevent entering the withdrawal mode before the
5048     ///      the echange stake can be withdrawn, all withdrawal requests still need to be handled
5049     ///      for at least MIN_TIME_IN_SHUTDOWN seconds.
5050     ///
5051     ///      Can only be called by the exchange owner.
5052     ///
5053     /// @return success True if the exchange is shutdown, else False
5054     function shutdown()
5055         external
5056         virtual
5057         returns (bool success);
5058 
5059     /// @dev Gets the protocol fees for this exchange.
5060     /// @return syncedAt The timestamp the protocol fees were last updated
5061     /// @return takerFeeBips The protocol taker fee
5062     /// @return makerFeeBips The protocol maker fee
5063     /// @return previousTakerFeeBips The previous protocol taker fee
5064     /// @return previousMakerFeeBips The previous protocol maker fee
5065     function getProtocolFeeValues()
5066         external
5067         virtual
5068         view
5069         returns (
5070             uint32 syncedAt,
5071             uint8 takerFeeBips,
5072             uint8 makerFeeBips,
5073             uint8 previousTakerFeeBips,
5074             uint8 previousMakerFeeBips
5075         );
5076 
5077     /// @dev Gets the domain separator used in this exchange.
5078     function getDomainSeparator()
5079         external
5080         virtual
5081         view
5082         returns (bytes32);
5083 }
5084 
5085 
5086 
5087 
5088 // Copyright 2017 Loopring Technology Limited.
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 /// @title Drainable
5097 /// @author Brecht Devos - <brecht@loopring.org>
5098 /// @dev Standard functionality to allow draining funds from a contract.
5099 abstract contract Drainable
5100 {
5101     using AddressUtil       for address;
5102     using ERC20SafeTransfer for address;
5103 
5104     event Drained(
5105         address to,
5106         address token,
5107         uint    amount
5108     );
5109 
5110     function drain(
5111         address to,
5112         address token
5113         )
5114         external
5115         returns (uint amount)
5116     {
5117         require(canDrain(msg.sender, token), "UNAUTHORIZED");
5118 
5119         if (token == address(0)) {
5120             amount = address(this).balance;
5121             to.sendETHAndVerify(amount, gasleft());   // ETH
5122         } else {
5123             amount = ERC20(token).balanceOf(address(this));
5124             token.safeTransferAndVerify(to, amount);  // ERC20 token
5125         }
5126 
5127         emit Drained(to, token, amount);
5128     }
5129 
5130     // Needs to return if the address is authorized to call drain.
5131     function canDrain(address drainer, address token)
5132         public
5133         virtual
5134         view
5135         returns (bool);
5136 }
5137 
5138 
5139 
5140 
5141 
5142 // Copyright 2017 Loopring Technology Limited.
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 /// @title  SelectorBasedAccessManager
5151 /// @author Daniel Wang - <daniel@loopring.org>
5152 contract SelectorBasedAccessManager is Claimable
5153 {
5154     using BytesUtil for bytes;
5155 
5156     event PermissionUpdate(
5157         address indexed user,
5158         bytes4  indexed selector,
5159         bool            allowed
5160     );
5161 
5162     address public target;
5163     mapping(address => mapping(bytes4 => bool)) public permissions;
5164 
5165     modifier withAccess(bytes4 selector)
5166     {
5167         require(hasAccessTo(msg.sender, selector), "PERMISSION_DENIED");
5168         _;
5169     }
5170 
5171     constructor(address _target)
5172     {
5173         require(_target != address(0), "ZERO_ADDRESS");
5174         target = _target;
5175     }
5176 
5177     function grantAccess(
5178         address user,
5179         bytes4  selector,
5180         bool    granted
5181         )
5182         external
5183         onlyOwner
5184     {
5185         require(permissions[user][selector] != granted, "INVALID_VALUE");
5186         permissions[user][selector] = granted;
5187         emit PermissionUpdate(user, selector, granted);
5188     }
5189 
5190     receive() payable external {}
5191 
5192     fallback()
5193         payable
5194         external
5195     {
5196         transact(msg.data);
5197     }
5198 
5199     function transact(bytes memory data)
5200         payable
5201         public
5202         withAccess(data.toBytes4(0))
5203     {
5204         (bool success, bytes memory returnData) = target
5205             .call{value: msg.value}(data);
5206 
5207         if (!success) {
5208             assembly { revert(add(returnData, 32), mload(returnData)) }
5209         }
5210     }
5211 
5212     function hasAccessTo(address user, bytes4 selector)
5213         public
5214         view
5215         returns (bool)
5216     {
5217         return user == owner || permissions[user][selector];
5218     }
5219 }
5220 
5221 
5222 
5223 
5224 contract LoopringIOExchangeOwner is SelectorBasedAccessManager, ERC1271, Drainable
5225 {
5226     using AddressUtil       for address;
5227     using AddressUtil       for address payable;
5228     using BytesUtil         for bytes;
5229     using MathUint          for uint;
5230     using SignatureUtil     for bytes32;
5231     using TransactionReader for ExchangeData.Block;
5232 
5233     bytes4 private constant SUBMITBLOCKS_SELECTOR  = IExchangeV3.submitBlocks.selector;
5234     bool   public  open;
5235 
5236     event SubmitBlocksAccessOpened(bool open);
5237 
5238     struct TxCallback
5239     {
5240         uint16 txIdx;
5241         uint16 numTxs;
5242         uint16 receiverIdx;
5243         bytes  data;
5244     }
5245 
5246     struct BlockCallback
5247     {
5248         uint16        blockIdx;
5249         TxCallback[]  txCallbacks;
5250     }
5251 
5252     struct CallbackConfig
5253     {
5254         BlockCallback[] blockCallbacks;
5255         address[]       receivers;
5256     }
5257 
5258     constructor(address _exchange)
5259         SelectorBasedAccessManager(_exchange)
5260     {
5261     }
5262 
5263     function openAccessToSubmitBlocks(bool _open)
5264         external
5265         onlyOwner
5266     {
5267         open = _open;
5268         emit SubmitBlocksAccessOpened(_open);
5269     }
5270 
5271     function isValidSignature(
5272         bytes32        signHash,
5273         bytes   memory signature
5274         )
5275         public
5276         view
5277         override
5278         returns (bytes4)
5279     {
5280         // Role system used a bit differently here.
5281         return hasAccessTo(
5282             signHash.recoverECDSASigner(signature),
5283             this.isValidSignature.selector
5284         ) ? ERC1271_MAGICVALUE : bytes4(0);
5285     }
5286 
5287     function canDrain(address drainer, address /* token */)
5288         public
5289         override
5290         view
5291         returns (bool)
5292     {
5293         return hasAccessTo(drainer, this.drain.selector);
5294     }
5295 
5296     function submitBlocksWithCallbacks(
5297         bool                     isDataCompressed,
5298         bytes           calldata data,
5299         CallbackConfig  calldata config
5300         )
5301         external
5302     {
5303         bool performCallback;
5304         if (config.blockCallbacks.length > 0) {
5305             require(config.receivers.length > 0, "MISSING_RECEIVERS");
5306             performCallback = true;
5307         }
5308 
5309         require(
5310             hasAccessTo(msg.sender, SUBMITBLOCKS_SELECTOR) || open,
5311             "PERMISSION_DENIED"
5312         );
5313         bytes memory decompressed = isDataCompressed ?
5314             ZeroDecompressor.decompress(data, 1):
5315             data;
5316 
5317         require(
5318             decompressed.toBytes4(0) == SUBMITBLOCKS_SELECTOR,
5319             "INVALID_DATA"
5320         );
5321 
5322         // Process the callback logic.
5323         if (performCallback) {
5324             _beforeBlockSubmission(_decodeBlocks(decompressed), config);
5325         }
5326 
5327         target.fastCallAndVerify(gasleft(), 0, decompressed);
5328     }
5329 
5330     function _beforeBlockSubmission(
5331         ExchangeData.Block[] memory   blocks,
5332         CallbackConfig       calldata config
5333         )
5334         private
5335     {
5336         int lastBlockIdx = -1;
5337         for (uint i = 0; i < config.blockCallbacks.length; i++) {
5338             BlockCallback calldata blockCallback = config.blockCallbacks[i];
5339 
5340             uint16 blockIdx = blockCallback.blockIdx;
5341             require(blockIdx > lastBlockIdx, "BLOCK_INDEX_OUT_OF_ORDER");
5342             lastBlockIdx = int(blockIdx);
5343 
5344             require(blockIdx < blocks.length, "INVALID_BLOCKIDX");
5345             ExchangeData.Block memory _block = blocks[blockIdx];
5346 
5347             _processTxCallbacks(_block, blockCallback.txCallbacks, config.receivers);
5348         }
5349     }
5350 
5351     function _processTxCallbacks(
5352         ExchangeData.Block memory _block,
5353         TxCallback[]       calldata txCallbacks,
5354         address[]          calldata receivers
5355         )
5356         private
5357     {
5358         uint cursor = 0;
5359 
5360         for (uint i = 0; i < txCallbacks.length; i++) {
5361             TxCallback calldata txCallback = txCallbacks[i];
5362 
5363             uint txIdx = uint(txCallback.txIdx);
5364             require(txIdx >= cursor, "TX_INDEX_OUT_OF_ORDER");
5365 
5366             uint16 receiverIdx = txCallback.receiverIdx;
5367             require(receiverIdx < receivers.length, "INVALID_RECEIVER_INDEX");
5368 
5369             ExchangeData.Block memory minimalBlock = _block.createMinimalBlock(txIdx, txCallback.numTxs);
5370             IBlockReceiver(receivers[receiverIdx]).beforeBlockSubmission(
5371                 minimalBlock,
5372                 txCallback.data,
5373                 0,
5374                 txCallback.numTxs
5375             );
5376 
5377             cursor = txIdx + txCallback.numTxs;
5378         }
5379     }
5380 
5381     function _decodeBlocks(bytes memory data)
5382         private
5383         pure
5384         returns (ExchangeData.Block[] memory)
5385     {
5386         // This copies the data (expensive) instead of just pointing to the correct address
5387         //bytes memory blockData;
5388         //assembly {
5389         //    blockData := add(data, 4)
5390         //}
5391         //ExchangeData.Block[] memory blocks = abi.decode(blockData, (ExchangeData.Block[]));
5392 
5393         // Points the block data to the data in the abi encoded data.
5394         // Only sets the data necessary in the callbacks!
5395         // 36 := 4 (function selector) + 32 (offset to blocks)
5396         uint numBlocks = data.toUint(36);
5397         ExchangeData.Block[] memory blocks = new ExchangeData.Block[](numBlocks);
5398         for (uint i = 0; i < numBlocks; i++) {
5399             ExchangeData.Block memory _block = blocks[i];
5400 
5401             // 68 := 36 (see above) + 32 (blocks length)
5402             uint blockOffset = 68 + data.toUint(68 + i*32);
5403 
5404             uint offset = blockOffset;
5405             //_block.blockType = uint8(data.toUint(offset));
5406             offset += 32;
5407             _block.blockSize = uint16(data.toUint(offset));
5408             offset += 32;
5409             //_block.blockVersion = uint8(data.toUint(offset));
5410             offset += 32;
5411             uint blockDataOffset = data.toUint(offset);
5412             offset += 32;
5413 
5414             bytes memory blockData;
5415             assembly {
5416                 blockData := add(data, add(32, add(blockOffset, blockDataOffset)))
5417             }
5418             _block.data = blockData;
5419         }
5420         return blocks;
5421     }
5422 }