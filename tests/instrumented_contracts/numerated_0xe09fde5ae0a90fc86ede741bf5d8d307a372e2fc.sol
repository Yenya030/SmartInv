1 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
2 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
3 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
4 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
5 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
6 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣶⡶⠾⠿⠿⠿⢶⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣶⡶⠿⠿⠿⠷⢶⣶⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
7 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⠿⠋⠁⠂⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣶⣄⠀⠀⠀⠀⠀⠀⣠⣾⠿⠋⠁⡂⠀⠀⠀⠀⠀⠀⠐⠙⠙⠿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
8 // ⠀⠀⠀⠀⠀⠀⠀⣠⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠈⢙⣷⣄⠀⠀⣠⡾⠋⠈⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀
9 // ⠀⠀⠀⠀⠀⠀⣰⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⣰⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣆⠀⠀⠀⠀⠀⠀
10 // ⠀⠀⠀⠀⠀⢰⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡆⠀⠀⠀⠀⠀
11 // ⠀⠀⠀⠀⠀⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀
12 // ⠀⠀⠀⠀⢠⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⠶⠿⠛⠛⠛⠛⠛⠛⠿⠶⢶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
13 // ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⣢⣵⠟⠋⢁⣠⣤⣤⣤⣤⣀⠀⠀⠀⢀⣠⣤⣼⣿⣿⣦⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀
14 // ⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀⠀⢀⣾⠏⠀⢠⡞⠋⣿⣿⣿⣿⣿⡏⠻⣆⣰⣟⣽⣿⣿⣿⣿⣿⠈⣹⡷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⠀⠀⠀⠀⠀
15 // ⠀⠀⠀⠀⠀⢻⡇⠀⠀⠀⢠⣾⠃⠀⠀⠈⠛⠶⢿⣿⣿⣿⣿⡷⠾⣃⣺⡿⣼⣿⣿⣿⣿⢿⣿⠟⠁⠀⠀⠀⢀⣀⣀⣀⡀⠄⠀⠀⠀⠀⠀⠀⠀⢸⡟⠀⠀⠀⠀⠀
16 // ⠀⠀⠀⠀⠀⠘⣿⡀⠀⢈⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠈⣿⠀⠀⠀⠀⣐⣿⡻⠟⠟⣿⡀⠀⠀⠀⠀⠀⠀⢠⣿⠃⠀⠀⠀⠀⠀
17 // ⠀⠀⠀⠀⠀⠀⢹⣧⠂⢰⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠻⣯⠁⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⣾⠇⠀⠀⠀⠀⠀⠀
18 // ⠀⠀⠀⠀⠀⠀⠀⢻⣧⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⣿⠀⠀⠀⣿⡇⠀⠀⠀⠀⢀⣾⠏⠀⠀⠀⠀⠀⠀⠀
19 // ⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⢀⣿⠀⠀⠀⣿⡇⠀⠀⠀⢀⣼⠏⠀⠀⠀⠀⠀⠀⠀⠀
20 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⢸⣿⠀⠀⠀⣿⡇⠀⠀⣠⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
21 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡆⠀⠀⠀⢸⣿⠀⠀⠀⣿⠃⢀⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
22 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡇⠀⠀⠀⢸⡇⠀⠀⠀⣿⣶⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
23 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢸⡇⠀⢀⣴⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
24 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣇⠀⠀⠀⣿⣇⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
25 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠀⣀⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
26 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⢶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
27 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢶⣤⣀⠀⠀⣀⣤⡶⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
28 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
29 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
30 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
31 
32 /**
33  *Submitted for verification at Etherscan.io on 2022-05-18
34 */
35 
36 /**
37  *Submitted for verification at Etherscan.io on 2022-05-17
38 */
39 
40 // SPDX-License-Identifier: MIT
41 
42 pragma solidity ^0.8.0;
43 
44 /**
45  * @dev Interface of the ERC165 standard, as defined in the
46  * https://eips.ethereum.org/EIPS/eip-165[EIP].
47  *
48  * Implementers can declare support of contract interfaces, which can then be
49  * queried by others ({ERC165Checker}).
50  *
51  * For an implementation, see {ERC165}.
52  */
53 interface IERC165 {
54     /**
55      * @dev Returns true if this contract implements the interface defined by
56      * `interfaceId`. See the corresponding
57      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
58      * to learn more about how these ids are created.
59      *
60      * This function call must use less than 30 000 gas.
61      */
62     function supportsInterface(bytes4 interfaceId) external view returns (bool);
63 }
64 
65 
66 pragma solidity ^0.8.0;
67 
68 
69 /**
70  * @dev Implementation of the {IERC165} interface.
71  *
72  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
73  * for the additional interface id that will be supported. For example:
74  *
75  * ```solidity
76  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
77  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
78  * }
79  * ```
80  *
81  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
82  */
83 abstract contract ERC165 is IERC165 {
84     /**
85      * @dev See {IERC165-supportsInterface}.
86      */
87     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
88         return interfaceId == type(IERC165).interfaceId;
89     }
90 }
91 
92 
93 pragma solidity ^0.8.0;
94 
95 /**
96  * @dev Collection of functions related to the address type
97  */
98 library Address {
99     /**
100      * @dev Returns true if `account` is a contract.
101      *
102      * [IMPORTANT]
103      * ====
104      * It is unsafe to assume that an address for which this function returns
105      * false is an externally-owned account (EOA) and not a contract.
106      *
107      * Among others, `isContract` will return false for the following
108      * types of addresses:
109      *
110      *  - an externally-owned account
111      *  - a contract in construction
112      *  - an address where a contract will be created
113      *  - an address where a contract lived, but was destroyed
114      * ====
115      */
116     function isContract(address account) internal view returns (bool) {
117         // This method relies on extcodesize, which returns 0 for contracts in
118         // construction, since the code is only stored at the end of the
119         // constructor execution.
120 
121         uint256 size;
122         assembly {
123             size := extcodesize(account)
124         }
125         return size > 0;
126     }
127 
128     /**
129      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
130      * `recipient`, forwarding all available gas and reverting on errors.
131      *
132      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
133      * of certain opcodes, possibly making contracts go over the 2300 gas limit
134      * imposed by `transfer`, making them unable to receive funds via
135      * `transfer`. {sendValue} removes this limitation.
136      *
137      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
138      *
139      * IMPORTANT: because control is transferred to `recipient`, care must be
140      * taken to not create reentrancy vulnerabilities. Consider using
141      * {ReentrancyGuard} or the
142      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
143      */
144     function sendValue(address payable recipient, uint256 amount) internal {
145         require(address(this).balance >= amount, "Address: insufficient balance");
146 
147         (bool success, ) = recipient.call{value: amount}("");
148         require(success, "Address: unable to send value, recipient may have reverted");
149     }
150 
151     /**
152      * @dev Performs a Solidity function call using a low level `call`. A
153      * plain `call` is an unsafe replacement for a function call: use this
154      * function instead.
155      *
156      * If `target` reverts with a revert reason, it is bubbled up by this
157      * function (like regular Solidity function calls).
158      *
159      * Returns the raw returned data. To convert to the expected return value,
160      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
161      *
162      * Requirements:
163      *
164      * - `target` must be a contract.
165      * - calling `target` with `data` must not revert.
166      *
167      * _Available since v3.1._
168      */
169     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
170         return functionCall(target, data, "Address: low-level call failed");
171     }
172 
173     /**
174      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
175      * `errorMessage` as a fallback revert reason when `target` reverts.
176      *
177      * _Available since v3.1._
178      */
179     function functionCall(
180         address target,
181         bytes memory data,
182         string memory errorMessage
183     ) internal returns (bytes memory) {
184         return functionCallWithValue(target, data, 0, errorMessage);
185     }
186 
187     /**
188      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
189      * but also transferring `value` wei to `target`.
190      *
191      * Requirements:
192      *
193      * - the calling contract must have an ETH balance of at least `value`.
194      * - the called Solidity function must be `payable`.
195      *
196      * _Available since v3.1._
197      */
198     function functionCallWithValue(
199         address target,
200         bytes memory data,
201         uint256 value
202     ) internal returns (bytes memory) {
203         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
204     }
205 
206     /**
207      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
208      * with `errorMessage` as a fallback revert reason when `target` reverts.
209      *
210      * _Available since v3.1._
211      */
212     function functionCallWithValue(
213         address target,
214         bytes memory data,
215         uint256 value,
216         string memory errorMessage
217     ) internal returns (bytes memory) {
218         require(address(this).balance >= value, "Address: insufficient balance for call");
219         require(isContract(target), "Address: call to non-contract");
220 
221         (bool success, bytes memory returndata) = target.call{value: value}(data);
222         return _verifyCallResult(success, returndata, errorMessage);
223     }
224 
225     /**
226      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
227      * but performing a static call.
228      *
229      * _Available since v3.3._
230      */
231     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
232         return functionStaticCall(target, data, "Address: low-level static call failed");
233     }
234 
235     /**
236      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
237      * but performing a static call.
238      *
239      * _Available since v3.3._
240      */
241     function functionStaticCall(
242         address target,
243         bytes memory data,
244         string memory errorMessage
245     ) internal view returns (bytes memory) {
246         require(isContract(target), "Address: static call to non-contract");
247 
248         (bool success, bytes memory returndata) = target.staticcall(data);
249         return _verifyCallResult(success, returndata, errorMessage);
250     }
251 
252     /**
253      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
254      * but performing a delegate call.
255      *
256      * _Available since v3.4._
257      */
258     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
259         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
260     }
261 
262     /**
263      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
264      * but performing a delegate call.
265      *
266      * _Available since v3.4._
267      */
268     function functionDelegateCall(
269         address target,
270         bytes memory data,
271         string memory errorMessage
272     ) internal returns (bytes memory) {
273         require(isContract(target), "Address: delegate call to non-contract");
274 
275         (bool success, bytes memory returndata) = target.delegatecall(data);
276         return _verifyCallResult(success, returndata, errorMessage);
277     }
278 
279     function _verifyCallResult(
280         bool success,
281         bytes memory returndata,
282         string memory errorMessage
283     ) private pure returns (bytes memory) {
284         if (success) {
285             return returndata;
286         } else {
287             // Look for revert reason and bubble it up if present
288             if (returndata.length > 0) {
289                 // The easiest way to bubble the revert reason is using memory via assembly
290 
291                 assembly {
292                     let returndata_size := mload(returndata)
293                     revert(add(32, returndata), returndata_size)
294                 }
295             } else {
296                 revert(errorMessage);
297             }
298         }
299     }
300 }
301 
302 
303 
304 
305 
306 
307 
308 
309 pragma solidity ^0.8.0;
310 
311 /**
312  * @title ERC721 token receiver interface
313  * @dev Interface for any contract that wants to support safeTransfers
314  * from ERC721 asset contracts.
315  */
316 interface IERC721Receiver {
317     /**
318      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
319      * by `operator` from `from`, this function is called.
320      *
321      * It must return its Solidity selector to confirm the token transfer.
322      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
323      *
324      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
325      */
326     function onERC721Received(
327         address operator,
328         address from,
329         uint256 tokenId,
330         bytes calldata data
331     ) external returns (bytes4);
332 }
333 
334 
335 
336 
337 pragma solidity ^0.8.0;
338 
339 
340 /**
341  * @dev Required interface of an ERC721 compliant contract.
342  */
343 interface IERC721 is IERC165 {
344     /**
345      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
346      */
347     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
348 
349     /**
350      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
351      */
352     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
353 
354     /**
355      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
356      */
357     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
358 
359     /**
360      * @dev Returns the number of tokens in ``owner``'s account.
361      */
362     function balanceOf(address owner) external view returns (uint256 balance);
363 
364     /**
365      * @dev Returns the owner of the `tokenId` token.
366      *
367      * Requirements:
368      *
369      * - `tokenId` must exist.
370      */
371     function ownerOf(uint256 tokenId) external view returns (address owner);
372 
373     /**
374      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
375      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
376      *
377      * Requirements:
378      *
379      * - `from` cannot be the zero address.
380      * - `to` cannot be the zero address.
381      * - `tokenId` token must exist and be owned by `from`.
382      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
383      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
384      *
385      * Emits a {Transfer} event.
386      */
387     function safeTransferFrom(
388         address from,
389         address to,
390         uint256 tokenId
391     ) external;
392 
393     /**
394      * @dev Transfers `tokenId` token from `from` to `to`.
395      *
396      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
397      *
398      * Requirements:
399      *
400      * - `from` cannot be the zero address.
401      * - `to` cannot be the zero address.
402      * - `tokenId` token must be owned by `from`.
403      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
404      *
405      * Emits a {Transfer} event.
406      */
407     function transferFrom(
408         address from,
409         address to,
410         uint256 tokenId
411     ) external;
412 
413     /**
414      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
415      * The approval is cleared when the token is transferred.
416      *
417      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
418      *
419      * Requirements:
420      *
421      * - The caller must own the token or be an approved operator.
422      * - `tokenId` must exist.
423      *
424      * Emits an {Approval} event.
425      */
426     function approve(address to, uint256 tokenId) external;
427 
428     /**
429      * @dev Returns the account approved for `tokenId` token.
430      *
431      * Requirements:
432      *
433      * - `tokenId` must exist.
434      */
435     function getApproved(uint256 tokenId) external view returns (address operator);
436 
437     /**
438      * @dev Approve or remove `operator` as an operator for the caller.
439      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
440      *
441      * Requirements:
442      *
443      * - The `operator` cannot be the caller.
444      *
445      * Emits an {ApprovalForAll} event.
446      */
447     function setApprovalForAll(address operator, bool _approved) external;
448 
449     /**
450      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
451      *
452      * See {setApprovalForAll}
453      */
454     function isApprovedForAll(address owner, address operator) external view returns (bool);
455 
456     /**
457      * @dev Safely transfers `tokenId` token from `from` to `to`.
458      *
459      * Requirements:
460      *
461      * - `from` cannot be the zero address.
462      * - `to` cannot be the zero address.
463      * - `tokenId` token must exist and be owned by `from`.
464      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
465      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
466      *
467      * Emits a {Transfer} event.
468      */
469     function safeTransferFrom(
470         address from,
471         address to,
472         uint256 tokenId,
473         bytes calldata data
474     ) external;
475 }
476 
477 
478 pragma solidity ^0.8.0;
479 
480 
481 /**
482  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
483  * @dev See https://eips.ethereum.org/EIPS/eip-721
484  */
485 interface IERC721Metadata is IERC721 {
486     /**
487      * @dev Returns the token collection name.
488      */
489     function name() external view returns (string memory);
490 
491     /**
492      * @dev Returns the token collection symbol.
493      */
494     function symbol() external view returns (string memory);
495 
496     /**
497      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
498      */
499     function tokenURI(uint256 tokenId) external view returns (string memory);
500 }
501 
502 
503 pragma solidity ^0.8.0;
504 
505 
506 /**
507  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
508  * @dev See https://eips.ethereum.org/EIPS/eip-721
509  */
510 interface IERC721Enumerable is IERC721 {
511     /**
512      * @dev Returns the total amount of tokens stored by the contract.
513      */
514     function totalSupply() external view returns (uint256);
515 
516     /**
517      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
518      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
519      */
520     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
521 
522     /**
523      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
524      * Use along with {totalSupply} to enumerate all tokens.
525      */
526     function tokenByIndex(uint256 index) external view returns (uint256);
527 }
528 
529 pragma solidity ^0.8.0;
530 
531 /*
532  * @dev Provides information about the current execution context, including the
533  * sender of the transaction and its data. While these are generally available
534  * via msg.sender and msg.data, they should not be accessed in such a direct
535  * manner, since when dealing with meta-transactions the account sending and
536  * paying for execution may not be the actual sender (as far as an application
537  * is concerned).
538  *
539  * This contract is only required for intermediate, library-like contracts.
540  */
541 abstract contract Context {
542     function _msgSender() internal view virtual returns (address) {
543         return msg.sender;
544     }
545 
546     function _msgData() internal view virtual returns (bytes calldata) {
547         return msg.data;
548     }
549 }
550 
551 
552 pragma solidity ^0.8.0;
553 
554 /**
555  * @dev String operations.
556  */
557 library Strings {
558     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
559 
560     /**
561      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
562      */
563     function toString(uint256 value) internal pure returns (string memory) {
564         // Inspired by OraclizeAPI's implementation - MIT licence
565         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
566 
567         if (value == 0) {
568             return "0";
569         }
570         uint256 temp = value;
571         uint256 digits;
572         while (temp != 0) {
573             digits++;
574             temp /= 10;
575         }
576         bytes memory buffer = new bytes(digits);
577         while (value != 0) {
578             digits -= 1;
579             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
580             value /= 10;
581         }
582         return string(buffer);
583     }
584 
585     /**
586      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
587      */
588     function toHexString(uint256 value) internal pure returns (string memory) {
589         if (value == 0) {
590             return "0x00";
591         }
592         uint256 temp = value;
593         uint256 length = 0;
594         while (temp != 0) {
595             length++;
596             temp >>= 8;
597         }
598         return toHexString(value, length);
599     }
600 
601     /**
602      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
603      */
604     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
605         bytes memory buffer = new bytes(2 * length + 2);
606         buffer[0] = "0";
607         buffer[1] = "x";
608         for (uint256 i = 2 * length + 1; i > 1; --i) {
609             buffer[i] = _HEX_SYMBOLS[value & 0xf];
610             value >>= 4;
611         }
612         require(value == 0, "Strings: hex length insufficient");
613         return string(buffer);
614     }
615 }
616 
617 
618 pragma solidity ^0.8.0;
619 
620 
621 /**
622  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
623  * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.
624  *
625  * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).
626  *
627  * Assumes the number of issuable tokens (collection size) is capped and fits in a uint128.
628  *
629  * Does not support burning tokens to address(0).
630  */
631 contract ERC721A is
632   Context,
633   ERC165,
634   IERC721,
635   IERC721Metadata,
636   IERC721Enumerable
637 {
638   using Address for address;
639   using Strings for uint256;
640 
641   struct TokenOwnership {
642     address addr;
643     uint64 startTimestamp;
644   }
645 
646   struct AddressData {
647     uint128 balance;
648     uint128 numberMinted;
649   }
650 
651   uint256 private currentIndex = 0;
652 
653   uint256 internal  collectionSize;
654   uint256 internal  collectionSizeFree;
655   uint256 internal  maxBatchSize;
656 
657   // Token name
658   string private _name;
659 
660   // Token symbol
661   string private _symbol;
662 
663   // Mapping from token ID to ownership details
664   // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.
665   mapping(uint256 => TokenOwnership) private _ownerships;
666 
667   // Mapping owner address to address data
668   mapping(address => AddressData) private _addressData;
669 
670   // Mapping from token ID to approved address
671   mapping(uint256 => address) private _tokenApprovals;
672 
673   // Mapping from owner to operator approvals
674   mapping(address => mapping(address => bool)) private _operatorApprovals;
675 
676   /**
677    * @dev
678    * `maxBatchSize` refers to how much a minter can mint at a time.
679    * `collectionSize_` refers to how many tokens are in the collection.
680    */
681   constructor(
682     string memory name_,
683     string memory symbol_,
684     uint256 maxBatchSize_,
685     uint256 collectionSize_,
686     uint256 collectionSizeFree_
687   ) {
688     require(
689       collectionSize_ > 0,
690       "ERC721A: collection must have a nonzero supply"
691     );
692     require(maxBatchSize_ > 0, "ERC721A: max batch size must be nonzero");
693     _name = name_;
694     _symbol = symbol_;
695     maxBatchSize = maxBatchSize_;
696     collectionSize = collectionSize_;
697     collectionSizeFree = collectionSizeFree_;
698   }
699 
700   /**
701    * @dev See {IERC721Enumerable-totalSupply}.
702    */
703   function totalSupply() public view override returns (uint256) {
704     return currentIndex;
705   }
706 
707   /**
708    * @dev See {IERC721Enumerable-tokenByIndex}.
709    */
710   function tokenByIndex(uint256 index) public view override returns (uint256) {
711     require(index < totalSupply(), "ERC721A: global index out of bounds");
712     return index;
713   }
714 
715   /**
716    * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
717    * This read function is O(collectionSize). If calling from a separate contract, be sure to test gas first.
718    * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.
719    */
720   function tokenOfOwnerByIndex(address owner, uint256 index)
721     public
722     view
723     override
724     returns (uint256)
725   {
726     require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
727     uint256 numMintedSoFar = totalSupply();
728     uint256 tokenIdsIdx = 0;
729     address currOwnershipAddr = address(0);
730     for (uint256 i = 0; i < numMintedSoFar; i++) {
731       TokenOwnership memory ownership = _ownerships[i];
732       if (ownership.addr != address(0)) {
733         currOwnershipAddr = ownership.addr;
734       }
735       if (currOwnershipAddr == owner) {
736         if (tokenIdsIdx == index) {
737           return i;
738         }
739         tokenIdsIdx++;
740       }
741     }
742     revert("ERC721A: unable to get token of owner by index");
743   }
744 
745   /**
746    * @dev See {IERC165-supportsInterface}.
747    */
748   function supportsInterface(bytes4 interfaceId)
749     public
750     view
751     virtual
752     override(ERC165, IERC165)
753     returns (bool)
754   {
755     return
756       interfaceId == type(IERC721).interfaceId ||
757       interfaceId == type(IERC721Metadata).interfaceId ||
758       interfaceId == type(IERC721Enumerable).interfaceId ||
759       super.supportsInterface(interfaceId);
760   }
761 
762   /**
763    * @dev See {IERC721-balanceOf}.
764    */
765   function balanceOf(address owner) public view override returns (uint256) {
766     require(owner != address(0), "ERC721A: balance query for the zero address");
767     return uint256(_addressData[owner].balance);
768   }
769 
770   function _numberMinted(address owner) internal view returns (uint256) {
771     require(
772       owner != address(0),
773       "ERC721A: number minted query for the zero address"
774     );
775     return uint256(_addressData[owner].numberMinted);
776   }
777 
778   function ownershipOf(uint256 tokenId)
779     internal
780     view
781     returns (TokenOwnership memory)
782   {
783     require(_exists(tokenId), "ERC721A: owner query for nonexistent token");
784 
785     uint256 lowestTokenToCheck;
786     if (tokenId >= maxBatchSize) {
787       lowestTokenToCheck = tokenId - maxBatchSize + 1;
788     }
789 
790     for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {
791       TokenOwnership memory ownership = _ownerships[curr];
792       if (ownership.addr != address(0)) {
793         return ownership;
794       }
795     }
796 
797     revert("ERC721A: unable to determine the owner of token");
798   }
799 
800   /**
801    * @dev See {IERC721-ownerOf}.
802    */
803   function ownerOf(uint256 tokenId) public view override returns (address) {
804     return ownershipOf(tokenId).addr;
805   }
806 
807   /**
808    * @dev See {IERC721Metadata-name}.
809    */
810   function name() public view virtual override returns (string memory) {
811     return _name;
812   }
813 
814   /**
815    * @dev See {IERC721Metadata-symbol}.
816    */
817   function symbol() public view virtual override returns (string memory) {
818     return _symbol;
819   }
820 
821   /**
822    * @dev See {IERC721Metadata-tokenURI}.
823    */
824   function tokenURI(uint256 tokenId)
825     public
826     view
827     virtual
828     override
829     returns (string memory)
830   {
831     require(
832       _exists(tokenId),
833       "ERC721Metadata: URI query for nonexistent token"
834     );
835 
836     string memory baseURI = _baseURI();
837     return
838       bytes(baseURI).length > 0
839         ? string(abi.encodePacked(baseURI, tokenId.toString()))
840         : "";
841   }
842 
843   /**
844    * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
845    * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
846    * by default, can be overriden in child contracts.
847    */
848   function _baseURI() internal view virtual returns (string memory) {
849     return "";
850   }
851 
852   /**
853    * @dev See {IERC721-approve}.
854    */
855   function approve(address to, uint256 tokenId) public override {
856     address owner = ERC721A.ownerOf(tokenId);
857     require(to != owner, "ERC721A: approval to current owner");
858 
859     require(
860       _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
861       "ERC721A: approve caller is not owner nor approved for all"
862     );
863 
864     _approve(to, tokenId, owner);
865   }
866 
867   /**
868    * @dev See {IERC721-getApproved}.
869    */
870   function getApproved(uint256 tokenId) public view override returns (address) {
871     require(_exists(tokenId), "ERC721A: approved query for nonexistent token");
872 
873     return _tokenApprovals[tokenId];
874   }
875 
876   /**
877    * @dev See {IERC721-setApprovalForAll}.
878    */
879   function setApprovalForAll(address operator, bool approved) public override {
880     require(operator != _msgSender(), "ERC721A: approve to caller");
881 
882     _operatorApprovals[_msgSender()][operator] = approved;
883     emit ApprovalForAll(_msgSender(), operator, approved);
884   }
885 
886   /**
887    * @dev See {IERC721-isApprovedForAll}.
888    */
889   function isApprovedForAll(address owner, address operator)
890     public
891     view
892     virtual
893     override
894     returns (bool)
895   {
896     return _operatorApprovals[owner][operator];
897   }
898 
899   /**
900    * @dev See {IERC721-transferFrom}.
901    */
902   function transferFrom(
903     address from,
904     address to,
905     uint256 tokenId
906   ) public override {
907     _transfer(from, to, tokenId);
908   }
909 
910   /**
911    * @dev See {IERC721-safeTransferFrom}.
912    */
913   function safeTransferFrom(
914     address from,
915     address to,
916     uint256 tokenId
917   ) public override {
918     safeTransferFrom(from, to, tokenId, "");
919   }
920 
921   /**
922    * @dev See {IERC721-safeTransferFrom}.
923    */
924   function safeTransferFrom(
925     address from,
926     address to,
927     uint256 tokenId,
928     bytes memory _data
929   ) public override {
930     _transfer(from, to, tokenId);
931     require(
932       _checkOnERC721Received(from, to, tokenId, _data),
933       "ERC721A: transfer to non ERC721Receiver implementer"
934     );
935   }
936 
937   /**
938    * @dev Returns whether `tokenId` exists.
939    *
940    * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
941    *
942    * Tokens start existing when they are minted (`_mint`),
943    */
944   function _exists(uint256 tokenId) internal view returns (bool) {
945     return tokenId < currentIndex;
946   }
947 
948   function _safeMint(address to, uint256 quantity) internal {
949     _safeMint(to, quantity, "");
950   }
951 
952   /**
953    * @dev Mints `quantity` tokens and transfers them to `to`.
954    *
955    * Requirements:
956    *
957    * - there must be `quantity` tokens remaining unminted in the total collection.
958    * - `to` cannot be the zero address.
959    * - `quantity` cannot be larger than the max batch size.
960    *
961    * Emits a {Transfer} event.
962    */
963   function _safeMint(
964     address to,
965     uint256 quantity,
966     bytes memory _data
967   ) internal {
968     uint256 startTokenId = currentIndex;
969     require(to != address(0), "ERC721A: mint to the zero address");
970     // We know if the first token in the batch doesn't exist, the other ones don't as well, because of serial ordering.
971     require(!_exists(startTokenId), "ERC721A: token already minted");
972     require(quantity <= maxBatchSize, "ERC721A: quantity to mint too high");
973 
974     _beforeTokenTransfers(address(0), to, startTokenId, quantity);
975 
976     AddressData memory addressData = _addressData[to];
977     _addressData[to] = AddressData(
978       addressData.balance + uint128(quantity),
979       addressData.numberMinted + uint128(quantity)
980     );
981     _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));
982 
983     uint256 updatedIndex = startTokenId;
984 
985     for (uint256 i = 0; i < quantity; i++) {
986       emit Transfer(address(0), to, updatedIndex);
987       require(
988         _checkOnERC721Received(address(0), to, updatedIndex, _data),
989         "ERC721A: transfer to non ERC721Receiver implementer"
990       );
991       updatedIndex++;
992     }
993 
994     currentIndex = updatedIndex;
995     _afterTokenTransfers(address(0), to, startTokenId, quantity);
996   }
997 
998   /**
999    * @dev Transfers `tokenId` from `from` to `to`.
1000    *
1001    * Requirements:
1002    *
1003    * - `to` cannot be the zero address.
1004    * - `tokenId` token must be owned by `from`.
1005    *
1006    * Emits a {Transfer} event.
1007    */
1008   function _transfer(
1009     address from,
1010     address to,
1011     uint256 tokenId
1012   ) private {
1013     TokenOwnership memory prevOwnership = ownershipOf(tokenId);
1014 
1015     bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||
1016       getApproved(tokenId) == _msgSender() ||
1017       isApprovedForAll(prevOwnership.addr, _msgSender()));
1018 
1019     require(
1020       isApprovedOrOwner,
1021       "ERC721A: transfer caller is not owner nor approved"
1022     );
1023 
1024     require(
1025       prevOwnership.addr == from,
1026       "ERC721A: transfer from incorrect owner"
1027     );
1028     require(to != address(0), "ERC721A: transfer to the zero address");
1029 
1030     _beforeTokenTransfers(from, to, tokenId, 1);
1031 
1032     // Clear approvals from the previous owner
1033     _approve(address(0), tokenId, prevOwnership.addr);
1034 
1035     _addressData[from].balance -= 1;
1036     _addressData[to].balance += 1;
1037     _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));
1038 
1039     // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
1040     // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1041     uint256 nextTokenId = tokenId + 1;
1042     if (_ownerships[nextTokenId].addr == address(0)) {
1043       if (_exists(nextTokenId)) {
1044         _ownerships[nextTokenId] = TokenOwnership(
1045           prevOwnership.addr,
1046           prevOwnership.startTimestamp
1047         );
1048       }
1049     }
1050 
1051     emit Transfer(from, to, tokenId);
1052     _afterTokenTransfers(from, to, tokenId, 1);
1053   }
1054 
1055   /**
1056    * @dev Approve `to` to operate on `tokenId`
1057    *
1058    * Emits a {Approval} event.
1059    */
1060   function _approve(
1061     address to,
1062     uint256 tokenId,
1063     address owner
1064   ) private {
1065     _tokenApprovals[tokenId] = to;
1066     emit Approval(owner, to, tokenId);
1067   }
1068 
1069   uint256 public nextOwnerToExplicitlySet = 0;
1070 
1071   /**
1072    * @dev Explicitly set `owners` to eliminate loops in future calls of ownerOf().
1073    */
1074   function _setOwnersExplicit(uint256 quantity) internal {
1075     uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;
1076     require(quantity > 0, "quantity must be nonzero");
1077     uint256 endIndex = oldNextOwnerToSet + quantity - 1;
1078     if (endIndex > collectionSize - 1) {
1079       endIndex = collectionSize - 1;
1080     }
1081     // We know if the last one in the group exists, all in the group exist, due to serial ordering.
1082     require(_exists(endIndex), "not enough minted yet for this cleanup");
1083     for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {
1084       if (_ownerships[i].addr == address(0)) {
1085         TokenOwnership memory ownership = ownershipOf(i);
1086         _ownerships[i] = TokenOwnership(
1087           ownership.addr,
1088           ownership.startTimestamp
1089         );
1090       }
1091     }
1092     nextOwnerToExplicitlySet = endIndex + 1;
1093   }
1094 
1095   /**
1096    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1097    * The call is not executed if the target address is not a contract.
1098    *
1099    * @param from address representing the previous owner of the given token ID
1100    * @param to target address that will receive the tokens
1101    * @param tokenId uint256 ID of the token to be transferred
1102    * @param _data bytes optional data to send along with the call
1103    * @return bool whether the call correctly returned the expected magic value
1104    */
1105   function _checkOnERC721Received(
1106     address from,
1107     address to,
1108     uint256 tokenId,
1109     bytes memory _data
1110   ) private returns (bool) {
1111     if (to.isContract()) {
1112       try
1113         IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)
1114       returns (bytes4 retval) {
1115         return retval == IERC721Receiver(to).onERC721Received.selector;
1116       } catch (bytes memory reason) {
1117         if (reason.length == 0) {
1118           revert("ERC721A: transfer to non ERC721Receiver implementer");
1119         } else {
1120           assembly {
1121             revert(add(32, reason), mload(reason))
1122           }
1123         }
1124       }
1125     } else {
1126       return true;
1127     }
1128   }
1129 
1130   /**
1131    * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
1132    *
1133    * startTokenId - the first token id to be transferred
1134    * quantity - the amount to be transferred
1135    *
1136    * Calling conditions:
1137    *
1138    * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1139    * transferred to `to`.
1140    * - When `from` is zero, `tokenId` will be minted for `to`.
1141    */
1142   function _beforeTokenTransfers(
1143     address from,
1144     address to,
1145     uint256 startTokenId,
1146     uint256 quantity
1147   ) internal virtual {}
1148 
1149   /**
1150    * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
1151    * minting.
1152    *
1153    * startTokenId - the first token id to be transferred
1154    * quantity - the amount to be transferred
1155    *
1156    * Calling conditions:
1157    *
1158    * - when `from` and `to` are both non-zero.
1159    * - `from` and `to` are never both zero.
1160    */
1161   function _afterTokenTransfers(
1162     address from,
1163     address to,
1164     uint256 startTokenId,
1165     uint256 quantity
1166   ) internal virtual {}
1167 }
1168 
1169 
1170 pragma solidity ^0.8.0;
1171 
1172 /**
1173  * @dev Contract module that helps prevent reentrant calls to a function.
1174  *
1175  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
1176  * available, which can be applied to functions to make sure there are no nested
1177  * (reentrant) calls to them.
1178  *
1179  * Note that because there is a single `nonReentrant` guard, functions marked as
1180  * `nonReentrant` may not call one another. This can be worked around by making
1181  * those functions `private`, and then adding `external` `nonReentrant` entry
1182  * points to them.
1183  *
1184  * TIP: If you would like to learn more about reentrancy and alternative ways
1185  * to protect against it, check out our blog post
1186  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
1187  */
1188 abstract contract ReentrancyGuard {
1189     // Booleans are more expensive than uint256 or any type that takes up a full
1190     // word because each write operation emits an extra SLOAD to first read the
1191     // slot's contents, replace the bits taken up by the boolean, and then write
1192     // back. This is the compiler's defense against contract upgrades and
1193     // pointer aliasing, and it cannot be disabled.
1194 
1195     // The values being non-zero value makes deployment a bit more expensive,
1196     // but in exchange the refund on every call to nonReentrant will be lower in
1197     // amount. Since refunds are capped to a percentage of the total
1198     // transaction's gas, it is best to keep them low in cases like this one, to
1199     // increase the likelihood of the full refund coming into effect.
1200     uint256 private constant _NOT_ENTERED = 1;
1201     uint256 private constant _ENTERED = 2;
1202 
1203     uint256 private _status;
1204 
1205     constructor() {
1206         _status = _NOT_ENTERED;
1207     }
1208 
1209     /**
1210      * @dev Prevents a contract from calling itself, directly or indirectly.
1211      * Calling a `nonReentrant` function from another `nonReentrant`
1212      * function is not supported. It is possible to prevent this from happening
1213      * by making the `nonReentrant` function external, and make it call a
1214      * `private` function that does the actual work.
1215      */
1216     modifier nonReentrant() {
1217         // On the first call to nonReentrant, _notEntered will be true
1218         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
1219 
1220         // Any calls to nonReentrant after this point will fail
1221         _status = _ENTERED;
1222 
1223         _;
1224 
1225         // By storing the original value once again, a refund is triggered (see
1226         // https://eips.ethereum.org/EIPS/eip-2200)
1227         _status = _NOT_ENTERED;
1228     }
1229 }
1230 
1231 
1232 pragma solidity ^0.8.0;
1233 
1234 
1235 /**
1236  * @dev Contract module which provides a basic access control mechanism, where
1237  * there is an account (an owner) that can be granted exclusive access to
1238  * specific functions.
1239  *
1240  * By default, the owner account will be the one that deploys the contract. This
1241  * can later be changed with {transferOwnership}.
1242  *
1243  * This module is used through inheritance. It will make available the modifier
1244  * `onlyOwner`, which can be applied to your functions to restrict their use to
1245  * the owner.
1246  */
1247 abstract contract Ownable is Context {
1248     address private _owner;
1249 
1250     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
1251 
1252     /**
1253      * @dev Initializes the contract setting the deployer as the initial owner.
1254      */
1255     constructor() {
1256         _setOwner(_msgSender());
1257     }
1258 
1259     /**
1260      * @dev Returns the address of the current owner.
1261      */
1262     function owner() public view virtual returns (address) {
1263         return _owner;
1264     }
1265 
1266     /**
1267      * @dev Throws if called by any account other than the owner.
1268      */
1269     modifier onlyOwner() {
1270         require(owner() == _msgSender(), "Ownable: caller is not the owner");
1271         _;
1272     }
1273 
1274     /**
1275      * @dev Leaves the contract without owner. It will not be possible to call
1276      * `onlyOwner` functions anymore. Can only be called by the current owner.
1277      *
1278      * NOTE: Renouncing ownership will leave the contract without an owner,
1279      * thereby removing any functionality that is only available to the owner.
1280      */
1281     function renounceOwnership() public virtual onlyOwner {
1282         _setOwner(address(0));
1283     }
1284 
1285     /**
1286      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1287      * Can only be called by the current owner.
1288      */
1289     function transferOwnership(address newOwner) public virtual onlyOwner {
1290         require(newOwner != address(0), "Ownable: new owner is the zero address");
1291         _setOwner(newOwner);
1292     }
1293 
1294     function _setOwner(address newOwner) private {
1295         address oldOwner = _owner;
1296         _owner = newOwner;
1297         emit OwnershipTransferred(oldOwner, newOwner);
1298     }
1299 }
1300 
1301 
1302 pragma solidity ^0.8.0;
1303 
1304 
1305 contract dansDANSdans is Ownable, ERC721A, ReentrancyGuard {
1306   uint256 public maxPerAddressDuringMint;
1307   uint256 public amountForDevs;
1308   uint256 public price = 0.009 ether;
1309   uint256 public freemintAmount = 2;
1310   uint256 public mintAmount = 20;
1311 
1312   struct SaleConfig {
1313     uint64 publicPrice;
1314   }
1315 
1316   SaleConfig public saleConfig;
1317 
1318   mapping(address => uint256) public allowlist;
1319 
1320   constructor(
1321     uint256 maxBatchSize_,
1322     uint256 collectionSize_,
1323     uint256 collectionSizeFree_,
1324     uint256 amountForDevs_
1325   ) ERC721A("dansDANSdans", "DANS", maxBatchSize_, collectionSize_, collectionSizeFree_) {
1326     maxPerAddressDuringMint = 50;
1327     amountForDevs = amountForDevs_;
1328     
1329   }
1330 
1331   modifier callerIsUser() {
1332     require(tx.origin == msg.sender, "The caller is another contract");
1333     _;
1334   }
1335 
1336   function webmint(uint256 quantity)
1337     external
1338     payable
1339     callerIsUser
1340   {
1341       require(quantity <= mintAmount, "Too many minted at once");
1342       require(msg.value >= price * quantity, "Need to send more ETH.");
1343     require(totalSupply() + quantity <= collectionSize, "reached max supply");
1344     _safeMint(msg.sender, quantity);
1345     
1346   }
1347 
1348 
1349   function mint(uint256 quantity) external payable {address _caller = _msgSender();
1350      
1351         require(quantity > 0, "No 0 mints");
1352         require(tx.origin == _caller, "No contracts"); 
1353 
1354         if(collectionSizeFree >= totalSupply())
1355 
1356         {require(freemintAmount >= quantity , "Excess max per free tx");} 
1357 
1358 
1359      else
1360      
1361      {require(mintAmount >= quantity , "Excess max per paid tx");
1362      
1363      require(msg.value >= price * quantity, "Need to send more ETH.");
1364      
1365      }
1366     
1367     _safeMint(msg.sender, quantity);
1368 
1369      }
1370 
1371   function seedAllowlist(address[] memory addresses, uint256[] memory numSlots)
1372     external
1373     onlyOwner
1374   {
1375     require(
1376       addresses.length == numSlots.length,
1377       "addresses does not match numSlots length"
1378     );
1379     for (uint256 i = 0; i < addresses.length; i++) {
1380       allowlist[addresses[i]] = numSlots[i];
1381     }
1382   }
1383 
1384   // For marketing etc.
1385   function Mint(uint256 quantity) external onlyOwner {
1386     
1387      require(totalSupply() + quantity <= amountForDevs, "reached max supply");
1388     _safeMint(msg.sender, quantity);
1389   }
1390     
1391 
1392   // // metadata URI
1393   string private _baseTokenURI;
1394 
1395   function _baseURI() internal view virtual override returns (string memory) {
1396     return _baseTokenURI;
1397   }
1398 
1399   function setBaseURI(string calldata baseURI) external onlyOwner {
1400     _baseTokenURI = baseURI;
1401   }
1402 
1403   function withdrawMoney() external onlyOwner nonReentrant {
1404     (bool success, ) = msg.sender.call{value: address(this).balance}("");
1405     require(success, "Transfer failed.");
1406   }
1407 
1408   function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
1409     _setOwnersExplicit(quantity);
1410   }
1411 
1412   function numberMinted(address owner) public view returns (uint256) {
1413     return _numberMinted(owner);
1414   }
1415 
1416   function getOwnershipData(uint256 tokenId)
1417     external
1418     view
1419     returns (TokenOwnership memory)
1420   {
1421     return ownershipOf(tokenId);
1422   }
1423 
1424 function setprice(uint256 _newprice) public onlyOwner {
1425 	    price = _newprice;
1426 	}
1427 
1428   function setfreemints(uint256 _newfreemints) public onlyOwner {
1429 	    collectionSizeFree = _newfreemints;
1430 	}
1431 
1432     function setcollectionSize(uint256 _newcollectionSize) public onlyOwner {
1433 	    collectionSize = _newcollectionSize;
1434 	}
1435 
1436     function setamountForDevs(uint256 _newamountForDevs) public onlyOwner {
1437 	    amountForDevs = _newamountForDevs;
1438 	}
1439 
1440     function setfreemintAmount(uint256 _newfreemintAmount) public onlyOwner {
1441 	    freemintAmount = _newfreemintAmount;
1442 	}
1443 
1444     function setmintAmount(uint256 _newmintAmount) public onlyOwner {
1445 	    mintAmount = _newmintAmount;
1446 	}
1447 
1448 
1449 }