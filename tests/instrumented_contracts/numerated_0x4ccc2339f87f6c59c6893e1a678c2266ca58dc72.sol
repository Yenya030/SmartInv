1 {{
2   "language": "Solidity",
3   "sources": {
4     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/OwnedUpgradeabilityProxy.sol": {
5       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport \"./UpgradeabilityProxy.sol\";\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n    /// @dev Storage position of the owner of the contract\n    bytes32 private constant proxyOwnerPosition = keccak256(\"org.zeppelinos.proxy.owner\");\n\n    /**\n     * @dev the constructor sets the original owner of the contract to the sender account.\n     */\n    constructor() public {\n        setUpgradeabilityOwner(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner());\n        _;\n    }\n\n    /**\n     * @dev Tells the address of the owner\n     * @return owner the address of the owner\n     */\n    function proxyOwner() public view returns (address owner) {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            owner := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the owner\n     * @param _newProxyOwner address of new proxy owner\n     */\n    function setUpgradeabilityOwner(address _newProxyOwner) internal {\n        bytes32 position = proxyOwnerPosition;\n        assembly {\n            sstore(position, _newProxyOwner)\n        }\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n        require(_newOwner != address(0));\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n        setUpgradeabilityOwner(_newOwner);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy.\n     * @param _implementation representing the address of the new implementation to be set.\n     */\n    function upgradeTo(address _implementation) public onlyProxyOwner {\n        _upgradeTo(_implementation);\n    }\n\n    /**\n     * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\n     * to initialize whatever is needed through a low level call.\n     * @param _implementation representing the address of the new implementation to be set.\n     * @param _data represents the msg.data to bet sent in the low level call. This parameter may include the function\n     * signature of the implementation to be called with the needed payload\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data) public payable onlyProxyOwner {\n        upgradeTo(_implementation);\n        (bool success, ) = address(this).call{value: msg.value}(_data);\n        require(success);\n    }\n}\n"
6     },
7     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/Proxy.sol": {
8       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\nabstract contract Proxy {\n    /**\n     * @dev Tells the address of the implementation where every call will be delegated.\n     * @return address of the implementation to which it will be delegated\n     */\n    function implementation() public virtual view returns (address);\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n     * This function will return whatever the implementation call returns\n     */\n    fallback() external payable {\n        address _impl = implementation();\n        require(_impl != address(0));\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n}\n"
9     },
10     "/Users/haythem96/Projects/Opyn/GammaProtocol/contracts/packages/oz/upgradeability/UpgradeabilityProxy.sol": {
11       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy {\n    /**\n     * @dev This event will be emitted every time the implementation gets upgraded\n     * @param implementation representing the address of the upgraded implementation\n     */\n    event Upgraded(address indexed implementation);\n\n    /// @dev Storage position of the address of the current implementation\n    bytes32 private constant implementationPosition = keccak256(\"org.zeppelinos.proxy.implementation\");\n\n    /**\n     * @dev Tells the address of the current implementation\n     * @return impl address of the current implementation\n     */\n    function implementation() public override view returns (address impl) {\n        bytes32 position = implementationPosition;\n        assembly {\n            impl := sload(position)\n        }\n    }\n\n    /**\n     * @dev Sets the address of the current implementation\n     * @param _newImplementation address representing the new implementation to be set\n     */\n    function setImplementation(address _newImplementation) internal {\n        bytes32 position = implementationPosition;\n        assembly {\n            sstore(position, _newImplementation)\n        }\n    }\n\n    /**\n     * @dev Upgrades the implementation address\n     * @param _newImplementation representing the address of the new implementation to be set\n     */\n    function _upgradeTo(address _newImplementation) internal {\n        address currentImplementation = implementation();\n        require(currentImplementation != _newImplementation);\n        setImplementation(_newImplementation);\n        emit Upgraded(_newImplementation);\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "remappings": [],
16     "optimizer": {
17       "enabled": true,
18       "runs": 200
19     },
20     "evmVersion": "istanbul",
21     "libraries": {
22       "": {}
23     },
24     "outputSelection": {
25       "*": {
26         "*": [
27           "evm.bytecode",
28           "evm.deployedBytecode",
29           "abi"
30         ]
31       }
32     }
33   }
34 }}