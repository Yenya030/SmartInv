1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/levin.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction allowance(address _owner, address spender) external view returns (uint256);\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory { function createPair(address tokenA, address tokenB) external returns (address pair); }\r\ninterface IUniswapV2Router02 {\r\n\tfunction getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\r\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n\tfunction factory() external pure returns (address);\r\n\tfunction addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\nabstract contract OWNED {\r\n\taddress internal _owner;\r\n\tevent OwnershipTransferred(address owner);\r\n\tconstructor(address contractOwner) { _owner = contractOwner; }\r\n\tmodifier onlyOwner() { require(msg.sender == _owner, \"Not the owner\"); _; }\r\n\t// function owner() external view returns (address) { return _owner; }  // moved into addressList() function\r\n\tfunction renounceOwnership() external onlyOwner { _transferOwnership(address(0)); }\r\n\tfunction transferOwnership(address newOwner) external onlyOwner { _transferOwnership(newOwner); }\r\n\tfunction _transferOwnership(address _newOwner) internal {\r\n\t\t_owner = _newOwner; \r\n\t\temit OwnershipTransferred(_newOwner); \r\n\t}\r\n}\r\n\r\ncontract LEVINU_Sidecar {\r\n\taddress private immutable _owner;\r\n\tconstructor() { _owner = msg.sender; }\r\n\tfunction owner() external view returns (address) { return _owner; }\r\n\tfunction recoverErc20Tokens(address tokenCA) external returns (uint256) {\r\n\t\trequire(msg.sender == _owner, \"Not authorized\");\r\n\t\tuint256 balance = IERC20(tokenCA).balanceOf(address(this));\r\n\t\tif (balance > 0) { IERC20(tokenCA).transfer(msg.sender, balance); }\r\n\t\treturn balance;\r\n\t}\r\n}\r\n\r\ncontract JackLevinInu is IERC20, OWNED {\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(address => mapping(address => uint256)) private _allowances;\r\n\tuint8 private constant _decimals = 9;\r\n\tuint256 private constant _totalSupply = 1_000_000_000 * 10**_decimals;\r\n\tstring private constant _name = \"Jack Levin Inu\";\r\n\tstring private constant _symbol = \"LEVINU\";\r\n\r\n\tuint256 private _thresholdUSDC = 1000;  // tax tokens USD value threshold to trigger tax token swap, transfer and adding liquidity\r\n\tuint256 private _maxTx; \r\n\tuint256 private _maxWallet;\r\n\tuint8 private immutable _usdcDecimals;\r\n\r\n\tuint256 private constant taxMcBracket1 = 100_000; // PROMOTION: below 100k MC tax is 5% (1 XENLP, 4 Marketing)\r\n\tuint256 private constant taxMcBracket2 = 250_000; // SUPPORT: below 250k MC tax is 4% (1 XENLP, 3 Marketing)\r\n\tuint256 private constant taxMcBracket3 = 1_000_000; // COMMUNITY: below 1m MC tax is 2% (1 XENLP, 1 Marketing), above it tax is 0% DEXENTRALIZED:\r\n\r\n\tmapping(address => bool) private _excluded;\r\n\taddress private _marketingWallet = address(0x40F693a958C96241aB0281f120c878ACC664e1D3);\r\n\t\r\n\taddress private constant _xen = address(0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8); \r\n\taddress private constant _usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); \r\n\t\r\n\taddress private immutable _sidecarAddress;\r\n\tLEVINU_Sidecar private immutable _sidecarContract;\r\n\r\n\taddress private constant _swapRouterAddress = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Uniswap V2 Router\r\n\tIUniswapV2Router02 private constant _swapRouter = IUniswapV2Router02(_swapRouterAddress);\r\n\taddress private _primaryLP;\r\n\tmapping(address => bool) private _isLP;\r\n\t\r\n\tuint256 private _openAt;\r\n\tuint256 private _addTime = 0;\r\n\tuint256 private _protected;\r\n\r\n\tbool private swapLocked;\r\n\tmodifier lockSwap { swapLocked = true; _; swapLocked = false; }\r\n\r\n\tconstructor() OWNED(msg.sender)  {\r\n\t\t_balances[address(this)] = _totalSupply;\r\n\t\temit Transfer(address(0), address(this), _balances[address(this)]);\r\n\t\t\r\n\t\t_sidecarContract = new LEVINU_Sidecar();\r\n\t\t_sidecarAddress = address(_sidecarContract);\r\n\t\t_usdcDecimals = IERC20(_usdc).decimals();\r\n\r\n\t\t_changeLimits(10,20); //set max TX to 1%, max wallet 2%\r\n\r\n\t\t_excluded[_owner] = true;\r\n\t\t_excluded[address(this)] = true;\r\n\t\t_excluded[_swapRouterAddress] = true;\r\n\t\t_excluded[_marketingWallet] = true;\r\n\t\t_excluded[_sidecarAddress] = true;\r\n\t}\r\n\r\n\tfunction addressList() external view returns (address owner, address sidecar, address marketing, address xen, address usdc, address swapRouter, address primaryLP) {\r\n\t\treturn (_owner, _sidecarAddress, _marketingWallet, _xen, _usdc, _swapRouterAddress, _primaryLP);\r\n\t}\r\n\r\n\tfunction totalSupply() external pure override returns (uint256) { return _totalSupply; }\r\n\tfunction decimals() external pure override returns (uint8) { return _decimals; }\r\n\tfunction symbol() external pure override returns (string memory) { return _symbol; }\r\n\tfunction name() external pure override returns (string memory) { return _name; }\r\n\tfunction balanceOf(address account) external view override returns (uint256) { return _balances[account]; }\r\n\tfunction allowance(address owner, address spender) external view override returns (uint256) { return _allowances[owner][spender]; }\r\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n\t\trequire(_balances[msg.sender] > 0,\"ERC20: Zero balance\");\r\n\t\t_approve(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction _approve(address owner, address spender, uint256 amount ) private {\r\n\t\trequire(owner != address(0) && spender != address(0), \"ERC20: Zero address\");\r\n\t\t_allowances[owner][spender] = amount;\r\n\t\temit Approval(owner, spender, amount);\r\n\t}\r\n\tfunction _checkAndApproveRouter(uint256 tokenAmount) private {\r\n\t\tif (_allowances[address(this)][_swapRouterAddress] < tokenAmount) { \r\n\t\t\t_approve(address(this), _swapRouterAddress, type(uint256).max);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _checkAndApproveRouterForToken(address _token, uint256 amount) internal {\r\n\t\tuint256 tokenAllowance;\r\n\t\tif (_token == address(this)) {\r\n\t\t\ttokenAllowance = _allowances[address(this)][_swapRouterAddress];\r\n\t\t\tif (amount > tokenAllowance) {\r\n\t\t\t\t_allowances[address(this)][_swapRouterAddress] = type(uint256).max;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttokenAllowance = IERC20(_token).allowance(address(this), _swapRouterAddress);\r\n\t\t\tif (amount > tokenAllowance) {\r\n\t\t\t\tIERC20(_token).approve(_swapRouterAddress, type(uint256).max);\r\n\t\t\t}\r\n\t\t}\r\n    }\r\n\r\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\r\n\t\t_transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction transferFrom(address from, address to, uint256 amount) public returns (bool) {\r\n\t\trequire(_allowances[from][msg.sender] >= amount,\"ERC20: amount exceeds allowance\");\r\n\t\t_allowances[from][msg.sender] -= amount;\r\n\t\t_transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\tfunction _transfer(address from, address to, uint256 amount) private {\r\n\t\trequire(from != address(0) && to != address(0), \"ERC20: Zero address\"); \r\n\t\trequire(_balances[from] >= amount, \"ERC20: amount exceeds balance\"); \r\n\t\trequire(_limitCheck(from, to, amount), \"Limits exceeded\");\r\n\t\trequire(block.timestamp>_openAt, \"Not enabled\");\r\n\r\n\t\tif (block.timestamp>_openAt && block.timestamp<_protected && tx.gasprice>block.basefee) {\r\n\t\t\tuint256 _gpb = tx.gasprice - block.basefee;\r\n\t\t\tuint256 _gpm = 10 * (10**9);\r\n\t\t\trequire(_gpb<_gpm,\"Not enabled\");\r\n\t\t}\r\n\r\n\t\tif ( !swapLocked && !_excluded[from] && _isLP[to] ) { _processTaxTokens(); }\r\n\t\t\r\n\t\t(uint256 xenLP, uint256 levinuLP, uint256 marketing) = _getTaxTokens(from, to, amount);\r\n\t\tuint256 taxTokens = xenLP + levinuLP + marketing;\r\n\t\t_balances[from] -= amount;\r\n\t\t_balances[address(this)] += taxTokens;\r\n\t\t_balances[to] += (amount - taxTokens);\r\n\t\temit Transfer(from, to, amount);\r\n\t}\r\n\tfunction _limitCheck(address from, address to, uint256 amount) private view returns (bool) {\r\n\t\tbool txSize = true;\r\n\t\tif ( amount > _maxTx && !_excluded[from] && !_excluded[to] ) { txSize = false; }\r\n\t\tbool walletSize = true;\r\n\t\tuint256 newBalanceTo = _balances[to] + amount;\r\n\t\tif ( newBalanceTo > _maxWallet && !_excluded[from] && !_excluded[to] && !_isLP[to] ) { walletSize = false; } \r\n\t\treturn (txSize && walletSize);\r\n\t}\r\n\r\n\tfunction _getCurrentDilutedMcUSD() private view returns (uint256) {\r\n\t\tuint256 marketCap;\r\n\t\tif (_primaryLP != address(0)) {\r\n\t\t\tuint256 tokensInLP = _balances[_primaryLP];\r\n\t\t\tuint256 usdcInLP = IERC20(_usdc).balanceOf(_primaryLP) / (10**_usdcDecimals);\r\n\t\t\tmarketCap = (usdcInLP * _totalSupply / tokensInLP);\r\n\t\t}\r\n\t\treturn marketCap;\r\n\t}\r\n\tfunction _getTaxRates() private view returns (uint8 xenRate, uint8 levinuRate, uint8 marketingRate) {\r\n\t\tuint8 _xenRate; uint8 _levinuRate; uint8 _marketingRate;\r\n\t\tuint256 currentDilutedUsdMC = _getCurrentDilutedMcUSD();\r\n\t\tif (currentDilutedUsdMC < taxMcBracket1 ) {\r\n\t\t\t_xenRate = 1; _levinuRate = 0; _marketingRate = 4;\r\n\t\t} else if (currentDilutedUsdMC >= taxMcBracket1 && currentDilutedUsdMC < taxMcBracket2) {\r\n\t\t\t_xenRate = 1; _levinuRate = 0; _marketingRate = 3;\r\n\t\t} else if (currentDilutedUsdMC >= taxMcBracket2 && currentDilutedUsdMC < taxMcBracket3) {\r\n\t\t\t_xenRate = 1; _levinuRate = 0; _marketingRate = 1;\r\n\t\t} else { \r\n\t\t\t_xenRate = 0; _levinuRate = 0; _marketingRate = 0;\r\n\t\t}\r\n\t\treturn (_xenRate, _levinuRate, _marketingRate);\r\n\t}\r\n\tfunction _getTaxTokens(address from, address to, uint256 amount) private view returns (uint256 xenLP, uint256 levinuLP, uint256 marketing) {\r\n\t\tuint256 _xenLP; uint256 _levinuLP; uint256 _marketing;\r\n\t\tif ( (_isLP[from] && !_excluded[to]) || (_isLP[to] && !_excluded[from]) ) { \r\n\t\t\t(uint8 xenRate, uint8 levinuRate, uint8 marketingRate) = _getTaxRates();\r\n\t\t\t_xenLP = amount * xenRate / 100;\r\n\t\t\t_levinuLP = amount * levinuRate / 100;\r\n\t\t\t_marketing = amount * marketingRate / 100;\r\n\t\t}\r\n\t\telse { \r\n\t\t\t_xenLP = 0;\r\n\t\t\t_levinuLP = 0;\r\n\t\t\t_marketing = 0;\r\n\t\t}\r\n\t\treturn (_xenLP, _levinuLP, _marketing);\r\n\t}  \r\n\r\n\tfunction addInitialLiquidity() external onlyOwner {\r\n\t\trequire(IERC20(_usdc).balanceOf(address(this))>0, \"USDC value zero\");\r\n\t\trequire(_primaryLP == address(0), \"LP exists\");\r\n\t\t_primaryLP = IUniswapV2Factory(_swapRouter.factory()).createPair(address(this), _usdc);\r\n\t\t_isLP[_primaryLP] = true;\r\n\t\t_addLiquidity(address(this), _balances[address(this)], IERC20(_usdc).balanceOf(address(this)), false);\r\n\t\t_openAt = block.timestamp + _addTime;\r\n\t\t_protected = _openAt + 0;\r\n\t}\r\n\r\n\tfunction _addLiquidity(address _token, uint256 tokenAmount, uint256 usdcAmount, bool burnLpTokens) internal {\r\n\t\trequire(IERC20(_token).balanceOf(address(this)) >= tokenAmount, \"Not enough tokens\");\r\n\t\trequire(IERC20(_usdc).balanceOf(address(this)) >= usdcAmount, \"Not enough USDC\");\r\n\t\t_checkAndApproveRouterForToken(_token, tokenAmount);\r\n\t\t_checkAndApproveRouterForToken(_usdc, usdcAmount);\r\n\t\taddress lpRecipient = _owner;\r\n\t\tif (burnLpTokens) { lpRecipient = address(0); }\r\n\r\n\t\t_swapRouter.addLiquidity(\r\n\t\t\t_usdc,  \t\t// tokenA\r\n\t\t\t_token, \t\t// tokenB\r\n\t\t\tusdcAmount,     // amountADesired\r\n\t\t\ttokenAmount,    // amountBDesired\r\n\t\t\t0,      \t\t// amountAMin -- allowing slippage\r\n\t\t\t0,      \t\t// amountBMin -- allowing slippage\r\n\t\t\tlpRecipient, \t// to -- who gets the LP tokens\r\n\t\t\tblock.timestamp // deadline\r\n\t\t);\r\n\t}\r\n\r\n\tfunction stats() external view returns (uint256 currentUsdMC, uint256 currentTaxUSD, uint256 swapThresholdUSD) { \r\n\t\tuint256 currentMc = _getCurrentDilutedMcUSD();\r\n\t\tuint256 currentTaxValue = currentMc * _balances[address(this)] / _totalSupply;\r\n\t\treturn (currentMc, currentTaxValue, _thresholdUSDC);\r\n\t}\r\n\r\n\tfunction tax() external view returns (uint8 Liquidityxen, uint8 LiquidityLEVINU, uint8 Marketing) { \r\n\t\t(uint8 xenRate, uint8 levinuRate, uint8 marketingRate) = _getTaxRates();\r\n\t\treturn (xenRate, levinuRate, marketingRate);\r\n\t}\r\n\tfunction limits() external view returns (uint256 maxTransaction, uint256 maxWallet) { return (_maxTx, _maxWallet); }\r\n\tfunction isExcluded(address wallet) external view returns (bool) { return _excluded[wallet]; }\r\n\r\n\tfunction changeLimits(uint16 maxTxPermille, uint16 maxWalletPermille) public onlyOwner { _changeLimits(maxTxPermille, maxWalletPermille); }\r\n\tfunction _changeLimits(uint16 _maxTxPermille, uint16 _maxWalletPermille) private {\r\n\t\tuint256 newMaxTx = (_totalSupply * _maxTxPermille / 1000) + (10 * 10**_decimals); //add 10 tokens to avoid rounding issues\r\n\t\tuint256 newMaxWallet = (_totalSupply * _maxWalletPermille / 1000) + (10 * 10**_decimals); //add 10 tokens to avoid rounding issues\r\n\t\trequire(newMaxTx >= _maxTx && newMaxWallet >= _maxWallet, \"Cannot decrease limits\");\r\n\t\tif (newMaxTx > _totalSupply) { newMaxTx = _totalSupply; }\r\n\t\tif (newMaxWallet > _totalSupply) { newMaxWallet = _totalSupply; }\r\n\t\t_maxTx = newMaxTx;\r\n\t\t_maxWallet = newMaxWallet;\r\n\t}\r\n\r\n\tfunction changeTaxWallet(address walletMarketing) external onlyOwner {\r\n\t\trequire(!_isLP[walletMarketing] && walletMarketing != _swapRouterAddress && walletMarketing != address(this) && walletMarketing != address(0));\r\n\t\t_excluded[walletMarketing] = true;\r\n\t\t_marketingWallet = walletMarketing;\r\n\t}\t\r\n\t\r\n\tfunction _getThresholdTokenAmount() private view returns (uint256) {\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = address(this);\r\n\t\tpath[1] = _usdc;\r\n\t\tuint256[] memory amounts = _swapRouter.getAmountsIn(_thresholdUSDC * 10**_usdcDecimals, path); \r\n\t\treturn amounts[0];\r\n\t}\r\n\tfunction _processTaxTokens() private lockSwap {\r\n\t\tuint256 thresholdTokens = _getThresholdTokenAmount();\r\n\t\t(uint8 xenRate, uint8 levinuRate, uint8 marketingRate) = _getTaxRates();\r\n\t\tuint8 totalRate = xenRate + levinuRate + marketingRate;\r\n\t\tuint256 swapAmount = _balances[address(this)];\r\n\t\tif (totalRate>0 && swapAmount >= thresholdTokens) {\r\n\t\t\tswapAmount = thresholdTokens;\r\n\r\n\t\t\tuint256 tokensForxen = (swapAmount * xenRate / totalRate);\r\n\t\t\tuint256 tokensForlevinuLP = (swapAmount * levinuRate / totalRate)/2;\r\n\t\t\tuint256 tokensForMarketing = swapAmount * marketingRate / totalRate;\r\n\r\n\t\t\tuint256 tokensToSwap = tokensForxen + tokensForMarketing + tokensForlevinuLP;\r\n\t\t\tif (tokensToSwap >= 10**_decimals) {\r\n\t\t\t\tuint256 swappedOutputUSDC = _swapTokens(address(this), _usdc, tokensToSwap, true); //swap LEVINU for USDC, use sidecar contract\r\n\t\t\t\tuint256 usdcForlevinuLP = swappedOutputUSDC * tokensForlevinuLP / tokensToSwap; //calc USDC for LEVINU liquidity\r\n\t\t\t\tuint256 usdcToSpendOnxen = (swappedOutputUSDC * tokensForxen / tokensToSwap) / 2; //calc USDC for xen liquidity\r\n\t\t\t\tuint256 usdcForMarketing = swappedOutputUSDC * tokensForMarketing / tokensToSwap; //calc USDC for marketing\r\n\r\n\t\t\t\tif (levinuRate>0) { _addLiquidity(address(this), tokensForlevinuLP, usdcForlevinuLP, true); } //add LEVINU liquidity and burn LP tokens\r\n\r\n\t\t\t\tif (xenRate>0) {\r\n\t\t\t\t\tuint256 xenPurchased = _swapTokens(_usdc, _xen, usdcToSpendOnxen, false); //purchase xen for liquidity, sidecar not used\r\n\t\t\t\t\t_addLiquidity(_xen, xenPurchased, usdcToSpendOnxen, true); //add xen liquidity and burn LP tokens\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (marketingRate>0) {\r\n\t\t\t\t\tuint256 remainingUsdcBalance = IERC20(_usdc).balanceOf(address(this));\r\n\t\t\t\t\tif (usdcForMarketing > remainingUsdcBalance) { usdcForMarketing = remainingUsdcBalance; } //added check to avoid risk of having insufficient balance\r\n\t\t\t\t\tif (usdcForMarketing > 0) { IERC20(_usdc).transfer(_marketingWallet, usdcForMarketing); } //transfer USDC to marketing wallet\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _swapTokens(address inputToken, address outputToken, uint256 inputAmount, bool useSidecar) private returns(uint256 outputAmount) {\t\t\r\n\t\taddress swapFunctionRecipient = address(this);\r\n\t\tuint256 balanceBefore;\r\n\t\tuint256 swappedOutputTokens;\r\n\t\t\r\n\t\tif (useSidecar == true) { swapFunctionRecipient = _sidecarAddress; }\r\n\t\telse { balanceBefore = IERC20(outputToken).balanceOf(address(this)); }\r\n\r\n\t\t_checkAndApproveRouterForToken(inputToken, inputAmount);\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = inputToken;\r\n\t\tpath[1] = outputToken;\r\n\t\t_swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\t\t\tinputAmount,\r\n\t\t\t0,\r\n\t\t\tpath,\r\n\t\t\tswapFunctionRecipient,\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t\t\r\n\t\tif (useSidecar == true) { swappedOutputTokens = _sidecarContract.recoverErc20Tokens(outputToken); }\r\n\t\telse { \r\n\t\t\tuint256 balanceAfter = IERC20(outputToken).balanceOf(address(this));\r\n\t\t\tswappedOutputTokens = (balanceAfter - balanceBefore); \r\n\t\t}\r\n\r\n\t\treturn swappedOutputTokens; \r\n\t}\r\n\r\n\tfunction recoverTokens(address tokenCa) external onlyOwner {\r\n\t\trequire(tokenCa != address(this),\"Not allowed\");\r\n\t\tuint256 tokenBalance = IERC20(tokenCa).balanceOf(address(this));\r\n\t\tIERC20(tokenCa).transfer(msg.sender, tokenBalance);\r\n\t}\r\n\r\n\tfunction manualSwap() external onlyOwner { _processTaxTokens(); }\r\n\tfunction setExcluded(address wallet, bool exclude) external onlyOwner { \r\n\t\tstring memory notAllowedError = \"Not allowed\";\r\n\t\trequire(!_isLP[wallet], notAllowedError);\r\n\t\trequire(wallet != address(this), notAllowedError);\r\n\t\trequire(wallet != _sidecarAddress, notAllowedError);\r\n\t\trequire(wallet != _swapRouterAddress, notAllowedError);\r\n\t \t_excluded[wallet] = exclude; \r\n\t}\r\n\tfunction setThreshold(uint256 amountUSD) external onlyOwner {\r\n\t\trequire(amountUSD > 0, \"Threshold cannot be 0\");\r\n\t\t_thresholdUSDC = amountUSD;\r\n\t}\r\n\r\n\tfunction burn(uint256 amount) external {\r\n\t\trequire(_balances[msg.sender] >= amount, \"Low balance\");\r\n\t\t_balances[msg.sender] -= amount;\r\n\t\t_balances[address(0)] += amount;\r\n\t\temit Transfer(msg.sender, address(0), amount);\r\n\t}\r\n\tfunction setAdditionalLP(address lpAddress, bool isLiqPool) external onlyOwner {\r\n\t\tstring memory notAllowedError = \"Not allowed\";\r\n\t\trequire(!_excluded[lpAddress], notAllowedError);\r\n\t\trequire(lpAddress != _primaryLP, notAllowedError);\r\n\t\trequire(lpAddress != address(this), notAllowedError);\r\n\t\trequire(lpAddress != _sidecarAddress, notAllowedError);\r\n\t\trequire(lpAddress != _swapRouterAddress, notAllowedError);\r\n\t\t_isLP[lpAddress] = isLiqPool;\r\n\t}\r\n\tfunction isLP(address ca) external view returns (bool) { return _isLP[ca]; }\r\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}