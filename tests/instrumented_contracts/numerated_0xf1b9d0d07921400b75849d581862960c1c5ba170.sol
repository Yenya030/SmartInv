1 // SPDX-License-Identifier: GPL-3.0
2 
3 /*
4       ::::::::   ::::::::  ::::    :::  ::::::::   ::::::::  :::        ::::::::::          ::::    ::: :::::::::: ::::::::::: 
5     :+:    :+: :+:    :+: :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:                 :+:+:   :+: :+:            :+:      
6    +:+        +:+    +:+ :+:+:+  +:+ +:+        +:+    +:+ +:+        +:+                 :+:+:+  +:+ +:+            +:+       
7   +#+        +#+    +:+ +#+ +:+ +#+ +#++:++#++ +#+    +:+ +#+        +#++:++#            +#+ +:+ +#+ :#::+::#       +#+        
8  +#+        +#+    +#+ +#+  +#+#+#        +#+ +#+    +#+ +#+        +#+                 +#+  +#+#+# +#+            +#+         
9 #+#    #+# #+#    #+# #+#   #+#+# #+#    #+# #+#    #+# #+#        #+#                 #+#   #+#+# #+#            #+#          
10 ########   ########  ###    ####  ########   ########  ########## ##########          ###    #### ###            ###           
11 */
12 
13 pragma solidity ^0.8.0;
14 
15 /**
16  * @dev These functions deal with verification of Merkle Trees proofs.
17  *
18  * The proofs can be generated using the JavaScript library
19  * https://github.com/miguelmota/merkletreejs[merkletreejs].
20  * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
21  *
22  * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
23  */
24 library MerkleProof {
25     /**
26      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
27      * defined by `root`. For this, a `proof` must be provided, containing
28      * sibling hashes on the branch from the leaf to the root of the tree. Each
29      * pair of leaves and each pair of pre-images are assumed to be sorted.
30      */
31     function verify(
32         bytes32[] memory proof,
33         bytes32 root,
34         bytes32 leaf
35     ) internal pure returns (bool) {
36         return processProof(proof, leaf) == root;
37     }
38 
39     /**
40      * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up
41      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
42      * hash matches the root of the tree. When processing the proof, the pairs
43      * of leafs & pre-images are assumed to be sorted.
44      *
45      * _Available since v4.4._
46      */
47     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
48         bytes32 computedHash = leaf;
49         for (uint256 i = 0; i < proof.length; i++) {
50             bytes32 proofElement = proof[i];
51             if (computedHash <= proofElement) {
52                 // Hash(current computed hash + current element of the proof)
53                 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
54             } else {
55                 // Hash(current element of the proof + current computed hash)
56                 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
57             }
58         }
59         return computedHash;
60     }
61 }
62 
63 contract VRFRequestIDBase {
64   /**
65    * @notice returns the seed which is actually input to the VRF coordinator
66    *
67    * @dev To prevent repetition of VRF output due to repetition of the
68    * @dev user-supplied seed, that seed is combined in a hash with the
69    * @dev user-specific nonce, and the address of the consuming contract. The
70    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
71    * @dev the final seed, but the nonce does protect against repetition in
72    * @dev requests which are included in a single block.
73    *
74    * @param _userSeed VRF seed input provided by user
75    * @param _requester Address of the requesting contract
76    * @param _nonce User-specific nonce at the time of the request
77    */
78   function makeVRFInputSeed(
79     bytes32 _keyHash,
80     uint256 _userSeed,
81     address _requester,
82     uint256 _nonce
83   ) internal pure returns (uint256) {
84     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
85   }
86 
87   /**
88    * @notice Returns the id for this request
89    * @param _keyHash The serviceAgreement ID to be used for this request
90    * @param _vRFInputSeed The seed to be passed directly to the VRF
91    * @return The id for this request
92    *
93    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
94    * @dev contract, but the one generated by makeVRFInputSeed
95    */
96   function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
97     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
98   }
99 }
100 
101 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
102 
103 interface LinkTokenInterface {
104   function allowance(address owner, address spender) external view returns (uint256 remaining);
105 
106   function approve(address spender, uint256 value) external returns (bool success);
107 
108   function balanceOf(address owner) external view returns (uint256 balance);
109 
110   function decimals() external view returns (uint8 decimalPlaces);
111 
112   function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
113 
114   function increaseApproval(address spender, uint256 subtractedValue) external;
115 
116   function name() external view returns (string memory tokenName);
117 
118   function symbol() external view returns (string memory tokenSymbol);
119 
120   function totalSupply() external view returns (uint256 totalTokensIssued);
121 
122   function transfer(address to, uint256 value) external returns (bool success);
123 
124   function transferAndCall(
125     address to,
126     uint256 value,
127     bytes calldata data
128   ) external returns (bool success);
129 
130   function transferFrom(
131     address from,
132     address to,
133     uint256 value
134   ) external returns (bool success);
135 }
136 
137 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBase.sol
138 
139 
140 
141 /** ****************************************************************************
142  * @notice Interface for contracts using VRF randomness
143  * *****************************************************************************
144  * @dev PURPOSE
145  *
146  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
147  * @dev to Vera the verifier in such a way that Vera can be sure he's not
148  * @dev making his output up to suit himself. Reggie provides Vera a public key
149  * @dev to which he knows the secret key. Each time Vera provides a seed to
150  * @dev Reggie, he gives back a value which is computed completely
151  * @dev deterministically from the seed and the secret key.
152  *
153  * @dev Reggie provides a proof by which Vera can verify that the output was
154  * @dev correctly computed once Reggie tells it to her, but without that proof,
155  * @dev the output is indistinguishable to her from a uniform random sample
156  * @dev from the output space.
157  *
158  * @dev The purpose of this contract is to make it easy for unrelated contracts
159  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
160  * @dev simple access to a verifiable source of randomness.
161  * *****************************************************************************
162  * @dev USAGE
163  *
164  * @dev Calling contracts must inherit from VRFConsumerBase, and can
165  * @dev initialize VRFConsumerBase's attributes in their constructor as
166  * @dev shown:
167  *
168  * @dev   contract VRFConsumer {
169  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
170  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
171  * @dev         <initialization with other arguments goes here>
172  * @dev       }
173  * @dev   }
174  *
175  * @dev The oracle will have given you an ID for the VRF keypair they have
176  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
177  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
178  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
179  * @dev want to generate randomness from.
180  *
181  * @dev Once the VRFCoordinator has received and validated the oracle's response
182  * @dev to your request, it will call your contract's fulfillRandomness method.
183  *
184  * @dev The randomness argument to fulfillRandomness is the actual random value
185  * @dev generated from your seed.
186  *
187  * @dev The requestId argument is generated from the keyHash and the seed by
188  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
189  * @dev requests open, you can use the requestId to track which seed is
190  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
191  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
192  * @dev if your contract could have multiple requests in flight simultaneously.)
193  *
194  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
195  * @dev differ. (Which is critical to making unpredictable randomness! See the
196  * @dev next section.)
197  *
198  * *****************************************************************************
199  * @dev SECURITY CONSIDERATIONS
200  *
201  * @dev A method with the ability to call your fulfillRandomness method directly
202  * @dev could spoof a VRF response with any random value, so it's critical that
203  * @dev it cannot be directly called by anything other than this base contract
204  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
205  *
206  * @dev For your users to trust that your contract's random behavior is free
207  * @dev from malicious interference, it's best if you can write it so that all
208  * @dev behaviors implied by a VRF response are executed *during* your
209  * @dev fulfillRandomness method. If your contract must store the response (or
210  * @dev anything derived from it) and use it later, you must ensure that any
211  * @dev user-significant behavior which depends on that stored value cannot be
212  * @dev manipulated by a subsequent VRF request.
213  *
214  * @dev Similarly, both miners and the VRF oracle itself have some influence
215  * @dev over the order in which VRF responses appear on the blockchain, so if
216  * @dev your contract could have multiple VRF requests in flight simultaneously,
217  * @dev you must ensure that the order in which the VRF responses arrive cannot
218  * @dev be used to manipulate your contract's user-significant behavior.
219  *
220  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
221  * @dev block in which the request is made, user-provided seeds have no impact
222  * @dev on its economic security properties. They are only included for API
223  * @dev compatability with previous versions of this contract.
224  *
225  * @dev Since the block hash of the block which contains the requestRandomness
226  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
227  * @dev miner could, in principle, fork the blockchain to evict the block
228  * @dev containing the request, forcing the request to be included in a
229  * @dev different block with a different hash, and therefore a different input
230  * @dev to the VRF. However, such an attack would incur a substantial economic
231  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
232  * @dev until it calls responds to a request.
233  */
234 abstract contract VRFConsumerBase is VRFRequestIDBase {
235   /**
236    * @notice fulfillRandomness handles the VRF response. Your contract must
237    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
238    * @notice principles to keep in mind when implementing your fulfillRandomness
239    * @notice method.
240    *
241    * @dev VRFConsumerBase expects its subcontracts to have a method with this
242    * @dev signature, and will call it once it has verified the proof
243    * @dev associated with the randomness. (It is triggered via a call to
244    * @dev rawFulfillRandomness, below.)
245    *
246    * @param requestId The Id initially returned by requestRandomness
247    * @param randomness the VRF output
248    */
249   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
250 
251   /**
252    * @dev In order to keep backwards compatibility we have kept the user
253    * seed field around. We remove the use of it because given that the blockhash
254    * enters later, it overrides whatever randomness the used seed provides.
255    * Given that it adds no security, and can easily lead to misunderstandings,
256    * we have removed it from usage and can now provide a simpler API.
257    */
258   uint256 private constant USER_SEED_PLACEHOLDER = 0;
259 
260   /**
261    * @notice requestRandomness initiates a request for VRF output given _seed
262    *
263    * @dev The fulfillRandomness method receives the output, once it's provided
264    * @dev by the Oracle, and verified by the vrfCoordinator.
265    *
266    * @dev The _keyHash must already be registered with the VRFCoordinator, and
267    * @dev the _fee must exceed the fee specified during registration of the
268    * @dev _keyHash.
269    *
270    * @dev The _seed parameter is vestigial, and is kept only for API
271    * @dev compatibility with older versions. It can't *hurt* to mix in some of
272    * @dev your own randomness, here, but it's not necessary because the VRF
273    * @dev oracle will mix the hash of the block containing your request into the
274    * @dev VRF seed it ultimately uses.
275    *
276    * @param _keyHash ID of public key against which randomness is generated
277    * @param _fee The amount of LINK to send with the request
278    *
279    * @return requestId unique ID for this request
280    *
281    * @dev The returned requestId can be used to distinguish responses to
282    * @dev concurrent requests. It is passed as the first argument to
283    * @dev fulfillRandomness.
284    */
285   function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
286     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
287     // This is the seed passed to VRFCoordinator. The oracle will mix this with
288     // the hash of the block containing this request to obtain the seed/input
289     // which is finally passed to the VRF cryptographic machinery.
290     uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
291     // nonces[_keyHash] must stay in sync with
292     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
293     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
294     // This provides protection against the user repeating their input seed,
295     // which would result in a predictable/duplicate output, if multiple such
296     // requests appeared in the same block.
297     nonces[_keyHash] = nonces[_keyHash] + 1;
298     return makeRequestId(_keyHash, vRFSeed);
299   }
300 
301   LinkTokenInterface internal immutable LINK;
302   address private immutable vrfCoordinator;
303 
304   // Nonces for each VRF key from which randomness has been requested.
305   //
306   // Must stay in sync with VRFCoordinator[_keyHash][this]
307   mapping(bytes32 => uint256) /* keyHash */ /* nonce */
308     private nonces;
309 
310   /**
311    * @param _vrfCoordinator address of VRFCoordinator contract
312    * @param _link address of LINK token contract
313    *
314    * @dev https://docs.chain.link/docs/link-token-contracts
315    */
316   constructor(address _vrfCoordinator, address _link) {
317     vrfCoordinator = _vrfCoordinator;
318     LINK = LinkTokenInterface(_link);
319   }
320 
321   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
322   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
323   // the origin of the call
324   function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
325     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
326     fulfillRandomness(requestId, randomness);
327   }
328 }
329 
330 /**
331  * @dev Interface of the ERC165 standard, as defined in the
332  * https://eips.ethereum.org/EIPS/eip-165[EIP].
333  *
334  * Implementers can declare support of contract interfaces, which can then be
335  * queried by others ({ERC165Checker}).
336  *
337  * For an implementation, see {ERC165}.
338  */
339 interface IERC165 {
340     /**
341      * @dev Returns true if this contract implements the interface defined by
342      * `interfaceId`. See the corresponding
343      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
344      * to learn more about how these ids are created.
345      *
346      * This function call must use less than 30 000 gas.
347      */
348     function supportsInterface(bytes4 interfaceId) external view returns (bool);
349 }
350 
351 
352 /**
353  * @dev Required interface of an ERC721 compliant contract.
354  */
355 interface IERC721 is IERC165 {
356     /**
357      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
358      */
359     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
360 
361     /**
362      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
363      */
364     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
365 
366     /**
367      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
368      */
369     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
370 
371     /**
372      * @dev Returns the number of tokens in ``owner``'s account.
373      */
374     function balanceOf(address owner) external view returns (uint256 balance);
375 
376     /**
377      * @dev Returns the owner of the `tokenId` token.
378      *
379      * Requirements:
380      *
381      * - `tokenId` must exist.
382      */
383     function ownerOf(uint256 tokenId) external view returns (address owner);
384 
385     /**
386      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
387      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
388      *
389      * Requirements:
390      *
391      * - `from` cannot be the zero address.
392      * - `to` cannot be the zero address.
393      * - `tokenId` token must exist and be owned by `from`.
394      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
395      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
396      *
397      * Emits a {Transfer} event.
398      */
399     function safeTransferFrom(
400         address from,
401         address to,
402         uint256 tokenId
403     ) external;
404 
405     /**
406      * @dev Transfers `tokenId` token from `from` to `to`.
407      *
408      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
409      *
410      * Requirements:
411      *
412      * - `from` cannot be the zero address.
413      * - `to` cannot be the zero address.
414      * - `tokenId` token must be owned by `from`.
415      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
416      *
417      * Emits a {Transfer} event.
418      */
419     function transferFrom(
420         address from,
421         address to,
422         uint256 tokenId
423     ) external;
424 
425     /**
426      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
427      * The approval is cleared when the token is transferred.
428      *
429      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
430      *
431      * Requirements:
432      *
433      * - The caller must own the token or be an approved operator.
434      * - `tokenId` must exist.
435      *
436      * Emits an {Approval} event.
437      */
438     function approve(address to, uint256 tokenId) external;
439 
440     /**
441      * @dev Returns the account approved for `tokenId` token.
442      *
443      * Requirements:
444      *
445      * - `tokenId` must exist.
446      */
447     function getApproved(uint256 tokenId) external view returns (address operator);
448 
449     /**
450      * @dev Approve or remove `operator` as an operator for the caller.
451      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
452      *
453      * Requirements:
454      *
455      * - The `operator` cannot be the caller.
456      *
457      * Emits an {ApprovalForAll} event.
458      */
459     function setApprovalForAll(address operator, bool _approved) external;
460 
461     /**
462      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
463      *
464      * See {setApprovalForAll}
465      */
466     function isApprovedForAll(address owner, address operator) external view returns (bool);
467 
468     /**
469      * @dev Safely transfers `tokenId` token from `from` to `to`.
470      *
471      * Requirements:
472      *
473      * - `from` cannot be the zero address.
474      * - `to` cannot be the zero address.
475      * - `tokenId` token must exist and be owned by `from`.
476      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
477      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
478      *
479      * Emits a {Transfer} event.
480      */
481     function safeTransferFrom(
482         address from,
483         address to,
484         uint256 tokenId,
485         bytes calldata data
486     ) external;
487 }
488 
489 
490 
491 /**
492  * @dev String operations.
493  */
494 library Strings {
495     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
496 
497     /**
498      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
499      */
500     function toString(uint256 value) internal pure returns (string memory) {
501         // Inspired by OraclizeAPI's implementation - MIT licence
502         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
503 
504         if (value == 0) {
505             return "0";
506         }
507         uint256 temp = value;
508         uint256 digits;
509         while (temp != 0) {
510             digits++;
511             temp /= 10;
512         }
513         bytes memory buffer = new bytes(digits);
514         while (value != 0) {
515             digits -= 1;
516             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
517             value /= 10;
518         }
519         return string(buffer);
520     }
521 
522 
523     /**
524      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation. 
525      */
526     function toHexString(uint256 value) internal pure returns (string memory) {
527         if (value == 0) {
528             return "0x00";
529         }
530         uint256 temp = value;
531         uint256 length = 0;
532         while (temp != 0) {
533             length++;
534             temp >>= 8;
535         }
536         return toHexString(value, length);
537     }
538 
539     /**
540      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
541      */
542     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
543         bytes memory buffer = new bytes(2 * length + 2);
544         buffer[0] = "0";
545         buffer[1] = "x";
546         for (uint256 i = 2 * length + 1; i > 1; --i) {
547             buffer[i] = _HEX_SYMBOLS[value & 0xf];
548             value >>= 4;
549         }
550         require(value == 0, "Strings: hex length insufficient");
551         return string(buffer);
552     }
553 }
554 
555 
556 /*
557  * @dev Provides information about the current execution context, including the
558  * sender of the transaction and its data. While these are generally available
559  * via msg.sender and msg.data, they should not be accessed in such a direct
560  * manner, since when dealing with meta-transactions the account sending and
561  * paying for execution may not be the actual sender (as far as an application
562  * is concerned).
563  *
564  * This contract is only required for intermediate, library-like contracts.
565  */
566 abstract contract Context {
567     function _msgSender() internal view virtual returns (address) {
568         return msg.sender;
569     }
570 
571     function _msgData() internal view virtual returns (bytes calldata) {
572         return msg.data;
573     }
574 }
575 
576 
577 /**
578  * @dev Contract module which provides a basic access control mechanism, where
579  * there is an account (an owner) that can be granted exclusive access to
580  * specific functions.
581  *
582  * By default, the owner account will be the one that deploys the contract. This
583  * can later be changed with {transferOwnership}.
584  *
585  * This module is used through inheritance. It will make available the modifier
586  * `onlyOwner`, which can be applied to your functions to restrict their use to
587  * the owner.
588  */
589 abstract contract Ownable is Context {
590     address private _owner;
591 
592     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
593 
594     /**
595      * @dev Initializes the contract setting the deployer as the initial owner.
596      */
597     constructor() {
598         _setOwner(_msgSender());
599     }
600 
601     /**
602      * @dev Returns the address of the current owner.
603      */
604     function owner() public view virtual returns (address) {
605         return _owner;
606     }
607 
608     /**
609      * @dev Throws if called by any account other than the owner.
610      */
611     modifier onlyOwner() {
612         require(owner() == _msgSender(), "Ownable: caller is not the owner");
613         _;
614     }
615 
616     /**
617      * @dev Leaves the contract without owner. It will not be possible to call
618      * `onlyOwner` functions anymore. Can only be called by the current owner.
619      *
620      * NOTE: Renouncing ownership will leave the contract without an owner,
621      * thereby removing any functionality that is only available to the owner.
622      */
623     function renounceOwnership() public virtual onlyOwner {
624         _setOwner(address(0));
625     }
626 
627     /**
628      * @dev Transfers ownership of the contract to a new account (`newOwner`).
629      * Can only be called by the current owner.
630      */
631     function transferOwnership(address newOwner) public virtual onlyOwner {
632         require(newOwner != address(0), "Ownable: new owner is the zero address");
633         _setOwner(newOwner);
634     }
635 
636     function _setOwner(address newOwner) private {
637         address oldOwner = _owner;
638         _owner = newOwner;
639         emit OwnershipTransferred(oldOwner, newOwner);
640     }
641 }
642 
643 
644 /**
645  * @dev Contract module that helps prevent reentrant calls to a function.
646  *
647  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
648  * available, which can be applied to functions to make sure there are no nested
649  * (reentrant) calls to them.
650  *
651  * Note that because there is a single `nonReentrant` guard, functions marked as
652  * `nonReentrant` may not call one another. This can be worked around by making
653  * those functions `private`, and then adding `external` `nonReentrant` entry
654  * points to them.
655  *
656  * TIP: If you would like to learn more about reentrancy and alternative ways
657  * to protect against it, check out our blog post
658  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
659  */
660 abstract contract ReentrancyGuard {
661     // Booleans are more expensive than uint256 or any type that takes up a full
662     // word because each write operation emits an extra SLOAD to first read the
663     // slot's contents, replace the bits taken up by the boolean, and then write
664     // back. This is the compiler's defense against contract upgrades and
665     // pointer aliasing, and it cannot be disabled.
666 
667     // The values being non-zero value makes deployment a bit more expensive,
668     // but in exchange the refund on every call to nonReentrant will be lower in
669     // amount. Since refunds are capped to a percentage of the total
670     // transaction's gas, it is best to keep them low in cases like this one, to
671     // increase the likelihood of the full refund coming into effect.
672     uint256 private constant _NOT_ENTERED = 1;
673     uint256 private constant _ENTERED = 2;
674 
675     uint256 private _status;
676 
677     constructor() {
678         _status = _NOT_ENTERED;
679     }
680 
681     /**
682      * @dev Prevents a contract from calling itself, directly or indirectly.
683      * Calling a `nonReentrant` function from another `nonReentrant`
684      * function is not supported. It is possible to prevent this from happening
685      * by making the `nonReentrant` function external, and make it call a
686      * `private` function that does the actual work.
687      */
688     modifier nonReentrant() {
689         // On the first call to nonReentrant, _notEntered will be true
690         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
691 
692         // Any calls to nonReentrant after this point will fail
693         _status = _ENTERED;
694 
695         _;
696 
697         // By storing the original value once again, a refund is triggered (see
698         // https://eips.ethereum.org/EIPS/eip-2200)
699         _status = _NOT_ENTERED;
700     }
701 }
702 
703 
704 
705 /**
706  * @title ERC721 token receiver interface
707  * @dev Interface for any contract that wants to support safeTransfers
708  * from ERC721 asset contracts.
709  */
710 interface IERC721Receiver {
711     /**
712      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
713      * by `operator` from `from`, this function is called.
714      *
715      * It must return its Solidity selector to confirm the token transfer.
716      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
717      *
718      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
719      */
720     function onERC721Received(
721         address operator,
722         address from,
723         uint256 tokenId,
724         bytes calldata data
725     ) external returns (bytes4);
726 }
727 
728 
729 /**
730  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
731  * @dev See https://eips.ethereum.org/EIPS/eip-721
732  */
733 interface IERC721Metadata is IERC721 {
734     /**
735      * @dev Returns the token collection name.
736      */
737     function name() external view returns (string memory);
738 
739     /**
740      * @dev Returns the token collection symbol.
741      */
742     function symbol() external view returns (string memory);
743 
744     /**
745      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
746      */
747     function tokenURI(uint256 tokenId) external view returns (string memory);
748 }
749 
750 
751 /**
752  * @dev Collection of functions related to the address type
753  */
754 library Address {
755     /**
756      * @dev Returns true if `account` is a contract.
757      *
758      * [IMPORTANT]
759      * ====
760      * It is unsafe to assume that an address for which this function returns
761      * false is an externally-owned account (EOA) and not a contract.
762      *
763      * Among others, `isContract` will return false for the following
764      * types of addresses:
765      *
766      *  - an externally-owned account
767      *  - a contract in construction
768      *  - an address where a contract will be created
769      *  - an address where a contract lived, but was destroyed
770      * ====
771      */
772     function isContract(address account) internal view returns (bool) {
773         // This method relies on extcodesize, which returns 0 for contracts in
774         // construction, since the code is only stored at the end of the
775         // constructor execution.
776 
777         uint256 size;
778         assembly {
779             size := extcodesize(account)
780         }
781         return size > 0;
782     }
783 
784     /**
785      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
786      * `recipient`, forwarding all available gas and reverting on errors.
787      *
788      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
789      * of certain opcodes, possibly making contracts go over the 2300 gas limit
790      * imposed by `transfer`, making them unable to receive funds via
791      * `transfer`. {sendValue} removes this limitation.
792      *
793      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
794      *
795      * IMPORTANT: because control is transferred to `recipient`, care must be
796      * taken to not create reentrancy vulnerabilities. Consider using
797      * {ReentrancyGuard} or the
798      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
799      */
800     function sendValue(address payable recipient, uint256 amount) internal {
801         require(address(this).balance >= amount, "Address: insufficient balance");
802 
803         (bool success, ) = recipient.call{value: amount}("");
804         require(success, "Address: unable to send value, recipient may have reverted");
805     }
806 
807     /**
808      * @dev Performs a Solidity function call using a low level `call`. A
809      * plain `call` is an unsafe replacement for a function call: use this
810      * function instead.
811      *
812      * If `target` reverts with a revert reason, it is bubbled up by this
813      * function (like regular Solidity function calls).
814      *
815      * Returns the raw returned data. To convert to the expected return value,
816      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
817      *
818      * Requirements:
819      *
820      * - `target` must be a contract.
821      * - calling `target` with `data` must not revert.
822      *
823      * _Available since v3.1._
824      */
825     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
826         return functionCall(target, data, "Address: low-level call failed");
827     }
828 
829     /**
830      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
831      * `errorMessage` as a fallback revert reason when `target` reverts.
832      *
833      * _Available since v3.1._
834      */
835     function functionCall(
836         address target,
837         bytes memory data,
838         string memory errorMessage
839     ) internal returns (bytes memory) {
840         return functionCallWithValue(target, data, 0, errorMessage);
841     }
842 
843     /**
844      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
845      * but also transferring `value` wei to `target`.
846      *
847      * Requirements:
848      *
849      * - the calling contract must have an ETH balance of at least `value`.
850      * - the called Solidity function must be `payable`.
851      *
852      * _Available since v3.1._
853      */
854     function functionCallWithValue(
855         address target,
856         bytes memory data,
857         uint256 value
858     ) internal returns (bytes memory) {
859         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
860     }
861 
862     /**
863      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
864      * with `errorMessage` as a fallback revert reason when `target` reverts.
865      *
866      * _Available since v3.1._
867      */
868     function functionCallWithValue(
869         address target,
870         bytes memory data,
871         uint256 value,
872         string memory errorMessage
873     ) internal returns (bytes memory) {
874         require(address(this).balance >= value, "Address: insufficient balance for call");
875         require(isContract(target), "Address: call to non-contract");
876 
877         (bool success, bytes memory returndata) = target.call{value: value}(data);
878         return _verifyCallResult(success, returndata, errorMessage);
879     }
880 
881     /**
882      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
883      * but performing a static call.
884      *
885      * _Available since v3.3._
886      */
887     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
888         return functionStaticCall(target, data, "Address: low-level static call failed");
889     }
890 
891     /**
892      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
893      * but performing a static call.
894      *
895      * _Available since v3.3._
896      */
897     function functionStaticCall(
898         address target,
899         bytes memory data,
900         string memory errorMessage
901     ) internal view returns (bytes memory) {
902         require(isContract(target), "Address: static call to non-contract");
903 
904         (bool success, bytes memory returndata) = target.staticcall(data);
905         return _verifyCallResult(success, returndata, errorMessage);
906     }
907 
908     /**
909      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
910      * but performing a delegate call.
911      *
912      * _Available since v3.4._
913      */
914     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
915         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
916     }
917 
918     /**
919      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
920      * but performing a delegate call.
921      *
922      * _Available since v3.4._
923      */
924     function functionDelegateCall(
925         address target,
926         bytes memory data,
927         string memory errorMessage
928     ) internal returns (bytes memory) {
929         require(isContract(target), "Address: delegate call to non-contract");
930 
931         (bool success, bytes memory returndata) = target.delegatecall(data);
932         return _verifyCallResult(success, returndata, errorMessage);
933     }
934 
935     function _verifyCallResult(
936         bool success,
937         bytes memory returndata,
938         string memory errorMessage
939     ) private pure returns (bytes memory) {
940         if (success) {
941             return returndata;
942         } else {
943             // Look for revert reason and bubble it up if present
944             if (returndata.length > 0) {
945                 // The easiest way to bubble the revert reason is using memory via assembly
946 
947                 assembly {
948                     let returndata_size := mload(returndata)
949                     revert(add(32, returndata), returndata_size)
950                 }
951             } else {
952                 revert(errorMessage);
953             }
954         }
955     }
956 }
957 
958 
959 
960 
961 /**
962  * @dev Implementation of the {IERC165} interface.
963  *
964  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
965  * for the additional interface id that will be supported. For example:
966  *
967  * ```solidity
968  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
969  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
970  * }
971  * ```
972  *
973  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
974  */
975 abstract contract ERC165 is IERC165 {
976     /**
977      * @dev See {IERC165-supportsInterface}.
978      */
979     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
980         return interfaceId == type(IERC165).interfaceId;
981     }
982 }
983 
984 
985 /**
986  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
987  * the Metadata extension, but not including the Enumerable extension, which is available separately as
988  * {ERC721Enumerable}.
989  */
990 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
991     using Address for address;
992     using Strings for uint256;
993 
994     // Token name
995     string private _name;
996 
997     // Token symbol
998     string private _symbol;
999 
1000     // Mapping from token ID to owner address
1001     mapping(uint256 => address) private _owners;
1002 
1003     // Mapping owner address to token count
1004     mapping(address => uint256) private _balances;
1005 
1006     // Mapping from token ID to approved address
1007     mapping(uint256 => address) private _tokenApprovals;
1008 
1009     // Mapping from owner to operator approvals
1010     mapping(address => mapping(address => bool)) private _operatorApprovals;
1011 
1012     /**
1013      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1014      */
1015     constructor(string memory name_, string memory symbol_) {
1016         _name = name_;
1017         _symbol = symbol_;
1018     }
1019 
1020     /**
1021      * @dev See {IERC165-supportsInterface}.
1022      */
1023     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1024         return
1025             interfaceId == type(IERC721).interfaceId ||
1026             interfaceId == type(IERC721Metadata).interfaceId ||
1027             super.supportsInterface(interfaceId);
1028     }
1029 
1030     /**
1031      * @dev See {IERC721-balanceOf}.
1032      */
1033     function balanceOf(address owner) public view virtual override returns (uint256) {
1034         require(owner != address(0), "ERC721: balance query for the zero address");
1035         return _balances[owner];
1036     }
1037 
1038     /**
1039      * @dev See {IERC721-ownerOf}.
1040      */
1041     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1042         address owner = _owners[tokenId];
1043         require(owner != address(0), "ERC721: owner query for nonexistent token");
1044         return owner;
1045     }
1046 
1047     /**
1048      * @dev See {IERC721Metadata-name}.
1049      */
1050     function name() public view virtual override returns (string memory) {
1051         return _name;
1052     }
1053 
1054     /**
1055      * @dev See {IERC721Metadata-symbol}.
1056      */
1057     function symbol() public view virtual override returns (string memory) {
1058         return _symbol;
1059     }
1060 
1061     /**
1062      * @dev See {IERC721Metadata-tokenURI}.
1063      */
1064     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1065         require(_exists(tokenId), "Nonexistent token");
1066 
1067         string memory baseURI = _baseURI();
1068         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1069     }
1070 
1071     /**
1072      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1073      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1074      * by default, can be overriden in child contracts.
1075      */
1076     function _baseURI() internal view virtual returns (string memory) {
1077         return "";
1078     }
1079 
1080     /**
1081      * @dev See {IERC721-approve}.
1082      */
1083     function approve(address to, uint256 tokenId) public virtual override {
1084         address owner = ERC721.ownerOf(tokenId);
1085         require(to != owner, "ERC721: approval to current owner");
1086 
1087         require(
1088             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1089             "ERC721: approve caller is not owner nor approved for all"
1090         );
1091 
1092         _approve(to, tokenId);
1093     }
1094 
1095     /**
1096      * @dev See {IERC721-getApproved}.
1097      */
1098     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1099         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1100 
1101         return _tokenApprovals[tokenId];
1102     }
1103 
1104     /**
1105      * @dev See {IERC721-setApprovalForAll}.
1106      */
1107     function setApprovalForAll(address operator, bool approved) public virtual override {
1108         require(operator != _msgSender(), "ERC721: approve to caller");
1109 
1110         _operatorApprovals[_msgSender()][operator] = approved;
1111         emit ApprovalForAll(_msgSender(), operator, approved);
1112     }
1113 
1114     /**
1115      * @dev See {IERC721-isApprovedForAll}.
1116      */
1117     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1118         return _operatorApprovals[owner][operator];
1119     }
1120 
1121     /**
1122      * @dev See {IERC721-transferFrom}.
1123      */
1124     function transferFrom(
1125         address from,
1126         address to,
1127         uint256 tokenId
1128     ) public virtual override {
1129         //solhint-disable-next-line max-line-length
1130         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1131 
1132         _transfer(from, to, tokenId);
1133     }
1134 
1135     /**
1136      * @dev See {IERC721-safeTransferFrom}.
1137      */
1138     function safeTransferFrom(
1139         address from,
1140         address to,
1141         uint256 tokenId
1142     ) public virtual override {
1143         safeTransferFrom(from, to, tokenId, "");
1144     }
1145 
1146     /**
1147      * @dev See {IERC721-safeTransferFrom}.
1148      */
1149     function safeTransferFrom(
1150         address from,
1151         address to,
1152         uint256 tokenId,
1153         bytes memory _data
1154     ) public virtual override {
1155         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1156         _safeTransfer(from, to, tokenId, _data);
1157     }
1158 
1159     /**
1160      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1161      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1162      *
1163      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1164      *
1165      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1166      * implement alternative mechanisms to perform token transfer, such as signature-based.
1167      *
1168      * Requirements:
1169      *
1170      * - `from` cannot be the zero address.
1171      * - `to` cannot be the zero address.
1172      * - `tokenId` token must exist and be owned by `from`.
1173      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1174      *
1175      * Emits a {Transfer} event.
1176      */
1177     function _safeTransfer(
1178         address from,
1179         address to,
1180         uint256 tokenId,
1181         bytes memory _data
1182     ) internal virtual {
1183         _transfer(from, to, tokenId);
1184         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1185     }
1186 
1187     /**
1188      * @dev Returns whether `tokenId` exists.
1189      *
1190      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1191      *
1192      * Tokens start existing when they are minted (`_mint`),
1193      * and stop existing when they are burned (`_burn`).
1194      */
1195     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1196         return _owners[tokenId] != address(0);
1197     }
1198 
1199     /**
1200      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1201      *
1202      * Requirements:
1203      *
1204      * - `tokenId` must exist.
1205      */
1206     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1207         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1208         address owner = ERC721.ownerOf(tokenId);
1209         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1210     }
1211 
1212     /**
1213      * @dev Safely mints `tokenId` and transfers it to `to`.
1214      *
1215      * Requirements:
1216      *
1217      * - `tokenId` must not exist.
1218      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1219      *
1220      * Emits a {Transfer} event.
1221      */
1222     function _safeMint(address to, uint256 tokenId) internal virtual {
1223         _safeMint(to, tokenId, "");
1224     }
1225 
1226     /**
1227      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1228      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1229      */
1230     function _safeMint(
1231         address to,
1232         uint256 tokenId,
1233         bytes memory _data
1234     ) internal virtual {
1235         _mint(to, tokenId);
1236         require(
1237             _checkOnERC721Received(address(0), to, tokenId, _data),
1238             "ERC721: transfer to non ERC721Receiver implementer"
1239         );
1240     }
1241 
1242     /**
1243      * @dev Mints `tokenId` and transfers it to `to`.
1244      *
1245      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1246      *
1247      * Requirements:
1248      *
1249      * - `tokenId` must not exist.
1250      * - `to` cannot be the zero address.
1251      *
1252      * Emits a {Transfer} event.
1253      */
1254     function _mint(address to, uint256 tokenId) internal virtual {
1255         require(to != address(0), "ERC721: mint to the zero address");
1256         require(!_exists(tokenId), "ERC721: token already minted");
1257 
1258         _beforeTokenTransfer(address(0), to, tokenId);
1259 
1260         _balances[to] += 1;
1261         _owners[tokenId] = to;
1262 
1263         emit Transfer(address(0), to, tokenId);
1264     }
1265 
1266     /**
1267      * @dev Destroys `tokenId`.
1268      * The approval is cleared when the token is burned.
1269      *
1270      * Requirements:
1271      *
1272      * - `tokenId` must exist.
1273      *
1274      * Emits a {Transfer} event.
1275      */
1276     function _burn(uint256 tokenId) internal virtual {
1277         address owner = ERC721.ownerOf(tokenId);
1278 
1279         _beforeTokenTransfer(owner, address(0), tokenId);
1280 
1281         // Clear approvals
1282         _approve(address(0), tokenId);
1283 
1284         _balances[owner] -= 1;
1285         delete _owners[tokenId];
1286 
1287         emit Transfer(owner, address(0), tokenId);
1288     }
1289 
1290     /**
1291      * @dev Transfers `tokenId` from `from` to `to`.
1292      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1293      *
1294      * Requirements:
1295      *
1296      * - `to` cannot be the zero address.
1297      * - `tokenId` token must be owned by `from`.
1298      *
1299      * Emits a {Transfer} event.
1300      */
1301     function _transfer(
1302         address from,
1303         address to,
1304         uint256 tokenId
1305     ) internal virtual {
1306         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1307         require(to != address(0), "ERC721: transfer to the zero address");
1308 
1309         _beforeTokenTransfer(from, to, tokenId);
1310 
1311         // Clear approvals from the previous owner
1312         _approve(address(0), tokenId);
1313 
1314         _balances[from] -= 1;
1315         _balances[to] += 1;
1316         _owners[tokenId] = to;
1317 
1318         emit Transfer(from, to, tokenId);
1319     }
1320 
1321     /**
1322      * @dev Approve `to` to operate on `tokenId`
1323      *
1324      * Emits a {Approval} event.
1325      */
1326     function _approve(address to, uint256 tokenId) internal virtual {
1327         _tokenApprovals[tokenId] = to;
1328         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1329     }
1330 
1331     /**
1332      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1333      * The call is not executed if the target address is not a contract.
1334      *
1335      * @param from address representing the previous owner of the given token ID
1336      * @param to target address that will receive the tokens
1337      * @param tokenId uint256 ID of the token to be transferred
1338      * @param _data bytes optional data to send along with the call
1339      * @return bool whether the call correctly returned the expected magic value
1340      */
1341     function _checkOnERC721Received(
1342         address from,
1343         address to,
1344         uint256 tokenId,
1345         bytes memory _data
1346     ) private returns (bool) {
1347         if (to.isContract()) {
1348             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1349                 return retval == IERC721Receiver(to).onERC721Received.selector;
1350             } catch (bytes memory reason) {
1351                 if (reason.length == 0) {
1352                     revert("ERC721: transfer to non ERC721Receiver implementer");
1353                 } else {
1354                     assembly {
1355                         revert(add(32, reason), mload(reason))
1356                     }
1357                 }
1358             }
1359         } else {
1360             return true;
1361         }
1362     }
1363 
1364     /**
1365      * @dev Hook that is called before any token transfer. This includes minting
1366      * and burning.
1367      *
1368      * Calling conditions:
1369      *
1370      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1371      * transferred to `to`.
1372      * - When `from` is zero, `tokenId` will be minted for `to`.
1373      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1374      * - `from` and `to` are never both zero.
1375      *
1376      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1377      */
1378     function _beforeTokenTransfer(
1379         address from,
1380         address to,
1381         uint256 tokenId
1382     ) internal virtual {}
1383 }
1384 
1385 
1386 
1387 /**
1388  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1389  * @dev See https://eips.ethereum.org/EIPS/eip-721
1390  */
1391 interface IERC721Enumerable is IERC721 {
1392     /**
1393      * @dev Returns the total amount of tokens stored by the contract.
1394      */
1395     function totalSupply() external view returns (uint256);
1396 
1397     /**
1398      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1399      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1400      */
1401     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1402 
1403     /**
1404      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1405      * Use along with {totalSupply} to enumerate all tokens.
1406      */
1407     function tokenByIndex(uint256 index) external view returns (uint256);
1408 }
1409 
1410 
1411 /**
1412  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1413  * enumerability of all the token ids in the contract as well as all token ids owned by each
1414  * account.
1415  */
1416 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1417     // Mapping from owner to list of owned token IDs
1418     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1419 
1420     // Mapping from token ID to index of the owner tokens list
1421     mapping(uint256 => uint256) private _ownedTokensIndex;
1422 
1423     // Array with all token ids, used for enumeration
1424     uint256[] private _allTokens;
1425 
1426     // Mapping from token id to position in the allTokens array
1427     mapping(uint256 => uint256) private _allTokensIndex;
1428 
1429     /**
1430      * @dev See {IERC165-supportsInterface}.
1431      */
1432     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1433         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1434     }
1435 
1436     /**
1437      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1438      */
1439     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1440         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1441         return _ownedTokens[owner][index];
1442     }
1443 
1444     /**
1445      * @dev See {IERC721Enumerable-totalSupply}.
1446      */
1447     function totalSupply() public view virtual override returns (uint256) {
1448         return _allTokens.length;
1449     }
1450 
1451     /**
1452      * @dev See {IERC721Enumerable-tokenByIndex}.
1453      */
1454     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1455         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1456         return _allTokens[index];
1457     }
1458 
1459     /**
1460      * @dev Hook that is called before any token transfer. This includes minting
1461      * and burning.
1462      *
1463      * Calling conditions:
1464      *
1465      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1466      * transferred to `to`.
1467      * - When `from` is zero, `tokenId` will be minted for `to`.
1468      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1469      * - `from` cannot be the zero address.
1470      * - `to` cannot be the zero address.
1471      *
1472      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1473      */
1474     function _beforeTokenTransfer(
1475         address from,
1476         address to,
1477         uint256 tokenId
1478     ) internal virtual override {
1479         super._beforeTokenTransfer(from, to, tokenId);
1480 
1481         if (from == address(0)) {
1482             _addTokenToAllTokensEnumeration(tokenId);
1483         } else if (from != to) {
1484             _removeTokenFromOwnerEnumeration(from, tokenId);
1485         }
1486         if (to == address(0)) {
1487             _removeTokenFromAllTokensEnumeration(tokenId);
1488         } else if (to != from) {
1489             _addTokenToOwnerEnumeration(to, tokenId);
1490         }
1491     }
1492 
1493     /**
1494      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1495      * @param to address representing the new owner of the given token ID
1496      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1497      */
1498     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1499         uint256 length = ERC721.balanceOf(to);
1500         _ownedTokens[to][length] = tokenId;
1501         _ownedTokensIndex[tokenId] = length;
1502     }
1503 
1504     /**
1505      * @dev Private function to add a token to this extension's token tracking data structures.
1506      * @param tokenId uint256 ID of the token to be added to the tokens list
1507      */
1508     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1509         _allTokensIndex[tokenId] = _allTokens.length;
1510         _allTokens.push(tokenId);
1511     }
1512 
1513     /**
1514      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1515      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1516      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1517      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1518      * @param from address representing the previous owner of the given token ID
1519      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1520      */
1521     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1522         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1523         // then delete the last slot (swap and pop).
1524 
1525         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1526         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1527 
1528         // When the token to delete is the last token, the swap operation is unnecessary
1529         if (tokenIndex != lastTokenIndex) {
1530             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1531 
1532             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1533             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1534         }
1535 
1536         // This also deletes the contents at the last position of the array
1537         delete _ownedTokensIndex[tokenId];
1538         delete _ownedTokens[from][lastTokenIndex];
1539     }
1540 
1541     /**
1542      * @dev Private function to remove a token from this extension's token tracking data structures.
1543      * This has O(1) time complexity, but alters the order of the _allTokens array.
1544      * @param tokenId uint256 ID of the token to be removed from the tokens list
1545      */
1546     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1547         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1548         // then delete the last slot (swap and pop).
1549 
1550         uint256 lastTokenIndex = _allTokens.length - 1;
1551         uint256 tokenIndex = _allTokensIndex[tokenId];
1552 
1553         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1554         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1555         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1556         uint256 lastTokenId = _allTokens[lastTokenIndex];
1557 
1558         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1559         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1560 
1561         // This also deletes the contents at the last position of the array
1562         delete _allTokensIndex[tokenId];
1563         _allTokens.pop();
1564     }
1565 }
1566 
1567 abstract contract SourceData {
1568 	function getRarity(uint256 token_id) public view virtual returns(uint8);
1569 	function getNumberOfItems(uint256 token_id) public view virtual returns(uint8);
1570 	function getCreditsMultiplier(uint256 token_id) public view virtual returns(uint256);
1571 	function getCreditsAmount(uint256 token_id) public view virtual returns(uint256);
1572 	function getFirstItemRarity(uint256 token_id) public view virtual returns(uint256);
1573 	function getSecondItemRarity(uint256 token_id) public view virtual returns(uint256);
1574 	function getFirstItemClass(uint256 token_id) public view virtual returns(uint256);
1575 }
1576 
1577 contract ConsoleNFT_Vault is ERC721Enumerable, ReentrancyGuard, Ownable, VRFConsumerBase {
1578 	
1579 	address dataContract;
1580 
1581     // Mapping for wallet addresses that have previously minted
1582     mapping(address => uint256) private _whitelistMinters;
1583 
1584 	string internal baseTokenURI;
1585 	string internal baseTokenURI_extension;
1586 	
1587 	uint public constant maxTokens = 500;
1588     uint public total = 0;
1589 	uint mintCost = 0.05 ether;
1590 	
1591 	bool whitelistActive;
1592 	bool sysAdminMinted;
1593 	bool error404Minted;
1594 	bool code200Minted;
1595 	bool giveawaysMinted;
1596 	
1597 	address error404Address;
1598 	address code200Address;
1599 	address giveawaysAddress;
1600 	
1601 	bytes32 _rootHash;
1602 	
1603 	string[] private rarity = [
1604         "Legendary",
1605         "Epic",
1606         "Rare",
1607         "Uncommon",
1608         "Common"
1609     ];
1610 	
1611 	string[] private numberOfItemsInside = [
1612         "6",
1613         "5",
1614         "4",
1615         "3",
1616         "2"
1617     ];
1618 	
1619 	string[] private creditsMultiplier = [
1620         "Ultra",
1621         "Very high",
1622         "High",
1623         "Medium",
1624         "Low"
1625     ];
1626 	
1627 	string[] private creditsAmount = [
1628         "Ultra",
1629         "Very high",
1630         "High",
1631         "Medium",
1632         "Low"
1633     ];
1634 	
1635 	string[] private firstItemRarity = [
1636         "Legendary",
1637         "Epic",
1638         "Rare",
1639         "Uncommon",
1640         "Common"
1641     ];
1642 	
1643 	string[] private secondItemRarity = [
1644         "Legendary",
1645         "Epic",
1646         "Rare",
1647         "Uncommon",
1648         "Common"
1649     ];
1650 	
1651 	string[] private firstItemClass = [
1652         "Computer",
1653         "Weapon",
1654         "Keylogger",
1655         "Rainbow tables",
1656         "Packet sniffer",
1657         "Smartphone",
1658         "De-auth device",
1659         "NFC device",
1660         "RFID blocker",
1661         "Drone",
1662         "Screen crab",
1663         "Programmable chip",
1664         "Lockpick",
1665         "Land",
1666         "Armor",
1667         "Clothing",
1668         "CD device",
1669         "USB device",
1670         "Floppy disc",
1671         "- None -"
1672     ];
1673 
1674 	
1675 	function getRarity(uint256 tokenId) public view returns (string memory) {
1676         require(_exists(tokenId), "Nonexistent token");
1677 		
1678         string memory output;
1679 		
1680 		SourceData source_data = SourceData(dataContract);
1681 		
1682         output = rarity[source_data.getRarity(tokenId)];
1683 		
1684         return output;
1685     }
1686 	
1687 	function getNumberOfItemsInside(uint256 tokenId) public view returns (string memory) {
1688         require(_exists(tokenId), "Nonexistent token");
1689 		
1690         string memory output;
1691 		
1692 		SourceData source_data = SourceData(dataContract);
1693 		
1694         output = numberOfItemsInside[source_data.getNumberOfItems(tokenId)];
1695 		
1696         return output;
1697     }
1698 	
1699 	function getCreditsMultiplier(uint256 tokenId) public view returns (string memory) {
1700         require(_exists(tokenId), "Nonexistent token");
1701 		
1702         string memory output;
1703 		
1704 		SourceData source_data = SourceData(dataContract);
1705 		
1706         output = creditsMultiplier[source_data.getCreditsMultiplier(tokenId)];
1707 		
1708         return output;
1709     }
1710 	
1711 	function getCreditsAmount(uint256 tokenId) public view returns (string memory) {
1712         require(_exists(tokenId), "Nonexistent token");
1713 		
1714         string memory output;
1715 		
1716 		SourceData source_data = SourceData(dataContract);
1717 		
1718         output = creditsAmount[source_data.getCreditsAmount(tokenId)];
1719 		
1720         return output;
1721     }
1722 	
1723 	function getFirstItemRarity(uint256 tokenId) public view returns (string memory) {
1724         require(_exists(tokenId), "Nonexistent token");
1725 		
1726         string memory output;
1727 		
1728 		SourceData source_data = SourceData(dataContract);
1729 		
1730         output = firstItemRarity[source_data.getFirstItemRarity(tokenId)];
1731 		
1732         return output;
1733     }
1734 	
1735 	function getSecondItemRarity(uint256 tokenId) public view returns (string memory) {
1736         require(_exists(tokenId), "Nonexistent token");
1737 		
1738         string memory output;
1739 		
1740 		SourceData source_data = SourceData(dataContract);
1741 		
1742         output = secondItemRarity[source_data.getSecondItemRarity(tokenId)];
1743 		
1744         return output;
1745     }
1746 	
1747 	function getFirstItemClass(uint256 tokenId) public view returns (string memory) {
1748         require(_exists(tokenId), "Nonexistent token");
1749 		
1750         string memory output;
1751 		
1752 		SourceData source_data = SourceData(dataContract);
1753 		
1754         output = firstItemClass[source_data.getFirstItemClass(tokenId)];
1755 		
1756         return output;
1757     }
1758 		
1759 	// Setters
1760 	function setSourceData(address _dataContract) external onlyOwner {
1761         dataContract = _dataContract;
1762     }
1763 	
1764 	function setBaseTokenURI(string memory _uri) external onlyOwner {
1765         baseTokenURI = _uri;
1766     }
1767 	
1768 	function setBaseTokenURI_extension(string memory _ext) external onlyOwner {
1769         baseTokenURI_extension = _ext;
1770     }
1771 	
1772 	function tokenURI(uint tokenId_) public view override returns (string memory) {
1773         require(_exists(tokenId_), "Query for non-existent token!");
1774         return string(abi.encodePacked(baseTokenURI, Strings.toString(tokenId_), baseTokenURI_extension));
1775     }
1776 	
1777 	function setError404Address(address _setAddress) external onlyOwner {
1778         error404Address = _setAddress;
1779     }
1780 	
1781 	function setCode200Address(address _setAddress) external onlyOwner {
1782         code200Address = _setAddress;
1783     }
1784 	
1785 	function setGiveawaysAddress(address _setAddress) external onlyOwner {
1786         giveawaysAddress = _setAddress;
1787     }
1788 	
1789 	function setRootHash(bytes32 rootHash) external onlyOwner {
1790         _rootHash = rootHash;
1791     }
1792 	
1793 	function setWhitelistState() external onlyOwner
1794     {
1795         whitelistActive = !whitelistActive;
1796     }
1797 	
1798 	// Claim
1799 	function sysAdminClaim() public onlyOwner nonReentrant {
1800 		require(sysAdminMinted == false, "Already minted!");
1801 		
1802 		sysAdminMinted = true;
1803 		uint tokenId = getVRFRandomIndex();
1804         total++;
1805         _safeMint(owner(), tokenId);
1806     }
1807 	
1808 	function error404Claim() public nonReentrant {
1809 		require(msg.sender == error404Address, "Not Error 404");
1810 		require(error404Minted == false, "Already minted!");
1811 		
1812 		error404Minted = true;
1813 		uint tokenId = getVRFRandomIndex();
1814         total++;
1815         _safeMint(msg.sender, tokenId);
1816     }
1817 	
1818 	function code200Claim() public nonReentrant {
1819 		require(msg.sender == code200Address, "Not Code 200");
1820 		require(code200Minted == false, "Already minted!");
1821 		
1822 		code200Minted = true;
1823 		uint tokenId = getVRFRandomIndex();
1824         total++;
1825         _safeMint(msg.sender, tokenId);
1826     }
1827 	
1828 	function giveawaysClaim() public nonReentrant {
1829 		// only 2, we can hardcode
1830 		require(msg.sender == giveawaysAddress, "Not Giveaways wallet");
1831 		require(giveawaysMinted == false, "Already minted!");
1832 		
1833 		giveawaysMinted = true;
1834 		
1835 		uint tokenId = getVRFRandomIndex();
1836         total++;
1837 		_safeMint(msg.sender, tokenId);
1838 		
1839 		uint tokenId_second = getVRFRandomIndex();
1840         total++;
1841         _safeMint(msg.sender, tokenId_second);
1842     }
1843 	
1844 	function whitelistClaim(bytes32[] memory proof) public nonReentrant payable {
1845         require(whitelistActive, "The whitelist is not active yet");
1846         require(total < maxTokens, "All tokens have been already minted");
1847 		require(msg.value >= mintCost, "Incorrect mint cost value");
1848 		
1849 		// Merkle tree validation
1850 		bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
1851 		require(MerkleProof.verify(proof, _rootHash, leaf), "Invalid proof");
1852 		
1853         require(_whitelistMinters[_msgSender()] < 1, "You've already minted");
1854 		
1855 		uint tokenId = getVRFRandomIndex();
1856         total++;
1857 
1858         _safeMint(_msgSender(), tokenId);
1859 
1860         //Set the _whitelistMinters value to tokenId for this address as it has minted
1861         _whitelistMinters[_msgSender()] = tokenId;
1862     }
1863 	
1864     constructor() ERC721("Console NFT Vaults", "Cnsl-NFT-V") VRFConsumerBase(
1865         0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,
1866         0x514910771AF9Ca656af840dff83E8264EcF986CA
1867     )
1868 	Ownable() {
1869 		keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;
1870         fee = 2 * (10**18);
1871 		
1872 		_rootHash = 0x944df87eb207e113ec142134130993ec225e847b9341eff16eb0c99ed8eb620a;
1873 		
1874 		error404Address = 0x24Db9e45f6aC29175030A083B985C184A02c2d64;
1875 		code200Address = 0x1C0d3B190B18b4452BD4d0928D7f425eA9A0B3F9;
1876 		giveawaysAddress = 0x7e95c71bDF0E0526eA534Fb5191ceD999190c117;
1877     }
1878 	
1879 
1880 	////////////////////////// VRF /////////////////////////////
1881 	
1882     bytes32 internal keyHash;
1883     uint internal fee;
1884     uint internal randomResult;
1885     
1886     // VRF Functions
1887     function getRandomNumber() public onlyOwner returns (bytes32 requestId) {
1888         require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK!");
1889         return requestRandomness(keyHash, fee);
1890     }
1891     function fulfillRandomness(bytes32 requestId, uint randomness) internal override {
1892         randomResult = randomness;
1893     }
1894     function getRandomResult() public view onlyOwner returns (uint) {
1895         return randomResult;
1896     }
1897 
1898     // >>> Now, the VRF is stored in [uint internal randomResult]
1899     ////////////////////////// VRF /////////////////////////////
1900 
1901     /////////////////////// Token ID Generator ////////////////////////
1902     // ** Thanks LarvaLabs for this big brain method. **             //
1903     // This function was orginally written by 0xInuarashi            //
1904     // and modified by SysAdmin to exclude Token ID,                 //
1905     // now including the usage of generated input from VRF.          //
1906     ///////////////////////////////////////////////////////////////////
1907 
1908     uint[maxTokens] internal indices;
1909     uint32 internal nonce;
1910 
1911     function getVRFRandomIndex() internal returns (uint) {
1912         require(randomResult != 0, "VRF Random Result has not been set!");
1913         uint _tokensRemaining = maxTokens - total; // require that this calculation is possible from all caller functions
1914         uint _maxIndex = _tokensRemaining == 0 ? 0 : _tokensRemaining - 1; // shorthand if for safety
1915         uint _rand = uint(keccak256(abi.encodePacked(randomResult, nonce, msg.sender, block.difficulty, block.timestamp))) % _tokensRemaining;
1916     
1917         uint _output = 0;
1918 
1919         _output = indices[_rand] != 0 ? indices[_rand] :_rand;
1920         indices[_rand] = indices[_maxIndex] == 0 ? _maxIndex : indices[_maxIndex];
1921 
1922         uint32 _nonceAdd = uint32(uint256(keccak256(abi.encodePacked(randomResult, nonce, msg.sender, block.difficulty, block.timestamp)))) % 10;
1923         nonce += _nonceAdd; 
1924 
1925         return _output;
1926     }
1927 
1928     /////////////////////// Token ID Generator ////////////////////////
1929 	
1930 	function toString(uint256 value) internal pure returns (string memory) {
1931     // Inspired by OraclizeAPI's implementation - MIT license
1932     // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
1933 
1934         if (value == 0) {
1935             return "0";
1936         }
1937         uint256 temp = value;
1938         uint256 digits;
1939         while (temp != 0) {
1940             digits++;
1941             temp /= 10;
1942         }
1943         bytes memory buffer = new bytes(digits);
1944         while (value != 0) {
1945             digits -= 1;
1946             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
1947             value /= 10;
1948         }
1949         return string(buffer);
1950     }
1951 	
1952 	// Withdraw Ether
1953     function withdrawEther() public onlyOwner {
1954         payable(msg.sender).transfer(address(this).balance); 
1955     }
1956 
1957 }