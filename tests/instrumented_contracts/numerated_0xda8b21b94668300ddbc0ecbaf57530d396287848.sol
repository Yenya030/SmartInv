1 pragma solidity ^0.5.0;
2 
3 /// @title localcoinswap.com
4 /// @author localcoinswap.com
5 contract LocalCoinSwapEthereumEscrow {
6     /***********************
7     +   Global settings   +
8     ***********************/
9 
10     // Address of the arbitrator (currently always localcoinswap staff)
11     address public arbitrator;
12     // Address of the owner (who can withdraw collected fees)
13     address public owner;
14     // Address of the relayer (who is allowed to forward signed instructions from parties)
15     address public relayer;
16     uint32 public requestCancellationMinimumTime = 2 hours;
17     // Cumulative balance of collected fees
18     uint256 public feesAvailableForWithdraw;
19 
20     /***********************
21     +  Instruction types  +
22     ***********************/
23 
24     // Called when the buyer marks payment as sent. Locks funds in escrow
25     uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;
26     // Buyer cancelling
27     uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;
28     // Seller cancelling
29     uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;
30     // Seller requesting to cancel. Begins a window for buyer to object
31     uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;
32     // Seller releasing funds to the buyer
33     uint8 constant INSTRUCTION_RELEASE = 0x05;
34     // Either party permitting the arbitrator to resolve a dispute
35     uint8 constant INSTRUCTION_RESOLVE = 0x06;
36 
37 
38     /***********************
39     +       Events        +
40     ***********************/
41 
42     event Created(bytes32 indexed _tradeHash);
43     event SellerCancelDisabled(bytes32 indexed _tradeHash);
44     event SellerRequestedCancel(bytes32 indexed _tradeHash);
45     event CancelledBySeller(bytes32 indexed _tradeHash);
46     event CancelledByBuyer(bytes32 indexed _tradeHash);
47     event Released(bytes32 indexed _tradeHash);
48     event DisputeResolved(bytes32 indexed _tradeHash);
49 
50     struct Escrow {
51         // So we know the escrow exists
52         bool exists;
53         // This is the timestamp in whic hthe seller can cancel the escrow after.
54         // It has two special values:
55         // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)
56         // 1 : The seller can only request to cancel, which will change this value to a timestamp.
57         //     This option is avaialble for complex trade terms such as cash-in-person where a
58         //     payment window is inappropriate
59         uint32 sellerCanCancelAfter;
60         // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner
61         // in the way of fees once the escrow has completed
62         uint128 totalGasFeesSpentByRelayer;
63     }
64 
65     // Mapping of active trades. The key here is a hash of the trade proprties
66     mapping (bytes32 => Escrow) public escrows;
67 
68     modifier onlyOwner() {
69         require(msg.sender == owner, "Must be owner");
70         _;
71     }
72 
73     modifier onlyArbitrator() {
74         require(msg.sender == arbitrator, "Must be arbitrator");
75         _;
76     }
77 
78     constructor(address initialAddress) public {
79         owner = initialAddress;
80         arbitrator = initialAddress;
81         relayer = initialAddress;
82     }
83 
84     /// @notice Create and fund a new escrow.
85     /// @param _tradeID The unique ID of the trade, generated by localcoinswap.com
86     /// @param _seller The selling party
87     /// @param _buyer The buying party
88     /// @param _value The amount of the escrow, exclusive of the fee
89     /// @param _fee localcoinswap's commission in 1/10000ths
90     /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after
91     /// @param _expiry This transaction must be created before this time
92     /// @param _v Signature "v" component
93     /// @param _r Signature "r" component
94     /// @param _s Signature "s" component
95     function createEscrow(
96         bytes16 _tradeID,
97         address _seller,
98         address _buyer,
99         uint256 _value,
100         uint16 _fee,
101         uint32 _paymentWindowInSeconds,
102         uint32 _expiry,
103         uint8 _v,
104         bytes32 _r,
105         bytes32 _s
106     ) external payable {
107         // The trade hash is created by tightly-concatenating and hashing properties of the trade.
108         // This hash becomes the identifier of the escrow, and hence all these variables must be
109         // supplied on future contract calls
110         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
111         // Require that trade does not already exist
112         require(!escrows[_tradeHash].exists, "Trade already exists");
113         // A signature (v, r and s) must come from localcoinswap to open an escrow
114         bytes32 _invitationHash = keccak256(abi.encodePacked(
115             _tradeHash,
116             _paymentWindowInSeconds,
117             _expiry
118         ));
119         require(recoverAddress(_invitationHash, _v, _r, _s) == relayer, "Must be relayer");
120         // These signatures come with an expiry stamp
121         require(block.timestamp < _expiry, "Signature has expired"); // solium-disable-line
122         // Check transaction value against signed _value and make sure is not 0
123         require(msg.value == _value && msg.value > 0, "Incorrect ether sent");
124         uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0
125             ? 1
126             : uint32(block.timestamp) + _paymentWindowInSeconds; // solium-disable-line
127         // Add the escrow to the public mapping
128         escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);
129         emit Created(_tradeHash);
130     }
131 
132     uint16 constant GAS_doResolveDispute = 36100;
133     /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.
134     /// @param _tradeID Escrow "tradeID" parameter
135     /// @param _seller Escrow "seller" parameter
136     /// @param _buyer Escrow "buyer" parameter
137     /// @param _value Escrow "value" parameter
138     /// @param _fee Escrow "fee parameter
139     /// @param _v Signature "v" component
140     /// @param _r Signature "r" component
141     /// @param _s Signature "s" component
142     /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)
143     function resolveDispute(
144         bytes16 _tradeID,
145         address payable _seller,
146         address payable _buyer,
147         uint256 _value,
148         uint16 _fee,
149         uint8 _v,
150         bytes32 _r,
151         bytes32 _s,
152         uint8 _buyerPercent
153     ) external onlyArbitrator {
154         address _signature = recoverAddress(keccak256(abi.encodePacked(
155             _tradeID,
156             INSTRUCTION_RESOLVE
157         )), _v, _r, _s);
158         require(_signature == _buyer || _signature == _seller, "Must be buyer or seller");
159 
160         Escrow memory _escrow;
161         bytes32 _tradeHash;
162         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
163         require(_escrow.exists, "Escrow does not exist");
164         require(_buyerPercent <= 100, "_buyerPercent must be 100 or lower");
165 
166         uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));
167         require(_value - _totalFees <= _value, "Overflow error"); // Prevent underflow
168         feesAvailableForWithdraw += _totalFees; // Add the the pot for localcoinswap to withdraw
169 
170         delete escrows[_tradeHash];
171         emit DisputeResolved(_tradeHash);
172         if (_buyerPercent > 0) {
173           // Take fees if buyer wins dispute
174           uint256 _escrowFees = (_value * _fee / 10000);
175           // Prevent underflow
176           uint256 _buyerAmount = _value * _buyerPercent / 100 - _totalFees - _escrowFees;
177           require(_buyerAmount <= _value, "Overflow error");
178           feesAvailableForWithdraw += _escrowFees;
179           _buyer.transfer(_buyerAmount);
180         }
181         if (_buyerPercent < 100) {
182           _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);
183         }
184     }
185 
186     /// @notice Release ether in escrow to the buyer. Direct call option.
187     /// @param _tradeID Escrow "tradeID" parameter
188     /// @param _seller Escrow "seller" parameter
189     /// @param _buyer Escrow "buyer" parameter
190     /// @param _value Escrow "value" parameter
191     /// @param _fee Escrow "fee parameter
192     /// @return bool
193     function release(
194         bytes16 _tradeID,
195         address payable _seller,
196         address payable _buyer,
197         uint256 _value,
198         uint16 _fee
199     ) external returns (bool){
200         require(msg.sender == _seller, "Must be seller");
201         return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);
202     }
203 
204     /// @notice Disable the seller from cancelling (i.e. "mark as paid"). Direct call option.
205     /// @param _tradeID Escrow "tradeID" parameter
206     /// @param _seller Escrow "seller" parameter
207     /// @param _buyer Escrow "buyer" parameter
208     /// @param _value Escrow "value" parameter
209     /// @param _fee Escrow "fee parameter
210     /// @return bool
211     function disableSellerCancel(
212         bytes16 _tradeID,
213         address _seller,
214         address _buyer,
215         uint256 _value,
216         uint16 _fee
217     ) external returns (bool) {
218         require(msg.sender == _buyer, "Must be buyer");
219         return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
220     }
221 
222     /// @notice Cancel the escrow as a buyer. Direct call option.
223     /// @param _tradeID Escrow "tradeID" parameter
224     /// @param _seller Escrow "seller" parameter
225     /// @param _buyer Escrow "buyer" parameter
226     /// @param _value Escrow "value" parameter
227     /// @param _fee Escrow "fee parameter
228     /// @return bool
229     function buyerCancel(
230       bytes16 _tradeID,
231       address payable _seller,
232       address payable _buyer,
233       uint256 _value,
234       uint16 _fee
235     ) external returns (bool) {
236         require(msg.sender == _buyer, "Must be buyer");
237         return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
238     }
239 
240     /// @notice Request to cancel as a seller. Direct call option.
241     /// @param _tradeID Escrow "tradeID" parameter
242     /// @param _seller Escrow "seller" parameter
243     /// @param _buyer Escrow "buyer" parameter
244     /// @param _value Escrow "value" parameter
245     /// @param _fee Escrow "fee parameter
246     /// @return bool
247     function sellerRequestCancel(
248         bytes16 _tradeID,
249         address _seller,
250         address _buyer,
251         uint256 _value,
252         uint16 _fee
253     ) external returns (bool) {
254         require(msg.sender == _seller, "Must be seller");
255         return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
256     }
257 
258     /// @notice Relay multiple signed instructions from parties of escrows.
259     /// @param _tradeID List of _tradeID values
260     /// @param _seller List of _seller values
261     /// @param _buyer List of _buyer values
262     /// @param _value List of _value values
263     /// @param _fee List of _fee values
264     /// @param _maximumGasPrice List of _maximumGasPrice values
265     /// @param _v List of signature "v" components
266     /// @param _r List of signature "r" components
267     /// @param _s List of signature "s" components
268     /// @param _instructionByte List of _instructionByte values
269     /// @return bool List of results
270     uint16 constant GAS_batchRelayBaseCost = 28500;
271     function batchRelay(
272         bytes16[] memory _tradeID,
273         address payable[] memory _seller,
274         address payable[] memory _buyer,
275         uint256[] memory _value,
276         uint16[] memory _fee,
277         uint128[] memory _maximumGasPrice,
278         uint8[] memory _v,
279         bytes32[] memory _r,
280         bytes32[] memory _s,
281         uint8[] memory _instructionByte
282     ) public returns (bool[] memory) {
283         bool[] memory _results = new bool[](_tradeID.length);
284         uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);
285         for (uint8 i = 0; i < _tradeID.length; i++) {
286             _results[i] = relay(
287                 _tradeID[i],
288                 _seller[i],
289                 _buyer[i],
290                 _value[i],
291                 _fee[i],
292                 _maximumGasPrice[i],
293                 _v[i],
294                 _r[i],
295                 _s[i],
296                 _instructionByte[i],
297                 _additionalGas
298             );
299         }
300         return _results;
301     }
302 
303     /// @notice Withdraw fees collected by the contract. Only the owner can call this.
304     /// @param _to Address to withdraw fees in to
305     /// @param _amount Amount to withdraw
306     function withdrawFees(address payable _to, uint256 _amount) external onlyOwner {
307         // This check also prevents underflow
308         require(_amount <= feesAvailableForWithdraw, "Amount is higher than amount available");
309         feesAvailableForWithdraw -= _amount;
310         _to.transfer(_amount);
311     }
312 
313     /// @notice Set the arbitrator to a new address. Only the owner can call this.
314     /// @param _newArbitrator Address of the replacement arbitrator
315     function setArbitrator(address _newArbitrator) external onlyOwner {
316         arbitrator = _newArbitrator;
317     }
318 
319     /// @notice Change the owner to a new address. Only the owner can call this.
320     /// @param _newOwner Address of the replacement owner
321     function setOwner(address _newOwner) external onlyOwner {
322         owner = _newOwner;
323     }
324 
325     /// @notice Change the relayer to a new address. Only the owner can call this.
326     /// @param _newRelayer Address of the replacement relayer
327     function setRelayer(address _newRelayer) external onlyOwner {
328         relayer = _newRelayer;
329     }
330 
331     /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.
332     /// @param _newRequestCancellationMinimumTime Replacement
333     function setRequestCancellationMinimumTime(
334         uint32 _newRequestCancellationMinimumTime
335     ) external onlyOwner {
336         requestCancellationMinimumTime = _newRequestCancellationMinimumTime;
337     }
338 
339     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
340     /// @param _tokenContract Token contract
341     /// @param _transferTo Recipient
342     /// @param _value Value
343     function transferToken(
344         _Token _tokenContract,
345         address _transferTo,
346         uint256 _value
347     ) external onlyOwner {
348         _tokenContract.transfer(_transferTo, _value);
349     }
350 
351     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
352     /// @param _tokenContract Token contract
353     /// @param _transferTo Recipient
354     /// @param _transferFrom Sender
355     /// @param _value Value
356     function transferTokenFrom(
357         _Token _tokenContract,
358         address _transferTo,
359         address _transferFrom,
360         uint256 _value
361     ) external onlyOwner {
362         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);
363     }
364 
365     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
366     /// @param _tokenContract Token contract
367     /// @param _spender Spender address
368     /// @param _value Value
369     function approveToken(
370         _Token _tokenContract,
371         address _spender,
372         uint256 _value
373     ) external onlyOwner {
374         _tokenContract.approve(_spender, _value);
375     }
376 
377     /// @notice Relay a signed instruction from a party of an escrow.
378     /// @param _tradeID Escrow "tradeID" parameter
379     /// @param _seller Escrow "seller" parameter
380     /// @param _buyer Escrow "buyer" parameter
381     /// @param _value Escrow "value" parameter
382     /// @param _fee Escrow "fee parameter
383     /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)
384     /// @param _v Signature "v" component
385     /// @param _r Signature "r" component
386     /// @param _s Signature "s" component
387     /// @param _additionalGas Additional gas to be deducted after this operation
388     /// @return bool
389     function relay(
390         bytes16 _tradeID,
391         address payable _seller,
392         address payable _buyer,
393         uint256 _value,
394         uint16 _fee,
395         uint128 _maximumGasPrice,
396         uint8 _v,
397         bytes32 _r,
398         bytes32 _s,
399         uint8 _instructionByte,
400         uint128 _additionalGas
401     ) private returns (bool) {
402         address _relayedSender = getRelayedSender(
403             _tradeID,
404             _instructionByte,
405             _maximumGasPrice,
406             _v,
407             _r,
408             _s
409         );
410         if (_relayedSender == _buyer) {
411             // Buyer's instructions:
412             if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {
413                 // Disable seller from cancelling
414                 return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
415             } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {
416                 // Cancel
417                 return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
418             }
419         } else if (_relayedSender == _seller) {
420             // Seller's instructions:
421             if (_instructionByte == INSTRUCTION_RELEASE) {
422                 // Release
423                 return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
424             } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {
425                 // Cancel
426                 return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
427             } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL){
428                 // Request to cancel
429                 return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
430             }
431         } else {
432             require(msg.sender == _seller, "Unrecognised party");
433             return false;
434         }
435     }
436 
437     /// @notice Increase the amount of gas to be charged later on completion of an escrow
438     /// @param _tradeHash Trade hash
439     /// @param _gas Gas cost
440     function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {
441         escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);
442     }
443 
444     /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay
445     /// @param _to Recipient address
446     /// @param _value Value of the transfer
447     /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer
448     /// @param _fee Commission in 1/10000ths
449     function transferMinusFees(
450         address payable _to,
451         uint256 _value,
452         uint128 _totalGasFeesSpentByRelayer,
453         uint16 _fee
454     ) private {
455         uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;
456         // Prevent underflow
457         if(_value - _totalFees > _value) {
458             return;
459         }
460         // Add fees to the pot for localcoinswap to withdraw
461         feesAvailableForWithdraw += _totalFees;
462         _to.transfer(_value - _totalFees);
463     }
464 
465     uint16 constant GAS_doRelease = 46588;
466     /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.
467     /// @param _tradeID Escrow "tradeID" parameter
468     /// @param _seller Escrow "seller" parameter
469     /// @param _buyer Escrow "buyer" parameter
470     /// @param _value Escrow "value" parameter
471     /// @param _fee Escrow "fee parameter
472     /// @param _additionalGas Additional gas to be deducted after this operation
473     /// @return bool
474     function doRelease(
475         bytes16 _tradeID,
476         address payable _seller,
477         address payable _buyer,
478         uint256 _value,
479         uint16 _fee,
480         uint128 _additionalGas
481     ) private returns (bool) {
482         Escrow memory _escrow;
483         bytes32 _tradeHash;
484         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
485         if (!_escrow.exists) return false;
486         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer
487                 ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)
488                 : 0
489             );
490         delete escrows[_tradeHash];
491         emit Released(_tradeHash);
492         transferMinusFees(_buyer, _value, _gasFees, _fee);
493         return true;
494     }
495 
496     uint16 constant GAS_doDisableSellerCancel = 28944;
497     /// @notice Prevents the seller from cancelling an escrow. Used to "mark as paid" by the buyer.
498     /// @param _tradeID Escrow "tradeID" parameter
499     /// @param _seller Escrow "seller" parameter
500     /// @param _buyer Escrow "buyer" parameter
501     /// @param _value Escrow "value" parameter
502     /// @param _fee Escrow "fee parameter
503     /// @param _additionalGas Additional gas to be deducted after this operation
504     /// @return bool
505     function doDisableSellerCancel(
506         bytes16 _tradeID,
507         address _seller,
508         address _buyer,
509         uint256 _value,
510         uint16 _fee,
511         uint128 _additionalGas
512     ) private returns (bool) {
513         Escrow memory _escrow;
514         bytes32 _tradeHash;
515         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
516         if (!_escrow.exists) return false;
517         if(_escrow.sellerCanCancelAfter == 0) return false;
518         escrows[_tradeHash].sellerCanCancelAfter = 0;
519         emit SellerCancelDisabled(_tradeHash);
520         if (msg.sender == relayer) {
521           increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
522         }
523         return true;
524     }
525 
526     uint16 constant GAS_doBuyerCancel = 46255;
527     /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.
528     /// @param _tradeID Escrow "tradeID" parameter
529     /// @param _seller Escrow "seller" parameter
530     /// @param _buyer Escrow "buyer" parameter
531     /// @param _value Escrow "value" parameter
532     /// @param _fee Escrow "fee parameter
533     /// @param _additionalGas Additional gas to be deducted after this operation
534     /// @return bool
535     function doBuyerCancel(
536         bytes16 _tradeID,
537         address payable _seller,
538         address payable _buyer,
539         uint256 _value,
540         uint16 _fee,
541         uint128 _additionalGas
542     ) private returns (bool) {
543         Escrow memory _escrow;
544         bytes32 _tradeHash;
545         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
546         if (!_escrow.exists) {
547             return false;
548         }
549         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer
550                 ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)
551                 : 0
552             );
553         delete escrows[_tradeHash];
554         emit CancelledByBuyer(_tradeHash);
555         transferMinusFees(_seller, _value, _gasFees, 0);
556         return true;
557     }
558 
559     uint16 constant GAS_doSellerCancel = 46815;
560     /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.
561     /// @param _tradeID Escrow "tradeID" parameter
562     /// @param _seller Escrow "seller" parameter
563     /// @param _buyer Escrow "buyer" parameter
564     /// @param _value Escrow "value" parameter
565     /// @param _fee Escrow "fee parameter
566     /// @param _additionalGas Additional gas to be deducted after this operation
567     /// @return bool
568     function doSellerCancel(
569         bytes16 _tradeID,
570         address payable _seller,
571         address payable _buyer,
572         uint256 _value,
573         uint16 _fee,
574         uint128 _additionalGas
575     ) private returns (bool) {
576         Escrow memory _escrow;
577         bytes32 _tradeHash;
578         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
579         if (!_escrow.exists) {
580             return false;
581         }
582         if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) { // solium-disable-line
583             return false;
584         }
585         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer
586                 ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)
587                 : 0
588             );
589         delete escrows[_tradeHash];
590         emit CancelledBySeller(_tradeHash);
591         transferMinusFees(_seller, _value, _gasFees, 0);
592         return true;
593     }
594 
595     uint16 constant GAS_doSellerRequestCancel = 29507;
596     /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.
597     /// @param _tradeID Escrow "tradeID" parameter
598     /// @param _seller Escrow "seller" parameter
599     /// @param _buyer Escrow "buyer" parameter
600     /// @param _value Escrow "value" parameter
601     /// @param _fee Escrow "fee parameter
602     /// @param _additionalGas Additional gas to be deducted after this operation
603     /// @return bool
604     function doSellerRequestCancel(
605         bytes16 _tradeID,
606         address _seller,
607         address _buyer,
608         uint256 _value,
609         uint16 _fee,
610         uint128 _additionalGas
611     ) private returns (bool) {
612         // Called on unlimited payment window trades where the buyer is not responding
613         Escrow memory _escrow;
614         bytes32 _tradeHash;
615         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
616         if (!_escrow.exists) {
617             return false;
618         }
619         if(_escrow.sellerCanCancelAfter != 1) {
620             return false;
621         }
622         escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) // solium-disable-line
623             + requestCancellationMinimumTime;
624         emit SellerRequestedCancel(_tradeHash);
625         if (msg.sender == relayer) {
626           increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);
627         }
628         return true;
629     }
630 
631     /// @notice Get the sender of the signed instruction.
632     /// @param _tradeID Identifier of the trade
633     /// @param _instructionByte Identifier of the instruction
634     /// @param _maximumGasPrice Maximum gas price permitted by the sender
635     /// @param _v Signature "v" component
636     /// @param _r Signature "r" component
637     /// @param _s Signature "s" component
638     /// @return address
639     function getRelayedSender(
640       bytes16 _tradeID,
641       uint8 _instructionByte,
642       uint128 _maximumGasPrice,
643       uint8 _v,
644       bytes32 _r,
645       bytes32 _s
646     ) private view returns (address) {
647         bytes32 _hash = keccak256(abi.encodePacked(
648             _tradeID,
649             _instructionByte,
650             _maximumGasPrice
651         ));
652         return recoverAddress(_hash, _v, _r, _s);
653     }
654 
655     /// @notice Hashes the values and returns the matching escrow object and trade hash.
656     /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.
657     /// @param _tradeID Escrow "tradeID" parameter
658     /// @param _seller Escrow "seller" parameter
659     /// @param _buyer Escrow "buyer" parameter
660     /// @param _value Escrow "value" parameter
661     /// @param _fee Escrow "fee parameter
662     /// @return Escrow
663     function getEscrowAndHash(
664         bytes16 _tradeID,
665         address _seller,
666         address _buyer,
667         uint256 _value,
668         uint16 _fee
669     ) private view returns (Escrow storage, bytes32) {
670         bytes32 _tradeHash = keccak256(abi.encodePacked(
671             _tradeID,
672             _seller,
673             _buyer,
674             _value,
675             _fee
676         ));
677         return (escrows[_tradeHash], _tradeHash);
678     }
679 
680     /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.
681     /// @param _h Data to be hashed
682     /// @param _v Signature "v" component
683     /// @param _r Signature "r" component
684     /// @param _s Signature "s" component
685     /// @return address
686     function recoverAddress(
687         bytes32 _h,
688         uint8 _v,
689         bytes32 _r,
690         bytes32 _s
691     ) private pure returns (address) {
692         bytes memory _prefix = "\x19Ethereum Signed Message:\n32";
693         bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));
694         return ecrecover(_prefixedHash, _v, _r, _s);
695     }
696 }
697 
698 contract _Token {
699     function transfer(address _to, uint _value) public returns (bool success);
700     function transferFrom(address _from, address _to, uint _value) public returns (bool success);
701     function approve(address _spender, uint _value) public returns (bool success);
702 }