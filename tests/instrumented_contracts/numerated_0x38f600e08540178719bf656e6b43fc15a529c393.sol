1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/RouterV1.sol": {
5       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { SafeCastUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport { TrancheData, TrancheDataHelpers, BondHelpers } from \"./_utils/BondHelpers.sol\";\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ITranche } from \"./_interfaces/buttonwood/ITranche.sol\";\nimport { IBondController } from \"./_interfaces/buttonwood/IBondController.sol\";\nimport { IPerpetualTranche } from \"./_interfaces/IPerpetualTranche.sol\";\n\n/**\n *  @title RouterV1\n *\n *  @notice Contract to dry-run and batch multiple operations.\n *\n */\ncontract RouterV1 {\n    // math\n    using SafeCastUpgradeable for uint256;\n\n    // data handling\n    using BondHelpers for IBondController;\n    using TrancheDataHelpers for TrancheData;\n\n    // ERC20 operations\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for ITranche;\n    using SafeERC20Upgradeable for IPerpetualTranche;\n\n    modifier afterPerpStateUpdate(IPerpetualTranche perp) {\n        perp.updateState();\n        _;\n    }\n\n    /// @notice Calculates the amount of tranche tokens minted after depositing into the deposit bond.\n    /// @dev Used by off-chain services to preview a tranche operation.\n    /// @param perp Address of the perp contract.\n    /// @param collateralAmount The amount of collateral the user wants to tranche.\n    /// @return bond The address of the current deposit bond.\n    /// @return trancheAmts The tranche token amounts minted.\n    function previewTranche(IPerpetualTranche perp, uint256 collateralAmount)\n        external\n        afterPerpStateUpdate(perp)\n        returns (\n            IBondController,\n            ITranche[] memory,\n            uint256[] memory\n        )\n    {\n        IBondController bond = perp.getDepositBond();\n\n        TrancheData memory td;\n        uint256[] memory trancheAmts;\n        (td, trancheAmts, ) = bond.previewDeposit(collateralAmount);\n\n        return (bond, td.tranches, trancheAmts);\n    }\n\n    /// @notice Calculates the amount of perp tokens minted and fees for the operation.\n    /// @dev Used by off-chain services to preview a deposit operation.\n    /// @param perp Address of the perp contract.\n    /// @param trancheIn The address of the tranche token to be deposited.\n    /// @param trancheInAmt The amount of tranche tokens deposited.\n    /// @return mintAmt The amount of perp tokens minted.\n    /// @return feeToken The address of the fee token.\n    /// @return mintFee The fee charged for minting.\n    function previewDeposit(\n        IPerpetualTranche perp,\n        ITranche trancheIn,\n        uint256 trancheInAmt\n    )\n        external\n        afterPerpStateUpdate(perp)\n        returns (\n            uint256,\n            IERC20Upgradeable,\n            int256\n        )\n    {\n        uint256 mintAmt = perp.computeMintAmt(trancheIn, trancheInAmt);\n        IERC20Upgradeable feeToken = perp.feeToken();\n        (int256 reserveFee, uint256 protocolFee) = perp.feeStrategy().computeMintFees(mintAmt);\n        int256 mintFee = reserveFee + protocolFee.toInt256();\n        return (mintAmt, feeToken, mintFee);\n    }\n\n    /// @notice Tranches the collateral using the current deposit bond and then deposits individual tranches\n    ///         to mint perp tokens. It transfers the perp tokens back to the\n    ///         transaction sender along with any unused tranches and fees.\n    /// @param perp Address of the perp contract.\n    /// @param bond Address of the deposit bond.\n    /// @param collateralAmount The amount of collateral the user wants to tranche.\n    /// @param feePaid The fee paid to the perp contract to mint perp when the fee token is not the perp token itself, otherwise 0.\n    /// @dev Fee to be paid should be pre-computed off-chain using the preview function.\n    function trancheAndDeposit(\n        IPerpetualTranche perp,\n        IBondController bond,\n        uint256 collateralAmount,\n        uint256 feePaid\n    ) external afterPerpStateUpdate(perp) {\n        TrancheData memory td = bond.getTrancheData();\n        IERC20Upgradeable collateralToken = IERC20Upgradeable(bond.collateralToken());\n        IERC20Upgradeable feeToken = perp.feeToken();\n\n        // transfers collateral & fees to router\n        collateralToken.safeTransferFrom(msg.sender, address(this), collateralAmount);\n        if (feePaid > 0) {\n            feeToken.safeTransferFrom(msg.sender, address(this), feePaid);\n        }\n\n        // approves collateral to be tranched\n        _checkAndApproveMax(collateralToken, address(bond), collateralAmount);\n\n        // tranches collateral\n        bond.deposit(collateralAmount);\n\n        // approves fee to be spent to mint perp tokens\n        _checkAndApproveMax(feeToken, address(perp), feePaid);\n\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            uint256 trancheAmt = td.tranches[i].balanceOf(address(this));\n            uint256 mintAmt = perp.computeMintAmt(td.tranches[i], trancheAmt);\n            if (mintAmt > 0) {\n                // approves tranches to be spent\n                _checkAndApproveMax(td.tranches[i], address(perp), trancheAmt);\n\n                // mints perp tokens using tranches\n                perp.deposit(td.tranches[i], trancheAmt);\n            } else {\n                // transfers unused tranches back\n                td.tranches[i].safeTransfer(msg.sender, trancheAmt);\n            }\n        }\n\n        // transfers any remaining collateral tokens back\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n        if (collateralBalance > 0) {\n            collateralToken.safeTransfer(msg.sender, collateralBalance);\n        }\n\n        // transfers remaining fee back if overpaid or reward\n        uint256 feeBalance = feeToken.balanceOf(address(this));\n        if (feeBalance > 0) {\n            feeToken.safeTransfer(msg.sender, feeBalance);\n        }\n\n        // transfers perp tokens back\n        perp.safeTransfer(msg.sender, perp.balanceOf(address(this)));\n    }\n\n    /// @notice Calculates the reserve tokens that can be redeemed from the queue\n    ///         for burning up to the requested amount of perp tokens.\n    /// @dev Used by off-chain services to preview a redeem operation.\n    /// @param perp Address of the perp contract.\n    /// @param perpAmtBurnt The amount of perp tokens requested to be burnt.\n    /// @return reserveTokens The list of reserve tokens redeemed.\n    /// @return redemptionAmts The list of reserve token amounts redeemed.\n    /// @return feeToken The address of the fee token.\n    /// @return burnFee The fee charged for burning.\n    function previewRedeem(IPerpetualTranche perp, uint256 perpAmtBurnt)\n        external\n        afterPerpStateUpdate(perp)\n        returns (\n            IERC20Upgradeable[] memory,\n            uint256[] memory,\n            IERC20Upgradeable,\n            int256\n        )\n    {\n        (IERC20Upgradeable[] memory reserveTokens, uint256[] memory redemptionAmts) = perp.computeRedemptionAmts(\n            perpAmtBurnt\n        );\n        (int256 reserveFee, uint256 protocolFee) = perp.feeStrategy().computeBurnFees(perpAmtBurnt);\n        int256 burnFee = reserveFee + protocolFee.toInt256();\n        IERC20Upgradeable feeToken = perp.feeToken();\n        return (reserveTokens, redemptionAmts, feeToken, burnFee);\n    }\n\n    /// @notice Calculates the amount tranche tokens that can be rolled out, remainders and fees,\n    ///         with a given tranche token rolled in and amount.\n    /// @dev Used by off-chain services to preview a rollover operation.\n    /// @param perp Address of the perp contract.\n    /// @param trancheIn The tranche token deposited.\n    /// @param tokenOut The reserve token requested to be withdrawn.\n    /// @param trancheInAmtRequested The amount of trancheIn tokens available to deposit.\n    /// @param maxTokenOutAmtUsed The token balance to be used for rollover.\n    /// @dev Set maxTokenOutAmtUsed to max(uint256) to use the entire balance.\n    /// @return r The amounts rolled over and remaining.\n    /// @return feeToken The address of the fee token.\n    /// @return rolloverFee The fee paid by the caller.\n    function previewRollover(\n        IPerpetualTranche perp,\n        ITranche trancheIn,\n        IERC20Upgradeable tokenOut,\n        uint256 trancheInAmtRequested,\n        uint256 maxTokenOutAmtUsed\n    )\n        external\n        afterPerpStateUpdate(perp)\n        returns (\n            IPerpetualTranche.RolloverPreview memory,\n            IERC20Upgradeable,\n            int256\n        )\n    {\n        IPerpetualTranche.RolloverPreview memory r;\n        r.remainingTrancheInAmt = trancheInAmtRequested;\n\n        IERC20Upgradeable feeToken = perp.feeToken();\n        int256 reserveFee = 0;\n        uint256 protocolFee = 0;\n        if (perp.isAcceptableRollover(trancheIn, tokenOut)) {\n            r = perp.computeRolloverAmt(trancheIn, tokenOut, trancheInAmtRequested, maxTokenOutAmtUsed);\n            (reserveFee, protocolFee) = perp.feeStrategy().computeRolloverFees(r.perpRolloverAmt);\n        }\n        int256 rolloverFee = reserveFee + protocolFee.toInt256();\n        return (r, feeToken, rolloverFee);\n    }\n\n    struct RolloverBatch {\n        ITranche trancheIn;\n        IERC20Upgradeable tokenOut;\n        uint256 trancheInAmt;\n    }\n\n    /// @notice Tranches collateral and performs a batch rollover.\n    /// @param perp Address of the perp contract.\n    /// @param bond Address of the deposit bond.\n    /// @param collateralAmount The amount of collateral the user wants to tranche.\n    /// @param rollovers List of batch rollover operations pre-computed off-chain.\n    /// @param feePaid The fee paid by the user performing rollover (fee could be negative).\n    function trancheAndRollover(\n        IPerpetualTranche perp,\n        IBondController bond,\n        uint256 collateralAmount,\n        RolloverBatch[] calldata rollovers,\n        uint256 feePaid\n    ) external afterPerpStateUpdate(perp) {\n        TrancheData memory td = bond.getTrancheData();\n        IERC20Upgradeable collateralToken = IERC20Upgradeable(bond.collateralToken());\n        IERC20Upgradeable feeToken = perp.feeToken();\n\n        // transfers collateral & fees to router\n        collateralToken.safeTransferFrom(msg.sender, address(this), collateralAmount);\n        if (feePaid > 0) {\n            feeToken.safeTransferFrom(msg.sender, address(this), feePaid);\n        }\n\n        // approves collateral to be tranched\n        _checkAndApproveMax(collateralToken, address(bond), collateralAmount);\n\n        // tranches collateral\n        bond.deposit(collateralAmount);\n\n        // approves fee to be spent to rollover\n        if (feePaid > 0) {\n            _checkAndApproveMax(feeToken, address(perp), feePaid);\n        }\n\n        for (uint256 i = 0; i < rollovers.length; i++) {\n            // approve trancheIn to be spent by perp\n            _checkAndApproveMax(rollovers[i].trancheIn, address(perp), rollovers[i].trancheInAmt);\n\n            // perform rollover\n            perp.rollover(rollovers[i].trancheIn, rollovers[i].tokenOut, rollovers[i].trancheInAmt);\n        }\n\n        for (uint256 i = 0; i < rollovers.length; i++) {\n            // transfer remaining tokenOut tokens back\n            uint256 tokenOutBalance = rollovers[i].tokenOut.balanceOf(address(this));\n            if (tokenOutBalance > 0) {\n                rollovers[i].tokenOut.safeTransfer(msg.sender, tokenOutBalance);\n            }\n        }\n\n        // transfers unused tranches back\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            uint256 trancheBalance = td.tranches[i].balanceOf(address(this));\n            if (trancheBalance > 0) {\n                td.tranches[i].safeTransfer(msg.sender, trancheBalance);\n            }\n        }\n\n        // transfers any remaining collateral tokens back\n        uint256 collateralBalance = collateralToken.balanceOf(address(this));\n        if (collateralBalance > 0) {\n            collateralToken.safeTransfer(msg.sender, collateralBalance);\n        }\n\n        // transfers remaining fee back if overpaid or reward\n        uint256 feeBalance = feeToken.balanceOf(address(this));\n        if (feeBalance > 0) {\n            feeToken.safeTransfer(msg.sender, feeBalance);\n        }\n    }\n\n    /// @dev Checks if the spender has sufficient allowance. If not, approves the maximum possible amount.\n    function _checkAndApproveMax(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 amount\n    ) private {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (allowance < amount) {\n            token.safeApprove(spender, type(uint256).max);\n        }\n    }\n}\n"
6     },
7     "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
9     },
10     "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
12     },
13     "contracts/_utils/BondHelpers.sol": {
14       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport { SafeCastUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { IBondController } from \"../_interfaces/buttonwood/IBondController.sol\";\nimport { ITranche } from \"../_interfaces/buttonwood/ITranche.sol\";\n\n/// @notice Expected tranche to be part of bond.\n/// @param tranche Address of the tranche token.\nerror UnacceptableTrancheIndex(ITranche tranche);\n\nstruct TrancheData {\n    ITranche[] tranches;\n    uint256[] trancheRatios;\n    uint8 trancheCount;\n}\n\n/**\n *  @title TrancheDataHelpers\n *\n *  @notice Library with helper functions the bond's retrieved tranche data.\n *\n */\nlibrary TrancheDataHelpers {\n    /// @notice Iterates through the tranche data to find the seniority index of the given tranche.\n    /// @param td The tranche data object.\n    /// @param t The address of the tranche to check.\n    /// @return the index of the tranche in the tranches array.\n    function getTrancheIndex(TrancheData memory td, ITranche t) internal pure returns (uint256) {\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            if (td.tranches[i] == t) {\n                return i;\n            }\n        }\n        revert UnacceptableTrancheIndex(t);\n    }\n}\n\n/**\n *  @title TrancheHelpers\n *\n *  @notice Library with helper functions tranche tokens.\n *\n */\nlibrary TrancheHelpers {\n    /// @notice Given a tranche, looks up the collateral balance backing the tranche supply.\n    /// @param t Address of the tranche token.\n    /// @return The collateral balance and the tranche token supply.\n    function getTrancheCollateralization(ITranche t) internal view returns (uint256, uint256) {\n        IBondController bond = IBondController(t.bond());\n        TrancheData memory td;\n        uint256[] memory collateralBalances;\n        uint256[] memory trancheSupplies;\n        (td, collateralBalances, trancheSupplies) = BondHelpers.getTrancheCollateralizations(bond);\n        uint256 trancheIndex = TrancheDataHelpers.getTrancheIndex(td, t);\n        return (collateralBalances[trancheIndex], trancheSupplies[trancheIndex]);\n    }\n}\n\n/**\n *  @title BondHelpers\n *\n *  @notice Library with helper functions for ButtonWood's Bond contract.\n *\n */\nlibrary BondHelpers {\n    // Replicating value used here:\n    // https://github.com/buttonwood-protocol/tranche/blob/main/contracts/BondController.sol\n    uint256 private constant TRANCHE_RATIO_GRANULARITY = 1000;\n    uint256 private constant BPS = 10_000;\n\n    /// @notice Given a bond, calculates the time remaining to maturity.\n    /// @param b The address of the bond contract.\n    /// @return The number of seconds before the bond reaches maturity.\n    function timeToMaturity(IBondController b) internal view returns (uint256) {\n        uint256 maturityDate = b.maturityDate();\n        return maturityDate > block.timestamp ? maturityDate - block.timestamp : 0;\n    }\n\n    /// @notice Given a bond, calculates the bond duration i.e)\n    ///         difference between creation time and maturity time.\n    /// @param b The address of the bond contract.\n    /// @return The duration in seconds.\n    function duration(IBondController b) internal view returns (uint256) {\n        return b.maturityDate() - b.creationDate();\n    }\n\n    /// @notice Given a bond, retrieves all of the bond's tranche related data.\n    /// @param b The address of the bond contract.\n    /// @return The tranche data.\n    function getTrancheData(IBondController b) internal view returns (TrancheData memory) {\n        TrancheData memory td;\n        td.trancheCount = SafeCastUpgradeable.toUint8(b.trancheCount());\n        td.tranches = new ITranche[](td.trancheCount);\n        td.trancheRatios = new uint256[](td.trancheCount);\n        // Max tranches per bond < 2**8 - 1\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            (ITranche t, uint256 ratio) = b.tranches(i);\n            td.tranches[i] = t;\n            td.trancheRatios[i] = ratio;\n        }\n        return td;\n    }\n\n    /// @notice Helper function to estimate the amount of tranches minted when a given amount of collateral\n    ///         is deposited into the bond.\n    /// @dev This function is used off-chain services (using callStatic) to preview tranches minted after\n    /// @param b The address of the bond contract.\n    /// @return The tranche data, an array of tranche amounts and fees.\n    function previewDeposit(IBondController b, uint256 collateralAmount)\n        internal\n        view\n        returns (\n            TrancheData memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        TrancheData memory td = getTrancheData(b);\n        uint256[] memory trancheAmts = new uint256[](td.trancheCount);\n        uint256[] memory fees = new uint256[](td.trancheCount);\n\n        uint256 totalDebt = b.totalDebt();\n        uint256 collateralBalance = IERC20Upgradeable(b.collateralToken()).balanceOf(address(b));\n        uint256 feeBps = b.feeBps();\n\n        for (uint256 i = 0; i < td.trancheCount; i++) {\n            uint256 trancheValue = (collateralAmount * td.trancheRatios[i]) / TRANCHE_RATIO_GRANULARITY;\n            if (collateralBalance > 0) {\n                trancheValue = (trancheValue * totalDebt) / collateralBalance;\n            }\n            fees[i] = (trancheValue * feeBps) / BPS;\n            if (fees[i] > 0) {\n                trancheValue -= fees[i];\n            }\n            trancheAmts[i] = trancheValue;\n        }\n\n        return (td, trancheAmts, fees);\n    }\n\n    /// @notice Given a bond, for each tranche token retrieves the total collateral redeemable\n    ///         for the total supply of the tranche token (aka debt issued).\n    /// @dev The cdr can be computed for each tranche by dividing the\n    ///      returned tranche's collateralBalance by the tranche's totalSupply.\n    /// @param b The address of the bond contract.\n    /// @return The tranche data and the list of collateral balances and the total supplies for each tranche.\n    function getTrancheCollateralizations(IBondController b)\n        internal\n        view\n        returns (\n            TrancheData memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        TrancheData memory td = getTrancheData(b);\n        uint256[] memory collateralBalances = new uint256[](td.trancheCount);\n        uint256[] memory trancheSupplies = new uint256[](td.trancheCount);\n\n        // When the bond is mature, the collateral is transferred over to the individual tranche token contracts\n        if (b.isMature()) {\n            for (uint8 i = 0; i < td.trancheCount; i++) {\n                trancheSupplies[i] = td.tranches[i].totalSupply();\n                collateralBalances[i] = IERC20Upgradeable(b.collateralToken()).balanceOf(address(td.tranches[i]));\n            }\n            return (td, collateralBalances, trancheSupplies);\n        }\n\n        // Before the bond is mature, all the collateral is held by the bond contract\n        uint256 bondCollateralBalance = IERC20Upgradeable(b.collateralToken()).balanceOf(address(b));\n        uint256 zTrancheIndex = td.trancheCount - 1;\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            trancheSupplies[i] = td.tranches[i].totalSupply();\n\n            // a to y tranches\n            if (i != zTrancheIndex) {\n                collateralBalances[i] = (trancheSupplies[i] <= bondCollateralBalance)\n                    ? trancheSupplies[i]\n                    : bondCollateralBalance;\n                bondCollateralBalance -= collateralBalances[i];\n            }\n            // z tranche\n            else {\n                collateralBalances[i] = bondCollateralBalance;\n            }\n        }\n\n        return (td, collateralBalances, trancheSupplies);\n    }\n\n    /// @notice Given a bond, retrieves the collateral redeemable for\n    ///         each tranche held by the given address.\n    /// @param b The address of the bond contract.\n    /// @param u The address to check balance for.\n    /// @return The tranche data and an array of collateral balances.\n    function getTrancheCollateralBalances(IBondController b, address u)\n        internal\n        view\n        returns (TrancheData memory, uint256[] memory)\n    {\n        TrancheData memory td;\n        uint256[] memory collateralBalances;\n        uint256[] memory trancheSupplies;\n\n        (td, collateralBalances, trancheSupplies) = getTrancheCollateralizations(b);\n\n        uint256[] memory balances = new uint256[](td.trancheCount);\n        for (uint8 i = 0; i < td.trancheCount; i++) {\n            balances[i] = (td.tranches[i].balanceOf(u) * collateralBalances[i]) / trancheSupplies[i];\n        }\n\n        return (td, balances);\n    }\n}\n"
15     },
16     "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
18     },
19     "contracts/_interfaces/buttonwood/ITranche.sol": {
20       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ITranche is IERC20Upgradeable {\n    function bond() external view returns (address);\n}\n"
21     },
22     "contracts/_interfaces/buttonwood/IBondController.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { ITranche } from \"./ITranche.sol\";\n\ninterface IBondController {\n    function collateralToken() external view returns (address);\n\n    function maturityDate() external view returns (uint256);\n\n    function creationDate() external view returns (uint256);\n\n    function totalDebt() external view returns (uint256);\n\n    function feeBps() external view returns (uint256);\n\n    function isMature() external view returns (bool);\n\n    function tranches(uint256 i) external view returns (ITranche token, uint256 ratio);\n\n    function trancheCount() external view returns (uint256 count);\n\n    function trancheTokenAddresses(ITranche token) external view returns (bool);\n\n    function deposit(uint256 amount) external;\n\n    function redeem(uint256[] memory amounts) external;\n\n    function mature() external;\n\n    function redeemMature(address tranche, uint256 amount) external;\n}\n"
24     },
25     "contracts/_interfaces/IPerpetualTranche.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport { IBondIssuer } from \"./IBondIssuer.sol\";\nimport { IFeeStrategy } from \"./IFeeStrategy.sol\";\nimport { IPricingStrategy } from \"./IPricingStrategy.sol\";\nimport { IDiscountStrategy } from \"./IDiscountStrategy.sol\";\nimport { IBondController } from \"./buttonwood/IBondController.sol\";\nimport { ITranche } from \"./buttonwood/ITranche.sol\";\n\ninterface IPerpetualTranche is IERC20Upgradeable {\n    //--------------------------------------------------------------------------\n    // Events\n\n    /// @notice Event emitted when the keeper is updated.\n    /// @param prevKeeper The address of the previous keeper.\n    /// @param newKeeper The address of the new keeper.\n    event UpdatedKeeper(address prevKeeper, address newKeeper);\n\n    /// @notice Event emitted when the bond issuer is updated.\n    /// @param issuer Address of the issuer contract.\n    event UpdatedBondIssuer(IBondIssuer issuer);\n\n    /// @notice Event emitted when the fee strategy is updated.\n    /// @param strategy Address of the strategy contract.\n    event UpdatedFeeStrategy(IFeeStrategy strategy);\n\n    /// @notice Event emitted when the pricing strategy is updated.\n    /// @param strategy Address of the strategy contract.\n    event UpdatedPricingStrategy(IPricingStrategy strategy);\n\n    /// @notice Event emitted when the discount strategy is updated.\n    /// @param strategy Address of the strategy contract.\n    event UpdatedDiscountStrategy(IDiscountStrategy strategy);\n\n    /// @notice Event emitted when maturity tolerance parameters are updated.\n    /// @param min The minimum maturity time.\n    /// @param max The maximum maturity time.\n    event UpdatedTolerableTrancheMaturity(uint256 min, uint256 max);\n\n    /// @notice Event emitted when the supply caps are updated.\n    /// @param maxSupply The max total supply.\n    /// @param maxMintAmtPerTranche The max mint amount per tranche.\n    event UpdatedMintingLimits(uint256 maxSupply, uint256 maxMintAmtPerTranche);\n\n    /// @notice Event emitted when the mature value target percentage is updated.\n    /// @param matureValueTargetPerc The new target percentage.\n    event UpdatedMatureValueTargetPerc(uint256 matureValueTargetPerc);\n\n    /// @notice Event emitted when the applied discount for a given token is set.\n    /// @param token The address of the token.\n    /// @param discount The discount factor applied.\n    event DiscountApplied(IERC20Upgradeable token, uint256 discount);\n\n    /// @notice Event emitted the reserve's current token balance is recorded after change.\n    /// @param token Address of token.\n    /// @param balance The recorded ERC-20 balance of the token held by the reserve.\n    event ReserveSynced(IERC20Upgradeable token, uint256 balance);\n\n    /// @notice Event emitted when the active deposit bond is updated.\n    /// @param bond Address of the new deposit bond.\n    event UpdatedDepositBond(IBondController bond);\n\n    /// @notice Event emitted when the mature tranche balance is updated.\n    /// @param matureTrancheBalance The mature tranche balance.\n    event UpdatedMatureTrancheBalance(uint256 matureTrancheBalance);\n\n    //--------------------------------------------------------------------------\n    // Methods\n\n    /// @notice Deposits tranche tokens into the system and mint perp tokens.\n    /// @param trancheIn The address of the tranche token to be deposited.\n    /// @param trancheInAmt The amount of tranche tokens deposited.\n    function deposit(ITranche trancheIn, uint256 trancheInAmt) external;\n\n    /// @notice Burn perp tokens and redeem the share of reserve assets.\n    /// @param perpAmtBurnt The amount of perp tokens burnt from the caller.\n    function redeem(uint256 perpAmtBurnt) external;\n\n    /// @notice Rotates newer tranches in for reserve tokens.\n    /// @param trancheIn The tranche token deposited.\n    /// @param tokenOut The reserve token to be redeemed.\n    /// @param trancheInAmt The amount of trancheIn tokens deposited.\n    function rollover(\n        ITranche trancheIn,\n        IERC20Upgradeable tokenOut,\n        uint256 trancheInAmt\n    ) external;\n\n    /// @notice Reference to the wallet or contract that has the ability to pause/unpause operations.\n    /// @return The address of the keeper.\n    function keeper() external view returns (address);\n\n    /// @notice The address of the underlying rebasing ERC-20 collateral token backing the tranches.\n    /// @return Address of the collateral token.\n    function collateral() external view returns (IERC20Upgradeable);\n\n    /// @notice The \"virtual\" balance of all mature tranches held by the system.\n    /// @return The mature tranche balance.\n    function getMatureTrancheBalance() external returns (uint256);\n\n    /// @notice The parent bond whose tranches are currently accepted to mint perp tokens.\n    /// @return Address of the deposit bond.\n    function getDepositBond() external returns (IBondController);\n\n    /// @notice Checks if the given `trancheIn` can be rolled out for `tokenOut`.\n    /// @param trancheIn The tranche token deposited.\n    /// @param tokenOut The reserve token to be redeemed.\n    function isAcceptableRollover(ITranche trancheIn, IERC20Upgradeable tokenOut) external returns (bool);\n\n    /// @notice The strategy contract with the fee computation logic.\n    /// @return Address of the strategy contract.\n    function feeStrategy() external view returns (IFeeStrategy);\n\n    /// @notice The ERC-20 contract which holds perp balances.\n    /// @return Address of the token.\n    function perpERC20() external view returns (IERC20Upgradeable);\n\n    /// @notice The contract where the protocol holds funds which back the perp token supply.\n    /// @return Address of the reserve.\n    function reserve() external view returns (address);\n\n    /// @notice The address which holds any revenue extracted by protocol.\n    /// @return Address of the fee collector.\n    function protocolFeeCollector() external view returns (address);\n\n    /// @notice The fee token currently used to receive fees in.\n    /// @return Address of the fee token.\n    function feeToken() external view returns (IERC20Upgradeable);\n\n    /// @notice Total count of tokens held in the reserve.\n    function getReserveCount() external returns (uint256);\n\n    /// @notice The token address from the reserve list by index.\n    /// @param index The index of a token.\n    function getReserveAt(uint256 index) external returns (IERC20Upgradeable);\n\n    /// @notice Checks if the given token is part of the reserve.\n    /// @param token The address of a token to check.\n    function inReserve(IERC20Upgradeable token) external returns (bool);\n\n    /// @notice Fetches the reserve's tranche token balance.\n    /// @param tranche The address of the tranche token held by the reserve.\n    function getReserveTrancheBalance(IERC20Upgradeable tranche) external returns (uint256);\n\n    /// @notice Computes the price of each perp token, i.e) reserve value / total supply.\n    function getAvgPrice() external returns (uint256);\n\n    /// @notice Fetches the list of reserve tokens which are up for rollover.\n    function getReserveTokensUpForRollover() external returns (IERC20Upgradeable[] memory);\n\n    /// @notice Computes the amount of perp tokens minted when `trancheInAmt` `trancheIn` tokens\n    ///         are deposited into the system.\n    /// @param trancheIn The tranche token deposited.\n    /// @param trancheInAmt The amount of tranche tokens deposited.\n    /// @return The amount of perp tokens to be minted.\n    function computeMintAmt(ITranche trancheIn, uint256 trancheInAmt) external returns (uint256);\n\n    /// @notice Computes the amount reserve tokens redeemed when burning given number of perp tokens.\n    /// @param perpAmtBurnt The amount of perp tokens to be burnt.\n    /// @return tokensOut The list of reserve tokens redeemed.\n    /// @return tokenOutAmts The list of reserve token amounts redeemed.\n    function computeRedemptionAmts(uint256 perpAmtBurnt)\n        external\n        returns (IERC20Upgradeable[] memory tokensOut, uint256[] memory tokenOutAmts);\n\n    struct RolloverPreview {\n        /// @notice The perp denominated value of tokens rolled over.\n        uint256 perpRolloverAmt;\n        /// @notice The amount of tokens rolled out.\n        uint256 tokenOutAmt;\n        /// @notice The tranche denominated amount of tokens rolled out.\n        /// @dev tokenOutAmt and trancheOutAmt can only be different values\n        ///      in the case of rolling over the mature tranche.\n        uint256 trancheOutAmt;\n        /// @notice The amount of trancheIn tokens rolled in.\n        uint256 trancheInAmt;\n        /// @notice The difference between the available trancheIn amount and\n        ///        the amount of tokens used for the rollover.\n        uint256 remainingTrancheInAmt;\n    }\n\n    /// @notice Computes the amount reserve tokens that are rolled out for the given number\n    ///         of `trancheIn` tokens rolled in.\n    /// @param trancheIn The tranche token rolled in.\n    /// @param tokenOut The reserve token to be rolled out.\n    /// @param trancheInAmtAvailable The amount of trancheIn tokens rolled in.\n    /// @param tokenOutAmtRequested The amount of tokenOut tokens requested to be rolled out.\n    /// @return r The rollover amounts in various denominations.\n    function computeRolloverAmt(\n        ITranche trancheIn,\n        IERC20Upgradeable tokenOut,\n        uint256 trancheInAmtAvailable,\n        uint256 tokenOutAmtRequested\n    ) external returns (RolloverPreview memory);\n\n    /// @notice The discount to be applied given the reserve token.\n    /// @param token The address of the reserve token.\n    /// @return The discount applied.\n    function computeDiscount(IERC20Upgradeable token) external view returns (uint256);\n\n    /// @notice The price of the given reserve token.\n    /// @param token The address of the reserve token.\n    /// @return The computed price.\n    function computePrice(IERC20Upgradeable token) external view returns (uint256);\n\n    /// @notice Updates time dependent storage state.\n    function updateState() external;\n}\n"
27     },
28     "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
30     },
31     "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
33     },
34     "contracts/_interfaces/IBondIssuer.sol": {
35       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IBondController } from \"./buttonwood/IBondController.sol\";\n\ninterface IBondIssuer {\n    /// @notice Event emitted when a new bond is issued by the issuer.\n    /// @param bond The newly issued bond.\n    event BondIssued(IBondController bond);\n\n    /// @notice The address of the underlying collateral token to be used for issued bonds.\n    /// @return Address of the collateral token.\n    function collateral() external view returns (address);\n\n    /// @notice Issues a new bond if sufficient time has elapsed since the last issue.\n    function issue() external;\n\n    /// @notice Checks if a given bond has been issued by the issuer.\n    /// @param bond Address of the bond to check.\n    /// @return if the bond has been issued by the issuer.\n    function isInstance(IBondController bond) external view returns (bool);\n\n    /// @notice Fetches the most recently issued bond.\n    /// @return Address of the most recent bond.\n    function getLatestBond() external returns (IBondController);\n\n    /// @notice Returns the total number of bonds issued by this issuer.\n    /// @return Number of bonds.\n    function issuedCount() external view returns (uint256);\n\n    /// @notice The bond address from the issued list by index.\n    /// @return Address of the bond.\n    function issuedBondAt(uint256 index) external view returns (IBondController);\n}\n"
36     },
37     "contracts/_interfaces/IFeeStrategy.sol": {
38       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IFeeStrategy {\n    /// @notice Address of the fee token.\n    function feeToken() external view returns (IERC20Upgradeable);\n\n    /// @notice Computes the fees while minting given amount of perp tokens.\n    /// @dev The mint fee can be either positive or negative. When positive it's paid by the minting users to the reserve.\n    ///      When negative its paid to the minting users by the reserve.\n    ///      The protocol fee is always non-negative and is paid by the users minting to the\n    ///      perp contract's fee collector.\n    /// @param amount The amount of perp tokens to be minted.\n    /// @return reserveFee The fee paid to the reserve to mint perp tokens.\n    /// @return protocolFee The fee paid to the protocol to mint perp tokens.\n    function computeMintFees(uint256 amount) external view returns (int256 reserveFee, uint256 protocolFee);\n\n    /// @notice Computes the fees while burning given amount of perp tokens.\n    /// @dev The burn fee can be either positive or negative. When positive it's paid by the burning users to the reserve.\n    ///      When negative its paid to the burning users by the reserve.\n    ///      The protocol fee is always non-negative and is paid by the users burning to the\n    ///      perp contract's fee collector.\n    /// @param amount The amount of perp tokens to be burnt.\n    /// @return reserveFee The fee paid to the reserve to burn perp tokens.\n    /// @return protocolFee The fee paid to the protocol to burn perp tokens.\n    function computeBurnFees(uint256 amount) external view returns (int256 reserveFee, uint256 protocolFee);\n\n    /// @notice Computes the fees while rolling over given amount of perp tokens.\n    /// @dev The rollover fee can be either positive or negative. When positive it's paid by the users rolling over to the reserve.\n    ///      When negative its paid to the users rolling over by the reserve.\n    ///      The protocol fee is always positive and is paid by the users rolling over to the\n    ///      perp contract's fee collector.\n    /// @param amount The Perp-denominated value of the tranches being rolled over.\n    /// @return reserveFee The fee paid to the reserve to rollover tokens.\n    /// @return protocolFee The fee paid to the protocol to rollover tokens.\n    function computeRolloverFees(uint256 amount) external view returns (int256 reserveFee, uint256 protocolFee);\n}\n"
39     },
40     "contracts/_interfaces/IPricingStrategy.sol": {
41       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ITranche } from \"../_interfaces/buttonwood/ITranche.sol\";\n\ninterface IPricingStrategy {\n    /// @notice Computes the price of a given tranche token.\n    /// @param tranche The tranche to compute price of.\n    /// @return The price as a fixed point number with `decimals()`.\n    function computeTranchePrice(ITranche tranche) external view returns (uint256);\n\n    /// @notice Computes the price of mature tranches extracted and held as naked collateral.\n    /// @param collateralToken The collateral token.\n    /// @param collateralBalance The collateral balance of all the mature tranches.\n    /// @param debt The total count of mature tranches.\n    /// @return The price as a fixed point number with `decimals()`.\n    function computeMatureTranchePrice(\n        IERC20Upgradeable collateralToken,\n        uint256 collateralBalance,\n        uint256 debt\n    ) external view returns (uint256);\n\n    /// @notice Number of price decimals.\n    function decimals() external view returns (uint8);\n}\n"
42     },
43     "contracts/_interfaces/IDiscountStrategy.sol": {
44       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IDiscountStrategy {\n    /// @notice Computes the discount to be applied to a given tranche token.\n    /// @param tranche The tranche token to compute discount for.\n    /// @return The discount as a fixed point number with `decimals()`.\n    function computeTrancheDiscount(IERC20Upgradeable tranche) external view returns (uint256);\n\n    /// @notice Number of discount decimals.\n    function decimals() external view returns (uint8);\n}\n"
45     }
46   },
47   "settings": {
48     "optimizer": {
49       "enabled": true,
50       "runs": 200
51     },
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     },
64     "libraries": {}
65   }
66 }}