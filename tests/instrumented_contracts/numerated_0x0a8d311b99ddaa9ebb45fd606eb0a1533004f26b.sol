1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/solady/src/utils/ECDSA.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The number which `s` must not exceed in order for\n    /// the signature to be non-malleable.\n    bytes32 private constant _MALLEABILITY_THRESHOLD =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(signature.length, 65) {\n                // Copy the free memory pointer so that we can restore it later.\n                let m := mload(0x40)\n                // Directly copy `r` and `s` from the calldata.\n                calldatacopy(0x40, signature.offset, 0x40)\n\n                // If `s` in lower half order, such that the signature is not malleable.\n                if iszero(gt(mload(0x60), _MALLEABILITY_THRESHOLD)) {\n                    mstore(0x00, hash)\n                    // Compute `v` and store it in the scratch space.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            0x01, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x40, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // Restore the zero slot.\n                    mstore(0x60, 0)\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    result := mload(sub(0x60, returndatasize()))\n                }\n                // Restore the free memory pointer.\n                mstore(0x40, m)\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    ///\n    /// To be honest, I do not recommend using EIP-2098 signatures\n    /// for simplicity, performance, and security reasons. Most if not\n    /// all clients support traditional non EIP-2098 signatures by default.\n    /// As such, this method is intentionally not fully inlined.\n    /// It is merely included for completeness.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        uint8 v;\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        result = recover(hash, v, r, s);\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n\n            // If `s` in lower half order, such that the signature is not malleable.\n            if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\n                mstore(0x00, hash)\n                mstore(0x20, v)\n                mstore(0x40, r)\n                mstore(0x60, s)\n                pop(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        0x01, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x40, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n                // Restore the zero slot.\n                mstore(0x60, 0)\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(sub(0x60, returndatasize()))\n            }\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store into scratch space for keccak256.\n            mstore(0x20, hash)\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\")\n            // 0x40 - 0x04 = 0x3c\n            result := keccak256(0x04, 0x3c)\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        assembly {\n            // We need at most 128 bytes for Ethereum signed message header.\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\n            // The length of \"\\x19Ethereum Signed Message:\\n\" is 26 bytes (i.e. 0x1a).\n            // The next multiple of 32 above 78 + 26 is 128 (i.e. 0x80).\n\n            // Instead of allocating, we temporarily copy the 128 bytes before the\n            // start of `s` data to some variables.\n            let m3 := mload(sub(s, 0x60))\n            let m2 := mload(sub(s, 0x40))\n            let m1 := mload(sub(s, 0x20))\n            // The length of `s` is in bytes.\n            let sLength := mload(s)\n\n            let ptr := add(s, 0x20)\n\n            // `end` marks the end of the memory which we will compute the keccak256 of.\n            let end := add(ptr, sLength)\n\n            // Convert the length of the bytes to ASCII decimal representation\n            // and store it into the memory.\n            for { let temp := sLength } 1 {} {\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            // Copy the header over to the memory.\n            mstore(sub(ptr, 0x20), \"\\x00\\x00\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n\")\n            // Compute the keccak256 of the memory.\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\n\n            // Restore the previous memory.\n            mstore(s, sLength)\n            mstore(sub(s, 0x20), m1)\n            mstore(sub(s, 0x40), m2)\n            mstore(sub(s, 0x60), m3)\n        }\n    }\n}\n"
6     },
7     "lib/solady/src/utils/LibString.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(31)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 31), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 31), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 63), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(31)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(mload(a), 32), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 32), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 67108863)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                // Restore the result.\n                result := mload(0x40)\n                // Stores the string length.\n                mstore(result, length)\n                // Zeroize the slot after the string.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, and(add(last, 31), not(31)))\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 31)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Restore the result to the start of the free memory.\n            result := mload(0x40)\n            // Store the length of the result.\n            mstore(result, sub(last, add(result, 0x20)))\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
9     },
10     "lib/solmate/src/auth/Owned.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
12     },
13     "lib/solmate/src/tokens/ERC721.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
15     },
16     "src/ETHGobblers.sol": {
17       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport \"solady/utils/ECDSA.sol\";\nimport \"solady/utils/LibString.sol\";\nimport \"solmate/auth/Owned.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"./GobDrops.sol\";\n\n/// @title ETH Gobblers\n/// @author EtDu\n/// @notice Gobble... Gobble... Gobble...\n\ncontract ETHGobblers is ERC721, Owned {\n  using ECDSA for bytes32;\n  using LibString for uint256;\n\n  /*------------------------------------------------------*/\n  /*                VARIABLES / CONSTANTS\n  /*------------------------------------------------------*/\n\n  uint256 public totalSupply = 0;\n  // Genesis max supply, newer generations can be minted via mitosis\n  uint256 constant genesisMaxSupply = 2000;\n  // Supply of new ETH Gobblers from mitosis\n  uint256 public mitosisSupply = 0;\n  // Current Gobbler Gobbler token ID. Has the power to gobble one ETH Gobbler before declaring another Gobbler Gobbler.\n  uint256 public currentGobblerGobbler;\n  // ETH Gobbler action pricing\n  uint256 public feedPrice = 0.001 ether;\n  uint256 public groomPrice = 0.01 ether;\n  uint256 public sleepPrice = 0.1 ether;\n  uint256 public gobbleGobblerPrice = 1 ether;\n\n  string public baseURI;\n\n  bool public paused;\n\n  GobDrops public gobDrops;\n  \n  // ETHGobblers signer of naughty/nice list verifications\n  address public signerAddress;\n  address constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n\n  // Gobbler ID to equipped traits\n  // Traits can be swapped/updated, separate from base artistic traits\n  // Base traits are kept track of off-chain\n  // Each trait type value represents a trait tokenID from GobDrops\n  // 7 trait IDs (uint32) are packed into a single uint256 variable to save on storage costs\n  // Value of 2^32 - 1 means no traits\n  mapping(uint256 => uint256) public equippedTraits;\n  // Total amount of ETH Gobbled per Gobbler ID (in wei)\n  mapping(uint256 => uint256) public ETHGobbled;\n  // Current nonce per signer, prevents signature replay attacks\n  // Backend should query it for creating signatures\n  mapping(address => uint256) public signatureNonce;\n\n  enum Action {\n    Feed, Groom, Sleep\n  }\n\n  /*------------------------------------------------------*/\n  /*                        EVENTS\n  /*------------------------------------------------------*/\n\n  // All actions are event based, the backend handles health logic based on emitted events\n  event Feed(\n    uint256 indexed tokenID,\n    uint8 indexed amount,\n    address indexed owner\n  );\n\n  event Groom(\n    uint256 indexed tokenID,\n    uint8 indexed amount,\n    address indexed owner\n  );\n\n  event Sleep(\n    uint256 indexed tokenID,\n    address indexed owner\n  );\n\n  event Bury(\n    uint256 indexed tokenID,\n    address indexed owner\n  );\n\n  event Mitosis(\n    uint256 indexed parentTokenID,\n    uint256 indexed newTokenID,\n    address indexed owner\n  );    \n\n  event ConfigureTraits(\n    uint256 indexed tokenID,\n    uint256 indexed traitIDs\n  );\n\n  event TraitUnlocked(\n    uint256 indexed parentGobblerID,\n    uint256 indexed newTraitTokenID,\n    address indexed owner\n  );\n\n  event GobblerGobbled(\n    uint256 indexed gobblerGobblerID,\n    uint256 indexed victimID,\n    uint256 indexed newGobblerGobblerID\n  );\n\n  /*------------------------------------------------------*/\n  /*                     CONSTRUCTOR\n  /*------------------------------------------------------*/\n\n  constructor(address signer) ERC721(\"ETH GOBBLERS\", \"GOOEY\") Owned(msg.sender){\n    signerAddress = signer;\n    gobDrops = new GobDrops(msg.sender);\n  }\n\n  modifier onlyTokenOwner(uint256 tokenID, address holder) {\n    require(ownerOf(tokenID) == holder, \"Must be token owner\");\n    _;\n  }\n\n  /*------------------------------------------------------*/\n  /*                     USER ACTIONS\n  /*------------------------------------------------------*/\n\n  /// @notice Mint a gobbler. Must be on the Omakasea Naughty or Nice list to participate\n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function mint(\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external {\n    // Free mint\n    require(totalSupply + 1 <= genesisMaxSupply, \"Genesis max supply reached\");\n    // must not be paused\n    require(!paused, \"Must not be paused\");\n    // Naughty/nice list checks\n    // The message should contain the msg sender, this contract address, function name sig and sig nonce\n    require(\n      hashMessage(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"mint\")),\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    _mint(msg.sender, totalSupply);\n\n    unchecked {\n      totalSupply++;\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Feed, Groom or Sleep - any action invoked while the gobbler is alive\n  /// @param action The action to invoke \n  /// @param tokenID The Gobbler tokenID to use \n  /// @param amount The of times the action should be invoked \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function actionAlive(\n    Action action,\n    uint256 tokenID,\n    uint8 amount,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external payable onlyTokenOwner(tokenID, msg.sender) {\n    // Checks required, valid message hash and signature only produced if health is above 0%\n    // This smart contract has no notion of health, which is entirely managed off chain\n    // The message should contain the msg sender, this contract address, function name sig and sig nonce\n    require(\n      hashMessage(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"actionAlive\")),\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n\n    if (action == Action.Feed) {\n      require(msg.value == feedPrice * amount, \"Not enough ETH Sent\");\n      emit Feed(tokenID, amount, msg.sender);\n    } else if (action == Action.Groom) {\n      require(msg.value == groomPrice * amount, \"Not enough ETH Sent\");\n      emit Groom(tokenID, amount, msg.sender);\n    } else if (action == Action.Sleep) {\n      require(msg.value == sleepPrice, \"Not enough ETH Sent\"); \n      emit Sleep(tokenID, msg.sender);\n    }\n\n    unchecked {\n      ETHGobbled[tokenID] += msg.value;\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Bury a gobbler, sending it to the burn address, eliminating it from supply permanently. Only possible if health is at 0\n  /// @param tokenID The Gobbler tokenID to use \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function bury(\n    uint256 tokenID,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external {\n    // Checks required, valid message hash and signature only produced if health is 0%\n    // This smart contract has no notion of health, which is entirely managed off chain\n    // The message should contain the msg sender, this contract address, function name sig, the tokenID and sig nonce\n    require(\n      hashMessageBury(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"bury\")),\n        tokenID,\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    address currentOwner = ownerOf(tokenID);\n\n    /*-----------ERC721-----------*/\n    // custom burn logic, sends to DEAD address\n    require(currentOwner != address(0), \"NOT_MINTED\");\n    unchecked {\n      _balanceOf[currentOwner]--;\n      _balanceOf[burnAddress]++;\n    }\n    _ownerOf[tokenID] = burnAddress;\n    delete getApproved[tokenID];\n    emit Transfer(currentOwner, burnAddress, tokenID);\n    /*-----------ERC721-----------*/\n\n    emit Bury(tokenID, msg.sender);\n    unchecked {\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Current gobbler divides into another one\n  /// @param tokenID The Gobbler tokenID to use \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  /// @dev should not be invoked until all 2000 genesis are minted\n  function mitosis(\n    uint256 tokenID,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external onlyTokenOwner(tokenID, msg.sender) {\n    // Checks required, valid message hash and signature only produced if certain actions have been called a number of times\n    // Action counts are tracked by emitted events\n    // The message should contain the msg sender, this contract address, function name and sig nonce\n    require(\n      hashMessage(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"mitosis\")),\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    // token IDs for mitosis gobblers start at ID 2000\n    uint newTokenID = genesisMaxSupply + mitosisSupply;\n\n    _mint(msg.sender, newTokenID);\n\n    emit Mitosis(\n      tokenID,\n      newTokenID,\n      msg.sender\n    );\n\n    unchecked {\n      mitosisSupply++;\n      totalSupply++;\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Configure NFT traits for the gobbler\n  /// @param tokenID The Gobbler tokenID to use \n  /// @param traitIDs The token IDs of traits to equip (packed into one uint256) \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function configureTraits(\n    uint256 tokenID,\n    uint256 traitIDs,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external onlyTokenOwner(tokenID, msg.sender) {\n    // checks required, cannot casually call this function from etherscan\n    // The message should contain the msg sender, this contract address, function name, trait IDs and sig nonce\n    require(\n      hashMessageConfigureTraits(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"configureTraits\")),\n        traitIDs,\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    equippedTraits[tokenID] = traitIDs;\n\n    emit ConfigureTraits(\n      tokenID,\n      traitIDs\n    );\n\n    unchecked {\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Unlock a new NFT trait\n  /// @param tokenID The Gobbler tokenID to use \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function unlockTrait(\n    uint256 tokenID,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external onlyTokenOwner(tokenID, msg.sender) {\n    \n    // checks required, valid signature and message hash only produced if certain actions have been called a number of times\n    // The message should contain the msg sender, this contract address, function name sig, and sig nonce\n    require(\n      hashMessage(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"unlockTrait\")),\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    uint newTraitTokenID = gobDrops.totalSupply();\n    gobDrops.mint(msg.sender);\n\n    emit TraitUnlocked(\n      tokenID,\n      newTraitTokenID,\n      msg.sender\n    );\n\n    unchecked {\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /// @notice Gobble (steal) another gobbler. Must be the Gobbler Gobbler\n  /// @param gobblerGobblerTokenID The token ID of the current Gobbler Gobbler \n  /// @param victimTokenID The token ID of the Gobbler to be gobbled \n  /// @param newGobblerGobbler The token ID of the new Gobbler Gobbler \n  /// @param messageHash Hash of message created by the backend\n  /// @param signature Signature of message hash signed by the ETH Gobblers admin address\n  function gobbleGobbler(\n    uint256 gobblerGobblerTokenID,\n    uint256 victimTokenID,\n    uint256 newGobblerGobbler,\n    bytes32 messageHash,\n    bytes calldata signature\n  ) external payable onlyTokenOwner(gobblerGobblerTokenID, msg.sender) {\n    require(currentGobblerGobbler == gobblerGobblerTokenID, \"Must be the Gobbler Gobbler!\");\n    require(msg.value == gobbleGobblerPrice, \"Not enough ETH sent!\");\n\n    require(\n      hashMessageGobbleGobbler(\n        msg.sender,\n        address(this),\n        bytes4(abi.encodePacked(\"gobbleGobbler\")),\n        newGobblerGobbler,\n        signatureNonce[msg.sender]\n      ) == messageHash, \"Wrong message hash!\"\n    );\n    require(verifyAddressSigner(messageHash, signature), \"Invalid address signer\");\n\n    address currentOwnerOfVictim = ownerOf(victimTokenID);\n\n    /*-----------ERC721-----------*/\n    unchecked {\n      _balanceOf[currentOwnerOfVictim]--;\n      _balanceOf[msg.sender]++;\n    }\n    _ownerOf[victimTokenID] = msg.sender;\n    delete getApproved[victimTokenID];\n    emit Transfer(currentOwnerOfVictim, msg.sender, victimTokenID);\n    /*-----------ERC721-----------*/\n\n    emit GobblerGobbled(\n      gobblerGobblerTokenID,\n      victimTokenID,\n      newGobblerGobbler\n    );\n\n    currentGobblerGobbler = newGobblerGobbler;\n\n    unchecked {\n      signatureNonce[msg.sender]++;\n    }\n  }\n\n  /*------------------------------------------------------*/\n  /*                        ADMIN\n  /*------------------------------------------------------*/\n\n  function changeFeedPrice(uint256 price) external onlyOwner {\n    feedPrice = price;\n  }\n\n  function changeGroomPrice(uint256 price) external onlyOwner {\n    groomPrice = price;\n  }\n  \n  function changeSleepPrice(uint256 price) external onlyOwner {\n    sleepPrice = price;\n  }\n\n  function changeGobbleGobblerPrice(uint256 price) external onlyOwner {\n    gobbleGobblerPrice = price;\n  }\n\n  function setGobblerGobbler(uint256 tokenID) external onlyOwner {\n    currentGobblerGobbler = tokenID;\n  }\n\n  function changeBaseURI(string calldata newBaseURI) external onlyOwner {\n      baseURI = newBaseURI;\n  }\n\n  function changeSigner(address signer) external onlyOwner {\n      signerAddress = signer;\n  }\n\n  function flipPaused() external onlyOwner {\n      paused = !paused;\n  }\n\n  /*------------------------------------------------------*/\n  /*                      READ ONLY\n  /*------------------------------------------------------*/\n\n  function getTraitConfiguration(uint256 tokenID) external view returns (\n    uint32 wings,\n    uint32 sidekick,\n    uint32 food,\n    uint32 accessory,\n    uint32 weather,\n    uint32 cushion,\n    uint32 inflight,\n    uint32 freeSlot\n  ) {\n    uint256 currentTraits = equippedTraits[tokenID];\n\n    assembly {\n      wings := and(shr(0xE0, currentTraits), 0xffffffff)\n      sidekick := and(shr(0xC0, currentTraits), 0xffffffff)\n      food := and(shr(0xA0, currentTraits), 0xffffffff)\n      accessory := and(shr(0x80, currentTraits), 0xffffffff)\n      weather := and(shr(0x60, currentTraits), 0xffffffff)\n      cushion := and(shr(0x40, currentTraits), 0xffffffff)\n      inflight := and(shr(0x20, currentTraits), 0xffffffff)\n      freeSlot := and(currentTraits, 0xffffffff)\n    }\n  }\n\n  function tokenURI(uint tokenID) public view override returns (string memory) {\n      require(tokenID < totalSupply, \"This token does not exist\");\n      return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenID.toString())) : \"\";\n  }\n\n  function verifyAddressSigner(bytes32 messageHash, bytes calldata signature) private view returns (bool) {\n    address recovery = messageHash.toEthSignedMessageHash().recover(signature);\n    return signerAddress == recovery;\n  }\n\n  function hashMessage(address sender, address thisContract, bytes4 functionNameSig, uint256 nonce) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(sender, thisContract, functionNameSig, nonce));\n  }\n\n  // special hash message for trait configuration function\n  function hashMessageConfigureTraits(address sender, address thisContract, bytes4 functionNameSig, uint256 traitIDs, uint256 nonce) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(sender, thisContract, functionNameSig, traitIDs, nonce));\n  }\n\n  // special hash message for bury function\n  function hashMessageBury(address sender, address thisContract, bytes4 functionNameSig, uint256 tokenID, uint256 nonce) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(sender, thisContract, functionNameSig, tokenID, nonce));\n  }\n\n  // special hash message for gobble gobbler function\n  function hashMessageGobbleGobbler(address sender, address thisContract, bytes4 functionNameSig, uint256 newGobblerGobbler, uint256 nonce) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(sender, thisContract, functionNameSig, newGobblerGobbler, nonce));\n  }\n\n  /*------------------------------------------------------*/\n  /*                      WITHDRAW\n  /*------------------------------------------------------*/\n\n  function withdraw() external onlyOwner {\n    assembly {\n        let result := call(0, caller(), selfbalance(), 0, 0, 0, 0)\n        switch result\n        case 0 { revert(0, 0) }\n        default { return(0, 0) }\n    }\n  }\n}"
18     },
19     "src/GobDrops.sol": {
20       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.15;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/auth/Owned.sol\";\nimport \"solady/utils/LibString.sol\";\n\n/// @title GobDrops\n/// @author EtDu\n\ncontract GobDrops is ERC721, Owned {\n  using LibString for uint256;\n\n  uint256 public totalSupply = 0;\n  string public baseURI;\n  address public admin;\n\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Must be admin!\");\n    _;\n  }\n\n  constructor(address adminAddress) ERC721(\"GOB DROPS\", \"DROP\") Owned(msg.sender) {\n    admin = adminAddress;\n  }\n\n  /// @notice Mint new trait. Only callable by ETH Gobblers contract on trait unlock.\n  /// @param user User address to claim the NFT trait.\n  function mint(address user) external onlyOwner {\n    _mint(user, totalSupply);\n    unchecked {\n      totalSupply++;\n    }\n  }\n\n  function tokenURI(uint tokenID) public view override returns (string memory) {\n    require(tokenID < totalSupply, \"This token does not exist\");\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenID.toString())) : \"\";\n  }\n\n  function changeBaseURI(string calldata newBaseURI) external onlyAdmin {\n    baseURI = newBaseURI;\n  }\n\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    admin = newAdmin;\n  }\n\n  function withdraw() external onlyAdmin {\n    assembly {\n        let result := call(0, caller(), selfbalance(), 0, 0, 0, 0)\n        switch result\n        case 0 { revert(0, 0) }\n        default { return(0, 0) }\n    }\n  }\n}"
21     }
22   },
23   "settings": {
24     "remappings": [
25       "ds-test/=lib/solmate/lib/ds-test/src/",
26       "forge-std/=lib/forge-std/src/",
27       "solady/=lib/solady/src/",
28       "solmate/=lib/solmate/src/"
29     ],
30     "optimizer": {
31       "enabled": true,
32       "runs": 200
33     },
34     "metadata": {
35       "bytecodeHash": "ipfs"
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "devdoc",
43           "userdoc",
44           "metadata",
45           "abi"
46         ]
47       }
48     },
49     "evmVersion": "london",
50     "libraries": {}
51   }
52 }}