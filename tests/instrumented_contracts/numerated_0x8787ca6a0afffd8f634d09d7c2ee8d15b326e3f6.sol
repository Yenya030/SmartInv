1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/FeeDistributor.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport {Math} from \"../lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"../lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\";\n\nimport {ERC20} from \"../lib/solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"../lib/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport \"./lib/OptionalOnlyCaller.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IFeeDistributor.sol\";\n\n// solhint-disable not-rely-on-time\n\n/**\n * @title FeeDistributor\n * @author opnxj - Modified from ZeframLou/fee-distributor: https://github.com/ZeframLou/fee-distributor\n * @notice Distributes any tokens transferred to the contract (e.g. Protocol fees and any token emissions) among vetoken\n * holders proportionally based on a snapshot of the week at which the tokens are sent to the FeeDistributor contract.\n * @dev Supports distributing arbitrarily many different tokens. In order to start distributing a new token to vetoken\n * holders simply transfer the tokens to the `FeeDistributor` contract and then call `checkpointToken`.\n */\ncontract FeeDistributor is\n    IFeeDistributor,\n    OptionalOnlyCaller,\n    ReentrancyGuard\n{\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for ERC20;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error FeeDistributor__InputLengthMismatch();\n    error FeeDistributor__VotingEscrowZeroTotalSupply();\n    error FeeDistributor__CannotStartBeforeCurrentWeek();\n\n    /// -----------------------------------------------------------------------\n    /// Immutable params\n    /// -----------------------------------------------------------------------\n\n    uint256 private immutable _startTime;\n    IVotingEscrow private immutable _votingEscrow;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    // Global State\n    uint256 private _timeCursor;\n    mapping(uint256 => uint256) private _veSupplyCache;\n\n    // Token State\n\n    // `startTime` and `timeCursor` are both timestamps so comfortably fit in a uint64.\n    // `cachedBalance` will comfortably fit the total supply of any meaningful token.\n    // Should more than 2^128 tokens be sent to this contract then checkpointing this token will fail until enough\n    // tokens have been claimed to bring the total balance back below 2^128.\n    struct TokenState {\n        uint64 startTime;\n        uint64 timeCursor;\n        uint128 cachedBalance;\n    }\n\n    mapping(ERC20 => TokenState) private _tokenState;\n    mapping(ERC20 => mapping(uint256 => uint256)) private _tokensPerWeek;\n\n    // User State\n\n    // `startTime` and `timeCursor` are timestamps so will comfortably fit in a uint64.\n    // For `lastEpochCheckpointed` to overflow would need over 2^128 transactions to the VotingEscrow contract.\n    struct UserState {\n        uint64 startTime;\n        uint64 timeCursor;\n        uint128 lastEpochCheckpointed;\n    }\n\n    mapping(address => UserState) internal _userState;\n    mapping(address => mapping(uint256 => uint256))\n        private _userBalanceAtTimestamp;\n    mapping(address => mapping(ERC20 => uint256)) private _userTokenTimeCursor;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IVotingEscrow votingEscrow,\n        uint256 startTime\n    ) EIP712(\"FeeDistributor\", \"1\") {\n        _votingEscrow = votingEscrow;\n\n        startTime = _roundDownTimestamp(startTime);\n        uint256 currentWeek = _roundDownTimestamp(block.timestamp);\n        if (startTime < currentWeek) {\n            revert FeeDistributor__CannotStartBeforeCurrentWeek();\n        }\n        if (startTime == currentWeek) {\n            // We assume that `votingEscrow` has been deployed in a week previous to this one.\n            // If `votingEscrow` did not have a non-zero supply at the beginning of the current week\n            // then any tokens which are distributed this week will be lost permanently.\n            if (_veTotalSupply(currentWeek) == 0) {\n                revert FeeDistributor__VotingEscrowZeroTotalSupply();\n            }\n        }\n        _startTime = startTime;\n        _timeCursor = startTime;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// View functions\n    /// -----------------------------------------------------------------------\n\n    /**\n     * @notice Returns the VotingEscrow (vetoken) token contract\n     */\n    function getVotingEscrow() external view override returns (IVotingEscrow) {\n        return _votingEscrow;\n    }\n\n    /**\n     * @notice Returns the global time cursor representing the most earliest uncheckpointed week.\n     */\n    function getTimeCursor() external view override returns (uint256) {\n        return _timeCursor;\n    }\n\n    /**\n     * @notice Returns the user-level time cursor representing the most earliest uncheckpointed week.\n     * @param user - The address of the user to query.\n     */\n    function getUserTimeCursor(\n        address user\n    ) external view override returns (uint256) {\n        return _userState[user].timeCursor;\n    }\n\n    /**\n     * @notice Returns the token-level time cursor storing the timestamp at up to which tokens have been distributed.\n     * @param token - The ERC20 token address to query.\n     */\n    function getTokenTimeCursor(\n        ERC20 token\n    ) external view override returns (uint256) {\n        return _tokenState[token].timeCursor;\n    }\n\n    /**\n     * @notice Returns the user-level time cursor storing the timestamp of the latest token distribution claimed.\n     * @param user - The address of the user to query.\n     * @param token - The ERC20 token address to query.\n     */\n    function getUserTokenTimeCursor(\n        address user,\n        ERC20 token\n    ) external view override returns (uint256) {\n        return _getUserTokenTimeCursor(user, token);\n    }\n\n    /**\n     * @notice Returns the user's cached balance of vetoken as of the provided timestamp.\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\n     * This function requires `user` to have been checkpointed past `timestamp` so that their balance is cached.\n     * @param user - The address of the user of which to read the cached balance of.\n     * @param timestamp - The timestamp at which to read the `user`'s cached balance at.\n     */\n    function getUserBalanceAtTimestamp(\n        address user,\n        uint256 timestamp\n    ) external view override returns (uint256) {\n        return _userBalanceAtTimestamp[user][timestamp];\n    }\n\n    /**\n     * @notice Returns the cached total supply of vetoken as of the provided timestamp.\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\n     * This function requires the contract to have been checkpointed past `timestamp` so that the supply is cached.\n     * @param timestamp - The timestamp at which to read the cached total supply at.\n     */\n    function getTotalSupplyAtTimestamp(\n        uint256 timestamp\n    ) external view override returns (uint256) {\n        return _veSupplyCache[timestamp];\n    }\n\n    /**\n     * @notice Returns the FeeDistributor's cached balance of `token`.\n     */\n    function getTokenLastBalance(\n        ERC20 token\n    ) external view override returns (uint256) {\n        return _tokenState[token].cachedBalance;\n    }\n\n    /**\n     * @notice Returns the amount of `token` which the FeeDistributor received in the week beginning at `timestamp`.\n     * @param token - The ERC20 token address to query.\n     * @param timestamp - The timestamp corresponding to the beginning of the week of interest.\n     */\n    function getTokensDistributedInWeek(\n        ERC20 token,\n        uint256 timestamp\n    ) external view override returns (uint256) {\n        return _tokensPerWeek[token][timestamp];\n    }\n\n    /// -----------------------------------------------------------------------\n    /// User actions\n    /// -----------------------------------------------------------------------\n\n    // Depositing\n\n    /**\n     * @notice Deposits tokens to be distributed in the current week.\n     * @dev Sending tokens directly to the FeeDistributor instead of using `depositToken` may result in tokens being\n     * retroactively distributed to past weeks, or for the distribution to carry over to future weeks.\n     *\n     * If for some reason `depositToken` cannot be called, in order to ensure that all tokens are correctly distributed\n     * manually call `checkpointToken` before and after the token transfer.\n     * @param token - The ERC20 token address to distribute.\n     * @param amount - The amount of tokens to deposit.\n     */\n    function depositToken(\n        ERC20 token,\n        uint256 amount\n    ) external override nonReentrant {\n        _checkpointToken(token, false);\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _checkpointToken(token, true);\n    }\n\n    /**\n     * @notice Deposits tokens to be distributed in the current week.\n     * @dev A version of `depositToken` which supports depositing multiple `tokens` at once.\n     * See `depositToken` for more details.\n     * @param tokens - An array of ERC20 token addresses to distribute.\n     * @param amounts - An array of token amounts to deposit.\n     */\n    function depositTokens(\n        ERC20[] calldata tokens,\n        uint256[] calldata amounts\n    ) external override nonReentrant {\n        if (tokens.length != amounts.length) {\n            revert FeeDistributor__InputLengthMismatch();\n        }\n\n        uint256 length = tokens.length;\n        for (uint256 i = 0; i < length; ) {\n            _checkpointToken(tokens[i], false);\n            tokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\n            _checkpointToken(tokens[i], true);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // Checkpointing\n\n    /**\n     * @notice Caches the total supply of vetoken at the beginning of each week.\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     */\n    function checkpoint() external override nonReentrant {\n        _checkpointTotalSupply();\n    }\n\n    /**\n     * @notice Caches the user's balance of vetoken at the beginning of each week.\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     * @param user - The address of the user to be checkpointed.\n     */\n    function checkpointUser(address user) external override nonReentrant {\n        _checkpointUserBalance(user);\n    }\n\n    /**\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\n     * @dev Any `token` balance held by the FeeDistributor above that which is returned by `getTokenLastBalance`\n     * will be distributed evenly across the time period since `token` was last checkpointed.\n     *\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     * @param token - The ERC20 token address to be checkpointed.\n     */\n    function checkpointToken(ERC20 token) external override nonReentrant {\n        _checkpointToken(token, true);\n    }\n\n    /**\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\n     * @dev A version of `checkpointToken` which supports checkpointing multiple tokens.\n     * See `checkpointToken` for more details.\n     * @param tokens - An array of ERC20 token addresses to be checkpointed.\n     */\n    function checkpointTokens(\n        ERC20[] calldata tokens\n    ) external override nonReentrant {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i = 0; i < tokensLength; ) {\n            _checkpointToken(tokens[i], true);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // Claiming\n\n    /**\n     * @notice Claims all pending distributions of the provided token for a user.\n     * @dev It's not necessary to explicitly checkpoint before calling this function, it will ensure the FeeDistributor\n     * is up to date before calculating the amount of tokens to be claimed.\n     * @param user - The user on behalf of which to claim.\n     * @param token - The ERC20 token address to be claimed.\n     * @return The amount of `token` sent to `user` as a result of claiming.\n     */\n    function claimToken(\n        address user,\n        ERC20 token\n    )\n        external\n        override\n        nonReentrant\n        optionalOnlyCaller(user)\n        returns (uint256)\n    {\n        _checkpointTotalSupply();\n        _checkpointUserBalance(user);\n        _checkpointToken(token, false);\n\n        uint256 amount = _claimToken(user, token);\n        return amount;\n    }\n\n    /**\n     * @notice Claims a number of tokens on behalf of a user.\n     * @dev A version of `claimToken` which supports claiming multiple `tokens` on behalf of `user`.\n     * See `claimToken` for more details.\n     * @param user - The user on behalf of which to claim.\n     * @param tokens - An array of ERC20 token addresses to be claimed.\n     * @return An array of the amounts of each token in `tokens` sent to `user` as a result of claiming.\n     */\n    function claimTokens(\n        address user,\n        ERC20[] calldata tokens\n    )\n        external\n        override\n        nonReentrant\n        optionalOnlyCaller(user)\n        returns (uint256[] memory)\n    {\n        _checkpointTotalSupply();\n        _checkpointUserBalance(user);\n\n        uint256 tokensLength = tokens.length;\n        uint256[] memory amounts = new uint256[](tokensLength);\n        for (uint256 i = 0; i < tokensLength; ) {\n            _checkpointToken(tokens[i], false);\n            amounts[i] = _claimToken(user, tokens[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return amounts;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal functions\n    /// -----------------------------------------------------------------------\n\n    /**\n     * @dev It is required that both the global, token and user state have been properly checkpointed\n     * before calling this function.\n     */\n    function _claimToken(address user, ERC20 token) internal returns (uint256) {\n        TokenState storage tokenState = _tokenState[token];\n        uint256 nextUserTokenWeekToClaim = _getUserTokenTimeCursor(user, token);\n\n        // The first week which cannot be correctly claimed is the earliest of:\n        // - A) The global or user time cursor (whichever is earliest), rounded up to the end of the week.\n        // - B) The token time cursor, rounded down to the beginning of the week.\n        //\n        // This prevents the two failure modes:\n        // - A) A user may claim a week for which we have not processed their balance, resulting in tokens being locked.\n        // - B) A user may claim a week which then receives more tokens to be distributed. However the user has\n        //      already claimed for that week so their share of these new tokens are lost.\n        uint256 firstUnclaimableWeek = Math.min(\n            _roundUpTimestamp(\n                Math.min(_timeCursor, _userState[user].timeCursor)\n            ),\n            _roundDownTimestamp(tokenState.timeCursor)\n        );\n\n        mapping(uint256 => uint256) storage tokensPerWeek = _tokensPerWeek[\n            token\n        ];\n        mapping(uint256 => uint256)\n            storage userBalanceAtTimestamp = _userBalanceAtTimestamp[user];\n\n        uint256 amount;\n        for (uint256 i = 0; i < 20; ) {\n            // We clearly cannot claim for `firstUnclaimableWeek` and so we break here.\n            if (nextUserTokenWeekToClaim >= firstUnclaimableWeek) break;\n\n            unchecked {\n                amount +=\n                    (tokensPerWeek[nextUserTokenWeekToClaim] *\n                        userBalanceAtTimestamp[nextUserTokenWeekToClaim]) /\n                    _veSupplyCache[nextUserTokenWeekToClaim];\n                nextUserTokenWeekToClaim += 1 weeks;\n                ++i;\n            }\n        }\n        // Update the stored user-token time cursor to prevent this user claiming this week again.\n        _userTokenTimeCursor[user][token] = nextUserTokenWeekToClaim;\n\n        if (amount > 0) {\n            unchecked {\n                // For a token to be claimable it must have been added to the cached balance so this is safe.\n                tokenState.cachedBalance = uint128(\n                    tokenState.cachedBalance - amount\n                );\n            }\n\n            token.safeTransfer(user, amount);\n            emit TokensClaimed(user, token, amount, nextUserTokenWeekToClaim);\n        }\n\n        return amount;\n    }\n\n    /**\n     * @dev Calculate the amount of `token` to be distributed to `_votingEscrow` holders since the last checkpoint.\n     */\n    function _checkpointToken(ERC20 token, bool force) internal {\n        TokenState storage tokenState = _tokenState[token];\n        uint256 lastTokenTime = tokenState.timeCursor;\n        uint256 timeSinceLastCheckpoint;\n        if (lastTokenTime == 0) {\n            // If it's the first time we're checkpointing this token then start distributing from now.\n            // Also mark at which timestamp users should start attempts to claim this token from.\n            lastTokenTime = block.timestamp;\n            tokenState.startTime = uint64(_roundDownTimestamp(block.timestamp));\n\n            // Prevent someone from assigning tokens to an inaccessible week.\n            require(\n                block.timestamp > _startTime,\n                \"Fee distribution has not started yet\"\n            );\n        } else {\n            unchecked {\n                timeSinceLastCheckpoint = block.timestamp - lastTokenTime;\n\n                if (!force) {\n                    // Checkpointing N times within a single week is completely equivalent to checkpointing once at the end.\n                    // We then want to get as close as possible to a single checkpoint every Wed 23:59 UTC to save gas.\n\n                    // We then skip checkpointing if we're in the same week as the previous checkpoint.\n                    bool alreadyCheckpointedThisWeek = _roundDownTimestamp(\n                        block.timestamp\n                    ) == _roundDownTimestamp(lastTokenTime);\n                    // However we want to ensure that all of this week's fees are assigned to the current week without\n                    // overspilling into the next week. To mitigate this, we checkpoint if we're near the end of the week.\n                    bool nearingEndOfWeek = _roundUpTimestamp(block.timestamp) -\n                        block.timestamp <\n                        1 days;\n\n                    // This ensures that we checkpoint once at the beginning of the week and again for each user interaction\n                    // towards the end of the week to give an accurate final reading of the balance.\n                    if (alreadyCheckpointedThisWeek && !nearingEndOfWeek) {\n                        return;\n                    }\n                }\n            }\n        }\n\n        tokenState.timeCursor = uint64(block.timestamp);\n\n        uint256 tokenBalance = token.balanceOf(address(this));\n        uint256 newTokensToDistribute = tokenBalance - tokenState.cachedBalance;\n        if (newTokensToDistribute == 0) return;\n        require(\n            tokenBalance <= type(uint128).max,\n            \"Maximum token balance exceeded\"\n        );\n        tokenState.cachedBalance = uint128(tokenBalance);\n\n        uint256 firstIncompleteWeek = _roundDownTimestamp(lastTokenTime);\n        uint256 nextWeek = 0;\n\n        // Distribute `newTokensToDistribute` evenly across the time period from `lastTokenTime` to now.\n        // These tokens are assigned to weeks proportionally to how much of this period falls into each week.\n        mapping(uint256 => uint256) storage tokensPerWeek = _tokensPerWeek[\n            token\n        ];\n        for (uint256 i = 0; i < 20; ) {\n            unchecked {\n                // This is safe as we're incrementing a timestamp.\n                nextWeek = firstIncompleteWeek + 1 weeks;\n                if (block.timestamp < nextWeek) {\n                    // `firstIncompleteWeek` is now the beginning of the current week, i.e. this is the final iteration.\n                    if (\n                        timeSinceLastCheckpoint == 0 &&\n                        block.timestamp == lastTokenTime\n                    ) {\n                        tokensPerWeek[\n                            firstIncompleteWeek\n                        ] += newTokensToDistribute;\n                    } else {\n                        // block.timestamp >= lastTokenTime by definition.\n                        tokensPerWeek[firstIncompleteWeek] +=\n                            (newTokensToDistribute *\n                                (block.timestamp - lastTokenTime)) /\n                            timeSinceLastCheckpoint;\n                    }\n                    // As we've caught up to the present then we should now break.\n                    break;\n                } else {\n                    // We've gone a full week or more without checkpointing so need to distribute tokens to previous weeks.\n                    if (\n                        timeSinceLastCheckpoint == 0 &&\n                        nextWeek == lastTokenTime\n                    ) {\n                        // It shouldn't be possible to enter this block\n                        tokensPerWeek[\n                            firstIncompleteWeek\n                        ] += newTokensToDistribute;\n                    } else {\n                        // nextWeek > lastTokenTime by definition.\n                        tokensPerWeek[firstIncompleteWeek] +=\n                            (newTokensToDistribute *\n                                (nextWeek - lastTokenTime)) /\n                            timeSinceLastCheckpoint;\n                    }\n                }\n\n                // We've now \"checkpointed\" up to the beginning of next week so must update timestamps appropriately.\n                lastTokenTime = nextWeek;\n                firstIncompleteWeek = nextWeek;\n\n                ++i;\n            }\n        }\n\n        emit TokenCheckpointed(token, newTokensToDistribute, lastTokenTime);\n    }\n\n    /**\n     * @dev Cache the `user`'s balance of `_votingEscrow` at the beginning of each new week\n     */\n    function _checkpointUserBalance(address user) internal {\n        uint256 maxUserEpoch = _votingEscrow.user_point_epoch(user);\n\n        // If user has no epochs then they have never locked vetoken.\n        // They clearly will not then receive fees.\n        if (maxUserEpoch == 0) return;\n\n        UserState storage userState = _userState[user];\n\n        // `nextWeekToCheckpoint` represents the timestamp of the beginning of the first week\n        // which we haven't checkpointed the user's VotingEscrow balance yet.\n        uint256 nextWeekToCheckpoint = userState.timeCursor;\n\n        uint256 userEpoch;\n        if (nextWeekToCheckpoint == 0) {\n            // First checkpoint for user so need to do the initial binary search\n            userEpoch = _findTimestampUserEpoch(\n                user,\n                _startTime,\n                0,\n                maxUserEpoch\n            );\n        } else {\n            if (nextWeekToCheckpoint >= block.timestamp) {\n                // User has checkpointed the current week already so perform early return.\n                // This prevents a user from processing epochs created later in this week, however this is not an issue\n                // as if a significant number of these builds up then the user will skip past them with a binary search.\n                return;\n            }\n\n            // Otherwise use the value saved from last time\n            userEpoch = userState.lastEpochCheckpointed;\n\n            unchecked {\n                // This optimizes a scenario common for power users, which have frequent `VotingEscrow` interactions in\n                // the same week. We assume that any such user is also claiming fees every week, and so we only perform\n                // a binary search here rather than integrating it into the main search algorithm, effectively skipping\n                // most of the week's irrelevant checkpoints.\n                // The slight tradeoff is that users who have multiple infrequent `VotingEscrow` interactions and also don't\n                // claim frequently will also perform the binary search, despite it not leading to gas savings.\n                if (maxUserEpoch - userEpoch > 20) {\n                    userEpoch = _findTimestampUserEpoch(\n                        user,\n                        nextWeekToCheckpoint,\n                        userEpoch,\n                        maxUserEpoch\n                    );\n                }\n            }\n        }\n\n        // Epoch 0 is always empty so bump onto the next one so that we start on a valid epoch.\n        if (userEpoch == 0) {\n            userEpoch = 1;\n        }\n\n        IVotingEscrow.Point memory nextUserPoint = _votingEscrow\n            .user_point_history(user, userEpoch);\n\n        // If this is the first checkpoint for the user, calculate the first week they're eligible for.\n        // i.e. the timestamp of the first Thursday after they locked.\n        // If this is earlier then the first distribution then fast forward to then.\n        if (nextWeekToCheckpoint == 0) {\n            // Disallow checkpointing before `startTime`.\n            require(\n                block.timestamp > _startTime,\n                \"Fee distribution has not started yet\"\n            );\n            nextWeekToCheckpoint = Math.max(\n                _startTime,\n                _roundUpTimestamp(nextUserPoint.ts)\n            );\n            userState.startTime = uint64(nextWeekToCheckpoint);\n        }\n\n        // It's safe to increment `userEpoch` and `nextWeekToCheckpoint` in this loop as epochs and timestamps\n        // are always much smaller than 2^256 and are being incremented by small values.\n        IVotingEscrow.Point memory currentUserPoint;\n        for (uint256 i = 0; i < 50; ) {\n            unchecked {\n                if (\n                    nextWeekToCheckpoint >= nextUserPoint.ts &&\n                    userEpoch <= maxUserEpoch\n                ) {\n                    // The week being considered is contained in a user epoch after that described by `currentUserPoint`.\n                    // We then shift `nextUserPoint` into `currentUserPoint` and query the Point for the next user epoch.\n                    // We do this in order to step though epochs until we find the first epoch starting after\n                    // `nextWeekToCheckpoint`, making the previous epoch the one that contains `nextWeekToCheckpoint`.\n                    userEpoch += 1;\n                    currentUserPoint = nextUserPoint;\n                    if (userEpoch > maxUserEpoch) {\n                        nextUserPoint = IVotingEscrow.Point(0, 0, 0, 0);\n                    } else {\n                        nextUserPoint = _votingEscrow.user_point_history(\n                            user,\n                            userEpoch\n                        );\n                    }\n                } else {\n                    // The week being considered lies inside the user epoch described by `oldUserPoint`\n                    // we can then use it to calculate the user's balance at the beginning of the week.\n                    if (nextWeekToCheckpoint >= block.timestamp) {\n                        // Break if we're trying to cache the user's balance at a timestamp in the future.\n                        // We only perform this check here to ensure that we can still process checkpoints created\n                        // in the current week.\n                        break;\n                    }\n\n                    int128 dt = SafeCast.toInt128(\n                        SafeCast.toInt256(\n                            nextWeekToCheckpoint - currentUserPoint.ts\n                        )\n                    );\n                    uint256 userBalance = currentUserPoint.bias >\n                        currentUserPoint.slope * dt\n                        ? uint256(\n                            SafeCast.toUint256(\n                                currentUserPoint.bias -\n                                    currentUserPoint.slope *\n                                    dt\n                            )\n                        )\n                        : 0;\n\n                    // User's lock has expired and they haven't relocked yet.\n                    if (userBalance == 0 && userEpoch > maxUserEpoch) {\n                        nextWeekToCheckpoint = _roundUpTimestamp(\n                            block.timestamp\n                        );\n                        break;\n                    }\n\n                    // User had a nonzero lock and so is eligible to collect fees.\n                    _userBalanceAtTimestamp[user][\n                        nextWeekToCheckpoint\n                    ] = userBalance;\n\n                    nextWeekToCheckpoint += 1 weeks;\n                }\n\n                ++i;\n            }\n        }\n\n        // We subtract off 1 from the userEpoch to step back once so that on the next attempt to checkpoint\n        // the current `currentUserPoint` will be loaded as `nextUserPoint`. This ensures that we can't skip over the\n        // user epoch containing `nextWeekToCheckpoint`.\n        unchecked {\n            // userEpoch > 0 so this is safe.\n            userState.lastEpochCheckpointed = uint64(userEpoch - 1);\n        }\n        userState.timeCursor = uint64(nextWeekToCheckpoint);\n    }\n\n    /**\n     * @notice Calculate total voting power at some point in the past\n     * @param point The point (bias/slope) to start search from\n     * @param t Time to calculate the total voting power at\n     * @return Total voting power at that time\n     */\n    function _supplyAt(\n        IVotingEscrow.Point memory point,\n        uint256 t\n    ) internal view returns (uint256) {\n        IVotingEscrow.Point memory lastPoint = point;\n        uint tI = _roundDownTimestamp(lastPoint.ts);\n        for (uint i = 0; i < 255; ++i) {\n            tI += 1 weeks;\n            int128 dSlope = 0;\n            if (tI > t) {\n                tI = t;\n            } else {\n                dSlope = IVotingEscrow(_votingEscrow).slope_changes(tI);\n            }\n            lastPoint.bias -=\n                lastPoint.slope *\n                int128(int(tI) - int(lastPoint.ts));\n            if (tI == t) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = tI;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint(uint128(lastPoint.bias));\n    }\n\n    /**\n     * @dev Provides a better implementation of VE.totalSupplyAtT\n     */\n    function _veTotalSupply(uint256 timestamp) internal view returns (uint256) {\n        uint256 _epoch = IVotingEscrow(_votingEscrow).epoch();\n        IVotingEscrow.Point memory lastPoint = IVotingEscrow(_votingEscrow)\n            .point_history(_epoch);\n        return _supplyAt(lastPoint, timestamp);\n    }\n\n    /**\n     * @dev Cache the totalSupply of VotingEscrow token at the beginning of each new week\n     */\n    function _checkpointTotalSupply() internal {\n        uint256 nextWeekToCheckpoint = _timeCursor;\n        uint256 weekStart = _roundDownTimestamp(block.timestamp);\n\n        // We expect `timeCursor == weekStart + 1 weeks` when fully up to date.\n        if (nextWeekToCheckpoint > weekStart || weekStart == block.timestamp) {\n            // We've already checkpointed up to this week so perform early return\n            return;\n        }\n\n        _votingEscrow.checkpoint();\n\n        // Step through the each week and cache the total supply at beginning of week on this contract\n        for (uint256 i = 0; i < 20; ) {\n            unchecked {\n                if (nextWeekToCheckpoint > weekStart) break;\n\n                _veSupplyCache[nextWeekToCheckpoint] = _veTotalSupply(\n                    nextWeekToCheckpoint\n                );\n\n                // This is safe as we're incrementing a timestamp\n                nextWeekToCheckpoint += 1 weeks;\n\n                ++i;\n            }\n        }\n        // Update state to the end of the current week (`weekStart` + 1 weeks)\n        _timeCursor = nextWeekToCheckpoint;\n    }\n\n    // Helper functions\n\n    /**\n     * @dev Wrapper around `_userTokenTimeCursor` which returns the start timestamp for `token`\n     * if `user` has not attempted to interact with it previously.\n     */\n    function _getUserTokenTimeCursor(\n        address user,\n        ERC20 token\n    ) internal view returns (uint256) {\n        uint256 userTimeCursor = _userTokenTimeCursor[user][token];\n        if (userTimeCursor > 0) return userTimeCursor;\n        // This is the first time that the user has interacted with this token.\n        // We then start from the latest out of either when `user` first locked vetoken or `token` was first checkpointed.\n        return\n            Math.max(_userState[user].startTime, _tokenState[token].startTime);\n    }\n\n    /**\n     * @dev Return the user epoch number for `user` corresponding to the provided `timestamp`\n     */\n    function _findTimestampUserEpoch(\n        address user,\n        uint256 timestamp,\n        uint256 minUserEpoch,\n        uint256 maxUserEpoch\n    ) internal view returns (uint256) {\n        uint256 min = minUserEpoch;\n        uint256 max = maxUserEpoch;\n\n        // Perform binary search through epochs to find epoch containing `timestamp`\n        for (uint256 i = 0; i < 128; ) {\n            unchecked {\n                if (min >= max) break;\n\n                // Algorithm assumes that inputs are less than 2^128 so this operation is safe.\n                // +2 avoids getting stuck in min == mid < max\n                uint256 mid = (min + max + 2) / 2;\n                IVotingEscrow.Point memory pt = _votingEscrow\n                    .user_point_history(user, mid);\n                if (pt.ts <= timestamp) {\n                    min = mid;\n                } else {\n                    // max > min so this is safe.\n                    max = mid - 1;\n                }\n            }\n        }\n        return min;\n    }\n\n    /**\n     * @dev Rounds the provided timestamp down to the beginning of the previous week (Thurs 00:00 UTC)\n     */\n    function _roundDownTimestamp(\n        uint256 timestamp\n    ) private pure returns (uint256) {\n        unchecked {\n            // Division by zero or overflows are impossible here.\n            return (timestamp / 1 weeks) * 1 weeks;\n        }\n    }\n\n    /**\n     * @dev Rounds the provided timestamp up to the beginning of the next week (Thurs 00:00 UTC)\n     */\n    function _roundUpTimestamp(\n        uint256 timestamp\n    ) private pure returns (uint256) {\n        unchecked {\n            // Overflows are impossible here for all realistic inputs.\n            return _roundDownTimestamp(timestamp + 1 weeks - 1);\n        }\n    }\n}\n"
6     },
7     "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
9     },
10     "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
12     },
13     "lib/solmate/src/tokens/ERC20.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
15     },
16     "lib/solmate/src/utils/SafeTransferLib.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
18     },
19     "lib/solmate/src/utils/ReentrancyGuard.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
21     },
22     "src/lib/OptionalOnlyCaller.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"./EOASignaturesValidator.sol\";\nimport \"../interfaces/IOptionalOnlyCaller.sol\";\n\nabstract contract OptionalOnlyCaller is\n    IOptionalOnlyCaller,\n    EOASignaturesValidator\n{\n    error OptionalOnlyCaller__SenderNotAllowed();\n\n    mapping(address => bool) private _isOnlyCallerEnabled;\n\n    uint256 private constant INVALID_SIGNATURE_ERROR = 1;\n    bytes32 private constant _SET_ONLY_CALLER_CHECK_TYPEHASH =\n        keccak256(\n            \"SetOnlyCallerCheck(address user,bool enabled,uint256 nonce)\"\n        );\n\n    /**\n     * @dev Reverts if the verification mechanism is enabled and the given address is not the caller.\n     * @param user - Address to validate as the only allowed caller, if the verification is enabled.\n     */\n    modifier optionalOnlyCaller(address user) {\n        _verifyCaller(user);\n        _;\n    }\n\n    function setOnlyCallerCheck(bool enabled) external override {\n        _setOnlyCallerCheck(msg.sender, enabled);\n    }\n\n    function setOnlyCallerCheckWithSignature(\n        address user,\n        bool enabled,\n        bytes memory signature\n    ) external override {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                _SET_ONLY_CALLER_CHECK_TYPEHASH,\n                user,\n                enabled,\n                getNextNonce(user)\n            )\n        );\n        _ensureValidSignature(\n            user,\n            structHash,\n            signature,\n            INVALID_SIGNATURE_ERROR\n        );\n        _setOnlyCallerCheck(user, enabled);\n    }\n\n    function _setOnlyCallerCheck(address user, bool enabled) private {\n        _isOnlyCallerEnabled[user] = enabled;\n        emit OnlyCallerOptIn(user, enabled);\n    }\n\n    function isOnlyCallerEnabled(\n        address user\n    ) external view override returns (bool) {\n        return _isOnlyCallerEnabled[user];\n    }\n\n    function _verifyCaller(address user) private view {\n        if (_isOnlyCallerEnabled[user]) {\n            if (msg.sender != user) {\n                revert OptionalOnlyCaller__SenderNotAllowed();\n            }\n        }\n    }\n}\n"
24     },
25     "src/interfaces/IVotingEscrow.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.11;\n\npragma experimental ABIEncoderV2;\n\n// For compatibility, we're keeping the same function names as in the original Curve code, including the mixed-case\n// naming convention.\n// solhint-disable func-name-mixedcase\n\ninterface IVotingEscrow {\n    struct Point {\n        int128 bias;\n        int128 slope; // - dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n    }\n\n    function epoch() external view returns (uint256);\n\n    function user_point_epoch(address user) external view returns (uint256);\n\n    function slope_changes(uint256 i) external view returns (int128);\n\n    function point_history(\n        uint256 timestamp\n    ) external view returns (Point memory);\n\n    function user_point_history(\n        address user,\n        uint256 timestamp\n    ) external view returns (Point memory);\n\n    function checkpoint() external;\n}\n"
27     },
28     "src/interfaces/IFeeDistributor.sol": {
29       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"../../lib/solmate/src/tokens/ERC20.sol\";\n\nimport \"./IVotingEscrow.sol\";\n\n/**\n * @title Fee Distributor\n * @notice Distributes any tokens transferred to the contract (e.g. Protocol fees and any BAL emissions) among veBAL\n * holders proportionally based on a snapshot of the week at which the tokens are sent to the FeeDistributor contract.\n * @dev Supports distributing arbitrarily many different tokens. In order to start distributing a new token to veBAL\n * holders simply transfer the tokens to the `FeeDistributor` contract and then call `checkpointToken`.\n */\ninterface IFeeDistributor {\n    event TokenCheckpointed(\n        ERC20 token,\n        uint256 amount,\n        uint256 lastCheckpointTimestamp\n    );\n    event TokensClaimed(\n        address user,\n        ERC20 token,\n        uint256 amount,\n        uint256 userTokenTimeCursor\n    );\n\n    /**\n     * @notice Returns the VotingEscrow (veBAL) token contract\n     */\n    function getVotingEscrow() external view returns (IVotingEscrow);\n\n    /**\n     * @notice Returns the global time cursor representing the most earliest uncheckpointed week.\n     */\n    function getTimeCursor() external view returns (uint256);\n\n    /**\n     * @notice Returns the user-level time cursor representing the most earliest uncheckpointed week.\n     * @param user - The address of the user to query.\n     */\n    function getUserTimeCursor(address user) external view returns (uint256);\n\n    /**\n     * @notice Returns the token-level time cursor storing the timestamp at up to which tokens have been distributed.\n     * @param token - The ERC20 token address to query.\n     */\n    function getTokenTimeCursor(ERC20 token) external view returns (uint256);\n\n    /**\n     * @notice Returns the user-level time cursor storing the timestamp of the latest token distribution claimed.\n     * @param user - The address of the user to query.\n     * @param token - The ERC20 token address to query.\n     */\n    function getUserTokenTimeCursor(\n        address user,\n        ERC20 token\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the user's cached balance of veBAL as of the provided timestamp.\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\n     * This function requires `user` to have been checkpointed past `timestamp` so that their balance is cached.\n     * @param user - The address of the user of which to read the cached balance of.\n     * @param timestamp - The timestamp at which to read the `user`'s cached balance at.\n     */\n    function getUserBalanceAtTimestamp(\n        address user,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the cached total supply of veBAL as of the provided timestamp.\n     * @dev Only timestamps which fall on Thursdays 00:00:00 UTC will return correct values.\n     * This function requires the contract to have been checkpointed past `timestamp` so that the supply is cached.\n     * @param timestamp - The timestamp at which to read the cached total supply at.\n     */\n    function getTotalSupplyAtTimestamp(\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the FeeDistributor's cached balance of `token`.\n     */\n    function getTokenLastBalance(ERC20 token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of `token` which the FeeDistributor received in the week beginning at `timestamp`.\n     * @param token - The ERC20 token address to query.\n     * @param timestamp - The timestamp corresponding to the beginning of the week of interest.\n     */\n    function getTokensDistributedInWeek(\n        ERC20 token,\n        uint256 timestamp\n    ) external view returns (uint256);\n\n    // Depositing\n\n    /**\n     * @notice Deposits tokens to be distributed in the current week.\n     * @dev Sending tokens directly to the FeeDistributor instead of using `depositTokens` may result in tokens being\n     * retroactively distributed to past weeks, or for the distribution to carry over to future weeks.\n     *\n     * If for some reason `depositTokens` cannot be called, in order to ensure that all tokens are correctly distributed\n     * manually call `checkpointToken` before and after the token transfer.\n     * @param token - The ERC20 token address to distribute.\n     * @param amount - The amount of tokens to deposit.\n     */\n    function depositToken(ERC20 token, uint256 amount) external;\n\n    /**\n     * @notice Deposits tokens to be distributed in the current week.\n     * @dev A version of `depositToken` which supports depositing multiple `tokens` at once.\n     * See `depositToken` for more details.\n     * @param tokens - An array of ERC20 token addresses to distribute.\n     * @param amounts - An array of token amounts to deposit.\n     */\n    function depositTokens(\n        ERC20[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    // Checkpointing\n\n    /**\n     * @notice Caches the total supply of veBAL at the beginning of each week.\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Caches the user's balance of veBAL at the beginning of each week.\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     * @param user - The address of the user to be checkpointed.\n     */\n    function checkpointUser(address user) external;\n\n    /**\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\n     * @dev Any `token` balance held by the FeeDistributor above that which is returned by `getTokenLastBalance`\n     * will be distributed evenly across the time period since `token` was last checkpointed.\n     *\n     * This function will be called automatically before claiming tokens to ensure the contract is properly updated.\n     * @param token - The ERC20 token address to be checkpointed.\n     */\n    function checkpointToken(ERC20 token) external;\n\n    /**\n     * @notice Assigns any newly-received tokens held by the FeeDistributor to weekly distributions.\n     * @dev A version of `checkpointToken` which supports checkpointing multiple tokens.\n     * See `checkpointToken` for more details.\n     * @param tokens - An array of ERC20 token addresses to be checkpointed.\n     */\n    function checkpointTokens(ERC20[] calldata tokens) external;\n\n    // Claiming\n\n    /**\n     * @notice Claims all pending distributions of the provided token for a user.\n     * @dev It's not necessary to explicitly checkpoint before calling this function, it will ensure the FeeDistributor\n     * is up to date before calculating the amount of tokens to be claimed.\n     * @param user - The user on behalf of which to claim.\n     * @param token - The ERC20 token address to be claimed.\n     * @return The amount of `token` sent to `user` as a result of claiming.\n     */\n    function claimToken(address user, ERC20 token) external returns (uint256);\n\n    /**\n     * @notice Claims a number of tokens on behalf of a user.\n     * @dev A version of `claimToken` which supports claiming multiple `tokens` on behalf of `user`.\n     * See `claimToken` for more details.\n     * @param user - The user on behalf of which to claim.\n     * @param tokens - An array of ERC20 token addresses to be claimed.\n     * @return An array of the amounts of each token in `tokens` sent to `user` as a result of claiming.\n     */\n    function claimTokens(\n        address user,\n        ERC20[] calldata tokens\n    ) external returns (uint256[] memory);\n}\n"
30     },
31     "src/lib/EOASignaturesValidator.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"../../lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\";\n\nimport \"../interfaces/ISignaturesValidator.sol\";\n\n/**\n * @dev Utility for signing Solidity function calls.\n */\nabstract contract EOASignaturesValidator is ISignaturesValidator, EIP712 {\n    error EOASignaturesValidator__ExpiredSignature();\n    error EOASignaturesValidator__MalformedSignature();\n    error EOASignaturesValidator__RevertWithErrorCode(uint256 errorCode);\n\n    // Replay attack prevention for each account.\n    mapping(address => uint256) internal _nextNonce;\n\n    function getDomainSeparator() public view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function getNextNonce(\n        address account\n    ) public view override returns (uint256) {\n        return _nextNonce[account];\n    }\n\n    function _ensureValidSignature(\n        address account,\n        bytes32 structHash,\n        bytes memory signature,\n        uint256 errorCode\n    ) internal {\n        return\n            _ensureValidSignature(\n                account,\n                structHash,\n                signature,\n                type(uint256).max,\n                errorCode\n            );\n    }\n\n    function _ensureValidSignature(\n        address account,\n        bytes32 structHash,\n        bytes memory signature,\n        uint256 deadline,\n        uint256 errorCode\n    ) internal {\n        bytes32 digest = _hashTypedDataV4(structHash);\n        if (!_isValidSignature(account, digest, signature)) {\n            revert EOASignaturesValidator__RevertWithErrorCode(errorCode);\n        }\n\n        // We could check for the deadline before validating the signature, but this leads to saner error processing (as\n        // we only care about expired deadlines if the signature is correct) and only affects the gas cost of the revert\n        // scenario, which will only occur infrequently, if ever.\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        if (deadline < block.timestamp) {\n            revert EOASignaturesValidator__ExpiredSignature();\n        }\n\n        // We only advance the nonce after validating the signature. This is irrelevant for this module, but it can be\n        // important in derived contracts that override _isValidSignature (e.g. SignaturesValidator), as we want for\n        // the observable state to still have the current nonce as the next valid one.\n        _nextNonce[account] += 1;\n    }\n\n    function _isValidSignature(\n        address account,\n        bytes32 digest,\n        bytes memory signature\n    ) internal view virtual returns (bool) {\n        if (signature.length != 65) {\n            revert EOASignaturesValidator__MalformedSignature();\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the r, s and v signature parameters, and the only way to get them is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        // ecrecover returns the zero address on recover failure, so we need to handle that explicitly.\n        return (recoveredAddress != address(0) && recoveredAddress == account);\n    }\n}\n"
33     },
34     "src/interfaces/IOptionalOnlyCaller.sol": {
35       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.11;\n\n/**\n * @dev Interface for the OptionalOnlyCaller helper, used to opt in to a caller\n * verification for a given address to methods that are otherwise callable by any address.\n */\ninterface IOptionalOnlyCaller {\n    /**\n     * @dev Emitted every time setOnlyCallerCheck is called.\n     */\n    event OnlyCallerOptIn(address user, bool enabled);\n\n    /**\n     * @dev Enables / disables verification mechanism for caller.\n     * @param enabled - True if caller verification shall be enabled, false otherwise.\n     */\n    function setOnlyCallerCheck(bool enabled) external;\n\n    function setOnlyCallerCheckWithSignature(\n        address user,\n        bool enabled,\n        bytes memory signature\n    ) external;\n\n    /**\n     * @dev Returns true if caller verification is enabled for the given user, false otherwise.\n     */\n    function isOnlyCallerEnabled(address user) external view returns (bool);\n}\n"
36     },
37     "lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
39     },
40     "src/interfaces/ISignaturesValidator.sol": {
41       "content": "// SPDX-License-Identifier: GPL-3.0\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.11;\n\n/**\n * @dev Interface for the SignatureValidator helper, used to support meta-transactions.\n */\ninterface ISignaturesValidator {\n    /**\n     * @dev Returns the EIP712 domain separator.\n     */\n    function getDomainSeparator() external view returns (bytes32);\n\n    /**\n     * @dev Returns the next nonce used by an address to sign messages.\n     */\n    function getNextNonce(address user) external view returns (uint256);\n}\n"
42     },
43     "lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
45     },
46     "lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
48     },
49     "lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
51     },
52     "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
54     },
55     "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
56       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
57     },
58     "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {
59       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
60     }
61   },
62   "settings": {
63     "remappings": [
64       "@openzeppelin/=lib/openzeppelin-contracts/",
65       "ds-test/=lib/forge-std/lib/ds-test/src/",
66       "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
67       "forge-std/=lib/forge-std/src/",
68       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
69       "openzeppelin/=lib/openzeppelin-contracts/contracts/",
70       "solidity-examples/=lib/solidity-examples/contracts/",
71       "solmate/=lib/solmate/src/",
72       "superallowlist/=lib/superallowlist/",
73       "v2-core/=lib/v2-core/contracts/"
74     ],
75     "optimizer": {
76       "enabled": true,
77       "runs": 200
78     },
79     "metadata": {
80       "bytecodeHash": "ipfs",
81       "appendCBOR": true
82     },
83     "outputSelection": {
84       "*": {
85         "*": [
86           "evm.bytecode",
87           "evm.deployedBytecode",
88           "devdoc",
89           "userdoc",
90           "metadata",
91           "abi"
92         ]
93       }
94     },
95     "evmVersion": "paris",
96     "libraries": {}
97   }
98 }}