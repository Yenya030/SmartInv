1 // ░█▀▀█ ░█▀▀▀ ░█▀▀▄ ░█▀▀█ ▀█▀ ░█─── ░█─── 
2 // ░█▄▄▀ ░█▀▀▀ ░█─░█ ░█▄▄█ ░█─ ░█─── ░█─── 
3 // ░█─░█ ░█▄▄▄ ░█▄▄▀ ░█─── ▄█▄ ░█▄▄█ ░█▄▄█
4 
5 
6 // Twitter: https://twitter.com/RedPill_erc20
7 // Telegram: https://t.me/RedPillToken
8 
9 
10 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⠶⠛⠛⠛⠶⣤⡀⠀⠀⠀
11 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⠟⠋⢁⣠⣴⣶⣶⣶⣬⣿⣆⠀⠀
12 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⡾⠟⠉⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀
13 // ⠀⠀⠀⠀⠀⠀⠀⢀⣠⡴⠟⠋⠁⠀⠀⠺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀
14 // ⠀⠀⠀⠀⢀⣴⠾⠛⠉⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀
15 // ⠀⠀⢀⡾⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀
16 // ⠀⢀⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⠿⢿⣿⣿⡿⠟⠋⠀⠀⠀⠀⠀⠀
17 // ⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⡾⠛⢉⣠⣴⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
18 // ⠀⠀⢿⡄⠐⢦⣤⣤⣴⣾⠿⠛⣁⣤⡾⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
19 // ⠀⠀⠀⠻⢦⣄⣀⠉⣉⣀⣴⠾⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
20 // ⠀⠀⠀⠀⠀⠉⠛⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
21 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
22 // ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
23 //   _______   ________  ______        __         _______    _______      ___________  __    __    _______      ___      ___       __  ___________  _______    __     ___  ___  
24 //  /"     "| /"       )/" _  "\      /""\       |   __ "\  /"     "|    ("     _   ")/" |  | "\  /"     "|    |"  \    /"  |     /""\("     _   ")/"      \  |" \   |"  \/"  | 
25 // (: ______)(:   \___/(: ( \___)    /    \      (. |__) :)(: ______)     )__/  \\__/(:  (__)  :)(: ______)     \   \  //   |    /    \)__/  \\__/|:        | ||  |   \   \  /  
26 //  \/    |   \___  \   \/ \        /' /\  \     |:  ____/  \/    |          \\_ /    \/      \/  \/    |       /\\  \/.    |   /' /\  \  \\_ /   |_____/   ) |:  |    \\  \/   
27 //  // ___)_   __/  \\  //  \ _    //  __'  \    (|  /      // ___)_         |.  |    //  __  \\  // ___)_     |: \.        |  //  __'  \ |.  |    //      /  |.  |    /\.  \   
28 // (:      "| /" \   :)(:   _) \  /   /  \\  \  /|__/ \    (:      "|        \:  |   (:  (  )  :)(:      "|    |.  \    /:  | /   /  \\  \\:  |   |:  __   \  /\  |\  /  \   \  
29 //  \_______)(_______/  \_______)(___/    \___)(_______)    \_______)         \__|    \__|  |__/  \_______)    |___|\__/|___|(___/    \___)\__|   |__|  \___)(__\_|_)|___/\___| 
30                                                                                                                                                                              
31 
32 // SPDX-License-Identifier: MIT
33 // OpenZeppelin Contracts v4.4.0 (utils/Context.sol)
34 
35 pragma solidity ^0.8.0;
36 
37 /**
38  * @dev Provides information about the current execution context, including the
39  * sender of the transaction and its data. While these are generally available
40  * via msg.sender and msg.data, they should not be accessed in such a direct
41  * manner, since when dealing with meta-transactions the account sending and
42  * paying for execution may not be the actual sender (as far as an application
43  * is concerned).
44  *
45  * This contract is only required for intermediate, library-like contracts.
46  */
47 abstract contract Context {
48     function _msgSender() internal view virtual returns (address) {
49         return msg.sender;
50     }
51 
52     function _msgData() internal view virtual returns (bytes calldata) {
53         return msg.data;
54     }
55 }
56 
57 
58 // File @openzeppelin/contracts/access/Ownable.sol@v4.4.0
59 
60 
61 // OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)
62 
63 pragma solidity ^0.8.0;
64 
65 /**
66  * @dev Contract module which provides a basic access control mechanism, where
67  * there is an account (an owner) that can be granted exclusive access to
68  * specific functions.
69  *
70  * By default, the owner account will be the one that deploys the contract. This
71  * can later be changed with {transferOwnership}.
72  *
73  * This module is used through inheritance. It will make available the modifier
74  * `onlyOwner`, which can be applied to your functions to restrict their use to
75  * the owner.
76  */
77 abstract contract Ownable is Context {
78     address private _owner;
79 
80     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
81 
82     /**
83      * @dev Initializes the contract setting the deployer as the initial owner.
84      */
85     constructor() {
86         _transferOwnership(_msgSender());
87     }
88 
89     /**
90      * @dev Returns the address of the current owner.
91      */
92     function owner() public view virtual returns (address) {
93         return _owner;
94     }
95 
96     /**
97      * @dev Throws if called by any account other than the owner.
98      */
99     modifier onlyOwner() {
100         require(owner() == _msgSender(), "Ownable: caller is not the owner");
101         _;
102     }
103 
104     /**
105      * @dev Leaves the contract without owner. It will not be possible to call
106      * `onlyOwner` functions anymore. Can only be called by the current owner.
107      *
108      * NOTE: Renouncing ownership will leave the contract without an owner,
109      * thereby removing any functionality that is only available to the owner.
110      */
111     function renounceOwnership() public virtual onlyOwner {
112         _transferOwnership(address(0));
113     }
114 
115     /**
116      * @dev Transfers ownership of the contract to a new account (`newOwner`).
117      * Can only be called by the current owner.
118      */
119     function transferOwnership(address newOwner) public virtual onlyOwner {
120         require(newOwner != address(0), "Ownable: new owner is the zero address");
121         _transferOwnership(newOwner);
122     }
123 
124     /**
125      * @dev Transfers ownership of the contract to a new account (`newOwner`).
126      * Internal function without access restriction.
127      */
128     function _transferOwnership(address newOwner) internal virtual {
129         address oldOwner = _owner;
130         _owner = newOwner;
131         emit OwnershipTransferred(oldOwner, newOwner);
132     }
133 }
134 
135 
136 // File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.0
137 
138 
139 // OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)
140 
141 pragma solidity ^0.8.0;
142 
143 /**
144  * @dev Interface of the ERC20 standard as defined in the EIP.
145  */
146 interface IERC20 {
147     /**
148      * @dev Returns the amount of tokens in existence.
149      */
150     function totalSupply() external view returns (uint256);
151 
152     /**
153      * @dev Returns the amount of tokens owned by `account`.
154      */
155     function balanceOf(address account) external view returns (uint256);
156 
157     /**
158      * @dev Moves `amount` tokens from the caller's account to `recipient`.
159      *
160      * Returns a boolean value indicating whether the operation succeeded.
161      *
162      * Emits a {Transfer} event.
163      */
164     function transfer(address recipient, uint256 amount) external returns (bool);
165 
166     /**
167      * @dev Returns the remaining number of tokens that `spender` will be
168      * allowed to spend on behalf of `owner` through {transferFrom}. This is
169      * zero by default.
170      *
171      * This value changes when {approve} or {transferFrom} are called.
172      */
173     function allowance(address owner, address spender) external view returns (uint256);
174 
175     /**
176      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
177      *
178      * Returns a boolean value indicating whether the operation succeeded.
179      *
180      * IMPORTANT: Beware that changing an allowance with this method brings the risk
181      * that someone may use both the old and the new allowance by unfortunate
182      * transaction ordering. One possible solution to mitigate this race
183      * condition is to first reduce the spender's allowance to 0 and set the
184      * desired value afterwards:
185      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
186      *
187      * Emits an {Approval} event.
188      */
189     function approve(address spender, uint256 amount) external returns (bool);
190 
191     /**
192      * @dev Moves `amount` tokens from `sender` to `recipient` using the
193      * allowance mechanism. `amount` is then deducted from the caller's
194      * allowance.
195      *
196      * Returns a boolean value indicating whether the operation succeeded.
197      *
198      * Emits a {Transfer} event.
199      */
200     function transferFrom(
201         address sender,
202         address recipient,
203         uint256 amount
204     ) external returns (bool);
205 
206     /**
207      * @dev Emitted when `value` tokens are moved from one account (`from`) to
208      * another (`to`).
209      *
210      * Note that `value` may be zero.
211      */
212     event Transfer(address indexed from, address indexed to, uint256 value);
213 
214     /**
215      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
216      * a call to {approve}. `value` is the new allowance.
217      */
218     event Approval(address indexed owner, address indexed spender, uint256 value);
219 }
220 
221 
222 // File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.4.0
223 
224 
225 // OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)
226 
227 pragma solidity ^0.8.0;
228 
229 /**
230  * @dev Interface for the optional metadata functions from the ERC20 standard.
231  *
232  * _Available since v4.1._
233  */
234 interface IERC20Metadata is IERC20 {
235     /**
236      * @dev Returns the name of the token.
237      */
238     function name() external view returns (string memory);
239 
240     /**
241      * @dev Returns the symbol of the token.
242      */
243     function symbol() external view returns (string memory);
244 
245     /**
246      * @dev Returns the decimals places of the token.
247      */
248     function decimals() external view returns (uint8);
249 }
250 
251 
252 // File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.4.0
253 
254 
255 // OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol)
256 
257 pragma solidity ^0.8.0;
258 
259 
260 
261 /**
262  * @dev Implementation of the {IERC20} interface.
263  *
264  * This implementation is agnostic to the way tokens are created. This means
265  * that a supply mechanism has to be added in a derived contract using {_mint}.
266  * For a generic mechanism see {ERC20PresetMinterPauser}.
267  *
268  * TIP: For a detailed writeup see our guide
269  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
270  * to implement supply mechanisms].
271  *
272  * We have followed general OpenZeppelin Contracts guidelines: functions revert
273  * instead returning `false` on failure. This behavior is nonetheless
274  * conventional and does not conflict with the expectations of ERC20
275  * applications.
276  *
277  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
278  * This allows applications to reconstruct the allowance for all accounts just
279  * by listening to said events. Other implementations of the EIP may not emit
280  * these events, as it isn't required by the specification.
281  *
282  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
283  * functions have been added to mitigate the well-known issues around setting
284  * allowances. See {IERC20-approve}.
285  */
286 contract ERC20 is Context, IERC20, IERC20Metadata {
287     mapping(address => uint256) private _balances;
288 
289     mapping(address => mapping(address => uint256)) private _allowances;
290 
291     uint256 private _totalSupply;
292 
293     string private _name;
294     string private _symbol;
295 
296     /**
297      * @dev Sets the values for {name} and {symbol}.
298      *
299      * The default value of {decimals} is 18. To select a different value for
300      * {decimals} you should overload it.
301      *
302      * All two of these values are immutable: they can only be set once during
303      * construction.
304      */
305     constructor(string memory name_, string memory symbol_) {
306         _name = name_;
307         _symbol = symbol_;
308     }
309 
310     /**
311      * @dev Returns the name of the token.
312      */
313     function name() public view virtual override returns (string memory) {
314         return _name;
315     }
316 
317     /**
318      * @dev Returns the symbol of the token, usually a shorter version of the
319      * name.
320      */
321     function symbol() public view virtual override returns (string memory) {
322         return _symbol;
323     }
324 
325     /**
326      * @dev Returns the number of decimals used to get its user representation.
327      * For example, if `decimals` equals `2`, a balance of `505` tokens should
328      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
329      *
330      * Tokens usually opt for a value of 18, imitating the relationship between
331      * Ether and Wei. This is the value {ERC20} uses, unless this function is
332      * overridden;
333      *
334      * NOTE: This information is only used for _display_ purposes: it in
335      * no way affects any of the arithmetic of the contract, including
336      * {IERC20-balanceOf} and {IERC20-transfer}.
337      */
338     function decimals() public view virtual override returns (uint8) {
339         return 18;
340     }
341 
342     /**
343      * @dev See {IERC20-totalSupply}.
344      */
345     function totalSupply() public view virtual override returns (uint256) {
346         return _totalSupply;
347     }
348 
349     /**
350      * @dev See {IERC20-balanceOf}.
351      */
352     function balanceOf(address account) public view virtual override returns (uint256) {
353         return _balances[account];
354     }
355 
356     /**
357      * @dev See {IERC20-transfer}.
358      *
359      * Requirements:
360      *
361      * - `recipient` cannot be the zero address.
362      * - the caller must have a balance of at least `amount`.
363      */
364     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
365         _transfer(_msgSender(), recipient, amount);
366         return true;
367     }
368 
369     /**
370      * @dev See {IERC20-allowance}.
371      */
372     function allowance(address owner, address spender) public view virtual override returns (uint256) {
373         return _allowances[owner][spender];
374     }
375 
376     /**
377      * @dev See {IERC20-approve}.
378      *
379      * Requirements:
380      *
381      * - `spender` cannot be the zero address.
382      */
383     function approve(address spender, uint256 amount) public virtual override returns (bool) {
384         _approve(_msgSender(), spender, amount);
385         return true;
386     }
387 
388     /**
389      * @dev See {IERC20-transferFrom}.
390      *
391      * Emits an {Approval} event indicating the updated allowance. This is not
392      * required by the EIP. See the note at the beginning of {ERC20}.
393      *
394      * Requirements:
395      *
396      * - `sender` and `recipient` cannot be the zero address.
397      * - `sender` must have a balance of at least `amount`.
398      * - the caller must have allowance for ``sender``'s tokens of at least
399      * `amount`.
400      */
401     function transferFrom(
402         address sender,
403         address recipient,
404         uint256 amount
405     ) public virtual override returns (bool) {
406         _transfer(sender, recipient, amount);
407 
408         uint256 currentAllowance = _allowances[sender][_msgSender()];
409         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
410         unchecked {
411             _approve(sender, _msgSender(), currentAllowance - amount);
412         }
413 
414         return true;
415     }
416 
417     /**
418      * @dev Atomically increases the allowance granted to `spender` by the caller.
419      *
420      * This is an alternative to {approve} that can be used as a mitigation for
421      * problems described in {IERC20-approve}.
422      *
423      * Emits an {Approval} event indicating the updated allowance.
424      *
425      * Requirements:
426      *
427      * - `spender` cannot be the zero address.
428      */
429     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
430         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
431         return true;
432     }
433 
434     /**
435      * @dev Atomically decreases the allowance granted to `spender` by the caller.
436      *
437      * This is an alternative to {approve} that can be used as a mitigation for
438      * problems described in {IERC20-approve}.
439      *
440      * Emits an {Approval} event indicating the updated allowance.
441      *
442      * Requirements:
443      *
444      * - `spender` cannot be the zero address.
445      * - `spender` must have allowance for the caller of at least
446      * `subtractedValue`.
447      */
448     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
449         uint256 currentAllowance = _allowances[_msgSender()][spender];
450         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
451         unchecked {
452             _approve(_msgSender(), spender, currentAllowance - subtractedValue);
453         }
454 
455         return true;
456     }
457 
458     /**
459      * @dev Moves `amount` of tokens from `sender` to `recipient`.
460      *
461      * This internal function is equivalent to {transfer}, and can be used to
462      * e.g. implement automatic token fees, slashing mechanisms, etc.
463      *
464      * Emits a {Transfer} event.
465      *
466      * Requirements:
467      *
468      * - `sender` cannot be the zero address.
469      * - `recipient` cannot be the zero address.
470      * - `sender` must have a balance of at least `amount`.
471      */
472     function _transfer(
473         address sender,
474         address recipient,
475         uint256 amount
476     ) internal virtual {
477         require(sender != address(0), "ERC20: transfer from the zero address");
478         require(recipient != address(0), "ERC20: transfer to the zero address");
479 
480         _beforeTokenTransfer(sender, recipient, amount);
481 
482         uint256 senderBalance = _balances[sender];
483         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
484         unchecked {
485             _balances[sender] = senderBalance - amount;
486         }
487         _balances[recipient] += amount;
488 
489         emit Transfer(sender, recipient, amount);
490 
491         _afterTokenTransfer(sender, recipient, amount);
492     }
493 
494     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
495      * the total supply.
496      *
497      * Emits a {Transfer} event with `from` set to the zero address.
498      *
499      * Requirements:
500      *
501      * - `account` cannot be the zero address.
502      */
503     function _mint(address account, uint256 amount) internal virtual {
504         require(account != address(0), "ERC20: mint to the zero address");
505 
506         _beforeTokenTransfer(address(0), account, amount);
507 
508         _totalSupply += amount;
509         _balances[account] += amount;
510         emit Transfer(address(0), account, amount);
511 
512         _afterTokenTransfer(address(0), account, amount);
513     }
514 
515     /**
516      * @dev Destroys `amount` tokens from `account`, reducing the
517      * total supply.
518      *
519      * Emits a {Transfer} event with `to` set to the zero address.
520      *
521      * Requirements:
522      *
523      * - `account` cannot be the zero address.
524      * - `account` must have at least `amount` tokens.
525      */
526     function _burn(address account, uint256 amount) internal virtual {
527         require(account != address(0), "ERC20: burn from the zero address");
528 
529         _beforeTokenTransfer(account, address(0), amount);
530 
531         uint256 accountBalance = _balances[account];
532         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
533         unchecked {
534             _balances[account] = accountBalance - amount;
535         }
536         _totalSupply -= amount;
537 
538         emit Transfer(account, address(0), amount);
539 
540         _afterTokenTransfer(account, address(0), amount);
541     }
542 
543     /**
544      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
545      *
546      * This internal function is equivalent to `approve`, and can be used to
547      * e.g. set automatic allowances for certain subsystems, etc.
548      *
549      * Emits an {Approval} event.
550      *
551      * Requirements:
552      *
553      * - `owner` cannot be the zero address.
554      * - `spender` cannot be the zero address.
555      */
556     function _approve(
557         address owner,
558         address spender,
559         uint256 amount
560     ) internal virtual {
561         require(owner != address(0), "ERC20: approve from the zero address");
562         require(spender != address(0), "ERC20: approve to the zero address");
563 
564         _allowances[owner][spender] = amount;
565         emit Approval(owner, spender, amount);
566     }
567 
568     /**
569      * @dev Hook that is called before any transfer of tokens. This includes
570      * minting and burning.
571      *
572      * Calling conditions:
573      *
574      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
575      * will be transferred to `to`.
576      * - when `from` is zero, `amount` tokens will be minted for `to`.
577      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
578      * - `from` and `to` are never both zero.
579      *
580      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
581      */
582     function _beforeTokenTransfer(
583         address from,
584         address to,
585         uint256 amount
586     ) internal virtual {}
587 
588     /**
589      * @dev Hook that is called after any transfer of tokens. This includes
590      * minting and burning.
591      *
592      * Calling conditions:
593      *
594      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
595      * has been transferred to `to`.
596      * - when `from` is zero, `amount` tokens have been minted for `to`.
597      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
598      * - `from` and `to` are never both zero.
599      *
600      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
601      */
602     function _afterTokenTransfer(
603         address from,
604         address to,
605         uint256 amount
606     ) internal virtual {}
607 }
608 
609 pragma solidity ^0.8.0;
610 
611 
612 contract RedPill is Ownable, ERC20 {
613     bool public limited;
614     uint256 public maxHoldingAmount;
615     uint256 public minHoldingAmount;
616     address public uniswapV2Pair;
617     mapping(address => bool) public blacklists;
618 
619     constructor(uint256 _totalSupply) ERC20("Red Pill", "RP") {
620         _mint(msg.sender, _totalSupply);
621     }
622 
623     function blacklist(address _address, bool _isBlacklisting) external onlyOwner {
624         blacklists[_address] = _isBlacklisting;
625     }
626 
627     function setRule(bool _limited, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {
628         limited = _limited;
629         maxHoldingAmount = _maxHoldingAmount;
630         minHoldingAmount = _minHoldingAmount;
631     }
632 
633     function _beforeTokenTransfer(
634         address from,
635         address to,
636         uint256 amount
637     ) override internal virtual {
638         require(!blacklists[to] && !blacklists[from], "Blacklisted");
639 
640         if (limited && from == uniswapV2Pair) {
641             require(super.balanceOf(to) + amount <= maxHoldingAmount && super.balanceOf(to) + amount >= minHoldingAmount, "Forbid");
642         }
643     }
644 
645     function burn(uint256 value) external {
646         _burn(msg.sender, value);
647     }
648 }