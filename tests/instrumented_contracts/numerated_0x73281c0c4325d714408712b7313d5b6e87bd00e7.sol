1 pragma solidity ^0.4.21;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 
7 // File: contracts/library/SafeMath.sol
8 
9 /**
10  * @title Safe Math
11  *
12  * @dev Library for safe mathematical operations.
13  */
14 library SafeMath {
15     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
16         uint256 c = a * b;
17         assert(a == 0 || c / a == b);
18 
19         return c;
20     }
21 
22     function div(uint256 a, uint256 b) internal pure returns (uint256) {
23         uint256 c = a / b;
24 
25         return c;
26     }
27 
28     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
29         assert(b <= a);
30 
31         return a - b;
32     }
33 
34     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
35         uint256 c = a + b;
36         assert(c >= a);
37 
38         return c;
39     }
40 }
41 
42 // File: contracts/token/ERC20Token.sol
43 
44 /**
45  * @dev The standard ERC20 Token contract base.
46  */
47 contract ERC20Token {
48     uint256 public totalSupply;  /* shorthand for public function and a property */
49     
50     function balanceOf(address _owner) public view returns (uint256 balance);
51     function transfer(address _to, uint256 _value) public returns (bool success);
52     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
53     function approve(address _spender, uint256 _value) public returns (bool success);
54     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
55 
56     event Transfer(address indexed _from, address indexed _to, uint256 _value);
57     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
58 }
59 
60 // File: contracts/token/StandardToken.sol
61 
62 /**
63  * @title Standard Token
64  *
65  * @dev The standard abstract implementation of the ERC20 interface.
66  */
67 contract StandardToken is ERC20Token {
68     using SafeMath for uint256;
69 
70     string public name;
71     string public symbol;
72     uint8 public decimals;
73     
74     mapping (address => uint256) balances;
75     mapping (address => mapping (address => uint256)) internal allowed;
76     
77     /**
78      * @dev The constructor assigns the token name, symbols and decimals.
79      */
80     constructor(string _name, string _symbol, uint8 _decimals) internal {
81         name = _name;
82         symbol = _symbol;
83         decimals = _decimals;
84     }
85 
86     /**
87      * @dev Get the balance of an address.
88      *
89      * @param _address The address which's balance will be checked.
90      *
91      * @return The current balance of the address.
92      */
93     function balanceOf(address _address) public view returns (uint256 balance) {
94         return balances[_address];
95     }
96 
97     /**
98      * @dev Checks the amount of tokens that an owner allowed to a spender.
99      *
100      * @param _owner The address which owns the funds allowed for spending by a third-party.
101      * @param _spender The third-party address that is allowed to spend the tokens.
102      *
103      * @return The number of tokens available to `_spender` to be spent.
104      */
105     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
106         return allowed[_owner][_spender];
107     }
108 
109     /**
110      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
111      * E.g. You place a buy or sell order on an exchange and in that example, the 
112      * `_spender` address is the address of the contract the exchange created to add your token to their 
113      * website and you are `msg.sender`.
114      *
115      * @param _spender The address which will spend the funds.
116      * @param _value The amount of tokens to be spent.
117      *
118      * @return Whether the approval process was successful or not.
119      */
120     function approve(address _spender, uint256 _value) public returns (bool) {
121         allowed[msg.sender][_spender] = _value;
122 
123         emit Approval(msg.sender, _spender, _value);
124 
125         return true;
126     }
127 
128     /**
129      * @dev Transfers `_value` number of tokens to the `_to` address.
130      *
131      * @param _to The address of the recipient.
132      * @param _value The number of tokens to be transferred.
133      */
134     function transfer(address _to, uint256 _value) public returns (bool) {
135         executeTransfer(msg.sender, _to, _value);
136 
137         return true;
138     }
139 
140     /**
141      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
142      *
143      * @param _from The address which approved you to spend tokens on their behalf.
144      * @param _to The address where you want to send tokens.
145      * @param _value The number of tokens to be sent.
146      *
147      * @return Whether the transfer was successful or not.
148      */
149     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
150         require(_value <= allowed[_from][msg.sender]);
151         
152         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
153         executeTransfer(_from, _to, _value);
154 
155         return true;
156     }
157 
158     /**
159      * @dev Internal function that this reused by the transfer functions
160      */
161     function executeTransfer(address _from, address _to, uint256 _value) internal {
162         require(_to != address(0));
163         require(_value != 0 && _value <= balances[_from]);
164         
165         balances[_from] = balances[_from].minus(_value);
166         balances[_to] = balances[_to].plus(_value);
167 
168         emit Transfer(_from, _to, _value);
169     }
170 }
171 
172 // File: contracts/token/MintableToken.sol
173 
174 /**
175  * @title Mintable Token
176  *
177  * @dev Allows the creation of new tokens.
178  */
179 contract MintableToken is StandardToken {
180     /// @dev The only address allowed to mint coins
181     address public minter;
182 
183     /// @dev Indicates whether the token is still mintable.
184     bool public mintingDisabled = false;
185 
186     /**
187      * @dev Event fired when minting is no longer allowed.
188      */
189     event MintingDisabled();
190 
191     /**
192      * @dev Allows a function to be executed only if minting is still allowed.
193      */
194     modifier canMint() {
195         require(!mintingDisabled);
196         _;
197     }
198 
199     /**
200      * @dev Allows a function to be called only by the minter
201      */
202     modifier onlyMinter() {
203         require(msg.sender == minter);
204         _;
205     }
206 
207     /**
208      * @dev The constructor assigns the minter which is allowed to mind and disable minting
209      */
210     constructor(address _minter) internal {
211         minter = _minter;
212     }
213 
214     /**
215     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
216     *
217     * @param _to The address which will receive the freshly minted tokens.
218     * @param _value The number of tokens that will be created.
219     */
220     function mint(address _to, uint256 _value) onlyMinter canMint public {
221         totalSupply = totalSupply.plus(_value);
222         balances[_to] = balances[_to].plus(_value);
223 
224         emit Transfer(0x0, _to, _value);
225     }
226 
227     /**
228     * @dev Disable the minting of new tokens. Cannot be reversed.
229     *
230     * @return Whether or not the process was successful.
231     */
232     function disableMinting() onlyMinter canMint public {
233         mintingDisabled = true;
234        
235         emit MintingDisabled();
236     }
237 }
238 
239 // File: contracts/token/BurnableToken.sol
240 
241 /**
242  * @title Burnable Token
243  *
244  * @dev Allows tokens to be destroyed.
245  */
246 contract BurnableToken is StandardToken {
247     /**
248      * @dev Event fired when tokens are burned.
249      *
250      * @param _from The address from which tokens will be removed.
251      * @param _value The number of tokens to be destroyed.
252      */
253     event Burn(address indexed _from, uint256 _value);
254 
255     /**
256      * @dev Burnes `_value` number of tokens.
257      *
258      * @param _value The number of tokens that will be burned.
259      */
260     function burn(uint256 _value) public {
261         require(_value != 0);
262 
263         address burner = msg.sender;
264         require(_value <= balances[burner]);
265 
266         balances[burner] = balances[burner].minus(_value);
267         totalSupply = totalSupply.minus(_value);
268 
269         emit Burn(burner, _value);
270         emit Transfer(burner, address(0), _value);
271     }
272 }
273 
274 // File: contracts/trait/HasOwner.sol
275 
276 /**
277  * @title HasOwner
278  *
279  * @dev Allows for exclusive access to certain functionality.
280  */
281 contract HasOwner {
282     // The current owner.
283     address public owner;
284 
285     // Conditionally the new owner.
286     address public newOwner;
287 
288     /**
289      * @dev The constructor.
290      *
291      * @param _owner The address of the owner.
292      */
293     constructor(address _owner) public {
294         owner = _owner;
295     }
296 
297     /** 
298      * @dev Access control modifier that allows only the current owner to call the function.
299      */
300     modifier onlyOwner {
301         require(msg.sender == owner);
302         _;
303     }
304 
305     /**
306      * @dev The event is fired when the current owner is changed.
307      *
308      * @param _oldOwner The address of the previous owner.
309      * @param _newOwner The address of the new owner.
310      */
311     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
312 
313     /**
314      * @dev Transfering the ownership is a two-step process, as we prepare
315      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
316      * the transfer. This prevents accidental lock-out if something goes wrong
317      * when passing the `newOwner` address.
318      *
319      * @param _newOwner The address of the proposed new owner.
320      */
321     function transferOwnership(address _newOwner) public onlyOwner {
322         newOwner = _newOwner;
323     }
324  
325     /**
326      * @dev The `newOwner` finishes the ownership transfer process by accepting the
327      * ownership.
328      */
329     function acceptOwnership() public {
330         require(msg.sender == newOwner);
331 
332         emit OwnershipTransfer(owner, newOwner);
333 
334         owner = newOwner;
335     }
336 }
337 
338 // File: contracts/fundraiser/AbstractFundraiser.sol
339 
340 contract AbstractFundraiser {
341     /// The ERC20 token contract.
342     ERC20Token public token;
343 
344     /**
345      * @dev The event fires every time a new buyer enters the fundraiser.
346      *
347      * @param _address The address of the buyer.
348      * @param _ethers The number of ethers funded.
349      * @param _tokens The number of tokens purchased.
350      */
351     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
352 
353 
354     /**
355      * @dev The initialization method for the token
356      *
357      * @param _token The address of the token of the fundraiser
358      */
359     function initializeFundraiserToken(address _token) internal
360     {
361         token = ERC20Token(_token);
362     }
363 
364     /**
365      * @dev The default function which is executed when someone sends funds to this contract address.
366      */
367     function() public payable {
368         receiveFunds(msg.sender, msg.value);
369     }
370 
371     /**
372      * @dev this overridable function returns the current conversion rate for the fundraiser
373      */
374     function getConversionRate() public view returns (uint256);
375 
376     /**
377      * @dev checks whether the fundraiser passed `endTime`.
378      *
379      * @return whether the fundraiser has ended.
380      */
381     function hasEnded() public view returns (bool);
382 
383     /**
384      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
385      *
386      * @param _address The address of the receiver of tokens.
387      * @param _amount The amount of received funds in ether.
388      */
389     function receiveFunds(address _address, uint256 _amount) internal;
390     
391     /**
392      * @dev It throws an exception if the transaction does not meet the preconditions.
393      */
394     function validateTransaction() internal view;
395     
396     /**
397      * @dev this overridable function makes and handles tokens to buyers
398      */
399     function handleTokens(address _address, uint256 _tokens) internal;
400 
401     /**
402      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
403      */
404     function handleFunds(address _address, uint256 _ethers) internal;
405 
406 }
407 
408 // File: contracts/fundraiser/BasicFundraiser.sol
409 
410 /**
411  * @title Basic Fundraiser
412  *
413  * @dev An abstract contract that is a base for fundraisers. 
414  * It implements a generic procedure for handling received funds:
415  * 1. Validates the transaciton preconditions
416  * 2. Calculates the amount of tokens based on the conversion rate.
417  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
418  * 4. Delegate the handling of the funds
419  * 5. Emit event for received funds
420  */
421 contract BasicFundraiser is HasOwner, AbstractFundraiser {
422     using SafeMath for uint256;
423 
424     // The number of decimals for the token.
425     uint8 constant DECIMALS = 18;  // Enforced
426 
427     // Decimal factor for multiplication purposes.
428     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
429 
430     /// The start time of the fundraiser - Unix timestamp.
431     uint256 public startTime;
432 
433     /// The end time of the fundraiser - Unix timestamp.
434     uint256 public endTime;
435 
436     /// The address where funds collected will be sent.
437     address public beneficiary;
438 
439     /// The conversion rate with decimals difference adjustment,
440     /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
441     uint256 public conversionRate;
442 
443     /// The total amount of ether raised.
444     uint256 public totalRaised;
445 
446     /**
447      * @dev The event fires when the number of token conversion rate has changed.
448      *
449      * @param _conversionRate The new number of tokens per 1 ether.
450      */
451     event ConversionRateChanged(uint _conversionRate);
452 
453     /**
454      * @dev The basic fundraiser initialization method.
455      *
456      * @param _startTime The start time of the fundraiser - Unix timestamp.
457      * @param _endTime The end time of the fundraiser - Unix timestamp.
458      * @param _conversionRate The number of tokens create for 1 ETH funded.
459      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
460      */
461     function initializeBasicFundraiser(
462         uint256 _startTime,
463         uint256 _endTime,
464         uint256 _conversionRate,
465         address _beneficiary
466     )
467         internal
468     {
469         require(_endTime >= _startTime);
470         require(_conversionRate > 0);
471         require(_beneficiary != address(0));
472 
473         startTime = _startTime;
474         endTime = _endTime;
475         conversionRate = _conversionRate;
476         beneficiary = _beneficiary;
477     }
478 
479     /**
480      * @dev Sets the new conversion rate
481      *
482      * @param _conversionRate New conversion rate
483      */
484     function setConversionRate(uint256 _conversionRate) public onlyOwner {
485         require(_conversionRate > 0);
486 
487         conversionRate = _conversionRate;
488 
489         emit ConversionRateChanged(_conversionRate);
490     }
491 
492     /**
493      * @dev Sets The beneficiary of the fundraiser.
494      *
495      * @param _beneficiary The address of the beneficiary.
496      */
497     function setBeneficiary(address _beneficiary) public onlyOwner {
498         require(_beneficiary != address(0));
499 
500         beneficiary = _beneficiary;
501     }
502 
503     /**
504      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
505      *
506      * @param _address The address of the receiver of tokens.
507      * @param _amount The amount of received funds in ether.
508      */
509     function receiveFunds(address _address, uint256 _amount) internal {
510         validateTransaction();
511 
512         uint256 tokens = calculateTokens(_amount);
513         require(tokens > 0);
514 
515         totalRaised = totalRaised.plus(_amount);
516         handleTokens(_address, tokens);
517         handleFunds(_address, _amount);
518 
519         emit FundsReceived(_address, msg.value, tokens);
520     }
521 
522     /**
523      * @dev this overridable function returns the current conversion rate for the fundraiser
524      */
525     function getConversionRate() public view returns (uint256) {
526         return conversionRate;
527     }
528 
529     /**
530      * @dev this overridable function that calculates the tokens based on the ether amount
531      */
532     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
533         tokens = _amount.mul(getConversionRate());
534     }
535 
536     /**
537      * @dev It throws an exception if the transaction does not meet the preconditions.
538      */
539     function validateTransaction() internal view {
540         require(msg.value != 0);
541         require(now >= startTime && now < endTime);
542     }
543 
544     /**
545      * @dev checks whether the fundraiser passed `endtime`.
546      *
547      * @return whether the fundraiser is passed its deadline or not.
548      */
549     function hasEnded() public view returns (bool) {
550         return now >= endTime;
551     }
552 }
553 
554 // File: contracts/token/StandardMintableToken.sol
555 
556 contract StandardMintableToken is MintableToken {
557     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
558         StandardToken(_name, _symbol, _decimals)
559         MintableToken(_minter)
560         public
561     {
562     }
563 }
564 
565 // File: contracts/fundraiser/MintableTokenFundraiser.sol
566 
567 /**
568  * @title Fundraiser With Mintable Token
569  */
570 contract MintableTokenFundraiser is BasicFundraiser {
571     /**
572      * @dev The initialization method that creates a new mintable token.
573      *
574      * @param _name Token name
575      * @param _symbol Token symbol
576      * @param _decimals Token decimals
577      */
578     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
579         token = new StandardMintableToken(
580             address(this), // The fundraiser is the token minter
581             _name,
582             _symbol,
583             _decimals
584         );
585     }
586 
587     /**
588      * @dev Mint the specific amount tokens
589      */
590     function handleTokens(address _address, uint256 _tokens) internal {
591         MintableToken(token).mint(_address, _tokens);
592     }
593 }
594 
595 // File: contracts/fundraiser/IndividualCapsFundraiser.sol
596 
597 /**
598  * @title Fundraiser with individual caps
599  *
600  * @dev Allows you to set a hard cap on your fundraiser.
601  */
602 contract IndividualCapsFundraiser is BasicFundraiser {
603     uint256 public individualMinCap;
604     uint256 public individualMaxCap;
605     uint256 public individualMaxCapTokens;
606 
607 
608     event IndividualMinCapChanged(uint256 _individualMinCap);
609     event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);
610 
611     /**
612      * @dev The initialization method.
613      *
614      * @param _individualMinCap The minimum amount of ether contribution per address.
615      * @param _individualMaxCap The maximum amount of ether contribution per address.
616      */
617     function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {
618         individualMinCap = _individualMinCap;
619         individualMaxCap = _individualMaxCap;
620         individualMaxCapTokens = _individualMaxCap * conversionRate;
621     }
622 
623     function setConversionRate(uint256 _conversionRate) public onlyOwner {
624         super.setConversionRate(_conversionRate);
625 
626         if (individualMaxCap == 0) {
627             return;
628         }
629         
630         individualMaxCapTokens = individualMaxCap * _conversionRate;
631 
632         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
633     }
634 
635     function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {
636         individualMinCap = _individualMinCap;
637 
638         emit IndividualMinCapChanged(individualMinCap);
639     }
640 
641     function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {
642         individualMaxCap = _individualMaxCap;
643         individualMaxCapTokens = _individualMaxCap * conversionRate;
644 
645         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
646     }
647 
648     /**
649      * @dev Extends the transaction validation to check if the value this higher than the minumum cap.
650      */
651     function validateTransaction() internal view {
652         super.validateTransaction();
653         require(msg.value >= individualMinCap);
654     }
655 
656     /**
657      * @dev We validate the new amount doesn't surpass maximum contribution cap
658      */
659     function handleTokens(address _address, uint256 _tokens) internal {
660         require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);
661 
662         super.handleTokens(_address, _tokens);
663     }
664 }
665 
666 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
667 
668 /**
669  * @title GasPriceLimitFundraiser
670  *
671  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
672  */
673 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
674     uint256 public gasPriceLimit;
675 
676     event GasPriceLimitChanged(uint256 gasPriceLimit);
677 
678     /**
679      * @dev This function puts the initial gas limit
680      */
681     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
682         gasPriceLimit = _gasPriceLimit;
683     }
684 
685     /**
686      * @dev This function allows the owner to change the gas limit any time during the fundraiser
687      */
688     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
689         gasPriceLimit = _gasPriceLimit;
690 
691         emit GasPriceLimitChanged(_gasPriceLimit);
692     }
693 
694     /**
695      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
696      */
697     function validateTransaction() internal view {
698         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
699 
700         return super.validateTransaction();
701     }
702 }
703 
704 // File: contracts/fundraiser/CappedFundraiser.sol
705 
706 /**
707  * @title Capped Fundraiser
708  *
709  * @dev Allows you to set a hard cap on your fundraiser.
710  */
711 contract CappedFundraiser is BasicFundraiser {
712     /// The maximum amount of ether allowed for the fundraiser.
713     uint256 public hardCap;
714 
715     /**
716      * @dev The initialization method.
717      *
718      * @param _hardCap The maximum amount of ether allowed to be raised.
719      */
720     function initializeCappedFundraiser(uint256 _hardCap) internal {
721         require(_hardCap > 0);
722 
723         hardCap = _hardCap;
724     }
725 
726     /**
727      * @dev Adds additional check if the hard cap has been reached.
728      *
729      * @return Whether the token purchase will be allowed.
730      */
731     function validateTransaction() internal view {
732         super.validateTransaction();
733         require(totalRaised < hardCap);
734     }
735 
736     /**
737      * @dev Overrides the method from the default `Fundraiser` contract
738      * to additionally check if the `hardCap` is reached.
739      *
740      * @return Whether or not the fundraiser has ended.
741      */
742     function hasEnded() public view returns (bool) {
743         return (super.hasEnded() || totalRaised >= hardCap);
744     }
745 }
746 
747 // File: contracts/fundraiser/ForwardFundsFundraiser.sol
748 
749 /**
750  * @title Forward Funds to Beneficiary Fundraiser
751  *
752  * @dev This contract forwards the funds received to the beneficiary.
753  */
754 contract ForwardFundsFundraiser is BasicFundraiser {
755     /**
756      * @dev Forward funds directly to beneficiary
757      */
758     function handleFunds(address, uint256 _ethers) internal {
759         // Forward the funds directly to the beneficiary
760         beneficiary.transfer(_ethers);
761     }
762 }
763 
764 // File: contracts/fundraiser/PresaleFundraiser.sol
765 
766 /**
767  * @title PresaleFundraiser
768  *
769  * @dev This is the standard fundraiser contract which allows
770  * you to raise ETH in exchange for your tokens.
771  */
772 contract PresaleFundraiser is MintableTokenFundraiser {
773     /// @dev The token hard cap for the pre-sale
774     uint256 public presaleSupply;
775 
776     /// @dev The token hard cap for the pre-sale
777     uint256 public presaleMaxSupply;
778 
779     /// @dev The start time of the pre-sale (Unix timestamp).
780     uint256 public presaleStartTime;
781 
782     /// @dev The end time of the pre-sale (Unix timestamp).
783     uint256 public presaleEndTime;
784 
785     /// @dev The conversion rate for the pre-sale
786     uint256 public presaleConversionRate;
787 
788     /**
789      * @dev The initialization method.
790      *
791      * @param _startTime The timestamp of the moment when the pre-sale starts
792      * @param _endTime The timestamp of the moment when the pre-sale ends
793      * @param _conversionRate The conversion rate during the pre-sale
794      */
795     function initializePresaleFundraiser(
796         uint256 _presaleMaxSupply,
797         uint256 _startTime,
798         uint256 _endTime,
799         uint256 _conversionRate
800     )
801         internal
802     {
803         require(_endTime >= _startTime);
804         require(_conversionRate > 0);
805 
806         presaleMaxSupply = _presaleMaxSupply;
807         presaleStartTime = _startTime;
808         presaleEndTime = _endTime;
809         presaleConversionRate = _conversionRate;
810     }
811 
812     /**
813      * @dev Internal funciton that helps to check if the pre-sale is active
814      */
815     
816     function isPresaleActive() internal view returns (bool) {
817         return now < presaleEndTime && now >= presaleStartTime;
818     }
819     /**
820      * @dev this function different conversion rate while in presale
821      */
822     function getConversionRate() public view returns (uint256) {
823         if (isPresaleActive()) {
824             return presaleConversionRate;
825         }
826         return super.getConversionRate();
827     }
828 
829     /**
830      * @dev It throws an exception if the transaction does not meet the preconditions.
831      */
832     function validateTransaction() internal view {
833         require(msg.value != 0);
834         require(now >= startTime && now < endTime || isPresaleActive());
835     }
836 
837     function handleTokens(address _address, uint256 _tokens) internal {
838         if (isPresaleActive()) {
839             presaleSupply = presaleSupply.plus(_tokens);
840             require(presaleSupply <= presaleMaxSupply);
841         }
842 
843         super.handleTokens(_address, _tokens);
844     }
845 
846 }
847 
848 // File: contracts/Fundraiser.sol
849 
850 /**
851  * @title BigchainToken
852  */
853 
854 contract BigchainToken is MintableToken, BurnableToken {
855     constructor(address _minter)
856         StandardToken(
857             "Bigchain",   // Token name
858             "BCHAIN", // Token symbol
859             18  // Token decimals
860         )
861         
862         MintableToken(_minter)
863         public
864     {
865     }
866 }
867 
868 
869 
870 
871 
872 
873 /**
874  * @title BigchainTokenFundraiser
875  */
876 
877 contract BigchainTokenFundraiser is MintableTokenFundraiser, PresaleFundraiser, IndividualCapsFundraiser, CappedFundraiser, ForwardFundsFundraiser, GasPriceLimitFundraiser {
878     
879 
880     constructor()
881         HasOwner(msg.sender)
882         public
883     {
884         token = new BigchainToken(
885         
886         address(this)  // The fundraiser is the minter
887         );
888 
889         
890 
891         initializeBasicFundraiser(
892             1537963200, // Start date = 2018-09-26 12:00 UTC
893             1539172800,  // End date = 2018-10-10 12:00 UTC
894             30000000, // Conversion rate = 30000000 BCHAIN per 1 ether
895             0x6d401719Ff29e733C6d25A1431cce6B26d05cC53     // Beneficiary
896         );
897 
898         initializeIndividualCapsFundraiser(
899             (0.01 ether), // Minimum contribution
900             (10 ether)  // Maximum individual cap
901         );
902 
903         initializeGasPriceLimitFundraiser(
904             0 // Gas price limit in wei
905         );
906 
907         initializePresaleFundraiser(
908             15000000000000000000000000000,
909             1537790400, // Start = 2018-09-24 12:00 UTC
910             1537963140,   // End = 2018-09-26 11:59 UTC
911             30000000
912         );
913 
914         initializeCappedFundraiser(
915             (350 ether) // Hard cap
916         );
917 
918         
919 
920         
921     }
922     
923 }