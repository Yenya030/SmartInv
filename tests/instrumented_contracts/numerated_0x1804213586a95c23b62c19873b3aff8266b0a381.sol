1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/SubDevFund.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./DevFund.sol\";\n\ncontract SubDevFund {\n    /// --- External contracts\n\n    // token to be awarded as reward to holders\n    IERC20 public rewardToken;\n\n    // token to claim rewards\n    IERC20 public holderToken;\n\n    DevFund public mainDevFund;\n\n    /// --- Storage\n\n    // total reward on contract\n    uint256 public totalReward;\n\n    // previously seen reward balance on contract\n    uint256 public prevBalance;\n\n    // User's address => Reward at time of withdraw\n    mapping(address => uint256) public rewardAtTimeOfWithdraw;\n\n    // User's address => Reward which can be withdrawn\n    mapping(address => uint256) public owed;\n\n    /**\n     * @dev Contract constructor sets reward token address.\n     */\n    constructor(address _rewardToken) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Setup function sets dev holder token address and owner, callable only once.\n     * @param _holderToken Dev holder Token address.\n     * @param _mainDevFund Address of the main dev fund from which it must withdraw rewards\n     */\n    function setup(address _holderToken, address _mainDevFund) external returns (bool) {\n        require(address(holderToken) == address(0), \"SubDevFund: already setup\");\n        require(_holderToken != address(0), \"SubDevFund: invalid _holderToken\");\n        require(_mainDevFund != address(0), \"SubDevFund: invalid _mainDevFund\");\n\n        holderToken = IERC20(_holderToken);\n        mainDevFund = DevFund(_mainDevFund);\n\n        return true;\n    }\n\n    /// --- Contract functions\n\n    /**\n     * @dev Withdraw reward from the main dev fund.\n     */\n    function withdrawFromMain() public {\n        mainDevFund.withdrawReward();\n    }\n\n    /**\n     * @dev Withdraws reward for holder. Returns reward.\n     */\n    function withdrawReward() public returns (uint256) {\n        updateTotalReward();\n\n        uint256 value = calcReward(msg.sender) + owed[msg.sender];\n        rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n        owed[msg.sender] = 0;\n\n        require(value > 0, \"SubDevFund: withdrawReward nothing to transfer\");\n\n        rewardToken.transfer(msg.sender, value);\n\n        prevBalance = rewardToken.balanceOf(address(this));\n\n        return value;\n    }\n\n    /**\n     * @dev Credits reward to owed balance.\n     * @param forAddress holder's address.\n     */\n    function softWithdrawRewardFor(address forAddress) external returns (uint256){\n        updateTotalReward();\n        uint256 value = calcReward(forAddress);\n        rewardAtTimeOfWithdraw[forAddress] = totalReward;\n        owed[forAddress] += value;\n\n        return value;\n    }\n\n    /**\n     * @dev View remaining reward for an address.\n     * @param forAddress holder's address.\n     */\n    function rewardFor(address forAddress) public view returns (uint256) {\n        uint256 _currentBalance = rewardToken.balanceOf(address(this));\n        uint256 _totalReward = totalReward +\n        (_currentBalance > prevBalance ? _currentBalance - prevBalance : 0);\n        return\n        owed[forAddress] +\n        (holderToken.balanceOf(forAddress) *\n        (_totalReward - rewardAtTimeOfWithdraw[forAddress])) /\n        holderToken.totalSupply();\n    }\n\n    /**\n     * @dev if we got some tokens update the totalReward, has to be called on every withdraw\n     */\n    function updateTotalReward() internal returns (uint256) {\n        uint256 currentBalance = rewardToken.balanceOf(address(this));\n        if (currentBalance > prevBalance) {\n            totalReward += currentBalance - prevBalance;\n        }\n        return totalReward;\n    }\n\n    /**\n     * @dev Compute reward for holder. Returns reward.\n     * @param forAddress holder address.\n     */\n    function calcReward(address forAddress) internal view returns (uint256) {\n        return\n        (holderToken.balanceOf(forAddress) *\n        (totalReward - rewardAtTimeOfWithdraw[forAddress])) /\n        holderToken.totalSupply();\n    }\n\n    // 0 ETH transfers to trigger withdrawReward\n    fallback() external {withdrawReward();}\n}\n"
6     },
7     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
9     },
10     "contracts/DevFund.sol": {
11       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract DevFund {\n    /// --- External contracts\n\n    // token to be awarded as reward to holders\n    IERC20 public rewardToken;\n\n    // token to claim rewards\n    IERC20 public holderToken;\n\n    /// --- Storage\n\n    // total reward on contract\n    uint256 public totalReward;\n\n    // previously seen reward balance on contract\n    uint256 public prevBalance;\n\n    // User's address => Reward at time of withdraw\n    mapping(address => uint256) public rewardAtTimeOfWithdraw;\n\n    // User's address => Reward which can be withdrawn\n    mapping(address => uint256) public owed;\n\n    /**\n     * @dev Contract constructor sets reward token address.\n     */\n    constructor(address _rewardToken) {\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    /**\n     * @dev Setup function sets dev holder token address and owner, callable only once.\n     * @param _holderToken Dev holder Token address.\n     */\n    function setup(address _holderToken) external returns (bool){\n        require(address(holderToken) == address(0), \"DevFund: already setup\");\n\n        holderToken = IERC20(_holderToken);\n\n        return true;\n    }\n\n    /// --- Contract functions\n\n    /**\n     * @dev Withdraws reward for holder. Returns reward.\n     */\n    function withdrawReward() public returns (uint256) {\n        updateTotalReward();\n        uint256 value = calcReward(msg.sender) + owed[msg.sender];\n        rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n        owed[msg.sender] = 0;\n\n        require(value > 0, \"DevFund: withdrawReward nothing to transfer\");\n\n        rewardToken.transfer(msg.sender, value);\n\n        prevBalance = rewardToken.balanceOf(address(this));\n\n        return value;\n    }\n\n    /**\n     * @dev Credits reward to owed balance.\n     * @param forAddress holder's address.\n     */\n    function softWithdrawRewardFor(address forAddress) external returns (uint256){\n        updateTotalReward();\n        uint256 value = calcReward(forAddress);\n        rewardAtTimeOfWithdraw[forAddress] = totalReward;\n        owed[forAddress] += value;\n\n        return value;\n    }\n\n    /**\n     * @dev View remaining reward for an address.\n     * @param forAddress holder's address.\n     */\n    function rewardFor(address forAddress) public view returns (uint256) {\n        uint256 _currentBalance = rewardToken.balanceOf(address(this));\n        uint256 _totalReward = totalReward +\n        (_currentBalance > prevBalance ? _currentBalance - prevBalance : 0);\n        return\n        owed[forAddress] +\n        (holderToken.balanceOf(forAddress) *\n        (_totalReward - rewardAtTimeOfWithdraw[forAddress])) /\n        holderToken.totalSupply();\n    }\n\n    /**\n     * @dev if we got some tokens update the totalReward, has to be called on every withdraw\n     */\n    function updateTotalReward() internal returns (uint256) {\n        uint256 currentBalance = rewardToken.balanceOf(address(this));\n        if (currentBalance > prevBalance) {\n            totalReward += currentBalance - prevBalance;\n        }\n        return totalReward;\n    }\n\n    /**\n     * @dev Compute reward for holder. Returns reward.\n     * @param forAddress holder address.\n     */\n    function calcReward(address forAddress) internal view returns (uint256) {\n        return\n        (holderToken.balanceOf(forAddress) *\n        (totalReward - rewardAtTimeOfWithdraw[forAddress])) /\n        holderToken.totalSupply();\n    }\n\n    // 0 ETH transfers to trigger withdrawReward\n    fallback() external {withdrawReward();}\n}\n"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": true,
17       "runs": 2
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     },
31     "metadata": {
32       "useLiteralContent": true
33     },
34     "libraries": {}
35   }
36 }}