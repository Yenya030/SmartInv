1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Tornado.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n\n/*\n    RIP Tornado Cash\n    08/2019 - 08/2022\n    Public Goods Can Never Die\n*/\n\n/// @author ynot | Taken from 0xBasset | Taken from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ncontract Tornado {\n\n    uint256 constant ONE_PERCENT  = type(uint256).max / 100;\n    uint256 constant MAX_PER_USER = 1;\n\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name   = \"CRYPTONADOS\";\n    string public symbol = \"NADO\";\n\n\n    /*//////////////////////////////////////////////////////////////\n                      STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n    address public renderer;\n    address public mineableToken;\n\n    uint256 public startEpoch = 210699;\n    uint256 public maxSupply = 808;\n    uint256 public totalSupply;\n\n    mapping(uint256 => Data)        internal _tokenData;\n    mapping(address => AddressData) internal _balanceOf;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    struct Data { address owner; Details details; }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 minted;\n    }\n\n    struct Details {\n        uint8 tornadoType;     // What is the 'nado made out of?\n        uint8 fujitaScale;     // How strong is it tho?\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() { owner = msg.sender; }\n\n    function mint(uint256 amount) external {    \n        require(IERC918(mineableToken).epochCount() >= startEpoch,     \"sale not started\");\n        require(msg.sender == tx.origin,                                \"not allowed\");\n        require(totalSupply + amount <= maxSupply,                      \"max supply reached\");\n        require(_balanceOf[msg.sender].minted + amount <= MAX_PER_USER, \"already minted\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    function zMint(uint256 amount, address to) external {\n        require(msg.sender == owner, \"not allowed\");\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(to);\n        }\n    } \n\n\n    /*//////////////////////////////////////////////////////////////\n                              ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function setERC918(address mineableToken_) external {\n        require(msg.sender == owner, \"not owner\");\n        mineableToken = mineableToken_;\n    }\n\n    function setRenderer(address rend_) external {\n        require(msg.sender == owner, \"not owner\");\n        renderer = rend_;\n    }\n\n    function setOwner(address owner_) external {\n        require(msg.sender == owner, \"not owner\");\n        owner = owner_;\n    }\n\n    function withdraw(address recipient) external {\n        require(msg.sender == owner, \"not owner\");\n        (bool succ, ) = payable(recipient).call{value: address(this).balance }(\"\");\n        require(succ, \"withdraw failed\");\n    }\n\n    function setStartEpoch(uint256 startEpoch_) external {\n        require(msg.sender == owner, \"not owner\");\n        startEpoch = startEpoch_;\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        require(msg.sender == _tokenData[id].owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _tokenData[id].owner, \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from].balance--;\n\n            _balanceOf[to].balance++;\n        }\n\n        _tokenData[id].owner = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 id) public view returns (string memory) {\n        Details memory details = _tokenData[id].details;\n        return RendererLike(renderer).getURI(id, details.tornadoType, details.fujitaScale);\n    }\n\n    function ownerOf(uint256 id) public view virtual returns (address owner_) {\n        // Details memory details = _tokenData[id].details;\n        owner_ = _tokenData[id].owner;\n\n        require(owner_ != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner_) public view virtual returns (uint256) {\n        require(owner_ != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner_].balance;\n    }\n\n    function minted(address owner_) public view virtual returns (uint256) {\n        require(owner_ != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner_].minted;\n    }\n\n    function getTraits(uint256 id_) public view returns (uint256 tornadoType_, uint256 fujitaScale_) {\n        Details memory details = _tokenData[id_].details;\n\n        tornadoType_ = details.tornadoType;\n        fujitaScale_ = details.fujitaScale;\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n     function _mint(address account) internal {\n        // Generate token\n        uint256 id = ++totalSupply;\n\n        // Not the strongest entropy, but good enough for a mint\n        uint256 entropy = uint256(keccak256(abi.encode(account, block.coinbase, id, \"entropy\")));\n\n        // Tornado Type\n        uint256 typeEntropy =  uint256(uint256(keccak256(abi.encode(entropy, \"TYPE\"))));\n        uint8 tornadoType = uint8(typeEntropy % 10 + 1);\n        _tokenData[id].details.tornadoType      = tornadoType;\n\n        // Tornado Strength\n        uint256 fujitaEntropy =  uint256(uint256(keccak256(abi.encode(entropy, \"FUJITA\"))));\n        uint8 fujitaScale = uint8(\n            // If entropy smaller than 50 %, is F0 or F1\n            fujitaEntropy <= 70 * ONE_PERCENT ? (fujitaEntropy % 2): \n            // If entropy between 50% and 85%, is F2 or F3\n            fujitaEntropy <= 93 * ONE_PERCENT ? (fujitaEntropy % 2) + 2:\n            // If entropy between 85% and 98%, is F4\n            fujitaEntropy <= (99 * ONE_PERCENT ) + (ONE_PERCENT / 2) ? 4:\n            // F5 tornado mother fucker\n            5);\n        _tokenData[id].details.fujitaScale      = fujitaScale;\n\n        _mint(account, id);\n    }\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_tokenData[id].owner == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to].balance++;\n            _balanceOf[to].minted++;\n        }\n\n        _tokenData[id].owner = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner_ = _tokenData[id].owner;\n\n        require(owner_ != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner_].balance--;\n        }\n\n        delete _tokenData[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner_, address(0), id);\n    }\n\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERFACES\n    //////////////////////////////////////////////////////////////*/\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ninterface IERC918  {   \n   function epochCount() external view returns (uint);\n}\n\ninterface RendererLike {\n    function getURI(uint256 id, uint256 tornadoType, uint256 fujitaScale) external pure returns(string memory uri);\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}