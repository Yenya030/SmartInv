1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/SignatureMint.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-only+VPL\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./libraries/EIP712.sol\";\nimport \"./interfaces/IYAYOMintable.sol\";\n\n/*\n  It saves bytecode to revert on custom errors instead of using require\n  statements. We are just declaring these errors for reverting with upon various\n  conditions later in this contract.\n*/\nerror CannotMintExpiredSignature ();\nerror CannotMintInvalidSignature ();\nerror MintArrayLengthMismatch ();\nerror SignerCannotBeZero ();\n\n/**\n  @custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n  @title A contract which accepts signatures from a trusted signer to mint an\n    ERC-721 item.\n  @author Tim Clancy <tim-clancy.eth>\n  @author cheb <evmcheb.eth>\n\n  This token contract allows for the implementation of off-chain systems that\n  mint items to callers using entirely off-chain data.\n\n  @custom:date May 24th, 2023\n*/\ncontract SignatureMint is EIP712, Ownable, ReentrancyGuard {\n\n  /**\n    A constant hash of the mint operation's signature.\n  \n    @dev _minter The address of the minter for the signed-for item. This must\n      be the address of the caller.\n    @dev _expiry The expiry time after which this signature cannot execute.\n    @dev _tokenId The ID of the specific token being minted.\n  */\n  bytes32 public constant MINT_TYPEHASH = keccak256(\n    \"mint(address _minter,uint256 _expiry,uint256 _tokenId)\"\n  );\n\n  /// The name of this minter.\n  string public name;\n\n  /// The address permitted to sign claim signatures.\n  address public signer;\n\n  /// The address of the YAYO contract to mint new items into.\n  address public immutable yayo;\n\n  /**\n    An event emitted when a caller mints a new item.\n\n    @param caller The caller who claimed the tokens.\n    @param id The ID of the specific item within the ERC-721 `item` contract.\n  */\n  event Minted (\n    address indexed caller,\n    uint256 id\n  );\n\n  /**\n    Construct a new minter by providing it a permissioned claim signer which may\n    issue claims and claim amounts, and the item to mint in.\n\n    @param _name The name of the minter, used in EIP-712 domain separation.\n    @param _signer The address permitted to sign claim signatures.\n    @param _yayo The address of the YAYO NFT contract that items are minted into.\n  */\n  constructor (\n    string memory _name,\n    address _signer,\n    address _yayo\n  ) EIP712 (_name, \"1\") {\n    if (_signer == address(0)) { revert SignerCannotBeZero(); }\n    name = _name;\n    signer = _signer;\n    yayo = _yayo;\n  }\n\n  /**\n    A private helper function to validate a signature supplied for item mints.\n    This function constructs a digest and verifies that the signature signer was\n    the authorized address we expect.\n\n    @param _minter The address of the minter for the signed-for item. This must\n      be the address of the caller.\n    @param _expiry The expiry time after which this signature cannot execute.\n    @param _tokenId The specific ID of the item to mint.\n    @param _v The recovery byte of the signature.\n    @param _r Half of the ECDSA signature pair.\n    @param _s Half of the ECDSA signature pair.\n  */\n  function validMint (\n    address _minter,\n    uint256 _expiry,\n    uint256 _tokenId,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) private view returns (bool) {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(MINT_TYPEHASH, _minter, _expiry, _tokenId)\n        )\n      )\n    );\n\n    // The claim is validated if it was signed by our authorized signer.\n    return ecrecover(digest, _v, _r, _s) == signer;\n  }\n\n  /**\n    Allow a caller to mint a new item if\n      1. the mint is backed by a valid signature from the trusted `signer`.\n      2. the signature is not expired.\n\n    @param _minter The address of the minter for the signed-for item. This does\n      not have to be the address of the caller, allowing for meta-transaction\n      style minting.\n    @param _expiry The expiry time after which this signature cannot execute.\n    @param _tokenId The specific ID of the item to mint.\n    @param _v The recovery byte of the signature.\n    @param _r Half of the ECDSA signature pair.\n    @param _s Half of the ECDSA signature pair.\n  */\n  function _mint (\n    address _minter,\n    uint256 _expiry,\n    uint256 _tokenId,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) internal nonReentrant {\n\n    // Validate the expiration time.\n    if (_expiry < block.timestamp) { revert CannotMintExpiredSignature(); }\n\n    // Validiate that the claim was provided by our trusted `signer`.\n    bool validSignature = validMint(_minter, _expiry, _tokenId, _v, _r, _s);\n    if (!validSignature) {\n      revert CannotMintInvalidSignature();\n    }\n\n    // Mint the new item.\n    IYAYOMintable yayoContract = IYAYOMintable(yayo);\n    yayoContract.mint(_minter, _tokenId);\n\n    // Emit an event.\n    emit Minted(_minter, _tokenId);\n  }\n\n  /**\n    Allow a caller to mint any new items in an array if, for each item\n      1. the mint is backed by a valid signature from the trusted `signer`.\n      2. the signature is not expired.\n\n    @param _minters Addresses of the minters for the signed-for item. This\n      does not have to be the address of the caller, allowing for\n      meta-transaction style minting.\n    @param _expiries The expiry times after which a signature cannot execute.\n    @param _tokenIds The specific IDs of the items to mint.\n    @param _v The recovery bytes of the signature.\n    @param _r Halves of the ECDSA signature pair.\n    @param _s Halves of the ECDSA signature pair.\n  */\n  function mint (\n    address[] memory _minters,\n    uint256[] memory _expiries,\n    uint256[] memory _tokenIds,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) external {\n    if (\n      _minters.length != _expiries.length || \n      _minters.length != _tokenIds.length || \n      _minters.length != _v.length ||\n      _minters.length != _r.length ||\n      _minters.length != _s.length\n    ) {\n      revert MintArrayLengthMismatch();\n    }\n\n    // Mint each item.\n    for (uint256 i = 0; i < _minters.length; i++) {\n      _mint(_minters[i], _expiries[i], _tokenIds[i], _v[i], _r[i], _s[i]);\n    }\n  }\n\n  /**\n    An administrative function to change the signer address. This may be used to\n    rotate the signer address routinely or in the event of a key compromise.\n    The zero address is used to disable the signer entirely.\n\n    @param _newSigner The address of the new address permitted to sign claim\n      signatures.\n  */\n  function setSigner (\n    address _newSigner\n  ) external onlyOwner {\n    if (_newSigner == address(0)) {\n      revert SignerCannotBeZero();\n    }\n    signer = _newSigner;\n  }\n}\n"
6     },
7     "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
12     },
13     "src/libraries/EIP712.sol": {
14       "content": "pragma solidity ^0.8.11;\n\nabstract contract EIP712 {\n    struct EIP712Domain {\n        string name;\n        string version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    bytes32 constant EIP712DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    bytes internal personalSignPrefix = \"\\x19Ethereum Signed Message:\\n\";\n\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor(string memory name, string memory version) {\n        uint256 chainId_;\n        assembly {\n            chainId_ := chainid()\n        }\n        DOMAIN_SEPARATOR =\n            hash(EIP712Domain({name: name, version: version, chainId: chainId_, verifyingContract: address(this)}));\n    }\n\n    function hash(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(bytes(eip712Domain.name)),\n                keccak256(bytes(eip712Domain.version)),\n                eip712Domain.chainId,\n                eip712Domain.verifyingContract\n            )\n        );\n    }\n\n    function parseSignature(bytes memory signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return (v, r, s);\n    }\n}\n"
15     },
16     "src/interfaces/IYAYOMintable.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only+VPL\npragma solidity ^0.8.19;\n\n/**\n  @custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n  @title A contract for minting new Ethereum-side YAYO tokens.\n  @author cheb <evmcheb.eth>\n  @author Tim Clancy <tim-clancy.eth>\n  \n  This token contract allows for privileged callers to mint new YAYO.\n\n  @custom:date May 24th, 2023\n*/\ninterface IYAYOMintable {\n\n  /**\n    A permissioned minting function. This function may only be called by the\n    admin-specified minter.\n\n    @param _to The recipient of the minted item.\n    @param _tokenId The ID of the item to mint.\n  */\n  function mint (\n    address _to,\n    uint256 _tokenId\n  ) external;\n}\n\n"
18     },
19     "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
21     }
22   },
23   "settings": {
24     "remappings": [
25       "@openzeppelin/=lib/openzeppelin-contracts/",
26       "ds-test/=lib/forge-std/lib/ds-test/src/",
27       "forge-std/=lib/forge-std/src/",
28       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
29       "solady/=lib/solady/src/",
30       "solarray/=lib/solarray/src/",
31       "solmate/=lib/solady/lib/solmate/src/"
32     ],
33     "optimizer": {
34       "enabled": true,
35       "runs": 200
36     },
37     "metadata": {
38       "bytecodeHash": "ipfs",
39       "appendCBOR": true
40     },
41     "outputSelection": {
42       "*": {
43         "*": [
44           "evm.bytecode",
45           "evm.deployedBytecode",
46           "devdoc",
47           "userdoc",
48           "metadata",
49           "abi"
50         ]
51       }
52     },
53     "evmVersion": "paris",
54     "libraries": {}
55   }
56 }}