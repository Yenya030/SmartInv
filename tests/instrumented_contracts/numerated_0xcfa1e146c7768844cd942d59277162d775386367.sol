1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/GrannysMysteryBox.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n/*****************************************************************************************************************************************************\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        (@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@            @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@                &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@        @@        .@@@@@@@@@@@@@@@         @         @@                       @@,        @@@@@@@@@,                  @@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@        @@@@         @@@@@@@@@@@@@@                   @@                       @@,        @@@@@@@                        @@@@@@@@@@@@\n @@@@@@@@@@@@@@@        @@@@@@         @@@@@@@@@@@@@                   @@                       @@,        @@@@@          (@@@@@@          @@@@@@@@@@@\n @@@@@@@@@@@@@(        @@@@@@@@         @@@@@@@@@@@@          @@@@@@@@@@@@@@@@@         @@@@@@@@@@,        @@@@         @@@@@@@@@@@         @@@@@@@@@@\n @@@@@@@@@@@@         @@@@@@@@@@         @@@@@@@@@@@         @@@@@@@@@@@@@@@@@@         @@@@@@@@@@,        @@@         @@@@@@@@@@@&%         @@@@@@@@@\n @@@@@@@@@@@                              @@@@@@@@@@         @@@@@@@@@@@@@@@@@@         @@@@@@@@@@,        @@@                               @@@@@@@@@\n @@@@@@@@@@                                @@@@@@@@@         @@@@@@@@@@@@@@@@@@         @@@@@@@@@@,        @@@                               @@@@@@@@@\n @@@@@@@@@                                  @@@@@@@@         @@@@@@@@@@@@@@@@@@         @@@@@@@@@@,        @@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@                                    @@@@@@@         @@@@@@@@@@@@@@@@@@          @@@@@@@@@.        @@@@         @@@@@@@@@@@@@@ @@@@@@@@@@@@@@@\n @@@@@@@         @@@@@@@@@@@@@@@@@@@@         @@@@@@         @@@@@@@@@@@@@@@@@@                 @@,        @@@@@            @@@@@         @@@@@@@@@@@@\n @@@@@@         @@@@@@@@@@@@@@@@@@@@@@         @@@@@         @@@@@@@@@@@@@@@@@@@                @@,        @@@@@@@                         @@@@@@@@@@@\n @@@@@         @@@@@@@@@@@@@@@@@@@@@@@@         @@@@         @@@@@@@@@@@@@@@@@@@@               @@,        @@@@@@@@@@                   @@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     (@@@@@@@@@@@@@@@@@@@@\n @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n*****************************************************************************************************************************************************/\npragma solidity ^0.8.0;\n\ninterface IDispensary {\n    function safeMint(address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBurn(address to, uint256 tokenID, uint256 amount) external;\n}\n\ninterface IHashGenerator {\n    function generateHash(uint256 i) external view returns (bytes32);\n}\n\ncontract GrannysMysteryBox {\n    IDispensary private immutable dispensary;\n    IHashGenerator private immutable hashGenerator;\n    uint256 private immutable burnID;\n    uint16[] private maxDroppable;\n    uint16[] private dropped;\n    uint256[] private tokenIds;\n    uint256[] private autoDropTokenIds;\n    uint256[] private dropRates;\n\n\n    constructor(address _dispensary, address _hashGenerator, uint256 _burnID, uint256[] memory _tokenIds, uint256[] memory _autoDropTokenIds, uint256[] memory _dropRates, uint16[] memory _maxDroppable) {\n        require(_tokenIds.length == _dropRates.length && _tokenIds.length == _maxDroppable.length, \"ARRAY LENGTH MISMATCH\");\n        uint256 sum = 0;\n        for (uint256 i = 0; i < _dropRates.length; i++) {\n            sum += _dropRates[i];\n        }\n        require(sum == 2**256 - 1, \"Sum of drop rates does not equal MAX_INT\");\n\n        dispensary = IDispensary(_dispensary);\n        hashGenerator = IHashGenerator(_hashGenerator);\n        burnID = _burnID;\n        tokenIds = _tokenIds;\n        autoDropTokenIds = _autoDropTokenIds;\n        dropRates = _dropRates;\n        maxDroppable = _maxDroppable;\n        dropped = new uint16[](_tokenIds.length);\n    }\n\n    function getNextRandomHash(uint256 seed, uint256 index, uint256 rotation, uint256 hash) internal pure returns (uint256) {\n        //Rotates the given hash around the uint256 bytespace given a rotation value\n        //XOR with the current value of the hash to get a continuous stream of new values\n        unchecked {\n            uint256 rotation_mod = ((rotation * index) % 256);\n            return (seed << rotation_mod | seed >> (256 - rotation_mod)) ^ hash;\n        }\n    }\n\n\n    //Gas optimization: https://0xmacro.com/blog/solidity-gas-optimizations-cheat-sheet/\n    function burn(uint16 amount) external {\n        require(amount > 0, \"You can't burn 0 tokens\");\n        //burn the token, will only succeed if the msg.sender has a sufficient amount of burnID in their wallet\n        dispensary.safeBurn(msg.sender, burnID, amount);\n\n\n        //Local Variable initialization\n        uint16 leftover;\n        uint16 delta;\n        //Generate the random hash\n        uint256 seed = uint256(hashGenerator.generateHash(amount));\n        uint256 hash;\n        uint256 rotation;\n\n        //SLOAD optimization\n        uint16[] memory _dropped = dropped;\n        uint16[] memory _maxDroppable = maxDroppable;\n        uint16[] memory dropping = new uint16[](_maxDroppable.length);\n        uint256[] memory _tokenIds = autoDropTokenIds;\n        //Drop all of the tokenIds that have a 100% drop rate\n        for (uint256 i = 0; i < _tokenIds.length;) {\n            dispensary.safeMint(msg.sender, _tokenIds[i], amount, '');\n            unchecked {\n                i++;\n            }\n        }\n        _tokenIds = tokenIds;\n        uint256[] memory _dropRates = dropRates;\n\n\n        unchecked {\n            //Select which tokenId should be won based off of a given hash from 0 -> uint256_MAX_INT\n            for (uint256 j = 0; j < amount; j++) {\n                rotation = seed>>((hash % 32) * 8);\n                hash = getNextRandomHash(seed, j, rotation, hash);\n                for (uint256 i = 0; i < _tokenIds.length; i++) {\n                    if (hash <= _dropRates[i]) {\n                        dropping[i]++;\n                        break;\n                    } else {\n                        hash -= _dropRates[i];\n                    }\n                }\n            }\n            //Mint won tokens, if the tokens won exceeds the maxDroppable then add the remainder to the leftover value\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\n                if (dropping[i] > 0) {\n                    if (_maxDroppable[i] >= _dropped[i] + dropping[i]) {\n                        dispensary.safeMint(msg.sender, _tokenIds[i], dropping[i], '');\n                        _dropped[i] += dropping[i];\n                    } else {\n                        delta = _maxDroppable[i] - _dropped[i];\n                        leftover += dropping[i] - delta;\n                        if (delta > 0) {\n                            dispensary.safeMint(msg.sender, _tokenIds[i], delta, '');\n                            _dropped[i] += delta;\n                        }\n                    }\n                }\n            }\n            //If the leftover value is not zero then assign the leftovers in the priority order of the tokenIds array if possible\n            if (leftover > 0) {\n                for (uint256 i = 0; i < _tokenIds.length; i++) {\n                    if (_maxDroppable[i] > _dropped[i] && leftover > 0) {\n                        if (_maxDroppable[i] >= _dropped[i] + leftover) {\n                            dispensary.safeMint(msg.sender, _tokenIds[i], leftover, '');\n                            _dropped[i] += leftover;\n                            break;\n                        } else {\n                            delta = _maxDroppable[i] - _dropped[i];\n                            dispensary.safeMint(msg.sender, _tokenIds[i], delta, '');\n                            leftover -= delta;\n                            _dropped[i] += delta;\n                        }\n                    }\n                }\n            }\n        }\n        dropped = _dropped;\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 10000
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}