1 pragma solidity 0.5.6;
2 
3 
4 /**
5  * @title Metapod (Version 1)
6  * @author 0age
7  * @notice This contract creates "hardened" metamorphic contracts, or contracts
8  * that can be redeployed with new code to the same address, with additional
9  * protections against creating non-metamorphic contracts or losing any balance
10  * held by the contract when it is destroyed. It does so by first setting the
11  * desired contract initialization code in temporary storage. Next, a vault
12  * contract corresponding to the target address is checked for a balance, and if
13  * one exists it will be sent to the address of an intermediate deployer, or a
14  * transient contract with fixed, non-deterministic initialization code. Once
15  * deployed via CREATE2, the transient contract retrieves the initialization
16  * code from storage and uses it to deploy the contract via CREATE, forwarding
17  * the entire balance to the new contract, and then SELFDESTRUCTs. Finally, the
18  * contract prelude is checked to ensure that it is properly destructible and
19  * that it designates the vault as the forwarding address. Once the contract
20  * undergoes metamorphosis, all existing storage will be deleted and any balance
21  * will be forwarded to the vault that can then resupply the metamorphic
22  * contract upon redeployment.
23  * @dev This contract has not yet been fully tested or audited - proceed with
24  * abundant caution and please share any exploits or optimizations you discover.
25  * Also, bear in mind that any initialization code provided to the contract must
26  * contain the proper prelude, or initial sequence, with a length of 44 bytes:
27  *
28  *  `0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773 + vault_address + 0xff5b`
29  *
30  * For the required vault address, use `findVaultContractAddress(bytes32 salt)`.
31  * Any initialization code generated by Solidity or another compiler will need
32  * to have the stack items provided to JUMP, JUMPI, and CODECOPY altered
33  * appropriately upon inserting this code, and may also need to alter some PC
34  * operations (especially if it is not Solidity code). Be aware that contracts
35  * are still accessible after they have been scheduled for deletion until the
36  * transaction is completed, and that ether may still be sent to them - as the
37  * funds forwarding step is performed immediately, not as part of the
38  * transaction substate with the account removal. If those funds do not move to
39  * a non-destructing account by the end of the transaction, they will be
40  * irreversibly burned. Lastly, due to the mechanics of SELFDESTRUCT, a contract
41  * cannot be destroyed and redeployed in a single transaction - to avoid
42  * "downtime" of the contract, consider utilizing multiple contracts and having
43  * the callers determine the current contract by using EXTCODEHASH.
44  */
45 contract Metapod {
46   // fires when a metamorphic contract is deployed.
47   event Metamorphosed(address metamorphicContract, bytes32 salt);
48 
49   // fires when a metamorphic contract is destroyed.
50   event Cocooned(address metamorphicContract, bytes32 salt);
51 
52   // initialization code for transient contract to deploy metamorphic contracts.
53   /* ##  op  operation        [stack] <memory> {return_buffer} *contract_deploy*
54      00  58  PC               [0]
55      01  60  PUSH1 0x1c       [0, 28]
56      03  59  MSIZE            [0, 28, 0]
57      04  58  PC               [0, 28, 0, 4]
58      05  59  MSIZE            [0, 28, 0, 4, 0]
59      06  92  SWAP3            [0, 0, 0, 4, 28]
60      07  33  CALLER           [0, 0, 0, 4, 28, caller]
61      08  5a  GAS              [0, 0, 0, 4, 28, caller, gas]
62      09  63  PUSH4 0x57b9f523 [0, 0, 0, 4, 28, caller, gas, selector]
63      14  59  MSIZE            [0, 0, 0, 4, 28, caller, gas, selector, 0]
64      15  52  MSTORE           [0, 0, 0, 4, 28, caller, gas] <selector>
65      16  fa  STATICCALL       [0, 1 => success] {init_code}
66      17  50  POP              [0]
67      18  60  PUSH1 0x40       [0, 64]
68      20  30  ADDRESS          [0, 64, address]
69      21  31  BALANCE          [0, 64, balance]
70      22  81  DUP2             [0, 64, balance, 64]
71      23  3d  RETURNDATASIZE   [0, 64, balance, 64, size]
72      24  03  SUB              [0, 64, balance, size - 64]
73      25  83  DUP4             [0, 64, balance, size - 64, 0]
74      26  92  SWAP3            [0, 0, balance, size - 64, 64]
75      27  81  DUP2             [0, 0, balance, size - 64, 64, size - 64]
76      28  94  SWAP5            [size - 64, 0, balance, size - 64, 64, 0]
77      29  3e  RETURNDATACOPY   [size - 64, 0, balance] <init_code>
78      30  f0  CREATE           [contract_address or 0] *init_code*
79      31  80  DUP1             [contract_address or 0, contract_address or 0]
80      32  15  ISZERO           [contract_address or 0, 0 or 1]
81      33  60  PUSH1 0x25       [contract_address or 0, 0 or 1, 37]
82      35  57  JUMPI            [contract_address]
83      36  ff  SELFDESTRUCT     []
84      37  5b  JUMPDEST         [0]
85      38  80  DUP1             [0, 0]
86      39  fd  REVERT           []
87   */
88   bytes private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE = (
89     hex"58601c59585992335a6357b9f5235952fa5060403031813d03839281943ef08015602557ff5b80fd"
90   );
91 
92   // store the hash of the initialization code for transient contracts as well.
93   bytes32 private constant TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH = bytes32(
94     0xb7d11e258d6663925ce8e43f07ba3b7792a573ecc2fd7682d01f8a70b2223294
95   );
96 
97   // the "empty data hash" is used to determine if the vault has been deployed.
98   bytes32 private constant EMPTY_DATA_HASH = bytes32(
99     0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
100   );
101 
102   // maintain a temporary storage slot for metamorphic initialization code.
103   bytes private _initCode;
104 
105   constructor() public {
106     // ensure that the deployment address is correct.
107     // factory: 0x00000000e82eb0431756271F0d00CFB143685e7B
108     // caller: 0x0734d56DA60852A03e2Aafae8a36FFd8c12B32f1
109     // init code hash: 0x8954ff8965dbf871b7b4f49acc85a2a7c96c93ebc16ba59a4d07c52d8d0b6ec2
110     // salt: 0x0734d56da60852a03e2aafae8a36ffd8c12b32f1ee8671f229d5dd0853050000
111     require(
112       address(this) == address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C),
113       "Incorrect deployment address."
114     );
115 
116     // ensure the transient initialization code hash constant value is correct.
117     require(
118       keccak256(
119         abi.encodePacked(TRANSIENT_CONTRACT_INITIALIZATION_CODE)
120       ) == TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH,
121       "Incorrect hash for transient initialization code."
122     );
123 
124     // ensure the empty data hash constant value is correct.
125     require(
126       keccak256(abi.encodePacked(hex"")) == EMPTY_DATA_HASH,
127       "Incorrect hash for empty data."
128     );
129   }
130 
131   /**
132    * @dev Deploy a metamorphic contract by submitting a given salt or nonce
133    * along with the initialization code to a transient contract which will then
134    * deploy the metamorphic contract before immediately SELFDESTRUCTing. To
135    * replace the metamorphic contract, call destroy() with the same salt value,
136    * then call with the same salt value and new initialization code (be aware
137    * that all existing state will be wiped from the contract).
138    * @param identifier uint96 The last twelve bytes of the salt that will be
139    * passed into the CREATE2 call (with the first twenty bytes of the salt set
140    * to `msg.sender`) and thus will determine the resulant address of the
141    * metamorphic contract.
142    * @param initializationCode bytes The initialization code for the metamorphic
143    * contract that will be deployed by the transient contract.
144    * @return The address of the deployed metamorphic contract.
145    */
146   function deploy(
147     uint96 identifier,
148     bytes calldata initializationCode
149   ) external payable returns (address metamorphicContract) {
150     // compute the salt using the supplied identifier.
151     bytes32 salt = _getSalt(identifier);
152 
153     // store the initialization code to be retrieved by the transient contract.
154     _initCode = initializationCode;
155 
156     // get vault contract and provide any funds therein to transient contract.
157     address vaultContract = _triggerVaultFundsRelease(salt);
158 
159     // declare variable to verify successful transient contract deployment.
160     address transientContract;
161 
162     // move transient contract initialization code into memory.
163     bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;
164 
165     // load transient contract init data and size, then deploy via CREATE2.
166     assembly { /* solhint-disable no-inline-assembly */
167       let encoded_data := add(0x20, initCode) // load initialization code.
168       let encoded_size := mload(initCode)     // load the init code's length.
169       transientContract := create2(           // call CREATE2 with 4 arguments.
170         callvalue,                            // forward any supplied endowment.
171         encoded_data,                         // pass in initialization code.
172         encoded_size,                         // pass in init code's length.
173         salt                                  // pass in the salt value.
174       )
175     } /* solhint-enable no-inline-assembly */
176 
177     // ensure that the contracts were successfully deployed.
178     require(transientContract != address(0), "Failed to deploy contract.");
179 
180     // get the address of the deployed metamorphic contract.
181     metamorphicContract = _getMetamorphicContractAddress(transientContract);
182 
183     // ensure that the deployed runtime code has the required prelude.
184     _verifyPrelude(metamorphicContract, _getPrelude(vaultContract));
185 
186     // clear the supplied initialization code from temporary storage.
187     delete _initCode;
188 
189     // emit an event to signify that the contract was successfully deployed.
190     emit Metamorphosed(metamorphicContract, salt);
191   }
192 
193   /**
194    * @dev Destroy a metamorphic contract by calling into it, which will trigger
195    * a SELFDESTRUCT and forward all funds to the designated vault contract. Be
196    * aware that all existing state will be wiped from the contract.
197    * @param identifier uint96 The last twelve bytes of the salt that was passed
198    * into the CREATE2 call (with the first twenty bytes of the salt set to
199    * `msg.sender`) that determined resulant address of the metamorphic contract.
200    */
201   function destroy(uint96 identifier) external {
202     // compute the salt using the supplied identifier.
203     bytes32 salt = _getSalt(identifier);
204 
205     // determine the address of the metamorphic contract.
206     address metamorphicContract = _getMetamorphicContractAddress(
207       _getTransientContractAddress(salt)
208     );
209 
210     // call it to trigger a SELFDESTRUCT that forwards any funds to the vault.
211     metamorphicContract.call(""); /* solhint-disable-line avoid-low-level-calls */
212 
213     // emit an event to signify that the contract was scheduled for deletion.
214     emit Cocooned(metamorphicContract, salt);
215   }
216 
217   /**
218    * @dev Recover the funds from a metamorphic contract, the associated vault,
219    * and the associated transient contract by deploying a dedicated metamorphic
220    * contract that will forward funds to `msg.sender` and immediately
221    * SELFDESTRUCT. The contract must be "cocooned" or else it will fail.
222    * @param identifier uint96 The last twelve bytes of the salt that was passed
223    * into the CREATE2 call (with the first twenty bytes of the salt set to
224    * `msg.sender`) that determined resulant address of the metamorphic contract.
225    */
226   function recover(uint96 identifier) external {
227     // compute the salt using the supplied identifier.
228     bytes32 salt = _getSalt(identifier);
229 
230     // trigger the vault contract to forward funds to the transient contract.
231     _triggerVaultFundsRelease(salt);
232 
233     // construct recovery contract initialization code and set in temp storage.
234     _initCode = abi.encodePacked(
235       bytes2(0x5873),  // PC PUSH20
236       msg.sender,      // <the caller is the recipient of funds>
237       bytes13(0x905959593031856108fcf150ff)
238         // SWAP1 MSIZEx3 ADDRESS BALANCE DUP6 PUSH2 2300 CALL POP SELFDESTRUCT
239     );
240 
241     // declare variable to verify successful transient contract deployment.
242     address transientContract;
243 
244     // move transient contract initialization code into memory.
245     bytes memory initCode = TRANSIENT_CONTRACT_INITIALIZATION_CODE;
246 
247     // load transient contract init data and size, then deploy via CREATE2.
248     assembly { /* solhint-disable no-inline-assembly */
249       let encoded_data := add(0x20, initCode) // load initialization code.
250       let encoded_size := mload(initCode)     // load the init code's length.
251       transientContract := create2(           // call CREATE2 with 4 arguments.
252         callvalue,                            // forward any supplied endowment.
253         encoded_data,                         // pass in initialization code.
254         encoded_size,                         // pass in init code's length.
255         salt                                  // pass in the salt value.
256       )
257     } /* solhint-enable no-inline-assembly */
258 
259     // ensure that the recovery contract was successfully deployed.
260     require(
261       transientContract != address(0),
262       "Recovery failed - ensure that the contract has been destroyed."
263     );
264 
265     // clear recovery contract initialization code from temporary storage.
266     delete _initCode;
267   }
268 
269   /**
270    * @dev View function for retrieving the initialization code for a given
271    * metamorphic contract to deploy via a transient contract. Called by the
272    * constructor of each transient contract - not meant to be called by users.
273    * @return The initialization code to use to deploy the metamorphic contract.
274    */
275   function getInitializationCode() external view returns (
276     bytes memory initializationCode
277   ) {
278     // return the current initialization code from temporary storage.
279     initializationCode = _initCode;
280   }
281 
282   /**
283    * @dev Compute the address of the transient contract that will be created
284    * upon submitting a given salt to the contract.
285    * @param salt bytes32 The nonce passed into CREATE2 when deploying the
286    * transient contract, composed of caller ++ identifier.
287    * @return The address of the corresponding transient contract.
288    */
289   function findTransientContractAddress(
290     bytes32 salt
291   ) external pure returns (address transientContract) {
292     // determine the address where the transient contract will be deployed.
293     transientContract = _getTransientContractAddress(salt);
294   }
295 
296   /**
297    * @dev Compute the address of the metamorphic contract that will be created
298    * upon submitting a given salt to the contract.
299    * @param salt bytes32 The nonce used to create the transient contract that
300    * deploys the metamorphic contract, composed of caller ++ identifier.
301    * @return The address of the corresponding metamorphic contract.
302    */
303   function findMetamorphicContractAddress(
304     bytes32 salt
305   ) external pure returns (address metamorphicContract) {
306     // determine the address of the metamorphic contract.
307     metamorphicContract = _getMetamorphicContractAddress(
308       _getTransientContractAddress(salt)
309     );
310   }
311 
312   /**
313    * @dev Compute the address of the vault contract that will be set as the
314    * recipient of funds from the metamorphic contract when it is destroyed.
315    * @param salt bytes32 The nonce used to create the transient contract that
316    * deploys the metamorphic contract, composed of caller ++ identifier.
317    * @return The address of the corresponding vault contract.
318    */
319   function findVaultContractAddress(
320     bytes32 salt
321   ) external pure returns (address vaultContract) {
322     vaultContract = _getVaultContractAddress(
323       _getVaultContractInitializationCode(
324         _getTransientContractAddress(salt)
325       )
326     );
327   }
328 
329   /**
330    * @dev View function for retrieving the prelude that will be required for any
331    * metamorphic contract deployed via a specific salt.
332    * @param salt bytes32 The nonce used to create the transient contract that
333    * deploys the metamorphic contract, composed of caller ++ identifier.
334    * @return The prelude that will be need to be present at the start of the
335    * deployed runtime code for any metamorphic contracts deployed using the
336    * provided salt.
337    */
338   function getPrelude(bytes32 salt) external pure returns (
339     bytes memory prelude
340   ) {
341     // compute and return the prelude.
342     prelude = _getPrelude(
343       _getVaultContractAddress(
344         _getVaultContractInitializationCode(
345           _getTransientContractAddress(salt)
346         )
347       )
348     );
349   }  
350 
351   /**
352    * @dev View function for retrieving the initialization code of metamorphic
353    * contracts for purposes of verification.
354    * @return The initialization code used to deploy transient contracts.
355    */
356   function getTransientContractInitializationCode() external pure returns (
357     bytes memory transientContractInitializationCode
358   ) {
359     // return the initialization code used to deploy transient contracts.
360     transientContractInitializationCode = (
361       TRANSIENT_CONTRACT_INITIALIZATION_CODE
362     );
363   }
364 
365   /**
366    * @dev View function for retrieving the keccak256 hash of the initialization
367    * code of metamorphic contracts for purposes of verification.
368    * @return The keccak256 hash of the initialization code used to deploy
369    * transient contracts.
370    */
371   function getTransientContractInitializationCodeHash() external pure returns (
372     bytes32 transientContractInitializationCodeHash
373   ) {
374     // return hash of initialization code used to deploy transient contracts.
375     transientContractInitializationCodeHash = (
376       TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH
377     );
378   }
379 
380   /**
381    * @dev View function for calculating a salt given a particular caller and
382    * identifier.
383    * @param identifier bytes12 The last twelve bytes of the salt (the first
384    * twenty bytes are set to `msg.sender`).
385    * @return The salt that will be supplied to CREATE2 upon providing the given
386    * identifier from the calling account.
387    */
388   function getSalt(uint96 identifier) external view returns (bytes32 salt) {
389     salt = _getSalt(identifier);
390   }
391 
392   /**
393    * @dev Internal view function for calculating a salt given a particular
394    * caller and identifier.
395    * @param identifier bytes12 The last twelve bytes of the salt (the first
396    * twenty bytes are set to `msg.sender`).
397    * @return The salt that will be supplied to CREATE2.
398    */
399   function _getSalt(uint96 identifier) internal view returns (bytes32 salt) {
400     assembly { /* solhint-disable no-inline-assembly */
401       salt := or(shl(96, caller), identifier) // caller: first 20, ID: last 12
402     } /* solhint-enable no-inline-assembly */
403   }
404 
405   /**
406    * @dev Internal function for determining the required prelude for metamorphic
407    * contracts deployed through the factory based on the corresponding vault
408    * contract.
409    * @param vaultContract address The address of the vault contract.
410    * @return The prelude that will be required for given a vault contract.
411    */
412   function _getPrelude(
413     address vaultContract
414   ) internal pure returns (bytes memory prelude) {
415     prelude = abi.encodePacked(
416       // PUSH15 <this> CALLER XOR PUSH1 43 JUMPI PUSH20
417       bytes22(0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773),
418       vaultContract, // <vault is the approved SELFDESTRUCT recipient>
419       bytes2(0xff5b) // SELFDESTRUCT JUMPDEST
420     );
421   }
422 
423   /**
424    * @dev Internal function for determining if deployed metamorphic contract has
425    * the necessary prelude at the start of its runtime code. The prelude ensures
426    * that the contract can be destroyed by a call originating from this contract
427    * and that any funds will be forwarded to the corresponding vault contract.
428    * @param metamorphicContract address The address of the metamorphic contract.
429    * @param prelude bytes The prelude that must be present on the contract.
430    */
431   function _verifyPrelude(
432     address metamorphicContract,
433     bytes memory prelude
434   ) internal view {
435     // get the first 44 bytes of metamorphic contract runtime code.
436     bytes memory runtimeHeader;
437 
438     assembly { /* solhint-disable no-inline-assembly */
439       // set and update the pointer based on the size of the runtime header.
440       runtimeHeader := mload(0x40)
441       mstore(0x40, add(runtimeHeader, 0x60))
442 
443       // store the runtime header code and length in memory.
444       mstore(runtimeHeader, 44)
445       extcodecopy(metamorphicContract, add(runtimeHeader, 0x20), 0, 44)
446     } /* solhint-enable no-inline-assembly */
447 
448     // ensure that the contract's runtime code has the correct prelude.
449     require(
450       keccak256(
451         abi.encodePacked(prelude)
452       ) == keccak256(
453         abi.encodePacked(runtimeHeader)
454       ),
455       "Deployed runtime code does not have the required prelude."
456     );
457   }
458 
459   /**
460    * @dev Internal function for determining if a vault contract has a balance
461    * and tranferring the balance to the corresponding transient contract if so.
462    * This is achieved via deploying the vault contract if no contract exists yet
463    * or by calling the contract if it has already been deployed.
464    * @param salt bytes32 The nonce used to create the transient contract that
465    * deploys the metamorphic contract associated with a corresponding vault.
466    * @return The address of the vault contract.
467    */
468   function _triggerVaultFundsRelease(
469     bytes32 salt
470   ) internal returns (address vaultContract) {
471     // determine the address of the transient contract.
472     address transientContract = _getTransientContractAddress(salt);
473 
474     // determine the initialization code of the vault contract.
475     bytes memory vaultContractInitCode = _getVaultContractInitializationCode(
476       transientContract
477     );
478 
479     // determine the address of the vault contract.
480     vaultContract = _getVaultContractAddress(vaultContractInitCode);
481 
482     // determine if the vault has a balance.
483     if (vaultContract.balance > 0) {
484       // determine if the vault has already been deployed.
485       bytes32 vaultContractCodeHash;
486 
487       assembly { /* solhint-disable no-inline-assembly */
488         vaultContractCodeHash := extcodehash(vaultContract)
489       } /* solhint-enable no-inline-assembly */
490 
491       // if it hasn't been deployed, deploy it to send funds to transient.
492       if (vaultContractCodeHash == EMPTY_DATA_HASH) {
493         assembly { /* solhint-disable no-inline-assembly */
494           let encoded_data := add(0x20, vaultContractInitCode) // init code.
495           let encoded_size := mload(vaultContractInitCode)     // init length.
496           let _ := create2(                   // call CREATE2.
497             0,                                // do not supply any endowment.
498             encoded_data,                     // pass in initialization code.
499             encoded_size,                     // pass in init code's length.
500             0                                 // pass in zero as the salt value.
501           )
502         } /* solhint-enable no-inline-assembly */
503       // otherwise, just call it which will also send funds to transient.
504       } else {
505         vaultContract.call(""); /* solhint-disable-line avoid-low-level-calls */
506       }
507     }
508   }
509 
510   /**
511    * @dev Internal view function for calculating a transient contract address
512    * given a particular salt.
513    * @param salt bytes32 The nonce used to create the transient contract.
514    * @return The address of the transient contract.
515    */
516   function _getTransientContractAddress(
517     bytes32 salt
518   ) internal pure returns (address transientContract) {
519     // determine the address of the transient contract.
520     transientContract = address(
521       uint160(                      // downcast to match the address type.
522         uint256(                    // convert to uint to truncate upper digits.
523           keccak256(                // compute the CREATE2 hash using 4 inputs.
524             abi.encodePacked(       // pack all inputs to the hash together.
525               hex"ff",              // start with 0xff to distinguish from RLP.
526               address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.
527               salt,                 // pass in the supplied salt value.
528               TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH // the init code hash.
529             )
530           )
531         )
532       )
533     );
534   }
535 
536   /**
537    * @dev Internal view function for calculating a metamorphic contract address
538    * that has been deployed via a transient contract given the address of the
539    * transient contract.
540    * @param transientContract address The address of the transient contract.
541    * @return The address of the metamorphic contract.
542    */
543   function _getMetamorphicContractAddress(
544     address transientContract
545   ) internal pure returns (address metamorphicContract) {
546     // determine the address of the metamorphic contract.
547     metamorphicContract = address(
548       uint160(                          // downcast to match the address type.
549         uint256(                        // set to uint to truncate upper digits.
550           keccak256(                    // compute CREATE hash via RLP encoding.
551             abi.encodePacked(           // pack all inputs to the hash together.
552               bytes2(0xd694),           // first two RLP bytes.
553               transientContract,        // called by the transient contract.
554               byte(0x01)                // nonce begins at 1 for contracts.
555             )
556           )
557         )
558       )
559     );
560   }
561 
562   /**
563    * @dev Internal view function for calculating a initialization code for a
564    * given vault contract based on the corresponding transient contract.
565    * @param transientContract address The address of the transient contract.
566    * @return The initialization code for the vault contract.
567    */
568   function _getVaultContractInitializationCode(
569     address transientContract
570   ) internal pure returns (bytes memory vaultContractInitializationCode) {
571     vaultContractInitializationCode = abi.encodePacked(
572       // PC PUSH15 <this> CALLER XOR PC JUMPI MSIZEx3 ADDRESS BALANCE PUSH20
573       bytes27(0x586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173),
574       // the transient contract is the recipient of funds
575       transientContract,
576       // GAS CALL PUSH1 49 MSIZE DUP2 MSIZEx2 CODECOPY RETURN
577       bytes10(0x5af160315981595939f3)
578     );
579   }
580 
581   /**
582    * @dev Internal view function for calculating a vault contract address given
583    * the initialization code for the vault contract.
584    * @param vaultContractInitializationCode bytes The initialization code of the
585    * vault contract.
586    * @return The address of the vault contract.
587    */
588   function _getVaultContractAddress(
589     bytes memory vaultContractInitializationCode
590   ) internal pure returns (address vaultContract) {
591     // determine the address of the vault contract.
592     vaultContract = address(
593       uint160(                      // downcast to match the address type.
594         uint256(                    // convert to uint to truncate upper digits.
595           keccak256(                // compute the CREATE2 hash using 4 inputs.
596             abi.encodePacked(       // pack all inputs to the hash together.
597               byte(0xff),           // start with 0xff to distinguish from RLP.
598               address(0x00000000002B13cCcEC913420A21e4D11b2DCd3C), // this.
599               bytes32(0),           // leave the salt value set to zero.
600               keccak256(            // hash the supplied initialization code.
601                 vaultContractInitializationCode
602               )
603             )
604           )
605         )
606       )
607     );
608   }
609 }