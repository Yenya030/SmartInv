1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/CollectorsClub/Degen.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nimport '../EthereumContracts/contracts/NFT/NFTFree.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC721.sol';\r\n\r\nabstract contract CCVault {\r\n\tfunction balanceOf( address tokenOwner ) public virtual view returns ( uint256 key ) {}\r\n}\r\n\r\ncontract Degen is NFTFree {\r\n\terror NFT_FORBIDDEN( address account );\r\n\terror NFT_ALLOCATION_CONSUMED( address account );\r\n\terror NFT_MAX_ALLOCATION( address account, uint256 allocated );\r\n\r\n\tuint8   public constant PRIVATE_SALE      = 2;\r\n\tuint8   public constant PARTNER_SALE      = 3;\r\n\r\n\tuint256 public constant MINTS_PER_KEY     = 3;\r\n\tuint256 public constant MINTS_PER_PARTNER = 1;\r\n\r\n\tmapping( address => uint256 ) public privateMints;\r\n\tmapping( address => uint256 ) public partnerMints;\r\n\r\n\tCCVault private _vault;\r\n\tIERC721 private _tab;\r\n\tIERC721 private _fmc;\r\n\r\n\tconstructor () {\r\n\t\t_initNFTFree (\r\n\t\t\t300,\r\n\t\t\t5,\r\n\t\t\t4000,\r\n\t\t\t1250,\r\n\t\t\t\"GMers\",\r\n\t\t\t\"GMER\",\r\n\t\t\t\"https://collectorsclub.io/api/gmers/metadata?tokenId=\"\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t* Ensures the contract state is PRIVATE_SALE or PARTNER_SALE\r\n\t*/\r\n\tmodifier isPrivateOrPartnerSale {\r\n\t\tuint8 _currentState_ = getPauseState();\r\n\t\tif ( _currentState_ != PRIVATE_SALE && _currentState_ != PARTNER_SALE ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _currentState_ );\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* Ensures the contract state is PARTNER_SALE\r\n\t*/\r\n\tmodifier isPartnerSale {\r\n\t\tuint8 _currentState_ = getPauseState();\r\n\t\tif ( _currentState_ != PARTNER_SALE ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _currentState_ );\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed to manage tokens on behalf of `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ : address that owns tokens\r\n\t\t* @param operator_   : address that tries to manage tokens\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to manage the token\r\n\t\t*/\r\n\t\tfunction _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual override(NFTFree) returns ( bool ) {\r\n\t\t\treturn operator_ == address( _vault ) ||\r\n\t\t\t\t\t\t super._isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* Mints a single token during the PARTNER_SALE period.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* - Contract state must be PARTNER_SALE\r\n\t\t* - Caller must own one of the PARTNER NFTs\r\n\t\t* - Caller must not have minted through this function before\r\n\t\t*/\r\n\t\tfunction mintPartner() public isPartnerSale {\r\n\t\t\taddress _account_ = _msgSender();\r\n\t\t\tif ( partnerMints[ _account_ ] == MINTS_PER_PARTNER ) {\r\n\t\t\t\trevert NFT_ALLOCATION_CONSUMED( _account_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _remainingSupply_ = MAX_SUPPLY - _reserve - supplyMinted();\r\n\t\t\tif ( _remainingSupply_ < MINTS_PER_PARTNER ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( MINTS_PER_PARTNER, _remainingSupply_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _allocated_;\r\n\t\t\tuint256 _tabOwned_ = _tab.balanceOf( _account_ );\r\n\t\t\tif ( _tabOwned_ > 0 ) {\r\n\t\t\t\t_allocated_ = MINTS_PER_PARTNER;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuint256 _fmcOwned_ = _fmc.balanceOf( _account_ );\r\n\t\t\t\tif ( _fmcOwned_ > 0 ) {\r\n\t\t\t\t\t_allocated_ = MINTS_PER_PARTNER;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ( _allocated_ < MINTS_PER_PARTNER ) {\r\n\t\t\t\trevert NFT_FORBIDDEN( _account_ );\r\n\t\t\t}\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tpartnerMints[ _account_ ] = MINTS_PER_PARTNER;\r\n\t\t\t}\r\n\r\n\t\t\t_mint( _account_, MINTS_PER_PARTNER );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* Mints tokens for key stakers.\r\n\t\t* \r\n\t\t* @param qty_ ~ type = uint256 : the number of tokens to mint \r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* - `qty_` must be greater than 0\r\n\t\t* - Contract state must be PARTNER_SALE or PRIVATE_SALE\r\n\t\t* - Caller must have enough keys staked (one key staked = 3 tokens)\r\n\t\t* - Caller must have enough remaining tokens allocated to mint `qty_` tokens\r\n\t\t*/\r\n\t\tfunction mintPrivate( uint256 qty_ ) public validateAmount( qty_ ) isPrivateOrPartnerSale {\r\n\t\t\taddress _account_ = _msgSender();\r\n\t\t\tif ( privateMints[ _account_ ] == MINTS_PER_KEY ) {\r\n\t\t\t\trevert NFT_ALLOCATION_CONSUMED( _account_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _remainingSupply_ = MAX_SUPPLY - _reserve - supplyMinted();\r\n\t\t\tif ( _remainingSupply_ < qty_ ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _keys_ = _vault.balanceOf( _account_ );\r\n\t\t\tuint256 _allocated_ = _keys_ * MINTS_PER_KEY;\r\n\t\t\tuint256 _claimed_ = privateMints[ _account_ ];\r\n\t\t\tif ( qty_ > _allocated_ - _claimed_ ) {\r\n\t\t\t\trevert NFT_MAX_ALLOCATION( _account_, _allocated_ );\r\n\t\t\t}\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tprivateMints[ _account_ ] = _claimed_ + qty_;\r\n\t\t\t}\r\n\r\n\t\t\t_mint( _account_, qty_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****       CONTRACT OWNER       *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Sets the vault contract address.\r\n\t\t*/\r\n\t\tfunction setVault( address vault_ ) public onlyOwner {\r\n\t\t\t_vault = CCVault( vault_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Sets the FMC contract address.\r\n\t\t*/\r\n\t\tfunction setFmc( address fmc_ ) public onlyOwner {\r\n\t\t\t_fmc = IERC721( fmc_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Sets the TAB contract address.\r\n\t\t*/\r\n\t\tfunction setTab( address tab_ ) public onlyOwner {\r\n\t\t\t_tab = IERC721( tab_ );\r\n\t\t}\r\n\t// **************************************\r\n}\r\n"
6     },
7     "contracts/EthereumContracts/contracts/interfaces/IERC721.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity 0.8.10;\n\nimport \"./IERC165.sol\";\n\n/**\n* @dev Required interface of an ERC721 compliant contract.\n*/\ninterface IERC721 is IERC165 {\n  /**\n  * @dev Emitted when `tokenId_` token is transferred from `from_` to `to_`.\n  */\n  event Transfer( address indexed from_, address indexed to_, uint256 indexed tokenId_ );\n\n  /**\n  * @dev Emitted when `owner_` enables `approved_` to manage the `tokenId_` token.\n  */\n  event Approval( address indexed owner_, address indexed approved_, uint256 indexed tokenId_ );\n\n  /**\n  * @dev Emitted when `owner_` enables or disables (`approved`) `operator_` to manage all of its assets.\n  */\n  event ApprovalForAll( address indexed owner_ , address indexed operator_ , bool approved_ );\n\n  /**\n  * @dev Gives permission to `to_` to transfer `tokenId_` token to another account.\n  * The approval is cleared when the token is transferred.\n  *\n  * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n  *\n  * Requirements:\n  *\n  * - The caller must own the token or be an approved operator.\n  * - `tokenId_` must exist.\n  *\n  * Emits an {Approval} event.\n  */\n  function approve( address to_, uint256 tokenId_ ) external;\n\n  /**\n  * @dev Safely transfers `tokenId_` token from `from_` to `to_`, checking first that contract recipients\n  * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n  *\n  * Requirements:\n  *\n  * - `from_` cannot be the zero address.\n  * - `to_` cannot be the zero address.\n  * - `tokenId_` token must exist and be owned by `from_`.\n  * - If the caller is not `from_`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n  * - If `to_` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n  *\n  * Emits a {Transfer} event.\n  */\n  function safeTransferFrom( address from_, address to_, uint256 tokenI_d ) external;\n\n  /**\n  * @dev Safely transfers `tokenId_` token from `from_` to `to_`.\n  *\n  * Requirements:\n  *\n  * - `from_` cannot be the zero address.\n  * - `to_` cannot be the zero address.\n  * - `tokenId_` token must exist and be owned by `from_`.\n  * - If the caller is not `from_`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n  * - If `to_` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n  *\n  * Emits a {Transfer} event.\n  */\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external;\n\n  /**\n  * @dev Approve or remove `operator_` as an operator for the caller.\n  * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n  *\n  * Requirements:\n  *\n  * - The `operator_` cannot be the caller.\n  *\n  * Emits an {ApprovalForAll} event.\n  */\n  function setApprovalForAll( address operator_, bool approved_ ) external;\n\n  /**\n  * @dev Transfers `tokenId_` token from `from_` to `to_`.\n  *\n  * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n  *\n  * Requirements:\n  *\n  * - `from_` cannot be the zero address.\n  * - `to_` cannot be the zero address.\n  * - `tokenId_` token must be owned by `from_`.\n  * - If the caller is not `from_`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n  *\n  * Emits a {Transfer} event.\n  */\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /**\n  * @dev Returns the number of tokens in `tokenOwner_`'s account.\n  */\n  function balanceOf( address tokenOwner_ ) external view returns ( uint256 balance );\n\n  /**\n  * @dev Returns the account approved for `tokenId_` token.\n  *\n  * Requirements:\n  *\n  * - `tokenId_` must exist.\n  */\n  function getApproved( uint256 tokenId_ ) external view returns ( address operator );\n\n  /**\n  * @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\n  *\n  * See {setApprovalForAll}\n  */\n  function isApprovedForAll( address tokenOwner_, address operator_ ) external view returns ( bool );\n\n  /**\n  * @dev Returns the owner of the `tokenId_` token.\n  *\n  * Requirements:\n  *\n  * - `tokenId_` must exist.\n  */\n  function ownerOf( uint256 tokenId_ ) external view returns ( address owner );\n}\n"
9     },
10     "contracts/EthereumContracts/contracts/NFT/NFTFree.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nimport '../tokens/ERC721/Reg_ERC721Batch.sol';\r\nimport '../utils/IOwnable.sol';\r\nimport '../utils/IPausable.sol';\r\nimport '../utils/ITradable.sol';\r\nimport '../utils/ERC2981Base.sol';\r\n\r\nabstract contract NFTFree is Reg_ERC721Batch, IOwnable, IPausable, ITradable, ERC2981Base {\r\n\t// Errors \r\n\terror NFT_ARRAY_LENGTH_MISMATCH( uint256 len1, uint256 len2 );\r\n\terror NFT_INVALID_QTY();\r\n\terror NFT_MAX_BATCH( uint256 qtyRequested, uint256 maxBatch );\r\n\terror NFT_MAX_RESERVE( uint256 qtyRequested, uint256 reserveLeft );\r\n\terror NFT_MAX_SUPPLY( uint256 qtyRequested, uint256 remainingSupply );\r\n\r\n\tuint256 private constant SHARE_BASE = 10000;\r\n\tuint256 public MAX_SUPPLY;\r\n\tuint256 public MAX_BATCH;\r\n\tuint256 internal _reserve;\r\n\r\n\t/**\r\n\t* @dev Ensures that `qty_` is higher than 0\r\n\t* \r\n\t* @param qty_ : the amount to validate \r\n\t*/\r\n\tmodifier validateAmount( uint256 qty_ ) {\r\n\t\tif ( qty_ == 0 ) {\r\n\t\t\trevert NFT_INVALID_QTY();\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function to initialize the NFT contract.\r\n\t\t* \r\n\t\t* @param reserve_       : total amount of reserved tokens for airdrops\r\n\t\t* @param maxBatch_      : maximum quantity of token that can be minted in one transaction\r\n\t\t* @param maxSupply_     : maximum number of tokens that can exist\r\n\t\t* @param royaltyRate_   : portion of the secondary sale that will be paid out to the collection, out of 10,000 total shares\r\n\t\t* @param name_          : name of the token\r\n\t\t* @param symbol_        : symbol representing the token\r\n\t\t* @param baseURI_       : baseURI for the tokens\r\n\t\t*/\r\n\t\tfunction _initNFTFree (\r\n\t\t\tuint256 reserve_,\r\n\t\t\tuint256 maxBatch_,\r\n\t\t\tuint256 maxSupply_,\r\n\t\t\tuint256 royaltyRate_,\r\n\t\t\tstring memory name_,\r\n\t\t\tstring memory symbol_,\r\n\t\t\tstring memory baseURI_\r\n\t\t) internal {\r\n\t\t\t_initERC721Metadata( name_, symbol_, baseURI_ );\r\n\t\t\t_initIOwnable( _msgSender() );\r\n\t\t\t_initERC2981Base( _msgSender(), royaltyRate_ );\r\n\t\t\tMAX_SUPPLY     = maxSupply_;\r\n\t\t\tMAX_BATCH      = maxBatch_;\r\n\t\t\t_reserve       = reserve_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed to manage tokens on behalf of `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ : address that owns tokens\r\n\t\t* @param operator_   : address that tries to manage tokens\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to manage the token\r\n\t\t*/\r\n\t\tfunction _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual override(Reg_ERC721Batch) returns ( bool ) {\r\n\t\t\treturn _isRegisteredProxy( tokenOwner_, operator_ ) ||\r\n\t\t\t\t\t\t super._isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `addr_` is a contract.\r\n\t\t* Note this function will be inacurate if `addr_` is a contract in deployment.\r\n\t\t* \r\n\t\t* @param addr_ : address to be verified\r\n\t\t* \r\n\t\t* @return bool whether `addr_` is a fully deployed contract\r\n\t\t*/\r\n\t\tfunction _isContract( address addr_ ) internal view returns ( bool ) {\r\n\t\t\tuint size;\r\n\t\t\tassembly {\r\n\t\t\t\tsize := extcodesize( addr_ )\r\n\t\t\t}\r\n\t\t\treturn size > 0;\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens and transfers them to the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.SALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must send enough ether to pay for `qty_` tokens at public sale price.\r\n\t\t* \r\n\t\t* @param qty_ : the amount of tokens to be minted\r\n\t\t*/\r\n\t\tfunction mintPublic( uint256 qty_ ) public validateAmount( qty_ ) isOpen {\r\n\t\t\tif ( qty_ > MAX_BATCH ) {\r\n\t\t\t\trevert NFT_MAX_BATCH( qty_, MAX_BATCH );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _remainingSupply_ = MAX_SUPPLY - _reserve - supplyMinted();\r\n\t\t\tif ( qty_ > _remainingSupply_ ) {\r\n\t\t\t\trevert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n\t\t\t}\r\n\r\n\t\t\t_mint( _msgSender(), qty_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****       CONTRACT_OWNER       *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev See {ITradable-addProxyRegistry}.\r\n\t\t* \r\n\t\t* @param proxyRegistryAddress_ : the address of the proxy registry to be added\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction addProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n\t\t\t_addProxyRegistry( proxyRegistryAddress_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {ITradable-removeProxyRegistry}.\r\n\t\t* \r\n\t\t* @param proxyRegistryAddress_ : the address of the proxy registry to be removed\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction removeProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n\t\t\t_removeProxyRegistry( proxyRegistryAddress_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `amounts_` tokens and transfers them to `accounts_`.\r\n\t\t* \r\n\t\t* @param accounts_ : the list of accounts that will receive airdropped tokens\r\n\t\t* @param amounts_  : the amount of tokens each account in `accounts_` will receive\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - `accounts_` and `amounts_` must have the same length.\r\n\t\t* - There must be enough tokens left in the reserve.\r\n\t\t*/\r\n\t\tfunction airdrop( address[] memory accounts_, uint256[] memory amounts_ ) public onlyOwner {\r\n\t\t\tuint256 _accountsLen_ = accounts_.length;\r\n\t\t\tuint256 _amountsLen_  = amounts_.length;\r\n\t\t\tif ( _accountsLen_ != _amountsLen_ ) {\r\n\t\t\t\trevert NFT_ARRAY_LENGTH_MISMATCH( _accountsLen_, _amountsLen_ );\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _totalQty_;\r\n\t\t\tfor ( uint256 i = _amountsLen_; i > 0; i -- ) {\r\n\t\t\t\t_totalQty_ += amounts_[ i - 1 ];\r\n\t\t\t}\r\n\t\t\tif ( _totalQty_ > _reserve ) {\r\n\t\t\t\trevert NFT_MAX_RESERVE( _totalQty_, _reserve );\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\t_reserve -= _totalQty_;\r\n\t\t\t}\r\n\r\n\t\t\tfor ( uint256 i; i < _accountsLen_; i ++ ) {\r\n\t\t\t\t_mint( accounts_[ i ], amounts_[ i ] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Updates the baseURI for the tokens.\r\n\t\t* \r\n\t\t* @param baseURI_ : the new baseURI for the tokens\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setBaseURI( string memory baseURI_ ) public onlyOwner {\r\n\t\t\t_setBaseURI( baseURI_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Updates the royalty recipient and rate.\r\n\t\t* \r\n\t\t* @param royaltyRecipient_ : the new recipient of the royalties\r\n\t\t* @param royaltyRate_      : the new royalty rate\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner\r\n\t\t* - `royaltyRate_` cannot be higher than 10,000\r\n\t\t*/\r\n\t\tfunction setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) external onlyOwner {\r\n\t\t\t_setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IPausable-setPauseState}.\r\n\t\t* \r\n\t\t* @param newState_ : the new sale state\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setPauseState( uint8 newState_ ) external onlyOwner {\r\n\t\t\t_setPauseState( newState_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override(Reg_ERC721Batch, ERC2981Base) returns ( bool ) {\r\n\t\t\treturn ERC2981Base.supportsInterface( interfaceId_ ) ||\r\n\t\t\t\t\t\t Reg_ERC721Batch.supportsInterface( interfaceId_ );\r\n\t\t}\r\n\t// **************************************\r\n}\r\n"
12     },
13     "contracts/EthereumContracts/contracts/interfaces/IERC165.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity 0.8.10;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
15     },
16     "contracts/EthereumContracts/contracts/utils/ERC2981Base.sol": {
17       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nimport \"../interfaces/IERC2981.sol\";\r\nimport \"../interfaces/IERC165.sol\";\r\n\r\nabstract contract ERC2981Base is IERC165, IERC2981 {\r\n\t// Errors\r\n\terror IERC2981_INVALID_ROYALTIES( uint256 royaltyRate, uint256 royaltyBase );\r\n\r\n\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\r\n\t// up to two digits below the unit such as 2.5% or 1.25%.\r\n\tuint private constant ROYALTY_BASE = 10000;\r\n\r\n\t// Represents the percentage of royalties on each sale on secondary markets.\r\n\t// Set to 0 to have no royalties.\r\n\tuint256 private _royaltyRate;\r\n\r\n\t// Address of the recipient of the royalties.\r\n\taddress private _royaltyRecipient;\r\n\r\n\tfunction _initERC2981Base( address royaltyRecipient_, uint256 royaltyRate_ ) internal {\r\n\t\t_setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC2981-royaltyInfo}.\r\n\t* \r\n\t* Note: This function should be overriden to revert on a query for non existent token.\r\n\t*/\r\n\tfunction royaltyInfo( uint256, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\r\n\t\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\r\n\t\t\treturn ( _royaltyRecipient, 0 );\r\n\t\t}\r\n\t\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\r\n\t\treturn ( _royaltyRecipient, _royaltyAmount_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `royaltyRecipient_`.\r\n\t* \r\n\t* Requirements: \r\n\t* \r\n\t* - `royaltyRate_` cannot be higher than `ROYALTY_BASE`;\r\n\t*/\r\n\tfunction _setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) internal virtual {\r\n\t\tif ( royaltyRate_ > ROYALTY_BASE ) {\r\n\t\t\trevert IERC2981_INVALID_ROYALTIES( royaltyRate_, ROYALTY_BASE );\r\n\t\t}\r\n\t\t_royaltyRate      = royaltyRate_;\r\n\t\t_royaltyRecipient = royaltyRecipient_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC165-supportsInterface}.\r\n\t*/\r\n\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\r\n\t\treturn \r\n\t\t\tinterfaceId_ == type( IERC2981 ).interfaceId ||\r\n\t\t\tinterfaceId_ == type( IERC165 ).interfaceId;\r\n\t}\r\n}\r\n"
18     },
19     "contracts/EthereumContracts/contracts/utils/ITradable.sol": {
20       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n\tmapping( address => OwnableDelegateProxy ) public proxies;\r\n}\r\n\r\nabstract contract ITradable {\r\n\t// OpenSea proxy registry address\r\n\taddress[] internal _proxyRegistries;\r\n\r\n\t/**\r\n\t* @dev Internal function that adds a proxy registry to the list of accepted proxy registries.\r\n\t*/\r\n\tfunction _addProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _index_ = _proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( _proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t_proxyRegistries.push( proxyRegistryAddress_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function that removes a proxy registry from the list of accepted proxy registries.\r\n\t*/\r\n\tfunction _removeProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _len_ = _proxyRegistries.length;\r\n\t\tuint256 _index_ = _len_;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( _proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\tif ( _index_ + 1 != _len_ ) {\r\n\t\t\t\t\t_proxyRegistries[ _index_ ] = _proxyRegistries[ _len_ - 1 ];\r\n\t\t\t\t}\r\n\t\t\t\t_proxyRegistries.pop();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Checks if `operator_` is a registered proxy for `tokenOwner_`.\r\n\t* \r\n\t* Note: Use this function to allow whitelisting of registered proxy.\r\n\t*/\r\n\tfunction _isRegisteredProxy( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\r\n\t\tuint256 _index_ = _proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tProxyRegistry _proxyRegistry_ = ProxyRegistry( _proxyRegistries[ _index_ ] );\r\n\t\t\tif ( address( _proxyRegistry_.proxies( tokenOwner_ ) ) == operator_ ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}"
21     },
22     "contracts/EthereumContracts/contracts/utils/IPausable.sol": {
23       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nabstract contract IPausable {\r\n\t// Enum to represent the sale state, defaults to ``CLOSED``.\r\n\tuint8 constant CLOSED = 0;\r\n\tuint8 constant OPEN   = 1;\r\n\r\n\t// Errors\r\n\terror IPausable_INCORRECT_STATE( uint8 currentState );\r\n\terror IPausable_INVALID_STATE( uint8 newState );\r\n\r\n\t// The current state of the contract\r\n\tuint8 private _contractState;\r\n\r\n\t/**\r\n\t* @dev Emitted when the sale state changes\r\n\t*/\r\n\tevent ContractStateChanged( uint8 indexed previousState, uint8 indexed newState );\r\n\r\n\t/**\r\n\t* @dev Internal function setting the contract state to `newState_`.\r\n\t* \r\n\t* Note: Contract state can have one of 2 values by default, ``CLOSED`` or ``OPEN``.\r\n\t* \t\t\tTo maintain extendability, the 2 available states are kept as uint8 instead of enum.\r\n\t* \t\t\tAs a result, it is possible to set the state to an incorrect value.\r\n\t* \t\t\tTo avoid issues, `newState_` should be validated before calling this function\r\n\t*/\r\n\tfunction _setPauseState( uint8 newState_ ) internal virtual {\r\n\t\tuint8 _previousState_ = _contractState;\r\n\t\t_contractState = newState_;\r\n\t\temit ContractStateChanged( _previousState_, newState_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function returning the contract state.\r\n\t*/\r\n\tfunction getPauseState() public virtual view returns ( uint8 ) {\r\n\t\treturn _contractState;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is not ``CLOSED``.\r\n\t*/\r\n\tmodifier isClosed {\r\n\t\tif ( _contractState != CLOSED ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is ``CLOSED``.\r\n\t*/\r\n\tmodifier isNotClosed {\r\n\t\tif ( _contractState == CLOSED ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is not ``OPEN``.\r\n\t*/\r\n\tmodifier isOpen {\r\n\t\tif ( _contractState != OPEN ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is ``OPEN``.\r\n\t*/\r\n\tmodifier isNotOpen {\r\n\t\tif ( _contractState == OPEN ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n}\r\n"
24     },
25     "contracts/EthereumContracts/contracts/utils/IOwnable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract IOwnable is Context {\r\n\t// Errors\r\n\terror IOwnable_NOT_OWNER( address operator );\r\n\r\n\t// The owner of the contract\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t* @dev Emitted when contract ownership changes.\r\n\t*/\r\n\tevent OwnershipTransferred( address indexed previousOwner, address indexed newOwner );\r\n\r\n\t/**\r\n\t* @dev Initializes the contract setting the deployer as the initial owner.\r\n\t*/\r\n\tfunction _initIOwnable( address owner_ ) internal {\r\n\t\t_owner = owner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the address of the current owner.\r\n\t*/\r\n\tfunction owner() public view virtual returns ( address ) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\taddress _sender_ = _msgSender();\r\n\t\tif ( owner() != _sender_ ) {\r\n\t\t\trevert IOwnable_NOT_OWNER( _sender_ );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t* Can only be called by the current owner.\r\n\t*/\r\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\r\n\t\taddress _oldOwner_ = _owner;\r\n\t\t_owner = newOwner_;\r\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\r\n\t}\r\n}\r\n"
27     },
28     "contracts/EthereumContracts/contracts/tokens/ERC721/Reg_ERC721Batch.sol": {
29       "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nimport \"../../interfaces/IERC721Enumerable.sol\";\r\nimport \"../../interfaces/IERC721Metadata.sol\";\r\nimport \"../../interfaces/IERC721Receiver.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n* @dev Required interface of an ERC721 compliant contract.\r\n*/\r\nabstract contract Reg_ERC721Batch is Context, IERC721Metadata, IERC721Enumerable {\r\n\t// Errors\r\n\terror IERC721_CALLER_NOT_APPROVED( address tokenOwner, address operator, uint256 tokenId );\r\n\terror IERC721_NONEXISTANT_TOKEN( uint256 tokenId );\r\n\terror IERC721_NON_ERC721_RECEIVER( address receiver );\r\n\terror IERC721_INVALID_APPROVAL( address operator );\r\n\terror IERC721_INVALID_TRANSFER( address recipient );\r\n\terror IERC721_INVALID_TRANSFER_FROM();\r\n\terror IERC721Enumerable_INDEX_OUT_OF_BOUNDS( uint256 index );\r\n\terror IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( address tokenOwner, uint256 index );\r\n\r\n\tuint256 private _nextId = 1;\r\n\tstring  public  name;\r\n\tstring  public  symbol;\r\n\r\n\t// Mapping from token ID to approved address\r\n\tmapping( uint256 => address ) public getApproved;\r\n\r\n\t// Mapping from owner to operator approvals\r\n\tmapping( address => mapping( address => bool ) ) private _operatorApprovals;\r\n\r\n\t// List of owner addresses\r\n\tmapping( uint256 => address ) private _owners;\r\n\r\n\t// Token Base URI\r\n\tstring  private _baseURI;\r\n\r\n\t/**\r\n\t* @dev Ensures the token exist. \r\n\t* A token exists if it has been minted and is not owned by the null address.\r\n\t* \r\n\t* @param tokenId_ uint256 ID of the token to verify\r\n\t*/\r\n\tmodifier exists( uint256 tokenId_ ) {\r\n\t\tif ( ! _exists( tokenId_ ) ) {\r\n\t\t\trevert IERC721_NONEXISTANT_TOKEN( tokenId_ );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function returning the number of tokens in `tokenOwner_`'s account.\r\n\t\t*/\r\n\t\tfunction _balanceOf( address tokenOwner_ ) internal view virtual returns ( uint256 ) {\r\n\t\t\tif ( tokenOwner_ == address( 0 ) ) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _count_ = 0;\r\n\t\t\taddress _currentTokenOwner_;\r\n\t\t\tfor ( uint256 i = 1; i < _nextId; ++ i ) {\r\n        if ( _exists( i ) ) {\r\n          if ( _owners[ i ] != address( 0 ) ) {\r\n            _currentTokenOwner_ = _owners[ i ];\r\n          }\r\n          if ( tokenOwner_ == _currentTokenOwner_ ) {\r\n            _count_++;\r\n          }\r\n        }\r\n\t\t\t}\r\n\t\t\treturn _count_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n\t\t* The call is not executed if the target address is not a contract.\r\n\t\t*\r\n\t\t* @param from_ address representing the previous owner of the given token ID\r\n\t\t* @param to_ target address that will receive the tokens\r\n\t\t* @param tokenId_ uint256 ID of the token to be transferred\r\n\t\t* @param data_ bytes optional data to send along with the call\r\n\t\t* @return bool whether the call correctly returned the expected magic value\r\n\t\t*/\r\n\t\tfunction _checkOnERC721Received( address from_, address to_, uint256 tokenId_, bytes memory data_ ) internal virtual returns ( bool ) {\r\n\t\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t\t// construction, since the code is only stored at the end of the\r\n\t\t\t// constructor execution.\r\n\t\t\t// \r\n\t\t\t// IMPORTANT\r\n\t\t\t// It is unsafe to assume that an address not flagged by this method\r\n\t\t\t// is an externally-owned account (EOA) and not a contract.\r\n\t\t\t//\r\n\t\t\t// Among others, the following types of addresses will not be flagged:\r\n\t\t\t//\r\n\t\t\t//  - an externally-owned account\r\n\t\t\t//  - a contract in construction\r\n\t\t\t//  - an address where a contract will be created\r\n\t\t\t//  - an address where a contract lived, but was destroyed\r\n\t\t\tuint256 _size_;\r\n\t\t\tassembly {\r\n\t\t\t\t_size_ := extcodesize( to_ )\r\n\t\t\t}\r\n\r\n\t\t\t// If address is a contract, check that it is aware of how to handle ERC721 tokens\r\n\t\t\tif ( _size_ > 0 ) {\r\n\t\t\t\ttry IERC721Receiver( to_ ).onERC721Received( _msgSender(), from_, tokenId_, data_ ) returns ( bytes4 retval ) {\r\n\t\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( bytes memory reason ) {\r\n\t\t\t\t\tif ( reason.length == 0 ) {\r\n\t\t\t\t\t\trevert IERC721_NON_ERC721_RECEIVER( to_ );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\trevert( add( 32, reason ), mload( reason ) )\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether a token exists. \r\n\t\t* A token exists if it has been minted and is not owned by the null address.\r\n\t\t* \r\n\t\t* @param tokenId_ uint256 ID of the token to verify\r\n\t\t* \r\n\t\t* @return bool whether the token exists\r\n\t\t*/\r\n\t\tfunction _exists( uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n      if ( tokenId_ == 0 ) {\r\n        return false;\r\n      }\r\n\t\t\treturn tokenId_ < _nextId;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n\t\t*/\r\n\t\tfunction _initERC721Metadata( string memory name_, string memory symbol_, string memory baseURI_ ) internal {\r\n\t\t\tname     = name_;\r\n\t\t\tsymbol   = symbol_;\r\n\t\t\t_baseURI = baseURI_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed \r\n\t\t* to manage tokens on behalf of `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ address that owns tokens\r\n\t\t* @param operator_ address that tries to manage tokens\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to handle the token\r\n\t\t*/\r\n\t\tfunction _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual returns ( bool ) {\r\n\t\t\treturn _operatorApprovals[ tokenOwner_ ][ operator_ ];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\r\n\t\t* \r\n\t\t* Note: To avoid multiple checks for the same data, it is assumed that existence of `tokeId_` \r\n\t\t* has been verified prior via {_exists}\r\n\t\t* If it hasn't been verified, this function might panic\r\n\t\t* \r\n\t\t* @param operator_ address that tries to handle the token\r\n\t\t* @param tokenId_ uint256 ID of the token to be handled\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to handle the token\r\n\t\t*/\r\n\t\tfunction _isApprovedOrOwner( address tokenOwner_, address operator_, uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n\t\t\tbool _isApproved_ = operator_ == tokenOwner_ ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\toperator_ == getApproved[ tokenId_ ] ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t\treturn _isApproved_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens and transfers them to `to_`.\r\n\t\t* \r\n\t\t* This internal function can be used to perform token minting.\r\n\t\t* \r\n\t\t* Emits one or more {Transfer} event.\r\n\t\t*/\r\n\t\tfunction _mint( address to_, uint256 qty_ ) internal virtual {\r\n\t\t\tuint256 _firstToken_ = _nextId;\r\n\t\t\tuint256 _nextStart_ = _firstToken_ + qty_;\r\n\t\t\tuint256 _lastToken_ = _nextStart_ - 1;\r\n\r\n\t\t\t_owners[ _firstToken_ ] = to_;\r\n\t\t\tif ( _lastToken_ > _firstToken_ ) {\r\n\t\t\t\t_owners[ _lastToken_ ] = to_;\r\n\t\t\t}\r\n\t\t\t_nextId = _nextStart_;\r\n\r\n\t\t\tif ( ! _checkOnERC721Received( address( 0 ), to_, _firstToken_, \"\" ) ) {\r\n\t\t\t\trevert IERC721_NON_ERC721_RECEIVER( to_ );\r\n\t\t\t}\r\n\r\n\t\t\tfor ( uint256 i = _firstToken_; i < _nextStart_; ++i ) {\r\n\t\t\t\temit Transfer( address( 0 ), to_, i );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning the owner of the `tokenId_` token.\r\n\t\t* \r\n\t\t* @param tokenId_ uint256 ID of the token to verify\r\n\t\t* \r\n\t\t* @return address the address of the token owner\r\n\t\t*/\r\n\t\tfunction _ownerOf( uint256 tokenId_ ) internal view virtual returns ( address ) {\r\n\t\t\tuint256 _tokenId_ = tokenId_;\r\n\t\t\taddress _tokenOwner_ = _owners[ _tokenId_ ];\r\n\t\t\twhile ( _tokenOwner_ == address( 0 ) ) {\r\n\t\t\t\t_tokenId_ --;\r\n\t\t\t\t_tokenOwner_ = _owners[ _tokenId_ ];\r\n\t\t\t}\r\n\r\n\t\t\treturn _tokenOwner_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function used to set the base URI of the collection.\r\n\t\t*/\r\n\t\tfunction _setBaseURI( string memory baseURI_ ) internal virtual {\r\n\t\t\t_baseURI = baseURI_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning the total supply.\r\n\t\t*/\r\n\t\tfunction _totalSupply() internal view virtual returns ( uint256 ) {\r\n\t\t\treturn supplyMinted();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t\t*/\r\n\t\tfunction _toString( uint256 value ) internal pure returns ( string memory ) {\r\n\t\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\t\t\tif ( value == 0 ) {\r\n\t\t\t\treturn \"0\";\r\n\t\t\t}\r\n\t\t\tuint256 temp = value;\r\n\t\t\tuint256 digits;\r\n\t\t\twhile ( temp != 0 ) {\r\n\t\t\t\tdigits ++;\r\n\t\t\t\ttemp /= 10;\r\n\t\t\t}\r\n\t\t\tbytes memory buffer = new bytes( digits );\r\n\t\t\twhile ( value != 0 ) {\r\n\t\t\t\tdigits -= 1;\r\n\t\t\t\tbuffer[ digits ] = bytes1( uint8( 48 + uint256( value % 10 ) ) );\r\n\t\t\t\tvalue /= 10;\r\n\t\t\t}\r\n\t\t\treturn string( buffer );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Transfers `tokenId_` from `from_` to `to_`.\r\n\t\t*\r\n\t\t* This internal function can be used to implement alternative mechanisms to perform \r\n\t\t* token transfer, such as signature-based, or token burning.\r\n\t\t* \r\n\t\t* Emits a {Transfer} event.\r\n\t\t*/\r\n\t\tfunction _transfer( address from_, address to_, uint256 tokenId_ ) internal virtual {\r\n\t\t\tgetApproved[ tokenId_ ] = address( 0 );\r\n\t\t\tuint256 _previousId_ = tokenId_ > 1 ? tokenId_ - 1 : 1;\r\n\t\t\tuint256 _nextId_     = tokenId_ + 1;\r\n\t\t\tbool _previousShouldUpdate_ = _previousId_ < tokenId_ &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_exists( _previousId_ ) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_owners[ _previousId_ ] == address( 0 );\r\n\t\t\tbool _nextShouldUpdate_ = _exists( _nextId_ ) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_owners[ _nextId_ ] == address( 0 );\r\n\r\n\t\t\tif ( _previousShouldUpdate_ ) {\r\n\t\t\t\t_owners[ _previousId_ ] = from_;\r\n\t\t\t}\r\n\r\n\t\t\tif ( _nextShouldUpdate_ ) {\r\n\t\t\t\t_owners[ _nextId_ ] = from_;\r\n\t\t\t}\r\n\r\n\t\t\t_owners[ tokenId_ ] = to_;\r\n\r\n\t\t\temit Transfer( from_, to_, tokenId_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev See {IERC721-approve}.\r\n\t\t*/\r\n\t\tfunction approve( address to_, uint256 tokenId_ ) public virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == _tokenOwner_ ) {\r\n\t\t\t\trevert IERC721_INVALID_APPROVAL( to_ );\r\n\t\t\t}\r\n\r\n\t\t\tgetApproved[ tokenId_ ] = to_;\r\n\t\t\temit Approval( _tokenOwner_, to_, tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-safeTransferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction safeTransferFrom( address from_, address to_, uint256 tokenId_ ) public virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tif ( from_ != _tokenOwner_ ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER_FROM();\r\n\t\t\t}\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER( to_ );\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\r\n\t\t\tif ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, \"\" ) ) {\r\n\t\t\t\trevert IERC721_NON_ERC721_RECEIVER( to_ );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-safeTransferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) public virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tif ( from_ != _tokenOwner_ ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER_FROM();\r\n\t\t\t}\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER( to_ );\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\r\n\t\t\tif ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, data_ ) ) {\r\n\t\t\t\trevert IERC721_NON_ERC721_RECEIVER( to_ );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-setApprovalForAll}.\r\n\t\t*/\r\n\t\tfunction setApprovalForAll( address operator_, bool approved_ ) public virtual override {\r\n\t\t\taddress _account_ = _msgSender();\r\n\t\t\tif ( operator_ == _account_ ) {\r\n\t\t\t\trevert IERC721_INVALID_APPROVAL( operator_ );\r\n\t\t\t}\r\n\r\n\t\t\t_operatorApprovals[ _account_ ][ operator_ ] = approved_;\r\n\t\t\temit ApprovalForAll( _account_, operator_, approved_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-transferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction transferFrom( address from_, address to_, uint256 tokenId_ ) public virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tif ( from_ != _tokenOwner_ ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER_FROM();\r\n\t\t\t}\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_INVALID_TRANSFER( to_ );\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Returns the number of tokens in `tokenOwner_`'s account.\r\n\t\t*/\r\n\t\tfunction balanceOf( address tokenOwner_ ) public view virtual returns ( uint256 ) {\r\n\t\t\treturn _balanceOf( tokenOwner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\r\n\t\t*\r\n\t\t* See {setApprovalForAll}\r\n\t\t*/\r\n\t\tfunction isApprovedForAll( address tokenOwner_, address operator_ ) public view virtual returns ( bool ) {\r\n\t\t\treturn _isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the owner of the `tokenId_` token.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction ownerOf( uint256 tokenId_ ) public view virtual exists( tokenId_ ) returns ( address ) {\r\n\t\t\treturn _ownerOf( tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the total number of tokens minted\r\n\t\t* \r\n\t\t* @return uint256 the number of tokens that have been minted so far\r\n\t\t*/\r\n\t\tfunction supplyMinted() public view virtual returns ( uint256 ) {\r\n\t\t\treturn _nextId - 1;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC165-supportsInterface}.\r\n\t\t*/\r\n\t\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\r\n\t\t\treturn \r\n\t\t\t\tinterfaceId_ == type( IERC721Enumerable ).interfaceId ||\r\n\t\t\t\tinterfaceId_ == type( IERC721Metadata ).interfaceId ||\r\n\t\t\t\tinterfaceId_ == type( IERC721 ).interfaceId ||\r\n\t\t\t\tinterfaceId_ == type( IERC165 ).interfaceId;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Enumerable-tokenByIndex}.\r\n\t\t*/\r\n\t\tfunction tokenByIndex( uint256 index_ ) public view virtual override returns ( uint256 ) {\r\n\t\t\tif ( index_ >= supplyMinted() ) {\r\n\t\t\t\trevert IERC721Enumerable_INDEX_OUT_OF_BOUNDS( index_ );\r\n\t\t\t}\r\n\t\t\treturn index_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n\t\t*/\r\n\t\tfunction tokenOfOwnerByIndex( address tokenOwner_, uint256 index_ ) public view virtual override returns ( uint256 tokenId ) {\r\n      if ( index_ >= _balanceOf( tokenOwner_ ) ) {\r\n        revert IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( tokenOwner_, index_ );\r\n      }\r\n\r\n      uint256 _count_ = 0;\r\n      for ( uint256 i = 1; i < _nextId; i++ ) {\r\n        if ( _exists( i ) && tokenOwner_ == _ownerOf( i ) ) {\r\n          if ( index_ == _count_ ) {\r\n            return i;\r\n          }\r\n          _count_++;\r\n        }\r\n      }\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Metadata-tokenURI}.\r\n\t\t*/\r\n\t\tfunction tokenURI( uint256 tokenId_ ) public view virtual override exists( tokenId_ ) returns ( string memory ) {\r\n\t\t\treturn bytes( _baseURI ).length > 0 ? string( abi.encodePacked( _baseURI, _toString( tokenId_ ) ) ) : _toString( tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Enumerable-totalSupply}.\r\n\t\t*/\r\n\t\tfunction totalSupply() public view virtual override returns ( uint256 ) {\r\n\t\t\treturn _totalSupply();\r\n\t\t}\r\n\t// **************************************\r\n}\r\n"
30     },
31     "@openzeppelin/contracts/utils/Context.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
33     },
34     "contracts/EthereumContracts/contracts/interfaces/IERC2981.sol": {
35       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.10;\r\n\r\ninterface IERC2981 {\r\n  /**\r\n  * @dev ERC165 bytes to add to interface array - set in parent contract\r\n  * implementing this standard\r\n  *\r\n  * bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n  * bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n  * _registerInterface(_INTERFACE_ID_ERC2981);\r\n  *\r\n  * @notice Called with the sale price to determine how much royalty\r\n  *           is owed and to whom.\r\n  * @param _tokenId - the NFT asset queried for royalty information\r\n  * @param _salePrice - the sale price of the NFT asset specified by _tokenId\r\n  * @return receiver - address of who should be sent the royalty payment\r\n  * @return royaltyAmount - the royalty payment amount for _salePrice\r\n  */\r\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n"
36     },
37     "contracts/EthereumContracts/contracts/interfaces/IERC721Receiver.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity 0.8.10;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
39     },
40     "contracts/EthereumContracts/contracts/interfaces/IERC721Metadata.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity 0.8.10;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
42     },
43     "contracts/EthereumContracts/contracts/interfaces/IERC721Enumerable.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity 0.8.10;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns ( uint256 );\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of `owner`'s tokens.\n     */\n    function tokenOfOwnerByIndex( address owner_, uint256 index_ ) external view returns ( uint256 tokenId );\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex( uint256 index_ ) external view returns ( uint256 );\n}\n"
45     }
46   },
47   "settings": {
48     "optimizer": {
49       "enabled": true,
50       "runs": 10000
51     },
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     }
64   }
65 }}