1 {{
2   "language": "Solidity",
3   "sources": {
4     "MantleTokenMigrator.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\n\n/// @title Mantle Token Migrator\n/// @author 0xMantle\n/// @notice Token migration contract for the BIT to MNT token migration\ncontract MantleTokenMigrator {\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// @dev The address of the BIT token contract\n    address public immutable BIT_TOKEN_ADDRESS;\n\n    /// @dev The address of the MNT token contract\n    address public immutable MNT_TOKEN_ADDRESS;\n\n    /// @dev The address of the treasury contract that receives defunded tokens\n    address public treasury;\n\n    /// @dev The address of the owner of the contract\n    /// @notice The owner of the contract is initially the deployer of the contract but will be transferred\n    ///         to a multisig wallet immediately after deployment\n    address public owner;\n\n    /// @dev Boolean indicating if this contract is halted\n    bool public halted;\n\n    /* ========== EVENTS ========== */\n\n    // TokenSwap Events\n\n    /// @dev Emitted when a user swaps BIT for MNT\n    /// @param to The address of the user that swapped BIT for MNT\n    /// @param amountSwapped The amount of BIT swapped and MNT received\n    event TokensMigrated(address indexed to, uint256 amountSwapped);\n\n    // Contract State Events\n\n    /// @dev Emitted when the owner of the contract is changed\n    /// @param previousOwner The address of the previous owner of this contract\n    /// @param newOwner The address of the new owner of this contract\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @dev Emitted when the contract is halted\n    /// @param halter The address of the caller that halted this contract\n    event ContractHalted(address indexed halter);\n\n    /// @dev Emitted when the contract is unhalted\n    /// @param halter The address of the caller that unhalted this contract\n    event ContractUnhalted(address indexed halter);\n\n    /// @dev Emitted when the treasury address is changed\n    /// @param previousTreasury The address of the previous treasury\n    /// @param newTreasury The address of the new treasury\n    event TreasuryChanged(address indexed previousTreasury, address indexed newTreasury);\n\n    // Admin Events\n\n    /// @dev Emitted when non BIT/MNT tokens are swept from the contract by the owner to the recipient address\n    /// @param token The address of the token contract that was swept\n    /// @param recipient The address of the recipient of the swept tokens\n    /// @param amount The amount of tokens swept\n    event TokensSwept(address indexed token, address indexed recipient, uint256 amount);\n\n    /// @dev Emitted when BIT/MNT tokens are defunded from the contract by the owner to the treasury\n    /// @param defunder The address of the defunder\n    /// @param token The address of the token contract that was defunded\n    /// @param amount The amount of tokens defunded\n    event ContractDefunded(address indexed defunder, address indexed token, uint256 amount);\n\n    /* ========== ERRORS ========== */\n\n    /// @notice Thrown when the caller is not the owner and the function being called uses the {onlyOwner} modifier\n    /// @param caller The address of the caller\n    error MantleTokenMigrator_OnlyOwner(address caller);\n\n    /// @notice Thrown when the contract is halted and the function being called uses the {onlyWhenNotHalted} modifier\n    error MantleTokenMigrator_OnlyWhenNotHalted();\n\n    /// @notice Thrown when the input passed into the {_migrateTokens} function is zero\n    error MantleTokenMigrator_ZeroSwap();\n\n    /// @notice Thrown when at least one of the inputs passed into the constructor is a zero value\n    error MantleTokenMigrator_ImproperlyInitialized();\n\n    /// @notice Thrown when the {_tokenAddress} passed into the {sweepTokens} function is the BIT or MNT token address\n    /// @param token The address of the token contract\n    error MantleTokenMigrator_SweepNotAllowed(address token);\n\n    /// @notice Thrown when the {_tokenAddress} passed into the {defundContract} function is NOT the BIT or MNT token address\n    /// @param token The address of the token contract\n    error MantleTokenMigrator_InvalidFundingToken(address token);\n\n    /// @notice Thrown when the treasury is the zero address\n    error MantleTokenMigrator_InvalidTreasury(address treasury);\n\n    /* ========== MODIFIERS ========== */\n\n    /// @notice Modifier that checks that the caller is the owner of the contract\n    /// @dev Throws {MantleTokenMigrator_OnlyOwner} if the caller is not the owner\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert MantleTokenMigrator_OnlyOwner(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier that checks that the contract is not halted\n    /// @dev Throws {MantleTokenMigrator_OnlyWhenNotHalted} if the contract is halted\n    modifier onlyWhenNotHalted() {\n        if (halted) revert MantleTokenMigrator_OnlyWhenNotHalted();\n        _;\n    }\n\n    /// @notice Initializes the MantleTokenMigrator contract, setting the initial deployer as the contract owner\n    /// @dev _bitTokenAddress, _mntTokenAddress, _tokenConversionNumerator, and _tokenConversionDenominator are immutable: they can only be set once during construction\n    /// @dev the contract is initialized in a halted state\n    /// @dev Requirements:\n    ///     - all parameters must be non-zero\n    ///     - _bitTokenAddress and _mntTokenAddress are assumed to have the same number of decimals\n    /// @param _bitTokenAddress The address of the BIT token contract\n    /// @param _mntTokenAddress The address of the MNT token contract\n    /// @param _treasury The address of the treasury contract that receives defunded tokens\n    constructor(address _bitTokenAddress, address _mntTokenAddress, address _treasury) {\n        if (_bitTokenAddress == address(0) || _mntTokenAddress == address(0) || _treasury == address(0)) {\n            revert MantleTokenMigrator_ImproperlyInitialized();\n        }\n\n        owner = msg.sender;\n        halted = true;\n\n        BIT_TOKEN_ADDRESS = _bitTokenAddress;\n        MNT_TOKEN_ADDRESS = _mntTokenAddress;\n\n        treasury = _treasury;\n    }\n\n    /* ========== TOKEN SWAPPING ========== */\n\n    /// @notice Swaps all of the caller's BIT tokens for MNT tokens\n    /// @dev emits a {TokensMigrated} event\n    /// @dev Requirements:\n    ///     - The caller must have approved this contract to spend their BIT tokens\n    ///     - The caller must have a non-zero balance of BIT tokens\n    ///     - The contract must not be halted\n    function migrateAllBIT() external onlyWhenNotHalted {\n        uint256 amount = ERC20(BIT_TOKEN_ADDRESS).balanceOf(msg.sender);\n        _migrateTokens(amount);\n    }\n\n    /// @notice Swaps a specified amount of the caller's BIT tokens for MNT tokens\n    /// @dev emits a {TokensMigrated} event\n    /// @dev Requirements:\n    ///     - The caller must have approved this contract to spend at least {_amount} of their BIT tokens\n    ///     - The caller must have a balance of at least {_amount} of BIT tokens\n    ///     - The contract must not be halted\n    ///     - {_amount} must be non-zero\n    /// @param _amount The amount of BIT tokens to swap\n    function migrateBIT(uint256 _amount) external onlyWhenNotHalted {\n        _migrateTokens(_amount);\n    }\n\n    /// @notice Internal function that swaps a specified amount of the caller's BIT tokens for MNT tokens\n    /// @dev emits a {TokensMigrated} event\n    /// @dev Requirements:\n    ///     - The caller must have approved this contract to spend at least {_amount} of their BIT tokens\n    ///     - The caller must have a balance of at least {_amount} of BIT tokens\n    ///     - {_amount} must be non-zero\n    /// @param _amount The amount of BIT tokens to swap\n    function _migrateTokens(uint256 _amount) internal {\n        if (_amount == 0) revert MantleTokenMigrator_ZeroSwap();\n\n        // transfer user's BIT tokens to this contract\n        ERC20(BIT_TOKEN_ADDRESS).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // transfer MNT tokens to user, if there are insufficient tokens, in the contract this will revert\n        ERC20(MNT_TOKEN_ADDRESS).safeTransfer(msg.sender, _amount);\n\n        emit TokensMigrated(msg.sender, _amount);\n    }\n\n    /* ========== ADMIN UTILS ========== */\n\n    // Ownership Functions\n\n    /// @notice Transfers ownership of the contract to a new address\n    /// @dev emits an {OwnershipTransferred} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    function transferOwnership(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n\n    // Contract State Functions\n\n    /// @notice Halts the contract, preventing token migrations\n    /// @dev emits a {ContractHalted} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    function haltContract() public onlyOwner {\n        halted = true;\n\n        emit ContractHalted(msg.sender);\n    }\n\n    /// @notice Unhalts the contract, allowing token migrations\n    /// @dev emits a {ContractUnhalted} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    function unhaltContract() public onlyOwner {\n        halted = false;\n\n        emit ContractUnhalted(msg.sender);\n    }\n\n    /// @notice Sets the treasury address\n    /// @dev emits a {TreasuryChanged} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    function setTreasury(address _treasury) public onlyOwner {\n        if (_treasury == address(0)) {\n            revert MantleTokenMigrator_InvalidTreasury(_treasury);\n        }\n\n        emit TreasuryChanged(treasury, _treasury);\n\n        treasury = _treasury;\n    }\n\n    // Token Management Functions\n\n    /// @notice Defunds the contract by transferring a specified amount of BIT or MNT tokens to the treasury address\n    /// @dev emits a {ContractDefunded} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    ///     - {_tokenAddress} must be either the BIT or the MNT token address\n    ///     - The contract must have a balance of at least {_amount} of {_tokenAddress} tokens\n    /// @param _tokenAddress The address of the token to defund\n    /// @param _amount The amount of tokens to defund\n    function defundContract(address _tokenAddress, uint256 _amount) public onlyOwner {\n        if (_tokenAddress != BIT_TOKEN_ADDRESS && _tokenAddress != MNT_TOKEN_ADDRESS) {\n            revert MantleTokenMigrator_InvalidFundingToken(_tokenAddress);\n        }\n\n        // we can only defund BIT or MNT into the predefined treasury address\n        ERC20(_tokenAddress).safeTransfer(treasury, _amount);\n\n        emit ContractDefunded(treasury, _tokenAddress, _amount);\n    }\n\n    /// @notice Sweeps a specified amount of tokens to an arbitrary address\n    /// @dev emits a {TokensSwept} event\n    /// @dev Requirements:\n    ///     - The caller must be the contract owner\n    ///     - {_tokenAddress} must not the BIT or the MNT token address\n    ///     - The contract must have a balance of at least {_amount} of {_tokenAddress} tokens\n    /// @param _tokenAddress The address of the token to sweep\n    /// @param _recipient The address to sweep the tokens to\n    /// @param _amount The amount of tokens to sweep\n    function sweepTokens(address _tokenAddress, address _recipient, uint256 _amount) public onlyOwner {\n        // we can only sweep tokens that are not BIT or MNT to an arbitrary addres\n        if ((_tokenAddress == BIT_TOKEN_ADDRESS) || (_tokenAddress == MNT_TOKEN_ADDRESS)) {\n            revert MantleTokenMigrator_SweepNotAllowed(_tokenAddress);\n        }\n        ERC20(_tokenAddress).safeTransfer(_recipient, _amount);\n\n        emit TokensSwept(_tokenAddress, _recipient, _amount);\n    }\n}\n"
6     },
7     "solmate/src/utils/SafeTransferLib.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
9     },
10     "solmate/src/tokens/ERC20.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": false,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     }
31   }
32 }}