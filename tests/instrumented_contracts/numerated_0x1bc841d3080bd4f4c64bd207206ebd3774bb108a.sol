1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/DoomsdayGarden.sol": {
5       "content": "// SPDX-License-Identifier: I live in the mountains\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\nimport \"./DoomsdayGardenMetadata.sol\";\r\n\r\ncontract DoomsdayGarden {\r\n\r\n    constructor(){\r\n        supportsInterface[0x80ac58cd] = true; //ERC721\r\n        supportsInterface[0x5b5e139f] = true; //ERC721Metadata\r\n        supportsInterface[0x01ffc9a7] = true; //ERC165\r\n\r\n        owner = msg.sender;\r\n\r\n        _mint(1,msg.sender,bytes32(0));\r\n    }\r\n\r\n\r\n    uint constant BASE_COST = 0.000025 ether;\r\n    uint constant BASE_DIFFICULTY = type(uint).max/uint(50000 * 300);\r\n    uint constant DIFFICULTY_RAMP = uint(50000 * 0.1);\r\n    uint constant CREATOR_FEE = 0.005 ether;\r\n\r\n    bytes32[] tokens;\r\n    uint public harvested;\r\n\r\n    uint public ownerWithdrawn;\r\n    address public owner;\r\n\r\n    mapping( uint => uint) public supplyAtMint;\r\n\r\n    event Plant(uint _tokenId, bytes32 _hash, address _planter, uint _newSupply, uint _blockNumber);\r\n    event Harvest(uint _tokenId, bytes32 _hash, uint _growth, uint _supplyAtMint, uint _newSupply, uint _blockNumber);\r\n\r\n    function plant(uint seed) public payable {\r\n        uint tokenId = tokens.length + 1;\r\n        uint supply = totalSupply();\r\n\r\n        uint difficulty = BASE_DIFFICULTY - (DIFFICULTY_RAMP * supply);\r\n\r\n        uint cost = BASE_COST * supply  + CREATOR_FEE;\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n                        msg.sender,\r\n                        tokens[tokens.length - 1],\r\n                        seed\r\n                    ));\r\n\r\n        require(uint(hash) < difficulty,\"difficulty\");\r\n        require(msg.value == cost,\"cost\");\r\n\r\n        supplyAtMint[tokenId] = supply;\r\n\r\n        hash = keccak256(abi.encodePacked(hash,block.timestamp));\r\n\r\n        _mint(tokenId,msg.sender,hash);\r\n\r\n        emit Plant(tokenId, hash, msg.sender, totalSupply(), block.number);\r\n    }\r\n\r\n    function harvest(uint tokenId) public{\r\n        require(msg.sender == ownerOf(tokenId),\"ownerOf\");\r\n\r\n        uint growth = (tokens.length - tokenId);\r\n        uint produce = growth * BASE_COST;\r\n\r\n\r\n        harvested++;\r\n\r\n        _burn(tokenId);\r\n\r\n        payable(msg.sender).transfer(produce);\r\n\r\n        emit Harvest(tokenId, tokens[tokenId - 1], growth, supplyAtMint[tokenId], totalSupply(), block.number);\r\n    }\r\n\r\n    function harvestMultiple(uint[] calldata tokenIds) public{\r\n        require(tokenIds.length > 0,\"tokenIds\");\r\n        for(uint i = 0; i < tokenIds.length; i++){\r\n            harvest(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n\r\n    function hashOf(uint _tokenId) public view returns(bytes32){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return tokens[_tokenId - 1];\r\n    }\r\n    function getEthContained(uint _tokenId) public view returns(uint){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return (tokens.length - _tokenId) * BASE_COST;\r\n    }\r\n    function getLastHash() public view returns(bytes32){\r\n        return tokens[tokens.length - 1];\r\n    }\r\n    function getMiningState() public view returns(bytes32 _hash, uint _supply, uint _harvested, uint blockNumber){\r\n        return (tokens[tokens.length - 1], totalSupply(), harvested, block.number);\r\n    }\r\n\r\n\r\n    function treeData(uint _tokenId) public view returns(bytes32 _hash, uint _supplyAtMint, uint _planted){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n\r\n        return (tokens[_tokenId - 1],supplyAtMint[_tokenId],tokens.length);\r\n    }\r\n\r\n    //////===721 Standard\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    //////===721 Implementation\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping (uint256 => address) internal allowance;\r\n    mapping (address => mapping (address => bool)) public isApprovedForAll;\r\n\r\n    mapping(uint256 => address) owners;  //Mapping of owners\r\n\r\n    //    METADATA VARS\r\n    string public name = \"Doomsday Garden\";\r\n    string public symbol = \"TREE\";\r\n\r\n    address private __metadata;\r\n\r\n\r\n    function _mint(uint _tokenId,address _to, bytes32 _hash) private{\r\n        owners[_tokenId] = msg.sender;\r\n        balanceOf[_to]++;\r\n\r\n        tokens.push(_hash);\r\n        emit Transfer(address(0),_to,_tokenId);\r\n    }\r\n    function _burn(uint _tokenId) private{\r\n        address _owner = owners[_tokenId];\r\n\r\n        balanceOf[ _owner ]--;\r\n        delete owners[_tokenId];\r\n\r\n        emit Transfer(_owner,address(0),_tokenId);\r\n    }\r\n\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return owners[_tokenId] != address(0);\r\n    }\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return owners[_tokenId];\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address _owner = ownerOf(_tokenId);\r\n        require( _owner == msg.sender                    //Require Sender Owns Token\r\n            || isApprovedForAll[_owner][msg.sender]                //  or is approved for all.\r\n        ,\"permission\");\r\n\r\n        emit Approval(_owner, _approved, _tokenId);\r\n\r\n        allowance[_tokenId] = _approved;\r\n    }\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return allowance[_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        isApprovedForAll[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n\r\n        //Check Transferable\r\n        //There is a token validity check in ownerOf\r\n        address _owner = ownerOf(_tokenId);\r\n\r\n        require ( _owner == msg.sender             //Require sender owns token\r\n            //Doing the two below manually instead of referring to the external methods saves gas\r\n            || allowance[_tokenId] == msg.sender      //or is approved for this token\r\n            || isApprovedForAll[_owner][msg.sender]          //or is approved for all\r\n        ,\"permission\");\r\n\r\n        require(_owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n        owners[_tokenId] =_to;\r\n\r\n        balanceOf[_from]--;\r\n        balanceOf[_to]++;\r\n\r\n        //Reset approved if there is one\r\n        if(allowance[_tokenId] != address(0)){\r\n            delete allowance[_tokenId];\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        //Get size of \"_to\" address, if 0 it's a wallet\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n    }\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\r\n        require(isValidToken(_tokenId),'tokenId');\r\n\r\n        return DoomsdayGardenMetadata(__metadata).tokenURI(\r\n                _tokenId,\r\n                tokens[_tokenId-1],\r\n                supplyAtMint[_tokenId],\r\n                tokens.length);\r\n    }\r\n\r\n\r\n    function totalSupply() public view returns (uint256){\r\n        return tokens.length - harvested;\r\n    }\r\n\r\n\r\n    ///////===165 Implementation\r\n    mapping (bytes4 => bool) public supportsInterface;\r\n    ///==End 165\r\n\r\n\r\n    //Admin\r\n    function setOwner(address newOwner) public{\r\n        require(msg.sender == owner,\"owner\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setMetadata(address _metadata) public{\r\n        require(msg.sender == owner,\"owner\");\r\n        __metadata = _metadata;\r\n    }\r\n\r\n    function ownerWithdraw() public{\r\n        require(msg.sender == owner,\"owner\");\r\n\r\n        uint toWithdraw = (tokens.length - ownerWithdrawn - 1) * CREATOR_FEE ;\r\n        require(toWithdraw > 0,\"withdrawn\");\r\n\r\n        ownerWithdrawn = tokens.length - 1;\r\n\r\n        payable(msg.sender).transfer(toWithdraw);\r\n\r\n    }\r\n}"
6     },
7     "contracts/interfaces/IERC721TokenReceiver.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}"
9     },
10     "contracts/DoomsdayGardenMetadata.sol": {
11       "content": "// SPDX-License-Identifier: Please may I have some salad\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./interfaces/IERC721.sol\";\r\n\r\ncontract DoomsdayGardenMetadata {\r\n    string __uriBase;\r\n    string __uriSuffix;\r\n\r\n    address garden;\r\n\r\n    constructor(address _garden,string memory _uriBase, string memory _uriSuffix){\r\n        garden = _garden;\r\n\r\n        __uriBase   = _uriBase;\r\n        __uriSuffix = _uriSuffix;\r\n    }\r\n\r\n\r\n    function tokenURI(uint _tokenId,bytes32 _hash, uint _supplyAtMint, uint _planted) public view returns (string memory){\r\n        //Validity check\r\n        IERC721(garden).ownerOf(_tokenId);\r\n\r\n        _hash;_supplyAtMint;_planted;\r\n\r\n        uint _i = _tokenId;\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n\r\n        return string(abi.encodePacked(__uriBase,bstr,__uriSuffix));\r\n    }\r\n}"
12     },
13     "contracts/interfaces/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": false,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     },
34     "libraries": {}
35   }
36 }}