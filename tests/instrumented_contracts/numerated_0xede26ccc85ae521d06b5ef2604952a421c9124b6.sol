1 /**
2    Copyright (c) 2021 LocalCryptos.com
3 
4    Licensed under the Apache License, Version 2.0 (the “License”);
5    you may not use this file except in compliance with the License.
6    You may obtain a copy of the License at
7 
8       http://www.apache.org/licenses/LICENSE-2.0
9 
10    Unless required by applicable law or agreed to in writing, software
11    distributed under the License is distributed on an “AS IS” BASIS,
12    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13    See the License for the specific language governing permissions and
14    limitations under the License.
15 */
16 // SPDX-License-Identifier: Apache-2.0
17 pragma solidity ^0.7.6;
18 
19 abstract contract Token {
20     function transfer(address _to, uint _value) public virtual returns (bool success);
21     function transferFrom(address _from, address _to, uint _value) public virtual returns (bool success);
22     function virtualapprove(address _spender, uint _value) public virtual returns (bool success);
23     function approve(address spender, uint256 value) public virtual returns (bool);
24 }
25 
26 /// @title LocalCryptos ETH Escrows
27 /// @author LocalCryptos
28 contract LocalCryptosETHEscrows {
29     /***********************
30     +   Global settings   +
31     ***********************/
32 
33     // Address of the arbitrator (currently always localethereum staff)
34     address public arbitrator;
35     // Address of the owner (who can withdraw collected fees)
36     address public owner;
37     address public inviterAddress;
38     // Addresses of the relayers (which addresses are allowed to forward signed instructions from parties)
39     mapping (address => bool) public relayers;
40 
41     uint32 public requestCancellationMinimumTime;
42     // Cumulative balance of collected fees
43     uint256 public feesAvailableForWithdraw;
44 
45     /***********************
46     +  Instruction types  +
47     ***********************/
48 
49     // Called when the buyer marks payment as sent. Locks funds in escrow
50     uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;
51     // Buyer cancelling
52     uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;
53     // Seller cancelling
54     uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;
55     // Seller requesting to cancel. Begins a window for buyer to object
56     uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;
57     // Seller releasing funds to the buyer
58     uint8 constant INSTRUCTION_RELEASE = 0x05;
59     // Either party permitting the arbitrator to resolve a dispute
60     uint8 constant INSTRUCTION_RESOLVE = 0x06;
61 
62     /***********************
63     +       Events        +
64     ***********************/
65 
66     event Created(bytes32 indexed _tradeHash);
67     event SellerCancelDisabled(bytes32 indexed _tradeHash);
68     event SellerRequestedCancel(bytes32 indexed _tradeHash);
69     event CancelledBySeller(bytes32 indexed _tradeHash);
70     event CancelledByBuyer(bytes32 indexed _tradeHash);
71     event Released(bytes32 indexed _tradeHash);
72     event DisputeResolved(bytes32 indexed _tradeHash);
73 
74     struct Escrow {
75         // So we know the escrow exists
76         bool exists;
77         // This is the timestamp in whic hthe seller can cancel the escrow after.
78         // It has two special values:
79         // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)
80         // 1 : The seller can only request to cancel, which will change this value to a timestamp.
81         //     This option is avaialble for complex trade terms such as cash-in-person where a
82         //     payment window is inappropriate
83         uint32 sellerCanCancelAfter;
84         // Cumulative cost of gas incurred by the relayer. This amount will be refunded to the owner
85         // in the way of fees once the escrow has completed
86         uint128 totalGasFeesSpentByRelayer;
87     }
88 
89     // Mapping of active trades. The key here is a hash of the trade proprties
90     mapping (bytes32 => Escrow) public escrows;
91 
92     modifier onlyOwner() {
93         require(msg.sender == owner, "Must be owner");
94         _;
95     }
96 
97     modifier onlyArbitrator() {
98         require(msg.sender == arbitrator, "Must be arbitrator");
99         _;
100     }
101 
102     /// @notice Initialize the contract.
103     constructor() {
104         owner = msg.sender;
105         arbitrator = msg.sender;
106         inviterAddress = msg.sender;
107         requestCancellationMinimumTime = 0 seconds;
108     }
109 
110     /// @notice Create and fund a new escrow.
111     /// @param _tradeID The unique ID of the trade, generated by localethereum.com
112     /// @param _seller The selling party
113     /// @param _buyer The buying party
114     /// @param _value The amount of the escrow, exclusive of the fee
115     /// @param _fee Localethereum's commission in 1/10000ths
116     /// @param _paymentWindowInSeconds The time in seconds from escrow creation that the seller can cancel after
117     /// @param _expiry This transaction must be created before this time
118     /// @param _v Signature "v" component
119     /// @param _r Signature "r" component
120     /// @param _s Signature "s" component
121     function createEscrow(
122         bytes16 _tradeID,
123         address _seller,
124         address _buyer,
125         uint256 _value,
126         uint16 _fee,
127         uint32 _paymentWindowInSeconds,
128         uint32 _expiry,
129         uint8 _v,
130         bytes32 _r,
131         bytes32 _s
132     ) payable external {
133         // The trade hash is created by tightly-concatenating and hashing properties of the trade.
134         // This hash becomes the identifier of the escrow, and hence all these variables must be
135         // supplied on future contract calls
136         bytes32 _tradeHash = keccak256(abi.encodePacked(_tradeID, _seller, _buyer, _value, _fee));
137         // Require that trade does not already exist
138         require(!escrows[_tradeHash].exists, "Trade already exists");
139         // A signature (v, r and s) must come from localethereum to open an escrow
140         bytes32 _invitationHash = keccak256(abi.encodePacked(
141             _tradeHash,
142             _paymentWindowInSeconds,
143             _expiry
144         ));
145         require(recoverAddress(_invitationHash, _v, _r, _s) == inviterAddress, "Invitation signature was not valid");
146         // These signatures come with an expiry stamp
147         require(block.timestamp < _expiry, "Signature has expired");
148         // Check transaction value against signed _value and make sure is not 0
149         require(msg.value == _value && msg.value > 0, "Incorrect ether sent");
150         uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0
151             ? 1
152             : uint32(block.timestamp) + _paymentWindowInSeconds;
153         // Add the escrow to the public mapping
154         escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);
155         emit Created(_tradeHash);
156     }
157 
158     uint16 constant GAS_doResolveDispute = 45368;
159     /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.
160     /// @param _tradeID Escrow "tradeID" parameter
161     /// @param _seller Escrow "seller" parameter
162     /// @param _buyer Escrow "buyer" parameter
163     /// @param _value Escrow "value" parameter
164     /// @param _fee Escrow "fee parameter
165     /// @param _v Signature "v" component
166     /// @param _r Signature "r" component
167     /// @param _s Signature "s" component
168     /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)
169     function resolveDispute(
170         bytes16 _tradeID,
171         address payable _seller,
172         address payable _buyer,
173         uint256 _value,
174         uint16 _fee,
175         uint8 _v,
176         bytes32 _r,
177         bytes32 _s,
178         uint8 _buyerPercent
179     ) external onlyArbitrator {
180         address _signature = recoverAddress(keccak256(abi.encodePacked(
181             _tradeID,
182             INSTRUCTION_RESOLVE
183         )), _v, _r, _s);
184         require(_signature == _buyer || _signature == _seller, "Must be buyer or seller");
185 
186         Escrow memory _escrow;
187         bytes32 _tradeHash;
188         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
189         require(_escrow.exists, "Escrow does not exist");
190         require(_buyerPercent <= 100, "_buyerPercent must be 100 or lower");
191 
192         uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + (GAS_doResolveDispute * uint128(tx.gasprice));
193         require(_value - _totalFees <= _value, "Overflow error"); // Prevent underflow
194         feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw
195 
196         delete escrows[_tradeHash];
197         emit DisputeResolved(_tradeHash);
198         if (_buyerPercent > 0)
199           payable(_buyer).transfer((_value - _totalFees) * _buyerPercent / 100);
200         if (_buyerPercent < 100)
201           payable(_seller).transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);
202     }
203 
204     /// @notice Release ether in escrow to the buyer. Direct call option.
205     /// @param _tradeID Escrow "tradeID" parameter
206     /// @param _seller Escrow "seller" parameter
207     /// @param _buyer Escrow "buyer" parameter
208     /// @param _value Escrow "value" parameter
209     /// @param _fee Escrow "fee parameter
210     /// @return bool
211     function release(
212         bytes16 _tradeID,
213         address _seller,
214         address payable _buyer,
215         uint256 _value,
216         uint16 _fee
217     ) external returns (bool) {
218         require(msg.sender == _seller, "Must be seller");
219         return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);
220     }
221 
222     /// @notice Disable the seller from cancelling (i.e. "mark as paid"). Direct call option.
223     /// @param _tradeID Escrow "tradeID" parameter
224     /// @param _seller Escrow "seller" parameter
225     /// @param _buyer Escrow "buyer" parameter
226     /// @param _value Escrow "value" parameter
227     /// @param _fee Escrow "fee parameter
228     /// @return bool
229     function disableSellerCancel(
230         bytes16 _tradeID,
231         address _seller,
232         address _buyer,
233         uint256 _value,
234         uint16 _fee
235     ) external returns (bool) {
236         require(msg.sender == _buyer, "Must be buyer");
237         return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
238     }
239 
240     /// @notice Cancel the escrow as a buyer. Direct call option.
241     /// @param _tradeID Escrow "tradeID" parameter
242     /// @param _seller Escrow "seller" parameter
243     /// @param _buyer Escrow "buyer" parameter
244     /// @param _value Escrow "value" parameter
245     /// @param _fee Escrow "fee parameter
246     /// @return bool
247     function buyerCancel(
248       bytes16 _tradeID,
249       address payable _seller,
250       address _buyer,
251       uint256 _value,
252       uint16 _fee
253     ) external returns (bool) {
254         require(msg.sender == _buyer, "Must be buyer");
255         return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
256     }
257 
258     /// @notice Cancel the escrow as a seller. Direct call option.
259     /// @param _tradeID Escrow "tradeID" parameter
260     /// @param _seller Escrow "seller" parameter
261     /// @param _buyer Escrow "buyer" parameter
262     /// @param _value Escrow "value" parameter
263     /// @param _fee Escrow "fee parameter
264     /// @return bool
265     function sellerCancel(
266         bytes16 _tradeID,
267         address payable _seller,
268         address _buyer,
269         uint256 _value,
270         uint16 _fee
271     ) external returns (bool) {
272         require(msg.sender == _seller, "Must be seller");
273         return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
274     }
275 
276     /// @notice Request to cancel as a seller. Direct call option.
277     /// @param _tradeID Escrow "tradeID" parameter
278     /// @param _seller Escrow "seller" parameter
279     /// @param _buyer Escrow "buyer" parameter
280     /// @param _value Escrow "value" parameter
281     /// @param _fee Escrow "fee parameter
282     /// @return bool
283     function sellerRequestCancel(
284         bytes16 _tradeID,
285         address _seller,
286         address _buyer,
287         uint256 _value,
288         uint16 _fee
289     ) external returns (bool) {
290         require(msg.sender == _seller, "Must be seller");
291         return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
292     }
293 
294     uint16 constant GAS_batchRelayBase = 32720;
295     /// @notice Relay multiple signed instructions from parties of escrows.
296     /// @param _tradeID List of _tradeID values
297     /// @param _seller List of _seller values
298     /// @param _buyer List of _buyer values
299     /// @param _value List of _value values
300     /// @param _fee List of _fee values
301     /// @param _maximumGasPrice List of _maximumGasPrice values
302     /// @param _v List of signature "v" components
303     /// @param _r List of signature "r" components
304     /// @param _s List of signature "s" components
305     /// @param _instructionByte List of _instructionByte values
306     /// @return bool List of results
307     function batchRelay(
308         bytes16[] memory _tradeID,
309         address payable[] memory _seller,
310         address payable[] memory _buyer,
311         uint256[] memory _value,
312         uint16[] memory _fee,
313         uint128[] memory _maximumGasPrice,
314         uint8[] memory _v,
315         bytes32[] memory _r,
316         bytes32[] memory _s,
317         uint8[] memory _instructionByte
318     ) public returns (bool[] memory) {
319         bool[] memory _results = new bool[](_tradeID.length);
320         uint128 _additionalGas = uint128(relayers[msg.sender] == true ? (GAS_batchRelayBase / _tradeID.length) : 0);
321         for (uint8 i=0; i<_tradeID.length; i++) {
322             _results[i] = relay(
323                 _tradeID[i],
324                 _seller[i],
325                 _buyer[i],
326                 _value[i],
327                 _fee[i],
328                 _maximumGasPrice[i],
329                 _v[i],
330                 _r[i],
331                 _s[i],
332                 _instructionByte[i],
333                 _additionalGas
334             );
335         }
336         return _results;
337     }
338 
339     /// @notice Withdraw fees collected by the contract. Only the owner can call this.
340     /// @param _to Address to withdraw fees in to
341     /// @param _amount Amount to withdraw
342     function withdrawFees(address payable _to, uint256 _amount) onlyOwner external {
343         // This check also prevents underflow
344         require(_amount <= feesAvailableForWithdraw, "Amount is higher than amount available");
345         feesAvailableForWithdraw -= _amount;
346         payable(_to).transfer(_amount);
347     }
348 
349     /// @notice Set the arbitrator to a new address. Only the owner can call this.
350     /// @param _newArbitrator Address of the replacement arbitrator
351     function setArbitrator(address _newArbitrator) onlyOwner external {
352         arbitrator = _newArbitrator;
353     }
354 
355     /// @notice Change the owner to a new address. Only the owner can call this.
356     /// @param _newOwner Address of the replacement owner
357     function setOwner(address _newOwner) onlyOwner external {
358         owner = _newOwner;
359     }
360 
361     /// @notice Enable or disable a relayer address. Only the owner can call this.
362     /// @param _newRelayer Address of the relayer
363     /// @param _enabled Whether the relayer is enabled
364     function setRelayer(address _newRelayer, bool _enabled) onlyOwner external {
365         relayers[_newRelayer] = _enabled;
366     }
367 
368     /// @notice Change the inviter to a new address. Only the owner can call this.
369     /// @param _newInviterAddress Address of the inviter address
370     function setInviterAddress(address _newInviterAddress) onlyOwner external {
371         inviterAddress = _newInviterAddress;
372     }
373 
374     /// @notice Change the requestCancellationMinimumTime. Only the owner can call this.
375     /// @param _newRequestCancellationMinimumTime Replacement
376     function setRequestCancellationMinimumTime(
377         uint32 _newRequestCancellationMinimumTime
378     ) onlyOwner external {
379         requestCancellationMinimumTime = _newRequestCancellationMinimumTime;
380     }
381 
382     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
383     /// @param _tokenContract Token contract
384     /// @param _transferTo Recipient
385     /// @param _value Value
386     function transferToken(
387         Token _tokenContract,
388         address _transferTo,
389         uint256 _value
390     ) onlyOwner external {
391         _tokenContract.transfer(_transferTo, _value);
392     }
393 
394     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
395     /// @param _tokenContract Token contract
396     /// @param _transferTo Recipient
397     /// @param _transferFrom Sender
398     /// @param _value Value
399     function transferTokenFrom(
400         Token _tokenContract,
401         address _transferTo,
402         address _transferFrom,
403         uint256 _value
404     ) onlyOwner external {
405         _tokenContract.transferFrom(_transferTo, _transferFrom, _value);
406     }
407 
408     /// @notice Send ERC20 tokens away. This function allows the owner to withdraw stuck ERC20 tokens.
409     /// @param _tokenContract Token contract
410     /// @param _spender Spender address
411     /// @param _value Value
412     function approveToken(
413         Token _tokenContract,
414         address _spender,
415         uint256 _value
416     ) onlyOwner external {
417         _tokenContract.approve(_spender, _value);
418     }
419 
420     /// @notice Relay a signed instruction from a party of an escrow.
421     /// @param _tradeID Escrow "tradeID" parameter
422     /// @param _seller Escrow "seller" parameter
423     /// @param _buyer Escrow "buyer" parameter
424     /// @param _value Escrow "value" parameter
425     /// @param _fee Escrow "fee parameter
426     /// @param _maximumGasPrice Maximum gas price permitted for the relayer (set by the instructor)
427     /// @param _v Signature "v" component
428     /// @param _r Signature "r" component
429     /// @param _s Signature "s" component
430     /// @param _additionalGas Additional gas to be deducted after this operation
431     /// @return bool
432     function relay(
433         bytes16 _tradeID,
434         address payable _seller,
435         address payable _buyer,
436         uint256 _value,
437         uint16 _fee,
438         uint128 _maximumGasPrice,
439         uint8 _v,
440         bytes32 _r,
441         bytes32 _s,
442         uint8 _instructionByte,
443         uint128 _additionalGas
444     ) private returns (bool) {
445         address _relayedSender = getRelayedSender(
446             _tradeID,
447             _instructionByte,
448             _maximumGasPrice,
449             _v,
450             _r,
451             _s
452         );
453         if (_relayedSender == _buyer) {
454             // Buyer's instructions:
455             if (_instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL) {
456                 // Disable seller from cancelling
457                 return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
458             } else if (_instructionByte == INSTRUCTION_BUYER_CANCEL) {
459                 // Cancel
460                 return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
461             }
462         } else if (_relayedSender == _seller) {
463             // Seller's instructions:
464             if (_instructionByte == INSTRUCTION_RELEASE) {
465                 // Release
466                 return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
467             } else if (_instructionByte == INSTRUCTION_SELLER_CANCEL) {
468                 // Cancel
469                 return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
470             } else if (_instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL) {
471                 // Request to cancel
472                 return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
473             }
474         }
475         return false;
476     }
477 
478     /// @notice Increase the amount of gas to be charged later on completion of an escrow
479     /// @param _tradeHash Trade hash
480     /// @param _gas Gas cost
481     function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {
482         escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);
483     }
484 
485     /// @notice Transfer the value of an escrow, minus the fees, minus the gas costs incurred by relay
486     /// @param _to Recipient address
487     /// @param _value Value of the transfer
488     /// @param _totalGasFeesSpentByRelayer Total gas fees spent by the relayer
489     /// @param _fee Commission in 1/10000ths
490     function transferMinusFees(
491         address payable _to,
492         uint256 _value,
493         uint128 _totalGasFeesSpentByRelayer,
494         uint16 _fee
495     ) private {
496         uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;
497         // Prevent underflow
498         if(_value - _totalFees > _value) {
499             return;
500         }
501         // Add fees to the pot for localethereum to withdraw
502         feesAvailableForWithdraw += _totalFees;
503         payable(_to).transfer(_value - _totalFees);
504     }
505 
506     uint16 constant GAS_doRelease = 12664;
507     /// @notice Release escrow to the buyer. This completes it and removes it from the mapping.
508     /// @param _tradeID Escrow "tradeID" parameter
509     /// @param _seller Escrow "seller" parameter
510     /// @param _buyer Escrow "buyer" parameter
511     /// @param _value Escrow "value" parameter
512     /// @param _fee Escrow "fee parameter
513     /// @param _additionalGas Additional gas to be deducted after this operation
514     /// @return bool
515     function doRelease(
516         bytes16 _tradeID,
517         address _seller,
518         address payable _buyer,
519         uint256 _value,
520         uint16 _fee,
521         uint128 _additionalGas
522     ) private returns (bool) {
523         Escrow memory _escrow;
524         bytes32 _tradeHash;
525         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
526         if (!_escrow.exists) return false;
527         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer
528             + (relayers[msg.sender] == true
529                 ? (GAS_doRelease + _additionalGas ) * uint128(tx.gasprice)
530                 : 0
531             );
532         delete escrows[_tradeHash];
533         emit Released(_tradeHash);
534         transferMinusFees(_buyer, _value, _gasFees, _fee);
535         return true;
536     }
537 
538     uint16 constant GAS_doDisableSellerCancel = 16568;
539     /// @notice Prevents the seller from cancelling an escrow. Used to "mark as paid" by the buyer.
540     /// @param _tradeID Escrow "tradeID" parameter
541     /// @param _seller Escrow "seller" parameter
542     /// @param _buyer Escrow "buyer" parameter
543     /// @param _value Escrow "value" parameter
544     /// @param _fee Escrow "fee parameter
545     /// @param _additionalGas Additional gas to be deducted after this operation
546     /// @return bool
547     function doDisableSellerCancel(
548         bytes16 _tradeID,
549         address _seller,
550         address _buyer,
551         uint256 _value,
552         uint16 _fee,
553         uint128 _additionalGas
554     ) private returns (bool) {
555         Escrow memory _escrow;
556         bytes32 _tradeHash;
557         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
558         if (!_escrow.exists) return false;
559         if(_escrow.sellerCanCancelAfter == 0) return false;
560         escrows[_tradeHash].sellerCanCancelAfter = 0;
561         emit SellerCancelDisabled(_tradeHash);
562         if (relayers[msg.sender] == true) {
563           increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
564         }
565         return true;
566     }
567 
568     uint16 constant GAS_doBuyerCancel = 12648;
569     /// @notice Cancels the trade and returns the ether to the seller. Can only be called the buyer.
570     /// @param _tradeID Escrow "tradeID" parameter
571     /// @param _seller Escrow "seller" parameter
572     /// @param _buyer Escrow "buyer" parameter
573     /// @param _value Escrow "value" parameter
574     /// @param _fee Escrow "fee parameter
575     /// @param _additionalGas Additional gas to be deducted after this operation
576     /// @return bool
577     function doBuyerCancel(
578         bytes16 _tradeID,
579         address payable _seller,
580         address _buyer,
581         uint256 _value,
582         uint16 _fee,
583         uint128 _additionalGas
584     ) private returns (bool) {
585         Escrow memory _escrow;
586         bytes32 _tradeHash;
587         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
588         if (!_escrow.exists) {
589             return false;
590         }
591         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer
592             + (relayers[msg.sender] == true
593                 ? (GAS_doBuyerCancel + _additionalGas ) * uint128(tx.gasprice)
594                 : 0
595             );
596         delete escrows[_tradeHash];
597         emit CancelledByBuyer(_tradeHash);
598         transferMinusFees(_seller, _value, _gasFees, 0);
599         return true;
600     }
601 
602     uint16 constant GAS_doSellerCancel = 13714;
603     /// @notice Returns the ether in escrow to the seller. Called by the seller. Sometimes unavailable.
604     /// @param _tradeID Escrow "tradeID" parameter
605     /// @param _seller Escrow "seller" parameter
606     /// @param _buyer Escrow "buyer" parameter
607     /// @param _value Escrow "value" parameter
608     /// @param _fee Escrow "fee parameter
609     /// @param _additionalGas Additional gas to be deducted after this operation
610     /// @return bool
611     function doSellerCancel(
612         bytes16 _tradeID,
613         address payable _seller,
614         address _buyer,
615         uint256 _value,
616         uint16 _fee,
617         uint128 _additionalGas
618     ) private returns (bool) {
619         Escrow memory _escrow;
620         bytes32 _tradeHash;
621         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
622         if (!_escrow.exists) {
623             return false;
624         }
625         if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) {
626             return false;
627         }
628         if (relayers[msg.sender] == false && _escrow.sellerCanCancelAfter + 12 hours > block.timestamp) {
629             return false;
630         }
631         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer
632             + (relayers[msg.sender] == true
633                 ? (GAS_doSellerCancel + _additionalGas ) * uint128(tx.gasprice)
634                 : 0
635             );
636         delete escrows[_tradeHash];
637         emit CancelledBySeller(_tradeHash);
638         transferMinusFees(_seller, _value, _gasFees, 0);
639         return true;
640     }
641 
642     uint16 constant GAS_doSellerRequestCancel = 17004;
643     /// @notice Request to cancel. Used if the buyer is unresponsive. Begins a countdown timer.
644     /// @param _tradeID Escrow "tradeID" parameter
645     /// @param _seller Escrow "seller" parameter
646     /// @param _buyer Escrow "buyer" parameter
647     /// @param _value Escrow "value" parameter
648     /// @param _fee Escrow "fee parameter
649     /// @param _additionalGas Additional gas to be deducted after this operation
650     /// @return bool
651     function doSellerRequestCancel(
652         bytes16 _tradeID,
653         address _seller,
654         address _buyer,
655         uint256 _value,
656         uint16 _fee,
657         uint128 _additionalGas
658     ) private returns (bool) {
659         // Called on unlimited payment window trades where the buyer is not responding
660         Escrow memory _escrow;
661         bytes32 _tradeHash;
662         (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
663         if (!_escrow.exists) {
664             return false;
665         }
666         if(_escrow.sellerCanCancelAfter != 1) {
667             return false;
668         }
669         escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp)
670             + requestCancellationMinimumTime;
671         emit SellerRequestedCancel(_tradeHash);
672         if (relayers[msg.sender] == true) {
673           increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);
674         }
675         return true;
676     }
677 
678     /// @notice Get the sender of the signed instruction.
679     /// @param _tradeID Identifier of the trade
680     /// @param _instructionByte Identifier of the instruction
681     /// @param _maximumGasPrice Maximum gas price permitted by the sender
682     /// @param _v Signature "v" component
683     /// @param _r Signature "r" component
684     /// @param _s Signature "s" component
685     /// @return address
686     function getRelayedSender(
687       bytes16 _tradeID,
688       uint8 _instructionByte,
689       uint128 _maximumGasPrice,
690       uint8 _v,
691       bytes32 _r,
692       bytes32 _s
693     ) view private returns (address) {
694         bytes32 _hash = keccak256(abi.encodePacked(
695             _tradeID,
696             _instructionByte,
697             _maximumGasPrice
698         ));
699         if(tx.gasprice > _maximumGasPrice) {
700             return (address)(0);
701         }
702         return recoverAddress(_hash, _v, _r, _s);
703     }
704 
705     /// @notice Hashes the values and returns the matching escrow object and trade hash.
706     /// @dev Returns an empty escrow struct and 0 _tradeHash if not found.
707     /// @param _tradeID Escrow "tradeID" parameter
708     /// @param _seller Escrow "seller" parameter
709     /// @param _buyer Escrow "buyer" parameter
710     /// @param _value Escrow "value" parameter
711     /// @param _fee Escrow "fee parameter
712     /// @return Escrow
713     function getEscrowAndHash(
714         bytes16 _tradeID,
715         address _seller,
716         address _buyer,
717         uint256 _value,
718         uint16 _fee
719     ) view private returns (Escrow memory, bytes32) {
720         bytes32 _tradeHash = keccak256(abi.encodePacked(
721             _tradeID,
722             _seller,
723             _buyer,
724             _value,
725             _fee
726         ));
727         return (escrows[_tradeHash], _tradeHash);
728     }
729 
730     /// @notice Returns an empty escrow struct and 0 _tradeHash if not found.
731     /// @param _h Data to be hashed
732     /// @param _v Signature "v" component
733     /// @param _r Signature "r" component
734     /// @param _s Signature "s" component
735     /// @return address
736     function recoverAddress(
737         bytes32 _h,
738         uint8 _v,
739         bytes32 _r,
740         bytes32 _s
741     ) private pure returns (address) {
742         bytes memory _prefix = "\x19Ethereum Signed Message:\n32";
743         bytes32 _prefixedHash = keccak256(abi.encodePacked(_prefix, _h));
744         return ecrecover(_prefixedHash, _v, _r, _s);
745     }
746 }