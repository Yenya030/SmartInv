1 {{
2   "language": "Solidity",
3   "sources": {
4     "@metalabel/solmate/src/auth/Owned.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
6     },
7     "@metalabel/solmate/src/utils/SSTORE2.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/utils/Base64.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/utils/Strings.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
15     },
16     "contracts/engines/DropEngineV2.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/*\n\n███╗   ███╗███████╗████████╗ █████╗ ██╗      █████╗ ██████╗ ███████╗██╗\n████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██║     ██╔══██╗██╔══██╗██╔════╝██║\n██╔████╔██║█████╗     ██║   ███████║██║     ███████║██████╔╝█████╗  ██║\n██║╚██╔╝██║██╔══╝     ██║   ██╔══██║██║     ██╔══██║██╔══██╗██╔══╝  ██║\n██║ ╚═╝ ██║███████╗   ██║   ██║  ██║███████╗██║  ██║██████╔╝███████╗███████╗\n╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚══════╝╚══════╝\n\n\nDeployed by Metalabel with 💖 as a permanent application on the Ethereum blockchain.\n\nMetalabel is a growing universe of tools, knowledge, and resources for\nmetalabels and cultural collectives.\n\nOur purpose is to establish the metalabel as key infrastructure for creative\ncollectives and to inspire a new culture of creative collaboration and mutual\nsupport.\n\nOUR SQUAD\n\nAnna Bulbrook (Curator)\nAustin Robey (Community)\nBrandon Valosek (Engineer)\nIlya Yudanov (Designer)\nLauren Dorman (Engineer)\nRob Kalin (Board)\nYancey Strickler (Director)\n\nhttps://metalabel.xyz\n\n*/\n\nimport {Owned} from \"@metalabel/solmate/src/auth/Owned.sol\";\nimport {SSTORE2} from \"@metalabel/solmate/src/utils/SSTORE2.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ICollection} from \"../interfaces/ICollection.sol\";\nimport {IEngine, SequenceData} from \"../interfaces/IEngine.sol\";\nimport {INodeRegistry} from \"../interfaces/INodeRegistry.sol\";\n\n/// @notice Data stored engine-side for each drop.\n/// - Royalty percentage is stored as basis points, eg 5% = 500\n/// - If maxRecordPerTransaction is 0, there is not limit\n/// - Protocol fee is written to drop data at configure-time to lock in protocol\n///   fee and avoid an additional storage read at mint-time\nstruct DropData {\n    uint96 price;\n    uint16 royaltyBps;\n    bool allowContractMints;\n    bool randomizeMetadataVariants;\n    uint8 maxRecordsPerTransaction;\n    address revenueRecipient;\n    uint16 primarySaleFeeBps;\n    uint96 priceDecayPerDay;\n    uint64 decayStopTimestamp;\n    // 59 bytes total / 5 remaining for a two-word slot\n}\n\n/// @notice A single attribute of an NFT's metadata\nstruct NFTMetadataAttribute {\n    string trait_type;\n    string value;\n}\n\n/// @notice Metadata stored for a single record variant\n/// @dev Storage is written via SSTORE2\nstruct NFTMetadata {\n    string name;\n    string description;\n    string image;\n    string external_url;\n    string metalabel_record_variant_name;\n    string metalabel_release_metadata_uri;\n    uint16[] metalabel_record_contents;\n    NFTMetadataAttribute[] attributes;\n}\n\n/// @notice Metalabel engine that implements a multi-NFT drop.\n/// - All metadata is stored onchain via SSTORE2.\n/// - Price can decay over time or be constant throughout the drop.\n/// - Metadata variants can be p-randomized or fixed.\n/// - Enabling or disabling smart contract mints is set per-sequence.\n/// - Multiple records can be minted in a single trx, configurable per-sequence.\n/// - The owner of this contract can set a primary sale fee that is taken from\n///   all primary sales revenue and retained by this drop engine.\ncontract DropEngineV2 is IEngine, Owned {\n    // ---\n    // Errors\n    // ---\n\n    /// @notice Invalid msg.value on purchase\n    error IncorrectPaymentAmount();\n\n    /// @notice If price or recipient is zero, they both have to be zero\n    error InvalidPriceOrRecipient();\n\n    /// @notice An invalid value was used for the royalty bps.\n    error InvalidRoyaltyBps();\n\n    /// @notice An invalid value was used for the primary sale fee.\n    error InvalidPrimarySaleFee();\n\n    /// @notice If smart contract mints are not allowed, msg.sender must be an\n    /// EOA\n    error MinterMustBeEOA();\n\n    /// @notice If minting more than the max allowed per transaction\n    error InvalidMintAmount();\n\n    /// @notice An invalid price decay stop time or per day decay was used.\n    error InvalidPriceDecayConfig();\n\n    /// @notice Unable to forward ETH to the revenue recipient or unable to\n    /// withdraw funds\n    error CouldNotTransferEth();\n\n    // ---\n    // Events\n    // ---\n\n    /// @notice A new drop was created.\n    /// @dev The collection already emits a SequenceCreated event, we're\n    /// emitting the additional engine-specific data here.\n    event DropCreated(address collection, uint16 sequenceId, DropData dropData);\n\n    /// @notice The primary sale for this drop engine was set\n    event PrimarySaleFeeSet(uint16 primarySaleFeeBps);\n\n    // ---\n    // Storage\n    // ---\n\n    /// @notice Drop data for a given collection + sequence ID.\n    mapping(address => mapping(uint16 => DropData)) public drops;\n\n    /// @notice The SSTORE2 contract storage address for a given sequence's list\n    /// of metadata variants\n    mapping(address => mapping(uint16 => address))\n        public metadataStoragePointers;\n\n    /// @notice A primary sales fee that is paid at mint time. Can be adjusted\n    /// by contract owner. Fee is written into the drop's DropData structure, so\n    /// fee at configure-time is locked. Fees are accumulated in the contract\n    /// and can be withdrawn by the contract owner\n    uint16 public primarySaleFeeBps;\n\n    /// @notice A reference to the core protocol's node registry.\n    /// @dev While this is not directly used by the engine, it is surfaced in\n    /// the onchain generated JSON metadata for records as a way of creating a\n    /// concrete link back to the cataloging protocol.\n    INodeRegistry public immutable nodeRegistry;\n\n    // ---\n    // Constructor\n    // ---\n\n    constructor(address _contractOwner, INodeRegistry _nodeRegistry)\n        Owned(_contractOwner)\n    {\n        nodeRegistry = _nodeRegistry;\n    }\n\n    // ---\n    // Admin functionality\n    // ---\n\n    /// @notice Set the primary sale fee for all drops configured on this\n    /// engine. Only callable by owner\n    function setPrimarySaleFeeBps(uint16 fee) external onlyOwner {\n        if (fee > 10000) revert InvalidPrimarySaleFee();\n        primarySaleFeeBps = fee;\n        emit PrimarySaleFeeSet(fee);\n    }\n\n    // ---\n    // Permissionless functions\n    // ---\n\n    /// @notice Transfer ETH from the contract that has accumulated from fees to\n    /// the owner's account. Can be called by any address.\n    function transferFeesToOwner() external {\n        (bool success, ) = owner.call{value: address(this).balance}(\"\");\n        if (!success) revert CouldNotTransferEth();\n    }\n\n    // ---\n    // Mint functionality\n    // ---\n\n    /// @notice Mint records. Returns the first token ID minted\n    function mint(\n        ICollection collection,\n        uint16 sequenceId,\n        uint8 count\n    ) external payable returns (uint256 tokenId) {\n        DropData storage drop = drops[address(collection)][sequenceId];\n\n        // block SC mints if flagged\n        if (!drop.allowContractMints && msg.sender != tx.origin) {\n            revert MinterMustBeEOA();\n        }\n\n        // Ensure not minting too many\n        if (\n            drop.maxRecordsPerTransaction > 0 &&\n            count > drop.maxRecordsPerTransaction\n        ) {\n            revert InvalidMintAmount();\n        }\n\n        // Resolve current unit price (which may change over time if there's a\n        // price decay configuration) and total order price\n        uint256 unitPrice = currentPrice(collection, sequenceId);\n        uint256 orderPrice = unitPrice * count;\n\n        // Ensure correct payment was sent with the transaction. Checking less\n        // than to allow sender to overpay (likely happens for all decaying\n        // prices). We refund the difference below.\n        if (msg.value < orderPrice) {\n            revert IncorrectPaymentAmount();\n        }\n\n        for (uint256 i = 0; i < count; i++) {\n            // If collection is a malicious contract, that does not impact any\n            // state in the engine.  If it's a valid protocol-deployed\n            // collection, then it will work as expected.\n            //\n            // Collection enforces max mint supply and mint window, so we're not\n            // checking that here\n            uint256 id = collection.mintRecord(msg.sender, sequenceId);\n\n            // return the first minted token ID, caller can infer subsequent\n            // sequential IDs\n            tokenId = tokenId != 0 ? tokenId : id;\n        }\n\n        // Amount to forward to the revenue recipient is the total order price\n        // minus the locked-in primary sale fee that was recorded at\n        // configure-time.  The remaining ETH (after refund) will stay in this\n        // contract, withdrawable by the owner at a later date via\n        // transferFeesToOwner\n        uint256 amountToForward = orderPrice -\n            ((orderPrice * drop.primarySaleFeeBps) / 10000);\n\n        // Amount to refund message sender is any difference in order price and\n        // msg.value. This happens if the caller overpays, which will generally\n        // always happen on decaying price mints\n        uint256 amountToRefund = msg.value > orderPrice\n            ? msg.value - orderPrice\n            : 0;\n\n        // Refund caller\n        if (amountToRefund > 0) {\n            (bool success, ) = msg.sender.call{value: amountToRefund}(\"\");\n            if (!success) revert CouldNotTransferEth();\n        }\n\n        // Forward ETH to the revenue recipient\n        if (amountToForward > 0) {\n            (bool success, ) = drop.revenueRecipient.call{\n                value: amountToForward\n            }(\"\");\n            if (!success) revert CouldNotTransferEth();\n        }\n    }\n\n    /// @notice Get the current price of a record in a given sequence. This will\n    /// return a price even if the sequence is not currently mintable (i.e. the\n    /// mint window hasn't started yet or the minting window has closed).\n    function currentPrice(ICollection collection, uint16 sequenceId)\n        public\n        view\n        returns (uint256 unitPrice)\n    {\n        DropData storage drop = drops[address(collection)][sequenceId];\n\n        // Compute unit price based on decay and timestamp.\n        // First compute how many seconds until the decay cutoff time, after\n        // which price will remain constant. Then compute the marginal increase\n        // in unit price by multiplying the base price by\n        //\n        //   (decay per day * seconds until decay stop) / 1 day\n        //\n\n        uint64 secondsBeforeDecayStop = block.timestamp <\n            drop.decayStopTimestamp\n            ? drop.decayStopTimestamp - uint64(block.timestamp)\n            : 0;\n        uint256 inflateUnitPriceBy = (uint256(drop.priceDecayPerDay) *\n            secondsBeforeDecayStop) / 1 days;\n        unitPrice = drop.price + inflateUnitPriceBy;\n    }\n\n    // ---\n    // IEngine setup\n    // ---\n\n    /// @inheritdoc IEngine\n    /// @dev There is no access control on this function, we infer the\n    /// collection from msg.sender, and use that to key all stored data. If\n    /// somebody calls this function with bogus info (instead of it getting\n    /// called via the collection), it just wastes storage but does not impact\n    /// contract functionality\n    function configureSequence(\n        uint16 sequenceId,\n        SequenceData calldata sequenceData,\n        bytes calldata engineData\n    ) external override {\n        (DropData memory dropData, NFTMetadata[] memory metadatas) = abi.decode(\n            engineData,\n            (DropData, NFTMetadata[])\n        );\n\n        // This drop is a \"free drop\" if and only if the price is zero and decay\n        // per day is zero\n        bool isFreeDrop = dropData.price == 0 && dropData.priceDecayPerDay == 0;\n\n        // Ensure that if this is a free drop, there's no revenue recipient, and\n        // vice versa\n        if ((isFreeDrop) != (dropData.revenueRecipient == address(0))) {\n            revert InvalidPriceOrRecipient();\n        }\n\n        // Don't allow setting a decay stop time in the past (or before the mint\n        // window opens) unless it's zero.\n        if (\n            dropData.decayStopTimestamp != 0 &&\n            (dropData.decayStopTimestamp < block.timestamp ||\n                dropData.decayStopTimestamp <\n                sequenceData.sealedBeforeTimestamp)\n        ) {\n            revert InvalidPriceDecayConfig();\n        }\n\n        // Don't allow setting a decay stop time after the mint window closes\n        if (\n            sequenceData.sealedAfterTimestamp > 0 && // sealed = 0 -> no end\n            dropData.decayStopTimestamp > sequenceData.sealedAfterTimestamp\n        ) {\n            revert InvalidPriceDecayConfig();\n        }\n\n        // Ensure that if decay stop time is set, decay per day is set, and vice\n        // versa\n        if (\n            (dropData.decayStopTimestamp == 0) !=\n            (dropData.priceDecayPerDay == 0)\n        ) {\n            revert InvalidPriceDecayConfig();\n        }\n\n        // Ensure royaltyBps is in range\n        if (dropData.royaltyBps > 10000) revert InvalidRoyaltyBps();\n\n        // To ensure that creators know the protocol fee they are effectively\n        // agreeing to during sequence creation time, we require that they set\n        // the primary sale fee correctly here. This also ensures the drop\n        // engine owner cannot frontrun a fee change\n        if (dropData.primarySaleFeeBps != primarySaleFeeBps) {\n            revert InvalidPrimarySaleFee();\n        }\n\n        // write metadata blob to chain\n        metadataStoragePointers[msg.sender][sequenceId] = SSTORE2.write(\n            abi.encode(metadatas)\n        );\n\n        // Write engine data (passed through from the collection when the\n        // collection admin calls `configureSequence`) to a struct in the engine\n        // with all the needed info.\n        drops[msg.sender][sequenceId] = dropData;\n        emit DropCreated(msg.sender, sequenceId, dropData);\n    }\n\n    // ---\n    // IEngine views\n    // ---\n\n    /// @inheritdoc IEngine\n    /// @dev Token URI is constructed programmatically from stored metadata by\n    /// creating the JSON string and base64ing it\n    function getTokenURI(address collection, uint256 tokenId)\n        external\n        view\n        override\n        returns (string memory tokenURI)\n    {\n        uint16 sequenceId = ICollection(collection).tokenSequenceId(tokenId);\n        uint80 editionNumber = ICollection(collection).tokenMintData(tokenId);\n        SequenceData memory sequenceData = ICollection(collection)\n            .getSequenceData(sequenceId);\n\n        NFTMetadata memory metadata = getStoredMetadataVariant(\n            collection,\n            tokenId\n        );\n\n        // Construct edition string as either \"1\" or \"1/1000\" depending on if\n        // this was an open edition\n        string memory sEdition = sequenceData.maxSupply == 0\n            ? Strings.toString(editionNumber)\n            : string.concat(\n                Strings.toString(editionNumber),\n                \"/\",\n                Strings.toString(sequenceData.maxSupply)\n            );\n\n        // Edition number and variant name are always included\n        string memory attributesInnerJson = string.concat(\n            '{\"trait_type\": \"Record Edition\", \"value\": \"',\n            sEdition,\n            '\"}, {\"trait_type\": \"Record Variant\", \"value\": \"',\n            metadata.metalabel_record_variant_name,\n            '\"}',\n            metadata.attributes.length > 0 ? \", \" : \"\"\n        );\n\n        // Additional attributes from metadata blob\n        for (uint256 i = 0; i < metadata.attributes.length; i++) {\n            attributesInnerJson = string.concat(\n                attributesInnerJson,\n                i > 0 ? \", \" : \"\",\n                '{\"trait_type\": \"',\n                metadata.attributes[i].trait_type,\n                '\", \"value\": \"',\n                metadata.attributes[i].value,\n                '\"}'\n            );\n        }\n\n        // create the contents array\n        string memory contentsInnerJson = \"[\";\n        for (\n            uint256 i = 0;\n            i < metadata.metalabel_record_contents.length;\n            i++\n        ) {\n            contentsInnerJson = string.concat(\n                contentsInnerJson,\n                Strings.toString(metadata.metalabel_record_contents[i]),\n                i == metadata.metalabel_record_contents.length - 1 ? \"]\" : \", \"\n            );\n        }\n\n        // Compose the final JSON payload. Split across multiple string.concat\n        // calls due to stack limitations\n        string memory json = string.concat(\n            '{\"name\":\"',\n            metadata.name,\n            \" \",\n            sEdition,\n            '\", \"description\":\"',\n            metadata.description,\n            '\", \"image\": \"',\n            metadata.image,\n            '\", \"external_url\": \"',\n            metadata.external_url,\n            '\", '\n        );\n        json = string.concat(\n            json,\n            '\"metalabel\": { \"node_registry_address\": \"',\n            Strings.toHexString(uint256(uint160(address(nodeRegistry))), 20),\n            '\", \"record_variant_name\": \"',\n            metadata.metalabel_record_variant_name,\n            '\", \"release_metadata_uri\": \"',\n            metadata.metalabel_release_metadata_uri,\n            '\", \"record_contents\": ',\n            contentsInnerJson,\n            '}, \"attributes\": [',\n            attributesInnerJson,\n            \"]}\"\n        );\n\n        // Prepend base64 prefix + encode JSON\n        tokenURI = string.concat(\n            \"data:application/json;base64,\",\n            Base64.encode(bytes(json))\n        );\n    }\n\n    /// @notice Get the onchain metadata variant for a specific record\n    /// @dev This is a view function that reads from SSTORE2 storage and picks\n    /// the random or sequential variant, the full onchain metadata is\n    /// generated in tokenURI\n    function getStoredMetadataVariant(address collection, uint256 tokenId)\n        public\n        view\n        returns (NFTMetadata memory metadata)\n    {\n        uint16 sequenceId = ICollection(collection).tokenSequenceId(tokenId);\n        uint80 editionNumber = ICollection(collection).tokenMintData(tokenId);\n\n        // Load all metadata variants from SSTORE2 storage\n        NFTMetadata[] memory metadatas = abi.decode(\n            SSTORE2.read(metadataStoragePointers[collection][sequenceId]),\n            (NFTMetadata[])\n        );\n\n        // Metadata variants are default sequential, but can be pseudo-random\n        // if the randomizeMetadataVariants flag is set.\n        // Using (edition - 1) for sequential since edition number starts at 1\n        uint256 idx = (editionNumber - 1) % metadatas.length;\n        if (drops[collection][sequenceId].randomizeMetadataVariants) {\n            idx =\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            collection,\n                            sequenceId,\n                            editionNumber,\n                            tokenId\n                        )\n                    )\n                ) %\n                metadatas.length;\n        }\n\n        metadata = metadatas[idx];\n    }\n\n    /// @inheritdoc IEngine\n    /// @dev Royalty bps and recipient is per-sequence.\n    function getRoyaltyInfo(\n        address collection,\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view override returns (address, uint256) {\n        uint16 sequenceId = ICollection(collection).tokenSequenceId(tokenId);\n        DropData storage drop = drops[collection][sequenceId];\n        return (drop.revenueRecipient, (salePrice * drop.royaltyBps) / 10000);\n    }\n}\n"
18     },
19     "contracts/interfaces/ICollection.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SequenceData} from \"./IEngine.sol\";\n\n/// @notice Collections are ERC721 contracts that contain records.\ninterface ICollection {\n    /// @notice Mint a new record with custom immutable token data. Only\n    /// callable by the sequence-specific engine.\n    function mintRecord(\n        address to,\n        uint16 sequenceId,\n        uint80 tokenData\n    ) external returns (uint256 tokenId);\n\n    /// @notice Mint a new record with the edition number of the sequence\n    /// written to the immutable token data. Only callable by the\n    /// sequence-specific engine.\n    function mintRecord(address to, uint16 sequenceId)\n        external\n        returns (uint256 tokenId);\n\n    /// @notice Get the sequence ID for a given token.\n    function tokenSequenceId(uint256 tokenId)\n        external\n        view\n        returns (uint16 sequenceId);\n\n    /// @notice Get the immutable mint data for a given token.\n    function tokenMintData(uint256 tokenId) external view returns (uint80 data);\n\n    /// @notice Get the sequence data for a given sequence ID.\n    function getSequenceData(uint16 sequenceId)\n        external\n        view\n        returns (SequenceData memory);\n}\n"
21     },
22     "contracts/interfaces/IEngine.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Data stored in the collection for each sequence.\n/// @dev We could use smaller ints for timestamps and supply, but we'd still be\n/// stuck with a 2-word storage layout. engine + dropNodeId is 28 bytes, leaving\n/// us with only 4 bytes for the remaining parameters.\nstruct SequenceData {\n    uint64 sealedBeforeTimestamp;\n    uint64 sealedAfterTimestamp;\n    uint64 maxSupply;\n    uint64 minted;\n    // ^ 1 word\n    IEngine engine;\n    uint64 dropNodeId;\n    // 4 bytes remaining\n}\n\n/// @notice An engine contract implements record minting mechanics, tokenURI\n/// computation, and royalty computation.\ninterface IEngine {\n    /// @notice Called by the collection when a new sequence is configured.\n    /// @dev An arbitrary bytes buffer engineData is forwarded from the\n    /// collection that can be used to pass setup and configuration data\n    function configureSequence(\n        uint16 sequenceId,\n        SequenceData calldata sequence,\n        bytes calldata engineData\n    ) external;\n\n    /// @notice Called by the collection to resolve tokenURI.\n    function getTokenURI(address collection, uint256 tokenId)\n        external\n        view\n        returns (string memory);\n\n    /// @notice Called by the collection to resolve royalties.\n    function getRoyaltyInfo(\n        address collection,\n        uint256 tokenId,\n        uint256 salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
24     },
25     "contracts/interfaces/INodeRegistry.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nenum NodeType {\n    INVALID_NODE_TYPE,\n    METALABEL,\n    RELEASE\n}\n\n/// @notice Data stored per node.\nstruct NodeData {\n    NodeType nodeType;\n    uint64 owner;\n    uint64 parent;\n    uint64 groupNode;\n    // 7 bytes remaining\n}\n\n/// @notice The node registry maintains a tree of ownable nodes that are used to\n/// catalog logical entities and manage access control in the Metalabel\n/// universe.\ninterface INodeRegistry {\n    /// @notice Create a new node. Child nodes can specify an group node that\n    /// will be used to determine ownership, and a separate logical parent that\n    /// expresses the entity relationship.  Child nodes can only be created if\n    /// msg.sender is an authorized manager of the parent node.\n    function createNode(\n        NodeType nodeType,\n        uint64 owner,\n        uint64 parent,\n        uint64 groupNode,\n        address[] memory initialControllers,\n        string memory metadata\n    ) external returns (uint64 id);\n\n    /// @notice Determine if an address is authorized to manage a node.\n    /// A node can be managed by an address if any of the following conditions\n    /// are true:\n    ///   - The address's account is the owner of the node\n    ///   - The address's account is the owner of the node's group node\n    ///   - The address is an authorized controller of the node\n    ///   - The address is an authorized controller of the node's group node\n    function isAuthorizedAddressForNode(uint64 node, address subject)\n        external\n        view\n        returns (bool isAuthorized);\n\n    /// @notice Resolve node owner account.\n    function ownerOf(uint64 id) external view returns (uint64);\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 1000
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "devdoc",
40           "userdoc",
41           "metadata",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}