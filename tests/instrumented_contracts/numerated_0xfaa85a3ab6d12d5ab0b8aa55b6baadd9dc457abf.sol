1 pragma solidity 0.4.25;
2 
3 // File: contracts/ERC777/ERC777Token.sol
4 
5 /* This Source Code Form is subject to the terms of the Mozilla external
6  * License, v. 2.0. If a copy of the MPL was not distributed with this
7  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
8  *
9  * This code has not been reviewed.
10  * Do not use or deploy this code before reviewing it personally first.
11  */
12 
13 
14 interface ERC777Token {
15   function name() external view returns (string);
16   function symbol() external view returns (string);
17   function totalSupply() external view returns (uint256);
18   function balanceOf(address owner) external view returns (uint256);
19   function granularity() external view returns (uint256);
20 
21   function defaultOperators() external view returns (address[]);
22   function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
23   function authorizeOperator(address operator) external;
24   function revokeOperator(address operator) external;
25 
26   function send(address to, uint256 amount, bytes holderData) external;
27   function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) external;
28 
29   function burn(uint256 amount, bytes holderData) external;
30   function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) external;
31 
32   event Sent(
33     address indexed operator,
34     address indexed from,
35     address indexed to,
36     uint256 amount,
37     bytes holderData,
38     bytes operatorData
39   );
40   event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);
41   event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);
42   event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
43   event RevokedOperator(address indexed operator, address indexed tokenHolder);
44 }
45 
46 // File: contracts/operators/DelegatedTransferOperatorV5GasOptimized.sol
47 
48 /// @title DelegatedTransferOperatorV5GasOptimized
49 /// @author Roger Wu (Roger-Wu)
50 /// @dev A DelegatedTransferOperator contract that has the following features:
51 ///   1. To prevent replay attack, we check if a _nonce has been used by a token holder.
52 ///   2. Minimize the gas by making functions inline and remove trivial event.
53 ///   3. Add `_userData`.
54 ///   4. Add function `batchTransferPreSigned` which does multiple delegated Transfers in one transaction.
55 ///   5. Support signature with "\x19Ethereum Signed Message:\n32" prefix
56 contract DelegatedTransferOperatorV5GasOptimized {
57   mapping(address => uint256) public usedNonce;
58   ERC777Token tokenContract = ERC777Token(0x67ab11058eF23D0a19178f61A050D3c38F81Ae21);
59 
60   /**
61     * @notice Submit a presigned transfer
62     * @param _to address The address which you want to transfer to.
63     * @param _delegate address The address which is allowed to send this transaction.
64     * @param _value uint256 The amount of tokens to be transferred.
65     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.
66     * @param _nonce uint256 Presigned transaction number.
67     * @param _userData bytes Data generated by the user to be sent to the recipient.
68     * @param _signedWithPrefix bool Whether "\x19Ethereum Signed Message:\n32" is prefixed
69     * @param _sig_r bytes32 The r of the signature.
70     * @param _sig_s bytes32 The s of the signature.
71     * @param _sig_v uint8 The v of the signature.
72     * @dev some rules:
73     * 1. If _to is address(0), the tx will fail when doSend().
74     * 2. If _delegate == address(0), then anyone can be the delegate.
75     * 3. _nonce must be greater than the last used nonce by the token holder,
76     *    but nonces don't have to be serial numbers.
77     *    We recommend using unix time as nonce.
78     * 4. _sig_v should be 27 or 28.
79     */
80   function transferPreSigned(
81     address _to,
82     address _delegate,
83     uint256 _value,
84     uint256 _fee,
85     uint256 _nonce,
86     bytes _userData,
87     bool _signedWithPrefix,
88     bytes32 _sig_r,
89     bytes32 _sig_s,
90     uint8 _sig_v
91   )
92     public
93   {
94     require(
95       _delegate == address(0) || _delegate == msg.sender,
96       "_delegate should be address(0) or msg.sender"
97     );
98 
99     // bytes32 _hash = transferPreSignedHashing(...);
100     bytes32 _hash = keccak256(
101       abi.encodePacked(
102         address(this),
103         _to,
104         _delegate,
105         _value,
106         _fee,
107         _nonce,
108         _userData
109       )
110     );
111     if (_signedWithPrefix) {
112       // _hash = toEthSignedMessageHash(_hash);
113       _hash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash));
114     }
115 
116     // address _signer = recoverVrs(_hash, _sig_v, _sig_r, _sig_s);
117     address _signer = (_sig_v != 27 && _sig_v != 28) ?
118       address(0) :
119       ecrecover(_hash, _sig_v, _sig_r, _sig_s);
120 
121     require(
122       _signer != address(0),
123       "_signature is invalid."
124     );
125 
126     require(
127       _nonce > usedNonce[_signer],
128       "_nonce must be greater than the last used nonce of the token holder."
129     );
130 
131     usedNonce[_signer] = _nonce;
132 
133     tokenContract.operatorSend(_signer, _to, _value, _userData, "");
134     if (_fee > 0) {
135       tokenContract.operatorSend(_signer, msg.sender, _fee, _userData, "");
136     }
137   }
138 }