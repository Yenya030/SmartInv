1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Crayzillas.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// Creator: 0xVinasaur\npragma solidity ^0.8.4;\n\n//                                             ╓▄▄▄\n//                                      ,▄██▄█▀    ▀█ ,╓▄██▄\n//                                     █▀    ╙█▄    ╟█▀     █╕\n//                                   ,█▌     ▄███████▀██▄   ▐█\n//                                 ╓█▀└▀███▀▀▀└░░░░░░░░ ╜▀█▄╫▌\n//                               ╓█▀ ░░░░░░░░░░░░░░░░░░░░░└███████▄\n//                             ╓█▀ ░░░░░░░░░░░░░░░░░░░░░░░░░▀█▄    █\n//                           ╓█▀ ░░░░░░░░░░░░░░░░░░░░░░░░░░░░╙█▄  ▄█\n//                         ,█▀███░░░░░░░░░░░░░░░░░░░░░░░░░░░░░╝█▄█▀\n//                        ,█▀░▀▀▀░░░░░░░░░░░░░.█▄░░░░░░░░░░░░░░██▀██╖\n//                        █▌░░░░░░░░░░░░░░░░░░╫██░░░░░░░░░░░░░░▐█   ╙█µ\n//                        █▒░░░░░██▄▄,▄█░░░░░░░'░░░░░░░░░░░░░░░░█▌   █▌\n//                        █▌░░░░░░└▀▀▀▀╙░░░░░░░░░░░░░░░░░░░░░░░░█▌▄██\n//                        ╙█▄░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████▄,\n//                         └██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░╫█   ╙█\n//                           ╙██▄░░░░░░░░░░░░░,███░░░░░░░░░░░░░░╙█    █\n//                             ▄█████▄▄▄▄▄█████▀└░░░░░░░░░░██,░░░██ ▄█\n//                         ,████▀░░├█╫▀▀▀▀▀╙.░░░░░╓█░░░░░░░░╟██ ░╙███▄,\n//                       ╓█▀╟████▀▀▀╙╙▀▀▀███ ░░░░░█▌░░░░░░░░░░▀█▌░║█▌  ▀█\n//                      █▀░███             ╙██▄░░░█▌░░░░░░░░░░░╙█▌░╫█   █▌\n//                     █▌░█▀ ╙▀██▄▄,,,,,▄▄██▀▀██░░╙█▌░░░░░░░░░░░╟█░░██▄█▀\n//          ,,,,   ,,,,█▌█▌   ,,   ╟█▀╙╙╠▄ ,,,▄██▄▄,███▄▄▄░░░,▄▄██▌░╙████▄      ,,,,\n//       ╓███▀▀▀████▀▀▀███▄ ████████▀████▀██▀▀▀▀▀▀██████▀█████████▌░░╫██████ ,███▀▀███\n//      ██▀  ,,   █   ,  ╟███▌  ╙██▄  ▀▀  ╫▌▄▄▄,  ,█  █▌ ▐████  ██▌░]██▌  ╙████  ,,,██▌\n//     ██▌ ╒██▀████  ╙▀  ▐██▌    ╙███   ,█████▀  ▄██  █▌ ▐████  ██▌.██▌    ╙███  ╙▀███\n//     ██▌ └██▄████  ,  ███▌  ▀▀  ╙███  █████  ╓████  █▌ ▐████  █████▌  ▀▀  ╙████▄  ╙██\n//      ██▄  `╙╙  █  ╟█  ╫▌  ▄▄▄▄  ╚██  ███▀   ╙╙╙╙█  █▌  ╙╙▀█  `╙╙▀▌  ▄▄▄▄  ╨█  ╙  ▄█▌\n//       ╙████▄███████████████▀▀████████████████████████████████████████▀▀███████████▀\n\ninterface IStateSender {\n    function syncState(address receiver, bytes calldata data) external;\n}\n\n/**\n@dev To enable cross-chain coloring with Polygon, and dedicated immutable metadata for Traits \n */\nabstract contract ERCColorable {\n    string internal traitMetadataURI;\n    string internal traitMetadataURI_EXT; // optional\n    IStateSender internal _stateSender;\n    address internal _childStateReceiver;\n    bool internal _isStateSenderSet;\n\n    /**\n     * @dev Sets a new value for the trait metadata URI\n     */\n    function _setTraitMetadataURI(string memory uri_) internal virtual {\n        traitMetadataURI = uri_;\n    }\n\n    /**\n     * @dev Sets a new value for the metadata file extension\n     eg: \".json\"\n     */\n    function _setTraitMetadataURI_EXT(string memory ext_) internal virtual {\n        traitMetadataURI_EXT = ext_;\n    }\n\n    /**\n    * @dev Sets the StateSender on ETH that will propagate state to Polygon\n    */\n    function _setStateSender(address newStateSender) internal {\n        require(newStateSender != address(0), \"ERCColorablew: Invalid State Sender\");\n        _isStateSenderSet = true;\n        _stateSender = IStateSender(newStateSender);\n    }\n\n    /**\n    * @dev Sets the address on Polygon that will receive state from ETH\n    */\n    function _setChildStateReceiver(address newChildStateReceiver) internal {\n        require(newChildStateReceiver != address(0), \"ERCColorable: Invalid child state receiver\");\n        _childStateReceiver = newChildStateReceiver;\n    }\n}\n\n// Forked from ERC721I by 0xInuarashi\ncontract ERC721C is ERCColorable {\n    string public name;\n    string public symbol;\n    string internal baseTokenURI;\n    string internal baseTokenURI_EXT;\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    uint256 public totalSupply;\n    mapping(uint256 => address) public ownerOf;\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    // Events\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    // // internal write functions\n    // mint\n    function _mint(address to_, uint256 tokenId_) internal virtual {\n        require(to_ != address(0x0), \"ERC721C: _mint() Mint to Zero Address\");\n        require(\n            ownerOf[tokenId_] == address(0x0),\n            \"ERC721C: _mint() Token to Mint Already Exists!\"\n        );\n\n        balanceOf[to_]++;\n        ownerOf[tokenId_] = to_;\n\n        emit Transfer(address(0x0), to_, tokenId_);\n    }\n\n    // transfer\n    function _transfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual {\n        require(\n            from_ == ownerOf[tokenId_],\n            \"ERC721C: _transfer() Transfer Not Owner of Token!\"\n        );\n        require(\n            to_ != address(0x0),\n            \"ERC721C: _transfer() Transfer to Zero Address!\"\n        );\n\n        // checks if there is an approved address clears it if there is\n        if (getApproved[tokenId_] != address(0x0)) {\n            _approve(address(0x0), tokenId_);\n        }\n\n        ownerOf[tokenId_] = to_;\n        balanceOf[from_]--;\n        balanceOf[to_]++;\n\n        emit Transfer(from_, to_, tokenId_);\n    }\n\n    // approve\n    function _approve(address to_, uint256 tokenId_) internal virtual {\n        if (getApproved[tokenId_] != to_) {\n            getApproved[tokenId_] = to_;\n            emit Approval(ownerOf[tokenId_], to_, tokenId_);\n        }\n    }\n\n    function _setApprovalForAll(\n        address owner_,\n        address operator_,\n        bool approved_\n    ) internal virtual {\n        require(\n            owner_ != operator_,\n            \"ERC721C: _setApprovalForAll() Owner must not be the Operator!\"\n        );\n        isApprovedForAll[owner_][operator_] = approved_;\n        emit ApprovalForAll(owner_, operator_, approved_);\n    }\n\n    // token uri\n    function _setBaseTokenURI(string memory uri_) internal virtual {\n        baseTokenURI = uri_;\n    }\n\n    function _setBaseTokenURI_EXT(string memory ext_) internal virtual {\n        baseTokenURI_EXT = ext_;\n    }\n\n    // // Internal View Functions\n    // Embedded Libraries\n    function _toString(uint256 value_) internal pure returns (string memory) {\n        if (value_ == 0) {\n            return \"0\";\n        }\n        uint256 _iterate = value_;\n        uint256 _digits;\n        while (_iterate != 0) {\n            _digits++;\n            _iterate /= 10;\n        } // get digits in value_\n        bytes memory _buffer = new bytes(_digits);\n        while (value_ != 0) {\n            _digits--;\n            _buffer[_digits] = bytes1(uint8(48 + uint256(value_ % 10)));\n            value_ /= 10;\n        } // create bytes of value_\n        return string(_buffer); // return string converted bytes of value_\n    }\n\n    // Functional Views\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            ownerOf[tokenId_] != address(0x0),\n            \"ERC721C: _isApprovedOrOwner() Owner is Zero Address!\"\n        );\n        address _owner = ownerOf[tokenId_];\n        return (spender_ == _owner ||\n            spender_ == getApproved[tokenId_] ||\n            isApprovedForAll[_owner][spender_]);\n    }\n\n    // // public write functions\n    function approve(address to_, uint256 tokenId_) public virtual {\n        address _owner = ownerOf[tokenId_];\n        require(to_ != _owner, \"ERC721C: approve() Cannot approve yourself!\");\n        require(\n            msg.sender == _owner || isApprovedForAll[_owner][msg.sender],\n            \"ERC721C: Caller not owner or Approved!\"\n        );\n        _approve(to_, tokenId_);\n    }\n\n    function setApprovalForAll(address operator_, bool approved_)\n        public\n        virtual\n    {\n        _setApprovalForAll(msg.sender, operator_, approved_);\n    }\n\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId_),\n            \"ERC721C: transferFrom() _isApprovedOrOwner = false!\"\n        );\n        _transfer(from_, to_, tokenId_);\n        // send data to the child chain\n        if (_isStateSenderSet) {\n            bytes memory syncData = abi.encode(address(this), tokenId_, to_);\n            _stateSender.syncState(\n                address(_childStateReceiver),\n                abi.encode(syncData)\n            );\n        }\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) public virtual {\n        transferFrom(from_, to_, tokenId_);\n        if (to_.code.length != 0) {\n            (, bytes memory _returned) = to_.staticcall(\n                abi.encodeWithSelector(\n                    0x150b7a02,\n                    msg.sender,\n                    from_,\n                    tokenId_,\n                    data_\n                )\n            );\n            bytes4 _selector = abi.decode(_returned, (bytes4));\n            require(\n                _selector == 0x150b7a02,\n                \"ERC721C: safeTransferFrom() to_ not ERC721Receivable!\"\n            );\n        }\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual {\n        safeTransferFrom(from_, to_, tokenId_, \"\");\n    }\n\n    // 0xInuarashi Custom Functions\n    function multiTransferFrom(\n        address from_,\n        address to_,\n        uint256[] memory tokenIds_\n    ) public virtual {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            transferFrom(from_, to_, tokenIds_[i]);\n        }\n    }\n\n    function multiSafeTransferFrom(\n        address from_,\n        address to_,\n        uint256[] memory tokenIds_,\n        bytes memory data_\n    ) public virtual {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            safeTransferFrom(from_, to_, tokenIds_[i], data_);\n        }\n    }\n\n    // OZ Standard Stuff\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\n        return (interfaceId_ == 0x80ac58cd || interfaceId_ == 0x5b5e139f);\n    }\n\n    function tokenURI(uint256 tokenId_)\n        public\n        view\n        virtual\n        returns (string memory)\n    {\n        require(\n            ownerOf[tokenId_] != address(0x0),\n            \"ERC721C: tokenURI() Token does not exist!\"\n        );\n        return\n            string(\n                abi.encodePacked(\n                    baseTokenURI,\n                    _toString(tokenId_),\n                    baseTokenURI_EXT\n                )\n            );\n    }\n\n    function tokenTraitURI(uint256 tokenId_)\n        public\n        view\n        virtual\n        returns (string memory)\n    {\n        require(\n            ownerOf[tokenId_] != address(0x0),\n            \"ERC721C: tokenTraitURI() Token does not exist!\"\n        );\n        return\n            string(\n                abi.encodePacked(\n                    traitMetadataURI,\n                    _toString(tokenId_),\n                    traitMetadataURI_EXT\n                )\n            );\n    }\n\n    // public view functions\n    function balance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // never use these for functions ever, they are expensive af and for view only\n    function walletOfOwner(address address_)\n        public\n        view\n        virtual\n        returns (uint256[] memory)\n    {\n        uint256 _balance = balanceOf[address_];\n        uint256[] memory _tokens = new uint256[](_balance);\n        uint256 _index;\n        uint256 _loopThrough = totalSupply;\n        for (uint256 i = 0; i < _loopThrough; i++) {\n            if (ownerOf[i] == address(0x0) && _tokens[_balance - 1] == 0) {\n                _loopThrough++;\n            }\n            if (ownerOf[i] == address_) {\n                _tokens[_index] = i;\n                _index++;\n            }\n        }\n        return _tokens;\n    }\n\n    // not sure when this will ever be needed but it conforms to erc721 enumerable\n    function tokenOfOwnerByIndex(address address_, uint256 index_)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256[] memory _wallet = walletOfOwner(address_);\n        return _wallet[index_];\n    }\n\n     function exists(uint256 tokenId_) public view virtual returns (bool) {\n        return ownerOf[tokenId_] != address(0x0);\n    }\n}\n\n// Open0x Ownable (by 0xInuarashi)\nabstract contract Ownable {\n    address public owner;\n    event OwnershipTransferred(\n        address indexed oldOwner_,\n        address indexed newOwner_\n    );\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function _onlyOwner() internal view {\n      require(owner == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    function _transferOwnership(address newOwner_) internal virtual {\n        address _oldOwner = owner;\n        owner = newOwner_;\n        emit OwnershipTransferred(_oldOwner, newOwner_);\n    }\n\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\n        require(\n            newOwner_ != address(0x0),\n            \"Ownable: new owner is the zero address!\"\n        );\n        _transferOwnership(newOwner_);\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0x0));\n    }\n}\n\nabstract contract MerkleAllowlist {\n    bytes32 internal _merkleAllowlistRoot;\n\n    function _setAllowlistMerkleRoot(bytes32 merkleRoot_) internal virtual {\n        _merkleAllowlistRoot = merkleRoot_;\n    }\n\n    function isAllowlisted(address address_, bytes32[] memory proof_)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\n        for (uint256 i = 0; i < proof_.length; i++) {\n            _leaf = _leaf < proof_[i]\n                ? keccak256(abi.encodePacked(_leaf, proof_[i]))\n                : keccak256(abi.encodePacked(proof_[i], _leaf));\n        }\n        return _leaf == _merkleAllowlistRoot;\n    }\n}\n\nabstract contract MerklePubRaffle {\n    bytes32 internal _merklePubRaffleRoot;\n\n    function _setPubRaffleMerkleRoot(bytes32 merkleRoot_) internal virtual {\n        _merklePubRaffleRoot = merkleRoot_;\n    }\n\n    function isPubRaffleListed(address address_, bytes32[] memory proof_)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\n        for (uint256 i = 0; i < proof_.length; i++) {\n            _leaf = _leaf < proof_[i]\n                ? keccak256(abi.encodePacked(_leaf, proof_[i]))\n                : keccak256(abi.encodePacked(proof_[i], _leaf));\n        }\n        return _leaf == _merklePubRaffleRoot;\n    }\n}\n\nabstract contract AllowlistMint {\n    // Allowlist Minting\n    bool internal _allowlistMintEnabled;\n    uint256 public _allowlistMintTime;\n\n    function _setAllowlistMint(bool bool_, uint256 time_) internal {\n        _allowlistMintEnabled = bool_;\n        _allowlistMintTime = time_;\n    }\n\n    function _isAllowlistMintEnabled() internal view {\n      require(\n            _allowlistMintEnabled && _allowlistMintTime <= block.timestamp,\n            \"Allowlist Mint is not enabled yet!\"\n        );\n    }\n\n    modifier allowlistMintEnabled() {\n        _isAllowlistMintEnabled();\n        _;\n    }\n\n    function allowlistMintStatus() external view returns (bool) {\n        return _allowlistMintEnabled && _allowlistMintTime <= block.timestamp;\n    }\n}\n\nabstract contract PubRaffleMint {\n    // Public Raffle Minting\n    bool internal _pubRaffleMintEnabled;\n    uint256 public _pubRaffleMintTime;\n\n    function _setPubRaffleMint(bool bool_, uint256 time_) internal {\n        _pubRaffleMintEnabled = bool_;\n        _pubRaffleMintTime = time_;\n    }\n\n    function _isPubRaffleMintEnabled() internal view {\n      require(\n            _pubRaffleMintEnabled && _pubRaffleMintTime <= block.timestamp,\n            \"Public Raffle Mint is not enabled yet!\"\n        );\n    }\n\n    modifier pubRaffleMintEnabled() {\n        _isPubRaffleMintEnabled();\n        _;\n    }\n\n    function pubRaffleMintStatus() external view returns (bool) {\n        return _pubRaffleMintEnabled && _pubRaffleMintTime <= block.timestamp;\n    }\n}\n\nabstract contract PublicMint {\n    // Public Minting\n    bool public _publicMintEnabled;\n    uint256 public _publicMintTime;\n\n    function _setPublicMint(bool bool_, uint256 time_) internal {\n        _publicMintEnabled = bool_;\n        _publicMintTime = time_;\n    }\n\n    function _isPublicMintEnabled() internal view {\n      require(\n            _publicMintEnabled && _publicMintTime <= block.timestamp,\n            \"Public Mint is not enabled yet!\"\n        );\n    }\n\n    modifier publicMintEnabled() {\n        _isPublicMintEnabled();\n        _;\n    }\n\n    function publicMintStatus() external view returns (bool) {\n        return _publicMintEnabled && _publicMintTime <= block.timestamp;\n    }\n}\n\nabstract contract Security {\n    function _onlySender() internal view {\n      require(msg.sender == tx.origin, \"No Smart Contracts!\");\n    }\n\n    // Prevent Smart Contracts\n    modifier onlySender() {\n        _onlySender();\n        _;\n    }\n}\n\ncontract Crayzillas is\n    ERC721C,\n    Ownable,\n    MerkleAllowlist,\n    MerklePubRaffle,\n    AllowlistMint,\n    PubRaffleMint,\n    PublicMint,\n    Security\n{\n    // Constructor\n    constructor() payable ERC721C(\"Crayzillas\", \"CRAY\") {}\n\n    // Project Constraints\n    uint256 public mintPrice = 0.077 ether;\n    uint256 public maxSupply = 7777;\n\n    string public crayzillasProvenance;\n\n    // Public Limits\n    uint256 public maxMintsPerPublic = 2; \n    mapping(address => uint256) public addressToPublicMints;\n\n    // Allowlist Limits\n    uint256 public maxMintsPerAllowlist = 2; \n    mapping(address => uint256) public addressToAllowlistMints;\n\n    // PubRaffle Limits\n    uint256 public maxMintsPerPubRaffle = 2; \n    mapping(address => uint256) public addressToPubRaffleMints;\n\n    // Administrative Functions\n    function setMintPrice(uint256 mintPrice_) external onlyOwner {\n        mintPrice = mintPrice_;\n    }\n\n    function setMaxSupply(uint256 maxSupply_) external onlyOwner {\n        maxSupply = maxSupply_;\n    }\n\n    // Public, PubRaffle, and Allowlist Mint Limits\n    function setMaxMintsPerPublic(uint256 maxMintsPerPublic_)\n        external\n        onlyOwner\n    {\n        maxMintsPerPublic = maxMintsPerPublic_;\n    }\n\n    function setMaxMintsPerPubRaffle(uint256 maxMintsPerPubRaffle_) external onlyOwner {\n        maxMintsPerPubRaffle = maxMintsPerPubRaffle_;\n    }\n\n    function setMaxMintsPerAllowlist(uint256 maxMintsPerAllowlist_) external onlyOwner {\n        maxMintsPerAllowlist = maxMintsPerAllowlist_;\n    }\n\n    // Token URI\n    function setBaseTokenURI(string calldata uri_) external onlyOwner {\n        _setBaseTokenURI(uri_);\n    }\n\n    function setBaseTokenURI_EXT(string calldata ext_) external onlyOwner {\n        _setBaseTokenURI_EXT(ext_);\n    }\n\n    // Allowlist MerkleRoot\n    function setAllowlistMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\n        _setAllowlistMerkleRoot(merkleRoot_);\n    }\n\n    // Public Raffle MerkleRoot\n    function setPubRaffleMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\n        _setPubRaffleMerkleRoot(merkleRoot_);\n    }\n\n    // Public Mint\n    function setPublicMint(bool bool_, uint256 time_) external onlyOwner {\n        _setPublicMint(bool_, time_);\n    }\n\n    // Allowlist Mint\n    function setAllowlistMint(bool bool_, uint256 time_) external onlyOwner {\n        _setAllowlistMint(bool_, time_);\n    }\n\n    // Public Raffle Mint\n    function setPubRaffleMint(bool bool_, uint256 time_) external onlyOwner {\n        _setPubRaffleMint(bool_, time_);\n    }\n\n    function setProvenanceHash(string memory provenanceHash_) external onlyOwner {\n        crayzillasProvenance = provenanceHash_;\n    }\n\n    function setStateSender(address newStateSender) external onlyOwner {\n        _setStateSender(newStateSender);\n    }\n\n    function setChildReceiver(address newChildStateReceiver) external onlyOwner {\n        _setChildStateReceiver(newChildStateReceiver);\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(payable(address(this)).balance);\n    }\n\n    // Internal Functions\n    function _mintMany(address to_, uint256 amount_) internal {\n        require(\n            maxSupply >= totalSupply + amount_,\n            \"Not enough Crayzillas remaining!\"\n        );\n\n        uint256 _startId = totalSupply + 1; // iterate from 1\n\n        for (uint256 i = 0; i < amount_; i++) {\n            _mint(to_, _startId + i);\n        }\n\n        totalSupply += amount_;\n    }\n\n    // Owner Mint\n    function ownerMint(address[] calldata tos_, uint256[] calldata amounts_)\n        external\n        onlyOwner\n    {\n        require(tos_.length == amounts_.length, \"Array lengths mismatch!\");\n\n        for (uint256 i = 0; i < tos_.length; i++) {\n            _mintMany(tos_[i], amounts_[i]);\n        }\n    }\n\n    // Allowlist Mint\n    function allowlistMint(bytes32[] calldata proof_, uint256 amount_)\n        external\n        payable\n        onlySender\n        allowlistMintEnabled\n    {\n        require(isAllowlisted(msg.sender, proof_), \"You are not allowlisted!\");\n        require(\n            maxMintsPerAllowlist >= addressToAllowlistMints[msg.sender] + amount_,\n            \"You don't have enough waxlist mints!\"\n        );\n        require(msg.value == mintPrice * amount_, \"Invalid value sent!\");\n\n        // Add address to WL minted\n        addressToAllowlistMints[msg.sender] += amount_;\n\n        // Now, mint to msg.sender\n        _mintMany(msg.sender, amount_);\n    }\n\n    // Public Raffle Mint\n    function pubRaffleMint(bytes32[] calldata proof_, uint256 amount_)\n        external\n        payable\n        onlySender\n        allowlistMintEnabled\n    {\n        require(isPubRaffleListed(msg.sender, proof_), \"You have not won a public raffle mint allocation!\");\n        require(\n            maxMintsPerPubRaffle >= addressToPubRaffleMints[msg.sender] + amount_,\n            \"You don't have enough public raffle mints!\"\n        );\n        require(msg.value == mintPrice * amount_, \"Invalid value sent!\");\n\n        // Add address to pub raffle minted\n        addressToPubRaffleMints[msg.sender] += amount_;\n\n        // Now, mint to msg.sender\n        _mintMany(msg.sender, amount_);\n    }\n\n    // Public Mint\n    function publicMint(uint256 amount_)\n        external\n        payable\n        onlySender\n        publicMintEnabled\n    {\n        require(\n            maxMintsPerPublic >= addressToPublicMints[msg.sender] + amount_,\n            \"You don't have enough Public Mints!\"\n        );\n        require(msg.value == mintPrice * amount_, \"Invalid value sent!\");\n\n        // Add address to Public Mints\n        addressToPublicMints[msg.sender] += amount_;\n\n        // Now, mint to msg.sender\n        _mintMany(msg.sender, amount_);\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": false,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}