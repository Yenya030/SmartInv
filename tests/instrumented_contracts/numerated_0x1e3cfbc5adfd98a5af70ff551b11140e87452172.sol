1 {{
2   "language": "Solidity",
3   "sources": {
4     "cache/solpp-generated-contracts/Proxy.sol": {
5       "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\nimport \"./Ownable.sol\";\nimport \"./Upgradeable.sol\";\nimport \"./UpgradeableMaster.sol\";\n\n/// @title Proxy Contract\n/// @dev NOTICE: Proxy must implement UpgradeableMaster interface to prevent calling some function of it not by master of proxy\n/// @author Matter Labs\ncontract Proxy is Upgradeable, UpgradeableMaster, Ownable {\n    /// @dev Storage position of \"target\" (actual implementation address: keccak256('eip1967.proxy.implementation') - 1)\n    bytes32 private constant targetPosition = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @notice Contract constructor\n    /// @dev Calls Ownable contract constructor and initialize target\n    /// @param target Initial implementation address\n    /// @param targetInitializationParameters Target initialization parameters\n    constructor(address target, bytes memory targetInitializationParameters) Ownable(msg.sender) {\n        setTarget(target);\n        (bool initializationSuccess, ) =\n        getTarget().delegatecall(abi.encodeWithSignature(\"initialize(bytes)\", targetInitializationParameters));\n        require(initializationSuccess, \"uin11\"); // uin11 - target initialization failed\n    }\n\n    /// @notice Intercepts initialization calls\n    function initialize(bytes calldata) external pure {\n        revert(\"ini11\"); // ini11 - interception of initialization call\n    }\n\n    /// @notice Intercepts upgrade calls\n    function upgrade(bytes calldata) external pure {\n        revert(\"upg11\"); // upg11 - interception of upgrade call\n    }\n\n    /// @notice Returns target of contract\n    /// @return target Actual implementation address\n    function getTarget() public view returns (address target) {\n        bytes32 position = targetPosition;\n        assembly {\n            target := sload(position)\n        }\n    }\n\n    /// @notice Sets new target of contract\n    /// @param _newTarget New actual implementation address\n    function setTarget(address _newTarget) internal {\n        bytes32 position = targetPosition;\n        assembly {\n            sstore(position, _newTarget)\n        }\n    }\n\n    /// @notice Upgrades target\n    /// @param newTarget New target\n    /// @param newTargetUpgradeParameters New target upgrade parameters\n    function upgradeTarget(address newTarget, bytes calldata newTargetUpgradeParameters) external override {\n        requireMaster(msg.sender);\n\n        setTarget(newTarget);\n        (bool upgradeSuccess, ) =\n        getTarget().delegatecall(abi.encodeWithSignature(\"upgrade(bytes)\", newTargetUpgradeParameters));\n        require(upgradeSuccess, \"ufu11\"); // ufu11 - target upgrade failed\n    }\n\n    /// @notice Performs a delegatecall to the contract implementation\n    /// @dev Fallback function allowing to perform a delegatecall to the given implementation\n    /// This function will return whatever the implementation call returns\n    function _fallback() internal {\n        address _target = getTarget();\n        assembly {\n            // The pointer to the free memory slot\n            let ptr := mload(0x40)\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(ptr, 0x0, calldatasize())\n            // Delegatecall method of the implementation contract, returns 0 on error\n            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(ptr, 0x0, size)\n            // Depending on result value\n            switch result\n                case 0 {\n                    // End execution and revert state changes\n                    revert(ptr, size)\n                }\n                default {\n                    // Return data with length of size at pointers position\n                    return(ptr, size)\n                }\n        }\n    }\n\n    /// @notice Will run when no functions matches call data\n    fallback() external payable {\n        _fallback();\n    }\n\n    /// @notice Same as fallback but called when calldata is empty\n    receive() external payable {\n        _fallback();\n    }\n\n    /// UpgradeableMaster functions\n    /// @notice Notice period before activation preparation status of upgrade mode\n    function getNoticePeriod() external override returns (uint256) {\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\"getNoticePeriod()\"));\n        require(success, \"unp11\"); // unp11 - upgradeNoticePeriod delegatecall failed\n        return abi.decode(result, (uint256));\n    }\n\n    /// @notice Notifies proxy contract that notice period started\n    function upgradeNoticePeriodStarted() external override {\n        requireMaster(msg.sender);\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\"upgradeNoticePeriodStarted()\"));\n        require(success, \"nps11\"); // nps11 - upgradeNoticePeriodStarted delegatecall failed\n    }\n\n    /// @notice Notifies proxy contract that upgrade preparation status is activated\n    function upgradePreparationStarted() external override {\n        requireMaster(msg.sender);\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\"upgradePreparationStarted()\"));\n        require(success, \"ups11\"); // ups11 - upgradePreparationStarted delegatecall failed\n    }\n\n    /// @notice Notifies proxy contract that upgrade canceled\n    function upgradeCanceled() external override {\n        requireMaster(msg.sender);\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\"upgradeCanceled()\"));\n        require(success, \"puc11\"); // puc11 - upgradeCanceled delegatecall failed\n    }\n\n    /// @notice Notifies proxy contract that upgrade finishes\n    function upgradeFinishes() external override {\n        requireMaster(msg.sender);\n        (bool success, ) = getTarget().delegatecall(abi.encodeWithSignature(\"upgradeFinishes()\"));\n        require(success, \"puf11\"); // puf11 - upgradeFinishes delegatecall failed\n    }\n\n    /// @notice Checks that contract is ready for upgrade\n    /// @return bool flag indicating that contract is ready for upgrade\n    function isReadyForUpgrade() external override returns (bool) {\n        (bool success, bytes memory result) = getTarget().delegatecall(abi.encodeWithSignature(\"isReadyForUpgrade()\"));\n        require(success, \"rfu11\"); // rfu11 - readyForUpgrade delegatecall failed\n        return abi.decode(result, (bool));\n    }\n}\n"
6     },
7     "cache/solpp-generated-contracts/Ownable.sol": {
8       "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title Ownable Contract\n/// @author Matter Labs\n// NO CHANGE\ncontract Ownable {\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\n    bytes32 private constant masterPosition = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @notice Contract constructor\n    /// @dev Sets msg sender address as masters address\n    /// @param masterAddress Master address\n    constructor(address masterAddress) {\n        setMaster(masterAddress);\n    }\n\n    /// @notice Check if specified address is master\n    /// @param _address Address to check\n    function requireMaster(address _address) internal view {\n        require(_address == getMaster(), \"1c\"); // oro11 - only by master\n    }\n\n    /// @notice Returns contract masters address\n    /// @return master Master's address\n    function getMaster() public view returns (address master) {\n        bytes32 position = masterPosition;\n        assembly {\n            master := sload(position)\n        }\n    }\n\n    /// @dev Sets new masters address\n    /// @param _newMaster New master's address\n    function setMaster(address _newMaster) internal {\n        bytes32 position = masterPosition;\n        assembly {\n            sstore(position, _newMaster)\n        }\n    }\n\n    /// @notice Transfer mastership of the contract to new master\n    /// @param _newMaster New masters address\n    function transferMastership(address _newMaster) external {\n        requireMaster(msg.sender);\n        require(_newMaster != address(0), \"1d\"); // otp11 - new masters address can't be zero address\n        setMaster(_newMaster);\n    }\n}\n"
9     },
10     "cache/solpp-generated-contracts/Upgradeable.sol": {
11       "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title Interface of the upgradeable contract\n/// @author Matter Labs\ninterface Upgradeable {\n    /// @notice Upgrades target of upgradeable contract\n    /// @param newTarget New target\n    /// @param newTargetInitializationParameters New target initialization parameters\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\n}\n"
12     },
13     "cache/solpp-generated-contracts/UpgradeableMaster.sol": {
14       "content": "pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\n/// @author Matter Labs\ninterface UpgradeableMaster {\n    /// @notice Notice period before activation preparation status of upgrade mode\n    function getNoticePeriod() external returns (uint256);\n\n    /// @notice Notifies contract that notice period started\n    function upgradeNoticePeriodStarted() external;\n\n    /// @notice Notifies contract that upgrade preparation status is activated\n    function upgradePreparationStarted() external;\n\n    /// @notice Notifies contract that upgrade canceled\n    function upgradeCanceled() external;\n\n    /// @notice Notifies contract that upgrade finishes\n    function upgradeFinishes() external;\n\n    /// @notice Checks that contract is ready for upgrade\n    /// @return bool flag indicating that contract is ready for upgrade\n    function isReadyForUpgrade() external returns (bool);\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     },
34     "libraries": {}
35   }
36 }}