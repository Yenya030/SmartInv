1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 800
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "@openzeppelin/contracts/access/Ownable.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
31     },
32     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
34     },
35     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
37     },
38     "@openzeppelin/contracts/utils/Context.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
40     },
41     "contracts/SingleSidedInsurancePool.sol": {
42       "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ICapitalAgent.sol\";\nimport \"./interfaces/IExchangeAgent.sol\";\nimport \"./interfaces/IMigration.sol\";\nimport \"./interfaces/IRewarderFactory.sol\";\nimport \"./interfaces/IRiskPoolFactory.sol\";\nimport \"./interfaces/ISingleSidedInsurancePool.sol\";\nimport \"./interfaces/IRewarder.sol\";\nimport \"./interfaces/IRiskPool.sol\";\nimport \"./interfaces/ISyntheticSSIPFactory.sol\";\nimport \"./libraries/TransferHelper.sol\";\n\ncontract SingleSidedInsurancePool is ISingleSidedInsurancePool, ReentrancyGuard, Ownable {\n    address public claimAssessor;\n    address private exchangeAgent;\n    address public migrateTo;\n    address public capitalAgent;\n    address public syntheticSSIP;\n\n    uint256 public LOCK_TIME = 10 days;\n    uint256 public constant ACC_UNO_PRECISION = 1e18;\n    uint256 public STAKING_START_TIME;\n\n    address public rewarder;\n    address public override riskPool;\n    struct PoolInfo {\n        uint128 lastRewardBlock;\n        uint128 accUnoPerShare;\n        uint256 unoMultiplierPerBlock;\n    }\n\n    struct UserInfo {\n        uint256 lastWithdrawTime;\n        uint256 rewardDebt;\n        uint256 amount;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n\n    PoolInfo public poolInfo;\n\n    event RiskPoolCreated(address indexed _SSIP, address indexed _pool);\n    event StakedInPool(address indexed _staker, address indexed _pool, uint256 _amount);\n    event LeftPool(address indexed _staker, address indexed _pool, uint256 _requestAmount);\n    event LogUpdatePool(uint128 _lastRewardBlock, uint256 _lpSupply, uint256 _accUnoPerShare);\n    event Harvest(address indexed _user, address indexed _receiver, uint256 _amount);\n    event LogSetExchangeAgent(address indexed _exchangeAgent);\n    event LogLeaveFromPendingSSIP(\n        address indexed _user,\n        address indexed _riskPool,\n        uint256 _withdrawLpAmount,\n        uint256 _withdrawUnoAmount\n    );\n    event PolicyClaim(address indexed _user, uint256 _claimAmount);\n    event LogLpTransferInSSIP(address indexed _from, address indexed _to, uint256 _amount);\n    event LogCreateRewarder(address indexed _SSIP, address indexed _rewarder, address _currency);\n    event LogCreateSyntheticSSIP(address indexed _SSIP, address indexed _syntheticSSIP, address indexed _lpToken);\n    event LogCancelWithdrawRequest(address indexed _user, uint256 _cancelAmount, uint256 _cancelAmountInUno);\n    event LogMigrate(address indexed _user, address indexed _migrateTo, uint256 _migratedAmount);\n    event LogSetCapitalAgent(address indexed _SSIP, address indexed _capitalAgent);\n    event LogSetRewardMultiplier(address indexed _SSIP, uint256 _rewardPerBlock);\n    event LogSetClaimAssessor(address indexed _SSIP, address indexed _claimAssessor);\n    event LogSetMigrateTo(address indexed _SSIP, address indexed _migrateTo);\n    event LogSetMinLPCapital(address indexed _SSIP, uint256 _minLPCapital);\n    event LogSetLockTime(address indexed _SSIP, uint256 _lockTime);\n    event LogSetStakingStartTime(address indexed _SSIP, uint256 _startTime);\n\n    constructor(\n        address _claimAssessor,\n        address _exchangeAgent,\n        address _capitalAgent,\n        address _multiSigWallet\n    ) {\n        require(_claimAssessor != address(0), \"UnoRe: zero claimAssessor address\");\n        require(_exchangeAgent != address(0), \"UnoRe: zero exchangeAgent address\");\n        require(_capitalAgent != address(0), \"UnoRe: zero capitalAgent address\");\n        require(_multiSigWallet != address(0), \"UnoRe: zero multisigwallet address\");\n        exchangeAgent = _exchangeAgent;\n        claimAssessor = _claimAssessor;\n        capitalAgent = _capitalAgent;\n        transferOwnership(_multiSigWallet);\n    }\n\n    modifier onlyClaimAssessor() {\n        require(msg.sender == claimAssessor, \"UnoRe: Forbidden\");\n        _;\n    }\n\n    modifier isStartTime() {\n        require(block.timestamp >= STAKING_START_TIME, \"UnoRe: not available time\");\n        _;\n    }\n\n    function setExchangeAgent(address _exchangeAgent) external onlyOwner {\n        require(_exchangeAgent != address(0), \"UnoRe: zero address\");\n        exchangeAgent = _exchangeAgent;\n        emit LogSetExchangeAgent(_exchangeAgent);\n    }\n\n    function setCapitalAgent(address _capitalAgent) external onlyOwner {\n        require(_capitalAgent != address(0), \"UnoRe: zero address\");\n        capitalAgent = _capitalAgent;\n        emit LogSetCapitalAgent(address(this), _capitalAgent);\n    }\n\n    function setRewardMultiplier(uint256 _rewardMultiplier) external onlyOwner {\n        require(_rewardMultiplier > 0, \"UnoRe: zero value\");\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\n        emit LogSetRewardMultiplier(address(this), _rewardMultiplier);\n    }\n\n    function setClaimAssessor(address _claimAssessor) external onlyOwner {\n        require(_claimAssessor != address(0), \"UnoRe: zero address\");\n        claimAssessor = _claimAssessor;\n        emit LogSetClaimAssessor(address(this), _claimAssessor);\n    }\n\n    function setMigrateTo(address _migrateTo) external onlyOwner {\n        require(_migrateTo != address(0), \"UnoRe: zero address\");\n        migrateTo = _migrateTo;\n        emit LogSetMigrateTo(address(this), _migrateTo);\n    }\n\n    function setMinLPCapital(uint256 _minLPCapital) external onlyOwner {\n        require(_minLPCapital > 0, \"UnoRe: not allow zero value\");\n        IRiskPool(riskPool).setMinLPCapital(_minLPCapital);\n        emit LogSetMinLPCapital(address(this), _minLPCapital);\n    }\n\n    function setLockTime(uint256 _lockTime) external onlyOwner {\n        require(_lockTime > 0, \"UnoRe: not allow zero lock time\");\n        LOCK_TIME = _lockTime;\n        emit LogSetLockTime(address(this), _lockTime);\n    }\n\n    function setStakingStartTime(uint256 _startTime) external onlyOwner {\n        STAKING_START_TIME = _startTime + block.timestamp;\n        emit LogSetStakingStartTime(address(this), STAKING_START_TIME);\n    }\n\n    /**\n     * @dev create Risk pool with UNO from SSIP owner\n     */\n    function createRiskPool(\n        string calldata _name,\n        string calldata _symbol,\n        address _factory,\n        address _currency,\n        uint256 _rewardMultiplier,\n        uint256 _SCR\n    ) external onlyOwner nonReentrant {\n        require(riskPool == address(0), \"UnoRe: risk pool created already\");\n        require(_factory != address(0), \"UnoRe: zero factory address\");\n        riskPool = IRiskPoolFactory(_factory).newRiskPool(_name, _symbol, address(this), _currency);\n        poolInfo.lastRewardBlock = uint128(block.number);\n        poolInfo.accUnoPerShare = 0;\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\n        ICapitalAgent(capitalAgent).addPool(address(this), _currency, _SCR);\n        emit RiskPoolCreated(address(this), riskPool);\n    }\n\n    function createRewarder(\n        address _operator,\n        address _factory,\n        address _currency\n    ) external onlyOwner nonReentrant {\n        require(_factory != address(0), \"UnoRe: rewarder factory no exist\");\n        require(_operator != address(0), \"UnoRe: zero operator address\");\n        rewarder = IRewarderFactory(_factory).newRewarder(_operator, _currency, address(this));\n        emit LogCreateRewarder(address(this), rewarder, _currency);\n    }\n\n    function createSyntheticSSIP(address _multiSigWallet, address _factory) external onlyOwner nonReentrant {\n        require(_multiSigWallet != address(0), \"UnoRe: zero owner address\");\n        require(_factory != address(0), \"UnoRe:zero factory address\");\n        require(riskPool != address(0), \"UnoRe:zero LP token address\");\n        syntheticSSIP = ISyntheticSSIPFactory(_factory).newSyntheticSSIP(_multiSigWallet, riskPool);\n        emit LogCreateSyntheticSSIP(address(this), syntheticSSIP, riskPool);\n    }\n\n    function migrate() external nonReentrant {\n        require(migrateTo != address(0), \"UnoRe: zero address\");\n        _harvest(msg.sender);\n        uint256 lpPrice = IRiskPool(riskPool).lpPriceUno();\n        uint256 amount = userInfo[msg.sender].amount;\n        bool isUnLocked = block.timestamp - userInfo[msg.sender].lastWithdrawTime > LOCK_TIME;\n        uint256 migratedAmount = IRiskPool(riskPool).migrateLP(msg.sender, migrateTo, isUnLocked);\n        ICapitalAgent(capitalAgent).SSIPPolicyCaim((amount * lpPrice) / 1e18, 0, false);\n        IMigration(migrateTo).onMigration(msg.sender, amount, \"\");\n        userInfo[msg.sender].amount = 0;\n        userInfo[msg.sender].rewardDebt = 0;\n        emit LogMigrate(msg.sender, migrateTo, migratedAmount);\n    }\n\n    function pendingUno(address _to) external view returns (uint256 pending) {\n        uint256 tokenSupply = IERC20(riskPool).totalSupply();\n        uint128 accUnoPerShare = poolInfo.accUnoPerShare;\n        if (block.number > poolInfo.lastRewardBlock && tokenSupply != 0) {\n            uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\n            uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\n            accUnoPerShare = accUnoPerShare + uint128((unoReward * ACC_UNO_PRECISION) / tokenSupply);\n        }\n        uint256 userBalance = userInfo[_to].amount;\n        pending = (userBalance * uint256(accUnoPerShare)) / ACC_UNO_PRECISION - userInfo[_to].rewardDebt;\n    }\n\n    function updatePool() public override {\n        if (block.number > poolInfo.lastRewardBlock) {\n            uint256 tokenSupply = IERC20(riskPool).totalSupply();\n            if (tokenSupply > 0) {\n                uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\n                uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\n                poolInfo.accUnoPerShare = poolInfo.accUnoPerShare + uint128(((unoReward * ACC_UNO_PRECISION) / tokenSupply));\n            }\n            poolInfo.lastRewardBlock = uint128(block.number);\n            emit LogUpdatePool(poolInfo.lastRewardBlock, tokenSupply, poolInfo.accUnoPerShare);\n        }\n    }\n\n    function enterInPool(uint256 _amount) external payable override isStartTime nonReentrant {\n        require(_amount != 0, \"UnoRe: ZERO Value\");\n        updatePool();\n        address token = IRiskPool(riskPool).currency();\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        if (token == address(0)) {\n            require(msg.value >= _amount, \"UnoRe: insufficient paid\");\n            if (msg.value > _amount) {\n                TransferHelper.safeTransferETH(msg.sender, msg.value - _amount);\n            }\n            TransferHelper.safeTransferETH(riskPool, _amount);\n        } else {\n            TransferHelper.safeTransferFrom(token, msg.sender, riskPool, _amount);\n        }\n        IRiskPool(riskPool).enter(msg.sender, _amount);\n        userInfo[msg.sender].rewardDebt =\n            userInfo[msg.sender].rewardDebt +\n            ((_amount * 1e18 * uint256(poolInfo.accUnoPerShare)) / lpPriceUno) /\n            ACC_UNO_PRECISION;\n        userInfo[msg.sender].amount = userInfo[msg.sender].amount + ((_amount * 1e18) / lpPriceUno);\n        ICapitalAgent(capitalAgent).SSIPStaking(_amount);\n        emit StakedInPool(msg.sender, riskPool, _amount);\n    }\n\n    /**\n     * @dev WR will be in pending for 10 days at least\n     */\n    function leaveFromPoolInPending(uint256 _amount) external override isStartTime nonReentrant {\n        _harvest(msg.sender);\n        require(ICapitalAgent(capitalAgent).checkCapitalByMCR(address(this), _amount), \"UnoRe: minimum capital underflow\");\n        // Withdraw desired amount from pool\n        uint256 amount = userInfo[msg.sender].amount;\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\n        require(amount - pendingAmount >= _amount * 1e18 / lpPriceUno, \"UnoRe: withdraw amount overflow\");\n        IRiskPool(riskPool).leaveFromPoolInPending(msg.sender, _amount);\n\n        userInfo[msg.sender].lastWithdrawTime = block.timestamp;\n        emit LeftPool(msg.sender, riskPool, _amount);\n    }\n\n    /**\n     * @dev user can submit claim again and receive his funds into his wallet after 10 days since last WR.\n     */\n    function leaveFromPending() external override isStartTime nonReentrant {\n        require(block.timestamp - userInfo[msg.sender].lastWithdrawTime >= LOCK_TIME, \"UnoRe: Locked time\");\n        _harvest(msg.sender);\n        uint256 amount = userInfo[msg.sender].amount;\n        (uint256 pendingAmount, , uint256 pendingAmountInUNO) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\n        ICapitalAgent(capitalAgent).SSIPWithdraw(pendingAmountInUNO);\n\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n        userInfo[msg.sender].rewardDebt =\n            accumulatedUno -\n            ((pendingAmount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n        (uint256 withdrawAmount, uint256 withdrawAmountInUNO) = IRiskPool(riskPool).leaveFromPending(msg.sender);\n        userInfo[msg.sender].amount = amount - withdrawAmount;\n        emit LogLeaveFromPendingSSIP(msg.sender, riskPool, withdrawAmount, withdrawAmountInUNO);\n    }\n\n    function lpTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override nonReentrant {\n        require(msg.sender == address(riskPool), \"UnoRe: not allow others transfer\");\n        if (_from != syntheticSSIP && _to != syntheticSSIP) {\n            _harvest(_from);\n            uint256 amount = userInfo[_from].amount;\n            (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(_from);\n            require(amount - pendingAmount >= _amount, \"UnoRe: balance overflow\");\n            uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n            userInfo[_from].rewardDebt = accumulatedUno - ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n            userInfo[_from].amount = amount - _amount;\n\n            userInfo[_to].rewardDebt =\n                userInfo[_to].rewardDebt +\n                ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\n            userInfo[_to].amount = userInfo[_to].amount + _amount;\n\n            emit LogLpTransferInSSIP(_from, _to, _amount);\n        }\n    }\n\n    function harvest(address _to) external override isStartTime nonReentrant {\n        _harvest(_to);\n    }\n\n    function _harvest(address _to) private {\n        updatePool();\n        uint256 amount = userInfo[_to].amount;\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\n        uint256 _pendingUno = accumulatedUno - userInfo[_to].rewardDebt;\n\n        // Effects\n        userInfo[msg.sender].rewardDebt = accumulatedUno;\n        uint256 rewardAmount = 0;\n\n        if (rewarder != address(0) && _pendingUno != 0) {\n            rewardAmount = IRewarder(rewarder).onReward(_to, _pendingUno);\n        }\n\n        emit Harvest(msg.sender, _to, rewardAmount);\n    }\n\n    function cancelWithdrawRequest() external nonReentrant {\n        (uint256 cancelAmount, uint256 cancelAmountInUno) = IRiskPool(riskPool).cancelWithrawRequest(msg.sender);\n        emit LogCancelWithdrawRequest(msg.sender, cancelAmount, cancelAmountInUno);\n    }\n\n    function policyClaim(\n        address _to,\n        uint256 _amount,\n        uint256 _policyId,\n        bool _isFinished\n    ) external onlyClaimAssessor isStartTime nonReentrant {\n        require(_to != address(0), \"UnoRe: zero address\");\n        require(_amount > 0, \"UnoRe: zero amount\");\n        uint256 realClaimAmount = IRiskPool(riskPool).policyClaim(_to, _amount);\n        ICapitalAgent(capitalAgent).SSIPPolicyCaim(realClaimAmount, _policyId, _isFinished);\n        emit PolicyClaim(_to, realClaimAmount);\n    }\n\n    function getStakedAmountPerUser(address _to) external view returns (uint256 unoAmount, uint256 lpAmount) {\n        lpAmount = userInfo[_to].amount;\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        unoAmount = (lpAmount * lpPriceUno) / 1e18;\n    }\n\n    /**\n     * @dev get withdraw request amount in pending per user in UNO\n     */\n    function getWithdrawRequestPerUser(address _user)\n        external\n        view\n        returns (\n            uint256 pendingAmount,\n            uint256 pendingAmountInUno,\n            uint256 originUnoAmount,\n            uint256 requestTime\n        )\n    {\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\n        (pendingAmount, requestTime, originUnoAmount) = IRiskPool(riskPool).getWithdrawRequest(_user);\n        pendingAmountInUno = (pendingAmount * lpPriceUno) / 1e18;\n    }\n\n    /**\n     * @dev get total withdraw request amount in pending for the risk pool in UNO\n     */\n    function getTotalWithdrawPendingAmount() external view returns (uint256) {\n        return IRiskPool(riskPool).getTotalWithdrawRequestAmount();\n    }\n}\n"
43     },
44     "contracts/interfaces/ICapitalAgent.sol": {
45       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface ICapitalAgent {\n    function addPool(\n        address _ssip,\n        address _currency,\n        uint256 _scr\n    ) external;\n\n    function setPolicy(address _policy) external;\n\n    function SSIPWithdraw(uint256 _withdrawAmount) external;\n\n    function SSIPStaking(uint256 _stakingAmount) external;\n\n    function SSIPPolicyCaim(\n        uint256 _withdrawAmount,\n        uint256 _policyId,\n        bool _isFinished\n    ) external;\n\n    function checkCapitalByMCR(address _pool, uint256 _withdrawAmount) external view returns (bool);\n\n    function checkCoverageByMLR(uint256 _coverageAmount) external view returns (bool);\n\n    function policySale(uint256 _coverageAmount) external;\n\n    function updatePolicyStatus(uint256 _policyId) external;\n}\n"
46     },
47     "contracts/interfaces/IExchangeAgent.sol": {
48       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface IExchangeAgent {\n    function USDC_TOKEN() external view returns (address);\n\n    function getTokenAmountForUSDC(address _token, uint256 _usdtAmount) external view returns (uint256);\n\n    function getETHAmountForUSDC(uint256 _usdtAmount) external view returns (uint256);\n\n    function getETHAmountForToken(address _token, uint256 _tokenAmount) external view returns (uint256);\n\n    function getTokenAmountForETH(address _token, uint256 _ethAmount) external view returns (uint256);\n\n    function getNeededTokenAmount(\n        address _token0,\n        address _token1,\n        uint256 _token0Amount\n    ) external view returns (uint256);\n\n    function convertForToken(\n        address _token0,\n        address _token1,\n        uint256 _token0Amount\n    ) external returns (uint256);\n\n    function convertForETH(address _token, uint256 _convertAmount) external returns (uint256);\n}\n"
49     },
50     "contracts/interfaces/IMigration.sol": {
51       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface IMigration {\n    function onMigration(\n        address who_,\n        uint256 amount_,\n        bytes memory data_\n    ) external;\n}\n"
52     },
53     "contracts/interfaces/IRewarder.sol": {
54       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\ninterface IRewarder {\n    function currency() external view returns (address);\n\n    function onReward(address to, uint256 unoAmount) external payable returns (uint256);\n}\n"
55     },
56     "contracts/interfaces/IRewarderFactory.sol": {
57       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRewarderFactory {\n    function newRewarder(\n        address _operator,\n        address _currency,\n        address _pool\n    ) external returns (address);\n}\n"
58     },
59     "contracts/interfaces/IRiskPool.sol": {
60       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRiskPool {\n    function enter(address _from, uint256 _amount) external;\n\n    function leaveFromPoolInPending(address _to, uint256 _amount) external;\n\n    function leaveFromPending(address _to) external returns (uint256, uint256);\n\n    function cancelWithrawRequest(address _to) external returns (uint256, uint256);\n\n    function policyClaim(address _to, uint256 _amount) external returns (uint256 realClaimAmount);\n\n    function migrateLP(\n        address _to,\n        address _migrateTo,\n        bool _isUnLocked\n    ) external returns (uint256);\n\n    function setMinLPCapital(uint256 _minLPCapital) external;\n\n    function currency() external view returns (address);\n\n    function getTotalWithdrawRequestAmount() external view returns (uint256);\n\n    function getWithdrawRequest(address _to)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function lpPriceUno() external view returns (uint256);\n}\n"
61     },
62     "contracts/interfaces/IRiskPoolFactory.sol": {
63       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface IRiskPoolFactory {\n    function newRiskPool(\n        string calldata _name,\n        string calldata _symbol,\n        address _pool,\n        address _currency\n    ) external returns (address);\n}\n"
64     },
65     "contracts/interfaces/ISingleSidedInsurancePool.sol": {
66       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface ISingleSidedInsurancePool {\n    function updatePool() external;\n\n    function enterInPool(uint256 _amount) external payable;\n\n    function leaveFromPoolInPending(uint256 _amount) external;\n\n    function leaveFromPending() external;\n\n    function harvest(address _to) external;\n\n    function lpTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external;\n\n    function riskPool() external view returns (address);\n}\n"
67     },
68     "contracts/interfaces/ISyntheticSSIPFactory.sol": {
69       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.0;\n\ninterface ISyntheticSSIPFactory {\n    function newSyntheticSSIP(address _multiSigWallet, address _lpToken) external returns (address);\n}\n"
70     },
71     "contracts/libraries/TransferHelper.sol": {
72       "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.0;\n\n// from Uniswap TransferHelper library\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeApprove: approve failed\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeTransfer: transfer failed\");\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::transferFrom: transferFrom failed\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n    }\n}\n"
73     }
74   }
75 }}