1 pragma solidity 0.4.25;
2 
3 /* This Source Code Form is subject to the terms of the Mozilla external
4  * License, v. 2.0. If a copy of the MPL was not distributed with this
5  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
6  *
7  * This code has not been reviewed.
8  * Do not use or deploy this code before reviewing it personally first.
9  */
10 
11 interface ERC777Token {
12   function name() external view returns (string);
13   function symbol() external view returns (string);
14   function totalSupply() external view returns (uint256);
15   function balanceOf(address owner) external view returns (uint256);
16   function granularity() external view returns (uint256);
17 
18   function defaultOperators() external view returns (address[]);
19   function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
20   function authorizeOperator(address operator) external;
21   function revokeOperator(address operator) external;
22 
23   function send(address to, uint256 amount, bytes holderData) external;
24   function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) external;
25 
26   function burn(uint256 amount, bytes holderData) external;
27   function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) external;
28 
29   event Sent(
30     address indexed operator,
31     address indexed from,
32     address indexed to,
33     uint256 amount,
34     bytes holderData,
35     bytes operatorData
36   );
37   event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);
38   event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);
39   event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
40   event RevokedOperator(address indexed operator, address indexed tokenHolder);
41 }
42 
43 /// @title DelegatedTransferOperatorV4
44 /// @author Roger Wu (Roger-Wu)
45 /// @dev A DelegatedTransferOperator contract that has the following features:
46 ///   1. To prevent replay attack, we check if a _nonce has been used by a token holder.
47 ///   2. Minimize the gas by making functions inline and remove trivial event.
48 ///   3. Add _userData.
49 contract DelegatedTransferOperatorV4 {
50   mapping(address => uint256) public usedNonce;
51   ERC777Token public tokenContract;
52 
53   constructor(address _tokenAddress) public {
54     tokenContract = ERC777Token(_tokenAddress);
55   }
56 
57   /**
58     * @notice Submit a presigned transfer
59     * @param _to address The address which you want to transfer to.
60     * @param _delegate address The address which is allowed to send this transaction.
61     * @param _value uint256 The amount of tokens to be transferred.
62     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.
63     * @param _nonce uint256 Presigned transaction number.
64     * @param _userData bytes Data generated by the user to be sent to the recipient.
65     * @param _sig_r bytes32 The r of the signature.
66     * @param _sig_s bytes32 The s of the signature.
67     * @param _sig_v uint8 The v of the signature.
68     * @notice some rules:
69     * 1. If _to is address(0), the tx will fail when doSend().
70     * 2. If _delegate == address(0), then anyone can be the delegate.
71     * 3. _nonce must be greater than the last used nonce by the token holder,
72     *    but nonces don't have to be serial numbers.
73     *    We recommend using unix time as nonce.
74     * 4. _sig_v should be 27 or 28.
75     */
76   function transferPreSigned(
77     address _to,
78     address _delegate,
79     uint256 _value,
80     uint256 _fee,
81     uint256 _nonce,
82     bytes _userData,
83     bytes32 _sig_r,
84     bytes32 _sig_s,
85     uint8 _sig_v
86   )
87     external
88   {
89     require(
90       _delegate == address(0) || _delegate == msg.sender,
91       "_delegate should be address(0) or msg.sender"
92     );
93 
94     // address _signer = recover(_hash, _signature);
95     address _signer = (_sig_v != 27 && _sig_v != 28) ?
96       address(0) :
97       ecrecover(
98         keccak256(abi.encodePacked(
99           address(this),
100           _to,
101           _delegate,
102           _value,
103           _fee,
104           _nonce,
105           _userData
106         )),
107         _sig_v, _sig_r, _sig_s
108       );
109 
110     require(
111       _signer != address(0),
112       "_signature is invalid."
113     );
114 
115     require(
116       _nonce > usedNonce[_signer],
117       "_nonce must be greater than the last used nonce of the token holder."
118     );
119 
120     usedNonce[_signer] = _nonce;
121 
122     tokenContract.operatorSend(_signer, _to, _value, _userData, "");
123     if (_fee > 0) {
124       tokenContract.operatorSend(_signer, msg.sender, _fee, _userData, "");
125     }
126   }
127 
128   /**
129     * @notice Hash (keccak256) of the payload used by transferPreSigned
130     * @param _operator address The address of the operator.
131     * @param _to address The address which you want to transfer to.
132     * @param _delegate address The address of the delegate.
133     * @param _value uint256 The amount of tokens to be transferred.
134     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.
135     * @param _nonce uint256 Presigned transaction number.
136     * @param _userData bytes Data generated by the user to be sent to the recipient.
137     */
138   function transferPreSignedHashing(
139     address _operator,
140     address _to,
141     address _delegate,
142     uint256 _value,
143     uint256 _fee,
144     uint256 _nonce,
145     bytes _userData
146   )
147     public
148     pure
149     returns (bytes32)
150   {
151     return keccak256(abi.encodePacked(
152       _operator,
153       _to,
154       _delegate,
155       _value,
156       _fee,
157       _nonce,
158       _userData
159     ));
160   }
161 
162   /**
163     * @notice Recover signer address from a message by using his signature
164     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
165     * @param sig bytes signature, the signature is generated using web3.eth.sign()
166     */
167   function recover(bytes32 hash, bytes sig) public pure returns (address) {
168     bytes32 r;
169     bytes32 s;
170     uint8 v;
171 
172     // Check the signature length
173     if (sig.length != 65) {
174       return (address(0));
175     }
176 
177     // Divide the signature in r, s and v variables
178     // ecrecover takes the signature parameters, and the only way to get them
179     // currently is to use assembly.
180     // solium-disable-next-line security/no-inline-assembly
181     assembly {
182       r := mload(add(sig, 0x20))
183       s := mload(add(sig, 0x40))
184       v := byte(0, mload(add(sig, 0x60)))
185     }
186 
187     // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
188     if (v < 27) {
189       v += 27;
190     }
191 
192     // If the version is correct return the signer address
193     if (v != 27 && v != 28) {
194       return (address(0));
195     } else {
196       return ecrecover(hash, v, r, s);
197     }
198   }
199 }