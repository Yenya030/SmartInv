1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "istanbul",
5     "libraries": {},
6     "metadata": {
7       "useLiteralContent": true
8     },
9     "optimizer": {
10       "enabled": true,
11       "runs": 100
12     },
13     "remappings": [],
14     "outputSelection": {
15       "*": {
16         "*": [
17           "evm.bytecode",
18           "evm.deployedBytecode",
19           "devdoc",
20           "userdoc",
21           "metadata",
22           "abi"
23         ]
24       }
25     }
26   },
27   "sources": {
28     "contracts/lending/tokens/cErc20ModifiedDelegator.sol": {
29       "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n// File: contracts/ComptrollerInterface.sol\n\npragma solidity ^0.5.12;\n\ninterface ComptrollerInterface {\n  /**\n   * @notice Marker function used for light validation when updating the comptroller of a market\n   * @dev Implementations should simply return true.\n   * @return true\n   */\n  function isComptroller() external view returns (bool);\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(\n    address[] calldata cTokens\n  ) external returns (uint256[] memory);\n\n  function exitMarket(address cToken) external returns (uint256);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external returns (uint256);\n\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 mintAmount,\n    uint256 mintTokens\n  ) external;\n\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external returns (uint256);\n\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external;\n\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external returns (uint256);\n\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external;\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 borrowerIndex\n  ) external;\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    uint256 seizeTokens\n  ) external;\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external;\n\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external returns (uint256);\n\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 repayAmount\n  ) external view returns (uint256, uint256);\n}\n\n// File: contracts/InterestRateModel.sol\n\npragma solidity ^0.5.12;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface InterestRateModel {\n  /**\n   * @notice Indicator that this is an InterestRateModel contract (for inspection)\n   */\n  function isInterestRateModel() external pure returns (bool);\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amnount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external view returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amnount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view returns (uint256);\n}\n\n// File: contracts/CTokenInterfaces.sol\n\npragma solidity ^0.5.12;\n\ncontract CTokenStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  /**\n   * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n   */\n\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  /**\n   * @notice Maximum fraction of interest that can be set aside for reserves\n   */\n  uint256 internal constant reserveFactorMaxMantissa = 1e18;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address payable public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address payable public pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  /**\n   * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n   */\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  /**\n   * @notice Official record of token balances for each account\n   */\n  mapping(address => uint256) internal accountTokens;\n\n  /**\n   * @notice Approved token transfer amounts on behalf of others\n   */\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /**\n   * @notice Mapping of account addresses to outstanding borrow balances\n   */\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n}\n\npragma solidity ^0.5.16;\n\ninterface ISanctionsList {\n  function isSanctioned(address addr) external view returns (bool);\n}\n\npragma solidity ^0.5.16;\n\n/**\n * @title IKYCRegistry\n * @author Ondo Finance\n * @notice The interface for Ondo's KYC Registry contract\n */\ninterface IKYCRegistry {\n  /**\n   * @notice Retrieves KYC status of an account\n   *\n   * @param kycRequirementGroup The KYC group for which we wish to check\n   * @param account             The account we wish to retrieve KYC status for\n   *\n   * @return bool Whether the `account` is KYC'd\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view returns (bool);\n}\n\npragma solidity ^0.5.16;\n\n///@notice KYC+Sanctions Specific Storage\ncontract OndoKYCStorage {\n  /**\n   * @dev Event for when the KYC registry reference is set\n   *\n   * @param oldRegistry The old registry\n   * @param newRegistry The new registry\n   */\n  event KYCRegistrySet(address oldRegistry, address newRegistry);\n\n  /**\n   * @dev Event for when the KYC group for this client is set\n   *\n   * @param oldRequirementGroup The old KYC group\n   * @param newRequirementGroup The new KYC group\n   */\n  event KYCRequirementGroupSet(\n    uint256 oldRequirementGroup,\n    uint256 newRequirementGroup\n  );\n\n  /**\n   * @notice Pointer to sanctions oracle\n   */\n  ISanctionsList public constant sanctionsList =\n    ISanctionsList(0x40C57923924B5c5c5455c48D93317139ADDaC8fb);\n\n  /**\n   * @notice Pointer to kycRegistry\n   */\n  IKYCRegistry public kycRegistry;\n\n  /**\n   * @notice Reference to KYC requirement group\n   */\n  uint256 public kycRequirementGroup;\n}\n\ncontract CTokenInterface is CTokenStorage, OndoKYCStorage {\n  /**\n   * @notice Indicator that this is a CToken contract (for inspection)\n   */\n  bool public constant isCToken = true;\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(\n    ComptrollerInterface oldComptroller,\n    ComptrollerInterface newComptroller\n  );\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(\n    InterestRateModel oldInterestRateModel,\n    InterestRateModel newInterestRateModel\n  );\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n\n  /**\n   * @notice Failure event\n   */\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function getAccountSnapshot(\n    address account\n  ) external view returns (uint256, uint256, uint256, uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) public view returns (uint256);\n\n  function exchangeRateCurrent() public returns (uint256);\n\n  function exchangeRateStored() public view returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function accrueInterest() public returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setPendingAdmin(\n    address payable newPendingAdmin\n  ) external returns (uint256);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _setComptroller(\n    ComptrollerInterface newComptroller\n  ) public returns (uint256);\n\n  function _setReserveFactor(\n    uint256 newReserveFactorMantissa\n  ) external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setInterestRateModel(\n    InterestRateModel newInterestRateModel\n  ) public returns (uint256);\n}\n\ncontract CErc20Storage {\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n}\n\ncontract CErc20Interface is CErc20Storage {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n}\n\ncontract CDelegationStorage {\n  /**\n   * @notice Implementation address for this contract\n   */\n  address public implementation;\n}\n\ncontract CDelegatorInterface is CDelegationStorage {\n  /**\n   * @notice Emitted when implementation is changed\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) public;\n}\n\ncontract CDelegateInterface is CDelegationStorage {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes memory data) public;\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() public;\n}\n\n// File: contracts/CErc20Delegator.sol\n\npragma solidity ^0.5.12;\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @dev Designed to Delegate to KYC/Sanctions CToken Implmentations\n * @author Compound\n */\ncontract CErc20DelegatorKYC is\n  CTokenInterface,\n  CErc20Interface,\n  CDelegatorInterface\n{\n  /**\n   * @notice Construct a new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param decimals_ ERC-20 decimal precision of this token\n   * @param admin_ Address of the administrator of this token\n   * @param implementation_ The address of the implementation the contract delegates to\n   * @param becomeImplementationData The encoded args for becomeImplmenetation\n   */\n  constructor(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_,\n    address implementation_,\n    address kycRegistry_,\n    uint256 kycRequirementGroup_,\n    bytes memory becomeImplementationData\n  ) public {\n    // Creator of the contract is admin during initialization\n    admin = msg.sender;\n\n    // First delegate gets to initialize the delegator (i.e. storage contract)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"initialize(address,address,address,uint256,string,string,uint8,address,uint256)\",\n        underlying_,\n        comptroller_,\n        interestRateModel_,\n        initialExchangeRateMantissa_,\n        name_,\n        symbol_,\n        decimals_,\n        kycRegistry_,\n        kycRequirementGroup_\n      )\n    );\n\n    // New implementations always get set via the settor (post-initialize)\n    _setImplementation(implementation_, false, becomeImplementationData);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) public {\n    require(\n      msg.sender == admin,\n      \"CErc20Delegator::_setImplementation: Caller must be admin\"\n    );\n\n    if (allowResign) {\n      delegateToImplementation(\n        abi.encodeWithSignature(\"_resignImplementation()\")\n      );\n    }\n\n    address oldImplementation = implementation;\n    implementation = implementation_;\n\n    delegateToImplementation(\n      abi.encodeWithSignature(\n        \"_becomeImplementation(bytes)\",\n        becomeImplementationData\n      )\n    );\n\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"mint(uint256)\", mintAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"repayBorrowBehalf(address,uint256)\",\n        borrower,\n        repayAmount\n      )\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"liquidateBorrow(address,uint256,address)\",\n        borrower,\n        repayAmount,\n        cTokenCollateral\n      )\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external returns (bool) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount)\n    );\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        src,\n        dst,\n        amount\n      )\n    );\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount)\n    );\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"allowance(address,address)\", owner, spender)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"balanceOf(address)\", owner)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(\n    address account\n  ) external view returns (uint256, uint256, uint256, uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"getAccountSnapshot(address)\", account)\n    );\n    return abi.decode(data, (uint256, uint256, uint256, uint256));\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"borrowRatePerBlock()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"supplyRatePerBlock()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"totalBorrowsCurrent()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"borrowBalanceStored(address)\", account)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"exchangeRateCurrent()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"exchangeRateStored()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view returns (uint256) {\n    bytes memory data = delegateToViewImplementation(\n      abi.encodeWithSignature(\"getCash()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves.\n   * @dev This calculates interest accrued from the last checkpointed block\n   *      up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"accrueInterest()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"seize(address,address,uint256)\",\n        liquidator,\n        borrower,\n        seizeTokens\n      )\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(\n    address payable newPendingAdmin\n  ) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(\n    ComptrollerInterface newComptroller\n  ) public returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(\n    uint256 newReserveFactorMantissa\n  ) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"_setReserveFactor(uint256)\",\n        newReserveFactorMantissa\n      )\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"_acceptAdmin()\")\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and adds reserves by transferring from admin\n   * @param addAmount Amount of reserves to add\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReserves(uint256 addAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount)\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(\n    InterestRateModel newInterestRateModel\n  ) public returns (uint256) {\n    bytes memory data = delegateToImplementation(\n      abi.encodeWithSignature(\n        \"_setInterestRateModel(address)\",\n        newInterestRateModel\n      )\n    );\n    return abi.decode(data, (uint256));\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param callee The contract to delegatecall\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateTo(\n    address callee,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize)\n      }\n    }\n    return returnData;\n  }\n\n  /**\n   * @notice Delegates execution to the implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateToImplementation(\n    bytes memory data\n  ) public returns (bytes memory) {\n    return delegateTo(implementation, data);\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateToViewImplementation(\n    bytes memory data\n  ) public view returns (bytes memory) {\n    (bool success, bytes memory returnData) = address(this).staticcall(\n      abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data)\n    );\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize)\n      }\n    }\n    return abi.decode(returnData, (bytes));\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   */\n  function() external payable {\n    require(\n      msg.value == 0,\n      \"CErc20Delegator:fallback: cannot send value to fallback\"\n    );\n\n    // delegate all other functions to current implementation\n    (bool success, ) = implementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize)\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize)\n      }\n      default {\n        return(free_mem_ptr, returndatasize)\n      }\n    }\n  }\n}\n"
30     }
31   }
32 }}