1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/MarsMiners.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\nimport \"./interfaces/IMarsMetadata.sol\";\r\n\r\ncontract MarsMiners {\r\n\r\n    constructor(){\r\n        supportsInterface[0x80ac58cd] = true;\r\n        supportsInterface[0x5b5e139f] = true;\r\n        supportsInterface[0x01ffc9a7] = true;\r\n        owner = msg.sender;\r\n        _mint(1,msg.sender,bytes32(0));\r\n        mintCost = BASE_COSTS[0] + CREATOR_FEE;\r\n    }\r\n\r\n    uint256[8]  BASE_COSTS = [\r\n        0.000010 ether,\r\n        0.000020 ether,\r\n        0.000025 ether,\r\n        0.000030 ether,\r\n\r\n        0.000040 ether,\r\n        0.000050 ether,\r\n        0.000070 ether,\r\n        0.000100 ether\r\n    ];\r\n\r\n    uint constant BASE_DIFFICULTY = type(uint).max/uint(50000 * 300);\r\n    uint constant DIFFICULTY_RAMP = uint(50000 * 0.1);\r\n    uint constant CREATOR_FEE = 0.005 ether;\r\n    bytes32[] tokens;\r\n    uint public closed;\r\n    uint public ownerWithdrawn;\r\n    address public owner;\r\n    uint public mintCost;\r\n    mapping( uint => uint) public supplyAtMint;\r\n\r\n    event OpenMine( uint _tokenId, bytes32 _hash, address _miner,   uint _newSupply, uint _newMintCost, uint _blockNumber);\r\n    event CloseMine(uint _tokenId, bytes32 _hash, uint _excavated, uint _supplyAtMint, uint _newSupply, uint _newMintCost,  uint _blockNumber);\r\n\r\n    function getMineType(bytes32 hash, uint _supplyAtMint) public pure returns(uint){\r\n        uint mineTypeMax;\r\n        if(_supplyAtMint < 500){\r\n            mineTypeMax = 2;\r\n        }else if(_supplyAtMint < 1000){\r\n            mineTypeMax = 3;\r\n        }else if(_supplyAtMint < 1500){\r\n            mineTypeMax = 4;\r\n        }else if(_supplyAtMint < 2000){\r\n            mineTypeMax = 5;\r\n        }else if(_supplyAtMint < 2500){\r\n            mineTypeMax = 6;\r\n        }else{\r\n            mineTypeMax = 7;\r\n        }\r\n\r\n        return (uint(hash)%100)**3 *(mineTypeMax + 1) / 1000000;\r\n    }\r\n\r\n    function openMine(uint nonce) public payable {\r\n        uint tokenId = tokens.length + 1;\r\n        uint supply = totalSupply();\r\n\r\n        uint difficulty = BASE_DIFFICULTY - (DIFFICULTY_RAMP * supply);\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                tokens[tokens.length - 1],\r\n                nonce\r\n            ));\r\n\r\n        require(uint(hash) < difficulty,\"difficulty\");\r\n        require(msg.value == mintCost,\"cost\");\r\n\r\n        supplyAtMint[tokenId] = supply;\r\n        hash = keccak256(abi.encodePacked(hash,block.timestamp));\r\n        _mint(tokenId,msg.sender,hash);\r\n        mintCost += BASE_COSTS[getMineType(hash,supply)];\r\n\r\n        emit OpenMine(tokenId, hash, msg.sender, totalSupply(), mintCost, block.number);\r\n    }\r\n\r\n    function closeMine(uint tokenId) public{\r\n        payable(msg.sender).transfer(_closeMine(tokenId));\r\n    }\r\n\r\n    function _closeMine(uint tokenId) private returns(uint){\r\n        require(msg.sender == ownerOf(tokenId),\"ownerOf\");\r\n\r\n        uint excavated = (tokens.length - tokenId);\r\n        uint BASE_COST = BASE_COSTS[getMineType(hashOf(tokenId),supplyAtMint[tokenId])];\r\n        uint earnings = excavated * BASE_COST;\r\n        closed++;\r\n        _burn(tokenId);\r\n        mintCost -= BASE_COST;\r\n\r\n        emit CloseMine(tokenId, tokens[tokenId - 1], excavated, supplyAtMint[tokenId], totalSupply(), mintCost, block.number);\r\n        return earnings;\r\n    }\r\n\r\n    function closeMultiple(uint[] calldata tokenIds) public{\r\n        require(tokenIds.length > 0,\"tokenIds\");\r\n        uint total;\r\n        for(uint i = 0; i < tokenIds.length; i++){\r\n            total += _closeMine(tokenIds[i]);\r\n        }\r\n        payable(msg.sender).transfer(total);\r\n    }\r\n\r\n    function hashOf(uint _tokenId) public view returns(bytes32){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return tokens[_tokenId - 1];\r\n    }\r\n\r\n    function getEthContained(uint _tokenId) public view returns(uint){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        uint BASE_COST = BASE_COSTS[getMineType(hashOf(_tokenId),supplyAtMint[_tokenId])];\r\n        return (tokens.length - _tokenId) * BASE_COST;\r\n    }\r\n\r\n    function getLastHash() public view returns(bytes32){\r\n        return tokens[tokens.length - 1];\r\n    }\r\n\r\n    function getMiningState() public view returns(bytes32 _hash, uint _supply, uint _closed, uint blockNumber){\r\n        return (tokens[tokens.length - 1], totalSupply(), closed, block.number);\r\n    }\r\n\r\n    function mineData(uint _tokenId) public view returns(bytes32 _hash, uint _supplyAtMint, uint _opened){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n\r\n        return (tokens[_tokenId - 1],supplyAtMint[_tokenId],tokens.length);\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping (uint256 => address) internal allowance;\r\n    mapping (address => mapping (address => bool)) public isApprovedForAll;\r\n\r\n    mapping(uint256 => address) owners;\r\n\r\n    string public name = \"Mars Mining Company\";\r\n    string public symbol = \"MARS\";\r\n\r\n    address private __metadata;\r\n\r\n    address constant VB = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045;\r\n\r\n    function _mint(uint _tokenId,address _to, bytes32 _hash) private{\r\n        owners[_tokenId] = msg.sender;\r\n        balanceOf[_to]++;\r\n        tokens.push(_hash);\r\n        emit Transfer(address(0),VB,_tokenId);\r\n        emit Transfer(VB,_to,_tokenId);\r\n    }\r\n\r\n    function _burn(uint _tokenId) private{\r\n        address _owner = owners[_tokenId];\r\n        balanceOf[ _owner ]--;\r\n        delete owners[_tokenId];\r\n\r\n        emit Transfer(_owner,address(0),_tokenId);\r\n    }\r\n\r\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return owners[_tokenId] != address(0);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return owners[_tokenId];\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address _owner = ownerOf(_tokenId);\r\n        require( _owner == msg.sender || isApprovedForAll[_owner][msg.sender],\"permission\");\r\n        emit Approval(_owner, _approved, _tokenId);\r\n        allowance[_tokenId] = _approved;\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(isValidToken(_tokenId),\"invalid\");\r\n        return allowance[_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        isApprovedForAll[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        address _owner = ownerOf(_tokenId);\r\n        require ( _owner == msg.sender  || allowance[_tokenId] == msg.sender  || isApprovedForAll[_owner][msg.sender],\"permission\");\r\n        require(_owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n        emit Transfer(_from, _to, _tokenId);\r\n        owners[_tokenId] =_to;\r\n        balanceOf[_from]--;\r\n        balanceOf[_to]++;\r\n        if(allowance[_tokenId] != address(0)){\r\n            delete allowance[_tokenId];\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\r\n        require(isValidToken(_tokenId),'tokenId');\r\n\r\n        return IMarsMetadata(__metadata).tokenURI(\r\n            _tokenId,\r\n            tokens[_tokenId-1],\r\n            supplyAtMint[_tokenId],\r\n            tokens.length);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256){\r\n        return tokens.length - closed;\r\n    }\r\n\r\n    mapping (bytes4 => bool) public supportsInterface;\r\n\r\n    function setOwner(address newOwner) public{\r\n        require(msg.sender == owner,\"owner\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setMetadata(address _metadata) public{\r\n        require(msg.sender == owner,\"owner\");\r\n        __metadata = _metadata;\r\n    }\r\n\r\n    function ownerWithdraw() public{\r\n        require(msg.sender == owner,\"owner\");\r\n        uint toWithdraw = (tokens.length - ownerWithdrawn - 1) * CREATOR_FEE ;\r\n        require(toWithdraw > 0,\"withdrawn\");\r\n        ownerWithdrawn = tokens.length - 1;\r\n        payable(msg.sender).transfer(toWithdraw);\r\n\r\n    }\r\n}"
6     },
7     "contracts/interfaces/IERC721TokenReceiver.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}"
9     },
10     "contracts/interfaces/IMarsMetadata.sol": {
11       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IMarsMetadata {\r\n    function tokenURI(uint _tokenId,bytes32 _hash, uint _supplyAtMint, uint _opened) external view returns (string memory);\r\n}"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": false,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     },
31     "libraries": {}
32   }
33 }}