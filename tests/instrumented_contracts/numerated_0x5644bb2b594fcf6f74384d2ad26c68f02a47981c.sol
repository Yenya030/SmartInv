1 /**
2  *Submitted for verification at Etherscan.io on 2021-11-29
3 */
4 
5 /**
6  #SuperMegaHyperDoge
7   
8   #SuperMegaHyperDoge features:
9   
10    4% liquidity fee ensures rising liquidity
11                     &
12    6% marketing fee ensures a huge marketing budget 
13           
14   #SuperMegaHyperDoge
15   
16    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
17 @@@@@@@@@@@@@@@@@@@@@@%##(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
18 @@@@@@@@@@@@@@@@@@@%##(((((##@@@@@@@@@@@@@@@@@@@&%#(%%@@@@@@@@@@@@@@@@@@@@@@@@@@
19 @@@@@@@@@@@@@@@&%%#((((((((#%@@@@@@@@@@@@@@@@@@######(%&(@@@@@@@@@@@@@@@@@@@@@@@
20 @@@@@@@@@@@@@(#((((((((((((##%#@@@@@@@@@@@@@@@%/#(#%((#(#%@#####%@@@@@@@@@@@@@@@
21 @@@@@@@@@@##((((((((((((((((##%&@@@%###&&&@@@@&%(((%((((#%((#%(((#%&@@@@@@@@@@@@
22 @@@@@@@@@%##(((((((((((((((((((#((((((((((((##%(((((((((%((((((#((((##%@@@@@@@@@
23 @@@@@@@@@%((%(%((((((((((((((((((%(((((((((((((((((((((((#(((((%((((((##@@@@@@@@
24 @@@@@@@@@##(((((%(((((((((((((((((((((((((((((((((((((#((#(%(((((((((#%#@@@@@@@@
25 @@@@@@@@@&#%(#(((((##((((((((((((#%(&%(((#((((%&((((((#@@@@#(##%%((((#(#@@@@@@@@
26 @@@@@@@@@@@%%(((((((((((((((((((((((((((#((((((((((((((((((((##%###((((#(@@@@@@@
27 @@@@@@@@@@@&%%(((((((((((((((((((((((#&      @(((((((((&  %(((#(%####((##(@@@@@@
28 @@@@@@@@@@@%%(((((((((((((((((((((((#         /(((((((,     %(((#/###%###%#%@@@@
29 @@@@@@@@@@@%#(((((((((((((((((((((((/    ,@@   #(((((%   %&  %((%(##############
30 @@@@@@@@@@%%((((((((((((((((((((((((.         ,((((((#       /((%###############
31 @@@@@@@@@@%%(((((((((((((((((((((((##         ##((((((*      #((%###############
32 @@@@@@@@@@%%(((((((((((((((((((((((((%.     %((((((((((#    ,(((#/(#############
33 @@@@@@@@@@%/##((((((((((#((((((((((((((((((((((((%....#((##(((((#(#//###########
34 @@@@@@@@@@%%%(((((((((# .......%#((((((((((((&%%&&%%%&&&&&&&&(#%/ ..#,((((((((((
35 @@@@@@@@@@%#%%(((((% ............... ,(###/...(@@&&&&&&&&%&&&........,,(((((((((
36 @@@@@@@@@@@&%%%#((#..............................@@%&&&&%@@ ........../,((((((((
37 @@@@@@@@@@@@@@%%%%.................................#&&&%@.............*,((((((((
38 @@@@@@@@@@@@@@@@/((...........................   ....... ............,,(((((((((
39 @@@@@@@@@@@@@@@@@@@%,*.........................@@@@&&&%%,..........,(,/(((((((((
40 @@@@@@@@@@@@@@@@@@@%,*((//......................,#(@%&/........./(/*((((((((((((
41 @@@@@@@@@@@@@@@@@@@@@@@@(%%%%%%#* ........................,(/,/////(((((((((((((
42 @@@@@@@@@@@@@@@@@@@@@@@@/%%%%%%#%%%%%&#./*# .........&#//#######################
43 @@@@@@@@@@@@@@@@@@@@@@@@(%%%%%%#(#&%%%%%(*///,(###%&#%%#,,,,,,,,,,,,,,,,,,,,,,,, 
44 /**@@@@@@@@@@@@@@@@@@@@@&&%%%%#%(((((((%...........%((@#%%%#,,,,,,,,,,,,,,,,,,,,,,,
45 @@@@@@@@@@@@@@@@@@@&%&#%%%&(((((((%.............. %#((&%%%*,,,,,,,,,,,,,,,,,,,,,
46 @@@@@@@@@@@@@@@@@@@&%%%%%((((((##&.................&((&&#%%((,,,,,,,,,,,,,,,,,,,
47 @@@@@@@@@@@@@@@@@@&%%%%&(((((((#(.................../(##%#%%%%,,,,,,,,,,,,,,,,,,
48 @@@@@@@@@@@@@@@@&%%%%#&((((((#%(.....................,(((#%%%%#,,,,,,,,,,,,,,,,,
49 @@@@@@@@@@@@@@@@#%%%%&(((((((%%.......................//((#&%%%&(,,,,,,,,,,,,,,,
50 @@@@@@@@@@@@@&&%%%%%&((((((##(.........................(((#(##%%&#,,,,,,,,,,,,,,
51 @@@@@@@@@@&%%&%%%%%%((((((((#@..........................&(#&((&##&%,,,,,,,,,,,,,
52 @@@@@@@@@@&%%%%%%%%%#((((((%(#...........................#((##((&#&/,,,,,,,,,,,,
53 @@@@@@@&&%%#&%%%%%%((((((((%((...........................@((&(((((&&&*,,,,,,,,,,
54 @@@@@@&&%%%&#%%%%#&((((((((((#...........................(((%(((((((@%&#,,,,,,,,
55 @@@@@%%%%%%&%%%%%%(((((((#%((&.........................../((%((((((((#((##%/,,,,
56 @@@@/%%%%%#%%%%%%&(((((((%&(((#..........................%((&#((((((((((((%%%(,,
57 @@@&&%%%%%#%%%%%###(((((((%((((/.........................#((&%%((#%#&(#(###%(%%/
58 @@@%#%%%%%%&%%%%%%(%((((((%(((((%.......................%##&%%%%%#(#(#((&(((((%(
59 @@&&%%%%%%%&%%%%#%(((%#((#((((((((%...................%(((#%%%%%%%#%(%##%&%&&&%(
60 @@&&%%%%%%%%#%&@%%(%((%#((%(((((((((#(#@%/,..,*#@@((#(((#%%&&&@@&%&((((%&&@&%#%/
61 @@@@&%%%%%%%&%&%%%#((((#%(((((((((((%#(((((((((((((((((&@@&&&&&&&&&&&&%%%&&&%#%/
62 @@@@&%&%%%%%%&&%%%%%%%#%((((((((((((#(((((((((((#((%%(((&%&&&&&&&&&&&&&&%&&&%#%/
63 @@@@@@@&&%%%%%%%%%%%%%#%(((((((((((%&&&&&&&@%(((#(((((#((#&&&&&&&&&&&&&&&@@&%#%/
64 @@@@@@@@@@&(&%&&%%%%%%%%(((((((((((&%&&&&&&%((((((((((##(#&&&&&&&&&&&&&&&&&&&&&&
65 @@@@@@@@@@@@@@@@%%%%%%%%(((((((((((%%(((((@&##(((((((((%##&&&&&&&&&&&&&&&&&&&&&&
66 @@@@@@@@@@@@@@@@@@@&%%%%(((((((((#%(######@.##(((((((((%&#&&&&&&&&&&&&&&&&&&&&&&
67 @@@@@@@@@@@@@@@@@@@&%%%%(((((((((((&######@%%((((((((##%%#&&&&&&&&&&&&&&&&&&&&&&
68 @@@@@@@@@@@@@@@@@@@&%%%@(((((((((%#&######@%%(((((((((%%%#&&&&&&&&&&&&&&&&&&&&&&
69 @@@@@@@@@@@@@@@@@@@@@@@%##(((((((&#&######@@/(((((((#(&@%#&&&&&&&&&&&&&&&&&&&&&&
70 @@@@@@@@@@@@@@@@@@@@@@@*%#((((((#*#&######@@*##(((((##/&%#&&&&&&&&&&&&&&&&&&&&&&
71 @@@@@@@@@@@@@@@@@@@@@@@*%(((((((%%(&######@@(%(((((((%#&%#&&&&&&&&&&&&&&&&&&&&&&
72 @@@@@@@@@@@@@@@@@@@@@@@&&((((((##%(&######@@&&(((((((%%&%#&&&&&&&&&&&&&&&&&&&&&&
73 @@@@@@@@@@@@@@@@@@@@@@@&&((((((%#%(&######@@&#((((((%.#&%#&&&&&&&&&&&&&&&&&&&&&&
74 @@@@@@@@@@@@@@@@@@@@@@&%((((((((%(%&######@@%%(((((((#%%%&&&&&&&&&&&&&&&&&&&&&&&
75 @@@@@@@@@@@@@@@@@@@@@@@%#((#(&#(%(%#######@@%%((##%(##(#&#&&&&&&&&&&&&&&&&&&&&&&
76 @@@@@@@@@@@@@@@@@@@@@@@@@@%@@&##&&&&&&&&&&&&&&&%%&&%%&%%%%%%%%%%%%%%%%%%%%%%%%%% 
77 
78 #SuperMegaHyperDoge
79 
80 */
81 
82 pragma solidity ^0.6.12;
83 // SPDX-License-Identifier: Unlicensed
84 interface IERC20 {
85 
86     function totalSupply() external view returns (uint256);
87 
88     /**
89      * @dev Returns the amount of tokens owned by `account`.
90      */
91     function balanceOf(address account) external view returns (uint256);
92 
93     /**
94      * @dev Moves `amount` tokens from the caller's account to `recipient`.
95      *
96      * Returns a boolean value indicating whether the operation succeeded.
97      *
98      * Emits a {Transfer} event.
99      */
100     function transfer(address recipient, uint256 amount) external returns (bool);
101 
102     /**
103      * @dev Returns the remaining number of tokens that `spender` will be
104      * allowed to spend on behalf of `owner` through {transferFrom}. This is
105      * zero by default.
106      *
107      * This value changes when {approve} or {transferFrom} are called.
108      */
109     function allowance(address owner, address spender) external view returns (uint256);
110 
111     /**
112      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
113      *
114      * Returns a boolean value indicating whether the operation succeeded.
115      *
116      * IMPORTANT: Beware that changing an allowance with this method brings the risk
117      * that someone may use both the old and the new allowance by unfortunate
118      * transaction ordering. One possible solution to mitigate this race
119      * condition is to first reduce the spender's allowance to 0 and set the
120      * desired value afterwards:
121      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
122      *
123      * Emits an {Approval} event.
124      */
125     function approve(address spender, uint256 amount) external returns (bool);
126 
127     /**
128      * @dev Moves `amount` tokens from `sender` to `recipient` using the
129      * allowance mechanism. `amount` is then deducted from the caller's
130      * allowance.
131      *
132      * Returns a boolean value indicating whether the operation succeeded.
133      *
134      * Emits a {Transfer} event.
135      */
136     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
137 
138     /**
139      * @dev Emitted when `value` tokens are moved from one account (`from`) to
140      * another (`to`).
141      *
142      * Note that `value` may be zero.
143      */
144     event Transfer(address indexed from, address indexed to, uint256 value);
145 
146     /**
147      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
148      * a call to {approve}. `value` is the new allowance.
149      */
150     event Approval(address indexed owner, address indexed spender, uint256 value);
151 }
152 
153 
154 
155 /**
156  * @dev Wrappers over Solidity's arithmetic operations with added overflow
157  * checks.
158  *
159  * Arithmetic operations in Solidity wrap on overflow. This can easily result
160  * in bugs, because programmers usually assume that an overflow raises an
161  * error, which is the standard behavior in high level programming languages.
162  * `SafeMath` restores this intuition by reverting the transaction when an
163  * operation overflows.
164  *
165  * Using this library instead of the unchecked operations eliminates an entire
166  * class of bugs, so it's recommended to use it always.
167  */
168  
169 library SafeMath {
170     /**
171      * @dev Returns the addition of two unsigned integers, reverting on
172      * overflow.
173      *
174      * Counterpart to Solidity's `+` operator.
175      *
176      * Requirements:
177      *
178      * - Addition cannot overflow.
179      */
180     function add(uint256 a, uint256 b) internal pure returns (uint256) {
181         uint256 c = a + b;
182         require(c >= a, "SafeMath: addition overflow");
183 
184         return c;
185     }
186 
187     /**
188      * @dev Returns the subtraction of two unsigned integers, reverting on
189      * overflow (when the result is negative).
190      *
191      * Counterpart to Solidity's `-` operator.
192      *
193      * Requirements:
194      *
195      * - Subtraction cannot overflow.
196      */
197     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
198         return sub(a, b, "SafeMath: subtraction overflow");
199     }
200 
201     /**
202      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
203      * overflow (when the result is negative).
204      *
205      * Counterpart to Solidity's `-` operator.
206      *
207      * Requirements:
208      *
209      * - Subtraction cannot overflow.
210      */
211     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
212         require(b <= a, errorMessage);
213         uint256 c = a - b;
214 
215         return c;
216     }
217 
218     /**
219      * @dev Returns the multiplication of two unsigned integers, reverting on
220      * overflow.
221      *
222      * Counterpart to Solidity's `*` operator.
223      *
224      * Requirements:
225      *
226      * - Multiplication cannot overflow.
227      */
228     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
229         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
230         // benefit is lost if 'b' is also tested.
231         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
232         if (a == 0) {
233             return 0;
234         }
235 
236         uint256 c = a * b;
237         require(c / a == b, "SafeMath: multiplication overflow");
238 
239         return c;
240     }
241 
242     /**
243      * @dev Returns the integer division of two unsigned integers. Reverts on
244      * division by zero. The result is rounded towards zero.
245      *
246      * Counterpart to Solidity's `/` operator. Note: this function uses a
247      * `revert` opcode (which leaves remaining gas untouched) while Solidity
248      * uses an invalid opcode to revert (consuming all remaining gas).
249      *
250      * Requirements:
251      *
252      * - The divisor cannot be zero.
253      */
254     function div(uint256 a, uint256 b) internal pure returns (uint256) {
255         return div(a, b, "SafeMath: division by zero");
256     }
257 
258     /**
259      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
260      * division by zero. The result is rounded towards zero.
261      *
262      * Counterpart to Solidity's `/` operator. Note: this function uses a
263      * `revert` opcode (which leaves remaining gas untouched) while Solidity
264      * uses an invalid opcode to revert (consuming all remaining gas).
265      *
266      * Requirements:
267      *
268      * - The divisor cannot be zero.
269      */
270     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
271         require(b > 0, errorMessage);
272         uint256 c = a / b;
273         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
274 
275         return c;
276     }
277 
278     /**
279      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
280      * Reverts when dividing by zero.
281      *
282      * Counterpart to Solidity's `%` operator. This function uses a `revert`
283      * opcode (which leaves remaining gas untouched) while Solidity uses an
284      * invalid opcode to revert (consuming all remaining gas).
285      *
286      * Requirements:
287      *
288      * - The divisor cannot be zero.
289      */
290     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
291         return mod(a, b, "SafeMath: modulo by zero");
292     }
293 
294     /**
295      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
296      * Reverts with custom message when dividing by zero.
297      *
298      * Counterpart to Solidity's `%` operator. This function uses a `revert`
299      * opcode (which leaves remaining gas untouched) while Solidity uses an
300      * invalid opcode to revert (consuming all remaining gas).
301      *
302      * Requirements:
303      *
304      * - The divisor cannot be zero.
305      */
306     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
307         require(b != 0, errorMessage);
308         return a % b;
309     }
310 }
311 
312 abstract contract Context {
313     function _msgSender() internal view virtual returns (address payable) {
314         return msg.sender;
315     }
316 
317     function _msgData() internal view virtual returns (bytes memory) {
318         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
319         return msg.data;
320     }
321 }
322 
323 
324 /**
325  * @dev Collection of functions related to the address type
326  */
327 library Address {
328     /**
329      * @dev Returns true if `account` is a contract.
330      *
331      * [IMPORTANT]
332      * ====
333      * It is unsafe to assume that an address for which this function returns
334      * false is an externally-owned account (EOA) and not a contract.
335      *
336      * Among others, `isContract` will return false for the following
337      * types of addresses:
338      *
339      *  - an externally-owned account
340      *  - a contract in construction
341      *  - an address where a contract will be created
342      *  - an address where a contract lived, but was destroyed
343      * ====
344      */
345     function isContract(address account) internal view returns (bool) {
346         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
347         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
348         // for accounts without code, i.e. `keccak256('')`
349         bytes32 codehash;
350         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
351         // solhint-disable-next-line no-inline-assembly
352         assembly { codehash := extcodehash(account) }
353         return (codehash != accountHash && codehash != 0x0);
354     }
355 
356     /**
357      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
358      * `recipient`, forwarding all available gas and reverting on errors.
359      *
360      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
361      * of certain opcodes, possibly making contracts go over the 2300 gas limit
362      * imposed by `transfer`, making them unable to receive funds via
363      * `transfer`. {sendValue} removes this limitation.
364      *
365      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
366      *
367      * IMPORTANT: because control is transferred to `recipient`, care must be
368      * taken to not create reentrancy vulnerabilities. Consider using
369      * {ReentrancyGuard} or the
370      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
371      */
372     function sendValue(address payable recipient, uint256 amount) internal {
373         require(address(this).balance >= amount, "Address: insufficient balance");
374 
375         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
376         (bool success, ) = recipient.call{ value: amount }("");
377         require(success, "Address: unable to send value, recipient may have reverted");
378     }
379 
380     /**
381      * @dev Performs a Solidity function call using a low level `call`. A
382      * plain`call` is an unsafe replacement for a function call: use this
383      * function instead.
384      *
385      * If `target` reverts with a revert reason, it is bubbled up by this
386      * function (like regular Solidity function calls).
387      *
388      * Returns the raw returned data. To convert to the expected return value,
389      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
390      *
391      * Requirements:
392      *
393      * - `target` must be a contract.
394      * - calling `target` with `data` must not revert.
395      *
396      * _Available since v3.1._
397      */
398     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
399       return functionCall(target, data, "Address: low-level call failed");
400     }
401 
402     /**
403      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
404      * `errorMessage` as a fallback revert reason when `target` reverts.
405      *
406      * _Available since v3.1._
407      */
408     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
409         return _functionCallWithValue(target, data, 0, errorMessage);
410     }
411 
412     /**
413      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
414      * but also transferring `value` wei to `target`.
415      *
416      * Requirements:
417      *
418      * - the calling contract must have an ETH balance of at least `value`.
419      * - the called Solidity function must be `payable`.
420      *
421      * _Available since v3.1._
422      */
423     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
424         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
425     }
426 
427     /**
428      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
429      * with `errorMessage` as a fallback revert reason when `target` reverts.
430      *
431      * _Available since v3.1._
432      */
433     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
434         require(address(this).balance >= value, "Address: insufficient balance for call");
435         return _functionCallWithValue(target, data, value, errorMessage);
436     }
437 
438     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
439         require(isContract(target), "Address: call to non-contract");
440 
441         // solhint-disable-next-line avoid-low-level-calls
442         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
443         if (success) {
444             return returndata;
445         } else {
446             // Look for revert reason and bubble it up if present
447             if (returndata.length > 0) {
448                 // The easiest way to bubble the revert reason is using memory via assembly
449 
450                 // solhint-disable-next-line no-inline-assembly
451                 assembly {
452                     let returndata_size := mload(returndata)
453                     revert(add(32, returndata), returndata_size)
454                 }
455             } else {
456                 revert(errorMessage);
457             }
458         }
459     }
460 }
461 
462 /**
463  * @dev Contract module which provides a basic access control mechanism, where
464  * there is an account (an owner) that can be granted exclusive access to
465  * specific functions.
466  *
467  * By default, the owner account will be the one that deploys the contract. This
468  * can later be changed with {transferOwnership}.
469  *
470  * This module is used through inheritance. It will make available the modifier
471  * `onlyOwner`, which can be applied to your functions to restrict their use to
472  * the owner.
473  */
474 contract Ownable is Context {
475     address private _owner;
476     address private _previousOwner;
477     uint256 private _lockTime;
478 
479     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
480 
481     /**
482      * @dev Initializes the contract setting the deployer as the initial owner.
483      */
484     constructor () internal {
485         address msgSender = _msgSender();
486         _owner = msgSender;
487         emit OwnershipTransferred(address(0), msgSender);
488     }
489     
490     /**
491      * @dev Returns the address of the current owner.
492      */
493     function owner() public view returns (address) {
494         return _owner;
495     }
496 
497     /**
498      * @dev Throws if called by any account other than the owner.
499      */
500     modifier onlyOwner() {
501         require(_owner == _msgSender(), "Ownable: caller is not the owner");
502         _;
503     }
504 
505      /**
506      * @dev Leaves the contract without owner. It will not be possible to call
507      * `onlyOwner` functions anymore. Can only be called by the current owner.
508      *
509      * NOTE: Renouncing ownership will leave the contract without an owner,
510      * thereby removing any functionality that is only available to the owner.
511      */
512     function renounceOwnership() public virtual onlyOwner {
513         emit OwnershipTransferred(_owner, address(0));
514         _owner = address(0);
515     }
516 
517     /**
518      * @dev Transfers ownership of the contract to a new account (`newOwner`).
519      * Can only be called by the current owner.
520      */
521     function transferOwnership(address newOwner) public virtual onlyOwner {
522         require(newOwner != address(0), "Ownable: new owner is the zero address");
523         emit OwnershipTransferred(_owner, newOwner);
524         _owner = newOwner;
525     }
526 
527     function geUnlockTime() public view returns (uint256) {
528         return _lockTime;
529     }
530 
531     //Locks the contract for owner for the amount of time provided
532     function lock(uint256 time) public virtual onlyOwner {
533         _previousOwner = _owner;
534         _owner = address(0);
535         _lockTime = now + time;
536         emit OwnershipTransferred(_owner, address(0));
537     }
538     
539     //Unlocks the contract for owner when _lockTime is exceeds
540     function unlock() public virtual {
541         require(_previousOwner == msg.sender, "You don't have permission to unlock");
542         require(now > _lockTime , "Contract is locked until 7 days");
543         emit OwnershipTransferred(_owner, _previousOwner);
544         _owner = _previousOwner;
545     }
546 }
547 
548 // pragma solidity >=0.5.0;
549 
550 interface IUniswapV2Factory {
551     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
552 
553     function feeTo() external view returns (address);
554     function feeToSetter() external view returns (address);
555 
556     function getPair(address tokenA, address tokenB) external view returns (address pair);
557     function allPairs(uint) external view returns (address pair);
558     function allPairsLength() external view returns (uint);
559 
560     function createPair(address tokenA, address tokenB) external returns (address pair);
561 
562     function setFeeTo(address) external;
563     function setFeeToSetter(address) external;
564 }
565 
566 
567 // pragma solidity >=0.5.0;
568 
569 interface IUniswapV2Pair {
570     event Approval(address indexed owner, address indexed spender, uint value);
571     event Transfer(address indexed from, address indexed to, uint value);
572 
573     function name() external pure returns (string memory);
574     function symbol() external pure returns (string memory);
575     function decimals() external pure returns (uint8);
576     function totalSupply() external view returns (uint);
577     function balanceOf(address owner) external view returns (uint);
578     function allowance(address owner, address spender) external view returns (uint);
579 
580     function approve(address spender, uint value) external returns (bool);
581     function transfer(address to, uint value) external returns (bool);
582     function transferFrom(address from, address to, uint value) external returns (bool);
583 
584     function DOMAIN_SEPARATOR() external view returns (bytes32);
585     function PERMIT_TYPEHASH() external pure returns (bytes32);
586     function nonces(address owner) external view returns (uint);
587 
588     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
589 
590     event Mint(address indexed sender, uint amount0, uint amount1);
591     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
592     event Swap(
593         address indexed sender,
594         uint amount0In,
595         uint amount1In,
596         uint amount0Out,
597         uint amount1Out,
598         address indexed to
599     );
600     event Sync(uint112 reserve0, uint112 reserve1);
601 
602     function MINIMUM_LIQUIDITY() external pure returns (uint);
603     function factory() external view returns (address);
604     function token0() external view returns (address);
605     function token1() external view returns (address);
606     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
607     function price0CumulativeLast() external view returns (uint);
608     function price1CumulativeLast() external view returns (uint);
609     function kLast() external view returns (uint);
610 
611     function mint(address to) external returns (uint liquidity);
612     function burn(address to) external returns (uint amount0, uint amount1);
613     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
614     function skim(address to) external;
615     function sync() external;
616 
617     function initialize(address, address) external;
618 }
619 
620 // pragma solidity >=0.6.2;
621 
622 interface IUniswapV2Router01 {
623     function factory() external pure returns (address);
624     function WETH() external pure returns (address);
625 
626     function addLiquidity(
627         address tokenA,
628         address tokenB,
629         uint amountADesired,
630         uint amountBDesired,
631         uint amountAMin,
632         uint amountBMin,
633         address to,
634         uint deadline
635     ) external returns (uint amountA, uint amountB, uint liquidity);
636     function addLiquidityETH(
637         address token,
638         uint amountTokenDesired,
639         uint amountTokenMin,
640         uint amountETHMin,
641         address to,
642         uint deadline
643     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
644     function removeLiquidity(
645         address tokenA,
646         address tokenB,
647         uint liquidity,
648         uint amountAMin,
649         uint amountBMin,
650         address to,
651         uint deadline
652     ) external returns (uint amountA, uint amountB);
653     function removeLiquidityETH(
654         address token,
655         uint liquidity,
656         uint amountTokenMin,
657         uint amountETHMin,
658         address to,
659         uint deadline
660     ) external returns (uint amountToken, uint amountETH);
661     function removeLiquidityWithPermit(
662         address tokenA,
663         address tokenB,
664         uint liquidity,
665         uint amountAMin,
666         uint amountBMin,
667         address to,
668         uint deadline,
669         bool approveMax, uint8 v, bytes32 r, bytes32 s
670     ) external returns (uint amountA, uint amountB);
671     function removeLiquidityETHWithPermit(
672         address token,
673         uint liquidity,
674         uint amountTokenMin,
675         uint amountETHMin,
676         address to,
677         uint deadline,
678         bool approveMax, uint8 v, bytes32 r, bytes32 s
679     ) external returns (uint amountToken, uint amountETH);
680     function swapExactTokensForTokens(
681         uint amountIn,
682         uint amountOutMin,
683         address[] calldata path,
684         address to,
685         uint deadline
686     ) external returns (uint[] memory amounts);
687     function swapTokensForExactTokens(
688         uint amountOut,
689         uint amountInMax,
690         address[] calldata path,
691         address to,
692         uint deadline
693     ) external returns (uint[] memory amounts);
694     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
695         external
696         payable
697         returns (uint[] memory amounts);
698     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
699         external
700         returns (uint[] memory amounts);
701     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
702         external
703         returns (uint[] memory amounts);
704     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
705         external
706         payable
707         returns (uint[] memory amounts);
708 
709     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
710     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
711     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
712     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
713     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
714 }
715 
716 
717 
718 // pragma solidity >=0.6.2;
719 
720 interface IUniswapV2Router02 is IUniswapV2Router01 {
721     function removeLiquidityETHSupportingFeeOnTransferTokens(
722         address token,
723         uint liquidity,
724         uint amountTokenMin,
725         uint amountETHMin,
726         address to,
727         uint deadline
728     ) external returns (uint amountETH);
729     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
730         address token,
731         uint liquidity,
732         uint amountTokenMin,
733         uint amountETHMin,
734         address to,
735         uint deadline,
736         bool approveMax, uint8 v, bytes32 r, bytes32 s
737     ) external returns (uint amountETH);
738 
739     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
740         uint amountIn,
741         uint amountOutMin,
742         address[] calldata path,
743         address to,
744         uint deadline
745     ) external;
746     function swapExactETHForTokensSupportingFeeOnTransferTokens(
747         uint amountOutMin,
748         address[] calldata path,
749         address to,
750         uint deadline
751     ) external payable;
752     function swapExactTokensForETHSupportingFeeOnTransferTokens(
753         uint amountIn,
754         uint amountOutMin,
755         address[] calldata path,
756         address to,
757         uint deadline
758     ) external;
759 }
760 
761 
762 contract SuperMegaHyperDoge is Context, IERC20, Ownable {
763     using SafeMath for uint256;
764     using Address for address;
765 
766     mapping (address => uint256) private _rOwned;
767     mapping (address => uint256) private _tOwned;
768     mapping (address => mapping (address => uint256)) private _allowances;
769 
770     mapping (address => bool) private _isExcludedFromFee;
771 
772     mapping (address => bool) private _isExcluded;
773     address[] private _excluded;
774    
775     uint256 private constant MAX = ~uint256(0);
776     uint256 private _tTotal = 4200 * 10**6 * 10**9;
777     uint256 private _rTotal = (MAX - (MAX % _tTotal));
778     uint256 private _tFeeTotal;
779 
780     string private _name = "SuperMegaHyperDoge";
781     string private _symbol = "SMHDoge";
782     uint8 private _decimals = 9;
783     
784     uint256 public _taxFee = 0;
785     uint256 private _previousTaxFee = _taxFee;
786     
787     uint256 public _liquidityFee = 4;
788     uint256 private _previousLiquidityFee = _liquidityFee;
789 
790     uint256 public _marketingFee = 6; // All taxes are divided by 100 for more accuracy.
791     uint256 private _previousMarketingFee = _marketingFee;    
792 
793     IUniswapV2Router02 public immutable uniswapV2Router;
794     address public immutable uniswapV2Pair;
795     
796     address public burnAddress = 0x000000000000000000000000000000000000dEaD;
797     address payable private _marketingWallet;
798 
799     bool inSwapAndLiquify;
800     bool public swapAndLiquifyEnabled = true;
801     
802     uint256 public _maxTxAmount = 42 * 10**6 * 10**9;
803     uint256 private numTokensSellToAddToLiquidity = 2.1 * 10**6 * 10**9;
804     
805     event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
806     event SwapAndLiquifyEnabledUpdated(bool enabled);
807     event SwapAndLiquify(
808         uint256 tokensSwapped,
809         uint256 ethReceived,
810         uint256 tokensIntoLiqudity
811     );
812     
813     modifier lockTheSwap {
814         inSwapAndLiquify = true;
815         _;
816         inSwapAndLiquify = false;
817     }
818     
819     constructor (address marketingWallet) public {
820         _rOwned[_msgSender()] = _rTotal;
821         
822         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
823          // Create a uniswap pair for this new token
824         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
825             .createPair(address(this), _uniswapV2Router.WETH());
826 
827         // set the rest of the contract variables
828         uniswapV2Router = _uniswapV2Router;
829         _marketingWallet = payable(marketingWallet);
830         
831         //exclude owner and this contract from fee
832         _isExcludedFromFee[owner()] = true;
833         _isExcludedFromFee[address(this)] = true;
834         
835         emit Transfer(address(0), _msgSender(), _tTotal);
836     }
837 
838     function name() public view returns (string memory) {
839         return _name;
840     }
841 
842     function symbol() public view returns (string memory) {
843         return _symbol;
844     }
845 
846     function decimals() public view returns (uint8) {
847         return _decimals;
848     }
849 
850     function totalSupply() public view override returns (uint256) {
851         return _tTotal;
852     }
853 
854     function balanceOf(address account) public view override returns (uint256) {
855         if (_isExcluded[account]) return _tOwned[account];
856         return tokenFromReflection(_rOwned[account]);
857     }
858 
859     function transfer(address recipient, uint256 amount) public override returns (bool) {
860         _transfer(_msgSender(), recipient, amount);
861         return true;
862     }
863 
864     function allowance(address owner, address spender) public view override returns (uint256) {
865         return _allowances[owner][spender];
866     }
867 
868     function approve(address spender, uint256 amount) public override returns (bool) {
869         _approve(_msgSender(), spender, amount);
870         return true;
871     }
872 
873     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
874         _transfer(sender, recipient, amount);
875         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
876         return true;
877     }
878 
879     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
880         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
881         return true;
882     }
883 
884     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
885         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
886         return true;
887     }
888 
889     function isExcludedFromReward(address account) public view returns (bool) {
890         return _isExcluded[account];
891     }
892 
893     function numTokensSellToAddToLiquidityAmount() public view returns (uint256) {
894         return numTokensSellToAddToLiquidity;
895     }
896 
897     function totalFees() public view returns (uint256) {
898         return _tFeeTotal;
899     }
900 
901     function deliver(uint256 tAmount) public {
902         address sender = _msgSender();
903         require(!_isExcluded[sender], "Excluded addresses cannot call this function");
904         (uint256 rAmount,,,,,) = _getValues(tAmount);
905         _rOwned[sender] = _rOwned[sender].sub(rAmount);
906         _rTotal = _rTotal.sub(rAmount);
907         _tFeeTotal = _tFeeTotal.add(tAmount);
908     }
909 
910     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
911         require(tAmount <= _tTotal, "Amount must be less than supply");
912         if (!deductTransferFee) {
913             (uint256 rAmount,,,,,) = _getValues(tAmount);
914             return rAmount;
915         } else {
916             (,uint256 rTransferAmount,,,,) = _getValues(tAmount);
917             return rTransferAmount;
918         }
919     }
920 
921     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
922         require(rAmount <= _rTotal, "Amount must be less than total reflections");
923         uint256 currentRate =  _getRate();
924         return rAmount.div(currentRate);
925     }
926 
927     function excludeFromReward(address account) public onlyOwner() {
928         // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');
929         require(!_isExcluded[account], "Account is already excluded");
930         if(_rOwned[account] > 0) {
931             _tOwned[account] = tokenFromReflection(_rOwned[account]);
932         }
933         _isExcluded[account] = true;
934         _excluded.push(account);
935     }
936 
937     function includeInReward(address account) external onlyOwner() {
938         require(_isExcluded[account], "Account is already excluded");
939         for (uint256 i = 0; i < _excluded.length; i++) {
940             if (_excluded[i] == account) {
941                 _excluded[i] = _excluded[_excluded.length - 1];
942                 _tOwned[account] = 0;
943                 _isExcluded[account] = false;
944                 _excluded.pop();
945                 break;
946             }
947         }
948     }
949         function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
950         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);
951         _tOwned[sender] = _tOwned[sender].sub(tAmount);
952         _rOwned[sender] = _rOwned[sender].sub(rAmount);
953         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
954         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        
955         _takeLiquidity(tLiquidity);
956         _reflectFee(rFee, tFee);
957         emit Transfer(sender, recipient, tTransferAmount);
958     }
959     
960         function excludeFromFee(address account) public onlyOwner {
961         _isExcludedFromFee[account] = true;
962     }
963     
964     function includeInFee(address account) public onlyOwner {
965         _isExcludedFromFee[account] = false;
966     }
967     
968     function setTaxFeePercent(uint256 taxFee) external onlyOwner() {
969         _taxFee = taxFee;
970     }
971     
972     function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {
973         _liquidityFee = liquidityFee;
974     }
975 
976     function setMarketingFeePercent(uint256 marketingFee) external onlyOwner() {
977         _marketingFee = marketingFee;
978     }    
979    
980     function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
981         _maxTxAmount = _tTotal.mul(maxTxPercent).div(
982             10**2
983         );
984     }
985 
986     function setMarketingWallet(address payable newWallet) external onlyOwner {
987         require(_marketingWallet != newWallet, "Wallet already set!");
988         _marketingWallet = payable(newWallet);
989     }
990 
991     function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
992         swapAndLiquifyEnabled = _enabled;
993         emit SwapAndLiquifyEnabledUpdated(_enabled);
994     }
995     
996      //to recieve ETH from uniswapV2Router when swaping
997     receive() external payable {}
998 
999     function _reflectFee(uint256 rFee, uint256 tFee) private {
1000         _rTotal = _rTotal.sub(rFee);
1001         _tFeeTotal = _tFeeTotal.add(tFee);
1002     }
1003 
1004     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
1005         (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);
1006         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());
1007         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);
1008     }
1009 
1010     function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {
1011         uint256 tFee = calculateTaxFee(tAmount);
1012         uint256 tLiquidity = calculateLiquidityFee(tAmount);
1013         uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);
1014         return (tTransferAmount, tFee, tLiquidity);
1015     }
1016 
1017     function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
1018         uint256 rAmount = tAmount.mul(currentRate);
1019         uint256 rFee = tFee.mul(currentRate);
1020         uint256 rLiquidity = tLiquidity.mul(currentRate);
1021         uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);
1022         return (rAmount, rTransferAmount, rFee);
1023     }
1024 
1025     function _getRate() private view returns(uint256) {
1026         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
1027         return rSupply.div(tSupply);
1028     }
1029 
1030     function _getCurrentSupply() private view returns(uint256, uint256) {
1031         uint256 rSupply = _rTotal;
1032         uint256 tSupply = _tTotal;      
1033         for (uint256 i = 0; i < _excluded.length; i++) {
1034             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
1035             rSupply = rSupply.sub(_rOwned[_excluded[i]]);
1036             tSupply = tSupply.sub(_tOwned[_excluded[i]]);
1037         }
1038         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
1039         return (rSupply, tSupply);
1040     }
1041     
1042     function _takeLiquidity(uint256 tLiquidity) private {
1043         uint256 currentRate =  _getRate();
1044         uint256 rLiquidity = tLiquidity.mul(currentRate);
1045         _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
1046         if(_isExcluded[address(this)])
1047             _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
1048     }
1049     
1050     function calculateTaxFee(uint256 _amount) private view returns (uint256) {
1051         return _amount.mul(_taxFee).div(
1052             10**2
1053         );
1054     }
1055 
1056     function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
1057         return _amount.mul(_liquidityFee.add(_marketingFee)).div(
1058             10**2
1059         );
1060     }
1061     
1062     function removeAllFee() private {
1063         if(_taxFee == 0 && _liquidityFee == 0 && _marketingFee == 0) return;
1064         
1065         _previousTaxFee = _taxFee;
1066         _previousLiquidityFee = _liquidityFee;
1067         _previousMarketingFee = _marketingFee;
1068         
1069         _taxFee = 0;
1070         _liquidityFee = 0;
1071         _marketingFee = 0;
1072     }
1073     
1074     function restoreAllFee() private {
1075         _taxFee = _previousTaxFee;
1076         _liquidityFee = _previousLiquidityFee;
1077         _marketingFee = _previousMarketingFee;
1078     }
1079     
1080     function isExcludedFromFee(address account) public view returns(bool) {
1081         return _isExcludedFromFee[account];
1082     }
1083 
1084     function _approve(address owner, address spender, uint256 amount) private {
1085         require(owner != address(0), "ERC20: approve from the zero address");
1086         require(spender != address(0), "ERC20: approve to the zero address");
1087 
1088         _allowances[owner][spender] = amount;
1089         emit Approval(owner, spender, amount);
1090     }
1091 
1092     function _transfer(
1093         address from,
1094         address to,
1095         uint256 amount
1096     ) private {
1097         require(from != address(0), "ERC20: transfer from the zero address");
1098         require(to != address(0), "ERC20: transfer to the zero address");
1099         require(amount > 0, "Transfer amount must be greater than zero");
1100          // buy
1101         if (
1102             from == uniswapV2Pair &&
1103             to != address(uniswapV2Router) &&
1104             !_isExcludedFromFee[to]
1105         ) 
1106             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
1107 
1108         // is the token balance of this contract address over the min number of
1109         // tokens that we need to initiate a swap + liquidity lock?
1110         // also, don't get caught in a circular liquidity event.
1111         // also, don't swap & liquify if sender is uniswap pair.
1112         uint256 contractTokenBalance = balanceOf(address(this));
1113         // sell
1114         if (!inSwapAndLiquify && to == uniswapV2Pair) 
1115         if(contractTokenBalance >= _maxTxAmount)
1116         {
1117             contractTokenBalance = _maxTxAmount;
1118         }
1119         
1120         bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;
1121         if (
1122             overMinTokenBalance &&
1123             !inSwapAndLiquify &&
1124             from != uniswapV2Pair &&
1125             swapAndLiquifyEnabled
1126         ) {
1127             contractTokenBalance = numTokensSellToAddToLiquidity;
1128             //add liquidity
1129             swapAndLiquify(contractTokenBalance);
1130         }
1131         
1132         bool takeFee = false;
1133 
1134         //take fee only on swaps
1135         if (
1136             (from == uniswapV2Pair || to == uniswapV2Pair) &&
1137             !(_isExcludedFromFee[from] || _isExcludedFromFee[to])
1138         ) {
1139             takeFee = true;
1140         }
1141 
1142         _tokenTransfer(from, to, amount, takeFee);
1143     }
1144 
1145     function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
1146         if (_marketingFee + _liquidityFee == 0)
1147             return;
1148         uint256 toMarketing = contractTokenBalance.mul(_marketingFee).div(_marketingFee.add(_liquidityFee));
1149         uint256 toLiquify = contractTokenBalance.sub(toMarketing);
1150 
1151         // split the contract balance into halves
1152         uint256 half = toLiquify.div(2);
1153         uint256 otherHalf = toLiquify.sub(half);
1154 
1155         // capture the contract's current ETH balance.
1156         // this is so that we can capture exactly the amount of ETH that the
1157         // swap creates, and not make the liquidity event include any ETH that
1158         // has been manually sent to the contract
1159         uint256 initialBalance = address(this).balance;
1160 
1161         // swap tokens for ETH
1162         uint256 toSwapForEth = half.add(toMarketing);
1163         swapTokensForEth(toSwapForEth);
1164 
1165         // how much ETH did we just swap into?
1166         uint256 fromSwap = address(this).balance.sub(initialBalance);
1167         uint256 liquidityBalance = fromSwap.mul(half).div(toSwapForEth);
1168 
1169         addLiquidity(otherHalf, liquidityBalance);
1170 
1171         emit SwapAndLiquify(half, liquidityBalance, otherHalf);
1172 
1173         _marketingWallet.transfer(fromSwap.sub(liquidityBalance));
1174     }
1175 
1176     function swapTokensForEth(uint256 tokenAmount) private {
1177         // generate the uniswap pair path of token -> weth
1178         address[] memory path = new address[](2);
1179         path[0] = address(this);
1180         path[1] = uniswapV2Router.WETH();
1181 
1182         _approve(address(this), address(uniswapV2Router), tokenAmount);
1183 
1184         // make the swap
1185         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
1186             tokenAmount,
1187             0, // accept any amount of ETH
1188             path,
1189             address(this),
1190             block.timestamp
1191         );
1192     }
1193 
1194     function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
1195         // approve token transfer to cover all possible scenarios
1196         _approve(address(this), address(uniswapV2Router), tokenAmount);
1197 
1198         // add the liquidity
1199         uniswapV2Router.addLiquidityETH{value: ethAmount}(
1200             address(this),
1201             tokenAmount,
1202             0, // slippage is unavoidable
1203             0, // slippage is unavoidable
1204             _marketingWallet,
1205             block.timestamp
1206         );
1207     }
1208 
1209     //this method is responsible for taking all fee, if takeFee is true
1210     function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {
1211         if(!takeFee)
1212             removeAllFee();
1213         
1214         if (_isExcluded[sender] && !_isExcluded[recipient]) {
1215             _transferFromExcluded(sender, recipient, amount);
1216         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
1217             _transferToExcluded(sender, recipient, amount);
1218         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
1219             _transferStandard(sender, recipient, amount);
1220         } else if (_isExcluded[sender] && _isExcluded[recipient]) {
1221             _transferBothExcluded(sender, recipient, amount);
1222         } else {
1223             _transferStandard(sender, recipient, amount);
1224         }
1225         
1226         if(!takeFee)
1227             restoreAllFee();
1228     }
1229 
1230     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
1231         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);
1232         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1233         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1234         _takeLiquidity(tLiquidity);
1235         _reflectFee(rFee, tFee);
1236         emit Transfer(sender, recipient, tTransferAmount);
1237     }
1238 
1239     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
1240         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);
1241         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1242         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
1243         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           
1244         _takeLiquidity(tLiquidity);
1245         _reflectFee(rFee, tFee);
1246         emit Transfer(sender, recipient, tTransferAmount);
1247     }
1248 
1249     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
1250         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);
1251         _tOwned[sender] = _tOwned[sender].sub(tAmount);
1252         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1253         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   
1254         _takeLiquidity(tLiquidity);
1255         _reflectFee(rFee, tFee);
1256         emit Transfer(sender, recipient, tTransferAmount);
1257     }
1258     
1259     function setnumTokensSellToAddToLiquidity(uint256 _numTokensSellToAddToLiquidity) external onlyOwner() {
1260         numTokensSellToAddToLiquidity = _numTokensSellToAddToLiquidity;
1261     }
1262 
1263 
1264     // Withdraw ETH that gets stuck in contract by accident
1265     function emergencyWithdraw() external onlyOwner {
1266         payable(owner()).transfer(address(this).balance);
1267     }
1268 }