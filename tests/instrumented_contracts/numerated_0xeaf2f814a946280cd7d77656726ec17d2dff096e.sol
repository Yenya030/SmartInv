1 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
2 // 口口口口口口口口口口口口口　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
3 // 口口口口口口口口口口口口　　　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
4 // 口口口口口口口口口口口　　　　口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
5 // 口口口口口口口口口口　　　　口口口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
6 // 口口口口口口口口口口　　　口口口口口口口　　　口口　　　　　　　口口口　　　　　　口口　　　　　　　　　口口口口口口口口口
7 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　口口　　　　　　口　　　　　　　　　　口口口口口口口口口
8 // 口口口口口口口口口　　　　口口口口口口口口口口　　　　口口口　　　口口　　　　口口口　　　口口　　　　　口口口口口口口口口
9 // 口口口口口口口口口　　　　口口口口口口口口口口口口口口口口口　　　口口　　　口口口　　　　口口口　　　　口口口口口口口口口
10 // 口口口口口口口口口　　　　口口口口口口口口口口口口　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
11 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
12 // 口口口口口口口口口口　　　口口口口口口口　　　　　　　口口口　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
13 // 口口口口口口口口口口　　　　口口口口口　　　　　　　口口口口　　　　口　　　口口口　　　　口口口　　　　口口口口口口口口口
14 // 口口口口口口口口口口口　　　　口口口　　　　口　　　　口口　　　　　口　　　口口口　　　　口口　　　　　口口口口口口口口口
15 // 口口口口口口口口口口口口　　　　　　　　　　口口　　　　　　　　　　口　　　口口口口　　　　　　　　　　口口口口口口口口口
16 // 口口口口口口口口口口口口口　　　　　　　口口口口口　　　　　　　　　口　　　口口口口口　　　　　　　　　口口口口口口口口口
17 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
18 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
19 // 口口口　　　　口口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
20 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
21 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
22 // 口口口　　　　　口口口口　　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
23 // 口口口　　　　　　口口口　　　　　　口口口　　　　　　　口口口　　　口口　　　　口口口　　　　　　口口口　　　　　　口口口
24 // 口口口　　　　　　口口口　　　　　　口口　　　　　　　　　口口　　　口　　　　口口　　　　　　　　　口口　　　　　　口口口
25 // 口口口　　　　　　口口　　　　　　　口　　　　口口口　　　口口　　　　　　　口口口　　　口口口　　　　口　　　　口口口口口
26 // 口口口　　　　　　　口　　　　　　　口口口口口口口口　　　口口　　　　　　口口口　　　　口口口口　　　口　　　口口口口口口
27 // 口口口　　　口　　　口　　　　　　　口口口　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
28 // 口口口　　　口　　　口　　　　　　　口口　　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
29 // 口口口　　　口　　　　　　口　　　　口　　　　口口口　　　　口　　　　　　　口口　　　口口口口口口口口口　　　口口口口口口
30 // 口口口　　　口口　　　　　口　　　　口　　　口口口口　　　　口　　　口　　　　口　　　　口口口口口口口口　　　口口口口口口
31 // 口口口　　　口口　　　　　口　　　　口　　　　口口　　　　　口　　　口口　　　口口　　　　口口　　　　口　　　口口口口口口
32 // 口口口　　　口口　　　　口口　　　　口口　　　　　　　　　　口　　　口口　　　　口　　　　　　　　　口口　　　口口口口口口
33 // 口口口　　　口口口　　　口口　　　　口口口　　　　　　　　　口　　　口口口　　　　口口　　　　　　口口口　　　口口口口口口
34 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
35 
36 
37 pragma solidity ^0.4.24;
38 
39 /**
40  * @title SafeMath
41  * @dev Math operations with safety checks that throw on error
42  */
43 library SafeMath {
44     /**
45     * @dev Multiplies two numbers, throws on overflow.
46     */
47     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
48         if (a == 0) {
49             return 0;
50         }
51         c = a * b;
52         assert(c / a == b);
53         return c;
54     }
55 
56     /**
57     * @dev Integer division of two numbers, truncating the quotient.
58     */
59     function div(uint256 a, uint256 b) internal pure returns (uint256) {
60         return a / b;
61     }
62 
63     /**
64     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
65     */
66     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
67         assert(b <= a);
68         return a - b;
69     }
70 
71     /**
72     * @dev Adds two numbers, throws on overflow.
73     */
74     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
75         c = a + b;
76         assert(c >= a);
77         return c;
78     }
79 }
80 
81 /**
82  * @title Ownable
83  * @dev The Ownable contract has an owner address, and provides basic authorization control
84  * functions, this simplifies the implementation of "user permissions".
85  */
86 contract Ownable {
87     address public owner;
88     address public newOwner;
89 
90     event OwnershipTransferred(address indexed _from, address indexed _to);
91 
92     constructor() public {
93         owner = msg.sender;
94     }
95 
96     modifier onlyOwner {
97         require(msg.sender == owner);
98         _;
99     }
100 
101     function transferOwnership(address _newOwner) public onlyOwner {
102         newOwner = _newOwner;
103     }
104 
105     function acceptOwnership() public {
106         require(msg.sender == newOwner);
107         emit OwnershipTransferred(owner, newOwner);
108         owner = newOwner;
109         newOwner = address(0);
110     }
111 }
112 
113 /**
114  * @title Pausable
115  * @dev Base contract which allows children to implement an emergency stop mechanism.
116  */
117 contract Pausable is Ownable {
118     event Pause();
119     event Unpause();
120 
121     bool public paused = false;
122 
123     /**
124      * @dev modifier to allow actions only when the contract IS paused
125      */
126     modifier whenNotPaused() {
127         require(!paused);
128         _;
129     }
130 
131     /**
132      * @dev modifier to allow actions only when the contract IS NOT paused
133      */
134     modifier whenPaused {
135         require(paused);
136         _;
137     }
138 
139     /**
140      * @dev called by the owner to pause, triggers stopped state
141      */
142     function pause() onlyOwner whenNotPaused public returns (bool) {
143         paused = true;
144         emit Pause();
145         return true;
146     }
147 
148     /**
149      * @dev called by the owner to unpause, returns to normal state
150      */
151     function unpause() onlyOwner whenPaused public returns (bool) {
152         paused = false;
153         emit Unpause();
154         return true;
155     }
156 }
157 
158 // ----------------------------------------------------------------------------
159 // ERC Token Standard #20 Interface
160 // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
161 // ----------------------------------------------------------------------------
162 contract ERC20Interface {
163     function totalSupply() public constant returns (uint);
164     function balanceOf(address tokenOwner) public constant returns (uint);
165     function allowance(address tokenOwner, address spender) public constant returns (uint);
166     function transfer(address to, uint tokens) public returns (bool);
167     function approve(address spender, uint tokens) public returns (bool);
168     function transferFrom(address from, address to, uint tokens) public returns (bool);
169 
170     function name() public constant returns (string);
171     function symbol() public constant returns (string);
172     function decimals() public constant returns (uint8);
173 
174     event Transfer(address indexed from, address indexed to, uint tokens);
175     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
176 }
177 
178 /**
179 * ERC223 token by Dexaran
180 * New ERC223 contract interface
181 * https://github.com/Dexaran/ERC223-token-standard
182 */
183 contract ERC223 is ERC20Interface {
184     function transfer(address to, uint value, bytes data) public returns (bool);
185 
186     event Transfer(address indexed from, address indexed to, uint tokens);
187     event Transfer(address indexed from, address indexed to, uint value, bytes data);
188 }
189 
190 /**
191 * @title Contract that will work with ERC223 tokens.
192 */
193 contract ERC223ReceivingContract {
194     /**
195      * @dev Standard ERC223 function that will handle incoming token transfers.
196      * @param _from  Token sender address.
197      * @param _value Amount of tokens.
198      * @param _data  Transaction metadata.
199      */
200     function tokenFallback(address _from, uint _value, bytes _data) public;
201     function doTransfer(address _to, uint256 _index) public returns (uint256 price, address owner);
202 }
203 
204 contract CardMakerCake is ERC223, Pausable {
205 
206     using SafeMath for uint256;
207 
208     mapping(address => uint) balances;
209     mapping(address => mapping(address => uint)) internal allowed;
210 
211     string public name;
212     string public symbol;
213     uint8 public decimals;
214     uint256 public totalSupply;
215 
216     // EIP1046/1047
217     string private tokenURI_ = "";
218 
219     event Burn(address indexed burner, uint256 value);
220 
221     constructor() public {
222         tokenURI_ = "cardmaker.io";
223         name = "CardMaker Alchemists Knowledge Energy (CardMaker Token)";
224         symbol = "CAKE";
225         decimals = 18;
226         totalSupply = 10000 * 10000 * 50 * 10 ** uint(decimals);
227         balances[msg.sender] = totalSupply;
228     }
229 
230     function tokenURI() external view returns (string) {
231         return tokenURI_;
232     }
233 
234     // Function to access name of token .
235     function name() public constant returns (string) {
236         return name;
237     }
238     // Function to access symbol of token .
239     function symbol() public constant returns (string) {
240         return symbol;
241     }
242     // Function to access decimals of token .
243     function decimals() public constant returns (uint8) {
244         return decimals;
245     }
246     // Function to access total supply of tokens .
247     function totalSupply() public constant returns (uint256) {
248         return totalSupply;
249     }
250 
251     // Function that is called when a user or another contract wants to transfer funds .
252     function transfer(address _to, uint _value, bytes _data) public whenNotPaused returns (bool) {
253         if(isContract(_to)) {
254             return transferToContract(_to, _value, _data);
255         } else {
256             return transferToAddress(_to, _value, _data);
257         }
258     }
259 
260     // Standard function transfer similar to ERC20 transfer with no _data .
261     // Added due to backwards compatibility reasons .
262     function transfer(address _to, uint _value) public whenNotPaused returns (bool) {
263         bytes memory empty;
264         if(isContract(_to)) {
265             return transferToContract(_to, _value, empty);
266         } else {
267             return transferToAddress(_to, _value, empty);
268         }
269     }
270 
271     //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
272     function isContract(address _addr) private view returns (bool) {
273         uint length;
274         assembly {
275         //retrieve the size of the code on target address, this needs assembly
276             length := extcodesize(_addr)
277         }
278         return (length>0);
279     }
280 
281     //function that is called when transaction target is an address
282     function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {
283         if (balanceOf(msg.sender) < _value) revert();
284         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
285         balances[_to] = balanceOf(_to).add(_value);
286         emit Transfer(msg.sender, _to, _value);
287         emit Transfer(msg.sender, _to, _value, _data);
288         return true;
289     }
290 
291     //function that is called when transaction target is a contract
292     function transferToContract(address _to, uint _value, bytes _data) private returns (bool) {
293 
294         ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
295         uint256 price;
296         address owner;
297         (price, owner) = receiver.doTransfer(msg.sender, bytesToUint(_data));
298 
299         if (balanceOf(msg.sender) < price) revert();
300         balances[msg.sender] = balanceOf(msg.sender).sub(price);
301         balances[owner] = balanceOf(owner).add(price);
302         receiver.tokenFallback(msg.sender, price, _data);
303         emit Transfer(msg.sender, _to, _value);
304         emit Transfer(msg.sender, _to, _value, _data);
305         return true;
306     }
307 
308     function balanceOf(address _owner) public constant returns (uint) {
309         return balances[_owner];
310     }
311 
312     function allowance(address _tokenOwner, address _spender) public constant returns (uint) {
313         return allowed[_tokenOwner][_spender];
314     }
315 
316     function burn(uint256 _value) public returns (bool) {
317         require (_value > 0);
318         // Check if the sender has enough
319         require (balanceOf(msg.sender) >= _value);
320         // Subtract from the sender
321         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
322         // Updates totalSupply
323         totalSupply = totalSupply.sub(_value);
324         emit Burn(msg.sender, _value);
325         return true;
326     }
327 
328     function bytesToUint(bytes b) private pure returns (uint result) {
329         uint i;
330         result = 0;
331         for (i = 0; i < b.length; i++) {
332             uint c = uint(b[i]);
333             if (c >= 48 && c <= 57) {
334                 result = result * 10 + (c - 48);
335             }
336         }
337     }
338 
339     function approve(address _spender, uint _tokens) public whenNotPaused returns (bool) {
340         allowed[msg.sender][_spender] = _tokens;
341         emit Approval(msg.sender, _spender, _tokens);
342         return true;
343     }
344 
345     function transferFrom(address _from, address _to, uint _tokens) public whenNotPaused returns (bool) {
346         require(_to != address(0));
347         require(_tokens <= balances[_from]);
348         require(_tokens <= allowed[_from][msg.sender]);
349 
350         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);
351         balances[_from] = balances[_from].sub(_tokens);
352         balances[_to] = balances[_to].add(_tokens);
353         emit Transfer(_from, _to, _tokens);
354         return true;
355     }
356 
357     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {
358         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));
359         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
360         return true;
361     }
362 
363     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool){
364         uint256 oldValue = allowed[msg.sender][_spender];
365         if (_subtractedValue > oldValue) {
366             allowed[msg.sender][_spender] = 0;
367         } else {
368             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
369         }
370         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
371         return true;
372     }
373 
374     // ------------------------------------------------------------------------
375     // Don't accept ETH
376     // ------------------------------------------------------------------------
377     function () public payable {
378         revert();
379     }
380 
381     // ------------------------------------------------------------------------
382     // Owner can transfer out any accidentally sent ERC20 tokens
383     // ------------------------------------------------------------------------
384     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool) {
385         return ERC20Interface(tokenAddress).transfer(owner, tokens);
386     }
387 }