1 pragma solidity ^0.4.21;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 
7 // File: contracts/library/SafeMath.sol
8 
9 /**
10  * @title Safe Math
11  *
12  * @dev Library for safe mathematical operations.
13  */
14 library SafeMath {
15     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
16         uint256 c = a * b;
17         assert(a == 0 || c / a == b);
18 
19         return c;
20     }
21 
22     function div(uint256 a, uint256 b) internal pure returns (uint256) {
23         uint256 c = a / b;
24 
25         return c;
26     }
27 
28     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
29         assert(b <= a);
30 
31         return a - b;
32     }
33 
34     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
35         uint256 c = a + b;
36         assert(c >= a);
37 
38         return c;
39     }
40 }
41 
42 // File: contracts/token/ERC20Token.sol
43 
44 /**
45  * @dev The standard ERC20 Token contract base.
46  */
47 contract ERC20Token {
48     uint256 public totalSupply;  /* shorthand for public function and a property */
49     
50     function balanceOf(address _owner) public view returns (uint256 balance);
51     function transfer(address _to, uint256 _value) public returns (bool success);
52     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
53     function approve(address _spender, uint256 _value) public returns (bool success);
54     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
55 
56     event Transfer(address indexed _from, address indexed _to, uint256 _value);
57     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
58 }
59 
60 // File: contracts/token/StandardToken.sol
61 
62 /**
63  * @title Standard Token
64  *
65  * @dev The standard abstract implementation of the ERC20 interface.
66  */
67 contract StandardToken is ERC20Token {
68     using SafeMath for uint256;
69 
70     string public name;
71     string public symbol;
72     uint8 public decimals;
73     
74     mapping (address => uint256) balances;
75     mapping (address => mapping (address => uint256)) internal allowed;
76     
77     /**
78      * @dev The constructor assigns the token name, symbols and decimals.
79      */
80     constructor(string _name, string _symbol, uint8 _decimals) internal {
81         name = _name;
82         symbol = _symbol;
83         decimals = _decimals;
84     }
85 
86     /**
87      * @dev Get the balance of an address.
88      *
89      * @param _address The address which's balance will be checked.
90      *
91      * @return The current balance of the address.
92      */
93     function balanceOf(address _address) public view returns (uint256 balance) {
94         return balances[_address];
95     }
96 
97     /**
98      * @dev Checks the amount of tokens that an owner allowed to a spender.
99      *
100      * @param _owner The address which owns the funds allowed for spending by a third-party.
101      * @param _spender The third-party address that is allowed to spend the tokens.
102      *
103      * @return The number of tokens available to `_spender` to be spent.
104      */
105     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
106         return allowed[_owner][_spender];
107     }
108 
109     /**
110      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
111      * E.g. You place a buy or sell order on an exchange and in that example, the 
112      * `_spender` address is the address of the contract the exchange created to add your token to their 
113      * website and you are `msg.sender`.
114      *
115      * @param _spender The address which will spend the funds.
116      * @param _value The amount of tokens to be spent.
117      *
118      * @return Whether the approval process was successful or not.
119      */
120     function approve(address _spender, uint256 _value) public returns (bool) {
121         allowed[msg.sender][_spender] = _value;
122 
123         emit Approval(msg.sender, _spender, _value);
124 
125         return true;
126     }
127 
128     /**
129      * @dev Transfers `_value` number of tokens to the `_to` address.
130      *
131      * @param _to The address of the recipient.
132      * @param _value The number of tokens to be transferred.
133      */
134     function transfer(address _to, uint256 _value) public returns (bool) {
135         executeTransfer(msg.sender, _to, _value);
136 
137         return true;
138     }
139 
140     /**
141      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
142      *
143      * @param _from The address which approved you to spend tokens on their behalf.
144      * @param _to The address where you want to send tokens.
145      * @param _value The number of tokens to be sent.
146      *
147      * @return Whether the transfer was successful or not.
148      */
149     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
150         require(_value <= allowed[_from][msg.sender]);
151         
152         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
153         executeTransfer(_from, _to, _value);
154 
155         return true;
156     }
157 
158     /**
159      * @dev Internal function that this reused by the transfer functions
160      */
161     function executeTransfer(address _from, address _to, uint256 _value) internal {
162         require(_to != address(0));
163         require(_value != 0 && _value <= balances[_from]);
164         
165         balances[_from] = balances[_from].minus(_value);
166         balances[_to] = balances[_to].plus(_value);
167 
168         emit Transfer(_from, _to, _value);
169     }
170 }
171 
172 // File: contracts/token/MintableToken.sol
173 
174 /**
175  * @title Mintable Token
176  *
177  * @dev Allows the creation of new tokens.
178  */
179 contract MintableToken is StandardToken {
180     /// @dev The only address allowed to mint coins
181     address public minter;
182 
183     /// @dev Indicates whether the token is still mintable.
184     bool public mintingDisabled = false;
185 
186     /**
187      * @dev Event fired when minting is no longer allowed.
188      */
189     event MintingDisabled();
190 
191     /**
192      * @dev Allows a function to be executed only if minting is still allowed.
193      */
194     modifier canMint() {
195         require(!mintingDisabled);
196         _;
197     }
198 
199     /**
200      * @dev Allows a function to be called only by the minter
201      */
202     modifier onlyMinter() {
203         require(msg.sender == minter);
204         _;
205     }
206 
207     /**
208      * @dev The constructor assigns the minter which is allowed to mind and disable minting
209      */
210     constructor(address _minter) internal {
211         minter = _minter;
212     }
213 
214     /**
215     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
216     *
217     * @param _to The address which will receive the freshly minted tokens.
218     * @param _value The number of tokens that will be created.
219     */
220     function mint(address _to, uint256 _value) onlyMinter canMint public {
221         totalSupply = totalSupply.plus(_value);
222         balances[_to] = balances[_to].plus(_value);
223 
224         emit Transfer(0x0, _to, _value);
225     }
226 
227     /**
228     * @dev Disable the minting of new tokens. Cannot be reversed.
229     *
230     * @return Whether or not the process was successful.
231     */
232     function disableMinting() onlyMinter canMint public {
233         mintingDisabled = true;
234        
235         emit MintingDisabled();
236     }
237 }
238 
239 // File: contracts/token/BurnableToken.sol
240 
241 /**
242  * @title Burnable Token
243  *
244  * @dev Allows tokens to be destroyed.
245  */
246 contract BurnableToken is StandardToken {
247     /**
248      * @dev Event fired when tokens are burned.
249      *
250      * @param _from The address from which tokens will be removed.
251      * @param _value The number of tokens to be destroyed.
252      */
253     event Burn(address indexed _from, uint256 _value);
254 
255     /**
256      * @dev Burnes `_value` number of tokens.
257      *
258      * @param _value The number of tokens that will be burned.
259      */
260     function burn(uint256 _value) public {
261         require(_value != 0);
262 
263         address burner = msg.sender;
264         require(_value <= balances[burner]);
265 
266         balances[burner] = balances[burner].minus(_value);
267         totalSupply = totalSupply.minus(_value);
268 
269         emit Burn(burner, _value);
270         emit Transfer(burner, address(0), _value);
271     }
272 }
273 
274 // File: contracts/trait/HasOwner.sol
275 
276 /**
277  * @title HasOwner
278  *
279  * @dev Allows for exclusive access to certain functionality.
280  */
281 contract HasOwner {
282     // The current owner.
283     address public owner;
284 
285     // Conditionally the new owner.
286     address public newOwner;
287 
288     /**
289      * @dev The constructor.
290      *
291      * @param _owner The address of the owner.
292      */
293     constructor(address _owner) public {
294         owner = _owner;
295     }
296 
297     /** 
298      * @dev Access control modifier that allows only the current owner to call the function.
299      */
300     modifier onlyOwner {
301         require(msg.sender == owner);
302         _;
303     }
304 
305     /**
306      * @dev The event is fired when the current owner is changed.
307      *
308      * @param _oldOwner The address of the previous owner.
309      * @param _newOwner The address of the new owner.
310      */
311     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
312 
313     /**
314      * @dev Transfering the ownership is a two-step process, as we prepare
315      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
316      * the transfer. This prevents accidental lock-out if something goes wrong
317      * when passing the `newOwner` address.
318      *
319      * @param _newOwner The address of the proposed new owner.
320      */
321     function transferOwnership(address _newOwner) public onlyOwner {
322         newOwner = _newOwner;
323     }
324  
325     /**
326      * @dev The `newOwner` finishes the ownership transfer process by accepting the
327      * ownership.
328      */
329     function acceptOwnership() public {
330         require(msg.sender == newOwner);
331 
332         emit OwnershipTransfer(owner, newOwner);
333 
334         owner = newOwner;
335     }
336 }
337 
338 // File: contracts/token/PausableToken.sol
339 
340 /**
341  * @title Pausable Token
342  *
343  * @dev Allows you to pause/unpause transfers of your token.
344  **/
345 contract PausableToken is StandardToken, HasOwner {
346 
347     /// Indicates whether the token contract is paused or not.
348     bool public paused = false;
349 
350     /**
351      * @dev Event fired when the token contracts gets paused.
352      */
353     event Pause();
354 
355     /**
356      * @dev Event fired when the token contracts gets unpaused.
357      */
358     event Unpause();
359 
360     /**
361      * @dev Allows a function to be called only when the token contract is not paused.
362      */
363     modifier whenNotPaused() {
364         require(!paused);
365         _;
366     }
367 
368     /**
369      * @dev Pauses the token contract.
370      */
371     function pause() onlyOwner whenNotPaused public {
372         paused = true;
373         emit Pause();
374     }
375 
376     /**
377      * @dev Unpauses the token contract.
378      */
379     function unpause() onlyOwner public {
380         require(paused);
381 
382         paused = false;
383         emit Unpause();
384     }
385 
386     /// Overrides of the standard token's functions to add the paused/unpaused functionality.
387 
388     function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
389         return super.transfer(_to, _value);
390     }
391 
392     function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
393         return super.approve(_spender, _value);
394     }
395 
396     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
397         return super.transferFrom(_from, _to, _value);
398     }
399 }
400 
401 // File: contracts/fundraiser/AbstractFundraiser.sol
402 
403 contract AbstractFundraiser {
404     /// The ERC20 token contract.
405     ERC20Token public token;
406 
407     /**
408      * @dev The event fires every time a new buyer enters the fundraiser.
409      *
410      * @param _address The address of the buyer.
411      * @param _ethers The number of ethers funded.
412      * @param _tokens The number of tokens purchased.
413      */
414     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
415 
416 
417     /**
418      * @dev The initialization method for the token
419      *
420      * @param _token The address of the token of the fundraiser
421      */
422     function initializeFundraiserToken(address _token) internal
423     {
424         token = ERC20Token(_token);
425     }
426 
427     /**
428      * @dev The default function which is executed when someone sends funds to this contract address.
429      */
430     function() public payable {
431         receiveFunds(msg.sender, msg.value);
432     }
433 
434     /**
435      * @dev this overridable function returns the current conversion rate for the fundraiser
436      */
437     function getConversionRate() public view returns (uint256);
438 
439     /**
440      * @dev checks whether the fundraiser passed `endTime`.
441      *
442      * @return whether the fundraiser has ended.
443      */
444     function hasEnded() public view returns (bool);
445 
446     /**
447      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
448      *
449      * @param _address The address of the receiver of tokens.
450      * @param _amount The amount of received funds in ether.
451      */
452     function receiveFunds(address _address, uint256 _amount) internal;
453     
454     /**
455      * @dev It throws an exception if the transaction does not meet the preconditions.
456      */
457     function validateTransaction() internal view;
458     
459     /**
460      * @dev this overridable function makes and handles tokens to buyers
461      */
462     function handleTokens(address _address, uint256 _tokens) internal;
463 
464     /**
465      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
466      */
467     function handleFunds(address _address, uint256 _ethers) internal;
468 
469 }
470 
471 // File: contracts/fundraiser/BasicFundraiser.sol
472 
473 /**
474  * @title Basic Fundraiser
475  *
476  * @dev An abstract contract that is a base for fundraisers. 
477  * It implements a generic procedure for handling received funds:
478  * 1. Validates the transaciton preconditions
479  * 2. Calculates the amount of tokens based on the conversion rate.
480  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
481  * 4. Delegate the handling of the funds
482  * 5. Emit event for received funds
483  */
484 contract BasicFundraiser is HasOwner, AbstractFundraiser {
485     using SafeMath for uint256;
486 
487     // The number of decimals for the token.
488     uint8 constant DECIMALS = 18;  // Enforced
489 
490     // Decimal factor for multiplication purposes.
491     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
492 
493     /// The start time of the fundraiser - Unix timestamp.
494     uint256 public startTime;
495 
496     /// The end time of the fundraiser - Unix timestamp.
497     uint256 public endTime;
498 
499     /// The address where funds collected will be sent.
500     address public beneficiary;
501 
502     /// The conversion rate with decimals difference adjustment,
503     /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
504     uint256 public conversionRate;
505 
506     /// The total amount of ether raised.
507     uint256 public totalRaised;
508 
509     /**
510      * @dev The event fires when the number of token conversion rate has changed.
511      *
512      * @param _conversionRate The new number of tokens per 1 ether.
513      */
514     event ConversionRateChanged(uint _conversionRate);
515 
516     /**
517      * @dev The basic fundraiser initialization method.
518      *
519      * @param _startTime The start time of the fundraiser - Unix timestamp.
520      * @param _endTime The end time of the fundraiser - Unix timestamp.
521      * @param _conversionRate The number of tokens create for 1 ETH funded.
522      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
523      */
524     function initializeBasicFundraiser(
525         uint256 _startTime,
526         uint256 _endTime,
527         uint256 _conversionRate,
528         address _beneficiary
529     )
530         internal
531     {
532         require(_endTime >= _startTime);
533         require(_conversionRate > 0);
534         require(_beneficiary != address(0));
535 
536         startTime = _startTime;
537         endTime = _endTime;
538         conversionRate = _conversionRate;
539         beneficiary = _beneficiary;
540     }
541 
542     /**
543      * @dev Sets the new conversion rate
544      *
545      * @param _conversionRate New conversion rate
546      */
547     function setConversionRate(uint256 _conversionRate) public onlyOwner {
548         require(_conversionRate > 0);
549 
550         conversionRate = _conversionRate;
551 
552         emit ConversionRateChanged(_conversionRate);
553     }
554 
555     /**
556      * @dev Sets The beneficiary of the fundraiser.
557      *
558      * @param _beneficiary The address of the beneficiary.
559      */
560     function setBeneficiary(address _beneficiary) public onlyOwner {
561         require(_beneficiary != address(0));
562 
563         beneficiary = _beneficiary;
564     }
565 
566     /**
567      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
568      *
569      * @param _address The address of the receiver of tokens.
570      * @param _amount The amount of received funds in ether.
571      */
572     function receiveFunds(address _address, uint256 _amount) internal {
573         validateTransaction();
574 
575         uint256 tokens = calculateTokens(_amount);
576         require(tokens > 0);
577 
578         totalRaised = totalRaised.plus(_amount);
579         handleTokens(_address, tokens);
580         handleFunds(_address, _amount);
581 
582         emit FundsReceived(_address, msg.value, tokens);
583     }
584 
585     /**
586      * @dev this overridable function returns the current conversion rate for the fundraiser
587      */
588     function getConversionRate() public view returns (uint256) {
589         return conversionRate;
590     }
591 
592     /**
593      * @dev this overridable function that calculates the tokens based on the ether amount
594      */
595     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
596         tokens = _amount.mul(getConversionRate());
597     }
598 
599     /**
600      * @dev It throws an exception if the transaction does not meet the preconditions.
601      */
602     function validateTransaction() internal view {
603         require(msg.value != 0);
604         require(now >= startTime && now < endTime);
605     }
606 
607     /**
608      * @dev checks whether the fundraiser passed `endtime`.
609      *
610      * @return whether the fundraiser is passed its deadline or not.
611      */
612     function hasEnded() public view returns (bool) {
613         return now >= endTime;
614     }
615 }
616 
617 // File: contracts/token/StandardMintableToken.sol
618 
619 contract StandardMintableToken is MintableToken {
620     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
621         StandardToken(_name, _symbol, _decimals)
622         MintableToken(_minter)
623         public
624     {
625     }
626 }
627 
628 // File: contracts/fundraiser/MintableTokenFundraiser.sol
629 
630 /**
631  * @title Fundraiser With Mintable Token
632  */
633 contract MintableTokenFundraiser is BasicFundraiser {
634     /**
635      * @dev The initialization method that creates a new mintable token.
636      *
637      * @param _name Token name
638      * @param _symbol Token symbol
639      * @param _decimals Token decimals
640      */
641     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
642         token = new StandardMintableToken(
643             address(this), // The fundraiser is the token minter
644             _name,
645             _symbol,
646             _decimals
647         );
648     }
649 
650     /**
651      * @dev Mint the specific amount tokens
652      */
653     function handleTokens(address _address, uint256 _tokens) internal {
654         MintableToken(token).mint(_address, _tokens);
655     }
656 }
657 
658 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
659 
660 /**
661  * @title GasPriceLimitFundraiser
662  *
663  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
664  */
665 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
666     uint256 public gasPriceLimit;
667 
668     event GasPriceLimitChanged(uint256 gasPriceLimit);
669 
670     /**
671      * @dev This function puts the initial gas limit
672      */
673     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
674         gasPriceLimit = _gasPriceLimit;
675     }
676 
677     /**
678      * @dev This function allows the owner to change the gas limit any time during the fundraiser
679      */
680     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
681         gasPriceLimit = _gasPriceLimit;
682 
683         emit GasPriceLimitChanged(_gasPriceLimit);
684     }
685 
686     /**
687      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
688      */
689     function validateTransaction() internal view {
690         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
691 
692         return super.validateTransaction();
693     }
694 }
695 
696 // File: contracts/fundraiser/ForwardFundsFundraiser.sol
697 
698 /**
699  * @title Forward Funds to Beneficiary Fundraiser
700  *
701  * @dev This contract forwards the funds received to the beneficiary.
702  */
703 contract ForwardFundsFundraiser is BasicFundraiser {
704     /**
705      * @dev Forward funds directly to beneficiary
706      */
707     function handleFunds(address, uint256 _ethers) internal {
708         // Forward the funds directly to the beneficiary
709         beneficiary.transfer(_ethers);
710     }
711 }
712 
713 // File: contracts/Fundraiser.sol
714 
715 /**
716  * @title RealDirectToken
717  */
718  
719 contract RealDirectToken is MintableToken, BurnableToken, PausableToken {
720   constructor(address _owner, address _minter)
721     StandardToken(
722       "Real Direct Token",   // Token name
723       "RDT", // Token symbol
724       18  // Token decimals
725     )
726     HasOwner(_owner)
727     MintableToken(_minter)
728     public
729   {
730   }
731 }
732 
733 
734 
735 /**
736  * @title RealDirectTokenFundraiser
737  */
738 
739 contract RealDirectTokenFundraiser is MintableTokenFundraiser, ForwardFundsFundraiser, GasPriceLimitFundraiser {
740   
741 
742   constructor()
743     HasOwner(msg.sender)
744     public
745   {
746     token = new RealDirectToken(
747       msg.sender,  // Owner
748       address(this)  // The fundraiser is the minter
749     );
750 
751     
752 
753     initializeBasicFundraiser(
754       1534291200, // Start date = 15 Aug 2018 00:00 UTC
755       1544918340,  // End date = 15 Dec 2018 23:59 UTC
756       20000, // Conversion rate = 20000 RDT per 1 ether
757       0xEcB3c79EB0A9f539340adE65e8823CE8d248fbad     // Beneficiary
758     );
759 
760     
761 
762     initializeGasPriceLimitFundraiser(
763         50000000000 // Gas price limit in wei
764     );
765 
766     
767 
768     
769 
770     
771     
772     
773   }
774   
775 }