1 /**
2 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKOxol:;'...              ...';:loxOKNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
3 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOdl;'.                                  .';ldOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
4 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxl,.         ..,;:cloodddxxxxdddoolc:;,..         .,lxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
5 MMMMMMMMMMMMMMMMMMMMMMMMMMMWXkl,.      ..,cldk0KXXXXXXXXXXXXXXXXXXXXXXXXK0kdlc,..      .,lkXWMMMMMMMMMMMMMMMMMMMMMMMMMMM
6 MMMMMMMMMMMMMMMMMMMMMMMMWXx:.      .,cdkKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKkdc,.      .:xXWMMMMMMMMMMMMMMMMMMMMMMMM
7 MMMMMMMMMMMMMMMMMMMMMMNk:.     .,lx0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0xl,.     .:kNMMMMMMMMMMMMMMMMMMMMMM
8 MMMMMMMMMMMMMMMMMMMWKo'     .;oOKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKOo;.     'o0WMMMMMMMMMMMMMMMMMMM
9 MMMMMMMMMMMMMMMMMWO:.    .;oOXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOo;.    .:OWMMMMMMMMMMMMMMMMM
10 MMMMMMMMMMMMMMMWO;.    .ckKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKkc.     ;OWMMMMMMMMMMMMMMM
11 MMMMMMMMMMMMMW0:.    'o0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0o'     :OWMMMMMMMMMMMMM
12 MMMMMMMMMMMMXl.    'dKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKd'    .lXMMMMMMMMMMMM
13 MMMMMMMMMMWk'    .o0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0o.    'kWMMMMMMMMMM
14 MMMMMMMMMXc.   .cOXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0c.   .cXMMMMMMMMM
15 MMMMMMMW0,    'xKXXXXXXXXXXXXXXXXXXXXXXX0d:,;cxKXXXXXXXXXXXXXXXXXXXXXXXXKxc;;:o0XXXXXXXXXXXXXXXXXXXXXXXKx'    ,OWMMMMMMM
16 MMMMMMWk.    :0XXXXXXXXXXXXXXXXXXXXXXXKd.      ,kXXXXXXXXXXXXXXXXXXXXXXk,      .dKXXXXXXXXXXXXXXXXXXXXXXX0:    .xWMMMMMM
17 MMMMMWd.   .oKXXXXXXXXXXXXXXXXXXXXXXXKo.        .xXXXXXXXXXXXXXXXXXXXXx.        .lKXXXXXXXXXXXXXXXXXXXXXXXKo.   .dWMMMMM
18 MMMMWd.   .dXXXXXXXXXXXXXXXXXXXXXXXXXd.          'OXXXXXXXXXXXXXXXXXXO'          .dXXXXXXXXXXXXXXXXXXXXXXXXXd.   .dWMMMM
19 MMMWx.   .dXXXXXXXXXXXXXXXXXXXXXXXXX0;            cKXXXXXXXXXXXXXXXXXl            ,0XXXXXXXXXXXXXXXXXXXXXXXXXx.   .dWMMM
20 MMMk.   .dXXXXXXXXXXXXXXXXXXXXXXXXXXx.            ,0XXXXXXXXXXXXXXXX0,            .xXXXXXXXXXXXXXXXXXXXXXXXXXXd.   .kMMM
21 MMK,   .oKXXXXXXXXXXXXXXXXXXXXXXXXXXo             .kXXXXXXXXXXXXXXXXk.             oXXXXXXXXXXXXXXXXXXXXXXXXXXXo.   ,0MM
22 MNc    :KXXXXXXXXXXXXXXXXXXXXXXXXXXXl             .xXXXXXXXXXXXXXXXXx.             lXXXXXXXXXXXXXXXXXXXXXXXXXXXK:    cNM
23 Mk.   'OXXXXXXXXXXXXXXXXXXXXXXXXXXXXo             .kXXXXXXXXXXXXXXXXk.             oXXXXXXXXXXXXXXXXXXXXXXXXXXXXO'   .xM
24 X:    oXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx.            ,0XXXXXXXXXXXXXXXX0,            .xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXo.   ;X
25 k.   ,OXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0;            lXXXXXXXXXXXXXXXXXXl            ;0XXXXXXXXXXXXXXXXXXXXXXXXXXXXX0,   .k
26 c    lXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx.          'OXXXXXXXXXXXXXXXXXXO,          .dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXl    c
27 ,   .kXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKo.        .xXXXXXXXXXXXXXXXXXXXXx.        .oKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXk.   '
28 .   ,0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKd'      ;kXXXXXXXXXXXXXXXXXXXXXXk;      'dKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0,   .
29     :KXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0dc;;cxKXXXXXXXXXXXXXXXXXXXXXXXXKxc;;cd0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXK:    
30     cXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXl    
31     lXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXl    
32     lXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXl    
33     cKXXXXXXXXXXXXXXXXXX0OKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0dx0XXXXXXXXXXXXXXXXXXc    
34 .   ;KXXXXXXXXXXXXXXKkl;..cKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXO,  .;okKXXXXXXXXXXXXXK;    
35 .   'OXXXXXXXXXXKOd:'      :0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx,.     ':oOKXXXXXXXXXO'   .
36 ;   .dXXXXXXXKxc,.     .,.  ;0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKko:.     .'o0XXXXXXXd.   ;
37 d    :KXXXXXX0:    .'cd0XO;  ,OXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKK0Okxdoc'     .lKXXXXXXK:    o
38 0'   .xXXXXXXX0:  .oKXXXXXO'  ,OXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx;...         ..oKXXXXXXXk.   '0
39 Wl    :KXXXXXXX0c  'kXXXXXk.   oXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXd.     ':clodxkO0XXXXXXXXK:    lW
40 MK,   .dXXXXXXXXKl  .cddl;.   .dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0c.     .;lkKXXXXXXXXXXXXXd.   ,0M
41 MWx.   'kXXXXXXXXKo.         'dKXXXKO0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOdxKXKOdc'.     .:xXXXXXXXXXXk'   .xWM
42 MMNl    ;0XXXXXXXXXkc'. ..'cd0XXXX0c..;okKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKkl;. .dXXXXXKko:.   .xXXXXXXXXX0;    lNMM
43 MMMX:    :0XXXXXXXXXXKOkk0KXXXXXX0:     .'cd0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXKOd:.  .,cx0KXXXXXXXXKklcxXXXXXXXXX0:    :XMMM
44 MMMMK;    :0XXXXXXXXXXXXXXXXXXXXO;    :l;.  .;lkKXXXXXXXXXXXXXXXXXXXXXXXOl,.  .:dO0xl,,xXXXXXXXXXXXXXXXXXXXX0:    ;KMMMM
45 MMMMMK;    ;OXXXXXXXXXXXXXXXXXXk,    .;dO0xc,. :0XXXX0xlc:;;;;:cld0XXXXXO;    :ko;.  .;xKXXXXXXXXXXXXXXXXXXO;    ;KMMMMM
46 MMMMMMK:    'kXXXXXXXXXXXXXXXXk'   .,'  .,lx0kx0XXXOc.   .....    .c0XXXX0:      .,cx0Od:;xXXXXXXXXXXXXXXXk'    ;KMMMMMM
47 MMMMMMMXc    .oKXXXXXXXXXXXXX0:    ,k0ko;. .lKXXXXO;   .lOKKKKk:,,,;xXXXXX0c    .d0xl,.  .oKXXXXXXXXXXXXKo.    cXMMMMMMM
48 MMMMMMMMNd.    ;kXXXXXXXXXXXXX0dc'.  ':dO0xoOXXXXXo.   cKXXKKx::::::dKXXXXXKl.   ..  .,lx0XXXXXXXXXXXXXO;    .dNMMMMMMMM
49 MMMMMMMMMW0;    .l0XXXXXXXXXXXXXXKOo:.  .,dKXXXXXXo.   cKXXK0l..    ,0XXXXXXKo.   ':dOXXXXXXXXXXXXXXX0l.    ;OWMMMMMMMMM
50 MMMMMMMMMMMNd.    'dKXXXXXXXXXXXXXXXX0xl,'dKXXXXXXO,   .:xO00kd;    ,0XXXXXXXXx:lkKXXXXXXXXXXXXXXXXKd'    .dNMMMMMMMMMMM
51 MMMMMMMMMMMMW0c.    'd0XXXXXXXXXXXXXXXXXKKXXXXXXXXXOc.    ....   .. ,0XXXXXXXXXXXXXXXXXXXXXXXXXXX0d,    .c0WMMMMMMMMMMMM
52 MMMMMMMMMMMMMMWO;     'lOXXXXXXXXXXXXXXXXXXXXXXXXXXXX0xolc::cclok0kokKXXXXXXXXXXXXXXXXXXXXXXXXXOo'     ;OWMMMMMMMMMMMMMM
53 MMMMMMMMMMMMMMMMWO:.    .:xKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKx:.    .:ONMMMMMMMMMMMMMMMM
54 MMMMMMMMMMMMMMMMMMW0c.     'ckKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKkl'     .c0WMMMMMMMMMMMMMMMMMM
55 MMMMMMMMMMMMMMMMMMMMMXd,.     'cd0XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX0xc'     .,dKWMMMMMMMMMMMMMMMMMMMM
56 MMMMMMMMMMMMMMMMMMMMMMMW0o,      .;lxOKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKOxl;.      ,l0NMMMMMMMMMMMMMMMMMMMMMMM
57 MMMMMMMMMMMMMMMMMMMMMMMMMMNOo;.      .':lxOKXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXKOxo:,.      .;oONMMMMMMMMMMMMMMMMMMMMMMMMMM
58 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKxc,.       ..,:codxO00KKXXXXXXXXXXKK00Oxdoc:,..       .,cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
59 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKko:'.          ....'',,,;;,,,''....          .':lkKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
60 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKkdl:,..                          ..,:ldkKNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
61 MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKOxl:,'..            ..',:lxOKNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
62 
63    #DEGEN Token features:
64    4% fee auto add to the liquidity pool
65    4% fee auto distribute to all holders
66    4% fee burn
67 
68 
69  */
70 
71 pragma solidity ^0.6.12;
72 // SPDX-License-Identifier: Unlicensed
73 interface IERC20 {
74 
75     function totalSupply() external view returns (uint256);
76 
77     /**
78      * @dev Returns the amount of tokens owned by `account`.
79      */
80     function balanceOf(address account) external view returns (uint256);
81 
82     /**
83      * @dev Moves `amount` tokens from the caller's account to `recipient`.
84      *
85      * Returns a boolean value indicating whether the operation succeeded.
86      *
87      * Emits a {Transfer} event.
88      */
89     function transfer(address recipient, uint256 amount) external returns (bool);
90 
91     /**
92      * @dev Returns the remaining number of tokens that `spender` will be
93      * allowed to spend on behalf of `owner` through {transferFrom}. This is
94      * zero by default.
95      *
96      * This value changes when {approve} or {transferFrom} are called.
97      */
98     function allowance(address owner, address spender) external view returns (uint256);
99 
100     /**
101      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
102      *
103      * Returns a boolean value indicating whether the operation succeeded.
104      *
105      * IMPORTANT: Beware that changing an allowance with this method brings the risk
106      * that someone may use both the old and the new allowance by unfortunate
107      * transaction ordering. One possible solution to mitigate this race
108      * condition is to first reduce the spender's allowance to 0 and set the
109      * desired value afterwards:
110      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
111      *
112      * Emits an {Approval} event.
113      */
114     function approve(address spender, uint256 amount) external returns (bool);
115 
116     /**
117      * @dev Moves `amount` tokens from `sender` to `recipient` using the
118      * allowance mechanism. `amount` is then deducted from the caller's
119      * allowance.
120      *
121      * Returns a boolean value indicating whether the operation succeeded.
122      *
123      * Emits a {Transfer} event.
124      */
125     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
126 
127     /**
128      * @dev Emitted when `value` tokens are moved from one account (`from`) to
129      * another (`to`).
130      *
131      * Note that `value` may be zero.
132      */
133     event Transfer(address indexed from, address indexed to, uint256 value);
134 
135     /**
136      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
137      * a call to {approve}. `value` is the new allowance.
138      */
139     event Approval(address indexed owner, address indexed spender, uint256 value);
140 }
141 
142 
143 
144 /**
145  * @dev Wrappers over Solidity's arithmetic operations with added overflow
146  * checks.
147  *
148  * Arithmetic operations in Solidity wrap on overflow. This can easily result
149  * in bugs, because programmers usually assume that an overflow raises an
150  * error, which is the standard behavior in high level programming languages.
151  * `SafeMath` restores this intuition by reverting the transaction when an
152  * operation overflows.
153  *
154  * Using this library instead of the unchecked operations eliminates an entire
155  * class of bugs, so it's recommended to use it always.
156  */
157 
158 library SafeMath {
159     /**
160      * @dev Returns the addition of two unsigned integers, reverting on
161      * overflow.
162      *
163      * Counterpart to Solidity's `+` operator.
164      *
165      * Requirements:
166      *
167      * - Addition cannot overflow.
168      */
169     function add(uint256 a, uint256 b) internal pure returns (uint256) {
170         uint256 c = a + b;
171         require(c >= a, "SafeMath: addition overflow");
172 
173         return c;
174     }
175 
176     /**
177      * @dev Returns the subtraction of two unsigned integers, reverting on
178      * overflow (when the result is negative).
179      *
180      * Counterpart to Solidity's `-` operator.
181      *
182      * Requirements:
183      *
184      * - Subtraction cannot overflow.
185      */
186     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
187         return sub(a, b, "SafeMath: subtraction overflow");
188     }
189 
190     /**
191      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
192      * overflow (when the result is negative).
193      *
194      * Counterpart to Solidity's `-` operator.
195      *
196      * Requirements:
197      *
198      * - Subtraction cannot overflow.
199      */
200     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
201         require(b <= a, errorMessage);
202         uint256 c = a - b;
203 
204         return c;
205     }
206 
207     /**
208      * @dev Returns the multiplication of two unsigned integers, reverting on
209      * overflow.
210      *
211      * Counterpart to Solidity's `*` operator.
212      *
213      * Requirements:
214      *
215      * - Multiplication cannot overflow.
216      */
217     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
218         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
219         // benefit is lost if 'b' is also tested.
220         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
221         if (a == 0) {
222             return 0;
223         }
224 
225         uint256 c = a * b;
226         require(c / a == b, "SafeMath: multiplication overflow");
227 
228         return c;
229     }
230 
231     /**
232      * @dev Returns the integer division of two unsigned integers. Reverts on
233      * division by zero. The result is rounded towards zero.
234      *
235      * Counterpart to Solidity's `/` operator. Note: this function uses a
236      * `revert` opcode (which leaves remaining gas untouched) while Solidity
237      * uses an invalid opcode to revert (consuming all remaining gas).
238      *
239      * Requirements:
240      *
241      * - The divisor cannot be zero.
242      */
243     function div(uint256 a, uint256 b) internal pure returns (uint256) {
244         return div(a, b, "SafeMath: division by zero");
245     }
246 
247     /**
248      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
249      * division by zero. The result is rounded towards zero.
250      *
251      * Counterpart to Solidity's `/` operator. Note: this function uses a
252      * `revert` opcode (which leaves remaining gas untouched) while Solidity
253      * uses an invalid opcode to revert (consuming all remaining gas).
254      *
255      * Requirements:
256      *
257      * - The divisor cannot be zero.
258      */
259     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
260         require(b > 0, errorMessage);
261         uint256 c = a / b;
262         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
263 
264         return c;
265     }
266 
267     /**
268      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
269      * Reverts when dividing by zero.
270      *
271      * Counterpart to Solidity's `%` operator. This function uses a `revert`
272      * opcode (which leaves remaining gas untouched) while Solidity uses an
273      * invalid opcode to revert (consuming all remaining gas).
274      *
275      * Requirements:
276      *
277      * - The divisor cannot be zero.
278      */
279     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
280         return mod(a, b, "SafeMath: modulo by zero");
281     }
282 
283     /**
284      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
285      * Reverts with custom message when dividing by zero.
286      *
287      * Counterpart to Solidity's `%` operator. This function uses a `revert`
288      * opcode (which leaves remaining gas untouched) while Solidity uses an
289      * invalid opcode to revert (consuming all remaining gas).
290      *
291      * Requirements:
292      *
293      * - The divisor cannot be zero.
294      */
295     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
296         require(b != 0, errorMessage);
297         return a % b;
298     }
299 }
300 
301 abstract contract Context {
302     function _msgSender() internal view virtual returns (address payable) {
303         return msg.sender;
304     }
305 
306     function _msgData() internal view virtual returns (bytes memory) {
307         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
308         return msg.data;
309     }
310 }
311 
312 
313 /**
314  * @dev Collection of functions related to the address type
315  */
316 library Address {
317     /**
318      * @dev Returns true if `account` is a contract.
319      *
320      * [IMPORTANT]
321      * ====
322      * It is unsafe to assume that an address for which this function returns
323      * false is an externally-owned account (EOA) and not a contract.
324      *
325      * Among others, `isContract` will return false for the following
326      * types of addresses:
327      *
328      *  - an externally-owned account
329      *  - a contract in construction
330      *  - an address where a contract will be created
331      *  - an address where a contract lived, but was destroyed
332      * ====
333      */
334     function isContract(address account) internal view returns (bool) {
335         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
336         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
337         // for accounts without code, i.e. `keccak256('')`
338         bytes32 codehash;
339         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
340         // solhint-disable-next-line no-inline-assembly
341         assembly { codehash := extcodehash(account) }
342         return (codehash != accountHash && codehash != 0x0);
343     }
344 
345     /**
346      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
347      * `recipient`, forwarding all available gas and reverting on errors.
348      *
349      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
350      * of certain opcodes, possibly making contracts go over the 2300 gas limit
351      * imposed by `transfer`, making them unable to receive funds via
352      * `transfer`. {sendValue} removes this limitation.
353      *
354      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
355      *
356      * IMPORTANT: because control is transferred to `recipient`, care must be
357      * taken to not create reentrancy vulnerabilities. Consider using
358      * {ReentrancyGuard} or the
359      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
360      */
361     function sendValue(address payable recipient, uint256 amount) internal {
362         require(address(this).balance >= amount, "Address: insufficient balance");
363 
364         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
365         (bool success, ) = recipient.call{ value: amount }("");
366         require(success, "Address: unable to send value, recipient may have reverted");
367     }
368 
369     /**
370      * @dev Performs a Solidity function call using a low level `call`. A
371      * plain`call` is an unsafe replacement for a function call: use this
372      * function instead.
373      *
374      * If `target` reverts with a revert reason, it is bubbled up by this
375      * function (like regular Solidity function calls).
376      *
377      * Returns the raw returned data. To convert to the expected return value,
378      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
379      *
380      * Requirements:
381      *
382      * - `target` must be a contract.
383      * - calling `target` with `data` must not revert.
384      *
385      * _Available since v3.1._
386      */
387     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
388         return functionCall(target, data, "Address: low-level call failed");
389     }
390 
391     /**
392      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
393      * `errorMessage` as a fallback revert reason when `target` reverts.
394      *
395      * _Available since v3.1._
396      */
397     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
398         return _functionCallWithValue(target, data, 0, errorMessage);
399     }
400 
401     /**
402      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
403      * but also transferring `value` wei to `target`.
404      *
405      * Requirements:
406      *
407      * - the calling contract must have an ETH balance of at least `value`.
408      * - the called Solidity function must be `payable`.
409      *
410      * _Available since v3.1._
411      */
412     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
413         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
414     }
415 
416     /**
417      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
418      * with `errorMessage` as a fallback revert reason when `target` reverts.
419      *
420      * _Available since v3.1._
421      */
422     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
423         require(address(this).balance >= value, "Address: insufficient balance for call");
424         return _functionCallWithValue(target, data, value, errorMessage);
425     }
426 
427     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
428         require(isContract(target), "Address: call to non-contract");
429 
430         // solhint-disable-next-line avoid-low-level-calls
431         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
432         if (success) {
433             return returndata;
434         } else {
435             // Look for revert reason and bubble it up if present
436             if (returndata.length > 0) {
437                 // The easiest way to bubble the revert reason is using memory via assembly
438 
439                 // solhint-disable-next-line no-inline-assembly
440                 assembly {
441                     let returndata_size := mload(returndata)
442                     revert(add(32, returndata), returndata_size)
443                 }
444             } else {
445                 revert(errorMessage);
446             }
447         }
448     }
449 }
450 
451 /**
452  * @dev Contract module which provides a basic access control mechanism, where
453  * there is an account (an owner) that can be granted exclusive access to
454  * specific functions.
455  *
456  * By default, the owner account will be the one that deploys the contract. This
457  * can later be changed with {transferOwnership}.
458  *
459  * This module is used through inheritance. It will make available the modifier
460  * `onlyOwner`, which can be applied to your functions to restrict their use to
461  * the owner.
462  */
463 contract Ownable is Context {
464     address private _owner;
465     address private _previousOwner;
466     uint256 private _lockTime;
467 
468     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
469 
470     /**
471      * @dev Initializes the contract setting the deployer as the initial owner.
472      */
473     constructor () internal {
474         address msgSender = _msgSender();
475         _owner = msgSender;
476         emit OwnershipTransferred(address(0), msgSender);
477     }
478 
479     /**
480      * @dev Returns the address of the current owner.
481      */
482     function owner() public view returns (address) {
483         return _owner;
484     }
485 
486     /**
487      * @dev Throws if called by any account other than the owner.
488      */
489     modifier onlyOwner() {
490         require(_owner == _msgSender(), "Ownable: caller is not the owner");
491         _;
492     }
493 
494     /**
495     * @dev Leaves the contract without owner. It will not be possible to call
496     * `onlyOwner` functions anymore. Can only be called by the current owner.
497     *
498     * NOTE: Renouncing ownership will leave the contract without an owner,
499     * thereby removing any functionality that is only available to the owner.
500     */
501     function renounceOwnership() public virtual onlyOwner {
502         emit OwnershipTransferred(_owner, address(0));
503         _owner = address(0);
504     }
505 
506     /**
507      * @dev Transfers ownership of the contract to a new account (`newOwner`).
508      * Can only be called by the current owner.
509      */
510     function transferOwnership(address newOwner) public virtual onlyOwner {
511         require(newOwner != address(0), "Ownable: new owner is the zero address");
512         emit OwnershipTransferred(_owner, newOwner);
513         _owner = newOwner;
514     }
515 
516     function geUnlockTime() public view returns (uint256) {
517         return _lockTime;
518     }
519 
520     //Locks the contract for owner for the amount of time provided
521     function lock(uint256 time) public virtual onlyOwner {
522         _previousOwner = _owner;
523         _owner = address(0);
524         _lockTime = now + time;
525         emit OwnershipTransferred(_owner, address(0));
526     }
527 
528     //Unlocks the contract for owner when _lockTime is exceeds
529     function unlock() public virtual {
530         require(_previousOwner == msg.sender, "You don't have permission to unlock");
531         require(now > _lockTime , "Contract is locked until 7 days");
532         emit OwnershipTransferred(_owner, _previousOwner);
533         _owner = _previousOwner;
534     }
535 }
536 
537 // pragma solidity >=0.5.0;
538 
539 interface IUniswapV2Factory {
540     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
541 
542     function feeTo() external view returns (address);
543     function feeToSetter() external view returns (address);
544 
545     function getPair(address tokenA, address tokenB) external view returns (address pair);
546     function allPairs(uint) external view returns (address pair);
547     function allPairsLength() external view returns (uint);
548 
549     function createPair(address tokenA, address tokenB) external returns (address pair);
550 
551     function setFeeTo(address) external;
552     function setFeeToSetter(address) external;
553 }
554 
555 
556 // pragma solidity >=0.5.0;
557 
558 interface IUniswapV2Pair {
559     event Approval(address indexed owner, address indexed spender, uint value);
560     event Transfer(address indexed from, address indexed to, uint value);
561 
562     function name() external pure returns (string memory);
563     function symbol() external pure returns (string memory);
564     function decimals() external pure returns (uint8);
565     function totalSupply() external view returns (uint);
566     function balanceOf(address owner) external view returns (uint);
567     function allowance(address owner, address spender) external view returns (uint);
568 
569     function approve(address spender, uint value) external returns (bool);
570     function transfer(address to, uint value) external returns (bool);
571     function transferFrom(address from, address to, uint value) external returns (bool);
572 
573     function DOMAIN_SEPARATOR() external view returns (bytes32);
574     function PERMIT_TYPEHASH() external pure returns (bytes32);
575     function nonces(address owner) external view returns (uint);
576 
577     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
578 
579     event Mint(address indexed sender, uint amount0, uint amount1);
580     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
581     event Swap(
582         address indexed sender,
583         uint amount0In,
584         uint amount1In,
585         uint amount0Out,
586         uint amount1Out,
587         address indexed to
588     );
589     event Sync(uint112 reserve0, uint112 reserve1);
590 
591     function MINIMUM_LIQUIDITY() external pure returns (uint);
592     function factory() external view returns (address);
593     function token0() external view returns (address);
594     function token1() external view returns (address);
595     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
596     function price0CumulativeLast() external view returns (uint);
597     function price1CumulativeLast() external view returns (uint);
598     function kLast() external view returns (uint);
599 
600     function mint(address to) external returns (uint liquidity);
601     function burn(address to) external returns (uint amount0, uint amount1);
602     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
603     function skim(address to) external;
604     function sync() external;
605 
606     function initialize(address, address) external;
607 }
608 
609 // pragma solidity >=0.6.2;
610 
611 interface IUniswapV2Router01 {
612     function factory() external pure returns (address);
613     function WETH() external pure returns (address);
614 
615     function addLiquidity(
616         address tokenA,
617         address tokenB,
618         uint amountADesired,
619         uint amountBDesired,
620         uint amountAMin,
621         uint amountBMin,
622         address to,
623         uint deadline
624     ) external returns (uint amountA, uint amountB, uint liquidity);
625     function addLiquidityETH(
626         address token,
627         uint amountTokenDesired,
628         uint amountTokenMin,
629         uint amountETHMin,
630         address to,
631         uint deadline
632     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
633     function removeLiquidity(
634         address tokenA,
635         address tokenB,
636         uint liquidity,
637         uint amountAMin,
638         uint amountBMin,
639         address to,
640         uint deadline
641     ) external returns (uint amountA, uint amountB);
642     function removeLiquidityETH(
643         address token,
644         uint liquidity,
645         uint amountTokenMin,
646         uint amountETHMin,
647         address to,
648         uint deadline
649     ) external returns (uint amountToken, uint amountETH);
650     function removeLiquidityWithPermit(
651         address tokenA,
652         address tokenB,
653         uint liquidity,
654         uint amountAMin,
655         uint amountBMin,
656         address to,
657         uint deadline,
658         bool approveMax, uint8 v, bytes32 r, bytes32 s
659     ) external returns (uint amountA, uint amountB);
660     function removeLiquidityETHWithPermit(
661         address token,
662         uint liquidity,
663         uint amountTokenMin,
664         uint amountETHMin,
665         address to,
666         uint deadline,
667         bool approveMax, uint8 v, bytes32 r, bytes32 s
668     ) external returns (uint amountToken, uint amountETH);
669     function swapExactTokensForTokens(
670         uint amountIn,
671         uint amountOutMin,
672         address[] calldata path,
673         address to,
674         uint deadline
675     ) external returns (uint[] memory amounts);
676     function swapTokensForExactTokens(
677         uint amountOut,
678         uint amountInMax,
679         address[] calldata path,
680         address to,
681         uint deadline
682     ) external returns (uint[] memory amounts);
683     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
684     external
685     payable
686     returns (uint[] memory amounts);
687     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
688     external
689     returns (uint[] memory amounts);
690     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
691     external
692     returns (uint[] memory amounts);
693     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
694     external
695     payable
696     returns (uint[] memory amounts);
697 
698     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
699     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
700     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
701     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
702     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
703 }
704 
705 
706 
707 // pragma solidity >=0.6.2;
708 
709 interface IUniswapV2Router02 is IUniswapV2Router01 {
710     function removeLiquidityETHSupportingFeeOnTransferTokens(
711         address token,
712         uint liquidity,
713         uint amountTokenMin,
714         uint amountETHMin,
715         address to,
716         uint deadline
717     ) external returns (uint amountETH);
718     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
719         address token,
720         uint liquidity,
721         uint amountTokenMin,
722         uint amountETHMin,
723         address to,
724         uint deadline,
725         bool approveMax, uint8 v, bytes32 r, bytes32 s
726     ) external returns (uint amountETH);
727 
728     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
729         uint amountIn,
730         uint amountOutMin,
731         address[] calldata path,
732         address to,
733         uint deadline
734     ) external;
735     function swapExactETHForTokensSupportingFeeOnTransferTokens(
736         uint amountOutMin,
737         address[] calldata path,
738         address to,
739         uint deadline
740     ) external payable;
741     function swapExactTokensForETHSupportingFeeOnTransferTokens(
742         uint amountIn,
743         uint amountOutMin,
744         address[] calldata path,
745         address to,
746         uint deadline
747     ) external;
748 }
749 
750 
751 contract DEGEN is Context, IERC20, Ownable {
752     using SafeMath for uint256;
753     using Address for address;
754 
755     mapping (address => uint256) private _rOwned;
756     mapping (address => uint256) private _tOwned;
757     mapping (address => mapping (address => uint256)) private _allowances;
758 
759     mapping (address => bool) private _isExcludedFromFee;
760 
761     mapping (address => bool) private _isExcluded;
762     address[] private _excluded;
763 
764     uint256 private constant MAX = ~uint256(0);
765     uint256 private _tTotal = 1000000000 * 10**6 * 10**9;
766     uint256 private _rTotal = (MAX - (MAX % _tTotal));
767     uint256 private _tFeeTotal;
768 
769     string private _name = "DEGEN Token";
770     string private _symbol = "DEGEN";
771     uint8 private _decimals = 9;
772 
773     uint256 public _taxFee = 4;
774     uint256 private _previousTaxFee = _taxFee;
775 
776     uint256 public _liquidityFee = 4;
777     uint256 private _previousLiquidityFee = _liquidityFee;
778 
779     uint256 public _burnFee = 4;
780     uint256 private _previousBurnFee = _burnFee;
781 
782 
783     IUniswapV2Router02 public immutable uniswapV2Router;
784     address public immutable uniswapV2Pair;
785 
786     bool inSwapAndLiquify;
787     bool public swapAndLiquifyEnabled = true;
788 
789     uint256 public _maxTxAmount = 10000000 * 10**6 * 10**9;
790     uint256 private numTokensSellToAddToLiquidity = 1000000 * 10**6 * 10**9;
791 
792     event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
793     event SwapAndLiquifyEnabledUpdated(bool enabled);
794     event SwapAndLiquify(
795         uint256 tokensSwapped,
796         uint256 ethReceived,
797         uint256 tokensIntoLiqudity
798     );
799 
800     modifier lockTheSwap {
801         inSwapAndLiquify = true;
802         _;
803         inSwapAndLiquify = false;
804     }
805 
806     constructor () public {
807         _rOwned[_msgSender()] = _rTotal;
808 
809         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
810         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
811         .createPair(address(this), _uniswapV2Router.WETH());
812 
813         // set the rest of the contract variables
814         uniswapV2Router = _uniswapV2Router;
815 
816         //exclude owner and this contract from fee
817         _isExcludedFromFee[owner()] = true;
818         _isExcludedFromFee[address(this)] = true;
819 
820         emit Transfer(address(0), _msgSender(), _tTotal);
821     }
822 
823     function name() public view returns (string memory) {
824         return _name;
825     }
826 
827     function symbol() public view returns (string memory) {
828         return _symbol;
829     }
830 
831     function decimals() public view returns (uint8) {
832         return _decimals;
833     }
834 
835     function totalSupply() public view override returns (uint256) {
836         return _tTotal;
837     }
838 
839     function balanceOf(address account) public view override returns (uint256) {
840         if (_isExcluded[account]) return _tOwned[account];
841         return tokenFromReflection(_rOwned[account]);
842     }
843 
844     function transfer(address recipient, uint256 amount) public override returns (bool) {
845 
846         _transfer(_msgSender(), recipient, amount);
847 
848         return true;
849     }
850 
851     function allowance(address owner, address spender) public view override returns (uint256) {
852         return _allowances[owner][spender];
853     }
854 
855     function approve(address spender, uint256 amount) public override returns (bool) {
856         _approve(_msgSender(), spender, amount);
857         return true;
858     }
859 
860     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
861         _transfer(sender, recipient, amount);
862         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
863         return true;
864     }
865 
866     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
867         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
868         return true;
869     }
870 
871     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
872         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
873         return true;
874     }
875 
876     function isExcludedFromReward(address account) public view returns (bool) {
877         return _isExcluded[account];
878     }
879 
880     function totalFees() public view returns (uint256) {
881         return _tFeeTotal;
882     }
883 
884     function deliver(uint256 tAmount) public {
885         address sender = _msgSender();
886         require(!_isExcluded[sender], "Excluded addresses cannot call this function");
887         Values memory values = _getValues(tAmount);
888         uint256 rAmount = values.rAmount;
889         _rOwned[sender] = _rOwned[sender].sub(rAmount);
890         _rTotal = _rTotal.sub(rAmount);
891         _tFeeTotal = _tFeeTotal.add(tAmount);
892     }
893 
894     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
895         require(tAmount <= _tTotal, "Amount must be less than supply");
896         if (!deductTransferFee) {
897             Values memory values = _getValues(tAmount);
898             return values.rAmount;
899         } else {
900             Values memory values = _getValues(tAmount);
901             return values.rTransferAmount;
902         }
903     }
904 
905     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
906         require(rAmount <= _rTotal, "Amount must be less than total reflections");
907         uint256 currentRate =  _getRate();
908         return rAmount.div(currentRate);
909     }
910 
911     function excludeFromReward(address account) public onlyOwner() {
912         // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');
913         require(!_isExcluded[account], "Account is already excluded");
914         if(_rOwned[account] > 0) {
915             _tOwned[account] = tokenFromReflection(_rOwned[account]);
916         }
917         _isExcluded[account] = true;
918         _excluded.push(account);
919     }
920 
921     function includeInReward(address account) external onlyOwner() {
922         require(_isExcluded[account], "Account is already excluded");
923         for (uint256 i = 0; i < _excluded.length; i++) {
924             if (_excluded[i] == account) {
925                 _excluded[i] = _excluded[_excluded.length - 1];
926                 _tOwned[account] = 0;
927                 _isExcluded[account] = false;
928                 _excluded.pop();
929                 break;
930             }
931         }
932     }
933     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
934         Values memory values = _getValues(tAmount);
935         uint256 rAmount = values.rAmount;
936         uint256 rTransferAmount = values.rTransferAmount;
937         uint256 rFee = values.rFee;
938         uint256 tTransferAmount = values.tTransferAmount;
939         uint256 tFee = values.tFee;
940         uint256 tLiquidity = values.tLiquidity;
941         _tOwned[sender] = _tOwned[sender].sub(tAmount);
942         _rOwned[sender] = _rOwned[sender].sub(rAmount);
943         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
944         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
945         _takeLiquidity(tLiquidity);
946         _reflectFee(rFee, tFee);
947         emit Transfer(sender, recipient, tTransferAmount);
948     }
949 
950     function excludeFromFee(address account) public onlyOwner {
951         _isExcludedFromFee[account] = true;
952     }
953 
954     function includeInFee(address account) public onlyOwner {
955         _isExcludedFromFee[account] = false;
956     }
957 
958     function setTaxFeePercent(uint256 taxFee) external onlyOwner() {
959         _taxFee = taxFee;
960     }
961 
962     function setBurnFeePercent(uint256 burnFee) external onlyOwner() {
963         _burnFee = burnFee;
964     }
965 
966     function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {
967         _liquidityFee = liquidityFee;
968     }
969 
970     function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
971         _maxTxAmount = _tTotal.mul(maxTxPercent).div(
972             10**2
973         );
974     }
975 
976     function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {
977         swapAndLiquifyEnabled = _enabled;
978         emit SwapAndLiquifyEnabledUpdated(_enabled);
979     }
980 
981     //to recieve ETH from uniswapV2Router when swaping
982     receive() external payable {}
983 
984     function _reflectFee(uint256 rFee, uint256 tFee) private {
985         _rTotal = _rTotal.sub(rFee);
986         _tFeeTotal = _tFeeTotal.add(tFee);
987     }
988 
989     struct Values{
990         uint256 rAmount;
991         uint256 rTransferAmount;
992         uint256  rFee;
993         uint256 rBurnFee;
994         uint256 tTransferAmount;
995         uint256 tFee;
996         uint256 tLiquidity;
997         uint256 tBurnFee;
998     }
999 
1000     struct rValuesParams {
1001         uint256 tAmount;
1002         uint256 tFee;
1003         uint256 tLiquidity;
1004         uint256 tBurnFee;
1005         uint256 currentRate;
1006     }
1007 
1008     function _getValues(uint256 tAmount) private view returns (Values memory) {
1009         (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tBurnFee) = _getTValues(tAmount);
1010 
1011         rValuesParams memory r_values_params = rValuesParams(tAmount, tFee, tLiquidity, tBurnFee, _getRate());
1012 
1013         (
1014         uint256 rAmount,
1015         uint256 rTransferAmount,
1016         uint256 rFee,
1017         uint256 rBurnFee
1018         ) = _getRValues(r_values_params);
1019 
1020         Values memory values = Values(rAmount, rTransferAmount, rFee, rBurnFee, tTransferAmount, tFee, tLiquidity, tBurnFee);
1021 
1022         return (values);
1023     }
1024 
1025     function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {
1026         uint256 tFee = calculateTaxFee(tAmount);
1027         uint256 tBurnFee = calculateBurnFee(tAmount);
1028         uint256 tLiquidity = calculateLiquidityFee(tAmount);
1029         uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity).sub(tBurnFee);
1030         return (tTransferAmount, tFee, tLiquidity, tBurnFee);
1031     }
1032 
1033     function _getRValues(rValuesParams memory r_values_params) private pure returns (uint256, uint256, uint256, uint256) {
1034         uint256 tAmount = r_values_params.tAmount;
1035         uint256 tFee = r_values_params.tFee;
1036         uint256 tLiquidity = r_values_params.tLiquidity;
1037         uint256 tBurnFee = r_values_params.tBurnFee;
1038         uint256 currentRate = r_values_params.currentRate;
1039 
1040         uint256 rAmount = tAmount.mul(currentRate);
1041         uint256 rFee = tFee.mul(currentRate);
1042         uint256 rBurnFee = tBurnFee.mul(currentRate);
1043         uint256 rLiquidity = tLiquidity.mul(currentRate);
1044         uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity).sub(rBurnFee);
1045         return (rAmount, rTransferAmount, rFee, rBurnFee);
1046     }
1047 
1048     function _getRate() private view returns(uint256) {
1049         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
1050         return rSupply.div(tSupply);
1051     }
1052 
1053     function _getCurrentSupply() private view returns(uint256, uint256) {
1054         uint256 rSupply = _rTotal;
1055         uint256 tSupply = _tTotal;
1056         for (uint256 i = 0; i < _excluded.length; i++) {
1057             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
1058             rSupply = rSupply.sub(_rOwned[_excluded[i]]);
1059             tSupply = tSupply.sub(_tOwned[_excluded[i]]);
1060         }
1061         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
1062         return (rSupply, tSupply);
1063     }
1064 
1065     function _takeLiquidity(uint256 tLiquidity) private {
1066         uint256 currentRate =  _getRate();
1067         uint256 rLiquidity = tLiquidity.mul(currentRate);
1068         _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
1069         if(_isExcluded[address(this)])
1070             _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);
1071     }
1072 
1073     function calculateTaxFee(uint256 _amount) private view returns (uint256) {
1074         return _amount.mul(_taxFee).div(
1075             10**2
1076         );
1077     }
1078 
1079     function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {
1080         return _amount.mul(_liquidityFee).div(
1081             10**2
1082         );
1083     }
1084 
1085     function calculateBurnFee(uint256 _amount) private view returns (uint256) {
1086         return _amount.mul(_burnFee).div(
1087             10**2
1088         );
1089     }
1090 
1091 
1092     function removeAllFee() private {
1093         if(_taxFee == 0 && _liquidityFee == 0 && _burnFee == 0) return;
1094 
1095         _previousTaxFee = _taxFee;
1096         _previousLiquidityFee = _liquidityFee;
1097         _previousBurnFee = _burnFee;
1098 
1099         _taxFee = 0;
1100         _liquidityFee = 0;
1101         _burnFee = 0;
1102     }
1103 
1104     function restoreAllFee() private {
1105         _taxFee = _previousTaxFee;
1106         _liquidityFee = _previousLiquidityFee;
1107         _burnFee = _previousBurnFee;
1108     }
1109 
1110     function isExcludedFromFee(address account) public view returns(bool) {
1111         return _isExcludedFromFee[account];
1112     }
1113 
1114     function _approve(address owner, address spender, uint256 amount) private {
1115         require(owner != address(0), "ERC20: approve from the zero address");
1116         require(spender != address(0), "ERC20: approve to the zero address");
1117 
1118         _allowances[owner][spender] = amount;
1119         emit Approval(owner, spender, amount);
1120     }
1121 
1122     function _transfer(
1123         address from,
1124         address to,
1125         uint256 amount
1126     ) private {
1127         require(from != address(0), "ERC20: transfer from the zero address");
1128         require(to != address(0), "ERC20: transfer to the zero address");
1129         require(amount > 0, "Transfer amount must be greater than zero");
1130         if(from != owner() && to != owner())
1131             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
1132 
1133         // is the token balance of this contract address over the min number of
1134         // tokens that we need to initiate a swap + liquidity lock?
1135         // also, don't get caught in a circular liquidity event.
1136         // also, don't swap & liquify if sender is uniswap pair.
1137         uint256 contractTokenBalance = balanceOf(address(this));
1138 
1139         if(contractTokenBalance >= _maxTxAmount)
1140         {
1141             contractTokenBalance = _maxTxAmount;
1142         }
1143 
1144         bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;
1145         if (
1146             overMinTokenBalance &&
1147             !inSwapAndLiquify &&
1148             from != uniswapV2Pair &&
1149             swapAndLiquifyEnabled
1150         ) {
1151             contractTokenBalance = numTokensSellToAddToLiquidity;
1152             //add liquidity
1153             swapAndLiquify(contractTokenBalance);
1154         }
1155 
1156         //indicates if fee should be deducted from transfer
1157         bool takeFee = true;
1158 
1159         //if any account belongs to _isExcludedFromFee account then remove the fee
1160         if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){
1161             takeFee = false;
1162         }
1163 
1164         //transfer amount, it will take tax, burn, liquidity fee
1165         _tokenTransfer(from,to,amount,takeFee);
1166     }
1167 
1168     function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
1169         // split the contract balance into halves
1170         uint256 half = contractTokenBalance.div(2);
1171         uint256 otherHalf = contractTokenBalance.sub(half);
1172 
1173         // capture the contract's current ETH balance.
1174         // this is so that we can capture exactly the amount of ETH that the
1175         // swap creates, and not make the liquidity event include any ETH that
1176         // has been manually sent to the contract
1177         uint256 initialBalance = address(this).balance;
1178 
1179         // swap tokens for ETH
1180         swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered
1181 
1182         // how much ETH did we just swap into?
1183         uint256 newBalance = address(this).balance.sub(initialBalance);
1184 
1185         // add liquidity to uniswap
1186         addLiquidity(otherHalf, newBalance);
1187 
1188         emit SwapAndLiquify(half, newBalance, otherHalf);
1189     }
1190 
1191     function swapTokensForEth(uint256 tokenAmount) private {
1192         // generate the uniswap pair path of token -> weth
1193         address[] memory path = new address[](2);
1194         path[0] = address(this);
1195         path[1] = uniswapV2Router.WETH();
1196 
1197         _approve(address(this), address(uniswapV2Router), tokenAmount);
1198 
1199         // make the swap
1200         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
1201             tokenAmount,
1202             0, // accept any amount of ETH
1203             path,
1204             address(this),
1205             block.timestamp
1206         );
1207     }
1208 
1209     function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
1210         // approve token transfer to cover all possible scenarios
1211         _approve(address(this), address(uniswapV2Router), tokenAmount);
1212 
1213         // add the liquidity
1214         uniswapV2Router.addLiquidityETH{value: ethAmount}(
1215             address(this),
1216             tokenAmount,
1217             0, // slippage is unavoidable
1218             0, // slippage is unavoidable
1219             owner(),
1220             block.timestamp
1221         );
1222     }
1223 
1224     //this method is responsible for taking all fee, if takeFee is true
1225     function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {
1226         if(!takeFee)
1227             removeAllFee();
1228 
1229         if (_isExcluded[sender] && !_isExcluded[recipient]) {
1230             _transferFromExcluded(sender, recipient, amount);
1231         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
1232             _transferToExcluded(sender, recipient, amount);
1233         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
1234             _transferStandard(sender, recipient, amount);
1235         } else if (_isExcluded[sender] && _isExcluded[recipient]) {
1236             _transferBothExcluded(sender, recipient, amount);
1237         } else {
1238             _transferStandard(sender, recipient, amount);
1239         }
1240 
1241         if(!takeFee)
1242             restoreAllFee();
1243     }
1244 
1245     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
1246         Values memory values = _getValues(tAmount);
1247         uint256 rAmount = values.rAmount;
1248         uint256 rTransferAmount = values.rTransferAmount;
1249         uint256 rFee = values.rFee;
1250         uint256 tTransferAmount = values.tTransferAmount;
1251         uint256 tFee = values.tFee;
1252         uint256 tLiquidity = values.tLiquidity;
1253         uint256 tBurnFee = values.tBurnFee;
1254         uint256 rBurnFee = values.rBurnFee;
1255 
1256         _tTotal = _tTotal.sub(tBurnFee);
1257         _rTotal = _rTotal.sub(rBurnFee);
1258 
1259         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1260         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1261 
1262         _takeLiquidity(tLiquidity);
1263         _reflectFee(rFee, tFee);
1264 
1265         emit Transfer(sender, recipient, tTransferAmount);
1266     }
1267 
1268     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
1269         Values memory values = _getValues(tAmount);
1270         uint256 rAmount = values.rAmount;
1271         uint256 rTransferAmount = values.rTransferAmount;
1272         uint256 rFee = values.rFee;
1273         uint256 tTransferAmount = values.tTransferAmount;
1274         uint256 tFee = values.tFee;
1275         uint256 tLiquidity = values.tLiquidity;
1276 
1277         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1278         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
1279         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1280         _takeLiquidity(tLiquidity);
1281         _reflectFee(rFee, tFee);
1282         emit Transfer(sender, recipient, tTransferAmount);
1283     }
1284 
1285     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
1286         Values memory values = _getValues(tAmount);
1287         uint256 rAmount = values.rAmount;
1288         uint256 rTransferAmount = values.rTransferAmount;
1289         uint256 rFee = values.rFee;
1290         uint256 tTransferAmount = values.tTransferAmount;
1291         uint256 tFee = values.tFee;
1292         uint256 tLiquidity = values.tLiquidity;
1293 
1294         _tOwned[sender] = _tOwned[sender].sub(tAmount);
1295         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1296         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1297         _takeLiquidity(tLiquidity);
1298         _reflectFee(rFee, tFee);
1299         emit Transfer(sender, recipient, tTransferAmount);
1300     }
1301 
1302 }