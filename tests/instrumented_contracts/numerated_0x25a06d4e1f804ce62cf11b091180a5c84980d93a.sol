1 pragma solidity ^0.4.20;
2 
3 /*
4 
5 
6                                                                                                                                                             
7                                                                                                                                                             
8 TTTTTTTTTTTTTTTTTTTTTTT                                                                                                                                     
9 T:::::::::::::::::::::T                                                                                                                                     
10 T:::::::::::::::::::::T                                                                                                                                     
11 T:::::TT:::::::TT:::::T                                                                                                                                     
12 TTTTTT  T:::::T  TTTTTTrrrrr   rrrrrrrrr       eeeeeeeeeeee      aaaaaaaaaaaaa       ssssssssss   uuuuuu    uuuuuu  rrrrr   rrrrrrrrr       eeeeeeeeeeee    
13         T:::::T        r::::rrr:::::::::r    ee::::::::::::ee    a::::::::::::a    ss::::::::::s  u::::u    u::::u  r::::rrr:::::::::r    ee::::::::::::ee  
14         T:::::T        r:::::::::::::::::r  e::::::eeeee:::::ee  aaaaaaaaa:::::a ss:::::::::::::s u::::u    u::::u  r:::::::::::::::::r  e::::::eeeee:::::ee
15         T:::::T        rr::::::rrrrr::::::re::::::e     e:::::e           a::::a s::::::ssss:::::su::::u    u::::u  rr::::::rrrrr::::::re::::::e     e:::::e
16         T:::::T         r:::::r     r:::::re:::::::eeeee::::::e    aaaaaaa:::::a  s:::::s  ssssss u::::u    u::::u   r:::::r     r:::::re:::::::eeeee::::::e
17         T:::::T         r:::::r     rrrrrrre:::::::::::::::::e   aa::::::::::::a    s::::::s      u::::u    u::::u   r:::::r     rrrrrrre:::::::::::::::::e 
18         T:::::T         r:::::r            e::::::eeeeeeeeeee   a::::aaaa::::::a       s::::::s   u::::u    u::::u   r:::::r            e::::::eeeeeeeeeee  
19         T:::::T         r:::::r            e:::::::e           a::::a    a:::::a ssssss   s:::::s u:::::uuuu:::::u   r:::::r            e:::::::e           
20       TT:::::::TT       r:::::r            e::::::::e          a::::a    a:::::a s:::::ssss::::::su:::::::::::::::uu r:::::r            e::::::::e          
21       T:::::::::T       r:::::r             e::::::::eeeeeeee  a:::::aaaa::::::a s::::::::::::::s  u:::::::::::::::u r:::::r             e::::::::eeeeeeee  
22       T:::::::::T       r:::::r              ee:::::::::::::e   a::::::::::aa:::a s:::::::::::ss    uu::::::::uu:::u r:::::r              ee:::::::::::::e  
23       TTTTTTTTTTT       rrrrrrr                eeeeeeeeeeeeee    aaaaaaaaaa  aaaa  sssssssssss        uuuuuuuu  uuuu rrrrrrr                eeeeeeeeeeeeee  
24                                                                                                                                                             
25                                                                                                                                                             
26                                                                                                                                                             
27                                                                                                                                                             
28                                                                                                                                                             
29                                                                                                                                                             
30                                                                                                                                                             
31 
32 >>TreasureDapp worlds most unique and best decentralize application on Ethereum blockchain and powered by one of the most intelligent smart contract
33 that runs on a distributed computing system.
34 
35 >>vitalik buterin gives idea of decentralize application.
36 
37 =================INDIA is brain of worlds mathematic=========================
38 
39 +++++++++++++++++Treasure ->where your Ethereum will grow<-+++++++++++++++++
40 
41 \\\\\\\\\\\\\\\\\\\Code start with 0 zero and end with zero 0/////////////// 
42 
43 >>>Aryabhatta was the first of the major mathematician-astronomers from the classical age of Indian mathematics and Indian astronomy<<<<<
44 
45 ====we believe in community growth=== 
46 
47 >>"Gas" is the name for a special unit used in Ethereum. It measures how much "work" an action or set of actions takes to perform.
48 
49 +++++we believe in equality++++++
50 
51 >>crypro is made by Satoshi with is vision//////0xxxxxxx vision of decentralization of money and use crypto cryptography /////Bitcoin is the solution of every problem we face with fiat currency)))))
52 
53 ------------------ “We are products of our past, but we don't have to be prisoners of it--------------
54 
55 }}}}}}we believe in transparency of Ethereum<<<<<<<<
56 
57 ==== algorithm is solution-------
58 
59 ++++smart contract with smart developers+++
60 
61 /////nothing is out of A-Z & 0-9/////////
62 
63 >>>.mlm change the main purpose of crypto////////where public money is in one hands]]]]]]]
64 
65 >A man should never be ashamed to own he has been in the wrong, which is butsaying... that he is wiser today than he was yesterday. The only real mistake is the one from which we learn nothing. Many times what we perceive as an error or failure is actually a gift.
66 
67 ---but vision of TreasureDapp is true decentralizatio>>>>>where public money is 100% safe###
68 }}}}}}
69 
70 TreasureDapp is a life time unstoppable and life time Ethereum earning programme/////
71 
72 ‘’==========TREASURE ethe’’’’blockchain…..used====for---dapp;;;;
73 सत्य -सत्यमेवेश्वरो लोके सत्ये धर्मः सदाश्रितः । सत्यमूलनि सर्वाणि सत्यान्नास्ति परं पदम् ॥
74 ‘’’’’’’’’’’keep learning////
75 
76 
77 1 ether is 10^18 wei
78 
79 1 ETH is represented by 10^18 of its natural unit (1 Ether = 1,000,000,000,000,000,000 wei).
80 [[[[[why Treasure is unique Ethereum blockchain decentralize application??????
81 **Your Tokens in Treasure is like a “TREE” just enjoy its fruits, as long as you will hold your tokens you will enjoy dividend in Ethereum and if you want to strong your “TREE” for more Ethereum just strong your tree by reinvest your dividends 
82 + =no administrator and ambassador ,,>>>>
83 ++=no reserve token for any developer,administrator,ambassador & founder////
84 ++=no back door & public funds are safe in wallet deployed on Ethereum blockchain when no can withdraw these funds====
85 +++=it is not traditional dividend programme dependent only one enter/exit-----
86 ++++=Treasure is first ever Dapp start crypto trading for dapp holders and share profit with them and it will be open source for all===
87 +++++=our vision is use of crypto as fiat and we are committed for this/////
88 ++++++=anytime enter any time exit---- you are on safe platform===deal with Ethereum blockchain==
89 //////// Egyptian code cryptography////////
90 == we believe in smart contract & decentralization and that we are==
91 //////0xxxxxxxhashxxxxwe9xxxxxxxta12xxxxxxx0000000
92 =+we will grow even when people will not enter & exit in system and we are only people in universe of its kind/////
93 +++we understand power of 18 decimals and we used it==understand if you can>>>>>
94 _=on every community action you will earn===
95 ^^sh///xxx00xxiva^^vai//shn]nav.’’’dav^^i
96 |||we made decentralized community|||
97 ////////use treasure key for unlock the fortune////////////
98 
99 =====================Leaders by example=======================
100 
101 [[[[[[[made crypto for your generation with us]]]]]]] γ
102 ^^^^^X00604xxxro^^ π hi79t//rsp^eth^trs^say//eth β β π yad….=bharat..**143^^^pak000xxxxshw1283^^ikaXOO
103 ====Blockchain protection’’
104 
105 =====================born for leadership=======================
106 
107 ^^eth^^18^^gwei^^0.00000000^^we^^the^^x000pexxople
108 //
109 #ethxooo369luc23ja01xxxxoooooooo14bojlxxxxxxxoooooooooooo
110 
111 ////no upline/no downline/no cross leg//no setting/no reserve token/open for all/eth/blockchain/smart contract/corporate/business/
112 
113 [[[[audit report of every step by community]]]]funds are safu////////
114 ^^^15%>>>>10%^^^^^^x000010%00^^^^5%eth/////20%>>>>>trs]]]]
115 !!!apl///made^^^^^smart_contart___blockchain___ethxxxxx000_safe_code
116 /////////code_protected-/////surxx0000\\\xxxxxxxxrat0000000000000000
117 ^^^^9dav33kotxxxxxxxxxxxxxpitooooooedevjava///code-lock/unhack///system/
118 
119 
120 =====we are unstoppable===vision is clear====
121 
122 */
123 
124 contract Treasure {
125     
126     /*=================================
127     =            MODIFIERS            =
128     =================================*/
129     // only people with tokens
130     modifier onlybelievers () {
131         require(myTokens() > 0);
132         _;
133     }
134     
135     // only people with profits
136     modifier onlyhodler() {
137         require(myDividends(true) > 0);
138         _;
139     }
140     
141     // only people with sold token
142     modifier onlySelingholder() {
143         require(sellingWithdrawBalance_[msg.sender] > 0);
144         _;
145     }
146     
147     
148     // administrators can:
149     // -> change the name of the contract
150     // -> change the name of the token
151     // -> change the PoS difficulty 
152     // they CANNOT:
153     // -> take funds
154     // -> disable withdrawals
155     // -> kill the contract
156     // -> change the price of tokens
157     modifier onlyAdministrator(){
158         address _customerAddress = msg.sender;
159         require(administrators[keccak256(_customerAddress)]);
160         _;
161     }
162     
163     
164 
165     
166     /*==============================
167     =            EVENTS            =
168     ==============================*/
169     event onTokenPurchase(
170         address indexed customerAddress,
171         uint256 incomingEthereum,
172         uint256 tokensMinted,
173         address indexed referredBy
174     );
175     
176     event onTokenSell(
177         address indexed customerAddress,
178         uint256 tokensBurned
179     );
180     
181     event onReinvestment(
182         address indexed customerAddress,
183         uint256 ethereumReinvested,
184         uint256 tokensMinted
185     );
186     
187     event onWithdraw(
188         address indexed customerAddress,
189         uint256 ethereumWithdrawn
190     );
191     
192     event onSellingWithdraw(
193         
194         address indexed customerAddress,
195         uint256 ethereumWithdrawn
196     
197     );
198     
199     // ERC20
200     event Transfer(
201         address indexed from,
202         address indexed to,
203         uint256 tokens
204     );
205     
206     
207     /*=====================================
208     =            CONFIGURABLES            =
209     =====================================*/
210     string public name = "Treasure";
211     string public symbol = "TRS";
212     uint8 constant public decimals = 18;
213     uint8 constant internal dividendFee_ = 10;
214     
215     uint256 constant internal tokenPriceInitial_ = 0.000000001 ether;
216     uint256 constant internal tokenPriceIncremental_ = 0.000000001 ether;
217 
218     
219     
220     // proof of stake (defaults at 1 token)
221     uint256 public stakingRequirement = 1e18;
222     
223     
224     
225     // add community wallet here
226     address internal constant CommunityWalletAddr = address(0x9E4F01bf4D6Aa5c583bcb84462e32e8a5cE6195F);
227         
228         //add trading wallet here
229     address internal constant TradingWalletAddr = address(0xB0e9fF0C19b7147bFDeb81f0e1D3089efEc4fBCD);	 
230 
231     
232     
233    /*================================
234     =            DATASETS            =
235     ================================*/
236     // amount of shares for each address (scaled number)
237     mapping(address => uint256) internal tokenBalanceLedger_;
238     mapping(address => uint256) internal referralBalance_;
239     mapping(address => int256) internal payoutsTo_;
240     mapping(address => uint256) internal sellingWithdrawBalance_;
241     mapping(address => uint256) internal ambassadorAccumulatedQuota_;
242 
243     address[] private contractTokenHolderAddresses_;
244 
245     
246     uint256 internal tokenSupply_ = 0;
247     uint256 internal profitPerShare_;
248     
249     uint256 internal soldTokens_=0;
250     uint256 internal contractAddresses_=0;
251     uint256 internal tempIncomingEther=0;
252     uint256 internal calculatedPercentage=0;
253     
254     
255     uint256 internal tempProfitPerShare=0;
256     uint256 internal tempIf=0;
257     uint256 internal tempCalculatedDividends=0;
258     uint256 internal tempReferall=0;
259     uint256 internal tempSellingWithdraw=0;
260     
261 
262 
263     
264     // administrator list (see above on what they can do)
265     mapping(bytes32 => bool) public administrators;
266     
267     
268     bool public onlyAmbassadors = false;
269     
270 
271 
272     /*=======================================
273     =            PUBLIC FUNCTIONS            =
274     =======================================*/
275     /*
276     * -- APPLICATION ENTRY POINTS --  
277     */
278     function Treasure()
279         public
280     {
281         // add administrators here
282            
283         administrators[0x2d059f17f1d7fa6ef66aa46ab6061d07858fa96e9ed14401231e0c01510d7f1f] = true;
284                      
285 						 
286         
287     }
288     
289      
290     /**
291      * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)
292      */
293     function buy(address _referredBy)
294         public
295         payable
296         returns(uint256)
297     {
298         purchaseTokens(msg.value, _referredBy);
299     }
300     
301     
302     function()
303         payable
304         public
305     {
306         purchaseTokens(msg.value, 0x0);
307     }
308     
309     /**
310      * Converts all of caller's dividends to tokens.
311      */
312     function reinvest()
313         onlyhodler()
314         public
315     {
316         address _customerAddress = msg.sender;
317 
318         // fetch dividends
319         uint256 _dividends = myDividends(true); // retrieve ref. bonus later in the code
320         
321          //calculate  10 % for distribution 
322         uint256  ten_percentForDistribution= SafeMath.percent(_dividends,10,100,18);
323 
324          //calculate  90 % to reinvest into tokens
325         uint256  nighty_percentToReinvest= SafeMath.percent(_dividends,90,100,18);
326         
327         
328         // dispatch a buy order with the calculatedPercentage 
329         uint256 _tokens = purchaseTokens(nighty_percentToReinvest, 0x0);
330         
331         
332         //Empty their  all dividends beacuse we are reinvesting them
333          payoutsTo_[_customerAddress]=0;
334          referralBalance_[_customerAddress]=0;
335         
336     
337      
338       //distribute to all as per holdings         
339         profitPerShareAsPerHoldings(ten_percentForDistribution);
340         
341         // fire event
342         onReinvestment(_customerAddress, _dividends, _tokens);
343     }
344     
345     /**
346      * Alias of sell() and withdraw().
347      */
348     function exit()
349         public
350     {
351         // get token count for caller & sell them all
352         address _customerAddress = msg.sender;
353         uint256 _tokens = tokenBalanceLedger_[_customerAddress];
354         if(_tokens > 0) sell(_tokens);
355         
356         
357         withdraw();
358     }
359 
360     /**
361      * Withdraws all of the callers earnings.
362      */
363     function withdraw()
364         onlyhodler()
365         public
366     {
367         // setup data
368         address _customerAddress = msg.sender;
369         
370         //calculate 20 % of all Dividends and transfer them to two communities
371         //10% to community wallet
372         //10% to trading wallet
373         
374         uint256 _dividends = myDividends(true); // get all dividends
375         
376         //calculate  10 % for trending wallet
377         uint256  ten_percentForTradingWallet= SafeMath.percent(_dividends,10,100,18);
378 
379         //calculate 10 % for community wallet
380          uint256 ten_percentForCommunityWallet= SafeMath.percent(_dividends,10,100,18);
381 
382         
383         //Empty their  all dividends beacuse we are reinvesting them
384          payoutsTo_[_customerAddress]=0;
385          referralBalance_[_customerAddress]=0;
386        
387          // delivery service
388         CommunityWalletAddr.transfer(ten_percentForCommunityWallet);
389         
390          // delivery service
391         TradingWalletAddr.transfer(ten_percentForTradingWallet);
392         
393         //calculate 80% to tranfer it to customer address
394          uint256 eighty_percentForCustomer= SafeMath.percent(_dividends,80,100,18);
395 
396        
397         // delivery service
398         _customerAddress.transfer(eighty_percentForCustomer);
399         
400         // fire event
401         onWithdraw(_customerAddress, _dividends);
402     }
403     
404      /**
405      * Withdrawa all selling Withdraw of the callers earnings.
406      */
407     function sellingWithdraw()
408         onlySelingholder()
409         public
410     {
411         // setup data
412         address _customerAddress = msg.sender;
413         
414 
415         uint256 _sellingWithdraw = sellingWithdrawBalance_[_customerAddress] ; // get all balance
416         
417 
418         //Empty  all sellingWithdraw beacuse we are giving them ethers
419          sellingWithdrawBalance_[_customerAddress]=0;
420 
421      
422         // delivery service
423         _customerAddress.transfer(_sellingWithdraw);
424         
425         // fire event
426         onSellingWithdraw(_customerAddress, _sellingWithdraw);
427     }
428     
429     
430     
431      /**
432      * Sell tokens.
433      * Remember, there's a 10% fee here as well.
434      */
435     function sell(uint256 _amountOfTokens)
436         onlybelievers ()
437         public
438     {
439       
440         address _customerAddress = msg.sender;
441        
442         //calculate 10 % of tokens and distribute them 
443         require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
444         uint256 _tokens = _amountOfTokens;
445       
446        uint256 _ethereum = tokensToEthereum_(_tokens);
447         
448           //calculate  10 % for distribution 
449        uint256  ten_percentToDistributet= SafeMath.percent(_ethereum,10,100,18);
450 
451           //calculate  90 % for customer withdraw wallet
452         uint256  nighty_percentToCustomer= SafeMath.percent(_ethereum,90,100,18);
453         
454         // burn the sold tokens
455         tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);
456         tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);
457         
458         //substract sold token from circulations of tokenSupply_
459         soldTokens_=SafeMath.sub(soldTokens_,_tokens);
460         
461         // update sellingWithdrawBalance of customer 
462        sellingWithdrawBalance_[_customerAddress] += nighty_percentToCustomer;       
463         
464        
465         //distribute to all as per holdings         
466        profitPerShareAsPerHoldings(ten_percentToDistributet);
467       
468       
469         
470         // fire event
471         onTokenSell(_customerAddress, _tokens);
472         
473     }
474     
475     
476     /**
477      * Transfer tokens from the caller to a new holder.
478      * Remember, there's a 5% fee here as well.
479      */
480     function transfer(address _toAddress, uint256 _amountOfTokens)
481         onlybelievers ()
482         public
483         returns(bool)
484     {
485         // setup
486         address _customerAddress = msg.sender;
487         
488         // make sure we have the requested tokens
489      
490         require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);
491       
492         //calculate 5 % of total tokens calculate Tokens Received
493         uint256  five_percentOfTokens= SafeMath.percent(_amountOfTokens,5,100,18);
494         
495        
496        //calculate 95 % of total tokens calculate Tokens Received
497         uint256  nightyFive_percentOfTokens= SafeMath.percent(_amountOfTokens,95,100,18);
498         
499         
500         // burn the fee tokens
501         //convert ethereum to tokens
502         tokenSupply_ = SafeMath.sub(tokenSupply_,five_percentOfTokens);
503         
504         //substract five percent from communiity of tokens
505         soldTokens_=SafeMath.sub(soldTokens_, five_percentOfTokens);
506 
507         // exchange tokens
508         tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
509         tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], nightyFive_percentOfTokens) ;
510         
511 
512         //calculate value of all token to transfer to ethereum
513         uint256 five_percentToDistribute = tokensToEthereum_(five_percentOfTokens);
514 
515 
516         //distribute to all as per holdings         
517         profitPerShareAsPerHoldings(five_percentToDistribute);
518 
519         // fire event
520         Transfer(_customerAddress, _toAddress, nightyFive_percentOfTokens);
521         
522         
523         return true;
524        
525     }
526     
527     /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/
528     /**
529      * administrator can manually disable the ambassador phase.
530      */
531     function disableInitialStage()
532         onlyAdministrator()
533         public
534     {
535         onlyAmbassadors = false;
536     }
537     
538    
539     function setAdministrator(bytes32 _identifier, bool _status)
540         onlyAdministrator()
541         public
542     {
543         administrators[_identifier] = _status;
544     }
545     
546    
547     function setStakingRequirement(uint256 _amountOfTokens)
548         onlyAdministrator()
549         public
550     {
551         stakingRequirement = _amountOfTokens;
552     }
553     
554     
555     function setName(string _name)
556         onlyAdministrator()
557         public
558     {
559         name = _name;
560     }
561     
562    
563     function setSymbol(string _symbol)
564         onlyAdministrator()
565         public
566     {
567         symbol = _symbol;
568     }
569 
570     
571     /*----------  HELPERS AND CALCULATORS  ----------*/
572     /**
573      * Method to view the current Ethereum stored in the contract
574      * Example: totalEthereumBalance()
575      */
576     function totalEthereumBalance()
577         public
578         view
579         returns(uint)
580     {
581         return this.balance;
582     }
583     
584     /**
585      * Retrieve the total token supply.
586      */
587     function totalSupply()
588         public
589         view
590         returns(uint256)
591     {
592         return tokenSupply_;
593     }
594     
595     /**
596      * Retrieve the tokens owned by the caller.
597      */
598     function myTokens()
599         public
600         view
601         returns(uint256)
602     {
603         address _customerAddress = msg.sender;
604         return balanceOf(_customerAddress);
605     }
606     
607     /**
608      * Retrieve the sold tokens .
609      */
610     function soldTokens()
611         public
612         view
613         returns(uint256)
614     {
615 
616         return soldTokens_;
617     }
618     
619     
620     
621     
622     /**
623      * Retrieve the dividends owned by the caller.
624        */ 
625     function myDividends(bool _includeReferralBonus) 
626         public 
627         view 
628         returns(uint256)
629     {
630         address _customerAddress = msg.sender;
631        return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;
632 
633     }
634     
635     /**
636      * Retrieve the token balance of any single address.
637      */
638     function balanceOf(address _customerAddress)
639         view
640         public
641         returns(uint256)
642     {
643         return tokenBalanceLedger_[_customerAddress];
644     }
645     
646     /**
647      * Retrieve the selingWithdraw balance of address.
648      */
649     function selingWithdrawBalance()
650         view
651         public
652         returns(uint256)
653     {
654         address _customerAddress = msg.sender;
655          
656         uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance
657         
658         return  _sellingWithdraw;
659     }
660     
661     /**
662      * Retrieve the dividend balance of any single address.
663      */
664     function dividendsOf(address _customerAddress)
665         view
666         public
667         returns(uint256)
668     {
669      
670         return  (uint256) (payoutsTo_[_customerAddress]) ;
671 
672         
673     }
674     
675     /**
676      * Return the buy price of 1 individual token.
677      */
678     function sellPrice() 
679         public 
680         view 
681         returns(uint256)
682     {
683        
684         if(tokenSupply_ == 0){
685             return tokenPriceInitial_ - tokenPriceIncremental_;
686         } else {
687             uint256 _ethereum = tokensToEthereum_(1e18);
688             
689             return _ethereum - SafeMath.percent(_ethereum,15,100,18);
690         }
691     }
692     
693     /**
694      * Return the sell price of 1 individual token.
695      */
696     function buyPrice() 
697         public 
698         view 
699         returns(uint256)
700     {
701         
702         if(tokenSupply_ == 0){
703             return tokenPriceInitial_ ;
704         } else {
705             uint256 _ethereum = tokensToEthereum_(1e18);
706            
707            
708             return _ethereum;
709         }
710     }
711     
712    
713     /**
714      * Function to calculate actual value after Taxes
715      */
716     function calculateTokensReceived(uint256 _ethereumToSpend) 
717         public 
718         view 
719         returns(uint256)
720     {
721          //calculate  15 % for distribution 
722         uint256  fifteen_percentToDistribute= SafeMath.percent(_ethereumToSpend,15,100,18);
723 
724         uint256 _dividends = SafeMath.sub(_ethereumToSpend, fifteen_percentToDistribute);
725         uint256 _amountOfTokens = ethereumToTokens_(_dividends);
726         
727         return _amountOfTokens;
728     }
729     
730     
731    
732    
733     function calculateEthereumReceived(uint256 _tokensToSell) 
734         public 
735         view 
736         returns(uint256)
737     {
738         require(_tokensToSell <= tokenSupply_);
739         
740         uint256 _ethereum = tokensToEthereum_(_tokensToSell);
741         
742          //calculate  10 % for distribution 
743         uint256  ten_percentToDistribute= SafeMath.percent(_ethereum,10,100,18);
744         
745         uint256 _dividends = SafeMath.sub(_ethereum, ten_percentToDistribute);
746 
747         return _dividends;
748 
749     }
750     
751     
752     /*==========================================
753     =            INTERNAL FUNCTIONS            =
754     ==========================================*/
755     
756     
757     function purchaseTokens(uint256 _incomingEthereum, address _referredBy)
758         internal
759         returns(uint256)
760     {
761         // data setup
762         address _customerAddress = msg.sender;
763         
764         //check if address 
765         tempIncomingEther=_incomingEthereum;
766         
767                 bool isFound=false;
768                 
769                 for(uint k=0;k<contractTokenHolderAddresses_.length;k++){
770                     
771                     if(contractTokenHolderAddresses_[k] ==_customerAddress){
772                         
773                      isFound=true;
774                     break;
775                         
776                     }
777                 }
778     
779     
780         if(!isFound){
781         
782             //increment address to keep track of no of users in smartcontract
783             contractAddresses_+=1;  
784             
785             contractTokenHolderAddresses_.push(_customerAddress);
786                         
787             }
788     
789      //calculate 85 percent
790       calculatedPercentage= SafeMath.percent(_incomingEthereum,85,100,18);
791       
792       uint256 _amountOfTokens = ethereumToTokens_(SafeMath.percent(_incomingEthereum,85,100,18));    
793 
794         // we can't give people infinite ethereum
795         if(tokenSupply_ > 0){
796             
797             // add tokens to the pool
798             tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);
799  
800         
801         
802         } else {
803             // add tokens to the pool
804             tokenSupply_ = _amountOfTokens;
805         }
806         
807         // update circulating supply & the ledger address for the customer
808         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);
809         
810         
811         require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));
812         
813         // is the user referred by a Treasure Key?
814         if(
815             // is this a referred purchase?
816             _referredBy != 0x0000000000000000000000000000000000000000 &&
817 
818             // no cheating!
819             _referredBy != _customerAddress &&
820             
821             // does the referrer have at least X whole tokens?
822             // i.e is the referrer a godly chad masternode
823             tokenBalanceLedger_[_referredBy] >= stakingRequirement
824             
825         ){
826            
827      // give 5 % to referral
828      referralBalance_[_referredBy]+= SafeMath.percent(_incomingEthereum,5,100,18);
829      
830      tempReferall+=SafeMath.percent(_incomingEthereum,5,100,18);
831      
832      if(contractAddresses_>0){
833          
834      profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,10,100,18));
835     
836     
837        
838      }
839      
840     } else {
841           
842      
843      if(contractAddresses_>0){
844     
845      profitPerShareAsPerHoldings(SafeMath.percent(_incomingEthereum,15,100,18));
846 
847  
848         
849      }
850             
851         }
852         
853       
854     
855 
856         
857         // fire event
858         onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);
859         
860         //calculate sold tokens here
861         soldTokens_+=_amountOfTokens;
862         
863         return _amountOfTokens;
864     }
865 
866    
867      
868    /**
869      * Calculate Token price based on an amount of incoming ethereum
870      * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;
871      * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.
872      */
873      
874     function ethereumToTokens_(uint256 _ethereum)
875         internal
876         view
877         returns(uint256)
878     {
879         uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;
880         uint256 _tokensReceived = 
881          (
882             (
883                 // underflow attempts BTFO
884                 SafeMath.sub(
885                     (sqrt
886                         (
887                             (_tokenPriceInitial**2)
888                             +
889                             (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))
890                             +
891                             (((tokenPriceIncremental_)**2)*(tokenSupply_**2))
892                             +
893                             (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)
894                         )
895                     ), _tokenPriceInitial
896                 )
897             )/(tokenPriceIncremental_)
898         )-(tokenSupply_)
899         ;
900   
901         return _tokensReceived;
902     }
903     
904     /**
905      * Calculate token sell value.
906           */
907      function tokensToEthereum_(uint256 _tokens)
908         internal
909         view
910         returns(uint256)
911     {
912 
913         uint256 tokens_ = (_tokens + 1e18);
914         uint256 _tokenSupply = (tokenSupply_ + 1e18);
915         uint256 _etherReceived =
916         (
917             // underflow attempts BTFO
918             SafeMath.sub(
919                 (
920                     (
921                         (
922                             tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))
923                         )-tokenPriceIncremental_
924                     )*(tokens_ - 1e18)
925                 ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2
926             )
927         /1e18);
928         return _etherReceived;
929     }
930     
931     //calculate profitPerShare as per holdings
932     function profitPerShareAsPerHoldings(uint256 calculatedDividend)  internal {
933     
934        //calculate number of token 
935        uint256 noOfTokens_;
936         tempCalculatedDividends=calculatedDividend;
937 
938        for(uint i=0;i<contractTokenHolderAddresses_.length;i++){
939          
940          noOfTokens_+= tokenBalanceLedger_[contractTokenHolderAddresses_[i]];
941 
942         }
943         
944         //check if self token balance is zero then distribute to others as per holdings
945         
946     for(uint k=0;k<contractTokenHolderAddresses_.length;k++){
947         
948         if(noOfTokens_>0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]!=0){
949        
950 
951            profitPerShare_=SafeMath.percent(calculatedDividend,tokenBalanceLedger_[contractTokenHolderAddresses_[k]],noOfTokens_,18);
952          
953            tempProfitPerShare=profitPerShare_;
954 
955            payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (profitPerShare_) ;
956            
957            tempIf=1;
958 
959             
960         }else if(noOfTokens_==0 && tokenBalanceLedger_[contractTokenHolderAddresses_[k]]==0){
961             
962             tempIf=2;
963             tempProfitPerShare=profitPerShare_;
964 
965             payoutsTo_[contractTokenHolderAddresses_[k]] += (int256) (calculatedDividend) ;
966         
967             
968         }
969         
970       }
971         
972         
973     
974         
975 
976     
977     }
978     
979     //calculate square root
980     function sqrt(uint x) internal pure returns (uint y) {
981         uint z = (x + 1) / 2;
982         y = x;
983         while (z < y) {
984             y = z;
985             z = (x / z + z) / 2;
986         }
987     }
988 }
989 
990 /**
991  * @title SafeMath
992  * @dev Math operations with safety checks that throw on error
993  */
994 library SafeMath {
995     
996     function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(/*uint division,*/uint quotient) {
997 
998          // caution, check safe-to-multiply here
999         uint _numerator  = numerator * 10 ** (precision+1);
1000         // with rounding of last digit
1001         uint _quotient =  ((_numerator / denominator) + 5) / 10;
1002         
1003        // uint division_=numerator/denominator;
1004         /* value*division_,*/
1005         return (value*_quotient/1000000000000000000);
1006   }
1007 
1008 
1009     
1010     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
1011         if (a == 0) {
1012             return 0;
1013         }
1014         uint256 c = a * b;
1015         assert(c / a == b);
1016         return c;
1017     }
1018 
1019    
1020     function div(uint256 a, uint256 b) internal pure returns (uint256) {
1021         // assert(b > 0); // Solidity automatically throws when dividing by 0
1022         uint256 c = a / b;
1023         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
1024         return c;
1025     }
1026 
1027     
1028     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
1029         assert(b <= a);
1030         return a - b;
1031     }
1032 
1033    
1034     function add(uint256 a, uint256 b) internal pure returns (uint256) {
1035         uint256 c = a + b;
1036         assert(c >= a);
1037         return c;
1038     }
1039 
1040 
1041     
1042 }