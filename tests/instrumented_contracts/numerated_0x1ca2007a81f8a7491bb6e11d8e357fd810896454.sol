1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/distribution/ITokenDistributor.sol": {
5       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC20.sol\";\n\nimport \"./ITokenDistributorParty.sol\";\n\n/// @notice Creates token distributions for parties.\ninterface ITokenDistributor {\n    enum TokenType {\n        Native,\n        Erc20\n    }\n\n    // Info on a distribution, created by createDistribution().\n    struct DistributionInfo {\n        // Type of distribution/token.\n        TokenType tokenType;\n        // ID of the distribution. Assigned by createDistribution().\n        uint256 distributionId;\n        // The party whose members can claim the distribution.\n        ITokenDistributorParty party;\n        // Who can claim `fee`.\n        address payable feeRecipient;\n        // The token being distributed.\n        address token;\n        // Total amount of `token` that can be claimed by party members.\n        uint128 memberSupply;\n        // Amount of `token` to be redeemed by `feeRecipient`.\n        uint128 fee;\n    }\n\n    event DistributionCreated(\n        ITokenDistributorParty indexed party,\n        DistributionInfo info\n    );\n    event DistributionFeeClaimed(\n        ITokenDistributorParty indexed party,\n        address indexed feeRecipient,\n        TokenType tokenType,\n        address token,\n        uint256 amount\n    );\n    event DistributionClaimedByPartyToken(\n        ITokenDistributorParty indexed party,\n        uint256 indexed partyTokenId,\n        address indexed owner,\n        TokenType tokenType,\n        address token,\n        uint256 amountClaimed\n    );\n\n    /// @notice Create a new distribution for an outstanding native token balance\n    ///         governed by a party.\n    /// @dev Native tokens should be transferred directly into this contract\n    ///      immediately prior (same tx) to calling `createDistribution()` or\n    ///      attached to the call itself.\n    /// @param party The party whose members can claim the distribution.\n    /// @param feeRecipient Who can claim `fee`.\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\n    /// @return info Information on the created distribution.\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info);\n\n    /// @notice Create a new distribution for an outstanding ERC20 token balance\n    ///         governed by a party.\n    /// @dev ERC20 tokens should be transferred directly into this contract\n    ///      immediately prior (same tx) to calling `createDistribution()` or\n    ///      attached to the call itself.\n    /// @param token The ERC20 token to distribute.\n    /// @param party The party whose members can claim the distribution.\n    /// @param feeRecipient Who can claim `fee`.\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\n    /// @return info Information on the created distribution.\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info);\n\n    /// @notice Claim a portion of a distribution owed to a `partyTokenId` belonging\n    ///         to the party that created the distribution. The caller\n    ///         must own this token.\n    /// @param info Information on the distribution being claimed.\n    /// @param partyTokenId The ID of the party token to claim for.\n    /// @return amountClaimed The amount of the distribution claimed.\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        external\n        returns (uint128 amountClaimed);\n\n    /// @notice Claim the fee for a distribution. Only a distribution's `feeRecipient`\n    ///         can call this.\n    /// @param info Information on the distribution being claimed.\n    /// @param recipient The address to send the fee to.\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        external;\n\n    /// @notice Batch version of `claim()`.\n    /// @param infos Information on the distributions being claimed.\n    /// @param partyTokenIds The ID of the party tokens to claim for.\n    /// @return amountsClaimed The amount of the distributions claimed.\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed);\n\n    /// @notice Batch version of `claimFee()`.\n    /// @param infos Information on the distributions to claim fees for.\n    /// @param recipients The addresses to send the fees to.\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external;\n\n    /// @notice Compute the amount of a distribution's token are owed to a party\n    ///         member, identified by the `partyTokenId`.\n    /// @param party The party to use for computing the claim amount.\n    /// @param memberSupply Total amount of tokens that can be claimed in the distribution.\n    /// @param partyTokenId The ID of the party token to claim for.\n    /// @return claimAmount The amount of the distribution owed to the party member.\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        external\n        view\n        returns (uint128);\n\n    /// @notice Check whether the fee has been claimed for a distribution.\n    /// @param party The party to use for checking whether the fee has been claimed.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return feeClaimed Whether the fee has been claimed.\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool);\n\n    /// @notice Check whether a `partyTokenId` has claimed their share of a distribution.\n    /// @param party The party to use for checking whether the `partyTokenId` has claimed.\n    /// @param partyTokenId The ID of the party token to check.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return hasClaimed Whether the `partyTokenId` has claimed.\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool);\n\n    /// @notice Get how much unclaimed member tokens are left in a distribution.\n    /// @param party The party to use for checking the unclaimed member tokens.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return remainingMemberSupply The amount of distribution supply remaining.\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128);\n}\n"
6     },
7     "contracts/distribution/ITokenDistributorParty.sol": {
8       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Interface the caller of `ITokenDistributor.createDistribution()` must implement.\ninterface ITokenDistributorParty {\n    /// @notice Return the owner of a token.\n    /// @param tokenId The token ID to query.\n    /// @return owner The owner of `tokenId`.\n    function ownerOf(uint256 tokenId) external view returns (address);\n    /// @notice Return the distribution share of a token. Denominated fractions\n    ///         of 1e18. I.e., 1e18 = 100%.\n    /// @param tokenId The token ID to query.\n    /// @return share The distribution percentage of `tokenId`.\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256);\n}\n"
9     },
10     "contracts/distribution/TokenDistributor.sol": {
11       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\n\nimport \"./ITokenDistributor.sol\";\n\n/// @notice Creates token distributions for parties (or any contract that\n///         implements `ITokenDistributorParty`).\ncontract TokenDistributor is ITokenDistributor {\n    using LibAddress for address payable;\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n\n    struct DistributionState {\n        // The hash of the `DistributionInfo`.\n        bytes32 distributionHash;\n        // The remaining member supply.\n        uint128 remainingMemberSupply;\n        // Whether the distribution's feeRecipient has claimed its fee.\n        bool wasFeeClaimed;\n        // Whether a governance token has claimed its distribution share.\n        mapping(uint256 => bool) hasPartyTokenClaimed;\n    }\n\n    // Arguments for `_createDistribution()`.\n    struct CreateDistributionArgs {\n        ITokenDistributorParty party;\n        TokenType tokenType;\n        address token;\n        uint256 currentTokenBalance;\n        address payable feeRecipient;\n        uint16 feeBps;\n    }\n\n    event EmergencyExecute(address target, bytes data);\n\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error InvalidDistributionInfoError(DistributionInfo info);\n    error DistributionAlreadyClaimedByPartyTokenError(uint256 distributionId, uint256 partyTokenId);\n    error DistributionFeeAlreadyClaimedError(uint256 distributionId);\n    error MustOwnTokenError(address sender, address expectedOwner, uint256 partyTokenId);\n    error EmergencyActionsNotAllowedError();\n    error InvalidDistributionSupplyError(uint128 supply);\n    error OnlyFeeRecipientError(address caller, address feeRecipient);\n    error InvalidFeeBpsError(uint16 feeBps);\n\n    // Token address used to indicate a native distribution (i.e. distribution of ETH).\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    IGlobals public immutable GLOBALS;\n    /// @notice Timestamp when the DAO is no longer allowed to call emergency functions.\n    uint40 public immutable EMERGENCY_DISABLED_TIMESTAMP;\n\n    /// @notice Last distribution ID for a party.\n    mapping(ITokenDistributorParty => uint256) public lastDistributionIdPerParty;\n    /// Last known balance of a token, identified by an ID derived from the token.\n    /// Gets lazily updated when creating and claiming a distribution (transfers).\n    /// Allows one to simply transfer and call `createDistribution()` without\n    /// fussing with allowances.\n    mapping(bytes32 => uint256) private _storedBalances;\n    // tokenDistributorParty => distributionId => DistributionState\n    mapping(ITokenDistributorParty => mapping(uint256 => DistributionState)) private _distributionStates;\n\n    // msg.sender == DAO\n    modifier onlyPartyDao() {\n        {\n            address partyDao = GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // emergencyActionsDisabled == false\n    modifier onlyIfEmergencyActionsAllowed() {\n        if (block.timestamp > EMERGENCY_DISABLED_TIMESTAMP) {\n            revert EmergencyActionsNotAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals, uint40 emergencyDisabledTimestamp) {\n        GLOBALS = globals;\n        EMERGENCY_DISABLED_TIMESTAMP = emergencyDisabledTimestamp;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Native,\n            token: NATIVE_TOKEN_ADDRESS,\n            currentTokenBalance: address(this).balance,\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info)\n    {\n        info = _createDistribution(CreateDistributionArgs({\n            party: party,\n            tokenType: TokenType.Erc20,\n            token: address(token),\n            currentTokenBalance: token.balanceOf(address(this)),\n            feeRecipient: feeRecipient,\n            feeBps: feeBps\n        }));\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        public\n        returns (uint128 amountClaimed)\n    {\n        // Caller must own the party token.\n        {\n            address ownerOfPartyToken = info.party.ownerOf(partyTokenId);\n            if (msg.sender != ownerOfPartyToken) {\n                revert MustOwnTokenError(msg.sender, ownerOfPartyToken, partyTokenId);\n            }\n        }\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // The partyTokenId must not have claimed its distribution yet.\n        if (state.hasPartyTokenClaimed[partyTokenId]) {\n            revert DistributionAlreadyClaimedByPartyTokenError(info.distributionId, partyTokenId);\n        }\n        // Mark the partyTokenId as having claimed their distribution.\n        state.hasPartyTokenClaimed[partyTokenId] = true;\n\n        // Compute amount owed to partyTokenId.\n        amountClaimed = getClaimAmount(info.party, info.memberSupply, partyTokenId);\n\n        // Cap at the remaining member supply. Otherwise a malicious\n        // party could drain more than the distribution supply.\n        uint128 remainingMemberSupply = state.remainingMemberSupply;\n        amountClaimed = amountClaimed > remainingMemberSupply\n            ? remainingMemberSupply\n            : amountClaimed;\n        state.remainingMemberSupply = remainingMemberSupply - amountClaimed;\n\n        // Transfer tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            payable(msg.sender),\n            amountClaimed\n        );\n        emit DistributionClaimedByPartyToken(\n            info.party,\n            partyTokenId,\n            msg.sender,\n            info.tokenType,\n            info.token,\n            amountClaimed\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        public\n    {\n        // DistributionInfo must be correct for this distribution ID.\n        DistributionState storage state = _distributionStates[info.party][info.distributionId];\n        if (state.distributionHash != _getDistributionHash(info)) {\n            revert InvalidDistributionInfoError(info);\n        }\n        // Caller must be the fee recipient.\n        if (info.feeRecipient != msg.sender) {\n            revert OnlyFeeRecipientError(msg.sender, info.feeRecipient);\n        }\n        // Must not have claimed the fee yet.\n        if (state.wasFeeClaimed) {\n            revert DistributionFeeAlreadyClaimedError(info.distributionId);\n        }\n        // Mark the fee as claimed.\n        state.wasFeeClaimed = true;\n        // Transfer the tokens owed.\n        _transfer(\n            info.tokenType,\n            info.token,\n            recipient,\n            info.fee\n        );\n        emit DistributionFeeClaimed(\n            info.party,\n            info.feeRecipient,\n            info.tokenType,\n            info.token,\n            info.fee\n        );\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed)\n    {\n        amountsClaimed = new uint128[](infos.length);\n        for (uint256 i = 0; i < infos.length; ++i) {\n            amountsClaimed[i] = claim(infos[i], partyTokenIds[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external\n    {\n        for (uint256 i = 0; i < infos.length; ++i) {\n            claimFee(infos[i], recipients[i]);\n        }\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        public\n        view\n        returns (uint128)\n    {\n        // getDistributionShareOf() is the fraction of the memberSupply partyTokenId\n        // is entitled to, scaled by 1e18.\n        // We round up here to prevent dust amounts getting trapped in this contract.\n        return (\n            (\n                uint256(party.getDistributionShareOf(partyTokenId))\n                * memberSupply\n                + (1e18 - 1)\n            )\n            / 1e18\n        ).safeCastUint256ToUint128();\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool)\n    {\n        return _distributionStates[party][distributionId].wasFeeClaimed;\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool)\n    {\n        return _distributionStates[party][distributionId].hasPartyTokenClaimed[partyTokenId];\n    }\n\n    /// @inheritdoc ITokenDistributor\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128)\n    {\n        return _distributionStates[party][distributionId].remainingMemberSupply;\n    }\n\n    /// @notice As the DAO, execute an arbitrary delegatecall from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to delegatecall into.\n    /// @param targetCallData The data to pass to the call.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData\n    )\n        external\n        onlyPartyDao\n        onlyIfEmergencyActionsAllowed\n    {\n        (bool success, bytes memory res) = targetAddress.delegatecall(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData);\n    }\n\n    function _createDistribution(CreateDistributionArgs memory args)\n        private\n        returns (DistributionInfo memory info)\n    {\n        if (args.feeBps > 1e4) {\n            revert InvalidFeeBpsError(args.feeBps);\n        }\n        uint128 supply;\n        {\n            bytes32 balanceId = _getBalanceId(args.tokenType, args.token);\n            supply = (args.currentTokenBalance - _storedBalances[balanceId])\n                .safeCastUint256ToUint128();\n            // Supply must be nonzero.\n            if (supply == 0) {\n                revert InvalidDistributionSupplyError(supply);\n            }\n            // Update stored balance.\n            _storedBalances[balanceId] = args.currentTokenBalance;\n        }\n\n        // Create a distribution.\n        uint128 fee = supply * args.feeBps / 1e4;\n        uint128 memberSupply = supply - fee;\n\n        info = DistributionInfo({\n            tokenType: args.tokenType,\n            distributionId: ++lastDistributionIdPerParty[args.party],\n            token: args.token,\n            party: args.party,\n            memberSupply: memberSupply,\n            feeRecipient: args.feeRecipient,\n            fee: fee\n        });\n        (\n            _distributionStates[args.party][info.distributionId].distributionHash,\n            _distributionStates[args.party][info.distributionId].remainingMemberSupply\n        ) = (_getDistributionHash(info), memberSupply);\n        emit DistributionCreated(args.party, info);\n    }\n\n    function _transfer(\n        TokenType tokenType,\n        address token,\n        address payable recipient,\n        uint256 amount\n    )\n        private\n    {\n        bytes32 balanceId = _getBalanceId(tokenType, token);\n        // Reduce stored token balance.\n        uint256 storedBalance = _storedBalances[balanceId] - amount;\n        // Temporarily set to max as a reentrancy guard. An interesing attack\n        // could occur if we didn't do this where an attacker could `claim()` and\n        // reenter upon transfer (eg. in the `tokensToSend` hook of an ERC777) to\n        // `createERC20Distribution()`. Since the `balanceOf(address(this))`\n        // would not of been updated yet, the supply would be miscalculated and\n        // the attacker would create a distribution that essentially steals from\n        // the last distribution they were claiming from. Here, we prevent that\n        // by causing an arithmetic underflow with the supply calculation if\n        // this were to be attempted.\n        _storedBalances[balanceId] = type(uint256).max;\n        if (tokenType == TokenType.Native) {\n            recipient.transferEth(amount);\n        } else {\n            assert(tokenType == TokenType.Erc20);\n            IERC20(token).compatTransfer(recipient, amount);\n        }\n        _storedBalances[balanceId] = storedBalance;\n    }\n\n    function _getDistributionHash(DistributionInfo memory info)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            hash := keccak256(info, 0xe0)\n        }\n    }\n\n    function _getBalanceId(TokenType tokenType, address token)\n        private\n        pure\n        returns (bytes32 balanceId)\n    {\n        if (tokenType == TokenType.Native) {\n            return bytes32(uint256(uint160(NATIVE_TOKEN_ADDRESS)));\n        }\n        assert(tokenType == TokenType.Erc20);\n        return bytes32(uint256(uint160(token)));\n    }\n}\n"
12     },
13     "contracts/globals/IGlobals.sol": {
14       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/Implementation.sol\";\n\n// Single registry of global values controlled by multisig.\n// See `LibGlobals` for all valid keys.\ninterface IGlobals {\n    function getBytes32(uint256 key) external view returns (bytes32);\n    function getUint256(uint256 key) external view returns (uint256);\n    function getBool(uint256 key) external view returns (bool);\n    function getAddress(uint256 key) external view returns (address);\n    function getImplementation(uint256 key) external view returns (Implementation);\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\n\n    function setBytes32(uint256 key, bytes32 value) external;\n    function setUint256(uint256 key, uint256 value) external;\n    function setBool(uint256 key, bool value) external;\n    function setAddress(uint256 key, address value) external;\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\n}\n"
15     },
16     "contracts/globals/LibGlobals.sol": {
17       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Valid keys in `IGlobals`. Append-only.\nlibrary LibGlobals {\n    uint256 internal constant GLOBAL_PARTY_IMPL                     = 1;\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL           = 2;\n    uint256 internal constant GLOBAL_PARTY_FACTORY                  = 3;\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL     = 4;\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL             = 5;\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT        = 6;\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION       = 7;\n    uint256 internal constant GLOBAL_AUCTION_CF_IMPL                = 8;\n    uint256 internal constant GLOBAL_BUY_CF_IMPL                    = 9;\n    uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL         = 10;\n    uint256 internal constant GLOBAL_DAO_WALLET                     = 11;\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR              = 12;\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY            = 13;\n    uint256 internal constant GLOBAL_OPENSEA_ZONE                   = 14;\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION   = 15;\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION      = 16;\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION      = 17;\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT       = 18;\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION          = 19;\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION          = 20;\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS          = 21;\n    uint256 internal constant GLOBAL_RENDERER_STORAGE               = 22;\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION   = 23;\n}\n"
18     },
19     "contracts/tokens/IERC20.sol": {
20       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\n// Minimal ERC20 interface.\ninterface IERC20 {\n    event Transfer(address indexed owner, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 allowance);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 allowance) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n}\n"
21     },
22     "contracts/utils/Implementation.sol": {
23       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Base contract for all contracts intended to be delegatecalled into.\nabstract contract Implementation {\n    error OnlyDelegateCallError();\n    error OnlyConstructorError();\n\n    address public immutable IMPL;\n\n    constructor() { IMPL = address(this); }\n\n    // Reverts if the current function context is not inside of a delegatecall.\n    modifier onlyDelegateCall() virtual {\n        if (address(this) == IMPL) {\n            revert OnlyDelegateCallError();\n        }\n        _;\n    }\n\n    // Reverts if the current function context is not inside of a constructor.\n    modifier onlyConstructor() {\n        uint256 codeSize;\n        assembly { codeSize := extcodesize(address()) }\n        if (codeSize != 0) {\n            revert OnlyConstructorError();\n        }\n        _;\n    }\n}\n"
24     },
25     "contracts/utils/LibAddress.sol": {
26       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibAddress {\n    error EthTransferFailed(address receiver, bytes errData);\n\n    // Transfer ETH with full gas stipend.\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        if (amount == 0) return;\n\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n}\n"
27     },
28     "contracts/utils/LibERC20Compat.sol": {
29       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC20.sol\";\n\n// Compatibility helpers for ERC20s.\nlibrary LibERC20Compat {\n    error NotATokenError(IERC20 token);\n    error TokenTransferFailedError(IERC20 token, address to, uint256 amount);\n\n    // Perform an `IERC20.transfer()` handling non-compliant implementations.\n    function compatTransfer(IERC20 token, address to, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) =\n            address(token).call(abi.encodeCall(IERC20.transfer, (to, amount)));\n        if (s) {\n            if (r.length == 0) {\n                uint256 cs;\n                assembly { cs := extcodesize(token) }\n                if (cs == 0) {\n                    revert NotATokenError(token);\n                }\n                return;\n            }\n            if (abi.decode(r, (bool))) {\n                return;\n            }\n        }\n        revert TokenTransferFailedError(token, to, amount);\n    }\n}\n"
30     },
31     "contracts/utils/LibRawResult.sol": {
32       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibRawResult {\n    // Revert with the data in `b`.\n    function rawRevert(bytes memory b)\n        internal\n        pure\n    {\n        assembly { revert(add(b, 32), mload(b)) }\n    }\n\n    // Return with the data in `b`.\n    function rawReturn(bytes memory b)\n        internal\n        pure\n    {\n        assembly { return(add(b, 32), mload(b)) }\n    }\n}\n"
33     },
34     "contracts/utils/LibSafeCast.sol": {
35       "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibSafeCast {\n    error Uint256ToUint96CastOutOfRange(uint256 v);\n    error Uint256ToInt192CastOutOfRange(uint256 v);\n    error Int192ToUint96CastOutOfRange(int192 i192);\n    error Uint256ToInt128CastOutOfRangeError(uint256 u256);\n    error Uint256ToUint128CastOutOfRangeError(uint256 u256);\n    error Uint256ToUint40CastOutOfRangeError(uint256 u256);\n\n    function safeCastUint256ToUint96(uint256 v) internal pure returns (uint96) {\n        if (v > uint256(type(uint96).max)) {\n            revert Uint256ToUint96CastOutOfRange(v);\n        }\n        return uint96(v);\n    }\n\n    function safeCastUint256ToUint128(uint256 v) internal pure returns (uint128) {\n        if (v > uint256(type(uint128).max)) {\n            revert Uint256ToUint128CastOutOfRangeError(v);\n        }\n        return uint128(v);\n    }\n\n    function safeCastUint256ToInt192(uint256 v) internal pure returns (int192) {\n        if (v > uint256(uint192(type(int192).max))) {\n            revert Uint256ToInt192CastOutOfRange(v);\n        }\n        return int192(uint192(v));\n    }\n\n    function safeCastUint96ToInt192(uint96 v) internal pure returns (int192) {\n        return int192(uint192(v));\n    }\n\n    function safeCastInt192ToUint96(int192 i192) internal pure returns (uint96) {\n        if (i192 < 0 || i192 > int192(uint192(type(uint96).max))) {\n            revert Int192ToUint96CastOutOfRange(i192);\n        }\n        return uint96(uint192(i192));\n    }\n\n    function safeCastUint256ToInt128(uint256 x)\n        internal\n        pure\n        returns (int128)\n    {\n        if (x > uint256(uint128(type(int128).max))) {\n            revert Uint256ToInt128CastOutOfRangeError(x);\n        }\n        return int128(uint128(x));\n    }\n\n    function safeCastUint256ToUint40(uint256 x)\n        internal\n        pure\n        returns (uint40)\n    {\n        if (x > uint256(type(uint40).max)) {\n            revert Uint256ToUint40CastOutOfRangeError(x);\n        }\n        return uint40(x);\n    }\n}\n"
36     }
37   },
38   "settings": {
39     "remappings": [
40       "ds-test/=lib/solmate/lib/ds-test/src/",
41       "forge-std/=lib/forge-std/src/",
42       "openzeppelin/=lib/openzeppelin-contracts/",
43       "solmate/=lib/solmate/src/"
44     ],
45     "optimizer": {
46       "enabled": true,
47       "runs": 200
48     },
49     "metadata": {
50       "bytecodeHash": "ipfs"
51     },
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     },
64     "evmVersion": "london",
65     "libraries": {}
66   }
67 }}