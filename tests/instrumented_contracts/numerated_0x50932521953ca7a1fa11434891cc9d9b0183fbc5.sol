1 pragma solidity ^0.5.2;
2 
3 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
4 
5 /**
6  * @title Elliptic curve signature operations
7  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
8  * TODO Remove this library once solidity supports passing a signature to ecrecover.
9  * See https://github.com/ethereum/solidity/issues/864
10  */
11 
12 library ECDSA {
13     /**
14      * @dev Recover signer address from a message by using their signature
15      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
16      * @param signature bytes signature, the signature is generated using web3.eth.sign()
17      */
18     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
19         bytes32 r;
20         bytes32 s;
21         uint8 v;
22 
23         // Check the signature length
24         if (signature.length != 65) {
25             return (address(0));
26         }
27 
28         // Divide the signature in r, s and v variables
29         // ecrecover takes the signature parameters, and the only way to get them
30         // currently is to use assembly.
31         // solhint-disable-next-line no-inline-assembly
32         assembly {
33             r := mload(add(signature, 0x20))
34             s := mload(add(signature, 0x40))
35             v := byte(0, mload(add(signature, 0x60)))
36         }
37 
38         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
39         if (v < 27) {
40             v += 27;
41         }
42 
43         // If the version is correct return the signer address
44         if (v != 27 && v != 28) {
45             return (address(0));
46         } else {
47             return ecrecover(hash, v, r, s);
48         }
49     }
50 
51     /**
52      * toEthSignedMessageHash
53      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
54      * and hash the result
55      */
56     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
57         // 32 is the length in bytes of hash,
58         // enforced by the type signature above
59         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
60     }
61 }
62 
63 // File: /Users/oren/daostack/daostack2/infra/contracts/votingMachines/IntVoteInterface.sol
64 
65 interface IntVoteInterface {
66     //When implementing this interface please do not only override function and modifier,
67     //but also to keep the modifiers on the overridden functions.
68     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
69     modifier votable(bytes32 _proposalId) {revert(); _;}
70 
71     event NewProposal(
72         bytes32 indexed _proposalId,
73         address indexed _organization,
74         uint256 _numOfChoices,
75         address _proposer,
76         bytes32 _paramsHash
77     );
78 
79     event ExecuteProposal(bytes32 indexed _proposalId,
80         address indexed _organization,
81         uint256 _decision,
82         uint256 _totalReputation
83     );
84 
85     event VoteProposal(
86         bytes32 indexed _proposalId,
87         address indexed _organization,
88         address indexed _voter,
89         uint256 _vote,
90         uint256 _reputation
91     );
92 
93     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
94     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
95 
96     /**
97      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
98      * generated by calculating keccak256 of a incremented counter.
99      * @param _numOfChoices number of voting choices
100      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
101      * @param _proposer address
102      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
103      * @return proposal's id.
104      */
105     function propose(
106         uint256 _numOfChoices,
107         bytes32 _proposalParameters,
108         address _proposer,
109         address _organization
110         ) external returns(bytes32);
111 
112     function vote(
113         bytes32 _proposalId,
114         uint256 _vote,
115         uint256 _rep,
116         address _voter
117     )
118     external
119     returns(bool);
120 
121     function cancelVote(bytes32 _proposalId) external;
122 
123     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
124 
125     function isVotable(bytes32 _proposalId) external view returns(bool);
126 
127     /**
128      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
129      * @param _proposalId the ID of the proposal
130      * @param _choice the index in the
131      * @return voted reputation for the given choice
132      */
133     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
134 
135     /**
136      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
137      * @return bool true or false
138      */
139     function isAbstainAllow() external pure returns(bool);
140 
141     /**
142      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
143      * @return min - minimum number of choices
144                max - maximum number of choices
145      */
146     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
147 }
148 
149 // File: /Users/oren/daostack/daostack2/infra/contracts/libs/RealMath.sol
150 
151 /**
152  * RealMath: fixed-point math library, based on fractional and integer parts.
153  * Using uint256 as real216x40, which isn't in Solidity yet.
154  * 40 fractional bits gets us down to 1E-12 precision, while still letting us
155  * go up to galaxy scale counting in meters.
156  * Internally uses the wider uint256 for some math.
157  *
158  * Note that for addition, subtraction, and mod (%), you should just use the
159  * built-in Solidity operators. Functions for these operations are not provided.
160  *
161  */
162 
163 
164 library RealMath {
165 
166     /**
167      * How many total bits are there?
168      */
169     uint256 constant private REAL_BITS = 256;
170 
171     /**
172      * How many fractional bits are there?
173      */
174     uint256 constant private REAL_FBITS = 40;
175 
176     /**
177      * What's the first non-fractional bit
178      */
179     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
180 
181     /**
182      * Raise a real number to any positive integer power
183      */
184     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
185 
186         uint256 tempRealBase = realBase;
187         uint256 tempExponent = exponent;
188 
189         // Start with the 0th power
190         uint256 realResult = REAL_ONE;
191         while (tempExponent != 0) {
192             // While there are still bits set
193             if ((tempExponent & 0x1) == 0x1) {
194                 // If the low bit is set, multiply in the (many-times-squared) base
195                 realResult = mul(realResult, tempRealBase);
196             }
197             // Shift off the low bit
198             tempExponent = tempExponent >> 1;
199             // Do the squaring
200             tempRealBase = mul(tempRealBase, tempRealBase);
201         }
202 
203         // Return the final result.
204         return uint216(realResult / REAL_ONE);
205     }
206 
207     /**
208      * Create a real from a rational fraction.
209      */
210     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
211         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
212     }
213 
214     /**
215      * Multiply one real by another. Truncates overflows.
216      */
217     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
218         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
219         // So we just have to clip off the extra REAL_FBITS fractional bits.
220         return uint256((uint256(realA) * uint256(realB)) >> REAL_FBITS);
221     }
222 
223     /**
224      * Divide one real by another real. Truncates overflows.
225      */
226     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
227         // We use the reverse of the multiplication trick: convert numerator from
228         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
229         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
230     }
231 
232 }
233 
234 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
235 
236 /**
237  * @title ERC20 interface
238  * @dev see https://github.com/ethereum/EIPs/issues/20
239  */
240 interface IERC20 {
241     function transfer(address to, uint256 value) external returns (bool);
242 
243     function approve(address spender, uint256 value) external returns (bool);
244 
245     function transferFrom(address from, address to, uint256 value) external returns (bool);
246 
247     function totalSupply() external view returns (uint256);
248 
249     function balanceOf(address who) external view returns (uint256);
250 
251     function allowance(address owner, address spender) external view returns (uint256);
252 
253     event Transfer(address indexed from, address indexed to, uint256 value);
254 
255     event Approval(address indexed owner, address indexed spender, uint256 value);
256 }
257 
258 // File: /Users/oren/daostack/daostack2/infra/contracts/votingMachines/VotingMachineCallbacksInterface.sol
259 
260 interface VotingMachineCallbacksInterface {
261     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
262     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
263 
264     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
265     external
266     returns(bool);
267 
268     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
269     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
270     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
271 }
272 
273 // File: /Users/oren/daostack/daostack2/infra/contracts/votingMachines/ProposalExecuteInterface.sol
274 
275 interface ProposalExecuteInterface {
276     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
277 }
278 
279 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
280 
281 /**
282  * @title SafeMath
283  * @dev Unsigned math operations with safety checks that revert on error
284  */
285 library SafeMath {
286     /**
287     * @dev Multiplies two unsigned integers, reverts on overflow.
288     */
289     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
290         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
291         // benefit is lost if 'b' is also tested.
292         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
293         if (a == 0) {
294             return 0;
295         }
296 
297         uint256 c = a * b;
298         require(c / a == b);
299 
300         return c;
301     }
302 
303     /**
304     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
305     */
306     function div(uint256 a, uint256 b) internal pure returns (uint256) {
307         // Solidity only automatically asserts when dividing by 0
308         require(b > 0);
309         uint256 c = a / b;
310         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
311 
312         return c;
313     }
314 
315     /**
316     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
317     */
318     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
319         require(b <= a);
320         uint256 c = a - b;
321 
322         return c;
323     }
324 
325     /**
326     * @dev Adds two unsigned integers, reverts on overflow.
327     */
328     function add(uint256 a, uint256 b) internal pure returns (uint256) {
329         uint256 c = a + b;
330         require(c >= a);
331 
332         return c;
333     }
334 
335     /**
336     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
337     * reverts when dividing by zero.
338     */
339     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
340         require(b != 0);
341         return a % b;
342     }
343 }
344 
345 // File: openzeppelin-solidity/contracts/math/Math.sol
346 
347 /**
348  * @title Math
349  * @dev Assorted math operations
350  */
351 library Math {
352     /**
353     * @dev Returns the largest of two numbers.
354     */
355     function max(uint256 a, uint256 b) internal pure returns (uint256) {
356         return a >= b ? a : b;
357     }
358 
359     /**
360     * @dev Returns the smallest of two numbers.
361     */
362     function min(uint256 a, uint256 b) internal pure returns (uint256) {
363         return a < b ? a : b;
364     }
365 
366     /**
367     * @dev Calculates the average of two numbers. Since these are integers,
368     * averages of an even and odd number cannot be represented, and will be
369     * rounded down.
370     */
371     function average(uint256 a, uint256 b) internal pure returns (uint256) {
372         // (a + b) / 2 can overflow, so we distribute
373         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
374     }
375 }
376 
377 // File: openzeppelin-solidity/contracts/utils/Address.sol
378 
379 /**
380  * Utility library of inline functions on addresses
381  */
382 library Address {
383     /**
384      * Returns whether the target address is a contract
385      * @dev This function will return false if invoked during the constructor of a contract,
386      * as the code is not actually created until after the constructor finishes.
387      * @param account address of the account to check
388      * @return whether the target address is a contract
389      */
390     function isContract(address account) internal view returns (bool) {
391         uint256 size;
392         // XXX Currently there is no better way to check if there is a contract in an address
393         // than to check the size of the code at that address.
394         // See https://ethereum.stackexchange.com/a/14016/36603
395         // for more details about how this works.
396         // TODO Check this again before the Serenity release, because all addresses will be
397         // contracts then.
398         // solhint-disable-next-line no-inline-assembly
399         assembly { size := extcodesize(account) }
400         return size > 0;
401     }
402 }
403 
404 // File: /Users/oren/daostack/daostack2/infra/contracts/votingMachines/GenesisProtocolLogic.sol
405 
406 /**
407  * @title GenesisProtocol implementation -an organization's voting machine scheme.
408  */
409 contract GenesisProtocolLogic is IntVoteInterface {
410     using SafeMath for uint;
411     using Math for uint;
412     using RealMath for uint216;
413     using RealMath for uint256;
414     using Address for address;
415 
416     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
417     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
418 
419     //Organization's parameters
420     struct Parameters {
421         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
422         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
423         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
424         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
425                                           //to be in an preparation state (stable) before boosted.
426         uint256 thresholdConst; //constant  for threshold calculation .
427                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
428         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
429                                    //in the threshold calculation to prevent overflow
430         uint256 quietEndingPeriod; //quite ending period
431         uint256 proposingRepReward;//proposer reputation reward.
432         uint256 votersReputationLossRatio;//Unsuccessful pre booster
433                                           //voters lose votersReputationLossRatio% of their reputation.
434         uint256 minimumDaoBounty;
435         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
436                                //(daoBountyConst * averageBoostDownstakes)/100 .
437         uint256 activationTime;//the point in time after which proposals can be created.
438         //if this address is set so only this address is allowed to vote of behalf of someone else.
439         address voteOnBehalf;
440     }
441 
442     struct Voter {
443         uint256 vote; // YES(1) ,NO(2)
444         uint256 reputation; // amount of voter's reputation
445         bool preBoosted;
446     }
447 
448     struct Staker {
449         uint256 vote; // YES(1) ,NO(2)
450         uint256 amount; // amount of staker's stake
451         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
452     }
453 
454     struct Proposal {
455         bytes32 organizationId; // the organization unique identifier the proposal is target to.
456         address callbacks;    // should fulfill voting callbacks interface.
457         ProposalState state;
458         uint256 winningVote; //the winning vote.
459         address proposer;
460         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
461         uint256 currentBoostedVotePeriodLimit;
462         bytes32 paramsHash;
463         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
464         uint256 daoBounty;
465         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
466         uint256 confidenceThreshold;
467         //The percentage from upper stakes which the caller for the expiration was given.
468         uint256 expirationCallBountyPercentage;
469         uint[3] times; //times[0] - submittedTime
470                        //times[1] - boostedPhaseTime
471                        //times[2] -preBoostedPhaseTime;
472         //      vote      reputation
473         mapping(uint256   =>  uint256    ) votes;
474         //      vote      reputation
475         mapping(uint256   =>  uint256    ) preBoostedVotes;
476         //      address     voter
477         mapping(address =>  Voter    ) voters;
478         //      vote        stakes
479         mapping(uint256   =>  uint256    ) stakes;
480         //      address  staker
481         mapping(address  => Staker   ) stakers;
482     }
483 
484     event Stake(bytes32 indexed _proposalId,
485         address indexed _organization,
486         address indexed _staker,
487         uint256 _vote,
488         uint256 _amount
489     );
490 
491     event Redeem(bytes32 indexed _proposalId,
492         address indexed _organization,
493         address indexed _beneficiary,
494         uint256 _amount
495     );
496 
497     event RedeemDaoBounty(bytes32 indexed _proposalId,
498         address indexed _organization,
499         address indexed _beneficiary,
500         uint256 _amount
501     );
502 
503     event RedeemReputation(bytes32 indexed _proposalId,
504         address indexed _organization,
505         address indexed _beneficiary,
506         uint256 _amount
507     );
508 
509     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
510     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
511     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
512 
513     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
514     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
515     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
516            //organizationId => organization
517     mapping(bytes32        => address     ) public organizations;
518           //organizationId => averageBoostDownstakes
519     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
520     uint256 constant public NUM_OF_CHOICES = 2;
521     uint256 constant public NO = 2;
522     uint256 constant public YES = 1;
523     uint256 public proposalsCnt; // Total number of proposals
524     IERC20 public stakingToken;
525     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
526     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
527 
528     /**
529      * @dev Constructor
530      */
531     constructor(IERC20 _stakingToken) public {
532       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
533       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
534       //If such contract address does not exist in the network (e.g ganache)
535       //the contract will use the _stakingToken param as the
536       //staking token address.
537         if (address(GEN_TOKEN_ADDRESS).isContract()) {
538             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
539         } else {
540             stakingToken = _stakingToken;
541         }
542     }
543 
544   /**
545    * @dev Check that the proposal is votable
546    * a proposal is votable if it is in one of the following states:
547    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
548    */
549     modifier votable(bytes32 _proposalId) {
550         require(_isVotable(_proposalId));
551         _;
552     }
553 
554     /**
555      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
556      * generated by calculating keccak256 of a incremented counter.
557      * @param _paramsHash parameters hash
558      * @param _proposer address
559      * @param _organization address
560      */
561     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
562         external
563         returns(bytes32)
564     {
565       // solhint-disable-next-line not-rely-on-time
566         require(now > parameters[_paramsHash].activationTime, "not active yet");
567         //Check parameters existence.
568         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
569         // Generate a unique ID:
570         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
571         proposalsCnt = proposalsCnt.add(1);
572          // Open proposal:
573         Proposal memory proposal;
574         proposal.callbacks = msg.sender;
575         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
576 
577         proposal.state = ProposalState.Queued;
578         // solhint-disable-next-line not-rely-on-time
579         proposal.times[0] = now;//submitted time
580         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
581         proposal.proposer = _proposer;
582         proposal.winningVote = NO;
583         proposal.paramsHash = _paramsHash;
584         if (organizations[proposal.organizationId] == address(0)) {
585             if (_organization == address(0)) {
586                 organizations[proposal.organizationId] = msg.sender;
587             } else {
588                 organizations[proposal.organizationId] = _organization;
589             }
590         }
591         //calc dao bounty
592         uint256 daoBounty =
593         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
594         if (daoBounty < parameters[_paramsHash].minimumDaoBounty) {
595             proposal.daoBountyRemain = parameters[_paramsHash].minimumDaoBounty;
596         } else {
597             proposal.daoBountyRemain = daoBounty;
598         }
599         proposal.totalStakes = proposal.daoBountyRemain;
600         proposals[proposalId] = proposal;
601         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
602         Staker storage staker = proposals[proposalId].stakers[organizations[proposal.organizationId]];
603         staker.vote = NO;
604         staker.amount = proposal.daoBountyRemain;
605 
606         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
607         return proposalId;
608     }
609 
610     /**
611       * @dev executeBoosted try to execute a boosted proposal if it is expired
612       * @param _proposalId the id of the proposal
613       * @return uint256 expirationCallBounty the bounty amount for the expiration call
614      */
615     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
616         Proposal storage proposal = proposals[_proposalId];
617         require(proposal.state == ProposalState.Boosted);
618         require(_execute(_proposalId), "proposal need to expire");
619         uint256 expirationCallBountyPercentage =
620         // solhint-disable-next-line not-rely-on-time
621         (uint(1).add(now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1])).div(15)));
622         if (expirationCallBountyPercentage > 100) {
623             expirationCallBountyPercentage = 100;
624         }
625         proposal.expirationCallBountyPercentage = expirationCallBountyPercentage;
626         expirationCallBounty = expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100);
627         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
628         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
629     }
630 
631     /**
632      * @dev hash the parameters, save them if necessary, and return the hash value
633      * @param _params a parameters array
634      *    _params[0] - _queuedVoteRequiredPercentage,
635      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
636      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
637      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
638      *                  state (stable) before boosted.
639      *    _params[4] -_thresholdConst
640      *    _params[5] -_quietEndingPeriod
641      *    _params[6] -_proposingRepReward
642      *    _params[7] -_votersReputationLossRatio
643      *    _params[8] -_minimumDaoBounty
644      *    _params[9] -_daoBountyConst
645      *    _params[10] -_activationTime
646      * @param _voteOnBehalf - authorized to vote on behalf of others.
647     */
648     function setParameters(
649         uint[11] calldata _params, //use array here due to stack too deep issue.
650         address _voteOnBehalf
651     )
652     external
653     returns(bytes32)
654     {
655         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
656         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
657         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
658         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
659         require(_params[8] > 0, "minimumDaoBounty should be > 0");
660         require(_params[9] > 0, "daoBountyConst should be > 0");
661 
662         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
663         //set a limit for power for a given alpha to prevent overflow
664         uint256 limitExponent = 172;//for alpha less or equal 2
665         uint256 j = 2;
666         for (uint256 i = 2000; i < 16000; i = i*2) {
667             if ((_params[4] > i) && (_params[4] <= i*2)) {
668                 limitExponent = limitExponent/j;
669                 break;
670             }
671             j++;
672         }
673 
674         parameters[paramsHash] = Parameters({
675             queuedVoteRequiredPercentage: _params[0],
676             queuedVotePeriodLimit: _params[1],
677             boostedVotePeriodLimit: _params[2],
678             preBoostedVotePeriodLimit: _params[3],
679             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
680             limitExponentValue:limitExponent,
681             quietEndingPeriod: _params[5],
682             proposingRepReward: _params[6],
683             votersReputationLossRatio:_params[7],
684             minimumDaoBounty:_params[8],
685             daoBountyConst:_params[9],
686             activationTime:_params[10],
687             voteOnBehalf:_voteOnBehalf
688         });
689         return paramsHash;
690     }
691 
692     /**
693      * @dev redeem a reward for a successful stake, vote or proposing.
694      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
695      * users to redeem on behalf of someone else.
696      * @param _proposalId the ID of the proposal
697      * @param _beneficiary - the beneficiary address
698      * @return rewards -
699      *           [0] stakerTokenReward
700      *           [1] voterReputationReward
701      *           [2] proposerReputationReward
702      */
703      // solhint-disable-next-line function-max-lines,code-complexity
704     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
705         Proposal storage proposal = proposals[_proposalId];
706         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
707         "Proposal should be Executed or ExpiredInQueue");
708         Parameters memory params = parameters[proposal.paramsHash];
709         uint256 lostReputation;
710         if (proposal.winningVote == YES) {
711             lostReputation = proposal.preBoostedVotes[NO];
712         } else {
713             lostReputation = proposal.preBoostedVotes[YES];
714         }
715         lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
716         //as staker
717         Staker storage staker = proposal.stakers[_beneficiary];
718         if (staker.amount > 0) {
719             if (proposal.state == ProposalState.ExpiredInQueue) {
720                 //Stakes of a proposal that expires in Queue are sent back to stakers
721                 rewards[0] = staker.amount;
722             } else if (staker.vote == proposal.winningVote) {
723                 uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
724                 uint256 totalStakes = proposal.stakes[YES].add(proposal.stakes[NO]);
725                 if (staker.vote == YES) {
726                     uint256 _totalStakes =
727                     ((totalStakes.mul(100 - proposal.expirationCallBountyPercentage))/100) - proposal.daoBounty;
728                     rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
729                 } else {
730                     rewards[0] = (staker.amount.mul(totalStakes))/totalWinningStakes;
731                     if (organizations[proposal.organizationId] == _beneficiary) {
732                           //dao redeem it reward
733                         rewards[0] = rewards[0].sub(proposal.daoBounty);
734                     }
735                 }
736             }
737             staker.amount = 0;
738         }
739         //as voter
740         Voter storage voter = proposal.voters[_beneficiary];
741         if ((voter.reputation != 0) && (voter.preBoosted)) {
742             if (proposal.state == ProposalState.ExpiredInQueue) {
743               //give back reputation for the voter
744                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
745             } else if (proposal.winningVote == voter.vote) {
746                 uint256 preBoostedVotes = proposal.preBoostedVotes[YES].add(proposal.preBoostedVotes[NO]);
747                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
748                 .add((voter.reputation.mul(lostReputation))/preBoostedVotes);
749             }
750             voter.reputation = 0;
751         }
752         //as proposer
753         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
754             rewards[2] = params.proposingRepReward;
755             proposal.proposer = address(0);
756         }
757         if (rewards[0] != 0) {
758             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
759             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
760             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
761         }
762         if (rewards[1].add(rewards[2]) != 0) {
763             VotingMachineCallbacksInterface(proposal.callbacks)
764             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
765             emit RedeemReputation(
766             _proposalId,
767             organizations[proposal.organizationId],
768             _beneficiary,
769             rewards[1].add(rewards[2])
770             );
771         }
772     }
773 
774     /**
775      * @dev redeemDaoBounty a reward for a successful stake.
776      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
777      * users to redeem on behalf of someone else.
778      * @param _proposalId the ID of the proposal
779      * @param _beneficiary - the beneficiary address
780      * @return redeemedAmount - redeem token amount
781      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
782      */
783     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
784     public
785     returns(uint256 redeemedAmount, uint256 potentialAmount) {
786         Proposal storage proposal = proposals[_proposalId];
787         require(proposal.state == ProposalState.Executed);
788         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
789         Staker storage staker = proposal.stakers[_beneficiary];
790         if (
791             (staker.amount4Bounty > 0)&&
792             (staker.vote == proposal.winningVote)&&
793             (proposal.winningVote == YES)&&
794             (totalWinningStakes != 0)) {
795             //as staker
796                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
797             }
798         if ((potentialAmount != 0)&&
799             (VotingMachineCallbacksInterface(proposal.callbacks)
800             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
801             staker.amount4Bounty = 0;
802             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
803             require(
804             VotingMachineCallbacksInterface(proposal.callbacks)
805             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
806             redeemedAmount = potentialAmount;
807             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
808         }
809     }
810 
811     /**
812      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
813      * @param _proposalId the ID of the proposal
814      * @return bool true or false.
815      */
816     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
817         Proposal memory proposal = proposals[_proposalId];
818         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
819     }
820 
821     /**
822      * @dev threshold return the organization's score threshold which required by
823      * a proposal to shift to boosted state.
824      * This threshold is dynamically set and it depend on the number of boosted proposal.
825      * @param _organizationId the organization identifier
826      * @param _paramsHash the organization parameters hash
827      * @return uint256 organization's score threshold.
828      */
829     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
830         uint256 power = orgBoostedProposalsCnt[_organizationId];
831         Parameters storage params = parameters[_paramsHash];
832 
833         if (power > params.limitExponentValue) {
834             power = params.limitExponentValue;
835         }
836 
837         return params.thresholdConst.pow(power);
838     }
839 
840   /**
841    * @dev hashParameters returns a hash of the given parameters
842    */
843     function getParametersHash(
844         uint[11] memory _params,//use array here due to stack too deep issue.
845         address _voteOnBehalf
846     )
847         public
848         pure
849         returns(bytes32)
850         {
851         //double call to keccak256 to avoid deep stack issue when call with too many params.
852         return keccak256(
853             abi.encodePacked(
854             keccak256(
855             abi.encodePacked(
856                 _params[0],
857                 _params[1],
858                 _params[2],
859                 _params[3],
860                 _params[4],
861                 _params[5],
862                 _params[6],
863                 _params[7],
864                 _params[8],
865                 _params[9],
866                 _params[10])
867             ),
868             _voteOnBehalf
869         ));
870     }
871 
872     /**
873       * @dev execute check if the proposal has been decided, and if so, execute the proposal
874       * @param _proposalId the id of the proposal
875       * @return bool true - the proposal has been executed
876       *              false - otherwise.
877      */
878      // solhint-disable-next-line function-max-lines,code-complexity
879     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
880         Proposal storage proposal = proposals[_proposalId];
881         Parameters memory params = parameters[proposal.paramsHash];
882         Proposal memory tmpProposal = proposal;
883         uint256 totalReputation =
884         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
885         //first divide by 100 to prevent overflow
886         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
887         ExecutionState executionState = ExecutionState.None;
888         uint256 averageDownstakesOfBoosted;
889         uint256 confidenceThreshold;
890 
891         if (proposal.votes[proposal.winningVote] > executionBar) {
892          // someone crossed the absolute vote execution bar.
893             if (proposal.state == ProposalState.Queued) {
894                 executionState = ExecutionState.QueueBarCrossed;
895             } else if (proposal.state == ProposalState.PreBoosted) {
896                 executionState = ExecutionState.PreBoostedBarCrossed;
897             } else {
898                 executionState = ExecutionState.BoostedBarCrossed;
899             }
900             proposal.state = ProposalState.Executed;
901         } else {
902             if (proposal.state == ProposalState.Queued) {
903                 // solhint-disable-next-line not-rely-on-time
904                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
905                     proposal.state = ProposalState.ExpiredInQueue;
906                     proposal.winningVote = NO;
907                     executionState = ExecutionState.QueueTimeOut;
908                 } else {
909                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
910                     if (_score(_proposalId) > confidenceThreshold) {
911                         //change proposal mode to PreBoosted mode.
912                         proposal.state = ProposalState.PreBoosted;
913                         // solhint-disable-next-line not-rely-on-time
914                         proposal.times[2] = now;
915                         proposal.confidenceThreshold = confidenceThreshold;
916                     }
917                 }
918             }
919 
920             if (proposal.state == ProposalState.PreBoosted) {
921                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
922               // solhint-disable-next-line not-rely-on-time
923                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
924                     if ((_score(_proposalId) > confidenceThreshold) &&
925                         (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)) {
926                        //change proposal mode to Boosted mode.
927                         proposal.state = ProposalState.Boosted;
928                        // solhint-disable-next-line not-rely-on-time
929                         proposal.times[1] = now;
930                         orgBoostedProposalsCnt[proposal.organizationId]++;
931                        //add a value to average -> average = average + ((value - average) / nbValues)
932                         averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
933                         // solium-disable-next-line indentation
934                         averagesDownstakesOfBoosted[proposal.organizationId] =
935                             uint256(int256(averageDownstakesOfBoosted) +
936                             ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
937                             int256(orgBoostedProposalsCnt[proposal.organizationId])));
938                     }
939                 } else { //check the Confidence level is stable
940                     uint256 proposalScore = _score(_proposalId);
941                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
942                         proposal.state = ProposalState.Queued;
943                     } else if (proposal.confidenceThreshold > proposalScore) {
944                         proposal.confidenceThreshold = confidenceThreshold;
945                     }
946                 }
947             }
948         }
949 
950         if ((proposal.state == ProposalState.Boosted) ||
951             (proposal.state == ProposalState.QuietEndingPeriod)) {
952             // solhint-disable-next-line not-rely-on-time
953             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
954                 proposal.state = ProposalState.Executed;
955                 executionState = ExecutionState.BoostedTimeOut;
956             }
957         }
958 
959         if (executionState != ExecutionState.None) {
960             if ((executionState == ExecutionState.BoostedTimeOut) ||
961                 (executionState == ExecutionState.BoostedBarCrossed)) {
962                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
963                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
964                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
965                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
966                 if (boostedProposals == 0) {
967                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
968                 } else {
969                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
970                     averagesDownstakesOfBoosted[proposal.organizationId] =
971                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
972                 }
973             }
974             emit ExecuteProposal(
975             _proposalId,
976             organizations[proposal.organizationId],
977             proposal.winningVote,
978             totalReputation
979             );
980             emit GPExecuteProposal(_proposalId, executionState);
981             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
982             proposal.daoBounty = proposal.daoBountyRemain;
983         }
984         if (tmpProposal.state != proposal.state) {
985             emit StateChange(_proposalId, proposal.state);
986         }
987         return (executionState != ExecutionState.None);
988     }
989 
990     /**
991      * @dev staking function
992      * @param _proposalId id of the proposal
993      * @param _vote  NO(2) or YES(1).
994      * @param _amount the betting amount
995      * @return bool true - the proposal has been executed
996      *              false - otherwise.
997      */
998     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
999         // 0 is not a valid vote.
1000         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1001         require(_amount > 0, "staking amount should be >0");
1002 
1003         if (_execute(_proposalId)) {
1004             return true;
1005         }
1006         Proposal storage proposal = proposals[_proposalId];
1007 
1008         if ((proposal.state != ProposalState.PreBoosted) &&
1009             (proposal.state != ProposalState.Queued)) {
1010             return false;
1011         }
1012 
1013         // enable to increase stake only on the previous stake vote
1014         Staker storage staker = proposal.stakers[_staker];
1015         if ((staker.amount > 0) && (staker.vote != _vote)) {
1016             return false;
1017         }
1018 
1019         uint256 amount = _amount;
1020         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1021         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1022         staker.amount = staker.amount.add(amount);
1023         //This is to prevent average downstakes calculation overflow
1024         //Note that any how GEN cap is 100000000 ether.
1025         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1026         require(proposal.totalStakes <= 0x100000000000000000000000000000000, "total stakes is too high");
1027 
1028         if (_vote == YES) {
1029             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1030         }
1031         staker.vote = _vote;
1032 
1033         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1034         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1035         return _execute(_proposalId);
1036     }
1037 
1038     /**
1039      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1040      * @param _proposalId id of the proposal
1041      * @param _voter used in case the vote is cast for someone else
1042      * @param _vote a value between 0 to and the proposal's number of choices.
1043      * @param _rep how many reputation the voter would like to stake for this vote.
1044      *         if  _rep==0 so the voter full reputation will be use.
1045      * @return true in case of proposal execution otherwise false
1046      * throws if proposal is not open or if it has been executed
1047      * NB: executes the proposal if a decision has been reached
1048      */
1049      // solhint-disable-next-line function-max-lines,code-complexity
1050     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1051         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1052         if (_execute(_proposalId)) {
1053             return true;
1054         }
1055 
1056         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1057         Proposal storage proposal = proposals[_proposalId];
1058 
1059         // Check voter has enough reputation:
1060         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
1061         require(reputation > 0, "_voter must have reputation");
1062         require(reputation >= _rep, "reputation >= _rep");
1063         uint256 rep = _rep;
1064         if (rep == 0) {
1065             rep = reputation;
1066         }
1067         // If this voter has already voted, return false.
1068         if (proposal.voters[_voter].reputation != 0) {
1069             return false;
1070         }
1071         // The voting itself:
1072         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
1073         //check if the current winningVote changed or there is a tie.
1074         //for the case there is a tie the current winningVote set to NO.
1075         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
1076             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
1077             proposal.winningVote == YES)) {
1078             if (proposal.state == ProposalState.Boosted &&
1079             // solhint-disable-next-line not-rely-on-time
1080                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
1081                 proposal.state == ProposalState.QuietEndingPeriod) {
1082                 //quietEndingPeriod
1083                 if (proposal.state != ProposalState.QuietEndingPeriod) {
1084                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
1085                     proposal.state = ProposalState.QuietEndingPeriod;
1086                 }
1087                 // solhint-disable-next-line not-rely-on-time
1088                 proposal.times[1] = now;
1089             }
1090             proposal.winningVote = _vote;
1091         }
1092         proposal.voters[_voter] = Voter({
1093             reputation: rep,
1094             vote: _vote,
1095             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
1096         });
1097         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
1098             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
1099             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
1100             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
1101         }
1102         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
1103         return _execute(_proposalId);
1104     }
1105 
1106     /**
1107      * @dev _score return the proposal score (Confidence level)
1108      * For dual choice proposal S = (S+)/(S-)
1109      * @param _proposalId the ID of the proposal
1110      * @return uint256 proposal score.
1111      */
1112     function _score(bytes32 _proposalId) internal view returns(uint256) {
1113         Proposal storage proposal = proposals[_proposalId];
1114         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
1115         return proposal.stakes[YES]/proposal.stakes[NO];
1116     }
1117 
1118     /**
1119       * @dev _isVotable check if the proposal is votable
1120       * @param _proposalId the ID of the proposal
1121       * @return bool true or false
1122     */
1123     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
1124         ProposalState pState = proposals[_proposalId].state;
1125         return ((pState == ProposalState.PreBoosted)||
1126                 (pState == ProposalState.Boosted)||
1127                 (pState == ProposalState.QuietEndingPeriod)||
1128                 (pState == ProposalState.Queued)
1129         );
1130     }
1131 }
1132 
1133 // File: contracts/votingMachines/GenesisProtocol.sol
1134 
1135 /**
1136  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1137  */
1138 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
1139     using ECDSA for bytes32;
1140 
1141     // Digest describing the data the user signs according EIP 712.
1142     // Needs to match what is passed to Metamask.
1143     bytes32 public constant DELEGATION_HASH_EIP712 =
1144     keccak256(abi.encodePacked(
1145     "address GenesisProtocolAddress",
1146     "bytes32 ProposalId",
1147     "uint256 Vote",
1148     "uint256 AmountToStake",
1149     "uint256 Nonce"
1150     ));
1151 
1152     mapping(address=>uint256) public stakesNonce; //stakes Nonce
1153 
1154     /**
1155      * @dev Constructor
1156      */
1157     constructor(IERC20 _stakingToken)
1158     public
1159     // solhint-disable-next-line no-empty-blocks
1160     GenesisProtocolLogic(_stakingToken) {
1161     }
1162 
1163     /**
1164      * @dev staking function
1165      * @param _proposalId id of the proposal
1166      * @param _vote  NO(2) or YES(1).
1167      * @param _amount the betting amount
1168      * @return bool true - the proposal has been executed
1169      *              false - otherwise.
1170      */
1171     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
1172         return _stake(_proposalId, _vote, _amount, msg.sender);
1173     }
1174 
1175     /**
1176      * @dev stakeWithSignature function
1177      * @param _proposalId id of the proposal
1178      * @param _vote  NO(2) or YES(1).
1179      * @param _amount the betting amount
1180      * @param _nonce nonce value ,it is part of the signature to ensure that
1181               a signature can be received only once.
1182      * @param _signatureType signature type
1183               1 - for web3.eth.sign
1184               2 - for eth_signTypedData according to EIP #712.
1185      * @param _signature  - signed data by the staker
1186      * @return bool true - the proposal has been executed
1187      *              false - otherwise.
1188      */
1189     function stakeWithSignature(
1190         bytes32 _proposalId,
1191         uint256 _vote,
1192         uint256 _amount,
1193         uint256 _nonce,
1194         uint256 _signatureType,
1195         bytes calldata _signature
1196         )
1197         external
1198         returns(bool)
1199         {
1200         // Recreate the digest the user signed
1201         bytes32 delegationDigest;
1202         if (_signatureType == 2) {
1203             delegationDigest = keccak256(
1204                 abi.encodePacked(
1205                     DELEGATION_HASH_EIP712, keccak256(
1206                         abi.encodePacked(
1207                         address(this),
1208                         _proposalId,
1209                         _vote,
1210                         _amount,
1211                         _nonce)
1212                     )
1213                 )
1214             );
1215         } else {
1216             delegationDigest = keccak256(
1217                         abi.encodePacked(
1218                         address(this),
1219                         _proposalId,
1220                         _vote,
1221                         _amount,
1222                         _nonce)
1223                     ).toEthSignedMessageHash();
1224         }
1225         address staker = delegationDigest.recover(_signature);
1226         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
1227         require(staker != address(0), "staker address cannot be 0");
1228         require(stakesNonce[staker] == _nonce);
1229         stakesNonce[staker] = stakesNonce[staker].add(1);
1230         return _stake(_proposalId, _vote, _amount, staker);
1231     }
1232 
1233     /**
1234      * @dev voting function
1235      * @param _proposalId id of the proposal
1236      * @param _vote NO(2) or YES(1).
1237      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
1238      * @param _voter voter address
1239      * @return bool true - the proposal has been executed
1240      *              false - otherwise.
1241      */
1242     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
1243     external
1244     votable(_proposalId)
1245     returns(bool) {
1246         Proposal storage proposal = proposals[_proposalId];
1247         Parameters memory params = parameters[proposal.paramsHash];
1248         address voter;
1249         if (params.voteOnBehalf != address(0)) {
1250             require(msg.sender == params.voteOnBehalf);
1251             voter = _voter;
1252         } else {
1253             voter = msg.sender;
1254         }
1255         return internalVote(_proposalId, voter, _vote, _amount);
1256     }
1257 
1258   /**
1259    * @dev Cancel the vote of the msg.sender.
1260    * cancel vote is not allow in genesisProtocol so this function doing nothing.
1261    * This function is here in order to comply to the IntVoteInterface .
1262    */
1263     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
1264        //this is not allowed
1265         return;
1266     }
1267 
1268     /**
1269       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1270       * @param _proposalId the id of the proposal
1271       * @return bool true - the proposal has been executed
1272       *              false - otherwise.
1273      */
1274     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
1275         return _execute(_proposalId);
1276     }
1277 
1278   /**
1279     * @dev getNumberOfChoices returns the number of choices possible in this proposal
1280     * @return uint256 that contains number of choices
1281     */
1282     function getNumberOfChoices(bytes32) external view returns(uint256) {
1283         return NUM_OF_CHOICES;
1284     }
1285 
1286     /**
1287       * @dev getProposalTimes returns proposals times variables.
1288       * @param _proposalId id of the proposal
1289       * @return proposals times array
1290       */
1291     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
1292         return proposals[_proposalId].times;
1293     }
1294 
1295     /**
1296      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
1297      * @param _proposalId the ID of the proposal
1298      * @param _voter the address of the voter
1299      * @return uint256 vote - the voters vote
1300      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
1301      */
1302     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
1303         Voter memory voter = proposals[_proposalId].voters[_voter];
1304         return (voter.vote, voter.reputation);
1305     }
1306 
1307     /**
1308     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
1309     * @param _proposalId the ID of the proposal
1310     * @param _choice the index in the
1311     * @return voted reputation for the given choice
1312     */
1313     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
1314         return proposals[_proposalId].votes[_choice];
1315     }
1316 
1317     /**
1318     * @dev isVotable check if the proposal is votable
1319     * @param _proposalId the ID of the proposal
1320     * @return bool true or false
1321     */
1322     function isVotable(bytes32 _proposalId) external view returns(bool) {
1323         return _isVotable(_proposalId);
1324     }
1325 
1326     /**
1327     * @dev proposalStatus return the total votes and stakes for a given proposal
1328     * @param _proposalId the ID of the proposal
1329     * @return uint256 preBoostedVotes YES
1330     * @return uint256 preBoostedVotes NO
1331     * @return uint256 total stakes YES
1332     * @return uint256 total stakes NO
1333     */
1334     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
1335         return (
1336                 proposals[_proposalId].preBoostedVotes[YES],
1337                 proposals[_proposalId].preBoostedVotes[NO],
1338                 proposals[_proposalId].stakes[YES],
1339                 proposals[_proposalId].stakes[NO]
1340         );
1341     }
1342 
1343   /**
1344     * @dev getProposalOrganization return the organizationId for a given proposal
1345     * @param _proposalId the ID of the proposal
1346     * @return bytes32 organization identifier
1347     */
1348     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
1349         return (proposals[_proposalId].organizationId);
1350     }
1351 
1352     /**
1353       * @dev getStaker return the vote and stake amount for a given proposal and staker
1354       * @param _proposalId the ID of the proposal
1355       * @param _staker staker address
1356       * @return uint256 vote
1357       * @return uint256 amount
1358     */
1359     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
1360         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
1361     }
1362 
1363     /**
1364       * @dev voteStake return the amount stakes for a given proposal and vote
1365       * @param _proposalId the ID of the proposal
1366       * @param _vote vote number
1367       * @return uint256 stake amount
1368     */
1369     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
1370         return proposals[_proposalId].stakes[_vote];
1371     }
1372 
1373   /**
1374     * @dev voteStake return the winningVote for a given proposal
1375     * @param _proposalId the ID of the proposal
1376     * @return uint256 winningVote
1377     */
1378     function winningVote(bytes32 _proposalId) external view returns(uint256) {
1379         return proposals[_proposalId].winningVote;
1380     }
1381 
1382     /**
1383       * @dev voteStake return the state for a given proposal
1384       * @param _proposalId the ID of the proposal
1385       * @return ProposalState proposal state
1386     */
1387     function state(bytes32 _proposalId) external view returns(ProposalState) {
1388         return proposals[_proposalId].state;
1389     }
1390 
1391    /**
1392     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
1393     * @return bool true or false
1394     */
1395     function isAbstainAllow() external pure returns(bool) {
1396         return false;
1397     }
1398 
1399     /**
1400      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
1401      * @return min - minimum number of choices
1402                max - maximum number of choices
1403      */
1404     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
1405         return (YES, NO);
1406     }
1407 
1408     /**
1409      * @dev score return the proposal score
1410      * @param _proposalId the ID of the proposal
1411      * @return uint256 proposal score.
1412      */
1413     function score(bytes32 _proposalId) public view returns(uint256) {
1414         return  _score(_proposalId);
1415     }
1416 }