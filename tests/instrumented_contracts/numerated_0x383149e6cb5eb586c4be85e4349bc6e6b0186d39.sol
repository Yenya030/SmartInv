1 // File: Base64.sol
2 
3 
4 pragma solidity ^0.8.2;
5 
6 /// [MIT License]
7 /// @title Base64
8 /// @notice Provides a function for encoding some bytes in base64
9 /// @author Brecht Devos <brecht@loopring.org>
10 library Base64 {
11   bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
12 
13   /// @notice Encodes some bytes to the base64 representation
14   function encode(bytes memory data) internal pure returns (string memory) {
15     uint256 len = data.length;
16     if (len == 0) return "";
17 
18     // multiply by 4/3 rounded up
19     uint256 encodedLen = 4 * ((len + 2) / 3);
20 
21     // Add some extra buffer at the end
22     bytes memory result = new bytes(encodedLen + 32);
23 
24     bytes memory table = TABLE;
25 
26     assembly {
27       let tablePtr := add(table, 1)
28       let resultPtr := add(result, 32)
29 
30       for {
31         let i := 0
32       } lt(i, len) {
33 
34       } {
35         i := add(i, 3)
36         let input := and(mload(add(data, i)), 0xffffff)
37 
38         let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
39         out := shl(8, out)
40         out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
41         out := shl(8, out)
42         out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
43         out := shl(8, out)
44         out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
45         out := shl(224, out)
46 
47         mstore(resultPtr, out)
48 
49         resultPtr := add(resultPtr, 4)
50       }
51 
52       switch mod(len, 3)
53       case 1 {
54         mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
55       }
56       case 2 {
57         mstore(sub(resultPtr, 1), shl(248, 0x3d))
58       }
59 
60       mstore(result, encodedLen)
61     }
62 
63     return string(result);
64   }
65 }
66 
67 // File: SVG721.sol
68 
69 
70 // attributes added by fatlion
71 pragma solidity ^0.8.0;
72 
73 
74 library SVG721 {
75   function metadata(
76     string memory tokenName,
77     string memory tokenDescription,
78     string memory svgString,
79     string memory attributes
80   ) internal pure returns (string memory) {
81     string memory json = string(abi.encodePacked('{"name":"', tokenName, '","description":"', tokenDescription, '","image": "data:image/svg+xml;base64,', Base64.encode(bytes(svgString)),'",',attributes,'}'));
82     return string(abi.encodePacked("data:application/json;base64,", Base64.encode(bytes(json))));
83   }
84 }
85 
86 // File: @chainlink/contracts/src/v0.8/VRFRequestIDBase.sol
87 
88 
89 pragma solidity ^0.8.0;
90 
91 contract VRFRequestIDBase {
92 
93   /**
94    * @notice returns the seed which is actually input to the VRF coordinator
95    *
96    * @dev To prevent repetition of VRF output due to repetition of the
97    * @dev user-supplied seed, that seed is combined in a hash with the
98    * @dev user-specific nonce, and the address of the consuming contract. The
99    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
100    * @dev the final seed, but the nonce does protect against repetition in
101    * @dev requests which are included in a single block.
102    *
103    * @param _userSeed VRF seed input provided by user
104    * @param _requester Address of the requesting contract
105    * @param _nonce User-specific nonce at the time of the request
106    */
107   function makeVRFInputSeed(
108     bytes32 _keyHash,
109     uint256 _userSeed,
110     address _requester,
111     uint256 _nonce
112   )
113     internal
114     pure
115     returns (
116       uint256
117     )
118   {
119     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
120   }
121 
122   /**
123    * @notice Returns the id for this request
124    * @param _keyHash The serviceAgreement ID to be used for this request
125    * @param _vRFInputSeed The seed to be passed directly to the VRF
126    * @return The id for this request
127    *
128    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
129    * @dev contract, but the one generated by makeVRFInputSeed
130    */
131   function makeRequestId(
132     bytes32 _keyHash,
133     uint256 _vRFInputSeed
134   )
135     internal
136     pure
137     returns (
138       bytes32
139     )
140   {
141     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
142   }
143 }
144 // File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
145 
146 
147 pragma solidity ^0.8.0;
148 
149 interface LinkTokenInterface {
150 
151   function allowance(
152     address owner,
153     address spender
154   )
155     external
156     view
157     returns (
158       uint256 remaining
159     );
160 
161   function approve(
162     address spender,
163     uint256 value
164   )
165     external
166     returns (
167       bool success
168     );
169 
170   function balanceOf(
171     address owner
172   )
173     external
174     view
175     returns (
176       uint256 balance
177     );
178 
179   function decimals()
180     external
181     view
182     returns (
183       uint8 decimalPlaces
184     );
185 
186   function decreaseApproval(
187     address spender,
188     uint256 addedValue
189   )
190     external
191     returns (
192       bool success
193     );
194 
195   function increaseApproval(
196     address spender,
197     uint256 subtractedValue
198   ) external;
199 
200   function name()
201     external
202     view
203     returns (
204       string memory tokenName
205     );
206 
207   function symbol()
208     external
209     view
210     returns (
211       string memory tokenSymbol
212     );
213 
214   function totalSupply()
215     external
216     view
217     returns (
218       uint256 totalTokensIssued
219     );
220 
221   function transfer(
222     address to,
223     uint256 value
224   )
225     external
226     returns (
227       bool success
228     );
229 
230   function transferAndCall(
231     address to,
232     uint256 value,
233     bytes calldata data
234   )
235     external
236     returns (
237       bool success
238     );
239 
240   function transferFrom(
241     address from,
242     address to,
243     uint256 value
244   )
245     external
246     returns (
247       bool success
248     );
249 
250 }
251 
252 // File: @chainlink/contracts/src/v0.8/VRFConsumerBase.sol
253 
254 
255 pragma solidity ^0.8.0;
256 
257 
258 
259 /** ****************************************************************************
260  * @notice Interface for contracts using VRF randomness
261  * *****************************************************************************
262  * @dev PURPOSE
263  *
264  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
265  * @dev to Vera the verifier in such a way that Vera can be sure he's not
266  * @dev making his output up to suit himself. Reggie provides Vera a public key
267  * @dev to which he knows the secret key. Each time Vera provides a seed to
268  * @dev Reggie, he gives back a value which is computed completely
269  * @dev deterministically from the seed and the secret key.
270  *
271  * @dev Reggie provides a proof by which Vera can verify that the output was
272  * @dev correctly computed once Reggie tells it to her, but without that proof,
273  * @dev the output is indistinguishable to her from a uniform random sample
274  * @dev from the output space.
275  *
276  * @dev The purpose of this contract is to make it easy for unrelated contracts
277  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
278  * @dev simple access to a verifiable source of randomness.
279  * *****************************************************************************
280  * @dev USAGE
281  *
282  * @dev Calling contracts must inherit from VRFConsumerBase, and can
283  * @dev initialize VRFConsumerBase's attributes in their constructor as
284  * @dev shown:
285  *
286  * @dev   contract VRFConsumer {
287  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
288  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
289  * @dev         <initialization with other arguments goes here>
290  * @dev       }
291  * @dev   }
292  *
293  * @dev The oracle will have given you an ID for the VRF keypair they have
294  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
295  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
296  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
297  * @dev want to generate randomness from.
298  *
299  * @dev Once the VRFCoordinator has received and validated the oracle's response
300  * @dev to your request, it will call your contract's fulfillRandomness method.
301  *
302  * @dev The randomness argument to fulfillRandomness is the actual random value
303  * @dev generated from your seed.
304  *
305  * @dev The requestId argument is generated from the keyHash and the seed by
306  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
307  * @dev requests open, you can use the requestId to track which seed is
308  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
309  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
310  * @dev if your contract could have multiple requests in flight simultaneously.)
311  *
312  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
313  * @dev differ. (Which is critical to making unpredictable randomness! See the
314  * @dev next section.)
315  *
316  * *****************************************************************************
317  * @dev SECURITY CONSIDERATIONS
318  *
319  * @dev A method with the ability to call your fulfillRandomness method directly
320  * @dev could spoof a VRF response with any random value, so it's critical that
321  * @dev it cannot be directly called by anything other than this base contract
322  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
323  *
324  * @dev For your users to trust that your contract's random behavior is free
325  * @dev from malicious interference, it's best if you can write it so that all
326  * @dev behaviors implied by a VRF response are executed *during* your
327  * @dev fulfillRandomness method. If your contract must store the response (or
328  * @dev anything derived from it) and use it later, you must ensure that any
329  * @dev user-significant behavior which depends on that stored value cannot be
330  * @dev manipulated by a subsequent VRF request.
331  *
332  * @dev Similarly, both miners and the VRF oracle itself have some influence
333  * @dev over the order in which VRF responses appear on the blockchain, so if
334  * @dev your contract could have multiple VRF requests in flight simultaneously,
335  * @dev you must ensure that the order in which the VRF responses arrive cannot
336  * @dev be used to manipulate your contract's user-significant behavior.
337  *
338  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
339  * @dev block in which the request is made, user-provided seeds have no impact
340  * @dev on its economic security properties. They are only included for API
341  * @dev compatability with previous versions of this contract.
342  *
343  * @dev Since the block hash of the block which contains the requestRandomness
344  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
345  * @dev miner could, in principle, fork the blockchain to evict the block
346  * @dev containing the request, forcing the request to be included in a
347  * @dev different block with a different hash, and therefore a different input
348  * @dev to the VRF. However, such an attack would incur a substantial economic
349  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
350  * @dev until it calls responds to a request.
351  */
352 abstract contract VRFConsumerBase is VRFRequestIDBase {
353 
354   /**
355    * @notice fulfillRandomness handles the VRF response. Your contract must
356    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
357    * @notice principles to keep in mind when implementing your fulfillRandomness
358    * @notice method.
359    *
360    * @dev VRFConsumerBase expects its subcontracts to have a method with this
361    * @dev signature, and will call it once it has verified the proof
362    * @dev associated with the randomness. (It is triggered via a call to
363    * @dev rawFulfillRandomness, below.)
364    *
365    * @param requestId The Id initially returned by requestRandomness
366    * @param randomness the VRF output
367    */
368   function fulfillRandomness(
369     bytes32 requestId,
370     uint256 randomness
371   )
372     internal
373     virtual;
374 
375   /**
376    * @dev In order to keep backwards compatibility we have kept the user
377    * seed field around. We remove the use of it because given that the blockhash
378    * enters later, it overrides whatever randomness the used seed provides.
379    * Given that it adds no security, and can easily lead to misunderstandings,
380    * we have removed it from usage and can now provide a simpler API.
381    */
382   uint256 constant private USER_SEED_PLACEHOLDER = 0;
383 
384   /**
385    * @notice requestRandomness initiates a request for VRF output given _seed
386    *
387    * @dev The fulfillRandomness method receives the output, once it's provided
388    * @dev by the Oracle, and verified by the vrfCoordinator.
389    *
390    * @dev The _keyHash must already be registered with the VRFCoordinator, and
391    * @dev the _fee must exceed the fee specified during registration of the
392    * @dev _keyHash.
393    *
394    * @dev The _seed parameter is vestigial, and is kept only for API
395    * @dev compatibility with older versions. It can't *hurt* to mix in some of
396    * @dev your own randomness, here, but it's not necessary because the VRF
397    * @dev oracle will mix the hash of the block containing your request into the
398    * @dev VRF seed it ultimately uses.
399    *
400    * @param _keyHash ID of public key against which randomness is generated
401    * @param _fee The amount of LINK to send with the request
402    *
403    * @return requestId unique ID for this request
404    *
405    * @dev The returned requestId can be used to distinguish responses to
406    * @dev concurrent requests. It is passed as the first argument to
407    * @dev fulfillRandomness.
408    */
409   function requestRandomness(
410     bytes32 _keyHash,
411     uint256 _fee
412   )
413     internal
414     returns (
415       bytes32 requestId
416     )
417   {
418     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
419     // This is the seed passed to VRFCoordinator. The oracle will mix this with
420     // the hash of the block containing this request to obtain the seed/input
421     // which is finally passed to the VRF cryptographic machinery.
422     uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
423     // nonces[_keyHash] must stay in sync with
424     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
425     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
426     // This provides protection against the user repeating their input seed,
427     // which would result in a predictable/duplicate output, if multiple such
428     // requests appeared in the same block.
429     nonces[_keyHash] = nonces[_keyHash] + 1;
430     return makeRequestId(_keyHash, vRFSeed);
431   }
432 
433   LinkTokenInterface immutable internal LINK;
434   address immutable private vrfCoordinator;
435 
436   // Nonces for each VRF key from which randomness has been requested.
437   //
438   // Must stay in sync with VRFCoordinator[_keyHash][this]
439   mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;
440 
441   /**
442    * @param _vrfCoordinator address of VRFCoordinator contract
443    * @param _link address of LINK token contract
444    *
445    * @dev https://docs.chain.link/docs/link-token-contracts
446    */
447   constructor(
448     address _vrfCoordinator,
449     address _link
450   ) {
451     vrfCoordinator = _vrfCoordinator;
452     LINK = LinkTokenInterface(_link);
453   }
454 
455   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
456   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
457   // the origin of the call
458   function rawFulfillRandomness(
459     bytes32 requestId,
460     uint256 randomness
461   )
462     external
463   {
464     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
465     fulfillRandomness(requestId, randomness);
466   }
467 }
468 
469 // File: @openzeppelin/contracts/utils/math/SafeMath.sol
470 
471 
472 // OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)
473 
474 pragma solidity ^0.8.0;
475 
476 // CAUTION
477 // This version of SafeMath should only be used with Solidity 0.8 or later,
478 // because it relies on the compiler's built in overflow checks.
479 
480 /**
481  * @dev Wrappers over Solidity's arithmetic operations.
482  *
483  * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
484  * now has built in overflow checking.
485  */
486 library SafeMath {
487     /**
488      * @dev Returns the addition of two unsigned integers, with an overflow flag.
489      *
490      * _Available since v3.4._
491      */
492     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
493         unchecked {
494             uint256 c = a + b;
495             if (c < a) return (false, 0);
496             return (true, c);
497         }
498     }
499 
500     /**
501      * @dev Returns the substraction of two unsigned integers, with an overflow flag.
502      *
503      * _Available since v3.4._
504      */
505     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
506         unchecked {
507             if (b > a) return (false, 0);
508             return (true, a - b);
509         }
510     }
511 
512     /**
513      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
514      *
515      * _Available since v3.4._
516      */
517     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
518         unchecked {
519             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
520             // benefit is lost if 'b' is also tested.
521             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
522             if (a == 0) return (true, 0);
523             uint256 c = a * b;
524             if (c / a != b) return (false, 0);
525             return (true, c);
526         }
527     }
528 
529     /**
530      * @dev Returns the division of two unsigned integers, with a division by zero flag.
531      *
532      * _Available since v3.4._
533      */
534     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
535         unchecked {
536             if (b == 0) return (false, 0);
537             return (true, a / b);
538         }
539     }
540 
541     /**
542      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
543      *
544      * _Available since v3.4._
545      */
546     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
547         unchecked {
548             if (b == 0) return (false, 0);
549             return (true, a % b);
550         }
551     }
552 
553     /**
554      * @dev Returns the addition of two unsigned integers, reverting on
555      * overflow.
556      *
557      * Counterpart to Solidity's `+` operator.
558      *
559      * Requirements:
560      *
561      * - Addition cannot overflow.
562      */
563     function add(uint256 a, uint256 b) internal pure returns (uint256) {
564         return a + b;
565     }
566 
567     /**
568      * @dev Returns the subtraction of two unsigned integers, reverting on
569      * overflow (when the result is negative).
570      *
571      * Counterpart to Solidity's `-` operator.
572      *
573      * Requirements:
574      *
575      * - Subtraction cannot overflow.
576      */
577     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
578         return a - b;
579     }
580 
581     /**
582      * @dev Returns the multiplication of two unsigned integers, reverting on
583      * overflow.
584      *
585      * Counterpart to Solidity's `*` operator.
586      *
587      * Requirements:
588      *
589      * - Multiplication cannot overflow.
590      */
591     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
592         return a * b;
593     }
594 
595     /**
596      * @dev Returns the integer division of two unsigned integers, reverting on
597      * division by zero. The result is rounded towards zero.
598      *
599      * Counterpart to Solidity's `/` operator.
600      *
601      * Requirements:
602      *
603      * - The divisor cannot be zero.
604      */
605     function div(uint256 a, uint256 b) internal pure returns (uint256) {
606         return a / b;
607     }
608 
609     /**
610      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
611      * reverting when dividing by zero.
612      *
613      * Counterpart to Solidity's `%` operator. This function uses a `revert`
614      * opcode (which leaves remaining gas untouched) while Solidity uses an
615      * invalid opcode to revert (consuming all remaining gas).
616      *
617      * Requirements:
618      *
619      * - The divisor cannot be zero.
620      */
621     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
622         return a % b;
623     }
624 
625     /**
626      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
627      * overflow (when the result is negative).
628      *
629      * CAUTION: This function is deprecated because it requires allocating memory for the error
630      * message unnecessarily. For custom revert reasons use {trySub}.
631      *
632      * Counterpart to Solidity's `-` operator.
633      *
634      * Requirements:
635      *
636      * - Subtraction cannot overflow.
637      */
638     function sub(
639         uint256 a,
640         uint256 b,
641         string memory errorMessage
642     ) internal pure returns (uint256) {
643         unchecked {
644             require(b <= a, errorMessage);
645             return a - b;
646         }
647     }
648 
649     /**
650      * @dev Returns the integer division of two unsigned integers, reverting with custom message on
651      * division by zero. The result is rounded towards zero.
652      *
653      * Counterpart to Solidity's `/` operator. Note: this function uses a
654      * `revert` opcode (which leaves remaining gas untouched) while Solidity
655      * uses an invalid opcode to revert (consuming all remaining gas).
656      *
657      * Requirements:
658      *
659      * - The divisor cannot be zero.
660      */
661     function div(
662         uint256 a,
663         uint256 b,
664         string memory errorMessage
665     ) internal pure returns (uint256) {
666         unchecked {
667             require(b > 0, errorMessage);
668             return a / b;
669         }
670     }
671 
672     /**
673      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
674      * reverting with custom message when dividing by zero.
675      *
676      * CAUTION: This function is deprecated because it requires allocating memory for the error
677      * message unnecessarily. For custom revert reasons use {tryMod}.
678      *
679      * Counterpart to Solidity's `%` operator. This function uses a `revert`
680      * opcode (which leaves remaining gas untouched) while Solidity uses an
681      * invalid opcode to revert (consuming all remaining gas).
682      *
683      * Requirements:
684      *
685      * - The divisor cannot be zero.
686      */
687     function mod(
688         uint256 a,
689         uint256 b,
690         string memory errorMessage
691     ) internal pure returns (uint256) {
692         unchecked {
693             require(b > 0, errorMessage);
694             return a % b;
695         }
696     }
697 }
698 
699 // File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol
700 
701 
702 // OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)
703 
704 pragma solidity ^0.8.0;
705 
706 /**
707  * @dev These functions deal with verification of Merkle Trees proofs.
708  *
709  * The proofs can be generated using the JavaScript library
710  * https://github.com/miguelmota/merkletreejs[merkletreejs].
711  * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
712  *
713  * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
714  */
715 library MerkleProof {
716     /**
717      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
718      * defined by `root`. For this, a `proof` must be provided, containing
719      * sibling hashes on the branch from the leaf to the root of the tree. Each
720      * pair of leaves and each pair of pre-images are assumed to be sorted.
721      */
722     function verify(
723         bytes32[] memory proof,
724         bytes32 root,
725         bytes32 leaf
726     ) internal pure returns (bool) {
727         return processProof(proof, leaf) == root;
728     }
729 
730     /**
731      * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up
732      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
733      * hash matches the root of the tree. When processing the proof, the pairs
734      * of leafs & pre-images are assumed to be sorted.
735      *
736      * _Available since v4.4._
737      */
738     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
739         bytes32 computedHash = leaf;
740         for (uint256 i = 0; i < proof.length; i++) {
741             bytes32 proofElement = proof[i];
742             if (computedHash <= proofElement) {
743                 // Hash(current computed hash + current element of the proof)
744                 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
745             } else {
746                 // Hash(current element of the proof + current computed hash)
747                 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
748             }
749         }
750         return computedHash;
751     }
752 }
753 
754 // File: @openzeppelin/contracts/utils/Counters.sol
755 
756 
757 // OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)
758 
759 pragma solidity ^0.8.0;
760 
761 /**
762  * @title Counters
763  * @author Matt Condon (@shrugs)
764  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
765  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
766  *
767  * Include with `using Counters for Counters.Counter;`
768  */
769 library Counters {
770     struct Counter {
771         // This variable should never be directly accessed by users of the library: interactions must be restricted to
772         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
773         // this feature: see https://github.com/ethereum/solidity/issues/4637
774         uint256 _value; // default: 0
775     }
776 
777     function current(Counter storage counter) internal view returns (uint256) {
778         return counter._value;
779     }
780 
781     function increment(Counter storage counter) internal {
782         unchecked {
783             counter._value += 1;
784         }
785     }
786 
787     function decrement(Counter storage counter) internal {
788         uint256 value = counter._value;
789         require(value > 0, "Counter: decrement overflow");
790         unchecked {
791             counter._value = value - 1;
792         }
793     }
794 
795     function reset(Counter storage counter) internal {
796         counter._value = 0;
797     }
798 }
799 
800 // File: @openzeppelin/contracts/utils/Strings.sol
801 
802 
803 // OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)
804 
805 pragma solidity ^0.8.0;
806 
807 /**
808  * @dev String operations.
809  */
810 library Strings {
811     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
812 
813     /**
814      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
815      */
816     function toString(uint256 value) internal pure returns (string memory) {
817         // Inspired by OraclizeAPI's implementation - MIT licence
818         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
819 
820         if (value == 0) {
821             return "0";
822         }
823         uint256 temp = value;
824         uint256 digits;
825         while (temp != 0) {
826             digits++;
827             temp /= 10;
828         }
829         bytes memory buffer = new bytes(digits);
830         while (value != 0) {
831             digits -= 1;
832             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
833             value /= 10;
834         }
835         return string(buffer);
836     }
837 
838     /**
839      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
840      */
841     function toHexString(uint256 value) internal pure returns (string memory) {
842         if (value == 0) {
843             return "0x00";
844         }
845         uint256 temp = value;
846         uint256 length = 0;
847         while (temp != 0) {
848             length++;
849             temp >>= 8;
850         }
851         return toHexString(value, length);
852     }
853 
854     /**
855      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
856      */
857     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
858         bytes memory buffer = new bytes(2 * length + 2);
859         buffer[0] = "0";
860         buffer[1] = "x";
861         for (uint256 i = 2 * length + 1; i > 1; --i) {
862             buffer[i] = _HEX_SYMBOLS[value & 0xf];
863             value >>= 4;
864         }
865         require(value == 0, "Strings: hex length insufficient");
866         return string(buffer);
867     }
868 }
869 
870 // File: @openzeppelin/contracts/utils/Context.sol
871 
872 
873 // OpenZeppelin Contracts v4.4.0 (utils/Context.sol)
874 
875 pragma solidity ^0.8.0;
876 
877 /**
878  * @dev Provides information about the current execution context, including the
879  * sender of the transaction and its data. While these are generally available
880  * via msg.sender and msg.data, they should not be accessed in such a direct
881  * manner, since when dealing with meta-transactions the account sending and
882  * paying for execution may not be the actual sender (as far as an application
883  * is concerned).
884  *
885  * This contract is only required for intermediate, library-like contracts.
886  */
887 abstract contract Context {
888     function _msgSender() internal view virtual returns (address) {
889         return msg.sender;
890     }
891 
892     function _msgData() internal view virtual returns (bytes calldata) {
893         return msg.data;
894     }
895 }
896 
897 // File: @openzeppelin/contracts/security/Pausable.sol
898 
899 
900 // OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)
901 
902 pragma solidity ^0.8.0;
903 
904 
905 /**
906  * @dev Contract module which allows children to implement an emergency stop
907  * mechanism that can be triggered by an authorized account.
908  *
909  * This module is used through inheritance. It will make available the
910  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
911  * the functions of your contract. Note that they will not be pausable by
912  * simply including this module, only once the modifiers are put in place.
913  */
914 abstract contract Pausable is Context {
915     /**
916      * @dev Emitted when the pause is triggered by `account`.
917      */
918     event Paused(address account);
919 
920     /**
921      * @dev Emitted when the pause is lifted by `account`.
922      */
923     event Unpaused(address account);
924 
925     bool private _paused;
926 
927     /**
928      * @dev Initializes the contract in unpaused state.
929      */
930     constructor() {
931         _paused = false;
932     }
933 
934     /**
935      * @dev Returns true if the contract is paused, and false otherwise.
936      */
937     function paused() public view virtual returns (bool) {
938         return _paused;
939     }
940 
941     /**
942      * @dev Modifier to make a function callable only when the contract is not paused.
943      *
944      * Requirements:
945      *
946      * - The contract must not be paused.
947      */
948     modifier whenNotPaused() {
949         require(!paused(), "Pausable: paused");
950         _;
951     }
952 
953     /**
954      * @dev Modifier to make a function callable only when the contract is paused.
955      *
956      * Requirements:
957      *
958      * - The contract must be paused.
959      */
960     modifier whenPaused() {
961         require(paused(), "Pausable: not paused");
962         _;
963     }
964 
965     /**
966      * @dev Triggers stopped state.
967      *
968      * Requirements:
969      *
970      * - The contract must not be paused.
971      */
972     function _pause() internal virtual whenNotPaused {
973         _paused = true;
974         emit Paused(_msgSender());
975     }
976 
977     /**
978      * @dev Returns to normal state.
979      *
980      * Requirements:
981      *
982      * - The contract must be paused.
983      */
984     function _unpause() internal virtual whenPaused {
985         _paused = false;
986         emit Unpaused(_msgSender());
987     }
988 }
989 
990 // File: @openzeppelin/contracts/access/Ownable.sol
991 
992 
993 // OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)
994 
995 pragma solidity ^0.8.0;
996 
997 
998 /**
999  * @dev Contract module which provides a basic access control mechanism, where
1000  * there is an account (an owner) that can be granted exclusive access to
1001  * specific functions.
1002  *
1003  * By default, the owner account will be the one that deploys the contract. This
1004  * can later be changed with {transferOwnership}.
1005  *
1006  * This module is used through inheritance. It will make available the modifier
1007  * `onlyOwner`, which can be applied to your functions to restrict their use to
1008  * the owner.
1009  */
1010 abstract contract Ownable is Context {
1011     address private _owner;
1012 
1013     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
1014 
1015     /**
1016      * @dev Initializes the contract setting the deployer as the initial owner.
1017      */
1018     constructor() {
1019         _transferOwnership(_msgSender());
1020     }
1021 
1022     /**
1023      * @dev Returns the address of the current owner.
1024      */
1025     function owner() public view virtual returns (address) {
1026         return _owner;
1027     }
1028 
1029     /**
1030      * @dev Throws if called by any account other than the owner.
1031      */
1032     modifier onlyOwner() {
1033         require(owner() == _msgSender(), "Ownable: caller is not the owner");
1034         _;
1035     }
1036 
1037     /**
1038      * @dev Leaves the contract without owner. It will not be possible to call
1039      * `onlyOwner` functions anymore. Can only be called by the current owner.
1040      *
1041      * NOTE: Renouncing ownership will leave the contract without an owner,
1042      * thereby removing any functionality that is only available to the owner.
1043      */
1044     function renounceOwnership() public virtual onlyOwner {
1045         _transferOwnership(address(0));
1046     }
1047 
1048     /**
1049      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1050      * Can only be called by the current owner.
1051      */
1052     function transferOwnership(address newOwner) public virtual onlyOwner {
1053         require(newOwner != address(0), "Ownable: new owner is the zero address");
1054         _transferOwnership(newOwner);
1055     }
1056 
1057     /**
1058      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1059      * Internal function without access restriction.
1060      */
1061     function _transferOwnership(address newOwner) internal virtual {
1062         address oldOwner = _owner;
1063         _owner = newOwner;
1064         emit OwnershipTransferred(oldOwner, newOwner);
1065     }
1066 }
1067 
1068 // File: @openzeppelin/contracts/utils/Address.sol
1069 
1070 
1071 // OpenZeppelin Contracts v4.4.0 (utils/Address.sol)
1072 
1073 pragma solidity ^0.8.0;
1074 
1075 /**
1076  * @dev Collection of functions related to the address type
1077  */
1078 library Address {
1079     /**
1080      * @dev Returns true if `account` is a contract.
1081      *
1082      * [IMPORTANT]
1083      * ====
1084      * It is unsafe to assume that an address for which this function returns
1085      * false is an externally-owned account (EOA) and not a contract.
1086      *
1087      * Among others, `isContract` will return false for the following
1088      * types of addresses:
1089      *
1090      *  - an externally-owned account
1091      *  - a contract in construction
1092      *  - an address where a contract will be created
1093      *  - an address where a contract lived, but was destroyed
1094      * ====
1095      */
1096     function isContract(address account) internal view returns (bool) {
1097         // This method relies on extcodesize, which returns 0 for contracts in
1098         // construction, since the code is only stored at the end of the
1099         // constructor execution.
1100 
1101         uint256 size;
1102         assembly {
1103             size := extcodesize(account)
1104         }
1105         return size > 0;
1106     }
1107 
1108     /**
1109      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
1110      * `recipient`, forwarding all available gas and reverting on errors.
1111      *
1112      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
1113      * of certain opcodes, possibly making contracts go over the 2300 gas limit
1114      * imposed by `transfer`, making them unable to receive funds via
1115      * `transfer`. {sendValue} removes this limitation.
1116      *
1117      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
1118      *
1119      * IMPORTANT: because control is transferred to `recipient`, care must be
1120      * taken to not create reentrancy vulnerabilities. Consider using
1121      * {ReentrancyGuard} or the
1122      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
1123      */
1124     function sendValue(address payable recipient, uint256 amount) internal {
1125         require(address(this).balance >= amount, "Address: insufficient balance");
1126 
1127         (bool success, ) = recipient.call{value: amount}("");
1128         require(success, "Address: unable to send value, recipient may have reverted");
1129     }
1130 
1131     /**
1132      * @dev Performs a Solidity function call using a low level `call`. A
1133      * plain `call` is an unsafe replacement for a function call: use this
1134      * function instead.
1135      *
1136      * If `target` reverts with a revert reason, it is bubbled up by this
1137      * function (like regular Solidity function calls).
1138      *
1139      * Returns the raw returned data. To convert to the expected return value,
1140      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
1141      *
1142      * Requirements:
1143      *
1144      * - `target` must be a contract.
1145      * - calling `target` with `data` must not revert.
1146      *
1147      * _Available since v3.1._
1148      */
1149     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
1150         return functionCall(target, data, "Address: low-level call failed");
1151     }
1152 
1153     /**
1154      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
1155      * `errorMessage` as a fallback revert reason when `target` reverts.
1156      *
1157      * _Available since v3.1._
1158      */
1159     function functionCall(
1160         address target,
1161         bytes memory data,
1162         string memory errorMessage
1163     ) internal returns (bytes memory) {
1164         return functionCallWithValue(target, data, 0, errorMessage);
1165     }
1166 
1167     /**
1168      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1169      * but also transferring `value` wei to `target`.
1170      *
1171      * Requirements:
1172      *
1173      * - the calling contract must have an ETH balance of at least `value`.
1174      * - the called Solidity function must be `payable`.
1175      *
1176      * _Available since v3.1._
1177      */
1178     function functionCallWithValue(
1179         address target,
1180         bytes memory data,
1181         uint256 value
1182     ) internal returns (bytes memory) {
1183         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
1184     }
1185 
1186     /**
1187      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
1188      * with `errorMessage` as a fallback revert reason when `target` reverts.
1189      *
1190      * _Available since v3.1._
1191      */
1192     function functionCallWithValue(
1193         address target,
1194         bytes memory data,
1195         uint256 value,
1196         string memory errorMessage
1197     ) internal returns (bytes memory) {
1198         require(address(this).balance >= value, "Address: insufficient balance for call");
1199         require(isContract(target), "Address: call to non-contract");
1200 
1201         (bool success, bytes memory returndata) = target.call{value: value}(data);
1202         return verifyCallResult(success, returndata, errorMessage);
1203     }
1204 
1205     /**
1206      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1207      * but performing a static call.
1208      *
1209      * _Available since v3.3._
1210      */
1211     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
1212         return functionStaticCall(target, data, "Address: low-level static call failed");
1213     }
1214 
1215     /**
1216      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1217      * but performing a static call.
1218      *
1219      * _Available since v3.3._
1220      */
1221     function functionStaticCall(
1222         address target,
1223         bytes memory data,
1224         string memory errorMessage
1225     ) internal view returns (bytes memory) {
1226         require(isContract(target), "Address: static call to non-contract");
1227 
1228         (bool success, bytes memory returndata) = target.staticcall(data);
1229         return verifyCallResult(success, returndata, errorMessage);
1230     }
1231 
1232     /**
1233      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
1234      * but performing a delegate call.
1235      *
1236      * _Available since v3.4._
1237      */
1238     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
1239         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
1240     }
1241 
1242     /**
1243      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
1244      * but performing a delegate call.
1245      *
1246      * _Available since v3.4._
1247      */
1248     function functionDelegateCall(
1249         address target,
1250         bytes memory data,
1251         string memory errorMessage
1252     ) internal returns (bytes memory) {
1253         require(isContract(target), "Address: delegate call to non-contract");
1254 
1255         (bool success, bytes memory returndata) = target.delegatecall(data);
1256         return verifyCallResult(success, returndata, errorMessage);
1257     }
1258 
1259     /**
1260      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
1261      * revert reason using the provided one.
1262      *
1263      * _Available since v4.3._
1264      */
1265     function verifyCallResult(
1266         bool success,
1267         bytes memory returndata,
1268         string memory errorMessage
1269     ) internal pure returns (bytes memory) {
1270         if (success) {
1271             return returndata;
1272         } else {
1273             // Look for revert reason and bubble it up if present
1274             if (returndata.length > 0) {
1275                 // The easiest way to bubble the revert reason is using memory via assembly
1276 
1277                 assembly {
1278                     let returndata_size := mload(returndata)
1279                     revert(add(32, returndata), returndata_size)
1280                 }
1281             } else {
1282                 revert(errorMessage);
1283             }
1284         }
1285     }
1286 }
1287 
1288 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
1289 
1290 
1291 // OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)
1292 
1293 pragma solidity ^0.8.0;
1294 
1295 /**
1296  * @title ERC721 token receiver interface
1297  * @dev Interface for any contract that wants to support safeTransfers
1298  * from ERC721 asset contracts.
1299  */
1300 interface IERC721Receiver {
1301     /**
1302      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
1303      * by `operator` from `from`, this function is called.
1304      *
1305      * It must return its Solidity selector to confirm the token transfer.
1306      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
1307      *
1308      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
1309      */
1310     function onERC721Received(
1311         address operator,
1312         address from,
1313         uint256 tokenId,
1314         bytes calldata data
1315     ) external returns (bytes4);
1316 }
1317 
1318 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
1319 
1320 
1321 // OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)
1322 
1323 pragma solidity ^0.8.0;
1324 
1325 /**
1326  * @dev Interface of the ERC165 standard, as defined in the
1327  * https://eips.ethereum.org/EIPS/eip-165[EIP].
1328  *
1329  * Implementers can declare support of contract interfaces, which can then be
1330  * queried by others ({ERC165Checker}).
1331  *
1332  * For an implementation, see {ERC165}.
1333  */
1334 interface IERC165 {
1335     /**
1336      * @dev Returns true if this contract implements the interface defined by
1337      * `interfaceId`. See the corresponding
1338      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
1339      * to learn more about how these ids are created.
1340      *
1341      * This function call must use less than 30 000 gas.
1342      */
1343     function supportsInterface(bytes4 interfaceId) external view returns (bool);
1344 }
1345 
1346 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
1347 
1348 
1349 // OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)
1350 
1351 pragma solidity ^0.8.0;
1352 
1353 
1354 /**
1355  * @dev Implementation of the {IERC165} interface.
1356  *
1357  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
1358  * for the additional interface id that will be supported. For example:
1359  *
1360  * ```solidity
1361  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
1362  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
1363  * }
1364  * ```
1365  *
1366  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
1367  */
1368 abstract contract ERC165 is IERC165 {
1369     /**
1370      * @dev See {IERC165-supportsInterface}.
1371      */
1372     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
1373         return interfaceId == type(IERC165).interfaceId;
1374     }
1375 }
1376 
1377 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
1378 
1379 
1380 // OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)
1381 
1382 pragma solidity ^0.8.0;
1383 
1384 
1385 /**
1386  * @dev Required interface of an ERC721 compliant contract.
1387  */
1388 interface IERC721 is IERC165 {
1389     /**
1390      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
1391      */
1392     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
1393 
1394     /**
1395      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
1396      */
1397     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
1398 
1399     /**
1400      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
1401      */
1402     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
1403 
1404     /**
1405      * @dev Returns the number of tokens in ``owner``'s account.
1406      */
1407     function balanceOf(address owner) external view returns (uint256 balance);
1408 
1409     /**
1410      * @dev Returns the owner of the `tokenId` token.
1411      *
1412      * Requirements:
1413      *
1414      * - `tokenId` must exist.
1415      */
1416     function ownerOf(uint256 tokenId) external view returns (address owner);
1417 
1418     /**
1419      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1420      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1421      *
1422      * Requirements:
1423      *
1424      * - `from` cannot be the zero address.
1425      * - `to` cannot be the zero address.
1426      * - `tokenId` token must exist and be owned by `from`.
1427      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
1428      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1429      *
1430      * Emits a {Transfer} event.
1431      */
1432     function safeTransferFrom(
1433         address from,
1434         address to,
1435         uint256 tokenId
1436     ) external;
1437 
1438     /**
1439      * @dev Transfers `tokenId` token from `from` to `to`.
1440      *
1441      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
1442      *
1443      * Requirements:
1444      *
1445      * - `from` cannot be the zero address.
1446      * - `to` cannot be the zero address.
1447      * - `tokenId` token must be owned by `from`.
1448      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
1449      *
1450      * Emits a {Transfer} event.
1451      */
1452     function transferFrom(
1453         address from,
1454         address to,
1455         uint256 tokenId
1456     ) external;
1457 
1458     /**
1459      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
1460      * The approval is cleared when the token is transferred.
1461      *
1462      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
1463      *
1464      * Requirements:
1465      *
1466      * - The caller must own the token or be an approved operator.
1467      * - `tokenId` must exist.
1468      *
1469      * Emits an {Approval} event.
1470      */
1471     function approve(address to, uint256 tokenId) external;
1472 
1473     /**
1474      * @dev Returns the account approved for `tokenId` token.
1475      *
1476      * Requirements:
1477      *
1478      * - `tokenId` must exist.
1479      */
1480     function getApproved(uint256 tokenId) external view returns (address operator);
1481 
1482     /**
1483      * @dev Approve or remove `operator` as an operator for the caller.
1484      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
1485      *
1486      * Requirements:
1487      *
1488      * - The `operator` cannot be the caller.
1489      *
1490      * Emits an {ApprovalForAll} event.
1491      */
1492     function setApprovalForAll(address operator, bool _approved) external;
1493 
1494     /**
1495      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
1496      *
1497      * See {setApprovalForAll}
1498      */
1499     function isApprovedForAll(address owner, address operator) external view returns (bool);
1500 
1501     /**
1502      * @dev Safely transfers `tokenId` token from `from` to `to`.
1503      *
1504      * Requirements:
1505      *
1506      * - `from` cannot be the zero address.
1507      * - `to` cannot be the zero address.
1508      * - `tokenId` token must exist and be owned by `from`.
1509      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
1510      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1511      *
1512      * Emits a {Transfer} event.
1513      */
1514     function safeTransferFrom(
1515         address from,
1516         address to,
1517         uint256 tokenId,
1518         bytes calldata data
1519     ) external;
1520 }
1521 
1522 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol
1523 
1524 
1525 // OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)
1526 
1527 pragma solidity ^0.8.0;
1528 
1529 
1530 /**
1531  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1532  * @dev See https://eips.ethereum.org/EIPS/eip-721
1533  */
1534 interface IERC721Enumerable is IERC721 {
1535     /**
1536      * @dev Returns the total amount of tokens stored by the contract.
1537      */
1538     function totalSupply() external view returns (uint256);
1539 
1540     /**
1541      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1542      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1543      */
1544     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1545 
1546     /**
1547      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1548      * Use along with {totalSupply} to enumerate all tokens.
1549      */
1550     function tokenByIndex(uint256 index) external view returns (uint256);
1551 }
1552 
1553 // File: IScrambles.sol
1554 
1555 
1556 pragma solidity ^0.8.4;
1557 
1558 
1559 interface IScrambles is IERC721Enumerable {
1560     function mint(uint8 windowIndex, uint8 amount, bytes32[] calldata merkleProof) external;
1561     function unpause() external;
1562     function pause() external;
1563     function editRedemptionWindow(uint8 _windowID, bytes32 _merkleRoot, bool _open, uint8 _maxPerWallet) external;
1564     function getCoreNumbers(uint256 tokenId) external returns(string memory);
1565 }
1566 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
1567 
1568 
1569 // OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)
1570 
1571 pragma solidity ^0.8.0;
1572 
1573 
1574 /**
1575  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
1576  * @dev See https://eips.ethereum.org/EIPS/eip-721
1577  */
1578 interface IERC721Metadata is IERC721 {
1579     /**
1580      * @dev Returns the token collection name.
1581      */
1582     function name() external view returns (string memory);
1583 
1584     /**
1585      * @dev Returns the token collection symbol.
1586      */
1587     function symbol() external view returns (string memory);
1588 
1589     /**
1590      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
1591      */
1592     function tokenURI(uint256 tokenId) external view returns (string memory);
1593 }
1594 
1595 // File: @openzeppelin/contracts/token/ERC721/ERC721.sol
1596 
1597 
1598 // OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)
1599 
1600 pragma solidity ^0.8.0;
1601 
1602 
1603 
1604 
1605 
1606 
1607 
1608 
1609 /**
1610  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
1611  * the Metadata extension, but not including the Enumerable extension, which is available separately as
1612  * {ERC721Enumerable}.
1613  */
1614 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
1615     using Address for address;
1616     using Strings for uint256;
1617 
1618     // Token name
1619     string private _name;
1620 
1621     // Token symbol
1622     string private _symbol;
1623 
1624     // Mapping from token ID to owner address
1625     mapping(uint256 => address) private _owners;
1626 
1627     // Mapping owner address to token count
1628     mapping(address => uint256) private _balances;
1629 
1630     // Mapping from token ID to approved address
1631     mapping(uint256 => address) private _tokenApprovals;
1632 
1633     // Mapping from owner to operator approvals
1634     mapping(address => mapping(address => bool)) private _operatorApprovals;
1635 
1636     /**
1637      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1638      */
1639     constructor(string memory name_, string memory symbol_) {
1640         _name = name_;
1641         _symbol = symbol_;
1642     }
1643 
1644     /**
1645      * @dev See {IERC165-supportsInterface}.
1646      */
1647     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1648         return
1649             interfaceId == type(IERC721).interfaceId ||
1650             interfaceId == type(IERC721Metadata).interfaceId ||
1651             super.supportsInterface(interfaceId);
1652     }
1653 
1654     /**
1655      * @dev See {IERC721-balanceOf}.
1656      */
1657     function balanceOf(address owner) public view virtual override returns (uint256) {
1658         require(owner != address(0), "ERC721: balance query for the zero address");
1659         return _balances[owner];
1660     }
1661 
1662     /**
1663      * @dev See {IERC721-ownerOf}.
1664      */
1665     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1666         address owner = _owners[tokenId];
1667         require(owner != address(0), "ERC721: owner query for nonexistent token");
1668         return owner;
1669     }
1670 
1671     /**
1672      * @dev See {IERC721Metadata-name}.
1673      */
1674     function name() public view virtual override returns (string memory) {
1675         return _name;
1676     }
1677 
1678     /**
1679      * @dev See {IERC721Metadata-symbol}.
1680      */
1681     function symbol() public view virtual override returns (string memory) {
1682         return _symbol;
1683     }
1684 
1685     /**
1686      * @dev See {IERC721Metadata-tokenURI}.
1687      */
1688     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1689         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1690 
1691         string memory baseURI = _baseURI();
1692         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1693     }
1694 
1695     /**
1696      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1697      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1698      * by default, can be overriden in child contracts.
1699      */
1700     function _baseURI() internal view virtual returns (string memory) {
1701         return "";
1702     }
1703 
1704     /**
1705      * @dev See {IERC721-approve}.
1706      */
1707     function approve(address to, uint256 tokenId) public virtual override {
1708         address owner = ERC721.ownerOf(tokenId);
1709         require(to != owner, "ERC721: approval to current owner");
1710 
1711         require(
1712             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1713             "ERC721: approve caller is not owner nor approved for all"
1714         );
1715 
1716         _approve(to, tokenId);
1717     }
1718 
1719     /**
1720      * @dev See {IERC721-getApproved}.
1721      */
1722     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1723         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1724 
1725         return _tokenApprovals[tokenId];
1726     }
1727 
1728     /**
1729      * @dev See {IERC721-setApprovalForAll}.
1730      */
1731     function setApprovalForAll(address operator, bool approved) public virtual override {
1732         _setApprovalForAll(_msgSender(), operator, approved);
1733     }
1734 
1735     /**
1736      * @dev See {IERC721-isApprovedForAll}.
1737      */
1738     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1739         return _operatorApprovals[owner][operator];
1740     }
1741 
1742     /**
1743      * @dev See {IERC721-transferFrom}.
1744      */
1745     function transferFrom(
1746         address from,
1747         address to,
1748         uint256 tokenId
1749     ) public virtual override {
1750         //solhint-disable-next-line max-line-length
1751         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1752 
1753         _transfer(from, to, tokenId);
1754     }
1755 
1756     /**
1757      * @dev See {IERC721-safeTransferFrom}.
1758      */
1759     function safeTransferFrom(
1760         address from,
1761         address to,
1762         uint256 tokenId
1763     ) public virtual override {
1764         safeTransferFrom(from, to, tokenId, "");
1765     }
1766 
1767     /**
1768      * @dev See {IERC721-safeTransferFrom}.
1769      */
1770     function safeTransferFrom(
1771         address from,
1772         address to,
1773         uint256 tokenId,
1774         bytes memory _data
1775     ) public virtual override {
1776         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1777         _safeTransfer(from, to, tokenId, _data);
1778     }
1779 
1780     /**
1781      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1782      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1783      *
1784      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1785      *
1786      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1787      * implement alternative mechanisms to perform token transfer, such as signature-based.
1788      *
1789      * Requirements:
1790      *
1791      * - `from` cannot be the zero address.
1792      * - `to` cannot be the zero address.
1793      * - `tokenId` token must exist and be owned by `from`.
1794      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1795      *
1796      * Emits a {Transfer} event.
1797      */
1798     function _safeTransfer(
1799         address from,
1800         address to,
1801         uint256 tokenId,
1802         bytes memory _data
1803     ) internal virtual {
1804         _transfer(from, to, tokenId);
1805         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1806     }
1807 
1808     /**
1809      * @dev Returns whether `tokenId` exists.
1810      *
1811      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1812      *
1813      * Tokens start existing when they are minted (`_mint`),
1814      * and stop existing when they are burned (`_burn`).
1815      */
1816     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1817         return _owners[tokenId] != address(0);
1818     }
1819 
1820     /**
1821      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1822      *
1823      * Requirements:
1824      *
1825      * - `tokenId` must exist.
1826      */
1827     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1828         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1829         address owner = ERC721.ownerOf(tokenId);
1830         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1831     }
1832 
1833     /**
1834      * @dev Safely mints `tokenId` and transfers it to `to`.
1835      *
1836      * Requirements:
1837      *
1838      * - `tokenId` must not exist.
1839      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1840      *
1841      * Emits a {Transfer} event.
1842      */
1843     function _safeMint(address to, uint256 tokenId) internal virtual {
1844         _safeMint(to, tokenId, "");
1845     }
1846 
1847     /**
1848      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1849      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1850      */
1851     function _safeMint(
1852         address to,
1853         uint256 tokenId,
1854         bytes memory _data
1855     ) internal virtual {
1856         _mint(to, tokenId);
1857         require(
1858             _checkOnERC721Received(address(0), to, tokenId, _data),
1859             "ERC721: transfer to non ERC721Receiver implementer"
1860         );
1861     }
1862 
1863     /**
1864      * @dev Mints `tokenId` and transfers it to `to`.
1865      *
1866      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1867      *
1868      * Requirements:
1869      *
1870      * - `tokenId` must not exist.
1871      * - `to` cannot be the zero address.
1872      *
1873      * Emits a {Transfer} event.
1874      */
1875     function _mint(address to, uint256 tokenId) internal virtual {
1876         require(to != address(0), "ERC721: mint to the zero address");
1877         require(!_exists(tokenId), "ERC721: token already minted");
1878 
1879         _beforeTokenTransfer(address(0), to, tokenId);
1880 
1881         _balances[to] += 1;
1882         _owners[tokenId] = to;
1883 
1884         emit Transfer(address(0), to, tokenId);
1885     }
1886 
1887     /**
1888      * @dev Destroys `tokenId`.
1889      * The approval is cleared when the token is burned.
1890      *
1891      * Requirements:
1892      *
1893      * - `tokenId` must exist.
1894      *
1895      * Emits a {Transfer} event.
1896      */
1897     function _burn(uint256 tokenId) internal virtual {
1898         address owner = ERC721.ownerOf(tokenId);
1899 
1900         _beforeTokenTransfer(owner, address(0), tokenId);
1901 
1902         // Clear approvals
1903         _approve(address(0), tokenId);
1904 
1905         _balances[owner] -= 1;
1906         delete _owners[tokenId];
1907 
1908         emit Transfer(owner, address(0), tokenId);
1909     }
1910 
1911     /**
1912      * @dev Transfers `tokenId` from `from` to `to`.
1913      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1914      *
1915      * Requirements:
1916      *
1917      * - `to` cannot be the zero address.
1918      * - `tokenId` token must be owned by `from`.
1919      *
1920      * Emits a {Transfer} event.
1921      */
1922     function _transfer(
1923         address from,
1924         address to,
1925         uint256 tokenId
1926     ) internal virtual {
1927         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1928         require(to != address(0), "ERC721: transfer to the zero address");
1929 
1930         _beforeTokenTransfer(from, to, tokenId);
1931 
1932         // Clear approvals from the previous owner
1933         _approve(address(0), tokenId);
1934 
1935         _balances[from] -= 1;
1936         _balances[to] += 1;
1937         _owners[tokenId] = to;
1938 
1939         emit Transfer(from, to, tokenId);
1940     }
1941 
1942     /**
1943      * @dev Approve `to` to operate on `tokenId`
1944      *
1945      * Emits a {Approval} event.
1946      */
1947     function _approve(address to, uint256 tokenId) internal virtual {
1948         _tokenApprovals[tokenId] = to;
1949         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1950     }
1951 
1952     /**
1953      * @dev Approve `operator` to operate on all of `owner` tokens
1954      *
1955      * Emits a {ApprovalForAll} event.
1956      */
1957     function _setApprovalForAll(
1958         address owner,
1959         address operator,
1960         bool approved
1961     ) internal virtual {
1962         require(owner != operator, "ERC721: approve to caller");
1963         _operatorApprovals[owner][operator] = approved;
1964         emit ApprovalForAll(owner, operator, approved);
1965     }
1966 
1967     /**
1968      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1969      * The call is not executed if the target address is not a contract.
1970      *
1971      * @param from address representing the previous owner of the given token ID
1972      * @param to target address that will receive the tokens
1973      * @param tokenId uint256 ID of the token to be transferred
1974      * @param _data bytes optional data to send along with the call
1975      * @return bool whether the call correctly returned the expected magic value
1976      */
1977     function _checkOnERC721Received(
1978         address from,
1979         address to,
1980         uint256 tokenId,
1981         bytes memory _data
1982     ) private returns (bool) {
1983         if (to.isContract()) {
1984             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1985                 return retval == IERC721Receiver.onERC721Received.selector;
1986             } catch (bytes memory reason) {
1987                 if (reason.length == 0) {
1988                     revert("ERC721: transfer to non ERC721Receiver implementer");
1989                 } else {
1990                     assembly {
1991                         revert(add(32, reason), mload(reason))
1992                     }
1993                 }
1994             }
1995         } else {
1996             return true;
1997         }
1998     }
1999 
2000     /**
2001      * @dev Hook that is called before any token transfer. This includes minting
2002      * and burning.
2003      *
2004      * Calling conditions:
2005      *
2006      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
2007      * transferred to `to`.
2008      * - When `from` is zero, `tokenId` will be minted for `to`.
2009      * - When `to` is zero, ``from``'s `tokenId` will be burned.
2010      * - `from` and `to` are never both zero.
2011      *
2012      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
2013      */
2014     function _beforeTokenTransfer(
2015         address from,
2016         address to,
2017         uint256 tokenId
2018     ) internal virtual {}
2019 }
2020 
2021 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol
2022 
2023 
2024 // OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)
2025 
2026 pragma solidity ^0.8.0;
2027 
2028 
2029 
2030 /**
2031  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
2032  * enumerability of all the token ids in the contract as well as all token ids owned by each
2033  * account.
2034  */
2035 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
2036     // Mapping from owner to list of owned token IDs
2037     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
2038 
2039     // Mapping from token ID to index of the owner tokens list
2040     mapping(uint256 => uint256) private _ownedTokensIndex;
2041 
2042     // Array with all token ids, used for enumeration
2043     uint256[] private _allTokens;
2044 
2045     // Mapping from token id to position in the allTokens array
2046     mapping(uint256 => uint256) private _allTokensIndex;
2047 
2048     /**
2049      * @dev See {IERC165-supportsInterface}.
2050      */
2051     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
2052         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
2053     }
2054 
2055     /**
2056      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
2057      */
2058     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
2059         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
2060         return _ownedTokens[owner][index];
2061     }
2062 
2063     /**
2064      * @dev See {IERC721Enumerable-totalSupply}.
2065      */
2066     function totalSupply() public view virtual override returns (uint256) {
2067         return _allTokens.length;
2068     }
2069 
2070     /**
2071      * @dev See {IERC721Enumerable-tokenByIndex}.
2072      */
2073     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
2074         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
2075         return _allTokens[index];
2076     }
2077 
2078     /**
2079      * @dev Hook that is called before any token transfer. This includes minting
2080      * and burning.
2081      *
2082      * Calling conditions:
2083      *
2084      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
2085      * transferred to `to`.
2086      * - When `from` is zero, `tokenId` will be minted for `to`.
2087      * - When `to` is zero, ``from``'s `tokenId` will be burned.
2088      * - `from` cannot be the zero address.
2089      * - `to` cannot be the zero address.
2090      *
2091      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
2092      */
2093     function _beforeTokenTransfer(
2094         address from,
2095         address to,
2096         uint256 tokenId
2097     ) internal virtual override {
2098         super._beforeTokenTransfer(from, to, tokenId);
2099 
2100         if (from == address(0)) {
2101             _addTokenToAllTokensEnumeration(tokenId);
2102         } else if (from != to) {
2103             _removeTokenFromOwnerEnumeration(from, tokenId);
2104         }
2105         if (to == address(0)) {
2106             _removeTokenFromAllTokensEnumeration(tokenId);
2107         } else if (to != from) {
2108             _addTokenToOwnerEnumeration(to, tokenId);
2109         }
2110     }
2111 
2112     /**
2113      * @dev Private function to add a token to this extension's ownership-tracking data structures.
2114      * @param to address representing the new owner of the given token ID
2115      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
2116      */
2117     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
2118         uint256 length = ERC721.balanceOf(to);
2119         _ownedTokens[to][length] = tokenId;
2120         _ownedTokensIndex[tokenId] = length;
2121     }
2122 
2123     /**
2124      * @dev Private function to add a token to this extension's token tracking data structures.
2125      * @param tokenId uint256 ID of the token to be added to the tokens list
2126      */
2127     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
2128         _allTokensIndex[tokenId] = _allTokens.length;
2129         _allTokens.push(tokenId);
2130     }
2131 
2132     /**
2133      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
2134      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
2135      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
2136      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
2137      * @param from address representing the previous owner of the given token ID
2138      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
2139      */
2140     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
2141         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
2142         // then delete the last slot (swap and pop).
2143 
2144         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
2145         uint256 tokenIndex = _ownedTokensIndex[tokenId];
2146 
2147         // When the token to delete is the last token, the swap operation is unnecessary
2148         if (tokenIndex != lastTokenIndex) {
2149             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
2150 
2151             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
2152             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
2153         }
2154 
2155         // This also deletes the contents at the last position of the array
2156         delete _ownedTokensIndex[tokenId];
2157         delete _ownedTokens[from][lastTokenIndex];
2158     }
2159 
2160     /**
2161      * @dev Private function to remove a token from this extension's token tracking data structures.
2162      * This has O(1) time complexity, but alters the order of the _allTokens array.
2163      * @param tokenId uint256 ID of the token to be removed from the tokens list
2164      */
2165     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
2166         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
2167         // then delete the last slot (swap and pop).
2168 
2169         uint256 lastTokenIndex = _allTokens.length - 1;
2170         uint256 tokenIndex = _allTokensIndex[tokenId];
2171 
2172         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
2173         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
2174         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
2175         uint256 lastTokenId = _allTokens[lastTokenIndex];
2176 
2177         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
2178         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
2179 
2180         // This also deletes the contents at the last position of the array
2181         delete _allTokensIndex[tokenId];
2182         _allTokens.pop();
2183     }
2184 }
2185 
2186 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol
2187 
2188 
2189 // OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Burnable.sol)
2190 
2191 pragma solidity ^0.8.0;
2192 
2193 
2194 
2195 /**
2196  * @title ERC721 Burnable Token
2197  * @dev ERC721 Token that can be irreversibly burned (destroyed).
2198  */
2199 abstract contract ERC721Burnable is Context, ERC721 {
2200     /**
2201      * @dev Burns `tokenId`. See {ERC721-_burn}.
2202      *
2203      * Requirements:
2204      *
2205      * - The caller must own `tokenId` or be an approved operator.
2206      */
2207     function burn(uint256 tokenId) public virtual {
2208         //solhint-disable-next-line max-line-length
2209         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");
2210         _burn(tokenId);
2211     }
2212 }
2213 
2214 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol
2215 
2216 
2217 // OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Pausable.sol)
2218 
2219 pragma solidity ^0.8.0;
2220 
2221 
2222 
2223 /**
2224  * @dev ERC721 token with pausable token transfers, minting and burning.
2225  *
2226  * Useful for scenarios such as preventing trades until the end of an evaluation
2227  * period, or having an emergency switch for freezing all token transfers in the
2228  * event of a large bug.
2229  */
2230 abstract contract ERC721Pausable is ERC721, Pausable {
2231     /**
2232      * @dev See {ERC721-_beforeTokenTransfer}.
2233      *
2234      * Requirements:
2235      *
2236      * - the contract must not be paused.
2237      */
2238     function _beforeTokenTransfer(
2239         address from,
2240         address to,
2241         uint256 tokenId
2242     ) internal virtual override {
2243         super._beforeTokenTransfer(from, to, tokenId);
2244 
2245         require(!paused(), "ERC721Pausable: token transfer while paused");
2246     }
2247 }
2248 
2249 // File: Scrambles.sol
2250 
2251 
2252 
2253 pragma solidity ^0.8.4;
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 /*
2268 * @title ERC721 token for Scrambles
2269 *
2270 * @author original logic by Niftydude, extended by @bitcoinski, extended again by @georgefatlion
2271 */
2272                                                                                                                                                
2273 contract Scrambles is IScrambles, ERC721Enumerable, ERC721Pausable, ERC721Burnable, Ownable, VRFConsumerBase {
2274     using Strings for uint256;
2275     using Strings for uint8;
2276     using SafeMath for uint256;
2277     using Counters for Counters.Counter;
2278 
2279     Counters.Counter private generalCounter; 
2280     uint public constant MAX_MINT = 963;
2281 
2282     // VRF stuff
2283     address public VRFCoordinator;
2284     address public LinkToken;
2285     bytes32 internal keyHash;
2286     uint256 public baseSeed;
2287   
2288     struct RedemptionWindow {
2289         bool open;
2290         uint8 maxRedeemPerWallet;
2291         bytes32 merkleRoot;
2292     }
2293 
2294     mapping(uint8 => RedemptionWindow) public redemptionWindows;
2295     mapping(address => uint8) public mintedTotal;
2296     mapping(uint8 => string[]) colours;
2297 
2298     // links
2299     string public _contractURI;
2300 
2301     bool public revealed;
2302 
2303     event Minted(address indexed account, string tokens);
2304 
2305     /**
2306     * @notice Constructor to create Scrambles contract
2307     * 
2308     * @param _name the token name
2309     * @param _symbol the token symbol
2310     * @param _maxRedeemPerWallet the max mint per redemption by index
2311     * @param _merkleRoots the merkle root for redemption window by index
2312     * @param _contractMetaDataURI the respective contract meta data URI
2313     * @param _VRFCoordinator the address of the vrf coordinator
2314     * @param _LinkToken link token
2315     * @param _keyHash chainlink keyhash
2316     */
2317     
2318     constructor (
2319         string memory _name, 
2320         string memory _symbol,
2321         uint8[] memory _maxRedeemPerWallet,
2322         bytes32[] memory _merkleRoots,
2323         string memory _contractMetaDataURI,
2324         address _VRFCoordinator, 
2325         address _LinkToken,
2326         bytes32 _keyHash
2327     ) 
2328     
2329     VRFConsumerBase(_VRFCoordinator, _LinkToken)
2330 
2331     ERC721(_name, _symbol) {
2332 
2333         // vrf stuff
2334         VRFCoordinator = _VRFCoordinator;
2335         LinkToken = _LinkToken;
2336 
2337         // erc721 stuff
2338         _contractURI = _contractMetaDataURI;
2339         keyHash = _keyHash;
2340         
2341         // set up the different redeption windows. 0 - ogs, 1 - earlybirds, 2 - ultimo macula, 3 - public.
2342         for(uint8 i = 0; i < _merkleRoots.length; i++) {
2343             redemptionWindows[i].open = false;
2344             redemptionWindows[i].maxRedeemPerWallet = _maxRedeemPerWallet[i];
2345             redemptionWindows[i].merkleRoot = _merkleRoots[i];
2346         }
2347 
2348         // setup rgb palette
2349         colours[0].push("#ff0000");
2350         colours[0].push("#00ff00");
2351         colours[0].push("#0000ff");
2352         colours[0].push("#ff8000");
2353         colours[0].push("#ffff00");
2354         colours[0].push("#ffffff");
2355 
2356         // setup cmyk palette
2357         colours[1].push("#ff00ff");
2358         colours[1].push("#00ffff");
2359         colours[1].push("#ffff00");
2360         colours[1].push("#000000");
2361         colours[1].push("#808080");
2362         colours[1].push("#ffffff");
2363 
2364         // setup b/w palette
2365         colours[2].push("#000000");
2366         colours[2].push("#333333");
2367         colours[2].push("#666666");
2368         colours[2].push("#999999");
2369         colours[2].push("#cccccc");
2370         colours[2].push("#ffffff");
2371     }
2372 
2373     /**
2374     * @notice Pause redeems until unpause is called. this pauses the whole contract. 
2375     */
2376     function pause() external override onlyOwner {
2377         _pause();
2378     }
2379 
2380     /**
2381     * @notice Unpause redeems until pause is called. this unpauses the whole contract. 
2382     */
2383     function unpause() external override onlyOwner {
2384         _unpause();
2385     }
2386 
2387     /**
2388     * @notice Set revealed to true. 
2389     */
2390     function reveal(bool state) external onlyOwner {
2391         revealed = state;
2392     }
2393 
2394     /**
2395     * @notice edit a redemption window. only writes value if it is different. 
2396     * 
2397     * @param _windowID the index of the claim window to set.
2398     * @param _merkleRoot the window merkleRoot.
2399     * @param _open the window open state.
2400     * @param _maxPerWallet the window maximum per wallet. 
2401     */
2402     function editRedemptionWindow(
2403         uint8 _windowID,
2404         bytes32 _merkleRoot, 
2405         bool _open,
2406         uint8 _maxPerWallet
2407     ) external override onlyOwner {
2408         if(redemptionWindows[_windowID].open != _open)
2409         {
2410             redemptionWindows[_windowID].open = _open;
2411         }
2412         if(redemptionWindows[_windowID].maxRedeemPerWallet != _maxPerWallet)
2413         {
2414             redemptionWindows[_windowID].maxRedeemPerWallet = _maxPerWallet;
2415         }
2416         if(redemptionWindows[_windowID].merkleRoot != _merkleRoot)
2417         {
2418             redemptionWindows[_windowID].merkleRoot = _merkleRoot;
2419         }
2420     }       
2421 
2422     /**
2423     * @notice Widthdraw Ether from contract.
2424     * 
2425     * @param _to the address to send to
2426     * @param _amount the amount to withdraw
2427     */
2428     function withdrawEther(address payable _to, uint256 _amount) public onlyOwner
2429     {
2430         _to.transfer(_amount);
2431     }
2432 
2433     /**
2434     * @notice Mint a Scramble.
2435     * 
2436     * @param windowIndex the index of the claim window to use.
2437     * @param amount the amount of tokens to mint
2438     * @param merkleProof the hash proving they are on the list for a given window. only applies to windows 0, 1 and 2.
2439     */
2440     function mint(uint8 windowIndex, uint8 amount, bytes32[] calldata merkleProof) external override{
2441         // checks
2442         require(redemptionWindows[windowIndex].open, "Redeem: window is not open");
2443         require(amount > 0, "Redeem: amount cannot be zero");
2444         require(amount < 11, "Redeem: amount cannot be more than 10");
2445         require(generalCounter.current() + amount <= MAX_MINT, "Max limit");
2446 
2447         if(windowIndex != 3)
2448         {
2449             // limit number that can be claimed for given presale window. 
2450             require(mintedTotal[msg.sender] + amount <=  redemptionWindows[windowIndex].maxRedeemPerWallet, "Too many for presale window");
2451 
2452             // check the merkle proof
2453             require(verifyMerkleProof(merkleProof, redemptionWindows[windowIndex].merkleRoot),"Invalid proof");          
2454         }
2455 
2456         string memory tokens = "";
2457 
2458         for(uint8 j = 0; j < amount; j++) {
2459             _safeMint(msg.sender, generalCounter.current());
2460             tokens = string(abi.encodePacked(tokens, generalCounter.current().toString(), ","));
2461             generalCounter.increment();
2462         }
2463         mintedTotal[msg.sender] = mintedTotal[msg.sender] + amount;
2464         emit Minted(msg.sender, tokens);
2465     }  
2466 
2467     /**
2468     * @notice Verify the merkle proof for a given root.   
2469     *     
2470     * @param proof vrf keyhash value
2471     * @param root vrf keyhash value
2472     */
2473     function verifyMerkleProof(bytes32[] memory proof, bytes32 root) public view returns (bool)
2474     {
2475         bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
2476         return MerkleProof.verify(proof, root, leaf);
2477     }
2478 
2479     /**
2480     * @notice assign the returned chainlink vrf random number to baseSeed variable.   
2481     *     
2482     * @param requestId the id of the request - unused.
2483     * @param randomness the random number from chainlink vrf. 
2484     */
2485     function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
2486         baseSeed = randomness;
2487     }
2488 
2489     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721, ERC721Enumerable) returns (bool) {
2490         return super.supportsInterface(interfaceId);
2491     }    
2492 
2493     function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
2494         super._beforeTokenTransfer(from, to, tokenId);
2495     } 
2496 
2497     function setContractURI(string memory uri) external onlyOwner{
2498         _contractURI = uri;
2499     }
2500 
2501     function contractURI() public view returns (string memory) {
2502         return _contractURI;
2503     }
2504 
2505     /**
2506     * @notice returns the base64 encoded json metadata for a token.   
2507     *     
2508     * @param tokenId the token to return data for.
2509     */
2510     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
2511         string memory name = string(abi.encodePacked("Scramble #", tokenId.toString()));
2512         return SVG721.metadata(name, getCoreNumbers(tokenId), getSVGString(tokenId),getTraits(tokenId));
2513     }
2514 
2515     /**
2516     * @notice returns the core numbers for the token. the palette index range:0-2 followed by the 9 colour indexes range: 0-5.
2517     *     
2518     * @param tokenId the tokenId to return numbers for.
2519     */
2520     function getCoreNumbers(uint256 tokenId) public view virtual override returns (string memory){
2521         string memory coreNumbers = "";
2522 
2523         if(!revealed)
2524         {
2525             return coreNumbers;
2526         }
2527 
2528         coreNumbers = string(abi.encodePacked(coreNumbers,getPaletteIndex(getSeed(tokenId)).toString()," "));
2529 
2530         for(uint8 i = 1; i < 10; i++)
2531         {
2532             coreNumbers = string(abi.encodePacked(coreNumbers,(expandRandom(getSeed(tokenId),i) % 6).toString()," "));
2533         }
2534 
2535         return coreNumbers;
2536     }
2537 
2538     /**
2539     * @notice checks if two indexes in a colour array match, if they do return 1 otherwise return 0.    
2540     *     
2541     * @param cols array of colours.
2542     * @param a first index to check.
2543     * @param b second index to check.
2544     */
2545     function checkConnection(string[9] memory cols, uint8 a, uint8 b) internal pure returns(uint8)
2546     {
2547         if(keccak256(abi.encodePacked(cols[a])) == keccak256(abi.encodePacked(cols[b]))){
2548             return 1;
2549         }
2550         else{
2551             return 0;
2552         }
2553     }
2554 
2555     /**
2556     * @notice returns the attributes part of the json string.   
2557     *     
2558     * @param tokenId the token to generate traits for.
2559     */
2560     function getTraits(uint256 tokenId) public view returns (string memory)
2561     {
2562         if(!revealed){
2563             return '"attributes": [{"value": "Unscrambled"}]';
2564         }
2565 
2566         string[9] memory cols;
2567         uint256[6] memory colTotals;
2568 
2569         for(uint8 j = 1; j < 10; j++) {
2570             
2571             string memory col = getColour(j,getSeed(tokenId));
2572             cols[j-1] =col; 
2573 
2574             for (uint i = 0; i<6; i++)
2575             {
2576                 string memory colToCheck = colours[getPaletteIndex(getSeed(tokenId))][i];
2577                 if(keccak256(abi.encodePacked(col)) == keccak256(abi.encodePacked(colToCheck)))
2578                 {
2579                     colTotals[i]++;
2580                 }
2581             }
2582         }
2583 
2584         uint8 connections = 0;
2585 
2586         connections += checkConnection(cols,0,1);
2587         connections += checkConnection(cols,1,2);
2588         connections += checkConnection(cols,0,3);
2589         connections += checkConnection(cols,1,4);
2590         connections += checkConnection(cols,2,5);
2591         connections += checkConnection(cols,3,4);
2592         connections += checkConnection(cols,4,5);
2593         connections += checkConnection(cols,3,6);
2594         connections += checkConnection(cols,4,7);
2595         connections += checkConnection(cols,5,8);
2596         connections += checkConnection(cols,6,7);
2597         connections += checkConnection(cols,7,8);
2598 
2599         uint256 totalCols = 0;
2600 
2601         for (uint256 h=0; h<6; h++){
2602 
2603             if(colTotals[h] > 0)
2604             {
2605                 totalCols++;
2606             }
2607         }
2608 
2609         string memory traits = '"attributes": [';
2610         string memory newTrait = "";
2611 
2612         for (uint256 h = 0; h < 6; h++){
2613             string memory traitName = string(abi.encodePacked('Colour #', h.toString()));
2614             newTrait = getPropertyString(traitName,colTotals[h]);
2615             traits = string(abi.encodePacked(traits,newTrait,","));
2616         }
2617 
2618         newTrait = getPropertyString("Connections",connections);
2619         traits = string(abi.encodePacked(traits,newTrait,","));
2620 
2621         newTrait = getPropertyString("Palette",getPaletteIndex(getSeed(tokenId)));
2622         traits = string(abi.encodePacked(traits,newTrait,","));
2623 
2624         newTrait = getPropertyString("Total Colours",totalCols);
2625         traits = string(abi.encodePacked(traits,newTrait,","));
2626 
2627         newTrait = getLevelString("Background Colour",expandRandom(getSeed(tokenId),10) % 256);
2628         traits = string(abi.encodePacked(traits,newTrait,","));
2629 
2630         newTrait = getLevelString("Shirt Colour",expandRandom(getSeed(tokenId),11) % 256);
2631         traits = string(abi.encodePacked(traits,newTrait,"]"));
2632 
2633         return traits;
2634     }
2635 
2636     /**
2637     * @notice create a property string with value encased in quotes.    
2638     *
2639     * @param traitName the name of the trait
2640     * @param value the value of the trait
2641     */
2642     function getPropertyString(string memory traitName, uint256 value) internal pure returns (string memory)
2643     {
2644         return string(abi.encodePacked('{"trait_type": "',traitName,'" , "value": "',value.toString(),'"}'));
2645     }
2646 
2647     /**
2648     * @notice create a level string with value not encased in quotes.    
2649     *
2650     * @param traitName the name of the trait
2651     * @param value the value of the trait
2652     */
2653     function getLevelString(string memory traitName, uint256 value) internal pure returns (string memory)
2654     {
2655         return string(abi.encodePacked('{"trait_type": "',traitName,'" , "value": ',value.toString(),'}'));
2656     }
2657 
2658     /**
2659     * @notice Return the svg string for a given token.  
2660     *
2661     * @param tokenId the token to return.  
2662     */
2663     function getSVGString(uint256 tokenId) public view returns (string memory)
2664     {   
2665         if(!revealed){
2666             return "";
2667         }
2668 
2669         string memory svgPartOne = string(abi.encodePacked('<svg xmlns="http://www.w3.org/2000/svg" width="420" height="420">',
2670         string(abi.encodePacked('<rect width="420" height="420" x="0" y="0" fill=',getGrey(10,getSeed(tokenId),100),' />')),
2671         string(abi.encodePacked('<rect width="280" height="280" x="90" y="90" fill=',getGrey(10,getSeed(tokenId),66),' />')),
2672         string(abi.encodePacked('<rect width="280" height="280" x="80" y="80" fill=',getGrey(10,getSeed(tokenId),33),' />')),
2673         string(abi.encodePacked('<rect width="280" height="280" x="70" y="70" fill="#000000" />')),
2674         string(abi.encodePacked('<rect width="120" height="70" x="150" y="350" fill=',getGrey(11,getSeed(tokenId),100),' />'))));
2675 
2676         string memory svgPartTwo = string(abi.encodePacked(        
2677         string(abi.encodePacked('<rect width="10" height="50" x="170" y="370" fill="#000000" />')),
2678         string(abi.encodePacked('<rect width="10" height="50" x="240" y="370" fill="#000000" />')),
2679         string(abi.encodePacked('<rect width="80" height="80" x="80" y="80" fill="',getColour(1,getSeed(tokenId)),'" />')),
2680         string(abi.encodePacked('<rect width="80" height="80" x="170" y="80" fill="',getColour(2,getSeed(tokenId)),'" />')),
2681         string(abi.encodePacked('<rect width="80" height="80" x="260" y="80" fill="',getColour(3,getSeed(tokenId)),'" />'))));
2682 
2683         string memory svgPartThree = string(abi.encodePacked( 
2684         string(abi.encodePacked('<rect width="80" height="80" x="80" y="170" fill="',getColour(4,getSeed(tokenId)),'" />')),
2685         string(abi.encodePacked('<rect width="80" height="80" x="170" y="170" fill="',getColour(5,getSeed(tokenId)),'" />')),
2686         string(abi.encodePacked('<rect width="80" height="80" x="260" y="170" fill="',getColour(6,getSeed(tokenId)),'" />')),
2687         string(abi.encodePacked('<rect width="80" height="80" x="80" y="260" fill="',getColour(7,getSeed(tokenId)),'" />')),
2688         string(abi.encodePacked('<rect width="80" height="80" x="170" y="260" fill="',getColour(8,getSeed(tokenId)),'" />')),
2689         string(abi.encodePacked('<rect width="80" height="80" x="260" y="260" fill="',getColour(9,getSeed(tokenId)),'" />')),
2690         '</svg>'));
2691 
2692         return string(abi.encodePacked(svgPartOne,svgPartTwo,svgPartThree));
2693     }
2694 
2695     /**
2696     * @notice Return the palette index based on a seed.  
2697     *
2698     * @param colourIndex used to expand the random number.  
2699     * @param seed the seed for the token.  
2700     */
2701     function getColour(uint8 colourIndex, uint256 seed) internal view returns (string memory)
2702     {
2703         uint256 expandedVal = expandRandom(seed,colourIndex) % 6;
2704         return colours[getPaletteIndex(seed)][expandedVal];
2705     }
2706 
2707     /**
2708     * @notice Return the palette index based on a seed.  
2709     *
2710     * @param colourIndex used to expand the random number.  
2711     * @param seed the seed for the token.  
2712     * @param percentage used to create the shadows.  
2713     */
2714     function getGrey(uint8 colourIndex, uint256 seed, uint256 percentage) public pure returns (string memory)
2715     {
2716         uint256 grey = ((expandRandom(seed,colourIndex) % 256)*percentage)/100;
2717         return string(abi.encodePacked('"rgb(',grey.toString(),',',grey.toString(),',',grey.toString(),')"'));
2718     }
2719 
2720     /**
2721     * @notice Return the palette index based on a seed.  
2722     *
2723     * @param seed the seed for the token.  
2724     */
2725     function getPaletteIndex(uint256 seed) internal pure returns (uint8)
2726     {
2727         if (seed % 10 < 6){
2728             return 0;
2729         }
2730         else if (seed % 10 < 9){
2731             return 1;
2732         }
2733         else{
2734             return 2;
2735         }
2736     }
2737 
2738     /**
2739     * @notice Call chainlink to get a random number to use as the base for the random seeds.  
2740     *
2741     * @param fee the link fee.  
2742     */
2743     function scramble(uint256 fee) public onlyOwner returns (bytes32 requestId) {
2744         require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
2745         return requestRandomness(keyHash, fee);
2746     }
2747 
2748     /**
2749     * @notice Get the random seed for a given token, expanded from the baseSeed from Chainlink VRF. 
2750     * 
2751     * @param tokenId the token id 
2752     */
2753     function getSeed(uint256 tokenId) public view returns (uint256)
2754     {
2755         require(totalSupply()>tokenId, "Token Not Found");
2756 
2757         if (baseSeed == 0){
2758             return 0;
2759         }
2760         else{
2761             return expandRandom(baseSeed, tokenId);
2762         }
2763     }
2764     
2765     /**
2766     * @notice Get the random seed for a given token, expanded from the baseSeed from Chainlink VRF. 
2767     * 
2768     * @param random the base random number 
2769     * @param expansion the expansion number
2770     */
2771     function expandRandom(uint256 random, uint256 expansion) internal pure returns (uint256)
2772     {
2773         return uint256(keccak256(abi.encode(random, expansion))) % 2000000000;
2774     }
2775 }