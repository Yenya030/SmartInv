1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/OracleV2.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract OracleV2 {\n    using SafeMath for uint;\n\n    event ExchangeRatePosted(\n        address operator,\n        uint prevExchangeRate,\n        uint newExchangeRate\n    );\n\n    address public admin;\n    address public poster;\n    uint public currentExchangeRate;\n    uint public lastUpdated;\n\n    /// @notice The change of exchange rate shouldn't exceed 1%.\n    uint public constant MAX_SWING = 0.01e18;\n\n    /// @notice Poster couldn't update the exchange rate within 12 hours.\n    uint public constant UPDATE_PERIOD = 12 hours;\n\n    constructor(address _poster) public {\n        admin = msg.sender;\n        poster = _poster;\n    }\n\n    function setAdmin(address _admin) external {\n        require(msg.sender == admin, \"!admin\");\n        admin = _admin;\n    }\n\n    function setPoster(address _poster) external {\n        require(msg.sender == admin, \"!admin\");\n        poster = _poster;\n    }\n\n    /// @notice Update the exchange rate by admin. It's for emergency.\n    /// @param newExchangeRate The new exchange rate.\n    function setExchangeRate(uint newExchangeRate) external {\n        require(msg.sender == admin, \"!admin\");\n\n        emit ExchangeRatePosted(msg.sender, currentExchangeRate, newExchangeRate);\n        currentExchangeRate = newExchangeRate;\n        lastUpdated = block.timestamp;\n    }\n\n    /// @notice Update the exchange rate by poster. It would have a cooldown period and a max swing limit.\n    /// @param newExchangeRate The new exchange rate.\n    function updateExchangeRate(uint newExchangeRate) external {\n        require(msg.sender == poster, \"!poster\");\n        require(block.timestamp > lastUpdated.add(UPDATE_PERIOD), \"cooldown\");\n\n        if (currentExchangeRate > 0) {\n            uint maxDiff = currentExchangeRate.mul(MAX_SWING).div(1e18);\n            require(newExchangeRate < currentExchangeRate.add(maxDiff), \"upper cap\");\n            require(newExchangeRate > currentExchangeRate.sub(maxDiff), \"lower cap\");\n        }\n\n        emit ExchangeRatePosted(msg.sender, currentExchangeRate, newExchangeRate);\n        currentExchangeRate = newExchangeRate;\n        lastUpdated = block.timestamp;\n    }\n\n    /// @notice Get the exchange rate between ETH and CETH2.\n    /// @return The exchange rate.\n    function exchangeRate() external view returns (uint) {\n        return currentExchangeRate;\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/math/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": true,
14       "runs": 200
15     },
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}