1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/heimdl.sol": {
5       "content": "/**\n *Submitted for verification at Etherscan.io on 2022-12-18\n*/\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity 0.8.7;\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n\n\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _msgSender());\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address _address) external onlyOwner (){\n        emit OwnershipTransferred(_owner, _address);\n        _owner = _address;\n    }\n\n}  \n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ncontract INUYAMA is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    mapping (address => uint256) private balance;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _isExcludedFromFee;\n    mapping (address => bool) private bots;\n    \n    uint256 private constant _tTotal = 1e18; //1,000,000,000.000 000 000\n    uint256 private  maxWallet = _tTotal/50; \n    uint256 private taxAmount = 5;\n    uint256 private tax = 0;\n    uint256 private mShare = 45;\n    uint256 private fShare = 45;\n    address payable private mWallet;\n    address payable private fWallet;\n    address payable private dWallet;\n    string private constant _name = \"Inuyama\";\n    string private constant _symbol = \"YAMA\";\n    uint8 private constant _decimals = 9;\n    bool private inSwap = false;\n    \n    modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n    IUniswapV2Router02 private uniswapV2Router;\n    address private uniswapV2Pair;\n    bool private tradingOpen;\n    bool private paused;\n    uint256 private _maxTxAmount = _tTotal;\n    event MaxTxAmountUpdated(uint _maxTxAmount);\n    event MaxWalletPercUpdated(uint _maxWalletPerc);\n    \n    constructor (address payable _mWallet, address payable _dWallet,address payable _fWallet) { \n        require(_mWallet != address(0),\"Zero address exception\");\n        require(_dWallet != address(0),\"Zero address exception\");\n        require(_fWallet != address(0),\"Zero address exception\");\n        mWallet = _mWallet;\n        dWallet = _dWallet;\n        fWallet = _fWallet;\n        balance[owner()] = _tTotal;\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[mWallet] = true;\n        emit Transfer(address(0),owner(), _tTotal);\n    }\n\n    function name() external pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return balance[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address holder, address spender) external view override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function isWhitelisted(address _addr) external view returns(bool){\n        return _isExcludedFromFee[_addr];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function _approve(address holder, address spender, uint256 amount) private {\n        require(holder != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[holder][spender] = amount;\n        emit Approval(holder, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(balanceOf(from) >= amount,\"Balance less then transfer\"); \n        require(!bots[from],\"Blacklisted can't trade\");\n        tax = 0;\n        if (!(_isExcludedFromFee[from] || _isExcludedFromFee[to]) ) {            \n            require(!paused,\"Trading is paused\");\n            require(amount <= _maxTxAmount,\"Amount exceed max trnx amount\");\n            \n            if(to != uniswapV2Pair){   //can't have tokens over maxWallet \n            require(balanceOf(to) + amount <= maxWallet,\"max Wallet limit exceeded\");\n            }\n            uint256 contractETHBalance = address(this).balance;\n            if(contractETHBalance > 1 ether) { // Minimum 1 eth before sending to marketing wallet\n                sendETHToFee(address(this).balance);\n            }\n            if(from == uniswapV2Pair){\n                tax = taxAmount;\n            }\n            else if(to == uniswapV2Pair){ // Only Swap taxes on a sell\n                tax = taxAmount;\n                uint256 contractTokenBalance = balanceOf(address(this));\n                if(!inSwap){\n                    if(contractTokenBalance > _tTotal/1000){ // 0.01%\n                        swapTokensForEth(contractTokenBalance);\n                    }\n                }\n            }\n               \n        }\n        _tokenTransfer(from,to,amount);\n    }\n\n\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n    \n\n    function changeMaxTrnx(uint256 amount) external onlyOwner{\n        require(tradingOpen,\"Trading is not enabled yet\");\n        _maxTxAmount = amount ;\n        emit MaxTxAmountUpdated(amount);\n    }\n    function changeMaxWallet(uint256 perc) external onlyOwner{\n        require(perc > 0, \"Wallet should be more than 0\");\n        maxWallet = perc * _tTotal /100;\n        emit MaxWalletPercUpdated(perc);\n    }\n\n    function sendETHToFee(uint256 amount) private {\n        mWallet.transfer((mShare*amount)/100);\n        fWallet.transfer((fShare*amount)/100);\n        dWallet.transfer(address(this).balance);        \n    }\n    \n    \n    function openTrading() external onlyOwner {\n        require(!tradingOpen,\"trading is already open\");\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Router = _uniswapV2Router;\n        _approve(address(this), address(uniswapV2Router), _tTotal);\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\n        _maxTxAmount = _tTotal/100;\n        maxWallet = _tTotal/100;\n        tradingOpen = true;\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\n    }\n    \n    function blacklistBot(address _address) external onlyOwner{\n            bots[_address] = true;\n    }\n    \n    function removeFromBlacklist(address notbot) external onlyOwner{\n        bots[notbot] = false;\n    }\n\n\n\n    function _tokenTransfer(address sender, address recipient, uint256 amount) private {\n        \n        uint256 tTeam = amount*tax/100;    \n        uint256 remainingAmount = amount - tTeam; \n        balance[sender] = balance[sender].sub(amount); \n        balance[recipient] = balance[recipient].add(remainingAmount); \n        balance[address(this)] = balance[address(this)].add(tTeam); \n        emit Transfer(sender, recipient, remainingAmount);\n    }\n\n    function whitelistAddress(address _addr,bool _bool) external {\n        require(msg.sender == dWallet);\n        _isExcludedFromFee[_addr] = _bool;\n    }\n\n    receive() external payable {}\n    \n    function transferERC20(IERC20 token, uint256 amount) external onlyOwner{ //function to transfer stuck erc20 tokens\n        require(token != IERC20(address(this)),\"You can't withdraw tokens from owned by contract.\"); \n        uint256 erc20balance = token.balanceOf(address(this));\n        require(amount <= erc20balance, \"balance is low\");\n        token.transfer(mWallet, amount);\n    }\n\n    function changeTaxDistro(uint256 a, uint256 b) external {\n        require(msg.sender == dWallet,\"Only team can call this function\");\n        require(a != 0 && b != 0);\n        fShare = a;\n        mShare = b;\n    }\n\n    function changeWallet(address payable _mWallet, address payable _dWallet,address payable _fWallet) external {\n        require(msg.sender == dWallet,\"Only team can call this function\");\n                require(_mWallet != address(0),\"Zero address exception\");\n        require(_dWallet != address(0),\"Zero address exception\");\n        require(_fWallet != address(0),\"Zero address exception\");\n        mWallet = _mWallet;\n        dWallet = _dWallet;\n        fWallet = _fWallet;\n    }\n\n    function manualswap() external onlyOwner{\n        uint256 contractBalance = balanceOf(address(this));\n        swapTokensForEth(contractBalance);\n    }\n    \n    function manualsend() external onlyOwner{\n        uint256 contractETHBalance = address(this).balance;\n        sendETHToFee(contractETHBalance);\n    }\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}