1 // hevm: flattened sources of src/Metastonez.sol
2 // SPDX-License-Identifier: MIT AND BSD-3-Clause AND GPL-3.0-or-later
3 pragma solidity >=0.8.0 <0.9.0 >=0.8.6 <0.9.0;
4 
5 ////// lib/chainlink/contracts/src/v0.8/VRFRequestIDBase.sol
6 /* pragma solidity ^0.8.0; */
7 
8 contract VRFRequestIDBase {
9   /**
10    * @notice returns the seed which is actually input to the VRF coordinator
11    *
12    * @dev To prevent repetition of VRF output due to repetition of the
13    * @dev user-supplied seed, that seed is combined in a hash with the
14    * @dev user-specific nonce, and the address of the consuming contract. The
15    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
16    * @dev the final seed, but the nonce does protect against repetition in
17    * @dev requests which are included in a single block.
18    *
19    * @param _userSeed VRF seed input provided by user
20    * @param _requester Address of the requesting contract
21    * @param _nonce User-specific nonce at the time of the request
22    */
23   function makeVRFInputSeed(
24     bytes32 _keyHash,
25     uint256 _userSeed,
26     address _requester,
27     uint256 _nonce
28   ) internal pure returns (uint256) {
29     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
30   }
31 
32   /**
33    * @notice Returns the id for this request
34    * @param _keyHash The serviceAgreement ID to be used for this request
35    * @param _vRFInputSeed The seed to be passed directly to the VRF
36    * @return The id for this request
37    *
38    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
39    * @dev contract, but the one generated by makeVRFInputSeed
40    */
41   function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
42     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
43   }
44 }
45 
46 ////// lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
47 /* pragma solidity ^0.8.0; */
48 
49 interface LinkTokenInterface {
50   function allowance(address owner, address spender) external view returns (uint256 remaining);
51 
52   function approve(address spender, uint256 value) external returns (bool success);
53 
54   function balanceOf(address owner) external view returns (uint256 balance);
55 
56   function decimals() external view returns (uint8 decimalPlaces);
57 
58   function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
59 
60   function increaseApproval(address spender, uint256 subtractedValue) external;
61 
62   function name() external view returns (string memory tokenName);
63 
64   function symbol() external view returns (string memory tokenSymbol);
65 
66   function totalSupply() external view returns (uint256 totalTokensIssued);
67 
68   function transfer(address to, uint256 value) external returns (bool success);
69 
70   function transferAndCall(
71     address to,
72     uint256 value,
73     bytes calldata data
74   ) external returns (bool success);
75 
76   function transferFrom(
77     address from,
78     address to,
79     uint256 value
80   ) external returns (bool success);
81 }
82 
83 ////// lib/chainlink/contracts/src/v0.8/VRFConsumerBase.sol
84 /* pragma solidity ^0.8.0; */
85 
86 /* import "./interfaces/LinkTokenInterface.sol"; */
87 
88 /* import "./VRFRequestIDBase.sol"; */
89 
90 /** ****************************************************************************
91  * @notice Interface for contracts using VRF randomness
92  * *****************************************************************************
93  * @dev PURPOSE
94  *
95  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
96  * @dev to Vera the verifier in such a way that Vera can be sure he's not
97  * @dev making his output up to suit himself. Reggie provides Vera a public key
98  * @dev to which he knows the secret key. Each time Vera provides a seed to
99  * @dev Reggie, he gives back a value which is computed completely
100  * @dev deterministically from the seed and the secret key.
101  *
102  * @dev Reggie provides a proof by which Vera can verify that the output was
103  * @dev correctly computed once Reggie tells it to her, but without that proof,
104  * @dev the output is indistinguishable to her from a uniform random sample
105  * @dev from the output space.
106  *
107  * @dev The purpose of this contract is to make it easy for unrelated contracts
108  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
109  * @dev simple access to a verifiable source of randomness.
110  * *****************************************************************************
111  * @dev USAGE
112  *
113  * @dev Calling contracts must inherit from VRFConsumerBase, and can
114  * @dev initialize VRFConsumerBase's attributes in their constructor as
115  * @dev shown:
116  *
117  * @dev   contract VRFConsumer {
118  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
119  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
120  * @dev         <initialization with other arguments goes here>
121  * @dev       }
122  * @dev   }
123  *
124  * @dev The oracle will have given you an ID for the VRF keypair they have
125  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
126  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
127  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
128  * @dev want to generate randomness from.
129  *
130  * @dev Once the VRFCoordinator has received and validated the oracle's response
131  * @dev to your request, it will call your contract's fulfillRandomness method.
132  *
133  * @dev The randomness argument to fulfillRandomness is the actual random value
134  * @dev generated from your seed.
135  *
136  * @dev The requestId argument is generated from the keyHash and the seed by
137  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
138  * @dev requests open, you can use the requestId to track which seed is
139  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
140  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
141  * @dev if your contract could have multiple requests in flight simultaneously.)
142  *
143  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
144  * @dev differ. (Which is critical to making unpredictable randomness! See the
145  * @dev next section.)
146  *
147  * *****************************************************************************
148  * @dev SECURITY CONSIDERATIONS
149  *
150  * @dev A method with the ability to call your fulfillRandomness method directly
151  * @dev could spoof a VRF response with any random value, so it's critical that
152  * @dev it cannot be directly called by anything other than this base contract
153  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
154  *
155  * @dev For your users to trust that your contract's random behavior is free
156  * @dev from malicious interference, it's best if you can write it so that all
157  * @dev behaviors implied by a VRF response are executed *during* your
158  * @dev fulfillRandomness method. If your contract must store the response (or
159  * @dev anything derived from it) and use it later, you must ensure that any
160  * @dev user-significant behavior which depends on that stored value cannot be
161  * @dev manipulated by a subsequent VRF request.
162  *
163  * @dev Similarly, both miners and the VRF oracle itself have some influence
164  * @dev over the order in which VRF responses appear on the blockchain, so if
165  * @dev your contract could have multiple VRF requests in flight simultaneously,
166  * @dev you must ensure that the order in which the VRF responses arrive cannot
167  * @dev be used to manipulate your contract's user-significant behavior.
168  *
169  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
170  * @dev block in which the request is made, user-provided seeds have no impact
171  * @dev on its economic security properties. They are only included for API
172  * @dev compatability with previous versions of this contract.
173  *
174  * @dev Since the block hash of the block which contains the requestRandomness
175  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
176  * @dev miner could, in principle, fork the blockchain to evict the block
177  * @dev containing the request, forcing the request to be included in a
178  * @dev different block with a different hash, and therefore a different input
179  * @dev to the VRF. However, such an attack would incur a substantial economic
180  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
181  * @dev until it calls responds to a request.
182  */
183 abstract contract VRFConsumerBase is VRFRequestIDBase {
184   /**
185    * @notice fulfillRandomness handles the VRF response. Your contract must
186    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
187    * @notice principles to keep in mind when implementing your fulfillRandomness
188    * @notice method.
189    *
190    * @dev VRFConsumerBase expects its subcontracts to have a method with this
191    * @dev signature, and will call it once it has verified the proof
192    * @dev associated with the randomness. (It is triggered via a call to
193    * @dev rawFulfillRandomness, below.)
194    *
195    * @param requestId The Id initially returned by requestRandomness
196    * @param randomness the VRF output
197    */
198   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
199 
200   /**
201    * @dev In order to keep backwards compatibility we have kept the user
202    * seed field around. We remove the use of it because given that the blockhash
203    * enters later, it overrides whatever randomness the used seed provides.
204    * Given that it adds no security, and can easily lead to misunderstandings,
205    * we have removed it from usage and can now provide a simpler API.
206    */
207   uint256 private constant USER_SEED_PLACEHOLDER = 0;
208 
209   /**
210    * @notice requestRandomness initiates a request for VRF output given _seed
211    *
212    * @dev The fulfillRandomness method receives the output, once it's provided
213    * @dev by the Oracle, and verified by the vrfCoordinator.
214    *
215    * @dev The _keyHash must already be registered with the VRFCoordinator, and
216    * @dev the _fee must exceed the fee specified during registration of the
217    * @dev _keyHash.
218    *
219    * @dev The _seed parameter is vestigial, and is kept only for API
220    * @dev compatibility with older versions. It can't *hurt* to mix in some of
221    * @dev your own randomness, here, but it's not necessary because the VRF
222    * @dev oracle will mix the hash of the block containing your request into the
223    * @dev VRF seed it ultimately uses.
224    *
225    * @param _keyHash ID of public key against which randomness is generated
226    * @param _fee The amount of LINK to send with the request
227    *
228    * @return requestId unique ID for this request
229    *
230    * @dev The returned requestId can be used to distinguish responses to
231    * @dev concurrent requests. It is passed as the first argument to
232    * @dev fulfillRandomness.
233    */
234   function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
235     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
236     // This is the seed passed to VRFCoordinator. The oracle will mix this with
237     // the hash of the block containing this request to obtain the seed/input
238     // which is finally passed to the VRF cryptographic machinery.
239     uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
240     // nonces[_keyHash] must stay in sync with
241     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
242     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
243     // This provides protection against the user repeating their input seed,
244     // which would result in a predictable/duplicate output, if multiple such
245     // requests appeared in the same block.
246     nonces[_keyHash] = nonces[_keyHash] + 1;
247     return makeRequestId(_keyHash, vRFSeed);
248   }
249 
250   LinkTokenInterface internal immutable LINK;
251   address private immutable vrfCoordinator;
252 
253   // Nonces for each VRF key from which randomness has been requested.
254   //
255   // Must stay in sync with VRFCoordinator[_keyHash][this]
256   mapping(bytes32 => uint256) /* keyHash */ /* nonce */
257     private nonces;
258 
259   /**
260    * @param _vrfCoordinator address of VRFCoordinator contract
261    * @param _link address of LINK token contract
262    *
263    * @dev https://docs.chain.link/docs/link-token-contracts
264    */
265   constructor(address _vrfCoordinator, address _link) {
266     vrfCoordinator = _vrfCoordinator;
267     LINK = LinkTokenInterface(_link);
268   }
269 
270   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
271   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
272   // the origin of the call
273   function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
274     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
275     fulfillRandomness(requestId, randomness);
276   }
277 }
278 
279 ////// lib/openzeppelin-contracts/contracts/utils/Context.sol
280 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
281 
282 /* pragma solidity ^0.8.0; */
283 
284 /**
285  * @dev Provides information about the current execution context, including the
286  * sender of the transaction and its data. While these are generally available
287  * via msg.sender and msg.data, they should not be accessed in such a direct
288  * manner, since when dealing with meta-transactions the account sending and
289  * paying for execution may not be the actual sender (as far as an application
290  * is concerned).
291  *
292  * This contract is only required for intermediate, library-like contracts.
293  */
294 abstract contract Context {
295     function _msgSender() internal view virtual returns (address) {
296         return msg.sender;
297     }
298 
299     function _msgData() internal view virtual returns (bytes calldata) {
300         return msg.data;
301     }
302 }
303 
304 ////// lib/openzeppelin-contracts/contracts/access/Ownable.sol
305 // OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)
306 
307 /* pragma solidity ^0.8.0; */
308 
309 /* import "../utils/Context.sol"; */
310 
311 /**
312  * @dev Contract module which provides a basic access control mechanism, where
313  * there is an account (an owner) that can be granted exclusive access to
314  * specific functions.
315  *
316  * By default, the owner account will be the one that deploys the contract. This
317  * can later be changed with {transferOwnership}.
318  *
319  * This module is used through inheritance. It will make available the modifier
320  * `onlyOwner`, which can be applied to your functions to restrict their use to
321  * the owner.
322  */
323 abstract contract Ownable is Context {
324     address private _owner;
325 
326     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
327 
328     /**
329      * @dev Initializes the contract setting the deployer as the initial owner.
330      */
331     constructor() {
332         _transferOwnership(_msgSender());
333     }
334 
335     /**
336      * @dev Returns the address of the current owner.
337      */
338     function owner() public view virtual returns (address) {
339         return _owner;
340     }
341 
342     /**
343      * @dev Throws if called by any account other than the owner.
344      */
345     modifier onlyOwner() {
346         require(owner() == _msgSender(), "Ownable: caller is not the owner");
347         _;
348     }
349 
350     /**
351      * @dev Leaves the contract without owner. It will not be possible to call
352      * `onlyOwner` functions anymore. Can only be called by the current owner.
353      *
354      * NOTE: Renouncing ownership will leave the contract without an owner,
355      * thereby removing any functionality that is only available to the owner.
356      */
357     function renounceOwnership() public virtual onlyOwner {
358         _transferOwnership(address(0));
359     }
360 
361     /**
362      * @dev Transfers ownership of the contract to a new account (`newOwner`).
363      * Can only be called by the current owner.
364      */
365     function transferOwnership(address newOwner) public virtual onlyOwner {
366         require(newOwner != address(0), "Ownable: new owner is the zero address");
367         _transferOwnership(newOwner);
368     }
369 
370     /**
371      * @dev Transfers ownership of the contract to a new account (`newOwner`).
372      * Internal function without access restriction.
373      */
374     function _transferOwnership(address newOwner) internal virtual {
375         address oldOwner = _owner;
376         _owner = newOwner;
377         emit OwnershipTransferred(oldOwner, newOwner);
378     }
379 }
380 
381 ////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
382 // OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)
383 
384 /* pragma solidity ^0.8.0; */
385 
386 /**
387  * @dev Interface of the ERC20 standard as defined in the EIP.
388  */
389 interface IERC20 {
390     /**
391      * @dev Returns the amount of tokens in existence.
392      */
393     function totalSupply() external view returns (uint256);
394 
395     /**
396      * @dev Returns the amount of tokens owned by `account`.
397      */
398     function balanceOf(address account) external view returns (uint256);
399 
400     /**
401      * @dev Moves `amount` tokens from the caller's account to `recipient`.
402      *
403      * Returns a boolean value indicating whether the operation succeeded.
404      *
405      * Emits a {Transfer} event.
406      */
407     function transfer(address recipient, uint256 amount) external returns (bool);
408 
409     /**
410      * @dev Returns the remaining number of tokens that `spender` will be
411      * allowed to spend on behalf of `owner` through {transferFrom}. This is
412      * zero by default.
413      *
414      * This value changes when {approve} or {transferFrom} are called.
415      */
416     function allowance(address owner, address spender) external view returns (uint256);
417 
418     /**
419      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
420      *
421      * Returns a boolean value indicating whether the operation succeeded.
422      *
423      * IMPORTANT: Beware that changing an allowance with this method brings the risk
424      * that someone may use both the old and the new allowance by unfortunate
425      * transaction ordering. One possible solution to mitigate this race
426      * condition is to first reduce the spender's allowance to 0 and set the
427      * desired value afterwards:
428      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
429      *
430      * Emits an {Approval} event.
431      */
432     function approve(address spender, uint256 amount) external returns (bool);
433 
434     /**
435      * @dev Moves `amount` tokens from `sender` to `recipient` using the
436      * allowance mechanism. `amount` is then deducted from the caller's
437      * allowance.
438      *
439      * Returns a boolean value indicating whether the operation succeeded.
440      *
441      * Emits a {Transfer} event.
442      */
443     function transferFrom(
444         address sender,
445         address recipient,
446         uint256 amount
447     ) external returns (bool);
448 
449     /**
450      * @dev Emitted when `value` tokens are moved from one account (`from`) to
451      * another (`to`).
452      *
453      * Note that `value` may be zero.
454      */
455     event Transfer(address indexed from, address indexed to, uint256 value);
456 
457     /**
458      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
459      * a call to {approve}. `value` is the new allowance.
460      */
461     event Approval(address indexed owner, address indexed spender, uint256 value);
462 }
463 
464 ////// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
465 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
466 
467 /* pragma solidity ^0.8.0; */
468 
469 /**
470  * @dev Interface of the ERC165 standard, as defined in the
471  * https://eips.ethereum.org/EIPS/eip-165[EIP].
472  *
473  * Implementers can declare support of contract interfaces, which can then be
474  * queried by others ({ERC165Checker}).
475  *
476  * For an implementation, see {ERC165}.
477  */
478 interface IERC165 {
479     /**
480      * @dev Returns true if this contract implements the interface defined by
481      * `interfaceId`. See the corresponding
482      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
483      * to learn more about how these ids are created.
484      *
485      * This function call must use less than 30 000 gas.
486      */
487     function supportsInterface(bytes4 interfaceId) external view returns (bool);
488 }
489 
490 ////// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol
491 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)
492 
493 /* pragma solidity ^0.8.0; */
494 
495 /* import "../../utils/introspection/IERC165.sol"; */
496 
497 /**
498  * @dev Required interface of an ERC721 compliant contract.
499  */
500 interface IERC721 is IERC165 {
501     /**
502      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
503      */
504     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
505 
506     /**
507      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
508      */
509     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
510 
511     /**
512      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
513      */
514     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
515 
516     /**
517      * @dev Returns the number of tokens in ``owner``'s account.
518      */
519     function balanceOf(address owner) external view returns (uint256 balance);
520 
521     /**
522      * @dev Returns the owner of the `tokenId` token.
523      *
524      * Requirements:
525      *
526      * - `tokenId` must exist.
527      */
528     function ownerOf(uint256 tokenId) external view returns (address owner);
529 
530     /**
531      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
532      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
533      *
534      * Requirements:
535      *
536      * - `from` cannot be the zero address.
537      * - `to` cannot be the zero address.
538      * - `tokenId` token must exist and be owned by `from`.
539      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
540      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
541      *
542      * Emits a {Transfer} event.
543      */
544     function safeTransferFrom(
545         address from,
546         address to,
547         uint256 tokenId
548     ) external;
549 
550     /**
551      * @dev Transfers `tokenId` token from `from` to `to`.
552      *
553      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
554      *
555      * Requirements:
556      *
557      * - `from` cannot be the zero address.
558      * - `to` cannot be the zero address.
559      * - `tokenId` token must be owned by `from`.
560      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
561      *
562      * Emits a {Transfer} event.
563      */
564     function transferFrom(
565         address from,
566         address to,
567         uint256 tokenId
568     ) external;
569 
570     /**
571      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
572      * The approval is cleared when the token is transferred.
573      *
574      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
575      *
576      * Requirements:
577      *
578      * - The caller must own the token or be an approved operator.
579      * - `tokenId` must exist.
580      *
581      * Emits an {Approval} event.
582      */
583     function approve(address to, uint256 tokenId) external;
584 
585     /**
586      * @dev Returns the account approved for `tokenId` token.
587      *
588      * Requirements:
589      *
590      * - `tokenId` must exist.
591      */
592     function getApproved(uint256 tokenId) external view returns (address operator);
593 
594     /**
595      * @dev Approve or remove `operator` as an operator for the caller.
596      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
597      *
598      * Requirements:
599      *
600      * - The `operator` cannot be the caller.
601      *
602      * Emits an {ApprovalForAll} event.
603      */
604     function setApprovalForAll(address operator, bool _approved) external;
605 
606     /**
607      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
608      *
609      * See {setApprovalForAll}
610      */
611     function isApprovedForAll(address owner, address operator) external view returns (bool);
612 
613     /**
614      * @dev Safely transfers `tokenId` token from `from` to `to`.
615      *
616      * Requirements:
617      *
618      * - `from` cannot be the zero address.
619      * - `to` cannot be the zero address.
620      * - `tokenId` token must exist and be owned by `from`.
621      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
622      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
623      *
624      * Emits a {Transfer} event.
625      */
626     function safeTransferFrom(
627         address from,
628         address to,
629         uint256 tokenId,
630         bytes calldata data
631     ) external;
632 }
633 
634 ////// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol
635 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)
636 
637 /* pragma solidity ^0.8.0; */
638 
639 /**
640  * @title ERC721 token receiver interface
641  * @dev Interface for any contract that wants to support safeTransfers
642  * from ERC721 asset contracts.
643  */
644 interface IERC721Receiver {
645     /**
646      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
647      * by `operator` from `from`, this function is called.
648      *
649      * It must return its Solidity selector to confirm the token transfer.
650      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
651      *
652      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
653      */
654     function onERC721Received(
655         address operator,
656         address from,
657         uint256 tokenId,
658         bytes calldata data
659     ) external returns (bytes4);
660 }
661 
662 ////// lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol
663 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
664 
665 /* pragma solidity ^0.8.0; */
666 
667 /* import "../IERC721.sol"; */
668 
669 /**
670  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
671  * @dev See https://eips.ethereum.org/EIPS/eip-721
672  */
673 interface IERC721Metadata is IERC721 {
674     /**
675      * @dev Returns the token collection name.
676      */
677     function name() external view returns (string memory);
678 
679     /**
680      * @dev Returns the token collection symbol.
681      */
682     function symbol() external view returns (string memory);
683 
684     /**
685      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
686      */
687     function tokenURI(uint256 tokenId) external view returns (string memory);
688 }
689 
690 ////// lib/openzeppelin-contracts/contracts/utils/Address.sol
691 // OpenZeppelin Contracts v4.4.1 (utils/Address.sol)
692 
693 /* pragma solidity ^0.8.0; */
694 
695 /**
696  * @dev Collection of functions related to the address type
697  */
698 library Address {
699     /**
700      * @dev Returns true if `account` is a contract.
701      *
702      * [IMPORTANT]
703      * ====
704      * It is unsafe to assume that an address for which this function returns
705      * false is an externally-owned account (EOA) and not a contract.
706      *
707      * Among others, `isContract` will return false for the following
708      * types of addresses:
709      *
710      *  - an externally-owned account
711      *  - a contract in construction
712      *  - an address where a contract will be created
713      *  - an address where a contract lived, but was destroyed
714      * ====
715      *
716      * [IMPORTANT]
717      * ====
718      * You shouldn't rely on `isContract` to protect against flash loan attacks!
719      *
720      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
721      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
722      * constructor.
723      * ====
724      */
725     function isContract(address account) internal view returns (bool) {
726         // This method relies on extcodesize, which returns 0 for contracts in
727         // construction, since the code is only stored at the end of the
728         // constructor execution.
729 
730         uint256 size;
731         assembly {
732             size := extcodesize(account)
733         }
734         return size > 0;
735     }
736 
737     /**
738      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
739      * `recipient`, forwarding all available gas and reverting on errors.
740      *
741      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
742      * of certain opcodes, possibly making contracts go over the 2300 gas limit
743      * imposed by `transfer`, making them unable to receive funds via
744      * `transfer`. {sendValue} removes this limitation.
745      *
746      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
747      *
748      * IMPORTANT: because control is transferred to `recipient`, care must be
749      * taken to not create reentrancy vulnerabilities. Consider using
750      * {ReentrancyGuard} or the
751      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
752      */
753     function sendValue(address payable recipient, uint256 amount) internal {
754         require(address(this).balance >= amount, "Address: insufficient balance");
755 
756         (bool success, ) = recipient.call{value: amount}("");
757         require(success, "Address: unable to send value, recipient may have reverted");
758     }
759 
760     /**
761      * @dev Performs a Solidity function call using a low level `call`. A
762      * plain `call` is an unsafe replacement for a function call: use this
763      * function instead.
764      *
765      * If `target` reverts with a revert reason, it is bubbled up by this
766      * function (like regular Solidity function calls).
767      *
768      * Returns the raw returned data. To convert to the expected return value,
769      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
770      *
771      * Requirements:
772      *
773      * - `target` must be a contract.
774      * - calling `target` with `data` must not revert.
775      *
776      * _Available since v3.1._
777      */
778     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
779         return functionCall(target, data, "Address: low-level call failed");
780     }
781 
782     /**
783      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
784      * `errorMessage` as a fallback revert reason when `target` reverts.
785      *
786      * _Available since v3.1._
787      */
788     function functionCall(
789         address target,
790         bytes memory data,
791         string memory errorMessage
792     ) internal returns (bytes memory) {
793         return functionCallWithValue(target, data, 0, errorMessage);
794     }
795 
796     /**
797      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
798      * but also transferring `value` wei to `target`.
799      *
800      * Requirements:
801      *
802      * - the calling contract must have an ETH balance of at least `value`.
803      * - the called Solidity function must be `payable`.
804      *
805      * _Available since v3.1._
806      */
807     function functionCallWithValue(
808         address target,
809         bytes memory data,
810         uint256 value
811     ) internal returns (bytes memory) {
812         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
813     }
814 
815     /**
816      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
817      * with `errorMessage` as a fallback revert reason when `target` reverts.
818      *
819      * _Available since v3.1._
820      */
821     function functionCallWithValue(
822         address target,
823         bytes memory data,
824         uint256 value,
825         string memory errorMessage
826     ) internal returns (bytes memory) {
827         require(address(this).balance >= value, "Address: insufficient balance for call");
828         require(isContract(target), "Address: call to non-contract");
829 
830         (bool success, bytes memory returndata) = target.call{value: value}(data);
831         return verifyCallResult(success, returndata, errorMessage);
832     }
833 
834     /**
835      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
836      * but performing a static call.
837      *
838      * _Available since v3.3._
839      */
840     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
841         return functionStaticCall(target, data, "Address: low-level static call failed");
842     }
843 
844     /**
845      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
846      * but performing a static call.
847      *
848      * _Available since v3.3._
849      */
850     function functionStaticCall(
851         address target,
852         bytes memory data,
853         string memory errorMessage
854     ) internal view returns (bytes memory) {
855         require(isContract(target), "Address: static call to non-contract");
856 
857         (bool success, bytes memory returndata) = target.staticcall(data);
858         return verifyCallResult(success, returndata, errorMessage);
859     }
860 
861     /**
862      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
863      * but performing a delegate call.
864      *
865      * _Available since v3.4._
866      */
867     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
868         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
869     }
870 
871     /**
872      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
873      * but performing a delegate call.
874      *
875      * _Available since v3.4._
876      */
877     function functionDelegateCall(
878         address target,
879         bytes memory data,
880         string memory errorMessage
881     ) internal returns (bytes memory) {
882         require(isContract(target), "Address: delegate call to non-contract");
883 
884         (bool success, bytes memory returndata) = target.delegatecall(data);
885         return verifyCallResult(success, returndata, errorMessage);
886     }
887 
888     /**
889      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
890      * revert reason using the provided one.
891      *
892      * _Available since v4.3._
893      */
894     function verifyCallResult(
895         bool success,
896         bytes memory returndata,
897         string memory errorMessage
898     ) internal pure returns (bytes memory) {
899         if (success) {
900             return returndata;
901         } else {
902             // Look for revert reason and bubble it up if present
903             if (returndata.length > 0) {
904                 // The easiest way to bubble the revert reason is using memory via assembly
905 
906                 assembly {
907                     let returndata_size := mload(returndata)
908                     revert(add(32, returndata), returndata_size)
909                 }
910             } else {
911                 revert(errorMessage);
912             }
913         }
914     }
915 }
916 
917 ////// lib/openzeppelin-contracts/contracts/utils/Strings.sol
918 // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)
919 
920 /* pragma solidity ^0.8.0; */
921 
922 /**
923  * @dev String operations.
924  */
925 library Strings {
926     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
927 
928     /**
929      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
930      */
931     function toString(uint256 value) internal pure returns (string memory) {
932         // Inspired by OraclizeAPI's implementation - MIT licence
933         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
934 
935         if (value == 0) {
936             return "0";
937         }
938         uint256 temp = value;
939         uint256 digits;
940         while (temp != 0) {
941             digits++;
942             temp /= 10;
943         }
944         bytes memory buffer = new bytes(digits);
945         while (value != 0) {
946             digits -= 1;
947             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
948             value /= 10;
949         }
950         return string(buffer);
951     }
952 
953     /**
954      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
955      */
956     function toHexString(uint256 value) internal pure returns (string memory) {
957         if (value == 0) {
958             return "0x00";
959         }
960         uint256 temp = value;
961         uint256 length = 0;
962         while (temp != 0) {
963             length++;
964             temp >>= 8;
965         }
966         return toHexString(value, length);
967     }
968 
969     /**
970      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
971      */
972     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
973         bytes memory buffer = new bytes(2 * length + 2);
974         buffer[0] = "0";
975         buffer[1] = "x";
976         for (uint256 i = 2 * length + 1; i > 1; --i) {
977             buffer[i] = _HEX_SYMBOLS[value & 0xf];
978             value >>= 4;
979         }
980         require(value == 0, "Strings: hex length insufficient");
981         return string(buffer);
982     }
983 }
984 
985 ////// lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
986 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
987 
988 /* pragma solidity ^0.8.0; */
989 
990 /* import "./IERC165.sol"; */
991 
992 /**
993  * @dev Implementation of the {IERC165} interface.
994  *
995  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
996  * for the additional interface id that will be supported. For example:
997  *
998  * ```solidity
999  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
1000  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
1001  * }
1002  * ```
1003  *
1004  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
1005  */
1006 abstract contract ERC165 is IERC165 {
1007     /**
1008      * @dev See {IERC165-supportsInterface}.
1009      */
1010     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
1011         return interfaceId == type(IERC165).interfaceId;
1012     }
1013 }
1014 
1015 ////// lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol
1016 // OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)
1017 
1018 /* pragma solidity ^0.8.0; */
1019 
1020 /* import "./IERC721.sol"; */
1021 /* import "./IERC721Receiver.sol"; */
1022 /* import "./extensions/IERC721Metadata.sol"; */
1023 /* import "../../utils/Address.sol"; */
1024 /* import "../../utils/Context.sol"; */
1025 /* import "../../utils/Strings.sol"; */
1026 /* import "../../utils/introspection/ERC165.sol"; */
1027 
1028 /**
1029  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
1030  * the Metadata extension, but not including the Enumerable extension, which is available separately as
1031  * {ERC721Enumerable}.
1032  */
1033 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
1034     using Address for address;
1035     using Strings for uint256;
1036 
1037     // Token name
1038     string private _name;
1039 
1040     // Token symbol
1041     string private _symbol;
1042 
1043     // Mapping from token ID to owner address
1044     mapping(uint256 => address) private _owners;
1045 
1046     // Mapping owner address to token count
1047     mapping(address => uint256) private _balances;
1048 
1049     // Mapping from token ID to approved address
1050     mapping(uint256 => address) private _tokenApprovals;
1051 
1052     // Mapping from owner to operator approvals
1053     mapping(address => mapping(address => bool)) private _operatorApprovals;
1054 
1055     /**
1056      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1057      */
1058     constructor(string memory name_, string memory symbol_) {
1059         _name = name_;
1060         _symbol = symbol_;
1061     }
1062 
1063     /**
1064      * @dev See {IERC165-supportsInterface}.
1065      */
1066     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1067         return
1068             interfaceId == type(IERC721).interfaceId ||
1069             interfaceId == type(IERC721Metadata).interfaceId ||
1070             super.supportsInterface(interfaceId);
1071     }
1072 
1073     /**
1074      * @dev See {IERC721-balanceOf}.
1075      */
1076     function balanceOf(address owner) public view virtual override returns (uint256) {
1077         require(owner != address(0), "ERC721: balance query for the zero address");
1078         return _balances[owner];
1079     }
1080 
1081     /**
1082      * @dev See {IERC721-ownerOf}.
1083      */
1084     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1085         address owner = _owners[tokenId];
1086         require(owner != address(0), "ERC721: owner query for nonexistent token");
1087         return owner;
1088     }
1089 
1090     /**
1091      * @dev See {IERC721Metadata-name}.
1092      */
1093     function name() public view virtual override returns (string memory) {
1094         return _name;
1095     }
1096 
1097     /**
1098      * @dev See {IERC721Metadata-symbol}.
1099      */
1100     function symbol() public view virtual override returns (string memory) {
1101         return _symbol;
1102     }
1103 
1104     /**
1105      * @dev See {IERC721Metadata-tokenURI}.
1106      */
1107     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1108         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1109 
1110         string memory baseURI = _baseURI();
1111         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1112     }
1113 
1114     /**
1115      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1116      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1117      * by default, can be overriden in child contracts.
1118      */
1119     function _baseURI() internal view virtual returns (string memory) {
1120         return "";
1121     }
1122 
1123     /**
1124      * @dev See {IERC721-approve}.
1125      */
1126     function approve(address to, uint256 tokenId) public virtual override {
1127         address owner = ERC721.ownerOf(tokenId);
1128         require(to != owner, "ERC721: approval to current owner");
1129 
1130         require(
1131             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1132             "ERC721: approve caller is not owner nor approved for all"
1133         );
1134 
1135         _approve(to, tokenId);
1136     }
1137 
1138     /**
1139      * @dev See {IERC721-getApproved}.
1140      */
1141     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1142         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1143 
1144         return _tokenApprovals[tokenId];
1145     }
1146 
1147     /**
1148      * @dev See {IERC721-setApprovalForAll}.
1149      */
1150     function setApprovalForAll(address operator, bool approved) public virtual override {
1151         _setApprovalForAll(_msgSender(), operator, approved);
1152     }
1153 
1154     /**
1155      * @dev See {IERC721-isApprovedForAll}.
1156      */
1157     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1158         return _operatorApprovals[owner][operator];
1159     }
1160 
1161     /**
1162      * @dev See {IERC721-transferFrom}.
1163      */
1164     function transferFrom(
1165         address from,
1166         address to,
1167         uint256 tokenId
1168     ) public virtual override {
1169         //solhint-disable-next-line max-line-length
1170         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1171 
1172         _transfer(from, to, tokenId);
1173     }
1174 
1175     /**
1176      * @dev See {IERC721-safeTransferFrom}.
1177      */
1178     function safeTransferFrom(
1179         address from,
1180         address to,
1181         uint256 tokenId
1182     ) public virtual override {
1183         safeTransferFrom(from, to, tokenId, "");
1184     }
1185 
1186     /**
1187      * @dev See {IERC721-safeTransferFrom}.
1188      */
1189     function safeTransferFrom(
1190         address from,
1191         address to,
1192         uint256 tokenId,
1193         bytes memory _data
1194     ) public virtual override {
1195         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1196         _safeTransfer(from, to, tokenId, _data);
1197     }
1198 
1199     /**
1200      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1201      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1202      *
1203      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1204      *
1205      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1206      * implement alternative mechanisms to perform token transfer, such as signature-based.
1207      *
1208      * Requirements:
1209      *
1210      * - `from` cannot be the zero address.
1211      * - `to` cannot be the zero address.
1212      * - `tokenId` token must exist and be owned by `from`.
1213      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1214      *
1215      * Emits a {Transfer} event.
1216      */
1217     function _safeTransfer(
1218         address from,
1219         address to,
1220         uint256 tokenId,
1221         bytes memory _data
1222     ) internal virtual {
1223         _transfer(from, to, tokenId);
1224         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1225     }
1226 
1227     /**
1228      * @dev Returns whether `tokenId` exists.
1229      *
1230      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1231      *
1232      * Tokens start existing when they are minted (`_mint`),
1233      * and stop existing when they are burned (`_burn`).
1234      */
1235     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1236         return _owners[tokenId] != address(0);
1237     }
1238 
1239     /**
1240      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1241      *
1242      * Requirements:
1243      *
1244      * - `tokenId` must exist.
1245      */
1246     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1247         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1248         address owner = ERC721.ownerOf(tokenId);
1249         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1250     }
1251 
1252     /**
1253      * @dev Safely mints `tokenId` and transfers it to `to`.
1254      *
1255      * Requirements:
1256      *
1257      * - `tokenId` must not exist.
1258      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1259      *
1260      * Emits a {Transfer} event.
1261      */
1262     function _safeMint(address to, uint256 tokenId) internal virtual {
1263         _safeMint(to, tokenId, "");
1264     }
1265 
1266     /**
1267      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1268      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1269      */
1270     function _safeMint(
1271         address to,
1272         uint256 tokenId,
1273         bytes memory _data
1274     ) internal virtual {
1275         _mint(to, tokenId);
1276         require(
1277             _checkOnERC721Received(address(0), to, tokenId, _data),
1278             "ERC721: transfer to non ERC721Receiver implementer"
1279         );
1280     }
1281 
1282     /**
1283      * @dev Mints `tokenId` and transfers it to `to`.
1284      *
1285      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1286      *
1287      * Requirements:
1288      *
1289      * - `tokenId` must not exist.
1290      * - `to` cannot be the zero address.
1291      *
1292      * Emits a {Transfer} event.
1293      */
1294     function _mint(address to, uint256 tokenId) internal virtual {
1295         require(to != address(0), "ERC721: mint to the zero address");
1296         require(!_exists(tokenId), "ERC721: token already minted");
1297 
1298         _beforeTokenTransfer(address(0), to, tokenId);
1299 
1300         _balances[to] += 1;
1301         _owners[tokenId] = to;
1302 
1303         emit Transfer(address(0), to, tokenId);
1304 
1305         _afterTokenTransfer(address(0), to, tokenId);
1306     }
1307 
1308     /**
1309      * @dev Destroys `tokenId`.
1310      * The approval is cleared when the token is burned.
1311      *
1312      * Requirements:
1313      *
1314      * - `tokenId` must exist.
1315      *
1316      * Emits a {Transfer} event.
1317      */
1318     function _burn(uint256 tokenId) internal virtual {
1319         address owner = ERC721.ownerOf(tokenId);
1320 
1321         _beforeTokenTransfer(owner, address(0), tokenId);
1322 
1323         // Clear approvals
1324         _approve(address(0), tokenId);
1325 
1326         _balances[owner] -= 1;
1327         delete _owners[tokenId];
1328 
1329         emit Transfer(owner, address(0), tokenId);
1330 
1331         _afterTokenTransfer(owner, address(0), tokenId);
1332     }
1333 
1334     /**
1335      * @dev Transfers `tokenId` from `from` to `to`.
1336      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1337      *
1338      * Requirements:
1339      *
1340      * - `to` cannot be the zero address.
1341      * - `tokenId` token must be owned by `from`.
1342      *
1343      * Emits a {Transfer} event.
1344      */
1345     function _transfer(
1346         address from,
1347         address to,
1348         uint256 tokenId
1349     ) internal virtual {
1350         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
1351         require(to != address(0), "ERC721: transfer to the zero address");
1352 
1353         _beforeTokenTransfer(from, to, tokenId);
1354 
1355         // Clear approvals from the previous owner
1356         _approve(address(0), tokenId);
1357 
1358         _balances[from] -= 1;
1359         _balances[to] += 1;
1360         _owners[tokenId] = to;
1361 
1362         emit Transfer(from, to, tokenId);
1363 
1364         _afterTokenTransfer(from, to, tokenId);
1365     }
1366 
1367     /**
1368      * @dev Approve `to` to operate on `tokenId`
1369      *
1370      * Emits a {Approval} event.
1371      */
1372     function _approve(address to, uint256 tokenId) internal virtual {
1373         _tokenApprovals[tokenId] = to;
1374         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1375     }
1376 
1377     /**
1378      * @dev Approve `operator` to operate on all of `owner` tokens
1379      *
1380      * Emits a {ApprovalForAll} event.
1381      */
1382     function _setApprovalForAll(
1383         address owner,
1384         address operator,
1385         bool approved
1386     ) internal virtual {
1387         require(owner != operator, "ERC721: approve to caller");
1388         _operatorApprovals[owner][operator] = approved;
1389         emit ApprovalForAll(owner, operator, approved);
1390     }
1391 
1392     /**
1393      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1394      * The call is not executed if the target address is not a contract.
1395      *
1396      * @param from address representing the previous owner of the given token ID
1397      * @param to target address that will receive the tokens
1398      * @param tokenId uint256 ID of the token to be transferred
1399      * @param _data bytes optional data to send along with the call
1400      * @return bool whether the call correctly returned the expected magic value
1401      */
1402     function _checkOnERC721Received(
1403         address from,
1404         address to,
1405         uint256 tokenId,
1406         bytes memory _data
1407     ) private returns (bool) {
1408         if (to.isContract()) {
1409             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1410                 return retval == IERC721Receiver.onERC721Received.selector;
1411             } catch (bytes memory reason) {
1412                 if (reason.length == 0) {
1413                     revert("ERC721: transfer to non ERC721Receiver implementer");
1414                 } else {
1415                     assembly {
1416                         revert(add(32, reason), mload(reason))
1417                     }
1418                 }
1419             }
1420         } else {
1421             return true;
1422         }
1423     }
1424 
1425     /**
1426      * @dev Hook that is called before any token transfer. This includes minting
1427      * and burning.
1428      *
1429      * Calling conditions:
1430      *
1431      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1432      * transferred to `to`.
1433      * - When `from` is zero, `tokenId` will be minted for `to`.
1434      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1435      * - `from` and `to` are never both zero.
1436      *
1437      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1438      */
1439     function _beforeTokenTransfer(
1440         address from,
1441         address to,
1442         uint256 tokenId
1443     ) internal virtual {}
1444 
1445     /**
1446      * @dev Hook that is called after any transfer of tokens. This includes
1447      * minting and burning.
1448      *
1449      * Calling conditions:
1450      *
1451      * - when `from` and `to` are both non-zero.
1452      * - `from` and `to` are never both zero.
1453      *
1454      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1455      */
1456     function _afterTokenTransfer(
1457         address from,
1458         address to,
1459         uint256 tokenId
1460     ) internal virtual {}
1461 }
1462 
1463 ////// lib/openzeppelin-contracts/contracts/utils/Counters.sol
1464 // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
1465 
1466 /* pragma solidity ^0.8.0; */
1467 
1468 /**
1469  * @title Counters
1470  * @author Matt Condon (@shrugs)
1471  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
1472  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
1473  *
1474  * Include with `using Counters for Counters.Counter;`
1475  */
1476 library Counters {
1477     struct Counter {
1478         // This variable should never be directly accessed by users of the library: interactions must be restricted to
1479         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
1480         // this feature: see https://github.com/ethereum/solidity/issues/4637
1481         uint256 _value; // default: 0
1482     }
1483 
1484     function current(Counter storage counter) internal view returns (uint256) {
1485         return counter._value;
1486     }
1487 
1488     function increment(Counter storage counter) internal {
1489         unchecked {
1490             counter._value += 1;
1491         }
1492     }
1493 
1494     function decrement(Counter storage counter) internal {
1495         uint256 value = counter._value;
1496         require(value > 0, "Counter: decrement overflow");
1497         unchecked {
1498             counter._value = value - 1;
1499         }
1500     }
1501 
1502     function reset(Counter storage counter) internal {
1503         counter._value = 0;
1504     }
1505 }
1506 
1507 ////// lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol
1508 // OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)
1509 
1510 /* pragma solidity ^0.8.0; */
1511 
1512 /**
1513  * @dev These functions deal with verification of Merkle Trees proofs.
1514  *
1515  * The proofs can be generated using the JavaScript library
1516  * https://github.com/miguelmota/merkletreejs[merkletreejs].
1517  * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
1518  *
1519  * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
1520  */
1521 library MerkleProof {
1522     /**
1523      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
1524      * defined by `root`. For this, a `proof` must be provided, containing
1525      * sibling hashes on the branch from the leaf to the root of the tree. Each
1526      * pair of leaves and each pair of pre-images are assumed to be sorted.
1527      */
1528     function verify(
1529         bytes32[] memory proof,
1530         bytes32 root,
1531         bytes32 leaf
1532     ) internal pure returns (bool) {
1533         return processProof(proof, leaf) == root;
1534     }
1535 
1536     /**
1537      * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up
1538      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
1539      * hash matches the root of the tree. When processing the proof, the pairs
1540      * of leafs & pre-images are assumed to be sorted.
1541      *
1542      * _Available since v4.4._
1543      */
1544     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
1545         bytes32 computedHash = leaf;
1546         for (uint256 i = 0; i < proof.length; i++) {
1547             bytes32 proofElement = proof[i];
1548             if (computedHash <= proofElement) {
1549                 // Hash(current computed hash + current element of the proof)
1550                 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
1551             } else {
1552                 // Hash(current element of the proof + current computed hash)
1553                 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
1554             }
1555         }
1556         return computedHash;
1557     }
1558 }
1559 
1560 ////// src/ERC721Checkpointable.sol
1561 
1562 /// @title Vote checkpointing for an ERC-721 token
1563 
1564 // LICENSE
1565 // ERC721Checkpointable.sol uses and modifies part of Compound Lab's Comp.sol:
1566 // https://github.com/compound-finance/compound-protocol/blob/ae4388e780a8d596d97619d9704a931a2752c2bc/contracts/Governance/Comp.sol
1567 //
1568 // Comp.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.
1569 // With modifications by Nounders DAO.
1570 // Additional slight modification by Metastonez (see note below).
1571 //
1572 // Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause
1573 //
1574 // MODIFICATIONS
1575 // Checkpointing logic from Comp.sol has been used with the following modifications:
1576 // - `delegates` is renamed to `_delegates` and is set to private
1577 // - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike
1578 //   Comp.sol, returns the delegator's own address if there is no delegate.
1579 //   This avoids the delegator needing to "delegate to self" with an additional transaction
1580 // - `_transferTokens()` is renamed `_beforeTokenTransfer()` and adapted to hook into OpenZeppelin's ERC721 hooks.
1581 //
1582 // METASTONEZ MODIFICATIONS
1583 // - Uses base ERC721 from OZ instead of the modified version of ERC721Enumerable made by Nounders DAO.
1584 
1585 /* pragma solidity ^0.8.6; */
1586 
1587 /* import "@openzeppelin/contracts/token/ERC721/ERC721.sol"; */
1588 /* import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol"; */
1589 
1590 abstract contract ERC721Checkpointable is ERC721 {
1591     /// @notice Defines decimals as per ERC-20 convention to make integrations with 3rd party governance platforms easier
1592     uint8 public constant decimals = 0;
1593 
1594     /// @notice A record of each accounts delegate
1595     mapping(address => address) private _delegates;
1596 
1597     /// @notice A checkpoint for marking number of votes from a given block
1598     struct Checkpoint {
1599         uint32 fromBlock;
1600         uint96 votes;
1601     }
1602 
1603     /// @notice A record of votes checkpoints for each account, by index
1604     mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;
1605 
1606     /// @notice The number of checkpoints for each account
1607     mapping(address => uint32) public numCheckpoints;
1608 
1609     /// @notice The EIP-712 typehash for the contract's domain
1610     bytes32 public constant DOMAIN_TYPEHASH =
1611         keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
1612 
1613     /// @notice The EIP-712 typehash for the delegation struct used by the contract
1614     bytes32 public constant DELEGATION_TYPEHASH =
1615         keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
1616 
1617     /// @notice A record of states for signing / validating signatures
1618     mapping(address => uint256) public nonces;
1619 
1620     /// @notice An event thats emitted when an account changes its delegate
1621     event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
1622 
1623     /// @notice An event thats emitted when a delegate account's vote balance changes
1624     event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
1625 
1626     /**
1627      * @notice The votes a delegator can delegate, which is the current balance of the delegator.
1628      * @dev Used when calling `_delegate()`
1629      */
1630     function votesToDelegate(address delegator) public view returns (uint96) {
1631         return safe96(balanceOf(delegator), "ERC721Checkpointable::votesToDelegate: amount exceeds 96 bits");
1632     }
1633 
1634     /**
1635      * @notice Overrides the standard `Comp.sol` delegates mapping to return
1636      * the delegator's own address if they haven't delegated.
1637      * This avoids having to delegate to oneself.
1638      */
1639     function delegates(address delegator) public view returns (address) {
1640         address current = _delegates[delegator];
1641         return current == address(0) ? delegator : current;
1642     }
1643 
1644     /**
1645      * @notice Adapted from `_transferTokens()` in `Comp.sol` to update delegate votes.
1646      * @dev hooks into OpenZeppelin's `ERC721._transfer`
1647      */
1648     function _beforeTokenTransfer(
1649         address from,
1650         address to,
1651         uint256 tokenId
1652     ) internal override {
1653         super._beforeTokenTransfer(from, to, tokenId);
1654 
1655         /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation
1656         _moveDelegates(delegates(from), delegates(to), 1);
1657     }
1658 
1659     /**
1660      * @notice Delegate votes from `msg.sender` to `delegatee`
1661      * @param delegatee The address to delegate votes to
1662      */
1663     function delegate(address delegatee) public {
1664         if (delegatee == address(0)) delegatee = msg.sender;
1665         return _delegate(msg.sender, delegatee);
1666     }
1667 
1668     /**
1669      * @notice Delegates votes from signatory to `delegatee`
1670      * @param delegatee The address to delegate votes to
1671      * @param nonce The contract state required to match the signature
1672      * @param expiry The time at which to expire the signature
1673      * @param v The recovery byte of the signature
1674      * @param r Half of the ECDSA signature pair
1675      * @param s Half of the ECDSA signature pair
1676      */
1677     function delegateBySig(
1678         address delegatee,
1679         uint256 nonce,
1680         uint256 expiry,
1681         uint8 v,
1682         bytes32 r,
1683         bytes32 s
1684     ) public {
1685         bytes32 domainSeparator = keccak256(
1686             abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))
1687         );
1688         bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
1689         bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
1690         address signatory = ecrecover(digest, v, r, s);
1691         require(signatory != address(0), "ERC721Checkpointable::delegateBySig: invalid signature");
1692         require(nonce == nonces[signatory]++, "ERC721Checkpointable::delegateBySig: invalid nonce");
1693         require(block.timestamp <= expiry, "ERC721Checkpointable::delegateBySig: signature expired");
1694         return _delegate(signatory, delegatee);
1695     }
1696 
1697     /**
1698      * @notice Gets the current votes balance for `account`
1699      * @param account The address to get votes balance
1700      * @return The number of current votes for `account`
1701      */
1702     function getCurrentVotes(address account) external view returns (uint96) {
1703         uint32 nCheckpoints = numCheckpoints[account];
1704         return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
1705     }
1706 
1707     /**
1708      * @notice Determine the prior number of votes for an account as of a block number
1709      * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
1710      * @param account The address of the account to check
1711      * @param blockNumber The block number to get the vote balance at
1712      * @return The number of votes the account had as of the given block
1713      */
1714     function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {
1715         require(blockNumber < block.number, "ERC721Checkpointable::getPriorVotes: not yet determined");
1716 
1717         uint32 nCheckpoints = numCheckpoints[account];
1718         if (nCheckpoints == 0) {
1719             return 0;
1720         }
1721 
1722         // First check most recent balance
1723         if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
1724             return checkpoints[account][nCheckpoints - 1].votes;
1725         }
1726 
1727         // Next check implicit zero balance
1728         if (checkpoints[account][0].fromBlock > blockNumber) {
1729             return 0;
1730         }
1731 
1732         uint32 lower = 0;
1733         uint32 upper = nCheckpoints - 1;
1734         while (upper > lower) {
1735             uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
1736             Checkpoint memory cp = checkpoints[account][center];
1737             if (cp.fromBlock == blockNumber) {
1738                 return cp.votes;
1739             } else if (cp.fromBlock < blockNumber) {
1740                 lower = center;
1741             } else {
1742                 upper = center - 1;
1743             }
1744         }
1745         return checkpoints[account][lower].votes;
1746     }
1747 
1748     function _delegate(address delegator, address delegatee) internal {
1749         /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation
1750         address currentDelegate = delegates(delegator);
1751 
1752         _delegates[delegator] = delegatee;
1753 
1754         emit DelegateChanged(delegator, currentDelegate, delegatee);
1755 
1756         uint96 amount = votesToDelegate(delegator);
1757 
1758         _moveDelegates(currentDelegate, delegatee, amount);
1759     }
1760 
1761     function _moveDelegates(
1762         address srcRep,
1763         address dstRep,
1764         uint96 amount
1765     ) internal {
1766         if (srcRep != dstRep && amount > 0) {
1767             if (srcRep != address(0)) {
1768                 uint32 srcRepNum = numCheckpoints[srcRep];
1769                 uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
1770                 uint96 srcRepNew = sub96(srcRepOld, amount, "ERC721Checkpointable::_moveDelegates: amount underflows");
1771                 _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
1772             }
1773 
1774             if (dstRep != address(0)) {
1775                 uint32 dstRepNum = numCheckpoints[dstRep];
1776                 uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
1777                 uint96 dstRepNew = add96(dstRepOld, amount, "ERC721Checkpointable::_moveDelegates: amount overflows");
1778                 _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
1779             }
1780         }
1781     }
1782 
1783     function _writeCheckpoint(
1784         address delegatee,
1785         uint32 nCheckpoints,
1786         uint96 oldVotes,
1787         uint96 newVotes
1788     ) internal {
1789         uint32 blockNumber = safe32(
1790             block.number,
1791             "ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits"
1792         );
1793 
1794         if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
1795             checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
1796         } else {
1797             checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
1798             numCheckpoints[delegatee] = nCheckpoints + 1;
1799         }
1800 
1801         emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
1802     }
1803 
1804     function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {
1805         require(n < 2**32, errorMessage);
1806         return uint32(n);
1807     }
1808 
1809     function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {
1810         require(n < 2**96, errorMessage);
1811         return uint96(n);
1812     }
1813 
1814     function add96(
1815         uint96 a,
1816         uint96 b,
1817         string memory errorMessage
1818     ) internal pure returns (uint96) {
1819         uint96 c = a + b;
1820         require(c >= a, errorMessage);
1821         return c;
1822     }
1823 
1824     function sub96(
1825         uint96 a,
1826         uint96 b,
1827         string memory errorMessage
1828     ) internal pure returns (uint96) {
1829         require(b <= a, errorMessage);
1830         return a - b;
1831     }
1832 
1833     function getChainId() internal view returns (uint256) {
1834         uint256 chainId;
1835         assembly {
1836             chainId := chainid()
1837         }
1838         return chainId;
1839     }
1840 }
1841 
1842 
1843 ////// src/Metastonez.sol
1844 /* pragma solidity ^0.8.0; */
1845 
1846 // Base contracts
1847 /* import "@openzeppelin/contracts/access/Ownable.sol"; */
1848 /* import "./ERC721Checkpointable.sol"; */
1849 
1850 // Chainlink related contracts
1851 /* import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; */
1852 /* import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"; */
1853 
1854 // Utilities
1855 /* import "@openzeppelin/contracts/utils/Counters.sol"; */
1856 /* import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol"; */
1857 /* import "@openzeppelin/contracts/utils/Address.sol"; */
1858 /* import "@openzeppelin/contracts/utils/Strings.sol"; */
1859 
1860 // MMMMMMMNy+/:-......-:/+yNMMMMMMM
1861 // MMMMMMd-....---::---....-mMMMMMM
1862 // MMMMMMo.:/oossssssssoo/:.sMMMMMM
1863 // MMMMMy//osssss+//+ssssso/+yMMMMM
1864 // MMMMNs:..--://....//:--../sNMMMM
1865 // MMMMds:......+..../-.....:sdMMMM
1866 // MMMMhs:....../..../......:shMMMM
1867 // MMMMys:......:://::......:syMMMM
1868 // MMMMss:.....:osssso:.....:ssMMMM
1869 // MMMNss:.....-:////:-.....:ssNMMM
1870 // MMMMys:....-////////-..../syMMMM
1871 // MMMMNd/...-osssssssso-...+dNMMMM
1872 // MMMMMMo..................sMMMMMM
1873 // MMMMMdo-................-sdMMMMM
1874 // MMMMMysso+///::::::///+ossyMMMMM
1875 // MMMMMNdhyyssssssssssssyyhdNMMMMM
1876 
1877 contract Metastonez is Ownable, ERC721Checkpointable, VRFConsumerBase {
1878   using Counters for Counters.Counter;
1879   using Strings for uint256;
1880 
1881   // Metastonez is structured in several batches.
1882   //
1883   // A batch represents a range of tokens, where each batch
1884   // contains metadata generated with different parameters from other batches.
1885   //
1886   // Metadata is shuffled locally within each batch using entropy set
1887   // during reveal of the tokens.
1888   //
1889   // All batches are revealed at the same time.
1890   struct Batch {
1891     // The starting token ID in this batch (inclusive)
1892     uint256 startIndex;
1893     // The ending token ID in this batch (exclusive)
1894     uint256 endIndex;
1895     // The hash of the metadata URI
1896     bytes32 metadataHash;
1897     // The metadata URI (where `keccak256(metadata) == metadataHash`)
1898     string metadata;
1899     // The price per token in the batch. Batches are priced differently
1900     // because they are generated with different parameters.
1901     uint256 unitPrice;
1902     // The merkle root of the whitelist of the batch.
1903     bytes32 merkleRoot;
1904     // A bitmap of spent already spent merkle leaves in the whitelist.
1905     mapping(uint256 => uint256) spentLeaves;
1906     // The entropy used to shuffle the tokens.
1907     // Once this is set, all tokens are revealed simultaneously,
1908     // given that the metadata URI of the batch has also
1909     // been revealed.
1910     uint256 entropy; 
1911   }
1912 
1913   // Metastonez has three initial batches:
1914   //
1915   // - The first one, "Genesis", contains a small set of Metastonez
1916   // - The second one, "Origins", contains a larger set of Metastonez
1917   // - The third one contains a set of 1/1s that will be auctioned off
1918   //   using a separate mechanism. This batch will be minted by the
1919   //   auction contract.
1920   //
1921   // It is possible for the owner to create more batches, e.g. for
1922   // collaboration tokens. The ownership of the contract is transferred
1923   // to the Metastonez DAO when minting is done.
1924   Batch[] public batches;
1925   // The batch that is currently (or about to be) minting
1926   uint256 public currentBatch = 0;
1927 
1928   enum MintState {
1929     Pause,
1930     Whitelist,
1931     Public
1932   }
1933 
1934   // The current state of minting
1935   //
1936   // The contract can be in three states:
1937   // - Pause: No one can mint
1938   // - Whitelist: Whitelist can mint
1939   // - Public: Anyone can mint
1940   //
1941   // The state can only transition in the following ways:
1942   //   Pause -> Whitelist -> Public
1943   //
1944   // After a cycle has been completed the contract is put
1945   // back into a paused state and the `currentBatch`
1946   // state variable is incremented.
1947   //
1948   // Accounts can only mint the tokens available in
1949   // the current batch (denoted by `currentBatch`).
1950   MintState public mintState = MintState.Pause;
1951 
1952   // The IPFS CID for pre-reveal metadata
1953   string public prerevealMetadata;
1954 
1955   // The address that ether used for mint is sent to.
1956   address public immutable beneficiary;
1957 
1958   // The Chainlink token used for VRF fees.
1959   IERC20 public immutable linkToken;
1960 
1961   // Chainlink VRF key hash
1962   bytes32 internal immutable keyHash;
1963 
1964   // A mapping of Chainlink request IDs to batch IDs
1965   mapping(bytes32 => uint256) internal entropyRequests;
1966 
1967   // Total supply tracking
1968   Counters.Counter private _totalSupply;
1969 
1970   // A list of authorized contracts.
1971   // The intention is that the controller of Metastonez will be able to create more
1972   // batches in the future. In the case that smart wallets and/or account abstraction
1973   // become a prevalent thing, we want to be able to give control of minting
1974   // to a separate contract.
1975   mapping(address => bool) public authorizedContracts;
1976 
1977   constructor(
1978     address _beneficiary,
1979     string memory _prerevealMetadata,
1980     bytes32 _linkKeyHash,
1981     address _linkAddress,
1982     address _linkVrfCoordinatorAddress
1983   )
1984     ERC721("MetaStonez", "MSZ")
1985     VRFConsumerBase(_linkVrfCoordinatorAddress, _linkAddress)
1986   {
1987     beneficiary = _beneficiary;
1988     prerevealMetadata = _prerevealMetadata;
1989     keyHash = _linkKeyHash;
1990     linkToken = IERC20(_linkAddress);
1991   }
1992 
1993   /**
1994    * @dev Creates a new batch of tokens with given supply, price and metadata.
1995    *
1996    * The metadata **SHOULD** be an IPFS CID and nothing else.
1997    *
1998    * Note: It is OK to create a batch without committing the metadata hash,
1999    * since the batch can only start minting once the hash is set (which can be set later).
2000    */
2001   function createBatch(
2002     uint256 supply,
2003     bytes32 metadataHash,
2004     uint256 unitPrice
2005   )
2006     external
2007     onlyOwner
2008     returns (uint256 batchId)
2009   {
2010     require(
2011       supply > 0,
2012       "Metastonez: BATCH_SIZE"
2013     );
2014 
2015     uint256 startIndex = 0;
2016     if (batches.length > 0) {
2017       startIndex = batches[batches.length - 1].endIndex;
2018     }
2019 
2020     Batch storage batch = batches.push();
2021     batch.startIndex = startIndex;
2022     batch.endIndex = startIndex + supply;
2023     batch.metadataHash = metadataHash;
2024     batch.unitPrice = unitPrice;
2025 
2026     return batches.length - 1;
2027   }
2028 
2029   /**
2030    * @dev Commits the hash of the metadata for the batch.
2031    *
2032    * This hash is used to prove that metadata was not shuffled
2033    * post-mint and must therefore be committed pre-mint.
2034    *
2035    * The metadata hash is committed upon batch creation, however
2036    * this method is intended to be a failsafe in case the committed
2037    * hash was wrong.
2038    */
2039   function commitBatchMetadata(
2040     uint256 batchId,
2041     bytes32 metadataHash
2042   )
2043     external
2044     onlyOwner
2045   {
2046     require(
2047       currentBatch < batchId || mintState == MintState.Pause,
2048       "Metastonez: BATCH_LOCKED"
2049     );
2050     Batch storage batch = batches[batchId];
2051     batch.metadataHash = metadataHash;
2052   }
2053 
2054   /**
2055    * @dev Reveals metadata for a given batch.
2056    *
2057    * The hash of the metadata *must* match the hash
2058    * committed to the batch before minting began.
2059    *
2060    * It is possible to reveal metadata _before_
2061    * minting begins, since metadata "leaks" are not
2062    * a concern, as in the case of a batch
2063    * that is put up for auction.
2064    */
2065   function revealBatchMetadata(
2066     uint256 batchId,
2067     string calldata metadata
2068   )
2069     internal
2070   {
2071     Batch storage batch = batches[batchId];
2072     require(
2073       keccak256(abi.encodePacked(metadata)) == batch.metadataHash,
2074       "Metastonez: INVALID_METADATA"
2075     );
2076     batch.metadata = metadata;
2077   }
2078 
2079   /**
2080    * @dev Reveals a batch by revealing the metadata
2081    * and requesting shuffling entropy from Chainlink.
2082    */
2083   function revealBatch(
2084     uint256 batchId,
2085     string calldata metadata,
2086     uint256 linkFee
2087   )
2088     public
2089     onlyOwner
2090     returns (bytes32 requestId)
2091   {
2092     require(linkToken.balanceOf(address(this)) >= linkFee, "Metastonez: INSUFFICIENT_LINK");
2093     require(batches[batchId].entropy == 0, "Metastonez: ENTROPY_ALREADY_SET");
2094     revealBatchMetadata(batchId, metadata);
2095 
2096     requestId = requestRandomness(keyHash, linkFee);
2097     entropyRequests[requestId] = batchId;
2098 
2099     return requestId;
2100   }
2101 
2102   /**
2103    * @dev Sets the whitelist merkle root for a batch.
2104    * Fails if it is already set.
2105    */
2106   function setBatchWhitelist(
2107     uint256 batchId,
2108     bytes32 merkleRoot
2109   )
2110     external
2111     onlyOwner
2112   {
2113     Batch storage batch = batches[batchId];
2114     require(
2115       batch.merkleRoot == 0,
2116       "Metastonez: WHITELIST_LOCKED"
2117     );
2118     batch.merkleRoot = merkleRoot;
2119   }
2120 
2121   function transitionState() external onlyOwner {
2122     if (mintState == MintState.Pause) {
2123       require(
2124         batches.length > 0,
2125         "Metastonez: TRANS_NO_BATCHES"
2126       );
2127       require(
2128         currentBatch <= batches.length - 1,
2129         "Metastonez: TRANS_NO_BATCH"
2130       );
2131       Batch storage batch = batches[currentBatch];
2132       require(
2133         batch.metadataHash != 0,
2134         "Metastonez: TRANS_METADATA_HASH"
2135       );
2136 
2137       mintState = MintState.Whitelist;
2138     } else if (mintState == MintState.Whitelist) {
2139       mintState = MintState.Public;
2140     } else {
2141       require(
2142         _totalSupply.current() == batches[currentBatch].endIndex,
2143         "Metastonez: TRANS_MINTING"
2144       );
2145       currentBatch = currentBatch + 1;
2146       mintState = MintState.Pause;
2147     }
2148   }
2149 
2150   /**
2151    * @dev Mints a token in the current batch for a
2152    * whitelisted user by submitting a merkle proof.
2153    *
2154    * Note that it is possible to perform the mint on
2155    * behalf of other accounts; given the proof is valid
2156    * the minted token will be sent to the account specified
2157    * in the parameter of the call.
2158    */
2159   function mintWhitelist(
2160     uint256 index,
2161     address account,
2162     uint256 amount,
2163     bytes32[] calldata proof
2164   )
2165     external
2166     payable
2167   {
2168     // Ensure that minting is enabled
2169     require(
2170       mintState != MintState.Pause,
2171       "Metastonez: MINT_PAUSED"
2172     );
2173 
2174     // Check that this leaf was not already claimed
2175     Batch storage batch = batches[currentBatch];
2176     require(
2177       !isClaimed(currentBatch, index),
2178       "Metastonez: MINT_ALREADY_CLAIMED"
2179     );
2180 
2181     // Validate the proof
2182     bytes32 node = keccak256(abi.encodePacked(index, account, amount));
2183     require(
2184       batch.merkleRoot != 0 && MerkleProof.verify(proof, batch.merkleRoot, node),
2185       "Metastonez: INVALID_PROOF"
2186     );
2187 
2188     // Validate the sent value
2189     require(msg.value == batch.unitPrice * amount, "Metastonez: INVALID_VALUE");
2190 
2191     // Validate that there are more tokens to mint
2192     require(_totalSupply.current() + amount <= batch.endIndex, "Metastonez: SUPPLY_EXHAUSTED");
2193 
2194     // Set the leaf as claimed and mint the token
2195     _setClaimed(batch, index);
2196     for (uint256 i = 0; i < amount; i++) {
2197       _safeMint(account, _totalSupply.current());
2198       _totalSupply.increment();
2199     }
2200   }
2201 
2202   /**
2203    * @dev Public mint
2204    */
2205   function mint() external payable {
2206     // Ensure that minting is enabled
2207     require(
2208       mintState == MintState.Public,
2209       "Metastonez: MINT_PAUSED"
2210     );
2211 
2212     // Ensure caller is either an EOA or an approved contract
2213     require(
2214       tx.origin == msg.sender || authorizedContracts[msg.sender],
2215       "Metastonez: SENDER_NOT_ALLOWED"
2216     );
2217 
2218     // Validate the sent value
2219     Batch storage batch = batches[currentBatch];
2220     require(msg.value == batch.unitPrice, "Metastonez: INVALID_VALUE");
2221 
2222     // Validate that there are more tokens to mint
2223     require(_totalSupply.current() + 1 <= batch.endIndex, "Metastonez: SUPPLY_EXHAUSTED");
2224 
2225     _safeMint(msg.sender, _totalSupply.current());
2226     _totalSupply.increment();
2227   }
2228 
2229   function fulfillRandomness(bytes32 requestId, uint256 entropy) internal override {
2230     uint256 batchId = entropyRequests[requestId];
2231     if (batches[batchId].entropy == 0) {
2232       batches[batchId].entropy = entropy;
2233       delete entropyRequests[requestId];
2234     }
2235   }
2236 
2237   function tokenURI(uint256 tokenId) public view override returns (string memory) {
2238     require(_exists(tokenId), "Metastonez: TOKEN_DOESNT_EXIST");
2239 
2240     for (uint256 i = 0; i < batches.length; i++) {
2241       Batch storage batch = batches[i];
2242       if (tokenId >= batch.startIndex && tokenId < batch.endIndex) {
2243         if (batch.entropy == 0 || bytes(batch.metadata).length == 0) {
2244           return string(abi.encodePacked("ipfs://", prerevealMetadata));
2245         }
2246 
2247         require(bytes(batch.metadata).length > 0, "Metastonez: METADATA_UNREVEALED");
2248 
2249         uint256 shuffledTokenId = computeShuffledIndex(
2250           uint64(tokenId - batch.startIndex),
2251           uint64(batch.endIndex - batch.startIndex),
2252           keccak256(abi.encode(batch.entropy))
2253         ) + batch.startIndex;
2254 
2255         return string(abi.encodePacked("ipfs://", batch.metadata, "/", shuffledTokenId.toString(), ".json")); 
2256       }
2257     }
2258  }
2259 
2260  function totalSupply() public view returns (uint256) {
2261    return _totalSupply.current();
2262  }
2263 
2264   /**
2265    * @dev An implementation of the swap-or-not algorithm based on
2266    * the implementation in the [Eth2 consesus spec](https://github.com/ethereum/consensus-specs/blob/v0.12.2/specs/phase0/beacon-chain.md#compute_shuffled_index)
2267    */
2268   function computeShuffledIndex(
2269     uint64 index,
2270     uint64 indexCount,
2271     bytes32 seed
2272   )
2273     public
2274     pure
2275     returns (uint64)
2276   {
2277     require(index < indexCount, "SwapOrNot: INVALID_PARAMS");
2278 
2279     for (
2280       uint8 currentRound = 0;
2281       currentRound < 24;
2282       currentRound++
2283     ) {
2284       uint64 pivot = uint64(uint(keccak256(abi.encodePacked(seed, currentRound)))) % indexCount;
2285       uint64 flip = (pivot + indexCount - index) % indexCount;
2286       uint64 position = index > flip ? index : flip;
2287       bytes32 source = keccak256(
2288         abi.encodePacked(seed, currentRound, position / 256)
2289       );
2290       uint8 byt = uint8(source[(position % 256) / 8]);
2291       uint8 bit = (byt >> (position % 8)) % 2;
2292 
2293       if (bit > 0) {
2294         index = flip;
2295       }
2296     }
2297 
2298     return index;
2299   }
2300 
2301   /**
2302    * @dev Checks if a whitelist spot has already been used for
2303    * a given batch ID and whitelist index.
2304    */
2305   function isClaimed(
2306     uint256 batchId,
2307     uint256 index
2308   )
2309     public
2310     view
2311     returns (bool)
2312   {
2313     uint256 claimedWordIndex = index / 256;
2314     uint256 claimedBitIndex = index % 256;
2315     uint256 claimedWord = batches[batchId].spentLeaves[claimedWordIndex];
2316     uint256 mask = (1 << claimedBitIndex);
2317     return claimedWord & mask == mask;
2318   }
2319 
2320   /**
2321    * @dev Mark a whitelist spot as claimed for a given batch.
2322    */
2323   function _setClaimed(
2324     Batch storage batch,
2325     uint256 index
2326   ) private {
2327     uint256 claimedWordIndex = index / 256;
2328     uint256 claimedBitIndex = index % 256;
2329     batch.spentLeaves[claimedWordIndex] = batch.spentLeaves[claimedWordIndex] | (1 << claimedBitIndex);
2330   }
2331 
2332   /**
2333    * @dev Authorize a contract to mint.
2334    */
2335   function authorizeContract(address contractAddress) public onlyOwner {
2336     authorizedContracts[contractAddress] = true;
2337   }
2338 
2339   /**
2340    * @dev Forbid a contract that has previously been authorized to mint.
2341    */
2342   function forbidContract(address contractAddress) public onlyOwner {
2343     authorizedContracts[contractAddress] = false;
2344   }
2345 
2346   /**
2347    * @dev Withdraw all eth from the contract
2348    */
2349   function withdraw() public {
2350     Address.sendValue(payable(beneficiary), address(this).balance);
2351   }
2352 
2353   /**
2354    * @dev Withdraw all of a token from the contract
2355    */
2356   function withdrawToken(address tokenAddress) public onlyOwner {
2357     IERC20 token = IERC20(tokenAddress);
2358     token.transferFrom(
2359       address(this),
2360       beneficiary,
2361       token.balanceOf(address(this))
2362     );
2363   }
2364 }