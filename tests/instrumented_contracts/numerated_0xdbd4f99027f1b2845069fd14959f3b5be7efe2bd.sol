1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/BollycoinPresaleV2.sol": {
5       "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../utils/Context.sol\";\nimport \"../interfaces/IBollycoinPriceFeed.sol\";\nimport \"../utils/ReentrancyGuard.sol\";\n\n/**\n * @title - Bollycoin Presale Contract V2\n * @author - Nodeberry Pvt Ltd\n */\n\ncontract BollycoinPresaleV2 is Context, ReentrancyGuard {\n    /**\n     * @dev `_usdt` represents the USDT smart contract address.\n     * @dev `_usdc` represents the USDC smart contract address.\n     * @dev `_busd` represents the BUSD smart contract address.\n     * @dev `_bollycoin` represents Bollycoin token contract address.\n     * @dev `_settlementWallet` represents the wallet address to which tokens are sent during purchase.\n     * @dev `_admin` is the account that controls the sale.\n     */\n    address private _usdt;\n    address private _usdc;\n    address private _busd;\n    address private _wbtc;\n    address private _bollycoin;\n    address private _admin;\n    address private _oracle;\n    address private _settlementWallet;\n    \n    uint256 public bollycoinPrice = 0.1 * 10**18; // 0.1 USD\n    \n    /**\n     * @dev checks if `caller` is `_admin`\n     * reverts if the `caller` is not the `_admin` account.\n     */\n    modifier onlyAdmin() {\n        require(_admin == msgSender(), \"Error: caller not admin\");\n        _;\n    }\n\n    /**\n     * @dev - Purchase event is emitted whenever a successful purchase is made.\n     */\n    event Purchase(\n        address indexed buyer,\n        string uid,\n        uint256 amount,\n        uint256 valueInPurchaseCurrency,\n        bytes32 currency\n    );\n\n    constructor(\n        address _usdtAddress,\n        address _usdcAddress,\n        address _busdAddress,\n        address _wbtcAddress,\n        address _bollyAddress,\n        address _oracleAddress,\n        address _settlementAddress\n        \n    ) {\n        _usdt = _usdtAddress;\n        _usdc = _usdcAddress;\n        _busd = _busdAddress;\n        _bollycoin = _bollyAddress;\n        _oracle = _oracleAddress;\n         _wbtc = _wbtcAddress;\n        _admin = _settlementAddress;\n        _settlementWallet = _settlementAddress;\n    }\n\n    /**\n     * @dev used to purchase bollycoin using USDT. Tokens are sent to the buyer.\n     * @param _amount - The number of bollycoin tokens to purchase\n     */\n    function purchaseWithUSDT(uint256 _amount, string memory uid)\n        public\n        nonReentrant\n        virtual\n        returns (bool)\n    {\n        uint256 balance = IERC20(_usdt).balanceOf(msgSender());\n        uint256 allowance = IERC20(_usdt).allowance(msgSender(), address(this));\n\n        uint256 usdValue = (bollycoinPrice) * _amount;\n\n        uint256 totalCostInUSDT = usdValue / 10**12;\n         \n        \n        require(balance >= totalCostInUSDT, \"Error: insufficient USDT Balance\");\n        require(\n            allowance >= totalCostInUSDT,\n            \"Error: allowance less than spending\"\n        );\n\n        IERC20(_usdt).transferFrom(\n            msgSender(),\n            _settlementWallet,\n            totalCostInUSDT\n        );\n        \n        IERC20(_bollycoin).transfer(msgSender(), _amount * 10**18);\n        \n        emit Purchase(\n            msgSender(),\n            uid,\n            _amount,\n            usdValue,\n            bytes32(\"USDT\")\n        );\n        \n        return true;\n    }\n\n    /**\n     * @dev used to purchase bollycoin using USDC. Tokens are sent to the buyer.\n     * @param _amount - The number of bollycoin tokens to purchase\n     */\n    function purchaseWithUSDC(uint256 _amount, string memory uid)\n        public\n        nonReentrant\n        virtual\n        returns (bool)\n    {\n        uint256 balance = IERC20(_usdc).balanceOf(msgSender());\n        uint256 allowance = IERC20(_usdc).allowance(msgSender(), address(this));\n\n        uint256 usdValue = (bollycoinPrice) * _amount;\n\n        uint256 totalCostInUSDC = usdValue / 10**12;\n         \n        require(balance >= totalCostInUSDC, \"Error: insufficient USDC Balance\");\n        \n        require(\n            allowance >= totalCostInUSDC,\n            \"Error: allowance less than spending\"\n        );\n\n        IERC20(_usdc).transferFrom(\n            msgSender(),\n            _settlementWallet,\n            totalCostInUSDC\n        );\n        IERC20(_bollycoin).transfer(msgSender(), _amount * 10**18);\n        \n        emit Purchase(msgSender(), uid, _amount, usdValue, bytes32(\"USDC\"));\n        \n        return true;\n    }\n\n    /**\n     * @dev used to purchase bollycoin using BUSD. Tokens are sent to the buyer.\n     * @param _amount - The number of bollycoin tokens to purchase\n     */\n    function purchaseWithBUSD(uint256 _amount, string memory uid)\n        public\n        nonReentrant\n        virtual\n        returns (bool)\n    {\n        uint256 balance = IERC20(_busd).balanceOf(msgSender());\n        uint256 allowance = IERC20(_busd).allowance(msgSender(), address(this));\n\n        uint256 totalCostInBUSD = (bollycoinPrice) * _amount;\n        require(balance >= totalCostInBUSD, \"Error: insufficient BUSD Balance\");\n        require(\n            allowance >= totalCostInBUSD,\n            \"Error: allowance less than spending\"\n        );\n\n        IERC20(_busd).transferFrom(\n            msgSender(),\n            _settlementWallet,\n            totalCostInBUSD\n        );\n        IERC20(_bollycoin).transfer(msgSender(), _amount * 10**18);\n        emit Purchase(\n            msgSender(),\n            uid,\n            _amount,\n            totalCostInBUSD,\n            bytes32(\"BUSD\")\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev used to purchase bollycoin using wBTC. Tokens are sent to the buyer.\n     * @param _amount - The number of bollycoin tokens to purchase\n     */\n    function purchaseWithWBTC(uint256 _amount, string memory uid)\n        public\n        nonReentrant\n        virtual\n        returns (bool)\n    {\n        uint256 balance = IERC20(_wbtc).balanceOf(msgSender());\n        uint256 allowance = IERC20(_wbtc).allowance(msgSender(), address(this));\n        \n        uint256 wbtcCmp = IBollycoinPriceFeed(_oracle).getLatestBTCPrice();\n       \n        uint256 totalCostInWBTC = (bollycoinPrice) * _amount *10**18 / wbtcCmp / 10**10;\n        \n        require(balance >= totalCostInWBTC, \"Error: insufficient WBTC Balance\");\n        require(\n            allowance >= totalCostInWBTC,\n            \"Error: allowance less than spending\"\n        );\n\n        IERC20(_wbtc).transferFrom(\n            msgSender(),\n            _settlementWallet,\n            totalCostInWBTC\n        );\n        \n        IERC20(_bollycoin).transfer(msgSender(), _amount * 10**18);\n        \n        emit Purchase(\n            msgSender(),\n            uid,\n            _amount,\n            totalCostInWBTC,\n            bytes32(\"wBTC\")\n        );\n        return true;\n    }\n \n   \n    \n    /**\n     * @dev used to purchase bollycoin using ETH. ETH is sent to the buyer.\n      */\n    function purchaseWithETH(string memory uid)\n        public\n        payable\n        nonReentrant\n        virtual\n        returns (bool)\n    {\n        uint256 ethCmp = IBollycoinPriceFeed(_oracle).getLatestETHPrice();\n         uint256 bollyToTransfer = _msgValue() * ethCmp / bollycoinPrice;\n        \n        (bool sent, bytes memory data) = _settlementWallet.call{value: _msgValue()}(\"\");\n        require(sent, \"Failed to send ETH\"); \t\t\n        IERC20(_bollycoin).transfer(msgSender(), bollyToTransfer);\n        emit Purchase(\n            msgSender(),\n            uid,\n            bollyToTransfer,\n            _msgValue(),\n            bytes32(\"ETH\")\n        );\n        return true;\n    }\n    /**\n     * @dev returns the USDT token address used for purchase.\n     */\n    function usdt() public view returns (address) {\n        return _usdt;\n    }\n\n    /**\n     * @dev returns the USDC token address used for purchase.\n     */\n    function usdc() public view returns (address) {\n        return _usdc;\n    }\n    \n    /**\n     * @dev returns the Oracle address.\n     */\n    function oracle() public view returns (address) {\n        return _oracle;\n    }\n\n    /**\n     * @dev returns the busd smart contract used for purchase.\n     */\n    function busd() public view returns (address) {\n        return _busd;\n    }\n\n    /**\n     * @dev returns the bollycoin smart contract used for purchase.\n     */\n    function bolly() public view returns (address) {\n        return _bollycoin;\n    }\n\n    /**\n     * @dev returns the wBTC token address used for purchase.\n     */\n     \n    function wBTC() public view returns (address) {\n        return _wbtc;\n    }\n\n    /**\n     * @dev returns the admin account used for purchase.\n     */\n    function admin() public view returns (address) {\n        return _admin;\n    }\n\n    /**\n     * @dev returns the settlement address used for purchase.\n     */\n    function settlementAddress() public view returns (address) {\n        return _settlementWallet;\n    }\n\n    /**\n     * @dev transfers ownership to a different account.\n     *\n     * Requirements:\n     * `newAdmin` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function transferControl(address newAdmin) public virtual onlyAdmin {\n        require(newAdmin != address(0), \"Error: owner cannot be zero\");\n        _admin = newAdmin;\n    }\n    \n    \n     /**\n     * @dev updates the oracle address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateOracle(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _oracle = newAddress;\n    }\n\n    /**\n     * @dev updates the usdt sc address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateUsdt(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _usdt = newAddress;\n    }\n\n    /**\n     * @dev updates the usdc sc address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateUsdc(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _usdc = newAddress;\n    }\n\n    /**\n     * @dev updates the bollycoin token address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateBolly(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _bollycoin = newAddress;\n    }\n    \n     /**\n     * @dev updates the wBTC token address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateWBTC(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _wbtc = newAddress;\n    }\n\n    /**\n     * @dev updates the busd sc address.\n     *\n     * Requirements:\n     * `newAddress` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateBusd(address newAddress) public virtual onlyAdmin {\n        require(newAddress != address(0), \"Error: address cannot be zero\");\n        _busd = newAddress;\n    }\n\n    /**\n     * @dev updates the bollycoin token price.\n     *\n     * Requirements:\n     * `newPrice` cannot be zero.\n     * `caller` should be current admin.\n     */\n    function updateBollycoinPrice(uint256 newPrice) public virtual onlyAdmin {\n        require(newPrice > 0, \"Error: price cannot be zero\");\n        bollycoinPrice = newPrice;\n    }\n\n    /**\n     * @dev updates the settlement wallet address\n     *\n     * Requirements:\n     * `settlementWallet` cannot be a zero address.\n     * `caller` should be current admin.\n     */\n    function updateSettlementWallet(address newAddress)\n        public\n        virtual\n        onlyAdmin\n    {\n        require(newAddress != address(0), \"Error: not a valid address\");\n        _settlementWallet = newAddress;\n    }\n\n    /**\n     * @dev withdraw bollycoin from SC to any EOA.\n     *\n     * `caller` should be admin account.\n     * `to` cannot be zero address.\n     */\n    function withdrawBolly(address to, uint256 amount)\n        public\n        virtual\n        onlyAdmin\n        returns (bool)\n    {\n        require(to != address(0), \"Error: cannot send to zero address\");\n        IERC20(_bollycoin).transfer(to, amount);\n        return true;\n    }\n}\n"
6     },
7     "utils/ReentrancyGuard.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
9     },
10     "interfaces/IBollycoinPriceFeed.sol": {
11       "content": "pragma solidity >=0.6.0;\n\ninterface IBollycoinPriceFeed {\n     \n    function getLatestETHPrice() external view returns(uint256);\n    function getLatestBTCPrice() external view returns(uint256);\n\n \n}"
12     },
13     "utils/Context.sol": {
14       "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n     function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n}"
15     },
16     "interfaces/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.8.4;\n\ninterface IERC20 {\n    \n     /**\n     * @dev returns the tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n     /**\n     * @dev returns the decimal places of a token\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev returns the remaining number of tokens the `spender' can spend\n     * on behalf of the owner.\n     *\n     * This value changes when {approve} or {transferFrom} is executed.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    /**\n     * @dev transfers the `amount` of tokens from caller's account\n     * to the `recipient` account.\n     *\n     * returns boolean value indicating the operation status.\n     *\n     * Emits a {Transfer} event\n     */\n    function transfer(address recipient, uint256 amount)\n        external;\n   /**\n     * @dev transfers the `amount` on behalf of `spender` to the `recipient` account.\n     *\n     * returns a boolean indicating the operation status.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) external;\n }\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 200
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     }
37   }
38 }}