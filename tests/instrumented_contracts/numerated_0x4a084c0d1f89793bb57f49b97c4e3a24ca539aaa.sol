1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/SwapContract.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\npragma experimental ABIEncoderV2;\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IBurnableToken.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ISwapContract.sol\";\nimport \"./interfaces/ISwapRewards.sol\";\nimport \"./interfaces/IParams.sol\";\nimport \"./interfaces/IAugustusSwapper.sol\";\nimport \"./interfaces/ITokenTransferProxy.sol\";\nimport \"./interfaces/IParaswap.sol\";\nimport \"./interfaces/lib/Utils.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/lib/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n//import \"hardhat/console.sol\"; //console.log()\n\ncontract SwapContract is Ownable, ReentrancyGuard, ISwapContract {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct spPendingTx {\n        bytes32 SwapID; //swap hash for identification of this swap.\n        string DestAddr; //destination BTC address for the swap\n        address RefundAddr; //refund address on evm source chain for if the swap fails.\n        uint256 AmountWBTC; //outbound amount for this swap.\n        uint256 Timestamp; // block timestamp that is set by EVM\n    }\n\n    IBurnableToken public immutable lpToken;\n    IParams public immutable ip;\n    ISwapRewards public immutable sw;\n\n    /** Skybridge */\n    mapping(address => bool) public whitelist;\n    address public immutable BTCT_ADDR;\n    address public immutable sbBTCPool;\n    uint256 private immutable convertScale;\n    uint256 private immutable lpDivisor;\n\n    mapping(address => uint256) private floatAmountOf;\n    mapping(bytes32 => bool) private used; //used TX\n\n    /** TSS */\n    // Node lists state { 0 => not exist, 1 => exist, 2 => removed }\n    mapping(address => uint8) private nodes;\n    address[] private nodeAddrs;\n    uint8 public activeNodeCount;\n    uint8 public churnedInCount;\n    uint8 public tssThreshold;\n\n    /** Skypool */\n    //skypools - token balance - call using tokens[token address][user address] to get uint256 balance - see function balanceOf\n    mapping(address => mapping(address => uint256)) public tokens;\n    //keep track of ether in tokens[][]\n    address constant ETHER = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public paraswapAddress; \n    address public immutable wETH;\n    //Data and indexes for pending swap objects\n    mapping(uint256 => spPendingTx) public spPendingTXs; //index => pending TX object\n    uint256 public swapCount;\n    uint256 public oldestActiveIndex;\n    uint256 public limitBTCForSPFlow2;\n\n    /**\n     * Events\n     */\n    event Swap(address from, address to, uint256 amount);\n    event Withdraw(\n        address token,\n        address user,\n        uint256 amount,\n        uint256 balance,\n        uint256 Timestamp\n    );\n    event Deposit(\n        address token,\n        address user,\n        uint256 amount,\n        uint256 balance,\n        uint256 Timestamp\n    );\n    event RewardsCollection(\n        address feesToken,\n        uint256 rewards,\n        uint256 amountLPTokensForNode,\n        uint256 currentPriceLP\n    );\n\n    event IssueLPTokensForFloat(\n        address to,\n        uint256 amountOfFloat,\n        uint256 amountOfLP,\n        uint256 currentPriceLP,\n        uint256 depositFees,\n        bytes32 txid\n    );\n\n    event BurnLPTokensForFloat(\n        address token,\n        uint256 amountOfLP,\n        uint256 amountOfFloat,\n        uint256 currentPriceLP,\n        uint256 withdrawal,\n        bytes32 txid\n    );\n\n    event SwapTokensToBTC(\n        bytes32 SwapID,\n        string DestAddr,\n        address RefundAddr,\n        uint256 AmountWBTC,\n        uint256 Timestamp\n    );\n\n    event DistributeNodeRewards(uint256 rewardLPTsForNodes);     \n\n    modifier priceCheck() {\n        uint256 beforePrice = getCurrentPriceLP();        \n        _;\n        require(getCurrentPriceLP() >= beforePrice, \"Invalid LPT price\");\n    }\n\n    constructor(\n        address _lpToken,\n        address _btct,\n        address _wETH,\n        address _sbBTCPool,\n        address _params,\n        address _swapRewards,\n        uint256 _existingBTCFloat\n    ) {\n        //init latest removed index and swapCount\n        oldestActiveIndex = 0;\n        swapCount = 0;\n        //set address for wETH\n        wETH = _wETH;\n        //set address for sbBTCpool\n        sbBTCPool = _sbBTCPool;\n        //set IParams\n        ip = IParams(_params);\n        //set paraswap address\n        paraswapAddress = ip.paraswapAddress();\n        //set ISwapRewards\n        sw = ISwapRewards(_swapRewards);\n        // Set lpToken address\n        lpToken = IBurnableToken(_lpToken);\n        // Set initial lpDivisor of LP token\n        lpDivisor = 10**IERC20(_lpToken).decimals();\n        // Set BTCT address\n        BTCT_ADDR = _btct;\n        // Set convertScale\n        convertScale = 10**(IERC20(_btct).decimals() - 8);\n        // Set whitelist addresses\n        whitelist[_btct] = true;\n        whitelist[_lpToken] = true;\n        whitelist[address(0)] = true;\n        floatAmountOf[address(0)] = _existingBTCFloat;\n    }\n\n    /**\n     * Transfer part\n     */\n    /// @dev singleTransferERC20 sends tokens from contract.\n    /// @param _destToken The address of target token.\n    /// @param _to The address of recipient.\n    /// @param _amount The amount of tokens.\n    /// @param _totalSwapped The amount of swap.\n    /// @param _rewardsAmount The fees that should be paid.\n    /// @param _redeemedFloatTxIds The txids which is for recording.\n    function singleTransferERC20(\n        address _destToken,\n        address _to,\n        uint256 _amount,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"14\"); //_destToken is not whitelisted\n        require(\n            _destToken != address(0),\n            \"15\" //_destToken should not be address(0)\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            sw.pullRewards(_destToken, _to, _totalSwapped);\n            _swap(address(0), BTCT_ADDR, _totalSwapped);\n        } else {\n            _feesToken = (_destToken == address(lpToken)) ? address(lpToken) : BTCT_ADDR;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        _safeTransfer(_destToken, _to, _amount);\n        return true;\n    }\n\n    /// @dev multiTransferERC20TightlyPacked sends tokens from contract.\n    /// @param _destToken The address of target token.\n    /// @param _addressesAndAmounts The address of recipient and amount.\n    /// @param _totalSwapped The amount of swap.\n    /// @param _rewardsAmount The fees that should be paid.\n    /// @param _redeemedFloatTxIds The txids which is for recording.\n    function multiTransferERC20TightlyPacked(\n        address _destToken,\n        bytes32[] memory _addressesAndAmounts,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"_destToken is not whitelisted\");\n        require(\n            _destToken != address(0),\n            \"_destToken should not be address(0)\"\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            _swap(address(0), BTCT_ADDR, _totalSwapped);\n        } else {\n            _feesToken = (_destToken == address(lpToken)) ? address(lpToken) : BTCT_ADDR;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        for (uint256 i = 0; i < _addressesAndAmounts.length; i++) {\n            _safeTransfer(\n                _destToken,\n                address(uint160(uint256(_addressesAndAmounts[i]))),\n                uint256(uint96(bytes12(_addressesAndAmounts[i])))\n            );\n        }\n        return true;\n    }\n\n    \n\n    /// @dev collectSwapFeesForBTC collects fees in the case of swap BTCT to BTC.\n    /// @param _incomingAmount The spent amount. (BTCT)\n    /// @param _minerFee The miner fees of BTC transaction.\n    /// @param _rewardsAmount The fees that should be paid.\n    function collectSwapFeesForBTC(\n        uint256 _incomingAmount,\n        uint256 _minerFee,\n        uint256 _rewardsAmount,\n        address[] memory _spenders,\n        uint256[] memory _swapAmounts,\n        bool _isUpdatelimitBTCForSPFlow2\n    ) external override onlyOwner returns (bool) {\n        address _feesToken = BTCT_ADDR;\n        if (_incomingAmount > 0) {\n            uint256 swapAmount = _incomingAmount.sub(_rewardsAmount);\n            sw.pullRewardsMulti(address(0), _spenders, _swapAmounts);\n            _swap(BTCT_ADDR, address(0), swapAmount);\n        } else if (_incomingAmount == 0) {\n            _feesToken = address(0);\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        if (_isUpdatelimitBTCForSPFlow2) {\n            _updateLimitBTCForSPFlow2();\n        }\n        return true;\n    }\n\n    /**\n     * Float part\n     */\n    /// @dev recordIncomingFloat mints LP token.\n    /// @param _token The address of target token.\n    /// @param _addressesAndAmountOfFloat The address of recipient and amount.\n    /// @param _txid The txids which is for recording.\n    function recordIncomingFloat(\n        address _token,\n        bytes32 _addressesAndAmountOfFloat,\n        bytes32 _txid\n    ) external override onlyOwner priceCheck returns (bool) {\n        require(whitelist[_token], \"16\"); //_token is invalid\n        require(\n            _issueLPTokensForFloat(_token, _addressesAndAmountOfFloat, _txid)\n        );\n        return true;\n    }\n\n    /// @dev recordOutcomingFloat burns LP token.\n    /// @param _token The address of target token.\n    /// @param _addressesAndAmountOfLPtoken The address of recipient and amount.\n    /// @param _minerFee The miner fees of BTC transaction.\n    /// @param _txid The txid which is for recording.\n    function recordOutcomingFloat(\n        address _token,\n        bytes32 _addressesAndAmountOfLPtoken,\n        uint256 _minerFee,\n        bytes32 _txid\n    ) external override onlyOwner priceCheck returns (bool) {\n        require(whitelist[_token], \"16\"); //_token is invalid\n        require(\n            _burnLPTokensForFloat(\n                _token,\n                _addressesAndAmountOfLPtoken,\n                _minerFee,\n                _txid\n            )\n        );\n        return true;\n    }\n\n    /**\n     * Skypools part\n     */\n    /// @dev Record SkyPools TX - allocate tokens from float to user in tokens[][]\n    /// @param _to The address of recipient.\n    /// @param _totalSwapped The amount of swap amount.\n    /// @param _rewardsAmount The fees that should be paid.\n    /// @param _usedTxIds The txids which is for recording.\n    function recordSkyPoolsTX(\n        address _to,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _usedTxIds\n    ) external onlyOwner returns (bool) {\n        require(_totalSwapped != 0);\n        require(_rewardsAmount != 0);\n\n        _swap(address(0), BTCT_ADDR, _totalSwapped);\n\n        tokens[BTCT_ADDR][_to] = tokens[BTCT_ADDR][_to].add(_totalSwapped);\n\n        _rewardsCollection(address(0), _rewardsAmount);\n\n        _addUsedTxs(_usedTxIds);\n\n        return true;\n    }\n\n    /// @dev multiRecordSkyPoolsTX - allocate tokens from float to user in tokens[][] in batches\n    /// @param _addressesAndAmounts The address of recipientand amount.\n    /// @param _totalSwapped The amount of swap amount.\n    /// @param _rewardsAmount The fees that should be paid.\n    /// @param _usedTxIds The txids which is for recording.\n    function multiRecordSkyPoolsTX(\n        bytes32[] memory _addressesAndAmounts,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _usedTxIds\n    ) external onlyOwner returns (bool) {\n        require(_totalSwapped != 0);\n        require(_rewardsAmount != 0);\n\n        _swap(address(0), BTCT_ADDR, _totalSwapped);\n\n        _rewardsCollection(address(0), _rewardsAmount);\n\n        _addUsedTxs(_usedTxIds);\n\n        for (uint256 i = 0; i < _addressesAndAmounts.length; i++) {\n            tokens[BTCT_ADDR][\n                address(uint160(uint256(_addressesAndAmounts[i])))\n            ] = tokens[BTCT_ADDR][\n                address(uint160(uint256(_addressesAndAmounts[i])))\n            ].add(uint256(uint96(bytes12(_addressesAndAmounts[i]))));\n        }\n\n        return true;\n    }\n\n    /// @dev spFlow1SimpleSwap - FLOW 1 - execute paraswap TX using simpleSwap, ending tokens sent DIRECTLY to user's wallet\n    /// @param _data A struct containing the data for simpleSwap, from the paraswap Utils lib.\n    function spFlow1SimpleSwap(Utils.SimpleData calldata _data)\n        external\n        nonReentrant\n    {\n        require(_data.beneficiary == msg.sender, \"beneficiary != msg.sender\");\n\n        require(\n            tokens[_data.fromToken][_data.beneficiary] >= _data.fromAmount,\n            \"Balance insufficient\"\n        );\n        require(\n            _data.fromToken == BTCT_ADDR,\n            \"fromToken != BTCT_ADDR\"\n        );\n\n        tokens[_data.fromToken][_data.beneficiary] = tokens[_data.fromToken][\n            _data.beneficiary\n        ].sub(_data.fromAmount);\n        \n        _doSimpleSwap(_data); //no received amount, tokens to go user's wallet\n    }\n\n    /// @dev spFlow1Uniswap - FLOW 1 - execute paraswap TX using uniswap, ending tokens sent to users allocation in tokens[][] mapping\n    /// @param _fork - BOOL to determine if using swapOnUniswap or swapOnUniswapFork paraswap contract methods\n    /// @param _factory - param for swapOnUniswapFork\n    /// @param _initCode - param for swapOnUniswapFork\n    /// @param _amountIn - param for swapOnUniswapFork or swapOnUniswap\n    /// @param _amountOutMin - param for swapOnUniswapFork or swapOnUniswap\n    /// @param _path - param for swapOnUniswapFork or swapOnUniswap\n    function spFlow1Uniswap(\n        bool _fork,\n        address _factory,\n        bytes32 _initCode,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) external nonReentrant returns (uint256 receivedAmount) {\n        address fromToken = _path[0];\n        address endToken = _path[_path.length - 1];\n\n        require(\n            tokens[fromToken][msg.sender] >= _amountIn,\n            \"Balance insufficient\"\n        );\n        require(fromToken == BTCT_ADDR, \"fromToken != BTCT_ADDR\");\n        require(endToken != ETHER, \"Use path wBTC -> wETH\");\n\n        uint256 preSwapBalance = IERC20(endToken).balanceOf(address(this));\n\n        tokens[fromToken][msg.sender] = tokens[fromToken][msg.sender].sub(\n            _amountIn\n        );\n\n        //do swap\n        if (_fork) {\n            _doUniswapFork(\n                _factory,\n                _initCode,\n                _amountIn,\n                _amountOutMin,\n                _path\n            );\n        } else {\n            _doUniswap(_amountIn, _amountOutMin, _path);\n        }\n\n        receivedAmount = IERC20(endToken).balanceOf(address(this)).sub(\n            preSwapBalance\n        );\n\n        require(\n            receivedAmount >= _amountOutMin,\n            \"Received < minimum\"\n        );\n\n        tokens[endToken][msg.sender] = tokens[endToken][msg.sender].add(\n            receivedAmount\n        );\n\n        return receivedAmount;\n    }\n\n    /// @dev spFlow2Uniswap - FLOW 1 - execute paraswap TX using uniswap, ending tokens sent to users allocation in tokens[][] mapping\n    /// @param _fork - BOOL to determine if using swapOnUniswap or swapOnUniswapFork paraswap contract methods\n    /// @param _factory - param for swapOnUniswapFork\n    /// @param _initCode - param for swapOnUniswapFork\n    /// @param _amountIn - param for swapOnUniswapFork or swapOnUniswap\n    /// @param _amountOutMin - param for swapOnUniswapFork or swapOnUniswap\n    /// @param _path - param for swapOnUniswapFork or swapOnUniswap\n    function spFlow2Uniswap(\n        string calldata _destinationAddressForBTC,\n        bool _fork,\n        address _factory,\n        bytes32 _initCode,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) external nonReentrant returns (uint256 receivedAmount) {\n        address fromToken = _path[0];\n        address endToken = _path[_path.length - 1];\n\n        require(\n            tokens[fromToken][msg.sender] >= _amountIn,\n            \"Balance insufficient\"\n        );\n        require(fromToken != ETHER, \"Use path wETH -> wBTC\");\n        require(endToken == BTCT_ADDR, \"swap => BTCT\");\n\n        uint256 preSwapBalance = IERC20(endToken).balanceOf(address(this));\n\n        tokens[fromToken][msg.sender] = tokens[fromToken][msg.sender].sub(\n            _amountIn\n        );\n\n        //do swap\n        if (_fork) {\n            _doUniswapFork(\n                _factory,\n                _initCode,\n                _amountIn,\n                _amountOutMin,\n                _path\n            );\n        } else {\n            _doUniswap(_amountIn, _amountOutMin, _path);\n        }\n\n        receivedAmount = IERC20(endToken).balanceOf(address(this)).sub(\n            preSwapBalance\n        );\n\n        require(\n            receivedAmount >= _amountOutMin,\n            \"Received < minimum\"\n        );\n        require(\n            receivedAmount >= ip.minimumSwapAmountForWBTC(),\n            \"receivedAmount < minimumSwapAmountForWBTC\"\n        );\n\n        _spRecordPendingTx(_destinationAddressForBTC, receivedAmount);\n\n        return receivedAmount;\n    }\n\n    /// @dev spParaSwapToken2BTC - FLOW 2 -> swap ERC20 -> wBTC\n    /// @param _destinationAddressForBTC The BTC address to send BTC to.\n    /// @param _data simpleData from paraswap API call, param for simpleSwap\n    function spFlow2SimpleSwap(\n        string calldata _destinationAddressForBTC,\n        Utils.SimpleData calldata _data\n    ) external nonReentrant returns (uint256 receivedAmount) {\n        //bytes32 destBytes32 = _stringToBytes32(destinationAddressForBTC);\n        //console.log(\"Converted to bytes32 and back to String:\",_bytes32ToString(destBytes32));\n\n        require(_data.fromToken != BTCT_ADDR, \"Must not swap from BTC token\");\n        require(_data.toToken == BTCT_ADDR, \"Must swap to BTC token\");\n        require(\n            _data.beneficiary == address(this),\n            \"beneficiary != swap contract\"\n        );\n        require(\n            tokens[_data.fromToken][msg.sender] >= _data.fromAmount,\n            \"Balance insufficient\"\n        );\n\n        uint256 preSwapBalance = IERC20(_data.toToken).balanceOf(address(this));\n\n        tokens[_data.fromToken][msg.sender] = tokens[_data.fromToken][\n            msg.sender\n        ].sub(_data.fromAmount);\n\n        _doSimpleSwap(_data);\n\n        receivedAmount = IERC20(_data.toToken).balanceOf(address(this)).sub(\n            preSwapBalance\n        );\n\n        require(\n            receivedAmount >= _data.expectedAmount,\n            \"Received amount insufficient\"\n        );\n        require(\n            receivedAmount >= ip.minimumSwapAmountForWBTC(),\n            \"receivedAmount < minimumSwapAmountForWBTC\"\n        );\n\n        _spRecordPendingTx(_destinationAddressForBTC, receivedAmount);\n\n        return receivedAmount;\n    }\n\n    /// @dev _doUniswapFork - performs paraswap transaction - BALANCE & TOKEN CHECKS MUST OCCUR BEFORE CALLING THIS\n    /// @param _factory - param for swapOnUniswapFork\n    /// @param _initCode - param for swapOnUniswapFork\n    /// @param _amountIn - param for swapOnUniswapFork\n    /// @param _amountOutMin - param for swapOnUniswapFork\n    /// @param _path - param for swapOnUniswapFork\n    function _doUniswapFork(\n        address _factory,\n        bytes32 _initCode,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) internal {\n        //address fromToken = _path[0];\n\n        //address proxy = IAugustusSwapper(paraswapAddress).getTokenTransferProxy();\n\n        IERC20(_path[0]).safeIncreaseAllowance(\n            IAugustusSwapper(paraswapAddress).getTokenTransferProxy(),\n            _amountIn\n        );\n\n        IParaswap(paraswapAddress).swapOnUniswapFork(\n            _factory,\n            _initCode,\n            _amountIn,\n            _amountOutMin,\n            _path\n        );\n    }\n\n    /// @dev _doUniswap - performs paraswap transaction - BALANCE & TOKEN CHECKS MUST OCCUR BEFORE CALLING THIS\n    /// @param _amountIn - param for swapOnUniswap\n    /// @param _amountOutMin - param for swapOnUniswap\n    /// @param _path - param for swapOnUniswap\n    function _doUniswap(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) internal {\n        //address fromToken = _path[0];\n\n        //address proxy = IAugustusSwapper(paraswapAddress).getTokenTransferProxy();\n\n        IERC20(_path[0]).safeIncreaseAllowance(\n            IAugustusSwapper(paraswapAddress).getTokenTransferProxy(), \n            _amountIn\n        );\n\n        IParaswap(paraswapAddress).swapOnUniswap(\n            _amountIn,\n            _amountOutMin,\n            _path\n        );\n    }\n\n    /// @dev _doSimpleSwap - performs paraswap transaction - BALANCE & TOKEN CHECKS MUST OCCUR BEFORE CALLING THIS\n    /// @param _data data from API call that is ready to be sent to paraswap interface\n    function _doSimpleSwap(Utils.SimpleData calldata _data) internal {\n        //address proxy = IAugustusSwapper(paraswapAddress).getTokenTransferProxy();\n\n        IERC20(_data.fromToken).safeIncreaseAllowance(\n            IAugustusSwapper(paraswapAddress).getTokenTransferProxy(), \n            _data.fromAmount\n        );\n\n        IParaswap(paraswapAddress).simpleSwap(_data);\n    }\n\n    /// @dev _spRecordPendingTx - hash a unique swap ID, and add it to the array of pending TXs, and then emit event\n    /// @param _destinationAddressForBTC The BTC address to send BTC to.\n    /// @param _btctAmount amount in BTC decimal 8.\n    function _spRecordPendingTx(\n        string calldata _destinationAddressForBTC,\n        uint256 _btctAmount\n    ) internal {\n        //hash TX data for unique ID\n        bytes32 ID = keccak256(\n            abi.encodePacked(\n                BTCT_ADDR, //specific to current chain\n                swapCount,\n                _destinationAddressForBTC,\n                _btctAmount,\n                block.timestamp\n            )\n        );\n\n        spPendingTXs[swapCount] = spPendingTx(\n            ID,\n            _destinationAddressForBTC,\n            msg.sender,\n            _btctAmount,\n            block.timestamp\n        );\n\n        //clean up expired TXs\n        spCleanUpOldTXs();\n\n        swapCount = swapCount.add(1); //increment TX count after cleaning up pending TXs to not loop over next empty index\n\n        _reduceLimitBTCForSPFlow2(_btctAmount);\n\n        emit SwapTokensToBTC(\n            ID,\n            _destinationAddressForBTC,\n            msg.sender,\n            _btctAmount,\n            block.timestamp\n        );\n    }\n\n    /// @dev _spCleanUpOldTXs - call when executing flow 2 swaps, cleans up expired TXs and moves the indices\n    function spCleanUpOldTXs() public {\n        uint256 max = oldestActiveIndex.add(ip.loopCount());\n\n        if (max >= swapCount) {\n            max = swapCount;\n        }\n\n        uint256 current = block.timestamp;\n        for (uint256 i = oldestActiveIndex; i < max; i++) {\n            if (spPendingTXs[i].Timestamp.add(ip.expirationTime()) < current) {\n                delete spPendingTXs[i];\n                oldestActiveIndex = i.add(1);\n            }\n        }\n    }\n\n    /**\n    /// @dev spCleanUpOldTXs - call when executing flow 2 swaps, cleans up expired TXs and moves the indices\n    /// @param _loopCount - max times the loop will run\n    function spCleanUpOldTXs(uint256 _loopCount) external {\n        uint256 max = oldestActiveIndex.add(_loopCount);\n\n        if (max >= swapCount) {\n            max = swapCount;\n        }\n\n        uint256 current = block.timestamp;\n        for (uint256 i = oldestActiveIndex; i < max; i++) {\n            if (spPendingTXs[i].Timestamp.add(ip.expirationTime()) < current) {\n                delete spPendingTXs[i];\n                oldestActiveIndex = i.add(1);\n            }\n        }\n    }\n     */\n\n    /// @dev spDeposit - ERC-20 ONLY - users deposit ERC-20 tokens, balances to be stored in tokens[][]\n    /// @param _token The address of the ERC-20 token contract.\n    /// @param _amount amount to be deposited.\n    function spDeposit(address _token, uint256 _amount)\n        external\n        payable\n        nonReentrant\n    {\n        if (msg.value == 0) {\n            require(_token != ETHER);\n            require(_token != BTCT_ADDR);\n\n            uint256 initBalance = IERC20(_token).balanceOf(address(this));\n\n            IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n            uint256 received = IERC20(_token).balanceOf(address(this)).sub(initBalance);\n\n            tokens[_token][msg.sender] = tokens[_token][msg.sender].add(\n                received\n            );\n\n            emit Deposit(\n                _token,\n                msg.sender,\n                received,\n                tokens[_token][msg.sender],\n                block.timestamp\n            );\n        } else {\n            require(msg.value > 0);\n            //swap to wETH tokens - contract now holds wETH instead of ether\n            IWETH(wETH).deposit{value: msg.value}();\n\n            tokens[wETH][msg.sender] = tokens[wETH][msg.sender].add(msg.value);\n\n            emit Deposit(\n                ETHER,\n                msg.sender,\n                msg.value,\n                tokens[wETH][msg.sender],\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev redeemEther for skypools - swap wETH for ether and send to user's wallet\n    /// @param _amount amount to withdraw\n    function redeemEther(uint256 _amount) external nonReentrant {\n        require(tokens[wETH][msg.sender] >= _amount);\n        IWETH(wETH).withdraw(_amount);\n        tokens[wETH][msg.sender] = tokens[wETH][msg.sender].sub(_amount);\n        address payable sender = payable(msg.sender);\n\n        (\n            bool success, /*bytes memory data*/\n\n        ) = sender.call{value: _amount}(\"\");\n\n        require(success, \"receiver rejected ETH transfer\");\n        emit Withdraw(\n            ETHER,\n            msg.sender,\n            _amount,\n            tokens[wETH][msg.sender],\n            block.timestamp\n        );\n    }\n\n    receive() external payable {\n        assert(msg.sender == wETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    /// @dev redeemERC20Token for skypools - redeem erc20 token\n    /// @param _token The address of target token.\n    /// @param _amount The amount to withdraw - call with BTC decimals (8) for BTC\n    function redeemERC20Token(address _token, uint256 _amount)\n        external\n        nonReentrant\n    {\n        require(tokens[_token][msg.sender] >= _amount, \"Insufficient Balance\");\n        tokens[_token][msg.sender] = tokens[_token][msg.sender].sub(_amount);\n        _safeTransfer(_token, msg.sender, _amount);\n\n        emit Withdraw(\n            _token,\n            msg.sender,\n            _amount,\n            tokens[_token][msg.sender],\n            block.timestamp\n        );\n    }\n\n    /**\n     * Life cycle part\n     */\n\n    /// @dev recordUTXOSweepMinerFee reduces float amount by collected miner fees.\n    /// @param _minerFee The miner fees of BTC transaction.\n    /// @param _txid The txid which is for recording.\n    function recordUTXOSweepMinerFee(uint256 _minerFee, bytes32 _txid)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(!isTxUsed(_txid), \"The txid is already used\");\n        floatAmountOf[address(0)] = floatAmountOf[address(0)].sub(\n            _minerFee,\n            \"12\" //\"BTC float amount insufficient\"\n        );\n        _addUsedTx(_txid);\n        return true;\n    }\n\n    /// @dev churn transfers contract ownership and set variables of the next TSS validator set.\n    /// @param _newOwner The address of new Owner.\n    /// @param _nodes The reward addresses.\n    /// @param _isRemoved The flags to remove node.\n    /// @param _churnedInCount The number of next party size of TSS group.\n    /// @param _tssThreshold The number of next threshold.\n    function churn(\n        address _newOwner,\n        address[] memory _nodes,\n        bool[] memory _isRemoved,\n        uint8 _churnedInCount,\n        uint8 _tssThreshold\n    ) external override onlyOwner returns (bool) {\n        require(\n            _tssThreshold >= tssThreshold && _tssThreshold <= 2**8 - 1,\n            \"01\" //\"_tssThreshold should be >= tssThreshold\"\n        );\n        require(\n            _churnedInCount >= _tssThreshold + uint8(1),\n            \"02\" //\"n should be >= t+1\"\n        );\n        require(\n            _nodes.length == _isRemoved.length,\n            \"05\" //\"_nodes and _isRemoved length is not match\"\n        );\n\n        transferOwnership(_newOwner);\n        // Update active node list\n        for (uint256 i = 0; i < _nodes.length; i++) {\n            if (!_isRemoved[i]) {\n                if (nodes[_nodes[i]] == uint8(0)) {\n                    nodeAddrs.push(_nodes[i]);\n                }\n                if (nodes[_nodes[i]] != uint8(1)) {\n                    activeNodeCount++;\n                }\n                nodes[_nodes[i]] = uint8(1);\n            } else {\n                activeNodeCount--;\n                nodes[_nodes[i]] = uint8(2);\n            }\n        }\n        require(activeNodeCount <= 100, \"Stored node size should be <= 100\");\n        churnedInCount = _churnedInCount;\n        tssThreshold = _tssThreshold;\n        return true;\n    }\n\n    /// @dev balanceOf - return user balance for given token and user for skypools\n    /// @param _token The address of target token.\n    /// @param _user The address of target user.\n    function balanceOf(address _token, address _user)\n        public\n        view\n        returns (uint256)\n    {\n        return tokens[_token][_user];\n    }\n\n    /// @dev spGetPendingSwaps - returns array of pending swaps\n    /// @return data - returns array of pending swap struct objects\n    function spGetPendingSwaps()\n        external\n        view\n        returns (spPendingTx[] memory data)\n    {\n        //require(swapCount != 0);\n\n        uint256 index = 0;\n        data = new spPendingTx[](swapCount.sub(oldestActiveIndex));\n\n        for (uint256 i = oldestActiveIndex.add(1); i <= swapCount; i++) {\n            data[index] = spPendingTXs[index.add(oldestActiveIndex)];\n            index = index.add(1);\n        }\n\n        return data;\n    }\n\n    /// @dev isTxUsed sends rewards for Nodes.\n    /// @param _txid The txid which is for recording.\n    function isTxUsed(bytes32 _txid) public view override returns (bool) {\n        return used[_txid];\n    }\n\n    /// @dev getCurrentPriceLP returns the current exchange rate of LP token.\n    function getCurrentPriceLP()\n        public\n        view\n        override\n        returns (uint256 nowPrice)\n    {\n        (uint256 reserveA, uint256 reserveB) = getFloatReserve(\n            address(0),\n            BTCT_ADDR\n        );\n        uint256 totalLPs = lpToken.totalSupply();\n        // decimals of totalReserved == 8, lpDivisor == 8, decimals of rate == 8\n        nowPrice = totalLPs == 0\n            ? lpDivisor\n            : (reserveA.add(reserveB)).mul(lpDivisor).div(totalLPs);\n        return nowPrice;\n    }\n\n    /// @dev getFloatReserve returns float reserves\n    /// @param _tokenA The address of target tokenA.\n    /// @param _tokenB The address of target tokenB.\n    function getFloatReserve(address _tokenA, address _tokenB)\n        public\n        view\n        override\n        returns (uint256 reserveA, uint256 reserveB)\n    {\n        (reserveA, reserveB) = (floatAmountOf[_tokenA], floatAmountOf[_tokenB]);\n    }\n\n    /// @dev getActiveNodes returns active nodes list\n    function getActiveNodes() public view override returns (address[] memory) {\n        uint256 count = 0;\n        address[] memory _nodes = new address[](activeNodeCount);\n        for (uint256 i = 0; i < nodeAddrs.length; i++) {\n            if (nodes[nodeAddrs[i]] == uint8(1)) {\n                _nodes[count] = nodeAddrs[i];\n                count++;\n            }\n        }\n        return _nodes;\n    }\n\n    /// @dev isNodeSake returns true if the node is churned in\n    function isNodeStake(address _user) public view override returns (bool) {\n        if (nodes[_user] == uint8(1)) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @dev _issueLPTokensForFloat\n    /// @param _token The address of target token.\n    /// @param _transaction The recevier address and amount.\n    /// @param _txid The txid which is for recording.\n    function _issueLPTokensForFloat(\n        address _token,\n        bytes32 _transaction,\n        bytes32 _txid\n    ) internal returns (bool) {\n        require(!isTxUsed(_txid), \"06\"); //\"The txid is already used\");\n        require(_transaction != 0x0, \"07\"); //\"The transaction is not valid\");\n        // Define target address which is recorded on the tx data (20 bytes)\n        // Define amountOfFloat which is recorded top on tx data (12 bytes)\n        (address to, uint256 amountOfFloat) = _splitToValues(_transaction);\n        // Calculate the amount of LP token\n        uint256 nowPrice = getCurrentPriceLP();\n        uint256 amountOfLP = amountOfFloat.mul(lpDivisor).div(nowPrice);\n        // Send LP tokens to LP\n        lpToken.mint(to, amountOfLP);\n        // Add float amount\n        _addFloat(_token, amountOfFloat);\n        _addUsedTx(_txid);\n\n        emit IssueLPTokensForFloat(\n            to,\n            amountOfFloat,\n            amountOfLP,\n            nowPrice,\n            ip.depositFeesBPS(),\n            _txid\n        );\n        return true;\n    }\n\n    /// @dev _burnLPTokensForFloat\n    /// @param _token The address of target token.\n    /// @param _transaction The address of sender and amount.\n    /// @param _minerFee The miner fees of BTC transaction.\n    /// @param _txid The txid which is for recording.\n    function _burnLPTokensForFloat(\n        address _token,\n        bytes32 _transaction,\n        uint256 _minerFee,\n        bytes32 _txid\n    ) internal returns (bool) {\n        require(!isTxUsed(_txid), \"06\"); //\"The txid is already used\");\n        require(_transaction != 0x0, \"07\"); //\"The transaction is not valid\");\n        // Define target address which is recorded on the tx data (20bytes)\n        // Define amountLP which is recorded top on tx data (12bytes)\n        (address to, uint256 amountOfLP) = _splitToValues(_transaction);\n        // Calculate the amount of LP token\n        uint256 nowPrice = getCurrentPriceLP();\n        // Calculate the amountOfFloat\n        uint256 amountOfFloat = amountOfLP.mul(nowPrice).div(lpDivisor);\n        uint256 withdrawalFees = amountOfFloat.mul(ip.withdrawalFeeBPS()).div(\n            10000\n        );\n        require(\n            amountOfFloat.sub(withdrawalFees) >= _minerFee,\n            \"09\" //\"Error: amountOfFloat.sub(withdrawalFees) < _minerFee\"\n        );\n        uint256 withdrawal = amountOfFloat.sub(withdrawalFees).sub(_minerFee);\n        (uint256 reserveA, uint256 reserveB) = getFloatReserve(\n            address(0),\n            BTCT_ADDR\n        );\n        if (_token == address(0)) {\n            require(\n                reserveA >= amountOfFloat.sub(withdrawalFees),\n                \"08\" //\"The float balance insufficient.\"\n            );\n        } else if (_token == BTCT_ADDR) {\n            require(\n                reserveB >= amountOfFloat.sub(withdrawalFees),\n                \"12\" //\"BTC float amount insufficient\"\n            );\n        }\n        // Collect fees before remove float\n        _rewardsCollection(_token, withdrawalFees);\n        // Remove float amount\n        _removeFloat(_token, amountOfFloat);\n        // Add txid for recording.\n        _addUsedTx(_txid);\n        // BTCT transfer if token address is BTCT_ADDR\n        if (_token == BTCT_ADDR) {\n            // _minerFee should be zero\n            _safeTransfer(_token, to, withdrawal);\n        }\n        // Burn LP tokens\n        require(lpToken.burn(amountOfLP));\n        emit BurnLPTokensForFloat(\n            to,\n            amountOfLP,\n            amountOfFloat,\n            nowPrice,\n            withdrawal,\n            _txid\n        );\n        return true;\n    }\n\n    /// @dev _addFloat updates one side of the float.\n    /// @param _token The address of target token.\n    /// @param _amount The amount of float.\n    function _addFloat(address _token, uint256 _amount) internal {\n        floatAmountOf[_token] = floatAmountOf[_token].add(_amount);\n    }\n\n    /// @dev _removeFloat remove one side of the float - redone for skypools using tokens mapping\n    /// @param _token The address of target token.\n    /// @param _amount The amount of float.\n    function _removeFloat(address _token, uint256 _amount) internal {\n        floatAmountOf[_token] = floatAmountOf[_token].sub(\n            _amount,\n            \"10\" //\"_removeFloat: float amount insufficient\"\n        );\n    }\n\n    /// @dev _swap collects swap amount to change float.\n    /// @param _sourceToken The address of source token\n    /// @param _destToken The address of target token.\n    /// @param _swapAmount The amount of swap.\n    function _swap(\n        address _sourceToken,\n        address _destToken,\n        uint256 _swapAmount\n    ) internal {\n        floatAmountOf[_destToken] = floatAmountOf[_destToken].sub(\n            _swapAmount,\n            \"11\" //\"_swap: float amount insufficient\"\n        );\n        floatAmountOf[_sourceToken] = floatAmountOf[_sourceToken].add(\n            _swapAmount\n        );\n\n        emit Swap(_sourceToken, _destToken, _swapAmount);\n    }\n\n    /// @dev _safeTransfer executes tranfer erc20 tokens\n    /// @param _token The address of target token\n    /// @param _to The address of receiver.\n    /// @param _amount The amount of transfer.\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_token == BTCT_ADDR) {\n            _amount = _amount.mul(convertScale);\n        }\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /// @dev _rewardsCollection collects tx rewards.\n    /// @param _feesToken The token address for collection fees.\n    /// @param _rewardsAmount The amount of rewards.\n    function _rewardsCollection(address _feesToken, uint256 _rewardsAmount)\n        internal\n    {\n        if (_rewardsAmount == 0) return;\n        // if (_feesToken == lpToken) {\n        //     IBurnableToken(lpToken).transfer(sbBTCPool, _rewardsAmount);\n        //     emit RewardsCollection(_feesToken, 0, _rewardsAmount, 0);\n        //     return;\n        // }\n\n        // Get current LP token price.\n        uint256 nowPrice = getCurrentPriceLP();\n        // Add all fees into pool\n        floatAmountOf[_feesToken] = floatAmountOf[_feesToken].add(\n            _rewardsAmount\n        );\n        uint256 amountForNodes = _rewardsAmount.mul(ip.nodeRewardsRatio()).div(\n            100\n        );\n        // Alloc LP tokens for nodes as fees\n        uint256 amountLPTokensForNode = amountForNodes.mul(lpDivisor).div(\n            nowPrice\n        );\n        // Mints LP tokens for Nodes\n        lpToken.mint(sbBTCPool, amountLPTokensForNode);\n\n        emit RewardsCollection(\n            _feesToken,\n            _rewardsAmount,\n            amountLPTokensForNode,\n            nowPrice\n        );\n    }\n\n    /// @dev _addUsedTx updates txid list which is spent. (single hash)\n    /// @param _txid The array of txid.\n    function _addUsedTx(bytes32 _txid) internal {\n        used[_txid] = true;\n    }\n\n    /// @dev _updateLimitBTCForSPFlow2 udpates limitBTCForSPFlow2\n    function _updateLimitBTCForSPFlow2() internal {\n        // Update limitBTCForSPFlow2 by adding BTC floats\n        limitBTCForSPFlow2 = floatAmountOf[address(0)];\n    }\n\n    /// @dev _reduceLimitBTCForSPFlow2 reduces limitBTCForSPFlow2 when new sp flow2 txs are coming.\n    /// @param _amount The amount of BTCT, (use BTCT amount insatead of BTC amount for enough. always BTCT > BTC)\n    function _reduceLimitBTCForSPFlow2(uint256 _amount) internal {\n        if (limitBTCForSPFlow2 == 0) {\n            // initialize when initial Flow2 tx has been called.\n            _updateLimitBTCForSPFlow2();\n        }\n        limitBTCForSPFlow2 = limitBTCForSPFlow2.sub(\n            _amount,\n            \"12\" //\"BTC float amount insufficient\"\n        );\n    }\n\n    /// @dev _addUsedTxs updates txid list which is spent. (multiple hashes)\n    /// @param _txids The array of txid.\n    function _addUsedTxs(bytes32[] memory _txids) internal {\n        for (uint256 i = 0; i < _txids.length; i++) {\n            used[_txids[i]] = true;\n        }\n    }\n\n    /// @dev _splitToValues returns address and amount of staked SWINGBYs\n    /// @param _data The info of a staker.\n    function _splitToValues(bytes32 _data)\n        internal\n        pure\n        returns (address, uint256)\n    {\n        return (\n            address(uint160(uint256(_data))),\n            uint256(uint96(bytes12(_data)))\n        );\n    }\n}\n"
6     },
7     "contracts/interfaces/IWETH.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
9     },
10     "contracts/interfaces/IBurnableToken.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IBurnableToken is IERC20 {\n    function mint(address target, uint256 amount) external returns (bool);\n\n    function burn(uint256 amount) external returns (bool);\n\n    function mintable() external returns (bool);\n}\n"
12     },
13     "contracts/interfaces/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner. (This is a BEP-20 token specific.)\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
15     },
16     "contracts/interfaces/ISwapContract.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/Utils.sol\";\n\ninterface ISwapContract {\n    \n    function BTCT_ADDR() external returns (address);\n\n    function singleTransferERC20(\n        address _destToken,\n        address _to,\n        uint256 _amount,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external returns (bool);\n\n    function multiTransferERC20TightlyPacked(\n        address _destToken,\n        bytes32[] memory _addressesAndAmounts,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external returns (bool);\n\n    function collectSwapFeesForBTC(\n        uint256 _incomingAmount,\n        uint256 _minerFee,\n        uint256 _rewardsAmount,\n        address[] memory _spenders,\n        uint256[] memory _swapAmounts,\n        bool    _isUpdatelimitBTCForSPFlow2\n    ) external returns (bool);\n\n    function recordIncomingFloat(\n        address _token,\n        bytes32 _addressesAndAmountOfFloat,\n        bytes32 _txid\n    ) external returns (bool);\n\n    function recordOutcomingFloat(\n        address _token,\n        bytes32 _addressesAndAmountOfLPtoken,\n        uint256 _minerFee,\n        bytes32 _txid\n    ) external returns (bool);\n\n    function recordSkyPoolsTX(\n        address _to,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _usedTxIds\n    ) external returns (bool);\n\n    function spFlow1SimpleSwap(Utils.SimpleData calldata _data) external;\n\n    function spFlow1Uniswap(\n        bool _fork,\n        address _factory,\n        bytes32 _initCode,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) external returns (uint256 receivedAmount);\n\n    function spFlow2Uniswap(\n        string memory _destinationAddressForBTC,\n        bool _fork,\n        address _factory,\n        bytes32 _initCode,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path\n    ) external returns (uint256 receivedAmount);\n\n    function spFlow2SimpleSwap(\n        string memory _destinationAddressForBTC,\n        Utils.SimpleData calldata _data\n    ) external returns (uint256 receivedAmount);\n\n    function spCleanUpOldTXs() external;\n\n    function spDeposit(address _token, uint256 _amount) external payable;\n\n    function redeemEther(uint256 _amount) external;\n\n    function redeemERC20Token(address _token, uint256 _amount) external;\n\n    function recordUTXOSweepMinerFee(uint256 _minerFee, bytes32 _txid)\n        external\n        returns (bool);\n\n    function churn(\n        address _newOwner,\n        address[] memory _nodes,\n        bool[] memory _isRemoved,\n        uint8 _churnedInCount,\n        uint8 _tssThreshold\n    ) external returns (bool);\n\n    function isTxUsed(bytes32 _txid) external view returns (bool);\n\n    function getCurrentPriceLP() external view returns (uint256);\n\n    function getFloatReserve(address _tokenA, address _tokenB)\n        external\n        returns (uint256 reserveA, uint256 reserveB);\n\n    function getActiveNodes() external view returns (address[] memory);\n\n    function isNodeStake(address _user) external returns (bool);\n}\n"
18     },
19     "contracts/interfaces/ISwapRewards.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\n\ninterface ISwapRewards {\n\n    function setSWINGBYPrice(uint256 _pricePerBTC) external;\n\n    function pullRewards(address _dest, address _receiver, uint256 _swapped) external returns (bool);\n\n    function pullRewardsMulti(address _dest, address[] memory _receiver, uint256[] memory _swapped) external returns (bool);\n}\n"
21     },
22     "contracts/interfaces/IParams.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IParams {\n\n    function minimumSwapAmountForWBTC() external view returns (uint256);\n    function expirationTime() external view returns (uint256);\n    function paraswapAddress() external view returns (address);\n    function nodeRewardsRatio() external view returns (uint8);\n    function depositFeesBPS() external view returns (uint8);\n    function withdrawalFeeBPS() external view returns (uint8);\n    function loopCount() external view returns (uint8);\n\n    function setMinimumSwapAmountForWBTC(uint256 _minimumSwapAmountForWBTC) external;\n\n    function setExpirationTime(uint256 _expirationTime) external;\n\n    function setParaswapAddress(address _paraswapAddress) external;\n\n    function setNodeRewardsRatio(uint8 _nodeRewardsRatio) external;\n\n    function setWithdrawalFeeBPS(uint8 _withdrawalFeeBPS) external;\n\n    function setDepositFeesBPS(uint8 _depositFeesBPS) external;\n\n    function setLoopCount(uint8 _loopCount) external;\n}   \n\n"
24     },
25     "contracts/interfaces/IAugustusSwapper.sol": {
26       "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.6.0 <=0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\ninterface IAugustusSwapper {\n\n    /**\n   * @param fromToken Address of the source token\n   * @param fromAmount Amount of source tokens to be swapped\n   * @param toAmount Minimum destination token amount expected out of this swap\n   * @param expectedAmount Expected amount of destination tokens without slippage\n   * @param beneficiary Beneficiary address\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\n   * @param referrer referral id\n   * @param useReduxToken whether to use redux token or not\n   * @param path Route to be taken for this swap to take place\n\n   */\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        string referrer;\n        bool useReduxToken;\n        Path[] path;\n\n    }\n\n    struct MegaSwapSellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        string referrer;\n        bool useReduxToken;\n        MegaSwapPath[] path;\n    }\n\n    struct BuyData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        address payable beneficiary;\n        string referrer;\n        bool useReduxToken;\n        BuyRoute[] route;\n    }\n\n    struct Route {\n        address payable exchange;\n        address targetExchange;\n        uint percent;\n        bytes payload;\n        uint256 networkFee;//Network fee is associated with 0xv3 trades\n    }\n\n    struct MegaSwapPath {\n        uint256 fromAmountPercent;\n        Path[] path;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee;//Network fee is associated with 0xv3 trades\n        Route[] routes;\n    }\n\n    struct BuyRoute {\n        address payable exchange;\n        address targetExchange;\n        uint256 fromAmount;\n        uint256 toAmount;\n        bytes payload;\n        uint256 networkFee;//Network fee is associated with 0xv3 trades\n    }\n\n    function getPartnerRegistry() external view returns(address);\n\n    function getWhitelistAddress() external view returns(address);\n\n    function getFeeWallet() external view returns(address);\n\n    function getTokenTransferProxy() external view returns (address);\n\n    function getUniswapProxy() external view returns(address);\n\n    function getVersion() external view returns(string memory);\n\n    /**\n   * @dev The function which performs the multi path swap.\n   */\n    function multiSwap(\n        SellData calldata data\n    )\n        external\n        payable\n        returns (uint256);\n\n    /**\n   * @dev The function which performs the single path buy.\n   */\n    function buy(\n        BuyData calldata data\n    )\n        external\n        payable\n        returns (uint256);\n\n    function swapOnUniswap(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint8 referrer\n    )\n        external\n        payable;\n\n    function buyOnUniswap(\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path,\n        uint8 referrer\n    )\n        external\n        payable;\n\n    function buyOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path,\n        uint8 referrer\n    )\n        external\n        payable;\n\n    function swapOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        uint8 referrer\n    )\n        external\n        payable;\n\n\n    function simplBuy(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address[] memory callees,\n        bytes memory exchangeData,\n        uint256[] memory startIndexes,\n        uint256[] memory values,\n        address payable beneficiary,\n        string memory referrer,\n        bool useReduxToken\n    )\n        external\n        payable;\n\n    function simpleSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 expectedAmount,\n        address[] memory callees,\n        bytes memory exchangeData,\n        uint256[] memory startIndexes,\n        uint256[] memory values,\n        address payable beneficiary,\n        string memory referrer,\n        bool useReduxToken\n    )\n        external\n        payable\n        returns (uint256 receivedAmount);\n\n    /**\n   * @dev The function which performs the mega path swap.\n   * @param data Data required to perform swap.\n   */\n    function megaSwap(\n        MegaSwapSellData memory data\n    )\n        external\n        payable\n        returns (uint256);\n}"
27     },
28     "contracts/interfaces/ITokenTransferProxy.sol": {
29       "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity >=0.6.0 <=0.8.9;\n\n\ninterface ITokenTransferProxy {\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        external;\n\n    function freeReduxTokens(address user, uint256 tokensToFree) external;\n}"
30     },
31     "contracts/interfaces/IParaswap.sol": {
32       "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity >=0.6.0 <=0.8.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./lib/Utils.sol\";\r\nimport \"./IERC20.sol\";\r\ninterface IParaswap {\r\n    function multiSwap(\r\n        Utils.SellData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function megaSwap(\r\n        Utils.MegaSwapSellData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function protectedMultiSwap(\r\n        Utils.SellData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function protectedMegaSwap(\r\n        Utils.MegaSwapSellData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256);\r\n\r\n    function protectedSimpleSwap(\r\n        Utils.SimpleData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 receivedAmount);\r\n\r\n    function protectedSimpleBuy(\r\n        Utils.SimpleData calldata data\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function simpleSwap(\r\n        Utils.SimpleData calldata data\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 receivedAmount);\r\n\r\n    function simpleBuy(\r\n        Utils.SimpleData calldata data\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function swapOnUniswap(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function swapOnUniswapFork(\r\n        address factory,\r\n        bytes32 initCode,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function buyOnUniswap(\r\n        uint256 amountInMax,\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function buyOnUniswapFork(\r\n        address factory,\r\n        bytes32 initCode,\r\n        uint256 amountInMax,\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function swapOnUniswapV2Fork(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address weth,\r\n        uint256[] calldata pools\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function buyOnUniswapV2Fork(\r\n        address tokenIn,\r\n        uint256 amountInMax,\r\n        uint256 amountOut,\r\n        address weth,\r\n        uint256[] calldata pools\r\n    )\r\n        external\r\n        payable;\r\n\r\n    function swapOnZeroXv2(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 fromAmount,\r\n        uint256 amountOutMin,\r\n        address exchange,\r\n        bytes calldata payload\r\n    )\r\n    external\r\n    payable;\r\n\r\n    function swapOnZeroXv4(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 fromAmount,\r\n        uint256 amountOutMin,\r\n        address exchange,\r\n        bytes calldata payload\r\n    )\r\n    external\r\n    payable;\r\n}"
33     },
34     "contracts/interfaces/lib/Utils.sol": {
35       "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity >=0.6.0 <=0.8.9;\r\n\r\nlibrary Utils {\r\n    /**\r\n   * @param fromToken Address of the source token\r\n   * @param fromAmount Amount of source tokens to be swapped\r\n   * @param toAmount Minimum destination token amount expected out of this swap\r\n   * @param expectedAmount Expected amount of destination tokens without slippage\r\n   * @param beneficiary Beneficiary address\r\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\r\n   * @param path Route to be taken for this swap to take place\r\n\r\n   */\r\n    struct SellData {\r\n        address fromToken;\r\n        uint256 fromAmount;\r\n        uint256 toAmount;\r\n        uint256 expectedAmount;\r\n        address payable beneficiary;\r\n        Utils.Path[] path;\r\n        address payable partner;\r\n        uint256 feePercent;\r\n        bytes permit;\r\n        uint256 deadline;\r\n        bytes16 uuid;\r\n    }\r\n\r\n    struct MegaSwapSellData {\r\n        address fromToken;\r\n        uint256 fromAmount;\r\n        uint256 toAmount;\r\n        uint256 expectedAmount;\r\n        address payable beneficiary;\r\n        Utils.MegaSwapPath[] path;\r\n        address payable partner;\r\n        uint256 feePercent;\r\n        bytes permit;\r\n        uint256 deadline;\r\n        bytes16 uuid;\r\n    }\r\n\r\n    struct SimpleData {\r\n        address fromToken;\r\n        address toToken;\r\n        uint256 fromAmount;\r\n        uint256 toAmount;\r\n        uint256 expectedAmount;\r\n        address[] callees;\r\n        bytes exchangeData;\r\n        uint256[] startIndexes;\r\n        uint256[] values;\r\n        address payable beneficiary;\r\n        address payable partner;\r\n        uint256 feePercent;\r\n        bytes permit;\r\n        uint256 deadline;\r\n        bytes16 uuid;\r\n    }\r\n\r\n    struct Adapter {\r\n        address payable adapter;\r\n        uint256 percent;\r\n        uint256 networkFee;\r\n        Route[] route;\r\n    }\r\n\r\n    struct Route {\r\n        uint256 index;//Adapter at which index needs to be used\r\n        address targetExchange;\r\n        uint percent;\r\n        bytes payload;\r\n        uint256 networkFee;//Network fee is associated with 0xv3 trades\r\n    }\r\n\r\n    struct MegaSwapPath {\r\n        uint256 fromAmountPercent;\r\n        Path[] path;\r\n    }\r\n\r\n    struct Path {\r\n        address to;\r\n        uint256 totalNetworkFee;//Network fee is associated with 0xv3 trades\r\n        Adapter[] adapters;\r\n    }\r\n}"
36     },
37     "@openzeppelin/contracts/access/Ownable.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
39     },
40     "contracts/interfaces/lib/SafeERC20.sol": {
41       "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity >=0.6.0 <=0.8.9;\n\nimport \"../IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    \n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
42     },
43     "@openzeppelin/contracts/utils/math/SafeMath.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
45     },
46     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
48     },
49     "@openzeppelin/contracts/utils/Context.sol": {
50       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
51     },
52     "contracts/interfaces/lib/Address.sol": {
53       "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity >=0.6.0 <=0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
54     }
55   },
56   "settings": {
57     "optimizer": {
58       "enabled": true,
59       "runs": 200
60     },
61     "outputSelection": {
62       "*": {
63         "*": [
64           "evm.bytecode",
65           "evm.deployedBytecode",
66           "devdoc",
67           "userdoc",
68           "metadata",
69           "abi"
70         ]
71       }
72     },
73     "libraries": {}
74   }
75 }}