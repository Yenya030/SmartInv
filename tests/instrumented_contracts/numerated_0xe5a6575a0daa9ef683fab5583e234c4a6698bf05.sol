1 // SPDX-License-Identifier: GPL-3.0
2 
3 /*
4       ::::::::   ::::::::  ::::    :::  ::::::::   ::::::::  :::        ::::::::::          ::::    ::: :::::::::: ::::::::::: 
5     :+:    :+: :+:    :+: :+:+:   :+: :+:    :+: :+:    :+: :+:        :+:                 :+:+:   :+: :+:            :+:      
6    +:+        +:+    +:+ :+:+:+  +:+ +:+        +:+    +:+ +:+        +:+                 :+:+:+  +:+ +:+            +:+       
7   +#+        +#+    +:+ +#+ +:+ +#+ +#++:++#++ +#+    +:+ +#+        +#++:++#            +#+ +:+ +#+ :#::+::#       +#+        
8  +#+        +#+    +#+ +#+  +#+#+#        +#+ +#+    +#+ +#+        +#+                 +#+  +#+#+# +#+            +#+         
9 #+#    #+# #+#    #+# #+#   #+#+# #+#    #+# #+#    #+# #+#        #+#                 #+#   #+#+# #+#            #+#          
10 ########   ########  ###    ####  ########   ########  ########## ##########          ###    #### ###            ###           
11 */
12 
13 pragma solidity ^0.8.0;
14 
15 /**
16  * @dev These functions deal with verification of Merkle Trees proofs.
17  *
18  * The proofs can be generated using the JavaScript library
19  * https://github.com/miguelmota/merkletreejs[merkletreejs].
20  * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
21  *
22  * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
23  */
24 library MerkleProof {
25     /**
26      * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
27      * defined by `root`. For this, a `proof` must be provided, containing
28      * sibling hashes on the branch from the leaf to the root of the tree. Each
29      * pair of leaves and each pair of pre-images are assumed to be sorted.
30      */
31     function verify(
32         bytes32[] memory proof,
33         bytes32 root,
34         bytes32 leaf
35     ) internal pure returns (bool) {
36         return processProof(proof, leaf) == root;
37     }
38 
39     /**
40      * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up
41      * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
42      * hash matches the root of the tree. When processing the proof, the pairs
43      * of leafs & pre-images are assumed to be sorted.
44      *
45      * _Available since v4.4._
46      */
47     function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
48         bytes32 computedHash = leaf;
49         for (uint256 i = 0; i < proof.length; i++) {
50             bytes32 proofElement = proof[i];
51             if (computedHash <= proofElement) {
52                 // Hash(current computed hash + current element of the proof)
53                 computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
54             } else {
55                 // Hash(current element of the proof + current computed hash)
56                 computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
57             }
58         }
59         return computedHash;
60     }
61 }
62 
63 contract VRFRequestIDBase {
64   /**
65    * @notice returns the seed which is actually input to the VRF coordinator
66    *
67    * @dev To prevent repetition of VRF output due to repetition of the
68    * @dev user-supplied seed, that seed is combined in a hash with the
69    * @dev user-specific nonce, and the address of the consuming contract. The
70    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
71    * @dev the final seed, but the nonce does protect against repetition in
72    * @dev requests which are included in a single block.
73    *
74    * @param _userSeed VRF seed input provided by user
75    * @param _requester Address of the requesting contract
76    * @param _nonce User-specific nonce at the time of the request
77    */
78   function makeVRFInputSeed(
79     bytes32 _keyHash,
80     uint256 _userSeed,
81     address _requester,
82     uint256 _nonce
83   ) internal pure returns (uint256) {
84     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
85   }
86 
87   /**
88    * @notice Returns the id for this request
89    * @param _keyHash The serviceAgreement ID to be used for this request
90    * @param _vRFInputSeed The seed to be passed directly to the VRF
91    * @return The id for this request
92    *
93    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
94    * @dev contract, but the one generated by makeVRFInputSeed
95    */
96   function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
97     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
98   }
99 }
100 
101 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
102 
103 interface LinkTokenInterface {
104   function allowance(address owner, address spender) external view returns (uint256 remaining);
105 
106   function approve(address spender, uint256 value) external returns (bool success);
107 
108   function balanceOf(address owner) external view returns (uint256 balance);
109 
110   function decimals() external view returns (uint8 decimalPlaces);
111 
112   function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
113 
114   function increaseApproval(address spender, uint256 subtractedValue) external;
115 
116   function name() external view returns (string memory tokenName);
117 
118   function symbol() external view returns (string memory tokenSymbol);
119 
120   function totalSupply() external view returns (uint256 totalTokensIssued);
121 
122   function transfer(address to, uint256 value) external returns (bool success);
123 
124   function transferAndCall(
125     address to,
126     uint256 value,
127     bytes calldata data
128   ) external returns (bool success);
129 
130   function transferFrom(
131     address from,
132     address to,
133     uint256 value
134   ) external returns (bool success);
135 }
136 
137 // File: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBase.sol
138 
139 
140 
141 /** ****************************************************************************
142  * @notice Interface for contracts using VRF randomness
143  * *****************************************************************************
144  * @dev PURPOSE
145  *
146  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
147  * @dev to Vera the verifier in such a way that Vera can be sure he's not
148  * @dev making his output up to suit himself. Reggie provides Vera a public key
149  * @dev to which he knows the secret key. Each time Vera provides a seed to
150  * @dev Reggie, he gives back a value which is computed completely
151  * @dev deterministically from the seed and the secret key.
152  *
153  * @dev Reggie provides a proof by which Vera can verify that the output was
154  * @dev correctly computed once Reggie tells it to her, but without that proof,
155  * @dev the output is indistinguishable to her from a uniform random sample
156  * @dev from the output space.
157  *
158  * @dev The purpose of this contract is to make it easy for unrelated contracts
159  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
160  * @dev simple access to a verifiable source of randomness.
161  * *****************************************************************************
162  * @dev USAGE
163  *
164  * @dev Calling contracts must inherit from VRFConsumerBase, and can
165  * @dev initialize VRFConsumerBase's attributes in their constructor as
166  * @dev shown:
167  *
168  * @dev   contract VRFConsumer {
169  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
170  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
171  * @dev         <initialization with other arguments goes here>
172  * @dev       }
173  * @dev   }
174  *
175  * @dev The oracle will have given you an ID for the VRF keypair they have
176  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
177  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
178  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
179  * @dev want to generate randomness from.
180  *
181  * @dev Once the VRFCoordinator has received and validated the oracle's response
182  * @dev to your request, it will call your contract's fulfillRandomness method.
183  *
184  * @dev The randomness argument to fulfillRandomness is the actual random value
185  * @dev generated from your seed.
186  *
187  * @dev The requestId argument is generated from the keyHash and the seed by
188  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
189  * @dev requests open, you can use the requestId to track which seed is
190  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
191  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
192  * @dev if your contract could have multiple requests in flight simultaneously.)
193  *
194  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
195  * @dev differ. (Which is critical to making unpredictable randomness! See the
196  * @dev next section.)
197  *
198  * *****************************************************************************
199  * @dev SECURITY CONSIDERATIONS
200  *
201  * @dev A method with the ability to call your fulfillRandomness method directly
202  * @dev could spoof a VRF response with any random value, so it's critical that
203  * @dev it cannot be directly called by anything other than this base contract
204  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
205  *
206  * @dev For your users to trust that your contract's random behavior is free
207  * @dev from malicious interference, it's best if you can write it so that all
208  * @dev behaviors implied by a VRF response are executed *during* your
209  * @dev fulfillRandomness method. If your contract must store the response (or
210  * @dev anything derived from it) and use it later, you must ensure that any
211  * @dev user-significant behavior which depends on that stored value cannot be
212  * @dev manipulated by a subsequent VRF request.
213  *
214  * @dev Similarly, both miners and the VRF oracle itself have some influence
215  * @dev over the order in which VRF responses appear on the blockchain, so if
216  * @dev your contract could have multiple VRF requests in flight simultaneously,
217  * @dev you must ensure that the order in which the VRF responses arrive cannot
218  * @dev be used to manipulate your contract's user-significant behavior.
219  *
220  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
221  * @dev block in which the request is made, user-provided seeds have no impact
222  * @dev on its economic security properties. They are only included for API
223  * @dev compatability with previous versions of this contract.
224  *
225  * @dev Since the block hash of the block which contains the requestRandomness
226  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
227  * @dev miner could, in principle, fork the blockchain to evict the block
228  * @dev containing the request, forcing the request to be included in a
229  * @dev different block with a different hash, and therefore a different input
230  * @dev to the VRF. However, such an attack would incur a substantial economic
231  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
232  * @dev until it calls responds to a request.
233  */
234 abstract contract VRFConsumerBase is VRFRequestIDBase {
235   /**
236    * @notice fulfillRandomness handles the VRF response. Your contract must
237    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
238    * @notice principles to keep in mind when implementing your fulfillRandomness
239    * @notice method.
240    *
241    * @dev VRFConsumerBase expects its subcontracts to have a method with this
242    * @dev signature, and will call it once it has verified the proof
243    * @dev associated with the randomness. (It is triggered via a call to
244    * @dev rawFulfillRandomness, below.)
245    *
246    * @param requestId The Id initially returned by requestRandomness
247    * @param randomness the VRF output
248    */
249   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
250 
251   /**
252    * @dev In order to keep backwards compatibility we have kept the user
253    * seed field around. We remove the use of it because given that the blockhash
254    * enters later, it overrides whatever randomness the used seed provides.
255    * Given that it adds no security, and can easily lead to misunderstandings,
256    * we have removed it from usage and can now provide a simpler API.
257    */
258   uint256 private constant USER_SEED_PLACEHOLDER = 0;
259 
260   /**
261    * @notice requestRandomness initiates a request for VRF output given _seed
262    *
263    * @dev The fulfillRandomness method receives the output, once it's provided
264    * @dev by the Oracle, and verified by the vrfCoordinator.
265    *
266    * @dev The _keyHash must already be registered with the VRFCoordinator, and
267    * @dev the _fee must exceed the fee specified during registration of the
268    * @dev _keyHash.
269    *
270    * @dev The _seed parameter is vestigial, and is kept only for API
271    * @dev compatibility with older versions. It can't *hurt* to mix in some of
272    * @dev your own randomness, here, but it's not necessary because the VRF
273    * @dev oracle will mix the hash of the block containing your request into the
274    * @dev VRF seed it ultimately uses.
275    *
276    * @param _keyHash ID of public key against which randomness is generated
277    * @param _fee The amount of LINK to send with the request
278    *
279    * @return requestId unique ID for this request
280    *
281    * @dev The returned requestId can be used to distinguish responses to
282    * @dev concurrent requests. It is passed as the first argument to
283    * @dev fulfillRandomness.
284    */
285   function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
286     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
287     // This is the seed passed to VRFCoordinator. The oracle will mix this with
288     // the hash of the block containing this request to obtain the seed/input
289     // which is finally passed to the VRF cryptographic machinery.
290     uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
291     // nonces[_keyHash] must stay in sync with
292     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
293     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
294     // This provides protection against the user repeating their input seed,
295     // which would result in a predictable/duplicate output, if multiple such
296     // requests appeared in the same block.
297     nonces[_keyHash] = nonces[_keyHash] + 1;
298     return makeRequestId(_keyHash, vRFSeed);
299   }
300 
301   LinkTokenInterface internal immutable LINK;
302   address private immutable vrfCoordinator;
303 
304   // Nonces for each VRF key from which randomness has been requested.
305   //
306   // Must stay in sync with VRFCoordinator[_keyHash][this]
307   mapping(bytes32 => uint256) /* keyHash */ /* nonce */
308     private nonces;
309 
310   /**
311    * @param _vrfCoordinator address of VRFCoordinator contract
312    * @param _link address of LINK token contract
313    *
314    * @dev https://docs.chain.link/docs/link-token-contracts
315    */
316   constructor(address _vrfCoordinator, address _link) {
317     vrfCoordinator = _vrfCoordinator;
318     LINK = LinkTokenInterface(_link);
319   }
320 
321   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
322   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
323   // the origin of the call
324   function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
325     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
326     fulfillRandomness(requestId, randomness);
327   }
328 }
329 
330 /**
331  * @dev Interface of the ERC165 standard, as defined in the
332  * https://eips.ethereum.org/EIPS/eip-165[EIP].
333  *
334  * Implementers can declare support of contract interfaces, which can then be
335  * queried by others ({ERC165Checker}).
336  *
337  * For an implementation, see {ERC165}.
338  */
339 interface IERC165 {
340     /**
341      * @dev Returns true if this contract implements the interface defined by
342      * `interfaceId`. See the corresponding
343      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
344      * to learn more about how these ids are created.
345      *
346      * This function call must use less than 30 000 gas.
347      */
348     function supportsInterface(bytes4 interfaceId) external view returns (bool);
349 }
350 
351 
352 /**
353  * @dev Required interface of an ERC721 compliant contract.
354  */
355 interface IERC721 is IERC165 {
356     /**
357      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
358      */
359     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
360 
361     /**
362      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
363      */
364     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
365 
366     /**
367      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
368      */
369     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
370 
371     /**
372      * @dev Returns the number of tokens in ``owner``'s account.
373      */
374     function balanceOf(address owner) external view returns (uint256 balance);
375 
376     /**
377      * @dev Returns the owner of the `tokenId` token.
378      *
379      * Requirements:
380      *
381      * - `tokenId` must exist.
382      */
383     function ownerOf(uint256 tokenId) external view returns (address owner);
384 
385     /**
386      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
387      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
388      *
389      * Requirements:
390      *
391      * - `from` cannot be the zero address.
392      * - `to` cannot be the zero address.
393      * - `tokenId` token must exist and be owned by `from`.
394      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
395      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
396      *
397      * Emits a {Transfer} event.
398      */
399     function safeTransferFrom(
400         address from,
401         address to,
402         uint256 tokenId
403     ) external;
404 
405     /**
406      * @dev Transfers `tokenId` token from `from` to `to`.
407      *
408      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
409      *
410      * Requirements:
411      *
412      * - `from` cannot be the zero address.
413      * - `to` cannot be the zero address.
414      * - `tokenId` token must be owned by `from`.
415      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
416      *
417      * Emits a {Transfer} event.
418      */
419     function transferFrom(
420         address from,
421         address to,
422         uint256 tokenId
423     ) external;
424 
425     /**
426      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
427      * The approval is cleared when the token is transferred.
428      *
429      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
430      *
431      * Requirements:
432      *
433      * - The caller must own the token or be an approved operator.
434      * - `tokenId` must exist.
435      *
436      * Emits an {Approval} event.
437      */
438     function approve(address to, uint256 tokenId) external;
439 
440     /**
441      * @dev Returns the account approved for `tokenId` token.
442      *
443      * Requirements:
444      *
445      * - `tokenId` must exist.
446      */
447     function getApproved(uint256 tokenId) external view returns (address operator);
448 
449     /**
450      * @dev Approve or remove `operator` as an operator for the caller.
451      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
452      *
453      * Requirements:
454      *
455      * - The `operator` cannot be the caller.
456      *
457      * Emits an {ApprovalForAll} event.
458      */
459     function setApprovalForAll(address operator, bool _approved) external;
460 
461     /**
462      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
463      *
464      * See {setApprovalForAll}
465      */
466     function isApprovedForAll(address owner, address operator) external view returns (bool);
467 
468     /**
469      * @dev Safely transfers `tokenId` token from `from` to `to`.
470      *
471      * Requirements:
472      *
473      * - `from` cannot be the zero address.
474      * - `to` cannot be the zero address.
475      * - `tokenId` token must exist and be owned by `from`.
476      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
477      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
478      *
479      * Emits a {Transfer} event.
480      */
481     function safeTransferFrom(
482         address from,
483         address to,
484         uint256 tokenId,
485         bytes calldata data
486     ) external;
487 }
488 
489 
490 
491 /**
492  * @dev String operations.
493  */
494 library Strings {
495     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
496 
497     /**
498      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
499      */
500     function toString(uint256 value) internal pure returns (string memory) {
501         // Inspired by OraclizeAPI's implementation - MIT licence
502         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
503 
504         if (value == 0) {
505             return "0";
506         }
507         uint256 temp = value;
508         uint256 digits;
509         while (temp != 0) {
510             digits++;
511             temp /= 10;
512         }
513         bytes memory buffer = new bytes(digits);
514         while (value != 0) {
515             digits -= 1;
516             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
517             value /= 10;
518         }
519         return string(buffer);
520     }
521 
522 
523     /**
524      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation. 
525      */
526     function toHexString(uint256 value) internal pure returns (string memory) {
527         if (value == 0) {
528             return "0x00";
529         }
530         uint256 temp = value;
531         uint256 length = 0;
532         while (temp != 0) {
533             length++;
534             temp >>= 8;
535         }
536         return toHexString(value, length);
537     }
538 
539     /**
540      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
541      */
542     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
543         bytes memory buffer = new bytes(2 * length + 2);
544         buffer[0] = "0";
545         buffer[1] = "x";
546         for (uint256 i = 2 * length + 1; i > 1; --i) {
547             buffer[i] = _HEX_SYMBOLS[value & 0xf];
548             value >>= 4;
549         }
550         require(value == 0, "Strings: hex length insufficient");
551         return string(buffer);
552     }
553 }
554 
555 
556 /*
557  * @dev Provides information about the current execution context, including the
558  * sender of the transaction and its data. While these are generally available
559  * via msg.sender and msg.data, they should not be accessed in such a direct
560  * manner, since when dealing with meta-transactions the account sending and
561  * paying for execution may not be the actual sender (as far as an application
562  * is concerned).
563  *
564  * This contract is only required for intermediate, library-like contracts.
565  */
566 abstract contract Context {
567     function _msgSender() internal view virtual returns (address) {
568         return msg.sender;
569     }
570 
571     function _msgData() internal view virtual returns (bytes calldata) {
572         return msg.data;
573     }
574 }
575 
576 
577 /**
578  * @dev Contract module which provides a basic access control mechanism, where
579  * there is an account (an owner) that can be granted exclusive access to
580  * specific functions.
581  *
582  * By default, the owner account will be the one that deploys the contract. This
583  * can later be changed with {transferOwnership}.
584  *
585  * This module is used through inheritance. It will make available the modifier
586  * `onlyOwner`, which can be applied to your functions to restrict their use to
587  * the owner.
588  */
589 abstract contract Ownable is Context {
590     address private _owner;
591 
592     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
593 
594     /**
595      * @dev Initializes the contract setting the deployer as the initial owner.
596      */
597     constructor() {
598         _setOwner(_msgSender());
599     }
600 
601     /**
602      * @dev Returns the address of the current owner.
603      */
604     function owner() public view virtual returns (address) {
605         return _owner;
606     }
607 
608     /**
609      * @dev Throws if called by any account other than the owner.
610      */
611     modifier onlyOwner() {
612         require(owner() == _msgSender(), "Ownable: caller is not the owner");
613         _;
614     }
615 
616     /**
617      * @dev Leaves the contract without owner. It will not be possible to call
618      * `onlyOwner` functions anymore. Can only be called by the current owner.
619      *
620      * NOTE: Renouncing ownership will leave the contract without an owner,
621      * thereby removing any functionality that is only available to the owner.
622      */
623     function renounceOwnership() public virtual onlyOwner {
624         _setOwner(address(0));
625     }
626 
627     /**
628      * @dev Transfers ownership of the contract to a new account (`newOwner`).
629      * Can only be called by the current owner.
630      */
631     function transferOwnership(address newOwner) public virtual onlyOwner {
632         require(newOwner != address(0), "Ownable: new owner is the zero address");
633         _setOwner(newOwner);
634     }
635 
636     function _setOwner(address newOwner) private {
637         address oldOwner = _owner;
638         _owner = newOwner;
639         emit OwnershipTransferred(oldOwner, newOwner);
640     }
641 }
642 
643 
644 /**
645  * @dev Contract module that helps prevent reentrant calls to a function.
646  *
647  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
648  * available, which can be applied to functions to make sure there are no nested
649  * (reentrant) calls to them.
650  *
651  * Note that because there is a single `nonReentrant` guard, functions marked as
652  * `nonReentrant` may not call one another. This can be worked around by making
653  * those functions `private`, and then adding `external` `nonReentrant` entry
654  * points to them.
655  *
656  * TIP: If you would like to learn more about reentrancy and alternative ways
657  * to protect against it, check out our blog post
658  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
659  */
660 abstract contract ReentrancyGuard {
661     // Booleans are more expensive than uint256 or any type that takes up a full
662     // word because each write operation emits an extra SLOAD to first read the
663     // slot's contents, replace the bits taken up by the boolean, and then write
664     // back. This is the compiler's defense against contract upgrades and
665     // pointer aliasing, and it cannot be disabled.
666 
667     // The values being non-zero value makes deployment a bit more expensive,
668     // but in exchange the refund on every call to nonReentrant will be lower in
669     // amount. Since refunds are capped to a percentage of the total
670     // transaction's gas, it is best to keep them low in cases like this one, to
671     // increase the likelihood of the full refund coming into effect.
672     uint256 private constant _NOT_ENTERED = 1;
673     uint256 private constant _ENTERED = 2;
674 
675     uint256 private _status;
676 
677     constructor() {
678         _status = _NOT_ENTERED;
679     }
680 
681     /**
682      * @dev Prevents a contract from calling itself, directly or indirectly.
683      * Calling a `nonReentrant` function from another `nonReentrant`
684      * function is not supported. It is possible to prevent this from happening
685      * by making the `nonReentrant` function external, and make it call a
686      * `private` function that does the actual work.
687      */
688     modifier nonReentrant() {
689         // On the first call to nonReentrant, _notEntered will be true
690         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
691 
692         // Any calls to nonReentrant after this point will fail
693         _status = _ENTERED;
694 
695         _;
696 
697         // By storing the original value once again, a refund is triggered (see
698         // https://eips.ethereum.org/EIPS/eip-2200)
699         _status = _NOT_ENTERED;
700     }
701 }
702 
703 
704 
705 /**
706  * @title ERC721 token receiver interface
707  * @dev Interface for any contract that wants to support safeTransfers
708  * from ERC721 asset contracts.
709  */
710 interface IERC721Receiver {
711     /**
712      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
713      * by `operator` from `from`, this function is called.
714      *
715      * It must return its Solidity selector to confirm the token transfer.
716      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
717      *
718      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
719      */
720     function onERC721Received(
721         address operator,
722         address from,
723         uint256 tokenId,
724         bytes calldata data
725     ) external returns (bytes4);
726 }
727 
728 
729 /**
730  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
731  * @dev See https://eips.ethereum.org/EIPS/eip-721
732  */
733 interface IERC721Metadata is IERC721 {
734     /**
735      * @dev Returns the token collection name.
736      */
737     function name() external view returns (string memory);
738 
739     /**
740      * @dev Returns the token collection symbol.
741      */
742     function symbol() external view returns (string memory);
743 
744     /**
745      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
746      */
747     function tokenURI(uint256 tokenId) external view returns (string memory);
748 }
749 
750 
751 /**
752  * @dev Collection of functions related to the address type
753  */
754 library Address {
755     /**
756      * @dev Returns true if `account` is a contract.
757      *
758      * [IMPORTANT]
759      * ====
760      * It is unsafe to assume that an address for which this function returns
761      * false is an externally-owned account (EOA) and not a contract.
762      *
763      * Among others, `isContract` will return false for the following
764      * types of addresses:
765      *
766      *  - an externally-owned account
767      *  - a contract in construction
768      *  - an address where a contract will be created
769      *  - an address where a contract lived, but was destroyed
770      * ====
771      */
772     function isContract(address account) internal view returns (bool) {
773         // This method relies on extcodesize, which returns 0 for contracts in
774         // construction, since the code is only stored at the end of the
775         // constructor execution.
776 
777         uint256 size;
778         assembly {
779             size := extcodesize(account)
780         }
781         return size > 0;
782     }
783 
784     /**
785      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
786      * `recipient`, forwarding all available gas and reverting on errors.
787      *
788      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
789      * of certain opcodes, possibly making contracts go over the 2300 gas limit
790      * imposed by `transfer`, making them unable to receive funds via
791      * `transfer`. {sendValue} removes this limitation.
792      *
793      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
794      *
795      * IMPORTANT: because control is transferred to `recipient`, care must be
796      * taken to not create reentrancy vulnerabilities. Consider using
797      * {ReentrancyGuard} or the
798      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
799      */
800     function sendValue(address payable recipient, uint256 amount) internal {
801         require(address(this).balance >= amount, "Address: insufficient balance");
802 
803         (bool success, ) = recipient.call{value: amount}("");
804         require(success, "Address: unable to send value, recipient may have reverted");
805     }
806 
807     /**
808      * @dev Performs a Solidity function call using a low level `call`. A
809      * plain `call` is an unsafe replacement for a function call: use this
810      * function instead.
811      *
812      * If `target` reverts with a revert reason, it is bubbled up by this
813      * function (like regular Solidity function calls).
814      *
815      * Returns the raw returned data. To convert to the expected return value,
816      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
817      *
818      * Requirements:
819      *
820      * - `target` must be a contract.
821      * - calling `target` with `data` must not revert.
822      *
823      * _Available since v3.1._
824      */
825     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
826         return functionCall(target, data, "Address: low-level call failed");
827     }
828 
829     /**
830      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
831      * `errorMessage` as a fallback revert reason when `target` reverts.
832      *
833      * _Available since v3.1._
834      */
835     function functionCall(
836         address target,
837         bytes memory data,
838         string memory errorMessage
839     ) internal returns (bytes memory) {
840         return functionCallWithValue(target, data, 0, errorMessage);
841     }
842 
843     /**
844      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
845      * but also transferring `value` wei to `target`.
846      *
847      * Requirements:
848      *
849      * - the calling contract must have an ETH balance of at least `value`.
850      * - the called Solidity function must be `payable`.
851      *
852      * _Available since v3.1._
853      */
854     function functionCallWithValue(
855         address target,
856         bytes memory data,
857         uint256 value
858     ) internal returns (bytes memory) {
859         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
860     }
861 
862     /**
863      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
864      * with `errorMessage` as a fallback revert reason when `target` reverts.
865      *
866      * _Available since v3.1._
867      */
868     function functionCallWithValue(
869         address target,
870         bytes memory data,
871         uint256 value,
872         string memory errorMessage
873     ) internal returns (bytes memory) {
874         require(address(this).balance >= value, "Address: insufficient balance for call");
875         require(isContract(target), "Address: call to non-contract");
876 
877         (bool success, bytes memory returndata) = target.call{value: value}(data);
878         return _verifyCallResult(success, returndata, errorMessage);
879     }
880 
881     /**
882      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
883      * but performing a static call.
884      *
885      * _Available since v3.3._
886      */
887     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
888         return functionStaticCall(target, data, "Address: low-level static call failed");
889     }
890 
891     /**
892      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
893      * but performing a static call.
894      *
895      * _Available since v3.3._
896      */
897     function functionStaticCall(
898         address target,
899         bytes memory data,
900         string memory errorMessage
901     ) internal view returns (bytes memory) {
902         require(isContract(target), "Address: static call to non-contract");
903 
904         (bool success, bytes memory returndata) = target.staticcall(data);
905         return _verifyCallResult(success, returndata, errorMessage);
906     }
907 
908     /**
909      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
910      * but performing a delegate call.
911      *
912      * _Available since v3.4._
913      */
914     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
915         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
916     }
917 
918     /**
919      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
920      * but performing a delegate call.
921      *
922      * _Available since v3.4._
923      */
924     function functionDelegateCall(
925         address target,
926         bytes memory data,
927         string memory errorMessage
928     ) internal returns (bytes memory) {
929         require(isContract(target), "Address: delegate call to non-contract");
930 
931         (bool success, bytes memory returndata) = target.delegatecall(data);
932         return _verifyCallResult(success, returndata, errorMessage);
933     }
934 
935     function _verifyCallResult(
936         bool success,
937         bytes memory returndata,
938         string memory errorMessage
939     ) private pure returns (bytes memory) {
940         if (success) {
941             return returndata;
942         } else {
943             // Look for revert reason and bubble it up if present
944             if (returndata.length > 0) {
945                 // The easiest way to bubble the revert reason is using memory via assembly
946 
947                 assembly {
948                     let returndata_size := mload(returndata)
949                     revert(add(32, returndata), returndata_size)
950                 }
951             } else {
952                 revert(errorMessage);
953             }
954         }
955     }
956 }
957 
958 
959 
960 
961 /**
962  * @dev Implementation of the {IERC165} interface.
963  *
964  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
965  * for the additional interface id that will be supported. For example:
966  *
967  * ```solidity
968  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
969  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
970  * }
971  * ```
972  *
973  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
974  */
975 abstract contract ERC165 is IERC165 {
976     /**
977      * @dev See {IERC165-supportsInterface}.
978      */
979     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
980         return interfaceId == type(IERC165).interfaceId;
981     }
982 }
983 
984 
985 /**
986  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
987  * the Metadata extension, but not including the Enumerable extension, which is available separately as
988  * {ERC721Enumerable}.
989  */
990 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
991     using Address for address;
992     using Strings for uint256;
993 
994     // Token name
995     string private _name;
996 
997     // Token symbol
998     string private _symbol;
999 
1000     // Mapping from token ID to owner address
1001     mapping(uint256 => address) private _owners;
1002 
1003     // Mapping owner address to token count
1004     mapping(address => uint256) private _balances;
1005 
1006     // Mapping from token ID to approved address
1007     mapping(uint256 => address) private _tokenApprovals;
1008 
1009     // Mapping from owner to operator approvals
1010     mapping(address => mapping(address => bool)) private _operatorApprovals;
1011 
1012     /**
1013      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1014      */
1015     constructor(string memory name_, string memory symbol_) {
1016         _name = name_;
1017         _symbol = symbol_;
1018     }
1019 
1020     /**
1021      * @dev See {IERC165-supportsInterface}.
1022      */
1023     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1024         return
1025             interfaceId == type(IERC721).interfaceId ||
1026             interfaceId == type(IERC721Metadata).interfaceId ||
1027             super.supportsInterface(interfaceId);
1028     }
1029 
1030     /**
1031      * @dev See {IERC721-balanceOf}.
1032      */
1033     function balanceOf(address owner) public view virtual override returns (uint256) {
1034         require(owner != address(0), "ERC721: balance query for the zero address");
1035         return _balances[owner];
1036     }
1037 
1038     /**
1039      * @dev See {IERC721-ownerOf}.
1040      */
1041     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1042         address owner = _owners[tokenId];
1043         require(owner != address(0), "ERC721: owner query for nonexistent token");
1044         return owner;
1045     }
1046 
1047     /**
1048      * @dev See {IERC721Metadata-name}.
1049      */
1050     function name() public view virtual override returns (string memory) {
1051         return _name;
1052     }
1053 
1054     /**
1055      * @dev See {IERC721Metadata-symbol}.
1056      */
1057     function symbol() public view virtual override returns (string memory) {
1058         return _symbol;
1059     }
1060 
1061     /**
1062      * @dev See {IERC721Metadata-tokenURI}.
1063      */
1064     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1065         require(_exists(tokenId), "Nonexistent token");
1066 
1067         string memory baseURI = _baseURI();
1068         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1069     }
1070 
1071     /**
1072      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1073      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1074      * by default, can be overriden in child contracts.
1075      */
1076     function _baseURI() internal view virtual returns (string memory) {
1077         return "";
1078     }
1079 
1080     /**
1081      * @dev See {IERC721-approve}.
1082      */
1083     function approve(address to, uint256 tokenId) public virtual override {
1084         address owner = ERC721.ownerOf(tokenId);
1085         require(to != owner, "ERC721: approval to current owner");
1086 
1087         require(
1088             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1089             "ERC721: approve caller is not owner nor approved for all"
1090         );
1091 
1092         _approve(to, tokenId);
1093     }
1094 
1095     /**
1096      * @dev See {IERC721-getApproved}.
1097      */
1098     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1099         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1100 
1101         return _tokenApprovals[tokenId];
1102     }
1103 
1104     /**
1105      * @dev See {IERC721-setApprovalForAll}.
1106      */
1107     function setApprovalForAll(address operator, bool approved) public virtual override {
1108         require(operator != _msgSender(), "ERC721: approve to caller");
1109 
1110         _operatorApprovals[_msgSender()][operator] = approved;
1111         emit ApprovalForAll(_msgSender(), operator, approved);
1112     }
1113 
1114     /**
1115      * @dev See {IERC721-isApprovedForAll}.
1116      */
1117     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1118         return _operatorApprovals[owner][operator];
1119     }
1120 
1121     /**
1122      * @dev See {IERC721-transferFrom}.
1123      */
1124     function transferFrom(
1125         address from,
1126         address to,
1127         uint256 tokenId
1128     ) public virtual override {
1129         //solhint-disable-next-line max-line-length
1130         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1131 
1132         _transfer(from, to, tokenId);
1133     }
1134 
1135     /**
1136      * @dev See {IERC721-safeTransferFrom}.
1137      */
1138     function safeTransferFrom(
1139         address from,
1140         address to,
1141         uint256 tokenId
1142     ) public virtual override {
1143         safeTransferFrom(from, to, tokenId, "");
1144     }
1145 
1146     /**
1147      * @dev See {IERC721-safeTransferFrom}.
1148      */
1149     function safeTransferFrom(
1150         address from,
1151         address to,
1152         uint256 tokenId,
1153         bytes memory _data
1154     ) public virtual override {
1155         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1156         _safeTransfer(from, to, tokenId, _data);
1157     }
1158 
1159     /**
1160      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1161      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1162      *
1163      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1164      *
1165      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1166      * implement alternative mechanisms to perform token transfer, such as signature-based.
1167      *
1168      * Requirements:
1169      *
1170      * - `from` cannot be the zero address.
1171      * - `to` cannot be the zero address.
1172      * - `tokenId` token must exist and be owned by `from`.
1173      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1174      *
1175      * Emits a {Transfer} event.
1176      */
1177     function _safeTransfer(
1178         address from,
1179         address to,
1180         uint256 tokenId,
1181         bytes memory _data
1182     ) internal virtual {
1183         _transfer(from, to, tokenId);
1184         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1185     }
1186 
1187     /**
1188      * @dev Returns whether `tokenId` exists.
1189      *
1190      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1191      *
1192      * Tokens start existing when they are minted (`_mint`),
1193      * and stop existing when they are burned (`_burn`).
1194      */
1195     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1196         return _owners[tokenId] != address(0);
1197     }
1198 
1199     /**
1200      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1201      *
1202      * Requirements:
1203      *
1204      * - `tokenId` must exist.
1205      */
1206     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1207         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1208         address owner = ERC721.ownerOf(tokenId);
1209         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1210     }
1211 
1212     /**
1213      * @dev Safely mints `tokenId` and transfers it to `to`.
1214      *
1215      * Requirements:
1216      *
1217      * - `tokenId` must not exist.
1218      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1219      *
1220      * Emits a {Transfer} event.
1221      */
1222     function _safeMint(address to, uint256 tokenId) internal virtual {
1223         _safeMint(to, tokenId, "");
1224     }
1225 
1226     /**
1227      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1228      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1229      */
1230     function _safeMint(
1231         address to,
1232         uint256 tokenId,
1233         bytes memory _data
1234     ) internal virtual {
1235         _mint(to, tokenId);
1236         require(
1237             _checkOnERC721Received(address(0), to, tokenId, _data),
1238             "ERC721: transfer to non ERC721Receiver implementer"
1239         );
1240     }
1241 
1242     /**
1243      * @dev Mints `tokenId` and transfers it to `to`.
1244      *
1245      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1246      *
1247      * Requirements:
1248      *
1249      * - `tokenId` must not exist.
1250      * - `to` cannot be the zero address.
1251      *
1252      * Emits a {Transfer} event.
1253      */
1254     function _mint(address to, uint256 tokenId) internal virtual {
1255         require(to != address(0), "ERC721: mint to the zero address");
1256         require(!_exists(tokenId), "ERC721: token already minted");
1257 
1258         _beforeTokenTransfer(address(0), to, tokenId);
1259 
1260         _balances[to] += 1;
1261         _owners[tokenId] = to;
1262 
1263         emit Transfer(address(0), to, tokenId);
1264     }
1265 
1266     /**
1267      * @dev Destroys `tokenId`.
1268      * The approval is cleared when the token is burned.
1269      *
1270      * Requirements:
1271      *
1272      * - `tokenId` must exist.
1273      *
1274      * Emits a {Transfer} event.
1275      */
1276     function _burn(uint256 tokenId) internal virtual {
1277         address owner = ERC721.ownerOf(tokenId);
1278 
1279         _beforeTokenTransfer(owner, address(0), tokenId);
1280 
1281         // Clear approvals
1282         _approve(address(0), tokenId);
1283 
1284         _balances[owner] -= 1;
1285         delete _owners[tokenId];
1286 
1287         emit Transfer(owner, address(0), tokenId);
1288     }
1289 
1290     /**
1291      * @dev Transfers `tokenId` from `from` to `to`.
1292      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1293      *
1294      * Requirements:
1295      *
1296      * - `to` cannot be the zero address.
1297      * - `tokenId` token must be owned by `from`.
1298      *
1299      * Emits a {Transfer} event.
1300      */
1301     function _transfer(
1302         address from,
1303         address to,
1304         uint256 tokenId
1305     ) internal virtual {
1306         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1307         require(to != address(0), "ERC721: transfer to the zero address");
1308 
1309         _beforeTokenTransfer(from, to, tokenId);
1310 
1311         // Clear approvals from the previous owner
1312         _approve(address(0), tokenId);
1313 
1314         _balances[from] -= 1;
1315         _balances[to] += 1;
1316         _owners[tokenId] = to;
1317 
1318         emit Transfer(from, to, tokenId);
1319     }
1320 
1321     /**
1322      * @dev Approve `to` to operate on `tokenId`
1323      *
1324      * Emits a {Approval} event.
1325      */
1326     function _approve(address to, uint256 tokenId) internal virtual {
1327         _tokenApprovals[tokenId] = to;
1328         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1329     }
1330 
1331     /**
1332      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1333      * The call is not executed if the target address is not a contract.
1334      *
1335      * @param from address representing the previous owner of the given token ID
1336      * @param to target address that will receive the tokens
1337      * @param tokenId uint256 ID of the token to be transferred
1338      * @param _data bytes optional data to send along with the call
1339      * @return bool whether the call correctly returned the expected magic value
1340      */
1341     function _checkOnERC721Received(
1342         address from,
1343         address to,
1344         uint256 tokenId,
1345         bytes memory _data
1346     ) private returns (bool) {
1347         if (to.isContract()) {
1348             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1349                 return retval == IERC721Receiver(to).onERC721Received.selector;
1350             } catch (bytes memory reason) {
1351                 if (reason.length == 0) {
1352                     revert("ERC721: transfer to non ERC721Receiver implementer");
1353                 } else {
1354                     assembly {
1355                         revert(add(32, reason), mload(reason))
1356                     }
1357                 }
1358             }
1359         } else {
1360             return true;
1361         }
1362     }
1363 
1364     /**
1365      * @dev Hook that is called before any token transfer. This includes minting
1366      * and burning.
1367      *
1368      * Calling conditions:
1369      *
1370      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1371      * transferred to `to`.
1372      * - When `from` is zero, `tokenId` will be minted for `to`.
1373      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1374      * - `from` and `to` are never both zero.
1375      *
1376      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1377      */
1378     function _beforeTokenTransfer(
1379         address from,
1380         address to,
1381         uint256 tokenId
1382     ) internal virtual {}
1383 }
1384 
1385 
1386 
1387 /**
1388  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1389  * @dev See https://eips.ethereum.org/EIPS/eip-721
1390  */
1391 interface IERC721Enumerable is IERC721 {
1392     /**
1393      * @dev Returns the total amount of tokens stored by the contract.
1394      */
1395     function totalSupply() external view returns (uint256);
1396 
1397     /**
1398      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1399      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1400      */
1401     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1402 
1403     /**
1404      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1405      * Use along with {totalSupply} to enumerate all tokens.
1406      */
1407     function tokenByIndex(uint256 index) external view returns (uint256);
1408 }
1409 
1410 
1411 /**
1412  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1413  * enumerability of all the token ids in the contract as well as all token ids owned by each
1414  * account.
1415  */
1416 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1417     // Mapping from owner to list of owned token IDs
1418     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1419 
1420     // Mapping from token ID to index of the owner tokens list
1421     mapping(uint256 => uint256) private _ownedTokensIndex;
1422 
1423     // Array with all token ids, used for enumeration
1424     uint256[] private _allTokens;
1425 
1426     // Mapping from token id to position in the allTokens array
1427     mapping(uint256 => uint256) private _allTokensIndex;
1428 
1429     /**
1430      * @dev See {IERC165-supportsInterface}.
1431      */
1432     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1433         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1434     }
1435 
1436     /**
1437      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1438      */
1439     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1440         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1441         return _ownedTokens[owner][index];
1442     }
1443 
1444     /**
1445      * @dev See {IERC721Enumerable-totalSupply}.
1446      */
1447     function totalSupply() public view virtual override returns (uint256) {
1448         return _allTokens.length;
1449     }
1450 
1451     /**
1452      * @dev See {IERC721Enumerable-tokenByIndex}.
1453      */
1454     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1455         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1456         return _allTokens[index];
1457     }
1458 
1459     /**
1460      * @dev Hook that is called before any token transfer. This includes minting
1461      * and burning.
1462      *
1463      * Calling conditions:
1464      *
1465      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1466      * transferred to `to`.
1467      * - When `from` is zero, `tokenId` will be minted for `to`.
1468      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1469      * - `from` cannot be the zero address.
1470      * - `to` cannot be the zero address.
1471      *
1472      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1473      */
1474     function _beforeTokenTransfer(
1475         address from,
1476         address to,
1477         uint256 tokenId
1478     ) internal virtual override {
1479         super._beforeTokenTransfer(from, to, tokenId);
1480 
1481         if (from == address(0)) {
1482             _addTokenToAllTokensEnumeration(tokenId);
1483         } else if (from != to) {
1484             _removeTokenFromOwnerEnumeration(from, tokenId);
1485         }
1486         if (to == address(0)) {
1487             _removeTokenFromAllTokensEnumeration(tokenId);
1488         } else if (to != from) {
1489             _addTokenToOwnerEnumeration(to, tokenId);
1490         }
1491     }
1492 
1493     /**
1494      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1495      * @param to address representing the new owner of the given token ID
1496      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1497      */
1498     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1499         uint256 length = ERC721.balanceOf(to);
1500         _ownedTokens[to][length] = tokenId;
1501         _ownedTokensIndex[tokenId] = length;
1502     }
1503 
1504     /**
1505      * @dev Private function to add a token to this extension's token tracking data structures.
1506      * @param tokenId uint256 ID of the token to be added to the tokens list
1507      */
1508     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1509         _allTokensIndex[tokenId] = _allTokens.length;
1510         _allTokens.push(tokenId);
1511     }
1512 
1513     /**
1514      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1515      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1516      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1517      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1518      * @param from address representing the previous owner of the given token ID
1519      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1520      */
1521     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1522         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1523         // then delete the last slot (swap and pop).
1524 
1525         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1526         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1527 
1528         // When the token to delete is the last token, the swap operation is unnecessary
1529         if (tokenIndex != lastTokenIndex) {
1530             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1531 
1532             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1533             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1534         }
1535 
1536         // This also deletes the contents at the last position of the array
1537         delete _ownedTokensIndex[tokenId];
1538         delete _ownedTokens[from][lastTokenIndex];
1539     }
1540 
1541     /**
1542      * @dev Private function to remove a token from this extension's token tracking data structures.
1543      * This has O(1) time complexity, but alters the order of the _allTokens array.
1544      * @param tokenId uint256 ID of the token to be removed from the tokens list
1545      */
1546     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1547         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1548         // then delete the last slot (swap and pop).
1549 
1550         uint256 lastTokenIndex = _allTokens.length - 1;
1551         uint256 tokenIndex = _allTokensIndex[tokenId];
1552 
1553         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1554         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1555         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1556         uint256 lastTokenId = _allTokens[lastTokenIndex];
1557 
1558         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1559         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1560 
1561         // This also deletes the contents at the last position of the array
1562         delete _allTokensIndex[tokenId];
1563         _allTokens.pop();
1564     }
1565 }
1566 
1567 /// [MIT License]
1568 /// @title Base64
1569 /// @notice Provides a function for encoding some bytes in base64
1570 /// @author Brecht Devos <brecht@loopring.org>
1571 library Base64 {
1572     bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
1573 
1574     /// @notice Encodes some bytes to the base64 representation
1575     function encode(bytes memory data) internal pure returns (string memory) {
1576         uint256 len = data.length;
1577         if (len == 0) return "";
1578 
1579         // multiply by 4/3 rounded up
1580         uint256 encodedLen = 4 * ((len + 2) / 3);
1581 
1582         // Add some extra buffer at the end
1583         bytes memory result = new bytes(encodedLen + 32);
1584 
1585         bytes memory table = TABLE;
1586 
1587         assembly {
1588             let tablePtr := add(table, 1)
1589             let resultPtr := add(result, 32)
1590 
1591             for {
1592                 let i := 0
1593             } lt(i, len) {
1594 
1595             } {
1596                 i := add(i, 3)
1597                 let input := and(mload(add(data, i)), 0xffffff)
1598 
1599                 let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
1600                 out := shl(8, out)
1601                 out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
1602                 out := shl(8, out)
1603                 out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
1604                 out := shl(8, out)
1605                 out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
1606                 out := shl(224, out)
1607 
1608                 mstore(resultPtr, out)
1609 
1610                 resultPtr := add(resultPtr, 4)
1611             }
1612 
1613             switch mod(len, 3)
1614             case 1 {
1615                 mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
1616             }
1617             case 2 {
1618                 mstore(sub(resultPtr, 1), shl(248, 0x3d))
1619             }
1620 
1621             mstore(result, encodedLen)
1622         }
1623 
1624         return string(result);
1625     }
1626 }
1627 
1628 abstract contract PercentageGenerator {
1629 	function calculatePercentage(bool hasVault, uint rarity, uint tokens) public view virtual returns (uint[] memory);
1630 }
1631 
1632 abstract contract SourceData {
1633 	function getVaultRarity(uint token_id) public view virtual returns(uint);
1634     function getFirstStat(uint token_id, uint rarity) public view virtual returns(uint);
1635     function getFirstStatValue(uint token_id, uint rarity) public view virtual returns(uint);
1636     function getSecondStat(uint token_id, uint rarity) public view virtual returns(uint);
1637     function getSecondStatValue(uint token_id, uint rarity) public view virtual returns(uint);
1638     function getFirstAugment(uint token_id, uint rarity) public view virtual returns(uint);
1639     function getSecondAugment(uint token_id, uint rarity) public view virtual returns(uint);
1640     function getAirdrops(uint token_id, uint rarity) public view virtual returns(uint);
1641 }
1642 
1643 contract ConsoleNFT_Cyber_Upgrades is ERC721Enumerable, ReentrancyGuard, Ownable, VRFConsumerBase {
1644 
1645 	address dataContract;
1646     address percentageContract;
1647     address vaultContract;
1648     address levelUpContract;
1649 
1650     mapping(uint => bool) private _usedVaults;
1651 
1652     // Mapping for wallet addresses that have previously minted
1653     mapping(address => uint) private _whitelistMinters;
1654 
1655     // Merkle Proof Hashes for tokens
1656     bytes32[] public rootHashes;
1657 
1658 	uint public constant maxTokens = 5000;
1659 
1660     uint public vaultHolderReserves = 500;
1661 
1662     uint[] public rarities; // mapping of pool rarities in constructor
1663 
1664     uint public total = 0;
1665 
1666 	uint mintCost = 0.05 ether;
1667     uint publicMintCost = 0.1 ether;
1668 
1669     uint public whitelistMintStart;
1670     uint public publicMintStart;
1671 
1672 	bool sysAdminMinted;
1673 	bool error404Minted;
1674 	bool code200Minted;
1675 	bool giveawaysMinted;
1676 	
1677 	address error404Address;
1678 	address code200Address;
1679 	address giveawaysAddress;
1680 
1681     mapping(uint => uint) public levels; // tokenID -> level
1682     mapping(uint => uint) public rarity; // tokenID -> rarity
1683 
1684     function setMerkleHashes(bytes32[] memory _rootHash) external onlyOwner {
1685         rootHashes = new bytes32[](0);
1686         for (uint i=0; i < _rootHash.length; i++) {
1687             rootHashes.push(_rootHash[i]);
1688         }
1689     }
1690 
1691     function setVaultContractAddress(address _vaultContract) external onlyOwner {
1692         vaultContract = _vaultContract;
1693     }
1694 
1695     function setPercentageContractAddress(address _percentageContract) external onlyOwner {
1696         percentageContract = _percentageContract;
1697     }
1698 
1699     function setWhitelistMintStart(uint _timestamp) external onlyOwner {
1700         whitelistMintStart = _timestamp;
1701     }
1702 	
1703     function setPublicMintStart(uint _timestamp) external onlyOwner {
1704         publicMintStart = _timestamp;
1705     }
1706 
1707 	function setSourceData(address _dataContract) external onlyOwner {
1708         dataContract = _dataContract;
1709     }
1710 
1711     function setLevelUpContract(address _levelUpContract) external onlyOwner {
1712         levelUpContract = _levelUpContract;
1713     }
1714 
1715 	string[] private rarityText = [
1716         "Common",
1717         "Uncommon",
1718         "Rare",
1719         "Epic",
1720         "Legendary"
1721     ];
1722 
1723     function getRarity(uint256 tokenId) public view returns (string memory) {
1724         require(_exists(tokenId), "Nonexistent token");
1725 		
1726         string memory output;
1727 		
1728         output = rarityText[rarity[tokenId]];
1729 		
1730         return output;
1731     }
1732 
1733     string[] private firstStat = [
1734         "Health",
1735         "Strength",
1736         "Speed",
1737         "Accuracy",
1738         "Intelligence",
1739         "Tech",
1740         "Hack speed",
1741         "SQL skill",
1742         "Network",
1743         "DNA",
1744         "De-auth",
1745         "Pwd cracking",
1746         "XSS forgery",
1747         "Decrypt",
1748         "Cryptography"
1749     ];
1750 
1751     function getFirstStat(uint256 tokenId) public view returns (string memory) {
1752         require(_exists(tokenId), "Nonexistent token");
1753 		
1754         string memory output;
1755 		
1756 		SourceData source_data = SourceData(dataContract);
1757 		
1758         output = firstStat[source_data.getFirstStat(tokenId, rarity[tokenId])];
1759 		
1760         return output;
1761     }
1762 
1763     function getFirstStatValue(uint256 tokenId) public view returns (uint) {
1764         require(_exists(tokenId), "Nonexistent token");
1765 		
1766         uint output;
1767 		
1768 		SourceData source_data = SourceData(dataContract);
1769 		
1770 		uint firstStatValue = source_data.getFirstStatValue(tokenId, rarity[tokenId]);
1771 		
1772         output = (firstStatValue * getItemLevel(tokenId)) + 1;
1773 		
1774         return output;
1775     }
1776 
1777     string[] private secondStat = [
1778         "Lockpicking",
1779         "Regeneration",
1780         "Armor",
1781         "Backpack",
1782         "Intelligence",
1783         "Charge",
1784         "Damage boost",
1785         "Reflexes",
1786         "Radar",
1787         "Keymaster",
1788         "Pickpocket",
1789         "EMP shield",
1790         "EMP power",
1791         "Run silent",
1792         "Nanotech"
1793     ];
1794 
1795     function getSecondStat(uint256 tokenId) public view returns (string memory) {
1796         require(_exists(tokenId), "Nonexistent token");
1797 		
1798         string memory output;
1799 		
1800 		SourceData source_data = SourceData(dataContract);
1801 		
1802         output = secondStat[source_data.getSecondStat(tokenId, rarity[tokenId])];
1803 		
1804         return output;
1805     }
1806 
1807     function getSecondStatValue(uint256 tokenId) public view returns (uint) {
1808         require(_exists(tokenId), "Nonexistent token");
1809 		
1810         uint output;
1811 		
1812 		SourceData source_data = SourceData(dataContract);
1813 		
1814 		uint secondStatValue = source_data.getSecondStatValue(tokenId, rarity[tokenId]);
1815 		
1816         output = (secondStatValue * getItemLevel(tokenId)) + 1;
1817 		
1818         return output;
1819     }
1820 
1821     string[] private firstAugment = [
1822         "Scrapper",
1823         "Bionic Arms",
1824         "Detoxifier",
1825         "Bionic Lungs",
1826         "Hardened Bones",
1827         "Berserk",
1828         "Blood pump",
1829         "Edge runner",
1830         "Adrenaline Pump",
1831         "Bloodware",
1832         "Cyber Joints",
1833         "Cloaking",
1834         "Nanobots",
1835         "Synthetic Heart",
1836         "?"
1837     ];
1838 
1839     function getFirstAugment(uint256 tokenId) public view returns (string memory) {
1840         require(_exists(tokenId), "Nonexistent token");
1841 		
1842         string memory output;
1843 		
1844 		SourceData source_data = SourceData(dataContract);
1845 		
1846         output = firstAugment[source_data.getFirstAugment(tokenId, rarity[tokenId])];
1847 		
1848         return output;
1849     }
1850 
1851     string[] private secondAugment = [
1852         "Nightvision",
1853         "Titan Knuckles",
1854         "Cyber Legs",
1855         "Cyber Arms",
1856         "Reflex Boost",
1857         "Lizard skin",
1858         "Titanium Bones",
1859         "Echolocation",
1860         "Thermal vision",
1861         "X-ray Vision",
1862         "Shapeshifter",
1863         "Exoskeleton",
1864         "Stealth kit",
1865         "Double Heart",
1866         "?"
1867     ];
1868 
1869     function getSecondAugment(uint256 tokenId) public view returns (string memory) {
1870         require(_exists(tokenId), "Nonexistent token");
1871 		
1872         string memory output;
1873 		
1874 		SourceData source_data = SourceData(dataContract);
1875 		
1876         output = secondAugment[source_data.getSecondAugment(tokenId, rarity[tokenId])];
1877 		
1878         return output;
1879     }
1880 
1881     function getAirdrops(uint256 tokenId) public view returns (uint) {
1882         require(_exists(tokenId), "Nonexistent token");
1883 		
1884         uint output;
1885 		
1886 		SourceData source_data = SourceData(dataContract);
1887 		
1888         output = source_data.getAirdrops(tokenId, rarity[tokenId]) + getItemLevel(tokenId);
1889 		
1890         return output;
1891     }
1892 	
1893     string internal baseTokenURI;
1894 
1895 	function setBaseTokenURI(string memory _uri) external onlyOwner {
1896         baseTokenURI = _uri;
1897     }
1898 
1899     string internal externalURI;
1900 
1901 	function setExternalURI(string memory _uri) external onlyOwner {
1902         externalURI = _uri;
1903     }
1904 
1905 	function tokenURI(uint _tokenId) public view override returns (string memory) {
1906         require(_exists(_tokenId), "Query for non-existent token!");
1907 
1908         string[7] memory json;
1909 
1910         json[0] = string(
1911 			abi.encodePacked('{',
1912                 '"name": "Cyber Upgrade #', t(_tokenId), ' (Level: ', t(getItemLevel(_tokenId)), ')",',
1913                 '"image": "', baseTokenURI, t(rarity[_tokenId]), '.jpg",',
1914                 '"external_url": "', externalURI, '?dna=', getDna(_tokenId) ,'&id=', t(_tokenId) ,'",',  
1915                 '"description": "Upgrades waiting to be connected to players.",',
1916                 '"attributes": ['
1917             )
1918 		);
1919 
1920         json[1] = string(
1921 			abi.encodePacked(
1922 				'{',
1923 					'"trait_type": "Rarity",',
1924 					'"value": "', getRarity(_tokenId) ,'"',
1925                 '},',
1926                 '{',
1927                     '"trait_type": "Level",',
1928                     '"value": "', t(getItemLevel(_tokenId)) ,'"',
1929                 '},'
1930             )
1931 		);
1932         json[2] = string(
1933 			abi.encodePacked(
1934 				'{',
1935                     '"trait_type": "Upgrade #1",',
1936                     '"value": "', getFirstStat(_tokenId) , " +", t(getFirstStatValue(_tokenId)) ,'"',
1937                 '},'
1938             )
1939 		);
1940 
1941         json[3] = string(
1942 			abi.encodePacked(
1943 				'{',
1944                     '"trait_type": "Upgrade #2",',
1945                     '"value": "', getSecondStat(_tokenId) ," +", t(getSecondStatValue(_tokenId)) ,'"',
1946                 '},'
1947             )
1948 		);
1949         json[4] = string(
1950 			abi.encodePacked(
1951 				'{',
1952                     '"trait_type": "Augmentation #1",',
1953                     '"value": "', getFirstAugment(_tokenId) ,'"',
1954                 '},'
1955             )
1956 		);
1957         json[5] = string(
1958 			abi.encodePacked(
1959                 '{',
1960                     '"trait_type": "Augmentation #2",',
1961                     '"value": "', getSecondAugment(_tokenId) ,'"',
1962                 '},',
1963                 '{',
1964                     '"trait_type": "Airdrops",',
1965 					'"value": "x', t(getAirdrops(_tokenId)) ,'"',
1966                 '}'
1967             )
1968 		);
1969         json[6] = string(
1970 			abi.encodePacked('],',
1971                 '"animation_url": "', externalURI, '?dna=', getDna(_tokenId) , '&id=', t(_tokenId) , '",',
1972                 '"iframe_url": "', externalURI, '?dna=', getDna(_tokenId) , '&id=', t(_tokenId) , '"',
1973             '}')
1974 		);
1975 
1976         string memory result = Base64.encode(
1977             bytes(
1978                 string(
1979                     abi.encodePacked(
1980                         json[0],
1981                         json[1],
1982                         json[2],
1983                         json[3],
1984                         json[4],
1985                         json[5],
1986                         json[6]
1987                     )
1988                 )
1989             )
1990         );
1991 
1992         return string(abi.encodePacked("data:application/json;base64,", result));
1993     }
1994 
1995 
1996 	
1997 	// helper
1998 	function t(uint _tokenId) public pure returns (string memory) {
1999 		return Strings.toString(_tokenId);
2000 	}
2001 
2002 
2003     // Getters
2004     function getDna(uint256 tokenId) public view returns (string memory) {
2005         require(_exists(tokenId), "Query for non-existent token!");
2006 
2007         SourceData source_data = SourceData(dataContract);
2008 
2009         // First stat index
2010         uint firstStatIndex = source_data.getFirstStat(tokenId, rarity[tokenId]);
2011 
2012         // First stat index
2013         uint secondStatIndex = source_data.getSecondStat(tokenId, rarity[tokenId]);
2014 
2015         string[2] memory dna;
2016 
2017         dna[0] = string(
2018             abi.encodePacked(
2019                 t(rarity[tokenId]), "-",
2020                 t(levels[tokenId]), "-",
2021                 t(firstStatIndex), "-",
2022                 t(getFirstStatValue(tokenId)), "-"
2023             )
2024         );
2025         
2026         dna[1] = string(
2027 			abi.encodePacked(
2028                 t(secondStatIndex), "-",
2029                 t(getSecondStatValue(tokenId)), "-",
2030                 t(source_data.getFirstAugment(tokenId, rarity[tokenId])), "-",
2031                 t(source_data.getSecondAugment(tokenId, rarity[tokenId])), "-",
2032                 t(getAirdrops(tokenId))
2033             )
2034 		);
2035 
2036         string memory result = string(
2037                     abi.encodePacked(
2038                         dna[0],
2039                         dna[1]
2040                     )
2041                 );
2042 
2043         return string(abi.encodePacked(result));
2044     }
2045 
2046     function getItemLevel(uint256 tokenId) public view returns (uint) {
2047         return levels[tokenId];
2048     }
2049 
2050     function setItemLevel(uint tokenId, uint level) external {
2051         require(msg.sender == levelUpContract, "You can not call this");
2052         levels[tokenId] = level;
2053     }
2054 
2055 	function whitelistClaim(bytes32[] memory proof, uint proofNumber) public nonReentrant payable {
2056         require(whitelistMintStart < block.timestamp, "Whitelist mint not started yet");
2057         require(maxTokens - total > vaultHolderReserves, "Minting over vault holder limit");
2058         require(total < maxTokens, "All tokens are already minted");
2059 		require(msg.value == mintCost, "Incorrect mint cost value");
2060         require(_whitelistMinters[_msgSender()] < 1, "You've already minted");
2061 		
2062 		// Merkle tree validation
2063 		bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
2064 		require(MerkleProof.verify(proof, rootHashes[proofNumber], leaf), "Invalid proof");
2065 		
2066 		uint userTokens = proofNumber * 1000;
2067                 
2068 		// Proceed in minting process
2069 		uint tokenId = getVRFRandomIndex(false, 0, userTokens);
2070 		total++;
2071 
2072 		// Set the _whitelistMinters value to tokenId for this address as it has minted
2073 		_whitelistMinters[_msgSender()] = tokenId;
2074 
2075 		_safeMint(_msgSender(), tokenId);
2076 		
2077     }
2078 
2079     function publicClaim(uint numberOfTokens) public nonReentrant payable {
2080         require(publicMintStart < block.timestamp, "Public mint did not start yet");
2081         require(maxTokens - total > vaultHolderReserves, "Minting over vault holder limit");
2082         require(total + numberOfTokens < maxTokens, "All tokens are already minted");
2083         require(numberOfTokens > 0, "Can not mint zero tokens");
2084         require(numberOfTokens < 11, "Request exceeds max tokens");
2085 		require(msg.value == publicMintCost * numberOfTokens, "Incorrect mint cost value");
2086 
2087         for (uint i=1; i < numberOfTokens; i++) {
2088             uint tokenId = getVRFRandomIndex(false, 0, 0);
2089             total++;
2090             _safeMint(_msgSender(), tokenId);
2091         }
2092 
2093     }
2094 
2095     function vaultHolderClaim(bytes32[] memory proof, uint proofNumber, uint[] memory vaultIds) public nonReentrant {
2096         require(whitelistMintStart < block.timestamp, "Whitelist mint not started yet");
2097         require(total + vaultIds.length < maxTokens, "Mint over the max tokens limit");
2098 
2099         for (uint i=0; i < vaultIds.length; i++) {
2100             require(validateVaultOwnership(vaultIds[i]), "Not Vault owner");
2101             require(!checkUsedVault(vaultIds[i]), "Vault was already used");
2102         }
2103 		
2104 		// This sender does not necessary need to have tokens, it is optional
2105         uint userTokens = 0;
2106 
2107         // Merkle tree for getting tokens
2108 		bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
2109 		
2110 		if (MerkleProof.verify(proof, rootHashes[proofNumber], leaf) ) {
2111 
2112 			userTokens = proofNumber * 1000;
2113 
2114 		}
2115 
2116         for (uint i=0; i < vaultIds.length; i++) {
2117 
2118             // get vault rarity
2119             uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);
2120             _usedVaults[vaultIds[i]] = true;
2121 
2122             total++;
2123             vaultHolderReserves--;
2124             _safeMint(_msgSender(), tokenId);
2125         }
2126 
2127     }
2128     
2129     function vaultHolderClaimCombined(bytes32[] memory proof, uint proofNumber, uint[] memory vaultIds) public nonReentrant payable {
2130         require(whitelistMintStart < block.timestamp, "Whitelist mint not started yet");
2131         require(total + 1 + vaultIds.length < maxTokens, "Mint over the max tokens limit");
2132         require(msg.value == mintCost, "Incorrect mint cost value");
2133         require(_whitelistMinters[_msgSender()] < 1, "You've already minted");
2134 
2135         for (uint i=0; i < vaultIds.length; i++) {
2136             require(validateVaultOwnership(vaultIds[i]), "Not Vault owner");
2137             require(!checkUsedVault(vaultIds[i]), "Vault was already used");
2138         }
2139 
2140         uint userTokens = 0;
2141 
2142         // Merkle tree for getting tokens
2143 		bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
2144 		require(MerkleProof.verify(proof, rootHashes[proofNumber], leaf), "Invalid proof");
2145 		
2146         userTokens = proofNumber * 1000;
2147 
2148         // Continue minting process
2149         for (uint i=0; i < vaultIds.length; i++) {
2150             uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);
2151             _usedVaults[vaultIds[i]] = true;
2152 
2153             total++;
2154             vaultHolderReserves--;
2155             _safeMint(_msgSender(), tokenId);
2156         }
2157 
2158         // + 1 for whitelist
2159         uint additionalTokenId = getVRFRandomIndex(false, 0, userTokens);
2160         total++;
2161         _whitelistMinters[_msgSender()] = additionalTokenId;
2162         _safeMint(_msgSender(), additionalTokenId);
2163 
2164     }
2165 
2166     function validateVaultOwnership(uint _vaultID) internal view returns(bool) {
2167         ERC721 vaultContractData = ERC721(vaultContract);
2168         if(vaultContractData.ownerOf(_vaultID) == msg.sender) {
2169             return true;
2170         }
2171         return false;
2172     }
2173 
2174     function checkUsedVault(uint _vaultID) internal view returns(bool) {
2175         if (_usedVaults[_vaultID] == true) {
2176             return true;
2177         }
2178         return false;
2179     }
2180 
2181     function vaultCheck(uint _vaultID) public view returns (bool) {
2182         if (_usedVaults[_vaultID] == true) {
2183             return true;
2184         }
2185         return false;
2186     }
2187 	
2188     function getVaultRarity(uint _vaultID) public view returns (uint) {
2189 
2190 		uint output;
2191 		
2192 		SourceData source_data = SourceData(dataContract);
2193 		
2194         output = source_data.getVaultRarity(_vaultID);
2195 		
2196         return output;
2197 
2198     }
2199 
2200 	function sysAdminClaim() public onlyOwner nonReentrant {
2201 		require(sysAdminMinted == false, "Already minted!");
2202 		
2203 		sysAdminMinted = true;
2204 		uint tokenId = getVRFRandomIndex(false, 0, 0);
2205         total++;
2206         _safeMint(owner(), tokenId);
2207     }
2208 
2209 	function error404Claim() public nonReentrant {
2210 		require(msg.sender == error404Address, "Not Error 404");
2211 		require(error404Minted == false, "Already minted!");
2212 		
2213 		error404Minted = true;
2214 		uint tokenId = getVRFRandomIndex(false, 0, 0);
2215         total++;
2216         _safeMint(msg.sender, tokenId);
2217     }
2218 	
2219 	function code200Claim() public nonReentrant {
2220 		require(msg.sender == code200Address, "Not Code 200");
2221 		require(code200Minted == false, "Already minted!");
2222 		
2223 		code200Minted = true;
2224 		uint tokenId = getVRFRandomIndex(false, 0, 0);
2225         total++;
2226         _safeMint(msg.sender, tokenId);
2227     }
2228 	
2229 	function giveawaysClaim() public nonReentrant {
2230 		require(msg.sender == giveawaysAddress, "Not Giveaways wallet");
2231 		require(giveawaysMinted == false, "Already minted!");
2232 		
2233 		giveawaysMinted = true;
2234 
2235         for (uint i=0; i < 20; i++) {
2236             uint tokenId = getVRFRandomIndex(false, 0, 0);
2237             total++;
2238             _safeMint(msg.sender, tokenId);
2239         }
2240 		
2241     }
2242 	
2243     constructor() ERC721("Console NFT Cyber Upgrades", "Cnsl-NFT-U") VRFConsumerBase(
2244         0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,
2245         0x514910771AF9Ca656af840dff83E8264EcF986CA
2246     ) 
2247 	Ownable() {
2248         keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;	
2249         fee = 2 * (10**18);
2250 		
2251 		error404Address = 0x24Db9e45f6aC29175030A083B985C184A02c2d64;
2252 		code200Address = 0x1C0d3B190B18b4452BD4d0928D7f425eA9A0B3F9;
2253 		giveawaysAddress = 0x7e95c71bDF0E0526eA534Fb5191ceD999190c117;
2254 
2255         whitelistMintStart = 1644330600; // 8. february 2022 - 14:30 UTC
2256         publicMintStart = 1644359400; // 8. february 2022 - 23:30 UTC (+8 hours)
2257         
2258         rarities.push(3250); // Common - 65%
2259         rarities.push(1000); // Uncommon - 20%
2260         rarities.push(475); // Rare - 9.5%
2261         rarities.push(225); // Epic - 4.5%
2262         rarities.push(50); // Legendary - 1%
2263     }
2264 
2265 
2266 	////////////////////////// VRF /////////////////////////////
2267 	
2268     bytes32 internal keyHash;
2269     uint internal fee;
2270     uint internal randomResult;
2271     
2272     // VRF Functions
2273     function getRandomNumber() public onlyOwner returns (bytes32 requestId) {
2274         require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK!");
2275         return requestRandomness(keyHash, fee);
2276     }
2277     function fulfillRandomness(bytes32 requestId, uint randomness) internal override {
2278         randomResult = randomness;
2279     }
2280     function getRandomResult() public view onlyOwner returns (uint) {
2281         return randomResult;
2282     }
2283 
2284     // >>> Now, the VRF is stored in [uint internal randomResult]
2285     ////////////////////////// VRF /////////////////////////////
2286 
2287     /////////////////////// Token ID Generator ////////////////////////
2288 
2289     uint[maxTokens] internal indices;
2290     uint32 internal nonce;
2291 
2292     function getVRFRandomIndex(bool hasVault, uint vaultRarity, uint _userTokens) internal returns (uint) {
2293         require(randomResult != 0, "VRF Random Result has not been set!");
2294 
2295         // Get the random token ID
2296         uint _tokensRemaining = maxTokens - total; // require that this calculation is possible from all caller functions
2297         uint _maxIndex = _tokensRemaining == 0 ? 0 : _tokensRemaining - 1; // shorthand if for safety
2298         uint _rand = uint(keccak256(abi.encodePacked(randomResult, nonce, msg.sender, block.difficulty, block.timestamp))) % _tokensRemaining;
2299     
2300         uint _output = 0;
2301 
2302         _output = indices[_rand] != 0 ? indices[_rand] :_rand;
2303         indices[_rand] = indices[_maxIndex] == 0 ? _maxIndex : indices[_maxIndex];
2304 
2305         uint32 _nonceAdd = uint32(uint256(keccak256(abi.encodePacked(randomResult, nonce, msg.sender, block.difficulty, block.timestamp)))) % 10;
2306         nonce += _nonceAdd; 
2307 
2308 
2309         // Get the data from Percentage Contract
2310         PercentageGenerator percentage = PercentageGenerator(percentageContract);
2311         uint[] memory percentageArray = percentage.calculatePercentage(hasVault, vaultRarity, _userTokens);
2312 
2313         // Construct view array of 10k items to pick from
2314         // Because of rounding errors there might be close but not exactly 10k items, this should be safe
2315         uint totalItems;
2316         uint[] memory percentageNumbers = new uint[](5);
2317         for (uint i=0; i < percentageArray.length; i++) {
2318             totalItems += percentageArray[i];
2319             percentageNumbers[i] = totalItems;
2320         }
2321 
2322         // VRF guess the number in 10k items to get the rarity
2323         uint _randRarity = uint(keccak256(abi.encodePacked(randomResult, nonce, msg.sender, block.difficulty, block.timestamp))) % totalItems;
2324 
2325         uint rarityResult = 0; // Common as base
2326 
2327         // Get the rarity based on the VRF result
2328         if (_randRarity >= percentageNumbers[0] && _randRarity < percentageNumbers[1]) {
2329             rarityResult = 1; // Uncommon
2330         }
2331         if (_randRarity >= percentageNumbers[1] && _randRarity < percentageNumbers[2]) {
2332             rarityResult = 2; // Rare
2333         }
2334         if (_randRarity >= percentageNumbers[2] && _randRarity < percentageNumbers[3]) {
2335             rarityResult = 3; // Rpic
2336         }
2337         if (_randRarity >= percentageNumbers[3] && _randRarity <= percentageNumbers[4]) {
2338             rarityResult = 4; // Legendary
2339         }
2340 
2341         // If rarity no longer exist in the pool, give lower rarity
2342         if (rarities[rarityResult] > 0) {
2343             
2344             rarities[rarityResult]--;
2345 
2346             // There is still enough in the rarity pool
2347             // Assign rarity to this token ID
2348             rarity[_output] = rarityResult;
2349 
2350             // Assign starting level
2351             levels[_output] = 1;
2352         }
2353         else {
2354             // give other rarity, up or down
2355             rarity[_output] = pickOtherRarity(rarityResult);
2356         }
2357 
2358         return _output;
2359     }
2360 
2361     function pickOtherRarity(uint rarityResult) internal returns (uint) {
2362 		
2363 		bool direction; // default false = down
2364 		
2365         if (rarities[rarityResult] > 0) {
2366             return rarityResult;
2367         }
2368         else {
2369             if(rarityResult == 4){	
2370                 direction = false;
2371             }
2372             if(rarityResult == 0){
2373                 direction = true;
2374         	}
2375             if(direction == true){ 
2376                 rarityResult++;
2377             } else {
2378                 rarityResult--;
2379             }
2380             if( rarities[rarityResult] > 0 ) {	
2381                 return rarityResult;
2382             } else {
2383                 return pickOtherRarity(rarityResult);
2384             }
2385         }
2386 
2387     }
2388 
2389     /////////////////////// Token ID Generator ////////////////////////
2390 	
2391 	// Withdraw Ether
2392     function withdrawEther() public onlyOwner {
2393         payable(msg.sender).transfer(address(this).balance); 
2394     }
2395 
2396 }