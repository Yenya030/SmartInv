1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/AaveV2StablecoinCellar.sol": {
5       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC4626, ERC20, SafeTransferLib } from \"./base/ERC4626.sol\";\nimport { Multicall } from \"./base/Multicall.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { IAaveV2StablecoinCellar } from \"./interfaces/IAaveV2StablecoinCellar.sol\";\nimport { IAaveIncentivesController } from \"./interfaces/IAaveIncentivesController.sol\";\nimport { IStakedTokenV2 } from \"./interfaces/IStakedTokenV2.sol\";\nimport { ICurveSwaps } from \"./interfaces/ICurveSwaps.sol\";\nimport { ISushiSwapRouter } from \"./interfaces/ISushiSwapRouter.sol\";\nimport { IGravity } from \"./interfaces/IGravity.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { Math } from \"./utils/Math.sol\";\n\nimport \"./Errors.sol\";\n\n/**\n * @title Sommelier Aave V2 Stablecoin Cellar\n * @notice Dynamic ERC4626 that changes positions to always get the best yield for stablecoins on Aave.\n * @author Brian Le\n */\ncontract AaveV2StablecoinCellar is IAaveV2StablecoinCellar, ERC4626, Multicall, Ownable {\n    using SafeTransferLib for ERC20;\n    using Math for uint256;\n\n    // ======================================== POSITION STORAGE ========================================\n\n    /**\n     * @notice An interest-bearing derivative of the current asset returned by Aave for lending\n     *         the current asset. Represents cellar's portion of assets earning yield in a lending\n     *         position.\n     */\n    ERC20 public assetAToken;\n\n    /**\n     * @notice The decimals of precision used by the current position's asset.\n     * @dev Since some stablecoins don't use the standard 18 decimals of precision (eg. USDC and USDT),\n     *      we cache this to use for more efficient decimal conversions.\n     */\n    uint8 public assetDecimals;\n\n    /**\n     * @notice The total amount of assets held in the current position since the time of last accrual.\n     * @dev Unlike `totalAssets`, this includes locked yield that hasn't been distributed.\n     */\n    uint256 public totalBalance;\n\n    // ======================================== ACCRUAL CONFIG ========================================\n\n    /**\n     * @notice Period of time over which yield since the last accrual is linearly distributed to the cellar.\n     * @dev Net gains are distributed gradually over a period to prevent frontrunning and sandwich attacks.\n     *      Net losses are realized immediately otherwise users could time exits to sidestep losses.\n     */\n    uint32 public accrualPeriod = 7 days;\n\n    /**\n     * @notice Timestamp of when the last accrual occurred.\n     */\n    uint64 public lastAccrual;\n\n    /**\n     * @notice The amount of yield to be distributed to the cellar from the last accrual.\n     */\n    uint160 public maxLocked;\n\n    /**\n     * @notice The minimum level of total balance a strategy provider needs to achieve to receive\n     *         performance fees for the next accrual.\n     */\n    uint256 public highWatermarkBalance;\n\n    /**\n     * @notice Set the accrual period over which yield is distributed.\n     * @param newAccrualPeriod period of time in seconds of the new accrual period\n     */\n    function setAccrualPeriod(uint32 newAccrualPeriod) external onlyOwner {\n        // Ensure that the change is not disrupting a currently ongoing distribution of accrued yield.\n        if (totalLocked() > 0) revert STATE_AccrualOngoing();\n\n        emit AccrualPeriodChanged(accrualPeriod, newAccrualPeriod);\n\n        accrualPeriod = newAccrualPeriod;\n    }\n\n    // ========================================= FEES CONFIG =========================================\n\n    /**\n     *  @notice The percentage of yield accrued as performance fees.\n     *  @dev This should be a value out of 1e18 (ie. 1e18 represents 100%, 0 represents 0%).\n     */\n    uint64 public constant platformFee = 0.0025e18; // 0.25%\n\n    /**\n     * @notice The percentage of total assets accrued as platform fees over a year.\n     * @dev This should be a value out of 1e18 (ie. 1e18 represents 100%, 0 represents 0%).\n     */\n    uint64 public constant performanceFee = 0.1e18; // 10%\n\n    /**\n     * @notice Cosmos address of module that distributes fees, specified as a hex value.\n     * @dev The Gravity contract expects a 32-byte value formatted in a specific way.\n     */\n    bytes32 public feesDistributor = hex\"000000000000000000000000b813554b423266bbd4c16c32fa383394868c1f55\";\n\n    /**\n     * @notice Set the address of the fee distributor on the Sommelier chain.\n     * @dev IMPORTANT: Ensure that the address is formatted in the specific way that the Gravity contract\n     *      expects it to be.\n     * @param newFeesDistributor formatted address of the new fee distributor module\n     */\n    function setFeesDistributor(bytes32 newFeesDistributor) external onlyOwner {\n        emit FeesDistributorChanged(feesDistributor, newFeesDistributor);\n\n        feesDistributor = newFeesDistributor;\n    }\n\n    // ======================================== TRUST CONFIG ========================================\n\n    /**\n     * @notice Whether an asset position is trusted or not. Prevents cellar from rebalancing into an\n     *         asset that has not been trusted by the users. Trusting / distrusting of an asset is done\n     *         through governance.\n     */\n    mapping(ERC20 => bool) public isTrusted;\n\n    /**\n     * @notice Set the trust for a position.\n     * @param position address of an asset position on Aave (eg. FRAX, UST, FEI).\n     * @param trust whether to trust or distrust\n     */\n    function setTrust(ERC20 position, bool trust) external onlyOwner {\n        isTrusted[position] = trust;\n\n        // In the case that validators no longer trust the current position, pull all assets back\n        // into the cellar.\n        ERC20 currentPosition = asset;\n        if (trust == false && position == currentPosition) _emptyPosition(currentPosition);\n\n        emit TrustChanged(address(position), trust);\n    }\n\n    // ======================================== LIMITS CONFIG ========================================\n\n    /**\n     * @notice Maximum amount of assets that can be managed by the cellar. Denominated in the same decimals\n     *         as the current asset.\n     * @dev Set to `type(uint256).max` to have no limit.\n     */\n    uint256 public liquidityLimit;\n\n    /**\n     * @notice Maximum amount of assets per wallet. Denominated in the same decimals as the current asset.\n     * @dev Set to `type(uint256).max` to have no limit.\n     */\n    uint256 public depositLimit;\n\n    /**\n     * @notice Set the maximum liquidity that cellar can manage. Uses the same decimals as the current asset.\n     * @param newLimit amount of assets to set as the new limit\n     */\n    function setLiquidityLimit(uint256 newLimit) external onlyOwner {\n        emit LiquidityLimitChanged(liquidityLimit, newLimit);\n\n        liquidityLimit = newLimit;\n    }\n\n    /**\n     * @notice Set the per-wallet deposit limit. Uses the same decimals as the current asset.\n     * @param newLimit amount of assets to set as the new limit\n     */\n    function setDepositLimit(uint256 newLimit) external onlyOwner {\n        emit DepositLimitChanged(depositLimit, newLimit);\n\n        depositLimit = newLimit;\n    }\n\n    // ======================================== EMERGENCY LOGIC ========================================\n\n    /**\n     * @notice Whether or not the contract is shutdown in case of an emergency.\n     */\n    bool public isShutdown;\n\n    /**\n     * @notice Prevent a function from being called during a shutdown.\n     */\n    modifier whenNotShutdown() {\n        if (isShutdown) revert STATE_ContractShutdown();\n\n        _;\n    }\n\n    /**\n     * @notice Shutdown the cellar. Used in an emergency or if the cellar has been deprecated.\n     * @param emptyPosition whether to pull all assets back into the cellar from the current position\n     */\n    function initiateShutdown(bool emptyPosition) external whenNotShutdown onlyOwner {\n        // Pull all assets from a position.\n        if (emptyPosition) _emptyPosition(asset);\n\n        isShutdown = true;\n\n        emit ShutdownInitiated(emptyPosition);\n    }\n\n    /**\n     * @notice Restart the cellar.\n     */\n    function liftShutdown() external onlyOwner {\n        isShutdown = false;\n\n        emit ShutdownLifted();\n    }\n\n    // ======================================== INITIALIZATION ========================================\n\n    /**\n     * @notice Curve Registry Exchange contract. Used for rebalancing positions.\n     */\n    ICurveSwaps public immutable curveRegistryExchange; // 0x81C46fECa27B31F3ADC2b91eE4be9717d1cd3DD7\n\n    /**\n     * @notice SushiSwap Router V2 contract. Used for reinvesting rewards back into the current position.\n     */\n    ISushiSwapRouter public immutable sushiswapRouter; // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\n\n    /**\n     * @notice Aave Lending Pool V2 contract. Used to deposit and withdraw from the current position.\n     */\n    ILendingPool public immutable lendingPool; // 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9\n\n    /**\n     * @notice Aave Incentives Controller V2 contract. Used to claim and unstake rewards to reinvest.\n     */\n    IAaveIncentivesController public immutable incentivesController; // 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5\n\n    /**\n     * @notice Cosmos Gravity Bridge contract. Used to transfer fees to `feeDistributor` on the Sommelier chain.\n     */\n    IGravity public immutable gravityBridge; // 0x69592e6f9d21989a043646fE8225da2600e5A0f7\n\n    /**\n     * @notice stkAAVE address. Used to swap rewards to the current asset to reinvest.\n     */\n    IStakedTokenV2 public immutable stkAAVE; // 0x4da27a545c0c5B758a6BA100e3a049001de870f5\n\n    /**\n     * @notice AAVE address. Used to swap rewards to the current asset to reinvest.\n     */\n    ERC20 public immutable AAVE; // 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\n\n    /**\n     * @notice WETH address. Used to swap rewards to the current asset to reinvest.\n     */\n    ERC20 public immutable WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n\n    /**\n     * @dev Owner will be set to the Gravity Bridge, which relays instructions from the Steward\n     *      module to the cellars.\n     *      https://github.com/PeggyJV/steward\n     *      https://github.com/cosmos/gravity-bridge/blob/main/solidity/contracts/Gravity.sol\n     * @param _asset current asset managed by the cellar\n     * @param _approvedPositions list of approved positions to start with\n     * @param _curveRegistryExchange Curve registry exchange\n     * @param _sushiswapRouter Sushiswap V2 router address\n     * @param _lendingPool Aave V2 lending pool address\n     * @param _incentivesController _incentivesController\n     * @param _gravityBridge Cosmos Gravity Bridge address\n     * @param _stkAAVE stkAAVE address\n     * @param _AAVE AAVE address\n     * @param _WETH WETH address\n     */\n    constructor(\n        ERC20 _asset,\n        ERC20[] memory _approvedPositions,\n        ICurveSwaps _curveRegistryExchange,\n        ISushiSwapRouter _sushiswapRouter,\n        ILendingPool _lendingPool,\n        IAaveIncentivesController _incentivesController,\n        IGravity _gravityBridge,\n        IStakedTokenV2 _stkAAVE,\n        ERC20 _AAVE,\n        ERC20 _WETH\n    ) ERC4626(_asset, \"Sommelier Aave V2 Stablecoin Cellar LP Token\", \"aave2-CLR-S\", 18) {\n        // Initialize immutables.\n        curveRegistryExchange = _curveRegistryExchange;\n        sushiswapRouter = _sushiswapRouter;\n        lendingPool = _lendingPool;\n        incentivesController = _incentivesController;\n        gravityBridge = _gravityBridge;\n        stkAAVE = _stkAAVE;\n        AAVE = _AAVE;\n        WETH = _WETH;\n\n        // Initialize asset.\n        isTrusted[_asset] = true;\n        uint8 _assetDecimals = _updatePosition(_asset);\n\n        // Initialize limits.\n        uint256 powOfAssetDecimals = 10**_assetDecimals;\n        liquidityLimit = 5_000_000 * powOfAssetDecimals;\n        depositLimit = type(uint256).max;\n\n        // Initialize approved positions.\n        for (uint256 i; i < _approvedPositions.length; i++) isTrusted[_approvedPositions[i]] = true;\n\n        // Initialize starting timestamp for first accrual.\n        lastAccrual = uint32(block.timestamp);\n\n        // Transfer ownership to the Gravity Bridge.\n        transferOwnership(address(_gravityBridge));\n    }\n\n    // ============================================ CORE LOGIC ============================================\n\n    function deposit(uint256 assets, address receiver) public override returns (uint256 shares) {\n        // Check that the deposit is not restricted by a deposit limit or liquidity limit and\n        // prevent deposits during a shutdown.\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) revert USR_DepositRestricted(assets, maxAssets);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        ERC20 cellarAsset = asset;\n        uint256 assetsBeforeDeposit = cellarAsset.balanceOf(address(this));\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Check that the balance transferred is what was expected.\n        uint256 assetsReceived = cellarAsset.balanceOf(address(this)) - assetsBeforeDeposit;\n        if (assetsReceived != assets) revert STATE_AssetUsesFeeOnTransfer(address(cellarAsset));\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public override returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Check that the deposit is not restricted by a deposit limit or liquidity limit and\n        // prevent deposits during a shutdown.\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) revert USR_DepositRestricted(assets, maxAssets);\n\n        ERC20 cellarAsset = asset;\n        uint256 assetsBeforeDeposit = cellarAsset.balanceOf(address(this));\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Check that the balance transferred is what was expected.\n        uint256 assetsReceived = cellarAsset.balanceOf(address(this)) - assetsBeforeDeposit;\n        if (assetsReceived != assets) revert STATE_AssetUsesFeeOnTransfer(address(cellarAsset));\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Check if holding position has enough funds to cover the withdraw and only pull from the\n     *      current lending position if needed.\n     * @param assets amount of assets to withdraw\n     */\n    function beforeWithdraw(\n        uint256 assets,\n        uint256,\n        address,\n        address\n    ) internal override {\n        ERC20 currentPosition = asset;\n        uint256 holdings = totalHoldings();\n\n        // Only withdraw if not enough assets in the holding pool.\n        if (assets > holdings) {\n            uint256 withdrawnAssets = _withdrawFromPosition(currentPosition, assets - holdings);\n\n            totalBalance -= withdrawnAssets;\n            highWatermarkBalance -= withdrawnAssets;\n        }\n    }\n\n    // ======================================= ACCOUNTING LOGIC =======================================\n\n    /**\n     * @notice The total amount of assets in the cellar.\n     * @dev Excludes locked yield that hasn't been distributed.\n     */\n    function totalAssets() public view override returns (uint256) {\n        return totalBalance + totalHoldings() - totalLocked();\n    }\n\n    /**\n     * @notice The total amount of assets in holding position.\n     */\n    function totalHoldings() public view returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n     * @notice The total amount of locked yield still being distributed.\n     */\n    function totalLocked() public view returns (uint256) {\n        // Get the last accrual and accrual period.\n        uint256 previousAccrual = lastAccrual;\n        uint256 accrualInterval = accrualPeriod;\n\n        // If the accrual period has passed, there is no locked yield.\n        if (block.timestamp >= previousAccrual + accrualInterval) return 0;\n\n        // Get the maximum amount we could return.\n        uint256 maxLockedYield = maxLocked;\n\n        // Get how much yield remains locked.\n        return maxLockedYield - (maxLockedYield * (block.timestamp - previousAccrual)) / accrualInterval;\n    }\n\n    /**\n     * @notice The amount of assets that the cellar would exchange for the amount of shares provided.\n     * @param shares amount of shares to convert\n     * @return assets the shares can be exchanged for\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 totalShares = totalSupply;\n\n        assets = totalShares == 0\n            ? shares.changeDecimals(18, assetDecimals)\n            : shares.mulDivDown(totalAssets(), totalShares);\n    }\n\n    /**\n     * @notice The amount of shares that the cellar would exchange for the amount of assets provided.\n     * @param assets amount of assets to convert\n     * @return shares the assets can be exchanged for\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 totalShares = totalSupply;\n\n        shares = totalShares == 0\n            ? assets.changeDecimals(assetDecimals, 18)\n            : assets.mulDivDown(totalShares, totalAssets());\n    }\n\n    /**\n     * @notice Simulate the effects of minting shares at the current block, given current on-chain conditions.\n     * @param shares amount of shares to mint\n     * @return assets that will be deposited\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 totalShares = totalSupply;\n\n        assets = totalShares == 0\n            ? shares.changeDecimals(18, assetDecimals)\n            : shares.mulDivUp(totalAssets(), totalShares);\n    }\n\n    /**\n     * @notice Simulate the effects of withdrawing assets at the current block, given current on-chain conditions.\n     * @param assets amount of assets to withdraw\n     * @return shares that will be redeemed\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        uint256 totalShares = totalSupply;\n\n        shares = totalShares == 0\n            ? assets.changeDecimals(assetDecimals, 18)\n            : assets.mulDivUp(totalShares, totalAssets());\n    }\n\n    // ========================================= LIMITS LOGIC =========================================\n\n    /**\n     * @notice Total amount of assets that can be deposited for a user.\n     * @param receiver address of account that would receive the shares\n     * @return assets maximum amount of assets that can be deposited\n     */\n    function maxDeposit(address receiver) public view override returns (uint256 assets) {\n        if (isShutdown) return 0;\n\n        uint256 asssetDepositLimit = depositLimit;\n        uint256 asssetLiquidityLimit = liquidityLimit;\n        if (asssetDepositLimit == type(uint256).max && asssetLiquidityLimit == type(uint256).max)\n            return type(uint256).max;\n\n        (uint256 leftUntilDepositLimit, uint256 leftUntilLiquidityLimit) = _getAssetsLeftUntilLimits(\n            asssetDepositLimit,\n            asssetLiquidityLimit,\n            receiver\n        );\n\n        // Only return the more relevant of the two.\n        assets = Math.min(leftUntilDepositLimit, leftUntilLiquidityLimit);\n    }\n\n    /**\n     * @notice Total amount of shares that can be minted for a user.\n     * @param receiver address of account that would receive the shares\n     * @return shares maximum amount of shares that can be minted\n     */\n    function maxMint(address receiver) public view override returns (uint256 shares) {\n        if (isShutdown) return 0;\n\n        uint256 asssetDepositLimit = depositLimit;\n        uint256 asssetLiquidityLimit = liquidityLimit;\n        if (asssetDepositLimit == type(uint256).max && asssetLiquidityLimit == type(uint256).max)\n            return type(uint256).max;\n\n        (uint256 leftUntilDepositLimit, uint256 leftUntilLiquidityLimit) = _getAssetsLeftUntilLimits(\n            asssetDepositLimit,\n            asssetLiquidityLimit,\n            receiver\n        );\n\n        // Only return the more relevant of the two.\n        shares = convertToShares(Math.min(leftUntilDepositLimit, leftUntilLiquidityLimit));\n    }\n\n    function _getAssetsLeftUntilLimits(\n        uint256 asssetDepositLimit,\n        uint256 asssetLiquidityLimit,\n        address receiver\n    ) internal view returns (uint256 leftUntilDepositLimit, uint256 leftUntilLiquidityLimit) {\n        uint256 totalAssetsIncludingUnrealizedGains = assetAToken.balanceOf(address(this)) + totalHoldings();\n\n        // Convert receiver's shares to assets using total assets including locked yield.\n        uint256 receiverShares = balanceOf[receiver];\n        uint256 totalShares = totalSupply;\n        uint256 maxWithdrawableByReceiver = totalShares == 0\n            ? receiverShares\n            : receiverShares.mulDivDown(totalAssetsIncludingUnrealizedGains, totalShares);\n\n        // Get the maximum amount of assets that can be deposited until limits are reached.\n        leftUntilDepositLimit = asssetDepositLimit.subMinZero(maxWithdrawableByReceiver);\n        leftUntilLiquidityLimit = asssetLiquidityLimit.subMinZero(totalAssetsIncludingUnrealizedGains);\n    }\n\n    // ========================================== ACCRUAL LOGIC ==========================================\n\n    /**\n     * @notice Accrue yield, platform fees, and performance fees.\n     * @dev Since this is the function responsible for distributing yield to shareholders and\n     *      updating the cellar's balance, it is important to make sure it gets called regularly.\n     */\n    function accrue() public {\n        uint256 totalLockedYield = totalLocked();\n\n        // Without this check, malicious actors could do a slowdown attack on the distribution of\n        // yield by continuously resetting the accrual period.\n        if (msg.sender != owner() && totalLockedYield > 0) revert STATE_AccrualOngoing();\n\n        // Compute and store current exchange rate between assets and shares for gas efficiency.\n        uint256 oneAsset = 10**assetDecimals;\n        uint256 exchangeRate = convertToShares(oneAsset);\n\n        // Get balance since last accrual and updated balance for this accrual.\n        uint256 balanceThisAccrual = assetAToken.balanceOf(address(this));\n\n        // Calculate platform fees accrued.\n        uint256 elapsedTime = block.timestamp - lastAccrual;\n        uint256 platformFeeInAssets = (balanceThisAccrual * elapsedTime * platformFee) / 1e18 / 365 days;\n        uint256 platformFees = platformFeeInAssets.mulDivDown(exchangeRate, oneAsset); // Convert to shares.\n\n        // Calculate performance fees accrued.\n        uint256 yield = balanceThisAccrual.subMinZero(highWatermarkBalance);\n        uint256 performanceFeeInAssets = yield.mulWadDown(performanceFee);\n        uint256 performanceFees = performanceFeeInAssets.mulDivDown(exchangeRate, oneAsset); // Convert to shares.\n\n        // Mint accrued fees as shares.\n        _mint(address(this), platformFees + performanceFees);\n\n        // Do not count assets set aside for fees as yield. Allows fees to be immediately withdrawable.\n        maxLocked = uint160(totalLockedYield + yield.subMinZero(platformFeeInAssets + performanceFeeInAssets));\n\n        lastAccrual = uint32(block.timestamp);\n\n        totalBalance = balanceThisAccrual;\n\n        // Only update high watermark if balance greater than last high watermark.\n        if (balanceThisAccrual > highWatermarkBalance) highWatermarkBalance = balanceThisAccrual;\n\n        emit Accrual(platformFees, performanceFees, yield);\n    }\n\n    // ========================================= POSITION LOGIC =========================================\n\n    /**\n     * @notice Pushes assets into the current Aave lending position.\n     * @param assets amount of assets to enter into the current position\n     */\n    function enterPosition(uint256 assets) public whenNotShutdown onlyOwner {\n        ERC20 currentPosition = asset;\n\n        totalBalance += assets;\n\n        // Without this line, assets entered into Aave would be counted as gains during the next\n        // accrual.\n        highWatermarkBalance += assets;\n\n        _depositIntoPosition(currentPosition, assets);\n\n        emit EnterPosition(address(currentPosition), assets);\n    }\n\n    /**\n     * @notice Pushes all assets in holding into the current Aave lending position.\n     */\n    function enterPosition() external {\n        enterPosition(totalHoldings());\n    }\n\n    /**\n     * @notice Pulls assets from the current Aave lending position.\n     * @param assets amount of assets to exit from the current position\n     */\n    function exitPosition(uint256 assets) public whenNotShutdown onlyOwner {\n        ERC20 currentPosition = asset;\n\n        uint256 withdrawnAssets = _withdrawFromPosition(currentPosition, assets);\n\n        totalBalance -= withdrawnAssets;\n\n        // Without this line, assets exited from Aave would be counted as losses during the next\n        // accrual.\n        highWatermarkBalance -= withdrawnAssets;\n\n        emit ExitPosition(address(currentPosition), assets);\n    }\n\n    /**\n     * @notice Pulls all assets from the current Aave lending position.\n     * @dev Strategy providers should not assume the position is empty after this call. If there is\n     *      unrealized yield, that will still remain in the position. To completely empty the cellar,\n     *      multicall accrue and this.\n     */\n    function exitPosition() external {\n        exitPosition(totalBalance);\n    }\n\n    /**\n     * @notice Rebalances current assets into a new position.\n     * @param route array of [initial token, pool, token, pool, token, ...] that specifies the swap route on Curve.\n     * @param swapParams multidimensional array of [i, j, swap type] where i and j are the correct\n                         values for the n'th pool in `_route` and swap type should be 1 for a\n                         stableswap `exchange`, 2 for stableswap `exchange_underlying`, 3 for a\n                         cryptoswap `exchange`, 4 for a cryptoswap `exchange_underlying` and 5 for\n                         Polygon factory metapools `exchange_underlying`\n     * @param minAssetsOut minimum amount of assets received after swap\n     */\n    function rebalance(\n        address[9] memory route,\n        uint256[3][4] memory swapParams,\n        uint256 minAssetsOut\n    ) external whenNotShutdown onlyOwner {\n        // Retrieve the last token in the route and store it as the new asset position.\n        ERC20 newPosition;\n        for (uint256 i; ; i += 2) {\n            if (i == 8 || route[i + 1] == address(0)) {\n                newPosition = ERC20(route[i]);\n                break;\n            }\n        }\n\n        // Ensure the asset position is trusted.\n        if (!isTrusted[newPosition]) revert USR_UntrustedPosition(address(newPosition));\n\n        ERC20 oldPosition = asset;\n\n        // Doesn't make sense to rebalance into the same position.\n        if (newPosition == oldPosition) revert USR_SamePosition(address(oldPosition));\n\n        // Store this for later when updating total balance.\n        uint256 totalAssetsInHolding = totalHoldings();\n        uint256 totalBalanceIncludingHoldings = totalBalance + totalAssetsInHolding;\n\n        // Pull any assets in the lending position back in to swap everything into the new position.\n        uint256 assetsBeforeSwap = assetAToken.balanceOf(address(this)) > 0\n            ? _withdrawFromPosition(oldPosition, type(uint256).max) + totalAssetsInHolding\n            : totalAssetsInHolding;\n\n        // Perform stablecoin swap using Curve.\n        oldPosition.safeApprove(address(curveRegistryExchange), assetsBeforeSwap);\n        uint256 assetsAfterSwap = curveRegistryExchange.exchange_multiple(\n            route,\n            swapParams,\n            assetsBeforeSwap,\n            minAssetsOut\n        );\n\n        uint8 oldPositionDecimals = assetDecimals;\n\n        // Updates state for new position and check that Aave supports it.\n        uint8 newPositionDecimals = _updatePosition(newPosition);\n\n        // Deposit all newly swapped assets into Aave.\n        _depositIntoPosition(newPosition, assetsAfterSwap);\n\n        // Update maximum locked yield to scale accordingly to the decimals of the new asset.\n        maxLocked = uint160(uint256(maxLocked).changeDecimals(oldPositionDecimals, newPositionDecimals));\n\n        // Update the cellar's balance. If the unrealized gains before rebalancing exceed the losses\n        // from the swap, then losses will be taken from the unrealized gains during next accrual\n        // and this rebalance will not effect the exchange rate of shares to assets. Otherwise, the\n        // losses from this rebalance will be realized and factored into the new balance.\n        uint256 newTotalBalance = Math.min(\n            totalBalanceIncludingHoldings.changeDecimals(oldPositionDecimals, newPositionDecimals),\n            assetsAfterSwap\n        );\n\n        totalBalance = newTotalBalance;\n\n        // Keep high watermark at level it should be at before rebalance because otherwise swap\n        // losses from this rebalance would not be counted in the next accrual. Include holdings\n        // into new high watermark balance as those have all been deposited into Aave now.\n        highWatermarkBalance = (highWatermarkBalance + totalAssetsInHolding).changeDecimals(\n            oldPositionDecimals,\n            newPositionDecimals\n        );\n\n        emit Rebalance(address(oldPosition), address(newPosition), newTotalBalance);\n    }\n\n    // ======================================= REINVEST LOGIC =======================================\n\n    /**\n     * @notice Claim rewards from Aave and begin cooldown period to unstake them.\n     * @return rewards amount of stkAAVE rewards claimed from Aave\n     */\n    function claimAndUnstake() external onlyOwner returns (uint256 rewards) {\n        // Necessary to do as `claimRewards` accepts a dynamic array as first param.\n        address[] memory aToken = new address[](1);\n        aToken[0] = address(assetAToken);\n\n        // Claim all stkAAVE rewards.\n        rewards = incentivesController.claimRewards(aToken, type(uint256).max, address(this));\n\n        // Begin the 10 day cooldown period for unstaking stkAAVE for AAVE.\n        stkAAVE.cooldown();\n\n        emit ClaimAndUnstake(rewards);\n    }\n\n    /**\n     * @notice Reinvest rewards back into cellar's current position.\n     * @dev Must be called within 2 day unstake period 10 days after `claimAndUnstake` was run.\n     * @param minAssetsOut minimum amount of assets to receive after swapping AAVE to the current asset\n     */\n    function reinvest(uint256 minAssetsOut) external onlyOwner {\n        // Redeems the cellar's stkAAVE rewards for AAVE.\n        stkAAVE.redeem(address(this), type(uint256).max);\n\n        // Get the amount of AAVE rewards going in to be swap for the current asset.\n        uint256 rewardsIn = AAVE.balanceOf(address(this));\n\n        ERC20 currentAsset = asset;\n\n        // Specify the swap path from AAVE -> WETH -> current asset.\n        address[] memory path = new address[](3);\n        path[0] = address(AAVE);\n        path[1] = address(WETH);\n        path[2] = address(currentAsset);\n\n        // Perform a multihop swap using Sushiswap.\n        AAVE.safeApprove(address(sushiswapRouter), rewardsIn);\n        uint256[] memory amounts = sushiswapRouter.swapExactTokensForTokens(\n            rewardsIn,\n            minAssetsOut,\n            path,\n            address(this),\n            block.timestamp + 60\n        );\n\n        uint256 assetsOut = amounts[amounts.length - 1];\n\n        // In the case of a shutdown, we just may want to redeem any leftover rewards for users to\n        // claim but without entering them back into a position in case the position has been\n        // exited. Also, for the purposes of performance fee calculation, we count reinvested\n        // rewards as yield so do not update balance.\n        if (!isShutdown) _depositIntoPosition(currentAsset, assetsOut);\n\n        emit Reinvest(address(currentAsset), rewardsIn, assetsOut);\n    }\n\n    // ========================================= FEES LOGIC =========================================\n\n    /**\n     * @notice Transfer accrued fees to the Sommelier chain to distribute.\n     * @dev Fees are accrued as shares and redeemed upon transfer.\n     */\n    function sendFees() external onlyOwner {\n        // Redeem our fee shares for assets to send to the fee distributor module.\n        uint256 totalFees = balanceOf[address(this)];\n        uint256 assets = previewRedeem(totalFees);\n        require(assets != 0, \"ZERO_ASSETS\");\n\n        // Only withdraw assets from position if the holding position does not contain enough funds.\n        // Pass in only the amount of assets withdrawn, the rest doesn't matter.\n        beforeWithdraw(assets, 0, address(0), address(0));\n\n        _burn(address(this), totalFees);\n\n        // Transfer assets to a fee distributor on the Sommelier chain.\n        ERC20 positionAsset = asset;\n        positionAsset.safeApprove(address(gravityBridge), assets);\n        gravityBridge.sendToCosmos(address(positionAsset), feesDistributor, assets);\n\n        emit SendFees(totalFees, assets);\n    }\n\n    // ====================================== RECOVERY LOGIC ======================================\n\n    /**\n     * @notice Sweep tokens that are not suppose to be in the cellar.\n     * @dev This may be used in case the wrong tokens are accidentally sent.\n     * @param token address of token to transfer out of this cellar\n     * @param to address to transfer sweeped tokens to\n     */\n    function sweep(ERC20 token, address to) external onlyOwner {\n        // Prevent sweeping of assets managed by the cellar and shares minted to the cellar as fees.\n        if (token == asset || token == assetAToken || token == this || address(token) == address(stkAAVE))\n            revert USR_ProtectedAsset(address(token));\n\n        // Transfer out tokens in this cellar that shouldn't be here.\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n\n        emit Sweep(address(token), to, amount);\n    }\n\n    // ===================================== HELPER FUNCTIONS =====================================\n\n    /**\n     * @notice Deposits cellar holdings into an Aave lending position.\n     * @param position the address of the asset position\n     * @param assets the amount of assets to deposit\n     */\n    function _depositIntoPosition(ERC20 position, uint256 assets) internal {\n        // Deposit assets into Aave position.\n        position.safeApprove(address(lendingPool), assets);\n        lendingPool.deposit(address(position), assets, address(this), 0);\n\n        emit DepositIntoPosition(address(position), assets);\n    }\n\n    /**\n     * @notice Withdraws assets from an Aave lending position.\n     * @dev The assets withdrawn differs from the assets specified if withdrawing `type(uint256).max`.\n     * @param position the address of the asset position\n     * @param assets amount of assets to withdraw\n     * @return withdrawnAssets amount of assets actually withdrawn\n     */\n    function _withdrawFromPosition(ERC20 position, uint256 assets) internal returns (uint256 withdrawnAssets) {\n        // Withdraw assets from Aave position.\n        withdrawnAssets = lendingPool.withdraw(address(position), assets, address(this));\n\n        emit WithdrawFromPosition(address(position), withdrawnAssets);\n    }\n\n    /**\n     * @notice Pull all assets from the current lending position on Aave back into holding.\n     * @param position the address of the asset position to pull from\n     */\n    function _emptyPosition(ERC20 position) internal {\n        uint256 totalPositionBalance = totalBalance;\n\n        if (totalPositionBalance > 0) {\n            accrue();\n\n            _withdrawFromPosition(position, type(uint256).max);\n\n            delete totalBalance;\n            delete highWatermarkBalance;\n        }\n    }\n\n    /**\n     * @notice Update state variables related to the current position.\n     * @dev Be aware that when updating to an asset that uses less decimals than the previous\n     *      asset (eg. DAI -> USDC), `depositLimit` and `liquidityLimit` will lose some precision\n     *      due to truncation.\n     * @param newPosition address of the new asset being managed by the cellar\n     */\n    function _updatePosition(ERC20 newPosition) internal returns (uint8 newAssetDecimals) {\n        // Retrieve the aToken that will represent the cellar's new position on Aave.\n        (, , , , , , , address aTokenAddress, , , , ) = lendingPool.getReserveData(address(newPosition));\n\n        // If the address is not null, it is supported by Aave.\n        if (aTokenAddress == address(0)) revert USR_UnsupportedPosition(address(newPosition));\n\n        // Update the decimals used by limits if necessary.\n        uint8 oldAssetDecimals = assetDecimals;\n        newAssetDecimals = newPosition.decimals();\n\n        // Ensure the decimals of precision of the new position uses will not break the cellar.\n        if (newAssetDecimals > 18) revert USR_TooManyDecimals(newAssetDecimals, 18);\n\n        // Ignore if decimals are the same or if it is the first time initializing a position.\n        if (oldAssetDecimals != 0 && oldAssetDecimals != newAssetDecimals) {\n            uint256 asssetDepositLimit = depositLimit;\n            uint256 asssetLiquidityLimit = liquidityLimit;\n            if (asssetDepositLimit != type(uint256).max)\n                depositLimit = asssetDepositLimit.changeDecimals(oldAssetDecimals, newAssetDecimals);\n\n            if (asssetLiquidityLimit != type(uint256).max)\n                liquidityLimit = asssetLiquidityLimit.changeDecimals(oldAssetDecimals, newAssetDecimals);\n        }\n\n        // Update state related to the current position.\n        asset = newPosition;\n        assetDecimals = newAssetDecimals;\n        assetAToken = ERC20(aTokenAddress);\n    }\n}\n"
6     },
7     "src/base/ERC4626.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Math } from \"../utils/Math.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using Math for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        beforeDeposit(assets, shares, receiver);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares, receiver);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        beforeDeposit(assets, shares, receiver);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares, receiver);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares, receiver, owner);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(assets, shares, receiver, owner);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares, receiver, owner);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(assets, shares, receiver, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeDeposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual {}\n\n    function afterDeposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual {}\n\n    function beforeWithdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual {}\n\n    function afterWithdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual {}\n}\n"
9     },
10     "src/base/Multicall.sol": {
11       "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport { IMulticall } from \"../interfaces/IMulticall.sol\";\n\n/**\n * @title Multicall\n * @notice Enables calling multiple methods in a single call to the contract\n * From: https://github.com/Uniswap/v3-periphery/contracts/base/Multicall.sol\n */\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                // solhint-disable-next-line reason-string\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
12     },
13     "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
15     },
16     "src/interfaces/IAaveV2StablecoinCellar.sol": {
17       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { IAaveIncentivesController } from \"../interfaces/IAaveIncentivesController.sol\";\nimport { IStakedTokenV2 } from \"../interfaces/IStakedTokenV2.sol\";\nimport { ICurveSwaps } from \"../interfaces/ICurveSwaps.sol\";\nimport { ISushiSwapRouter } from \"../interfaces/ISushiSwapRouter.sol\";\nimport { ILendingPool } from \"../interfaces/ILendingPool.sol\";\nimport { IGravity } from \"../interfaces/IGravity.sol\";\n\n/**\n * @title Interface for AaveV2StablecoinCellar\n */\ninterface IAaveV2StablecoinCellar {\n    // ======================================== POSITION STORAGE ========================================\n\n    function assetAToken() external view returns (ERC20);\n\n    function assetDecimals() external view returns (uint8);\n\n    function totalBalance() external view returns (uint256);\n\n    // ========================================= ACCRUAL CONFIG =========================================\n\n    /**\n     * @notice Emitted when accrual period is changed.\n     * @param oldPeriod time the period was changed from\n     * @param newPeriod time the period was changed to\n     */\n    event AccrualPeriodChanged(uint32 oldPeriod, uint32 newPeriod);\n\n    function accrualPeriod() external view returns (uint32);\n\n    function lastAccrual() external view returns (uint64);\n\n    function maxLocked() external view returns (uint160);\n\n    function setAccrualPeriod(uint32 newAccrualPeriod) external;\n\n    // =========================================== FEES CONFIG ===========================================\n\n    /**\n     * @notice Emitted when platform fees is changed.\n     * @param oldPlatformFee value platform fee was changed from\n     * @param newPlatformFee value platform fee was changed to\n     */\n    event PlatformFeeChanged(uint64 oldPlatformFee, uint64 newPlatformFee);\n\n    /**\n     * @notice Emitted when performance fees is changed.\n     * @param oldPerformanceFee value performance fee was changed from\n     * @param newPerformanceFee value performance fee was changed to\n     */\n    event PerformanceFeeChanged(uint64 oldPerformanceFee, uint64 newPerformanceFee);\n\n    /**\n     * @notice Emitted when fees distributor is changed.\n     * @param oldFeesDistributor address of fee distributor was changed from\n     * @param newFeesDistributor address of fee distributor was changed to\n     */\n    event FeesDistributorChanged(bytes32 oldFeesDistributor, bytes32 newFeesDistributor);\n\n    function platformFee() external view returns (uint64);\n\n    function performanceFee() external view returns (uint64);\n\n    function feesDistributor() external view returns (bytes32);\n\n    function setFeesDistributor(bytes32 newFeesDistributor) external;\n\n    // ======================================== TRUST CONFIG ========================================\n\n    /**\n     * @notice Emitted when trust for a position is changed.\n     * @param position address of the position that trust was changed for\n     * @param trusted whether the position was trusted or untrusted\n     */\n    event TrustChanged(address indexed position, bool trusted);\n\n    function isTrusted(ERC20) external view returns (bool);\n\n    function setTrust(ERC20 position, bool trust) external;\n\n    // ======================================== LIMITS CONFIG ========================================\n\n    /**\n     * @notice Emitted when the liquidity limit is changed.\n     * @param oldLimit amount the limit was changed from\n     * @param newLimit amount the limit was changed to\n     */\n    event LiquidityLimitChanged(uint256 oldLimit, uint256 newLimit);\n\n    /**\n     * @notice Emitted when the deposit limit is changed.\n     * @param oldLimit amount the limit was changed from\n     * @param newLimit amount the limit was changed to\n     */\n    event DepositLimitChanged(uint256 oldLimit, uint256 newLimit);\n\n    function liquidityLimit() external view returns (uint256);\n\n    function depositLimit() external view returns (uint256);\n\n    function setLiquidityLimit(uint256 newLimit) external;\n\n    function setDepositLimit(uint256 newLimit) external;\n\n    // ======================================== EMERGENCY LOGIC ========================================\n\n    /**\n     * @notice Emitted when cellar is shutdown.\n     * @param emptyPositions whether the current position(s) was exited\n     */\n    event ShutdownInitiated(bool emptyPositions);\n\n    /**\n     * @notice Emitted when shutdown is lifted.\n     */\n    event ShutdownLifted();\n\n    function isShutdown() external view returns (bool);\n\n    function initiateShutdown(bool emptyPosition) external;\n\n    function liftShutdown() external;\n\n    // ========================================== IMMUTABLES ==========================================\n\n    function curveRegistryExchange() external view returns (ICurveSwaps);\n\n    function sushiswapRouter() external view returns (ISushiSwapRouter);\n\n    function lendingPool() external view returns (ILendingPool);\n\n    function incentivesController() external view returns (IAaveIncentivesController);\n\n    function gravityBridge() external view returns (IGravity);\n\n    function stkAAVE() external view returns (IStakedTokenV2);\n\n    function AAVE() external view returns (ERC20);\n\n    function WETH() external view returns (ERC20);\n\n    // ======================================= ACCOUNTING LOGIC =======================================\n\n    function totalHoldings() external view returns (uint256);\n\n    function totalLocked() external view returns (uint256);\n\n    // ======================================== ACCRUAL LOGIC ========================================\n\n    /**\n     * @notice Emitted on accruals.\n     * @param platformFees amount of shares minted as platform fees this accrual\n     * @param performanceFees amount of shares minted as performance fees this accrual\n     * @param yield amount of assets accrued as yield that will be distributed over this accrual period\n     */\n    event Accrual(uint256 platformFees, uint256 performanceFees, uint256 yield);\n\n    /**\n     * @notice Accrue yield, platform fees, and performance fees.\n     * @dev Since this is the function responsible for distributing yield to shareholders and\n     *      updating the cellar's balance, it is important to make sure it gets called regularly.\n     */\n    function accrue() external;\n\n    // ========================================= POSITION LOGIC =========================================\n    /**\n     * @notice Emitted on deposit to Aave.\n     * @param position the address of the position\n     * @param assets the amount of assets to deposit\n     */\n    event DepositIntoPosition(address indexed position, uint256 assets);\n\n    /**\n     * @notice Emitted on withdraw from Aave.\n     * @param position the address of the position\n     * @param assets the amount of assets to withdraw\n     */\n    event WithdrawFromPosition(address indexed position, uint256 assets);\n\n    /**\n     * @notice Emitted upon entering assets into the current position on Aave.\n     * @param position the address of the asset being pushed into the current position\n     * @param assets amount of assets being pushed\n     */\n    event EnterPosition(address indexed position, uint256 assets);\n\n    /**\n     * @notice Emitted upon exiting assets from the current position on Aave.\n     * @param position the address of the asset being pulled from the current position\n     * @param assets amount of assets being pulled\n     */\n    event ExitPosition(address indexed position, uint256 assets);\n\n    /**\n     * @notice Emitted on rebalance of Aave poisition.\n     * @param oldAsset the address of the asset for the old position\n     * @param newAsset the address of the asset for the new position\n     * @param assets the amount of the new assets cellar has after rebalancing\n     */\n    event Rebalance(address indexed oldAsset, address indexed newAsset, uint256 assets);\n\n    function enterPosition() external;\n\n    function enterPosition(uint256 assets) external;\n\n    function exitPosition() external;\n\n    function exitPosition(uint256 assets) external;\n\n    function rebalance(\n        address[9] memory route,\n        uint256[3][4] memory swapParams,\n        uint256 minAssetsOut\n    ) external;\n\n    // ========================================= REINVEST LOGIC =========================================\n\n    /**\n     * @notice Emitted upon claiming rewards and beginning cooldown period to unstake them.\n     * @param rewards amount of rewards that were claimed\n     */\n    event ClaimAndUnstake(uint256 rewards);\n\n    /**\n     * @notice Emitted upon reinvesting rewards into the current position.\n     * @param token the address of the asset rewards were swapped to\n     * @param rewards amount of rewards swapped to be reinvested\n     * @param assets amount of assets received from swapping rewards\n     */\n    event Reinvest(address indexed token, uint256 rewards, uint256 assets);\n\n    function claimAndUnstake() external returns (uint256 rewards);\n\n    function reinvest(uint256 minAssetsOut) external;\n\n    // =========================================== FEES LOGIC ===========================================\n\n    /**\n     * @notice Emitted when platform fees are send to the Sommelier chain.\n     * @param feesInSharesRedeemed amount of fees redeemed for assets to send\n     * @param feesInAssetsSent amount of assets fees were redeemed for that were sent\n     */\n    event SendFees(uint256 feesInSharesRedeemed, uint256 feesInAssetsSent);\n\n    function sendFees() external;\n\n    // ========================================= RECOVERY LOGIC =========================================\n\n    /**\n     * @notice Emitted when tokens accidentally sent to cellar are recovered.\n     * @param token the address of the token\n     * @param to the address sweeped tokens were transferred to\n     * @param amount amount transferred out\n     */\n    event Sweep(address indexed token, address indexed to, uint256 amount);\n\n    function sweep(ERC20 token, address to) external;\n}\n"
18     },
19     "src/interfaces/IAaveIncentivesController.sol": {
20       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\ninterface IAaveIncentivesController {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(address indexed user, address indexed to, address indexed claimer, uint256 amount);\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /*\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /*\n     * LEGACY **************************\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function assets(address asset)\n        external\n        view\n        returns (\n            uint128,\n            uint128,\n            uint256\n        );\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating\n     * the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @param asset The asset to incentivize\n     * @return the user index for the asset\n     */\n    function getUserAssetData(address user, address asset) external view returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function PRECISION() external view returns (uint8);\n\n    /**\n     * @dev Gets the distribution end timestamp of the emissions\n     */\n    function DISTRIBUTION_END() external view returns (uint256);\n}\n"
21     },
22     "src/interfaces/IStakedTokenV2.sol": {
23       "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.15;\n\ninterface IStakedTokenV2 {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function stakersCooldowns(address account) external view returns (uint256);\n}\n"
24     },
25     "src/interfaces/ICurveSwaps.sol": {
26       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\n/**\n * @notice Partial interface for a Curve Registry Exchanges contract\n * @dev The registry exchange contract is used to find pools and query exchange rates for token swaps.\n *      It also provides a unified exchange API that can be useful for on-chain integrators.\n **/\ninterface ICurveSwaps {\n    /**\n     * @notice Perform up to four swaps in a single transaction\n     * @dev Routing and swap params must be determined off-chain. This\n     *      functionality is designed for gas efficiency over ease-of-use.\n     * @param _route Array of [initial token, pool, token, pool, token, ...]\n     *               The array is iterated until a pool address of 0x00, then the last\n     *               given token is transferred to `_receiver` (address to transfer the final output token to)\n     * @param _swap_params Multidimensional array of [i, j, swap type] where i and j are the correct\n     *                     values for the n'th pool in `_route`. The swap type should be 1 for\n     *                     a stableswap `exchange`, 2 for stableswap `exchange_underlying`, 3\n     *                     for a cryptoswap `exchange`, 4 for a cryptoswap `exchange_underlying`\n     *                     and 5 for Polygon factory metapools `exchange_underlying`\n     * @param _expected The minimum amount received after the final swap.\n     * @return Received amount of final output token\n     **/\n    function exchange_multiple(\n        address[9] memory _route,\n        uint256[3][4] memory _swap_params,\n        uint256 _amount,\n        uint256 _expected\n    ) external returns (uint256);\n}\n"
27     },
28     "src/interfaces/ISushiSwapRouter.sol": {
29       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\n/**\n * @notice Partial interface for a SushiSwap Router contract\n **/\ninterface ISushiSwapRouter {\n    /**\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined by the `path`\n     * @dev The first element of `path` is the input token, the last is the output token,\n     *      and any intermediate elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\n     *      `msg.sender` should have already given the router an allowance of at least `amountIn` on the input token\n     * @param amountIn The amount of input tokens to send\n     * @param amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert\n     * @param path An array of token addresses. `path.length` must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity\n     * @param to Recipient of the output tokens\n     * @param deadline Unix timestamp after which the transaction will revert\n     * @return amounts The input token amount and all subsequent output token amounts\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n"
30     },
31     "src/interfaces/IGravity.sol": {
32       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\ninterface IGravity {\n    function sendToCosmos(\n        address _tokenContract,\n        bytes32 _destination,\n        uint256 _amount\n    ) external;\n}\n"
33     },
34     "src/interfaces/ILendingPool.sol": {
35       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\n/**\n * @dev Partial interface for a Aave LendingPool contract,\n * which is the main point of interaction with an Aave protocol's market\n **/\ninterface ILendingPool {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     **/\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            //stores the reserve configuration\n            //bit 0-15: LTV\n            //bit 16-31: Liq. threshold\n            //bit 32-47: Liq. bonus\n            //bit 48-55: Decimals\n            //bit 56: Reserve is active\n            //bit 57: reserve is frozen\n            //bit 58: borrowing is enabled\n            //bit 59: stable rate borrowing enabled\n            //bit 60-63: reserved\n            //bit 64-79: reserve factor\n            uint256 configuration,\n            //the liquidity index. Expressed in ray\n            uint128 liquidityIndex,\n            //variable borrow index. Expressed in ray\n            uint128 variableBorrowIndex,\n            //the current supply rate. Expressed in ray\n            uint128 currentLiquidityRate,\n            //the current variable borrow rate. Expressed in ray\n            uint128 currentVariableBorrowRate,\n            //the current stable borrow rate. Expressed in ray\n            uint128 currentStableBorrowRate,\n            uint40 lastUpdateTimestamp,\n            //tokens addresses\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress,\n            //address of the interest rate strategy\n            address interestRateStrategyAddress,\n            //the id of the reserve. Represents the position in the list of the active reserves\n            uint8 id\n        );\n}\n"
36     },
37     "src/utils/Math.sol": {
38       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nlibrary Math {\n    /**\n     * @notice Substract and return 0 instead if results are negative.\n     */\n    function subMinZero(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x - y : 0;\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function changeDecimals(\n        uint256 amount,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        } else if (fromDecimals < toDecimals) {\n            return amount * 10**(toDecimals - fromDecimals);\n        } else {\n            return amount / 10**(fromDecimals - toDecimals);\n        }\n    }\n\n    // ===================================== OPENZEPPELIN'S MATH =====================================\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // ================================= SOLMATE's FIXEDPOINTMATHLIB =================================\n\n    uint256 public constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"
39     },
40     "src/Errors.sol": {
41       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\n// ========================================== USER ERRORS ===========================================\n\n/**\n * @dev These errors represent invalid user input to functions. Where appropriate, the invalid value\n *      is specified along with constraints. These errors can be resolved by callers updating their\n *      arguments.\n */\n\n/**\n * @notice Attempted an action with zero assets.\n */\nerror USR_ZeroAssets();\n\n/**\n * @notice Attempted an action with zero shares.\n */\nerror USR_ZeroShares();\n\n/**\n * @notice Attempted deposit more than the max deposit.\n * @param assets the assets user attempted to deposit\n * @param maxDeposit the max assets that can be deposited\n */\nerror USR_DepositRestricted(uint256 assets, uint256 maxDeposit);\n\n/**\n * @notice Attempted to transfer more active shares than the user has.\n * @param activeShares amount of shares user has\n * @param attemptedActiveShares amount of shares user tried to transfer\n */\nerror USR_NotEnoughActiveShares(uint256 activeShares, uint256 attemptedActiveShares);\n\n/**\n * @notice Attempted swap into an asset that is not the current asset of the position.\n * @param assetOut address of the asset attempted to swap to\n * @param currentAsset address of the current asset of position\n */\nerror USR_InvalidSwap(address assetOut, address currentAsset);\n\n/**\n * @notice Attempted to sweep an asset that is managed by the cellar.\n * @param token address of the token that can't be sweeped\n */\nerror USR_ProtectedAsset(address token);\n\n/**\n * @notice Attempted rebalance into the same position.\n * @param position address of the position\n */\nerror USR_SamePosition(address position);\n\n/**\n * @notice Attempted to update the position to one that is not supported by the platform.\n * @param unsupportedPosition address of the unsupported position\n */\nerror USR_UnsupportedPosition(address unsupportedPosition);\n\n/**\n * @notice Attempted an operation on an untrusted position.\n * @param position address of the position\n */\nerror USR_UntrustedPosition(address position);\n\n/**\n * @notice Attempted to update a position to an asset that uses an incompatible amount of decimals.\n * @param newDecimals decimals of precision that the new position uses\n * @param maxDecimals maximum decimals of precision for a position to be compatible with the cellar\n */\nerror USR_TooManyDecimals(uint8 newDecimals, uint8 maxDecimals);\n\n/**\n * @notice User attempted to stake zero amout.\n */\nerror USR_ZeroDeposit();\n\n/**\n * @notice User attempted to stake an amount smaller than the minimum deposit.\n *\n * @param amount                Amount user attmpted to stake.\n * @param minimumDeposit        The minimum deopsit amount accepted.\n */\nerror USR_MinimumDeposit(uint256 amount, uint256 minimumDeposit);\n\n/**\n * @notice The specified deposit ID does not exist for the caller.\n *\n * @param depositId             The deposit ID provided for lookup.\n */\nerror USR_NoDeposit(uint256 depositId);\n\n/**\n * @notice The user is attempting to cancel unbonding for a deposit which is not unbonding.\n *\n * @param depositId             The deposit ID the user attempted to cancel.\n */\nerror USR_NotUnbonding(uint256 depositId);\n\n/**\n * @notice The user is attempting to unbond a deposit which has already been unbonded.\n *\n * @param depositId             The deposit ID the user attempted to unbond.\n */\nerror USR_AlreadyUnbonding(uint256 depositId);\n\n/**\n * @notice The user is attempting to unstake a deposit which is still timelocked.\n *\n * @param depositId             The deposit ID the user attempted to unstake.\n */\nerror USR_StakeLocked(uint256 depositId);\n\n/**\n * @notice The contract owner attempted to update rewards but the new reward rate would cause overflow.\n */\nerror USR_RewardTooLarge();\n\n/**\n * @notice The reward distributor attempted to update rewards but 0 rewards per epoch.\n *         This can also happen if there is less than 1 wei of rewards per second of the\n *         epoch - due to integer division this will also lead to 0 rewards.\n */\nerror USR_ZeroRewardsPerEpoch();\n\n/**\n * @notice The caller attempted to stake with a lock value that did not\n *         correspond to a valid staking time.\n *\n * @param lock                  The provided lock value.\n */\nerror USR_InvalidLockValue(uint256 lock);\n\n/**\n * @notice The caller attempted an signed action with an invalid signature.\n * @param signatureLength length of the signature passed in\n * @param expectedSignatureLength expected length of the signature passed in\n */\nerror USR_InvalidSignature(uint256 signatureLength, uint256 expectedSignatureLength);\n\n// ========================================== STATE ERRORS ===========================================\n\n/**\n * @dev These errors represent actions that are being prevented due to current contract state.\n *      These errors do not relate to user input, and may or may not be resolved by other actions\n *      or the progression of time.\n */\n\n/**\n * @notice Attempted an action when cellar is using an asset that has a fee on transfer.\n * @param assetWithFeeOnTransfer address of the asset with fee on transfer\n */\nerror STATE_AssetUsesFeeOnTransfer(address assetWithFeeOnTransfer);\n\n/**\n * @notice Attempted action was prevented due to contract being shutdown.\n */\nerror STATE_ContractShutdown();\n\n/**\n * @notice Attempted to shutdown the contract when it was already shutdown.\n */\nerror STATE_AlreadyShutdown();\n\n/**\n * @notice The caller attempted to start a reward period, but the contract did not have enough tokens\n *         for the specified amount of rewards.\n *\n * @param rewardBalance         The amount of distributionToken held by the contract.\n * @param reward                The amount of rewards the caller attempted to distribute.\n */\nerror STATE_RewardsNotFunded(uint256 rewardBalance, uint256 reward);\n\n/**\n * @notice Attempted an operation that is prohibited while yield is still being distributed from the last accrual.\n */\nerror STATE_AccrualOngoing();\n\n/**\n * @notice The caller attempted to change the epoch length, but current reward epochs were active.\n */\nerror STATE_RewardsOngoing();\n\n/**\n * @notice The caller attempted to change the next epoch duration, but there are rewards ready.\n */\nerror STATE_RewardsReady();\n\n/**\n * @notice The caller attempted to deposit stake, but there are no remaining rewards to pay out.\n */\nerror STATE_NoRewardsLeft();\n\n/**\n * @notice The caller attempted to perform an an emergency unstake, but the contract\n *         is not in emergency mode.\n */\nerror STATE_NoEmergencyUnstake();\n\n/**\n * @notice The caller attempted to perform an an emergency unstake, but the contract\n *         is not in emergency mode, or the emergency mode does not allow claiming rewards.\n */\nerror STATE_NoEmergencyClaim();\n\n/**\n * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\n *         while the contract was paused.\n */\nerror STATE_ContractPaused();\n\n/**\n * @notice The caller attempted to perform a state-mutating action (e.g. staking or unstaking)\n *         while the contract was killed (placed in emergency mode).\n * @dev    Emergency mode is irreversible.\n */\nerror STATE_ContractKilled();\n"
42     },
43     "lib/solmate/src/tokens/ERC20.sol": {
44       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
45     },
46     "lib/solmate/src/utils/SafeTransferLib.sol": {
47       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
48     },
49     "src/interfaces/IMulticall.sol": {
50       "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\n// From: https://github.com/Uniswap/v3-periphery/contracts/interfaces/IMulticall.sol\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
51     },
52     "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
54     },
55     "src/CellarStaking.sol": {
56       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ICellarStaking } from \"./interfaces/ICellarStaking.sol\";\n\nimport \"./Errors.sol\";\n\n/**\n * @title Sommelier Staking\n * @author Kevin Kennis\n *\n * Staking for Sommelier Cellars.\n *\n * This contract is inspired by the Synthetix staking rewards contract, Ampleforth's\n * token geyser, and Treasure DAO's MAGIC mine. However, there are unique improvements\n * and new features, specifically unbonding, as inspired by LP bonding on Osmosis.\n * Unbonding allows the contract to guarantee deposits for a certain amount of time,\n * increasing predictability and stickiness of TVL for Cellars.\n *\n * *********************************** Funding Flow ***********************************\n *\n * 1) The contract owner calls 'notifyRewardAmount' to specify an initial schedule of rewards\n *    The contract should hold enough the distribution token to fund the\n *    specified reward schedule, where the length of the reward schedule is defined by\n *    epochDuration. This duration can also be changed by the owner, and any change will apply\n *    to future calls to 'notifyRewardAmount' (but will not affect active schedules).\n * 2) At a future time, the contract owner may call 'notifyRewardAmount' again to extend the\n *    staking program with new rewards. These new schedules may distribute more or less\n *    rewards than previous epochs. If a previous epoch is not finished, any leftover rewards\n *    get rolled into the new schedule, increasing the reward rate. Reward schedules always\n *    end exactly 'epochDuration' seconds from the most recent time 'notifyRewardAmount' has been\n *    called.\n *\n * ********************************* Staking Lifecycle ********************************\n *\n * 1) A user may deposit a certain amount of tokens to stake, and is required to lock\n *    those tokens for a specified amount of time. There are three locking options:\n *    one day, one week, or one month. Longer locking times receive larger 'boosts',\n *    that the deposit will receive a larger proportional amount of shares. A user\n *    may not unstake until they choose to unbond, and time defined by the lock has\n *    elapsed during unbonding.\n * 2) When a user wishes to withdraw, they must first \"unbond\" their stake, which starts\n *    a timer equivalent to the lock time. They still receive their rewards during this\n *    time, but forfeit any locktime boosts. A user may cancel the unbonding period at any\n *    time to regain their boosts, which will set the unbonding timer back to 0.\n * 2) Once the lock has elapsed, a user may unstake their deposit, either partially\n *    or in full. The user will continue to receive the same 'boosted' amount of rewards\n *    until they unstake. The user may unstake all of their deposits at once, as long\n *    as all of the lock times have elapsed. When unstaking, the user will also receive\n *    all eligible rewards for all deposited stakes, which accumulate linearly.\n * 3) At any time, a user may claim their available rewards for their deposits. Rewards\n *    accumulate linearly and can be claimed at any time, whether or not the lock has\n *    for a given deposit has expired. The user can claim rewards for a specific deposit,\n *    or may choose to collect all eligible rewards at once.\n *\n * ************************************ Accounting ************************************\n *\n * The contract uses an accounting mechanism based on the 'rewardPerToken' model,\n * originated by the Synthetix staking rewards contract. First, token deposits are accounted\n * for, with synthetic \"boosted\" amounts used for reward calculations. As time passes,\n * rewardPerToken continues to accumulate, whereas the value of 'rewardPerToken' will match\n * the reward due to a single token deposited before the first ever rewards were scheduled.\n *\n * At each accounting checkpoint, rewardPerToken will be recalculated, and every time an\n * existing stake is 'touched', this value is used to calculate earned rewards for that\n * stake. Each stake tracks a 'rewardPerTokenPaid' value, which represents the 'rewardPerToken'\n * value the last time the stake calculated \"earned\" rewards. Every recalculation pays the difference.\n * This ensures no earning is double-counted. When a new stake is deposited, its\n * initial 'rewardPerTokenPaid' is set to the current 'rewardPerToken' in the contract,\n * ensuring it will not receive any rewards emitted during the period before deposit.\n *\n * The following example applies to a given epoch of 100 seconds, with a reward rate\n * of 100 tokens per second:\n *\n * a) User 1 deposits a stake of 50 before the epoch begins\n * b) User 2 deposits a stake of 20 at second 20 of the epoch\n * c) User 3 deposits a stake of 100 at second 50 of the epoch\n *\n * In this case,\n *\n * a) At second 20, before User 2's deposit, rewardPerToken will be 40\n *     (2000 total tokens emitted over 20 seconds / 50 staked).\n * b) At second 50, before User 3's deposit, rewardPerToken will be 82.857\n *     (previous 40 + 3000 tokens emitted over 30 seconds / 70 staked == 42.857)\n * c) At second 100, when the period is over, rewardPerToken will be 112.267\n *     (previous 82.857 + 5000 tokens emitted over 50 seconds / 170 staked == 29.41)\n *\n *\n * Then, each user will receive rewards proportional to the their number of tokens. At second 100:\n * a) User 1 will receive 50 * 112.267 = 5613.35 rewards\n * b) User 2 will receive 20 * (112.267 - 40) = 1445.34\n *       (40 is deducted because it was the current rewardPerToken value on deposit)\n * c) User 3 will receive 100 * (112.267 - 82.857) = 2941\n *       (82.857 is deducted because it was the current rewardPerToken value on deposit)\n *\n * Depending on deposit times, this accumulation may take place over multiple\n * reward periods, and the total rewards earned is simply the sum of rewards earned for\n * each period. A user may also have multiple discrete deposits, which are all\n * accounted for separately due to timelocks and locking boosts. Therefore,\n * a user's total earned rewards are a function of their rewards across\n * the proportional tokens deposited, across different ranges of rewardPerToken.\n *\n * Reward accounting takes place before every operation which may change\n * accounting calculations (minting of new shares on staking, burning of\n * shares on unstaking, or claiming, which decrements eligible rewards).\n * This is gas-intensive but unavoidable, since retroactive accounting\n * based on previous proportionate shares would require a prohibitive\n * amount of storage of historical state. On every accounting run, there\n * are a number of safety checks to ensure that all reward tokens are\n * accounted for and that no accounting time periods have been missed.\n *\n */\ncontract CellarStaking is ICellarStaking, Ownable {\n    using SafeTransferLib for ERC20;\n\n    // ============================================ STATE ==============================================\n\n    // ============== Constants ==============\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant ONE_DAY = 60 * 60 * 24;\n    uint256 public constant ONE_WEEK = ONE_DAY * 7;\n    uint256 public constant TWO_WEEKS = ONE_WEEK * 2;\n\n    uint256 public immutable SHORT_BOOST;\n    uint256 public immutable MEDIUM_BOOST;\n    uint256 public immutable LONG_BOOST;\n\n    uint256 public immutable SHORT_BOOST_TIME;\n    uint256 public immutable MEDIUM_BOOST_TIME;\n    uint256 public immutable LONG_BOOST_TIME;\n\n    // ============ Global State =============\n\n    ERC20 public immutable override stakingToken;\n    ERC20 public immutable override distributionToken;\n    uint256 public override currentEpochDuration;\n    uint256 public override nextEpochDuration;\n    uint256 public override rewardsReady;\n\n    uint256 public override minimumDeposit;\n    uint256 public override endTimestamp;\n    uint256 public override totalDeposits;\n    uint256 public override totalDepositsWithBoost;\n    uint256 public override rewardRate;\n    uint256 public override rewardPerTokenStored;\n\n    uint256 private lastAccountingTimestamp = block.timestamp;\n\n    /// @notice Emergency states in case of contract malfunction.\n    bool public override paused;\n    bool public override ended;\n    bool public override claimable;\n\n    // ============= User State ==============\n\n    /// @notice user => all user's staking positions\n    mapping(address => UserStake[]) public stakes;\n\n    // ========================================== CONSTRUCTOR ===========================================\n\n    /**\n     * @param _owner                The owner of the staking contract - will immediately receive ownership.\n     * @param _stakingToken         The token users will deposit in order to stake.\n     * @param _distributionToken    The token the staking contract will distribute as rewards.\n     * @param _epochDuration        The length of a reward schedule.\n     * @param shortBoost            The boost multiplier for the short unbonding time.\n     * @param mediumBoost           The boost multiplier for the medium unbonding time.\n     * @param longBoost             The boost multiplier for the long unbonding time.\n     * @param shortBoostTime        The short unbonding time.\n     * @param mediumBoostTime       The medium unbonding time.\n     * @param longBoostTime         The long unbonding time.\n     */\n    constructor(\n        address _owner,\n        ERC20 _stakingToken,\n        ERC20 _distributionToken,\n        uint256 _epochDuration,\n        uint256 shortBoost,\n        uint256 mediumBoost,\n        uint256 longBoost,\n        uint256 shortBoostTime,\n        uint256 mediumBoostTime,\n        uint256 longBoostTime\n    ) {\n        stakingToken = _stakingToken;\n        distributionToken = _distributionToken;\n        nextEpochDuration = _epochDuration;\n\n        SHORT_BOOST = shortBoost;\n        MEDIUM_BOOST = mediumBoost;\n        LONG_BOOST = longBoost;\n\n        SHORT_BOOST_TIME = shortBoostTime;\n        MEDIUM_BOOST_TIME = mediumBoostTime;\n        LONG_BOOST_TIME = longBoostTime;\n\n        transferOwnership(_owner);\n    }\n\n    // ======================================= STAKING OPERATIONS =======================================\n\n    /**\n     * @notice  Make a new deposit into the staking contract. Longer locks receive reward boosts.\n     * @dev     Specified amount of stakingToken must be approved for withdrawal by the caller.\n     * @dev     Valid lock values are 0 (one day), 1 (one week), and 2 (two weeks).\n     *\n     * @param amount                The amount of the stakingToken to stake.\n     * @param lock                  The amount of time to lock stake for.\n     */\n    function stake(uint256 amount, Lock lock) external override whenNotPaused updateRewards {\n        if (amount == 0) revert USR_ZeroDeposit();\n        if (amount < minimumDeposit) revert USR_MinimumDeposit(amount, minimumDeposit);\n\n        if (totalDeposits == 0 && rewardsReady > 0) {\n            _startProgram(rewardsReady);\n            rewardsReady = 0;\n\n            // Need to run updateRewards again\n            _updateRewards();\n        } else if (block.timestamp > endTimestamp) {\n            revert STATE_NoRewardsLeft();\n        }\n\n        // Do share accounting and populate user stake information\n        (uint256 boost, ) = _getBoost(lock);\n        uint256 amountWithBoost = amount + ((amount * boost) / ONE);\n\n        stakes[msg.sender].push(\n            UserStake({\n                amount: uint112(amount),\n                amountWithBoost: uint112(amountWithBoost),\n                unbondTimestamp: 0,\n                rewardPerTokenPaid: uint112(rewardPerTokenStored),\n                rewards: 0,\n                lock: lock\n            })\n        );\n\n        // Update global state\n        totalDeposits += amount;\n        totalDepositsWithBoost += amountWithBoost;\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(msg.sender, stakes[msg.sender].length - 1, amount);\n    }\n\n    /**\n     * @notice  Unbond a specified amount from a certain deposited stake.\n     * @dev     After the unbond time elapses, the deposit can be unstaked.\n     *\n     * @param depositId             The specified deposit to unstake from.\n     *\n     */\n    function unbond(uint256 depositId) external override whenNotPaused updateRewards {\n        _unbond(depositId);\n    }\n\n    /**\n     * @notice  Unbond all user deposits.\n     * @dev     Different deposits may have different timelocks.\n     *\n     */\n    function unbondAll() external override whenNotPaused updateRewards {\n        // Individually unbond each deposit\n        UserStake[] storage userStakes = stakes[msg.sender];\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            UserStake storage s = userStakes[i];\n\n            if (s.amount != 0 && s.unbondTimestamp == 0) {\n                _unbond(i);\n            }\n        }\n    }\n\n    /**\n     * @dev     Contains all logic for processing an unbond operation.\n     *          For the given deposit, sets an unlock time, and\n     *          reverts boosts to 0.\n     *\n     * @param depositId             The specified deposit to unbond from.\n     */\n    function _unbond(uint256 depositId) internal {\n        // Fetch stake and make sure it is withdrawable\n        UserStake storage s = stakes[msg.sender][depositId];\n\n        uint256 depositAmount = s.amount;\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\n        if (s.unbondTimestamp > 0) revert USR_AlreadyUnbonding(depositId);\n\n        _updateRewardForStake(msg.sender, depositId);\n\n        // Remove any lock boosts\n        uint256 depositAmountReduced = s.amountWithBoost - depositAmount;\n        (, uint256 lockDuration) = _getBoost(s.lock);\n\n        s.amountWithBoost = uint112(depositAmount);\n        s.unbondTimestamp = uint32(block.timestamp + lockDuration);\n\n        totalDepositsWithBoost -= uint112(depositAmountReduced);\n\n        emit Unbond(msg.sender, depositId, depositAmount);\n    }\n\n    /**\n     * @notice  Cancel an unbonding period for a stake that is currently unbonding.\n     * @dev     Resets the unbonding timer and reinstates any lock boosts.\n     *\n     * @param depositId             The specified deposit to unstake from.\n     *\n     */\n    function cancelUnbonding(uint256 depositId) external override whenNotPaused updateRewards {\n        _cancelUnbonding(depositId);\n    }\n\n    /**\n     * @notice  Cancel an unbonding period for all stakes.\n     * @dev     Only cancels stakes that are unbonding.\n     *\n     */\n    function cancelUnbondingAll() external override whenNotPaused updateRewards {\n        // Individually unbond each deposit\n        UserStake[] storage userStakes = stakes[msg.sender];\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            UserStake storage s = userStakes[i];\n\n            if (s.amount != 0 && s.unbondTimestamp != 0) {\n                _cancelUnbonding(i);\n            }\n        }\n    }\n\n    /**\n     * @dev     Contains all logic for cancelling an unbond operation.\n     *          For the given deposit, resets the unbonding timer, and\n     *          reverts boosts to amount determined by lock.\n     *\n     * @param depositId             The specified deposit to unbond from.\n     */\n    function _cancelUnbonding(uint256 depositId) internal {\n        // Fetch stake and make sure it is withdrawable\n        UserStake storage s = stakes[msg.sender][depositId];\n\n        uint256 depositAmount = s.amount;\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\n        if (s.unbondTimestamp == 0) revert USR_NotUnbonding(depositId);\n\n        _updateRewardForStake(msg.sender, depositId);\n\n        // Reinstate\n        (uint256 boost, ) = _getBoost(s.lock);\n        uint256 depositAmountIncreased = (s.amount * boost) / ONE;\n        uint256 amountWithBoost = s.amount + depositAmountIncreased;\n\n        s.amountWithBoost = uint112(amountWithBoost);\n        s.unbondTimestamp = 0;\n\n        totalDepositsWithBoost += depositAmountIncreased;\n\n        emit CancelUnbond(msg.sender, depositId);\n    }\n\n    /**\n     * @notice  Unstake a specific deposited stake.\n     * @dev     The unbonding time for the specified deposit must have elapsed.\n     * @dev     Unstaking automatically claims available rewards for the deposit.\n     *\n     * @param depositId             The specified deposit to unstake from.\n     *\n     * @return reward               The amount of accumulated rewards since the last reward claim.\n     */\n    function unstake(uint256 depositId) external override whenNotPaused updateRewards returns (uint256 reward) {\n        return _unstake(depositId);\n    }\n\n    /**\n     * @notice  Unstake all user deposits.\n     * @dev     Only unstakes rewards that are unbonded.\n     * @dev     Unstaking automatically claims all available rewards.\n     *\n     * @return rewards              The amount of accumulated rewards since the last reward claim.\n     */\n    function unstakeAll() external override whenNotPaused updateRewards returns (uint256[] memory) {\n        // Individually unstake each deposit\n        UserStake[] storage userStakes = stakes[msg.sender];\n        uint256[] memory rewards = new uint256[](userStakes.length);\n\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            UserStake storage s = userStakes[i];\n\n            if (s.amount != 0 && s.unbondTimestamp != 0 && block.timestamp >= s.unbondTimestamp) {\n                rewards[i] = _unstake(i);\n            }\n        }\n\n        return rewards;\n    }\n\n    /**\n     * @dev     Contains all logic for processing an unstake operation.\n     *          For the given deposit, does share accounting and burns\n     *          shares, returns staking tokens to the original owner,\n     *          updates global deposit and share trackers, and claims\n     *          rewards for the given deposit.\n     *\n     * @param depositId             The specified deposit to unstake from.\n     */\n    function _unstake(uint256 depositId) internal returns (uint256 reward) {\n        // Fetch stake and make sure it is withdrawable\n        UserStake storage s = stakes[msg.sender][depositId];\n\n        uint256 depositAmount = s.amount;\n\n        if (depositAmount == 0) revert USR_NoDeposit(depositId);\n        if (s.unbondTimestamp == 0 || block.timestamp < s.unbondTimestamp) revert USR_StakeLocked(depositId);\n\n        _updateRewardForStake(msg.sender, depositId);\n\n        // Start unstaking\n        reward = s.rewards;\n\n        s.amount = 0;\n        s.amountWithBoost = 0;\n        s.rewards = 0;\n\n        // Update global state\n        // Boosted amount same as deposit amount, since we have unbonded\n        totalDeposits -= depositAmount;\n        totalDepositsWithBoost -= depositAmount;\n\n        // Distribute stake\n        stakingToken.safeTransfer(msg.sender, depositAmount);\n\n        // Distribute reward\n        distributionToken.safeTransfer(msg.sender, reward);\n\n        emit Unstake(msg.sender, depositId, depositAmount, reward);\n    }\n\n    /**\n     * @notice  Claim rewards for a given deposit.\n     * @dev     Rewards accumulate linearly since deposit.\n     *\n     * @param depositId             The specified deposit for which to claim rewards.\n     *\n     * @return reward               The amount of accumulated rewards since the last reward claim.\n     */\n    function claim(uint256 depositId) external override whenNotPaused updateRewards returns (uint256 reward) {\n        return _claim(depositId);\n    }\n\n    /**\n     * @notice  Claim all available rewards.\n     * @dev     Rewards accumulate linearly.\n     *\n     *\n     * @return rewards               The amount of accumulated rewards since the last reward claim.\n     *                               Each element of the array specified rewards for the corresponding\n     *                               indexed deposit.\n     */\n    function claimAll() external override whenNotPaused updateRewards returns (uint256[] memory rewards) {\n        // Individually claim for each stake\n        UserStake[] storage userStakes = stakes[msg.sender];\n        rewards = new uint256[](userStakes.length);\n\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            rewards[i] = _claim(i);\n        }\n    }\n\n    /**\n     * @dev Contains all logic for processing a claim operation.\n     *      Relies on previous reward accounting done before\n     *      processing external functions. Updates the amount\n     *      of rewards claimed so rewards cannot be claimed twice.\n     *\n     *\n     * @param depositId             The specified deposit to claim rewards for.\n     *\n     * @return reward               The amount of accumulated rewards since the last reward claim.\n     */\n    function _claim(uint256 depositId) internal returns (uint256 reward) {\n        // Fetch stake and make sure it is valid\n        UserStake storage s = stakes[msg.sender][depositId];\n\n        _updateRewardForStake(msg.sender, depositId);\n\n        reward = s.rewards;\n\n        // Distribute reward\n        if (reward > 0) {\n            s.rewards = 0;\n\n            distributionToken.safeTransfer(msg.sender, reward);\n\n            emit Claim(msg.sender, depositId, reward);\n        }\n    }\n\n    /**\n     * @notice  Unstake and return all staked tokens to the caller.\n     * @dev     In emergency mode, staking time locks do not apply.\n     */\n    function emergencyUnstake() external override {\n        if (!ended) revert STATE_NoEmergencyUnstake();\n\n        UserStake[] storage userStakes = stakes[msg.sender];\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            if (claimable) _updateRewardForStake(msg.sender, i);\n\n            UserStake storage s = userStakes[i];\n            uint256 amount = s.amount;\n\n            if (amount > 0) {\n                // Update global state\n                totalDeposits -= amount;\n                totalDepositsWithBoost -= s.amountWithBoost;\n\n                s.amount = 0;\n                s.amountWithBoost = 0;\n\n                stakingToken.transfer(msg.sender, amount);\n\n                emit EmergencyUnstake(msg.sender, i, amount);\n            }\n        }\n    }\n\n    /**\n     * @notice  Claim any accumulated rewards in emergency mode.\n     * @dev     In emergency node, no additional reward accounting is done.\n     *          Rewards do not accumulate after emergency mode begins,\n     *          so any earned amount is only retroactive to when the contract\n     *          was active.\n     */\n    function emergencyClaim() external override {\n        if (!ended) revert STATE_NoEmergencyUnstake();\n        if (!claimable) revert STATE_NoEmergencyClaim();\n\n        uint256 reward;\n\n        UserStake[] storage userStakes = stakes[msg.sender];\n        for (uint256 i = 0; i < userStakes.length; i++) {\n            _updateRewardForStake(msg.sender, i);\n\n            UserStake storage s = userStakes[i];\n\n            reward += s.rewards;\n            s.rewards = 0;\n        }\n\n        if (reward > 0) {\n            distributionToken.safeTransfer(msg.sender, reward);\n\n            // No need for per-stake events like emergencyUnstake:\n            // don't need to make sure positions were unwound\n            emit EmergencyClaim(msg.sender, reward);\n        }\n    }\n\n    // ======================================== ADMIN OPERATIONS ========================================\n\n    /**\n     * @notice Specify a new schedule for staking rewards. Contract must already hold enough tokens.\n     * @dev    Can only be called by reward distributor. Owner must approve distributionToken for withdrawal.\n     * @dev    epochDuration must divide reward evenly, otherwise any remainder will be lost.\n     *\n     * @param reward                The amount of rewards to distribute per second.\n     */\n    function notifyRewardAmount(uint256 reward) external override onlyOwner updateRewards {\n        if (block.timestamp < endTimestamp) {\n            uint256 remaining = endTimestamp - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            reward += leftover;\n        }\n\n        if (reward < nextEpochDuration) revert USR_ZeroRewardsPerEpoch();\n\n        uint256 rewardBalance = distributionToken.balanceOf(address(this));\n        uint256 pendingRewards = reward + rewardsReady;\n        if (rewardBalance < pendingRewards) revert STATE_RewardsNotFunded(rewardBalance, pendingRewards);\n\n        // prevent overflow when computing rewardPerToken\n        uint256 proposedRewardRate = reward / nextEpochDuration;\n        if (proposedRewardRate >= ((type(uint256).max / ONE) / nextEpochDuration)) {\n            revert USR_RewardTooLarge();\n        }\n\n        if (totalDeposits == 0) {\n            // No deposits yet, so keep rewards pending until first deposit\n            // Incrementing in case it is called twice\n            rewardsReady += reward;\n        } else {\n            // Ready to start\n            _startProgram(reward);\n        }\n\n        lastAccountingTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Change the length of a reward epoch for future reward schedules.\n     *\n     * @param _epochDuration        The new duration for reward schedules.\n     */\n    function setRewardsDuration(uint256 _epochDuration) external override onlyOwner {\n        if (rewardsReady > 0) revert STATE_RewardsReady();\n\n        nextEpochDuration = _epochDuration;\n        emit EpochDurationChange(nextEpochDuration);\n    }\n\n    /**\n     * @notice Specify a minimum deposit for staking.\n     * @dev    Can only be called by owner.\n     *\n     * @param _minimum              The minimum deposit for each new stake.\n     */\n    function setMinimumDeposit(uint256 _minimum) external override onlyOwner {\n        minimumDeposit = _minimum;\n    }\n\n    /**\n     * @notice Pause the contract. Pausing prevents staking, unstaking, claiming\n     *         rewards, and scheduling new rewards. Should only be used\n     *         in an emergency.\n     *\n     * @param _paused               Whether the contract should be paused.\n     */\n    function setPaused(bool _paused) external override onlyOwner {\n        paused = _paused;\n    }\n\n    /**\n     * @notice Stops the contract - this is irreversible. Should only be used\n     *         in an emergency, for example an irreversible accounting bug\n     *         or an exploit. Enables all depositors to withdraw their stake\n     *         instantly. Also stops new rewards accounting.\n     *\n     * @param makeRewardsClaimable  Whether any previously accumulated rewards should be claimable.\n     */\n    function emergencyStop(bool makeRewardsClaimable) external override onlyOwner {\n        if (ended) revert STATE_AlreadyShutdown();\n\n        // Update state and put in irreversible emergency mode\n        ended = true;\n        claimable = makeRewardsClaimable;\n        uint256 amountToReturn = distributionToken.balanceOf(address(this));\n\n        if (makeRewardsClaimable) {\n            // Update rewards one more time\n            _updateRewards();\n\n            // Return any remaining, since new calculation is stopped\n            uint256 remaining = endTimestamp > block.timestamp ? (endTimestamp - block.timestamp) * rewardRate : 0;\n\n            // Make sure any rewards except for remaining are kept for claims\n            uint256 amountToKeep = rewardRate * currentEpochDuration - remaining;\n\n            amountToReturn -= amountToKeep;\n        }\n\n        // Send distribution token back to owner\n        distributionToken.transfer(msg.sender, amountToReturn);\n\n        emit EmergencyStop(msg.sender, makeRewardsClaimable);\n    }\n\n    // ======================================= STATE INFORMATION =======================================\n\n    /**\n     * @notice Returns the latest time to account for in the reward program.\n     *\n     * @return timestamp           The latest time to calculate.\n     */\n    function latestRewardsTimestamp() public view override returns (uint256) {\n        return block.timestamp < endTimestamp ? block.timestamp : endTimestamp;\n    }\n\n    /**\n     * @notice Returns the amount of reward to distribute per currently-depostied token.\n     *         Will update on changes to total deposit balance or reward rate.\n     * @dev    Sets rewardPerTokenStored.\n     *\n     *\n     * @return newRewardPerTokenStored  The new rewards to distribute per token.\n     * @return latestTimestamp          The latest time to calculate.\n     */\n    function rewardPerToken() public view override returns (uint256 newRewardPerTokenStored, uint256 latestTimestamp) {\n        latestTimestamp = latestRewardsTimestamp();\n\n        if (totalDeposits == 0) return (rewardPerTokenStored, latestTimestamp);\n\n        uint256 timeElapsed = latestTimestamp - lastAccountingTimestamp;\n        uint256 rewardsForTime = timeElapsed * rewardRate;\n        uint256 newRewardsPerToken = (rewardsForTime * ONE) / totalDepositsWithBoost;\n\n        newRewardPerTokenStored = rewardPerTokenStored + newRewardsPerToken;\n    }\n\n    /**\n     * @notice Gets all of a user's stakes.\n     * @dev This is provided because Solidity converts public arrays into index getters,\n     *      but we need a way to allow external contracts and users to access the whole array.\n\n     * @param user                      The user whose stakes to get.\n     *\n     * @return stakes                   Array of all user's stakes\n     */\n    function getUserStakes(address user) public view override returns (UserStake[] memory) {\n        return stakes[user];\n    }\n\n    // ============================================ HELPERS ============================================\n\n    /**\n     * @dev Modifier to apply reward updates before functions that change accounts.\n     */\n    modifier updateRewards() {\n        _updateRewards();\n        _;\n    }\n\n    /**\n     * @dev Blocks calls if contract is paused or killed.\n     */\n    modifier whenNotPaused() {\n        if (paused) revert STATE_ContractPaused();\n        if (ended) revert STATE_ContractKilled();\n        _;\n    }\n\n    /**\n     * @dev Update reward accounting for the global state totals.\n     */\n    function _updateRewards() internal {\n        (rewardPerTokenStored, lastAccountingTimestamp) = rewardPerToken();\n    }\n\n    /**\n     * @dev On initial deposit, start the rewards program.\n     *\n     * @param reward                    The pending rewards to start distributing.\n     */\n    function _startProgram(uint256 reward) internal {\n        // Assumptions\n        // Total deposits are now (mod current tx), no ongoing program\n        // Rewards are already funded (since checked in notifyRewardAmount)\n\n        rewardRate = reward / nextEpochDuration;\n        endTimestamp = block.timestamp + nextEpochDuration;\n        currentEpochDuration = nextEpochDuration;\n\n        emit Funding(reward, endTimestamp);\n    }\n\n    /**\n     * @dev Update reward for a specific user stake.\n     */\n    function _updateRewardForStake(address user, uint256 depositId) internal {\n        UserStake storage s = stakes[user][depositId];\n        if (s.amount == 0) return;\n\n        uint256 earned = _earned(s);\n        s.rewards += uint112(earned);\n\n        s.rewardPerTokenPaid = uint112(rewardPerTokenStored);\n    }\n\n    /**\n     * @dev Return how many rewards a stake has earned and has claimable.\n     */\n    function _earned(UserStake memory s) internal view returns (uint256) {\n        uint256 rewardPerTokenAcc = rewardPerTokenStored - s.rewardPerTokenPaid;\n        uint256 newRewards = (s.amountWithBoost * rewardPerTokenAcc) / ONE;\n\n        return newRewards;\n    }\n\n    /**\n     * @dev Maps Lock enum values to corresponding lengths of time and reward boosts.\n     */\n    function _getBoost(Lock _lock) internal view returns (uint256 boost, uint256 timelock) {\n        if (_lock == Lock.short) {\n            return (SHORT_BOOST, SHORT_BOOST_TIME);\n        } else if (_lock == Lock.medium) {\n            return (MEDIUM_BOOST, MEDIUM_BOOST_TIME);\n        } else if (_lock == Lock.long) {\n            return (LONG_BOOST, LONG_BOOST_TIME);\n        } else {\n            revert USR_InvalidLockValue(uint256(_lock));\n        }\n    }\n}\n"
57     },
58     "src/interfaces/ICellarStaking.sol": {
59       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\n\n/**\n * @title Sommelier Staking Interface\n * @author Kevin Kennis\n *\n * @notice Full documentation in implementation contract.\n */\ninterface ICellarStaking {\n    // ===================== Events =======================\n\n    event Funding(uint256 rewardAmount, uint256 rewardEnd);\n    event Stake(address indexed user, uint256 depositId, uint256 amount);\n    event Unbond(address indexed user, uint256 depositId, uint256 amount);\n    event CancelUnbond(address indexed user, uint256 depositId);\n    event Unstake(address indexed user, uint256 depositId, uint256 amount, uint256 reward);\n    event Claim(address indexed user, uint256 depositId, uint256 amount);\n    event EmergencyStop(address owner, bool claimable);\n    event EmergencyUnstake(address indexed user, uint256 depositId, uint256 amount);\n    event EmergencyClaim(address indexed user, uint256 amount);\n    event EpochDurationChange(uint256 duration);\n\n    // ===================== Structs ======================\n\n    enum Lock {\n        short,\n        medium,\n        long\n    }\n\n    struct UserStake {\n        uint112 amount;\n        uint112 amountWithBoost;\n        uint32 unbondTimestamp;\n        uint112 rewardPerTokenPaid;\n        uint112 rewards;\n        Lock lock;\n    }\n\n    // ============== Public State Variables ==============\n\n    function stakingToken() external returns (ERC20);\n\n    function distributionToken() external returns (ERC20);\n\n    function currentEpochDuration() external returns (uint256);\n\n    function nextEpochDuration() external returns (uint256);\n\n    function rewardsReady() external returns (uint256);\n\n    function minimumDeposit() external returns (uint256);\n\n    function endTimestamp() external returns (uint256);\n\n    function totalDeposits() external returns (uint256);\n\n    function totalDepositsWithBoost() external returns (uint256);\n\n    function rewardRate() external returns (uint256);\n\n    function rewardPerTokenStored() external returns (uint256);\n\n    function paused() external returns (bool);\n\n    function ended() external returns (bool);\n\n    function claimable() external returns (bool);\n\n    // ================ User Functions ================\n\n    function stake(uint256 amount, Lock lock) external;\n\n    function unbond(uint256 depositId) external;\n\n    function unbondAll() external;\n\n    function cancelUnbonding(uint256 depositId) external;\n\n    function cancelUnbondingAll() external;\n\n    function unstake(uint256 depositId) external returns (uint256 reward);\n\n    function unstakeAll() external returns (uint256[] memory rewards);\n\n    function claim(uint256 depositId) external returns (uint256 reward);\n\n    function claimAll() external returns (uint256[] memory rewards);\n\n    function emergencyUnstake() external;\n\n    function emergencyClaim() external;\n\n    // ================ Admin Functions ================\n\n    function notifyRewardAmount(uint256 reward) external;\n\n    function setRewardsDuration(uint256 _epochDuration) external;\n\n    function setMinimumDeposit(uint256 _minimum) external;\n\n    function setPaused(bool _paused) external;\n\n    function emergencyStop(bool makeRewardsClaimable) external;\n\n    // ================ View Functions ================\n\n    function latestRewardsTimestamp() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256, uint256);\n\n    function getUserStakes(address user) external view returns (UserStake[] memory);\n}\n"
60     },
61     "src/mocks/MockSwapRouter.sol": {
62       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { Math } from \"src/utils/Math.sol\";\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n\ncontract MockSwapRouter {\n    using Path for bytes;\n    using Math for uint256;\n\n    uint256 public constant EXCHANGE_RATE = 0.95e18;\n\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256) {\n        ERC20(params.tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n\n        uint256 amountOut = params.amountIn.mulWadDown(EXCHANGE_RATE);\n\n        uint8 fromDecimals = ERC20(params.tokenIn).decimals();\n        uint8 toDecimals = ERC20(params.tokenOut).decimals();\n        amountOut = amountOut.changeDecimals(fromDecimals, toDecimals);\n\n        require(amountOut >= params.amountOutMinimum, \"amountOutMin invariant failed\");\n\n        ERC20(params.tokenOut).transfer(params.recipient, amountOut);\n        return amountOut;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams memory params) external payable returns (uint256) {\n        (address tokenIn, address tokenOut, ) = params.path.decodeFirstPool();\n\n        while (params.path.hasMultiplePools()) {\n            params.path = params.path.skipToken();\n            (, tokenOut, ) = params.path.decodeFirstPool();\n        }\n\n        ERC20(tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n\n        uint256 amountOut = params.amountIn.mulWadDown(EXCHANGE_RATE);\n\n        uint8 fromDecimals = ERC20(tokenIn).decimals();\n        uint8 toDecimals = ERC20(tokenOut).decimals();\n        amountOut = amountOut.changeDecimals(fromDecimals, toDecimals);\n\n        require(amountOut >= params.amountOutMinimum, \"amountOutMin invariant failed\");\n\n        ERC20(tokenOut).transfer(params.recipient, amountOut);\n        return amountOut;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256\n    ) external returns (uint256[] memory) {\n        address tokenIn = path[0];\n        address tokenOut = path[path.length - 1];\n\n        ERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n\n        uint256 amountOut = amountIn.mulWadDown(EXCHANGE_RATE);\n\n        uint8 fromDecimals = ERC20(tokenIn).decimals();\n        uint8 toDecimals = ERC20(tokenOut).decimals();\n        amountOut = amountOut.changeDecimals(fromDecimals, toDecimals);\n\n        require(amountOut >= amountOutMin, \"amountOutMin invariant failed\");\n\n        ERC20(tokenOut).transfer(to, amountOut);\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amountOut;\n\n        return amounts;\n    }\n\n    function exchange_multiple(\n        address[9] memory _route,\n        uint256[3][4] memory,\n        uint256 _amount,\n        uint256 _expected\n    ) external returns (uint256) {\n        address tokenIn = _route[0];\n\n        address tokenOut;\n        for (uint256 i; ; i += 2) {\n            if (i == 8 || _route[i + 1] == address(0)) {\n                tokenOut = _route[i];\n                break;\n            }\n        }\n\n        ERC20(tokenIn).transferFrom(msg.sender, address(this), _amount);\n\n        uint256 amountOut = _amount.mulWadDown(EXCHANGE_RATE);\n\n        uint8 fromDecimals = ERC20(tokenIn).decimals();\n        uint8 toDecimals = ERC20(tokenOut).decimals();\n        amountOut = amountOut.changeDecimals(fromDecimals, toDecimals);\n\n        require(amountOut >= _expected, \"received less than expected\");\n\n        ERC20(tokenOut).transfer(msg.sender, amountOut);\n\n        return amountOut;\n    }\n\n    function quote(uint256 amountIn, address[] calldata path) external view returns (uint256) {\n        address tokenIn = path[0];\n        address tokenOut = path[path.length - 1];\n\n        uint256 amountOut = amountIn.mulWadDown(EXCHANGE_RATE);\n\n        uint8 fromDecimals = ERC20(tokenIn).decimals();\n        uint8 toDecimals = ERC20(tokenOut).decimals();\n        return amountOut.changeDecimals(fromDecimals, toDecimals);\n    }\n\n    receive() external payable {}\n}\n"
63     },
64     "src/mocks/MockERC20WithTransferFee.sol": {
65       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { MockERC20 } from \"./MockERC20.sol\";\nimport { Math } from \"src/utils/Math.sol\";\n\ncontract MockERC20WithTransferFee is MockERC20 {\n    using Math for uint256;\n\n    uint256 public constant transferFee = 0.01e18;\n\n    constructor(string memory _symbol, uint8 _decimals) MockERC20(_symbol, _decimals) {}\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        amount -= amount.mulWadDown(transferFee);\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        amount -= amount.mulWadDown(transferFee);\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n}\n"
66     },
67     "src/mocks/MockERC20.sol": {
68       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory _symbol, uint8 _decimals) ERC20(_symbol, _symbol, _decimals) {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function burn(address to, uint256 amount) external {\n        _burn(to, amount);\n    }\n}\n"
69     },
70     "src/mocks/MockStkAAVE.sol": {
71       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { MockERC20 } from \"./MockERC20.sol\";\n\ncontract MockStkAAVE is MockERC20 {\n    MockERC20 public immutable AAVE; // AAVE\n    uint256 public constant COOLDOWN_SECONDS = 864000; // 10 days\n    uint256 public constant UNSTAKE_WINDOW = 172800; // 2 days\n    mapping(address => uint256) public stakersCooldowns;\n\n    constructor(MockERC20 _AAVE) MockERC20(\"stkAAVE\", 18) {\n        AAVE = _AAVE;\n    }\n\n    function cooldown() external {\n        require(balanceOf[msg.sender] != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\n        stakersCooldowns[msg.sender] = block.timestamp;\n    }\n\n    function redeem(address to, uint256 amount) external {\n        require(amount != 0, \"INVALID_ZERO_AMOUNT\");\n        uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\n        require(block.timestamp > cooldownStartTimestamp + COOLDOWN_SECONDS, \"INSUFFICIENT_COOLDOWN\");\n        require(\n            block.timestamp - (cooldownStartTimestamp + COOLDOWN_SECONDS) <= UNSTAKE_WINDOW,\n            \"UNSTAKE_WINDOW_FINISHED\"\n        );\n\n        uint256 balanceOfMessageSender = balanceOf[msg.sender];\n\n        uint256 amountToRedeem = amount > balanceOfMessageSender ? balanceOfMessageSender : amount;\n\n        // _updateCurrentUnclaimedRewards(msg.sender, balanceOfMessageSender, true);\n\n        _burn(msg.sender, amountToRedeem);\n\n        if (balanceOfMessageSender - amountToRedeem == 0) stakersCooldowns[msg.sender] = 0;\n\n        AAVE.mint(to, amountToRedeem);\n    }\n}\n"
72     },
73     "src/mocks/MockIncentivesController.sol": {
74       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { MockStkAAVE } from \"./MockStkAAVE.sol\";\n\ncontract MockIncentivesController {\n    MockStkAAVE public stkAAVE;\n    mapping(address => uint256) public usersUnclaimedRewards;\n\n    constructor(MockStkAAVE _stkAAVE) {\n        stkAAVE = _stkAAVE;\n    }\n\n    /// @dev For testing purposes\n    function addRewards(address account, uint256 amount) external {\n        usersUnclaimedRewards[account] += amount;\n    }\n\n    function claimRewards(\n        address[] calldata,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        uint256 claimable = usersUnclaimedRewards[to];\n\n        if (amount > claimable) {\n            amount = claimable;\n        }\n\n        usersUnclaimedRewards[to] -= amount;\n\n        stkAAVE.mint(to, amount);\n\n        return amount;\n    }\n}\n"
75     },
76     "src/mocks/MockERC4626.sol": {
77       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC4626 } from \"src/base/ERC4626.sol\";\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { MockERC20 } from \"./MockERC20.sol\";\n\ncontract MockERC4626 is ERC4626 {\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC4626(_asset, _name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) external {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) external {\n        _burn(from, value);\n    }\n\n    function simulateGain(uint256 assets, address receiver) external returns (uint256 shares) {\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        MockERC20(address(asset)).mint(address(this), assets);\n\n        _mint(receiver, shares);\n    }\n\n    function simulateLoss(uint256 assets) external {\n        MockERC20(address(asset)).burn(address(this), assets);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n}\n"
78     },
79     "src/interfaces/ICellarRouter.sol": {
80       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { ERC4626 } from \"src/base/ERC4626.sol\";\n\ninterface ICellarRouter {\n    // ======================================= ROUTER OPERATIONS =======================================\n\n    function depositIntoCellarWithPermit(\n        ERC4626 cellar,\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares);\n\n    function depositAndSwapIntoCellar(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver\n    ) external returns (uint256 shares);\n\n    function depositAndSwapIntoCellarWithPermit(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares);\n\n    function withdrawAndSwapFromCellar(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver\n    ) external returns (uint256 shares);\n\n    function withdrawAndSwapFromCellarWithPermit(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares);\n}\n"
81     },
82     "src/CellarRouter.sol": {
83       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { ERC4626 } from \"./base/ERC4626.sol\";\nimport { Ownable } from \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport { ISwapRouter as IUniswapV3Router } from \"./interfaces/ISwapRouter.sol\";\nimport { IUniswapV2Router02 as IUniswapV2Router } from \"./interfaces/IUniswapV2Router02.sol\";\nimport { ICellarRouter } from \"./interfaces/ICellarRouter.sol\";\nimport { IGravity } from \"./interfaces/IGravity.sol\";\n\nimport \"./Errors.sol\";\n\ncontract CellarRouter is ICellarRouter, Ownable {\n    using SafeTransferLib for ERC20;\n\n    // ========================================== CONSTRUCTOR ==========================================\n    /**\n     * @notice Uniswap V3 swap router contract. Used for swapping if pool fees are specified.\n     */\n    IUniswapV3Router public immutable uniswapV3Router; // 0xE592427A0AEce92De3Edee1F18E0157C05861564\n\n    /**\n     * @notice Uniswap V2 swap router contract. Used for swapping if pool fees are not specified.\n     */\n    IUniswapV2Router public immutable uniswapV2Router; // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n\n    /**\n     * @param _uniswapV3Router Uniswap V3 swap router address\n     * @param _uniswapV2Router Uniswap V2 swap router address\n     */\n    constructor(\n        IUniswapV3Router _uniswapV3Router,\n        IUniswapV2Router _uniswapV2Router,\n        address owner\n    ) {\n        uniswapV3Router = _uniswapV3Router;\n        uniswapV2Router = _uniswapV2Router;\n\n        // Transfer ownership to the Sommelier multisig.\n        transferOwnership(address(owner));\n    }\n\n    // ======================================= DEPOSIT OPERATIONS =======================================\n\n    /**\n     * @notice Deposit assets into a cellar using permit.\n     * @param cellar address of the cellar to deposit into\n     * @param assets amount of assets to deposit\n     * @param receiver address receiving the shares\n     * @param deadline timestamp after which permit is invalid\n     * @param signature a valid secp256k1 signature\n     * @return shares amount of shares minted\n     */\n    function depositIntoCellarWithPermit(\n        ERC4626 cellar,\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares) {\n        // Retrieve the cellar's current asset.\n        ERC20 asset = cellar.asset();\n\n        // Approve the assets from the user to the router via permit.\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(signature);\n        asset.permit(msg.sender, address(this), assets, deadline, v, r, s);\n\n        // Transfer assets from the user to the router.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Approve the cellar to spend assets.\n        asset.safeApprove(address(cellar), assets);\n\n        // Deposit assets into the cellar.\n        shares = cellar.deposit(assets, receiver);\n    }\n\n    /**\n     * @notice Deposit into a cellar by first performing a swap to the cellar's current asset if necessary.\n     * @dev If using Uniswap V3 for swap, must specify the pool fee tier to use for each swap. For\n     *      example, if there are \"n\" addresses in path, there should be \"n-1\" values specifying the\n     *      fee tiers of each pool used for each swap. The current possible pool fee tiers for\n     *      Uniswap V3 are 0.01% (100), 0.05% (500), 0.3% (3000), and 1% (10000). If using Uniswap\n     *      V2, leave pool fees empty to use Uniswap V2 for swap.\n     * @param cellar address of the cellar to deposit into\n     * @param path array of [token1, token2, token3] that specifies the swap path on Sushiswap\n     * @param poolFees amount out of 1e4 (eg. 10000 == 1%) that represents the fee tier to use for each swap\n     * @param assets amount of assets to deposit\n     * @param assetsOutMin minimum amount of assets received from swap\n     * @param receiver address receiving the shares\n     * @return shares amount of shares minted\n     */\n    function depositAndSwapIntoCellar(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver\n    ) public returns (uint256 shares) {\n        // Retrieve the asset being swapped and asset of cellar.\n        ERC20 asset = cellar.asset();\n        ERC20 assetIn = ERC20(path[0]);\n\n        // Transfer assets from the user to the router.\n        assetIn.safeTransferFrom(msg.sender, address(this), assets);\n\n        // Check whether a swap is necessary. If not, skip swap and deposit into cellar directly.\n        if (assetIn != asset) assets = _swap(path, poolFees, assets, assetsOutMin);\n\n        // Approve the cellar to spend assets.\n        asset.safeApprove(address(cellar), assets);\n\n        // Deposit assets into the cellar.\n        shares = cellar.deposit(assets, receiver);\n    }\n\n    /**\n     * @notice Deposit into a cellar by first performing a swap to the cellar's current asset if necessary.\n     * @dev If using Uniswap V3 for swap, must specify the pool fee tier to use for each swap. For\n     *      example, if there are \"n\" addresses in path, there should be \"n-1\" values specifying the\n     *      fee tiers of each pool used for each swap. The current possible pool fee tiers for\n     *      Uniswap V3 are 0.01% (100), 0.05% (500), 0.3% (3000), and 1% (10000). If using Uniswap\n     *      V2, leave pool fees empty to use Uniswap V2 for swap.\n     * @param cellar address of the cellar to deposit into\n     * @param path array of [token1, token2, token3] that specifies the swap path on Sushiswap\n     * @param poolFees amount out of 1e4 (eg. 10000 == 1%) that represents the fee tier to use for each swap\n     * @param assets amount of assets to deposit\n     * @param assetsOutMin minimum amount of assets received from swap\n     * @param receiver address receiving the shares\n     * @param deadline timestamp after which permit is invalid\n     * @param signature a valid secp256k1 signature\n     * @return shares amount of shares minted\n     */\n    function depositAndSwapIntoCellarWithPermit(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares) {\n        // Retrieve the asset being swapped.\n        ERC20 assetIn = ERC20(path[0]);\n\n        // Approve for router to burn user shares via permit.\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(signature);\n        assetIn.permit(msg.sender, address(this), assets, deadline, v, r, s);\n\n        // Deposit assets into the cellar using a swap if necessary.\n        shares = depositAndSwapIntoCellar(cellar, path, poolFees, assets, assetsOutMin, receiver);\n    }\n\n    // ======================================= WITHDRAW OPERATIONS =======================================\n\n    /**\n     * @notice Withdraws from a cellar and then performs a swap to another desired asset, if the\n     *         withdrawn asset is not already.\n     * @dev Permission is required from caller for router to burn shares. Please make sure that\n     *      caller has approved the router to spend their shares.\n     * @dev If using Uniswap V3 for swap, must specify the pool fee tier to use for each swap. For\n     *      example, if there are \"n\" addresses in path, there should be \"n-1\" values specifying the\n     *      fee tiers of each pool used for each swap. The current possible pool fee tiers for\n     *      Uniswap V3 are 0.01% (100), 0.05% (500), 0.3% (3000), and 1% (10000). If using Uniswap\n     *      V2, leave pool fees empty to use Uniswap V2 for swap.\n     * @param cellar address of the cellar\n     * @param path array of [token1, token2, token3] that specifies the swap path on swap\n     * @param poolFees amount out of 1e4 (eg. 10000 == 1%) that represents the fee tier to use for each swap\n     * @param assets amount of assets to withdraw\n     * @param assetsOutMin minimum amount of assets received from swap\n     * @param receiver address receiving the assets\n     * @return shares amount of shares burned\n     */\n    function withdrawAndSwapFromCellar(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver\n    ) public returns (uint256 shares) {\n        ERC20 asset = cellar.asset();\n        ERC20 assetOut = ERC20(path[path.length - 1]);\n\n        // Withdraw assets from the cellar.\n        shares = cellar.withdraw(assets, address(this), msg.sender);\n\n        // Check whether a swap is necessary. If not, skip swap and transfer withdrawn assets to receiver.\n        if (assetOut != asset) assets = _swap(path, poolFees, assets, assetsOutMin);\n\n        // Transfer assets from the router to the receiver.\n        assetOut.safeTransfer(receiver, assets);\n    }\n\n    /**\n     * @notice Withdraws from a cellar and then performs a swap to another desired asset, if the\n     *         withdrawn asset is not already, using permit.\n     * @dev If using Uniswap V3 for swap, must specify the pool fee tier to use for each swap. For\n     *      example, if there are \"n\" addresses in path, there should be \"n-1\" values specifying the\n     *      fee tiers of each pool used for each swap. The current possible pool fee tiers for\n     *      Uniswap V3 are 0.01% (100), 0.05% (500), 0.3% (3000), and 1% (10000). If using Uniswap\n     *      V2, leave pool fees empty to use Uniswap V2 for swap.\n     * @param cellar address of the cellar\n     * @param path array of [token1, token2, token3] that specifies the swap path on swap\n     * @param poolFees amount out of 1e4 (eg. 10000 == 1%) that represents the fee tier to use for each swap\n     * @param assets amount of assets to withdraw\n     * @param assetsOutMin minimum amount of assets received from swap\n     * @param receiver address receiving the assets\n     * @param deadline timestamp after which permit is invalid\n     * @param signature a valid secp256k1 signature\n     * @return shares amount of shares burned\n     */\n    function withdrawAndSwapFromCellarWithPermit(\n        ERC4626 cellar,\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin,\n        address receiver,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (uint256 shares) {\n        // Approve for router to burn user shares via permit.\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(signature);\n        cellar.permit(msg.sender, address(this), assets, deadline, v, r, s);\n\n        // Withdraw assets from the cellar and swap to another asset if necessary.\n        shares = withdrawAndSwapFromCellar(cellar, path, poolFees, assets, assetsOutMin, receiver);\n    }\n\n    // ========================================== RECOVERY LOGIC ==========================================\n\n    /**\n     * @notice Emitted when tokens accidentally sent to cellar router are recovered.\n     * @param token the address of the token\n     * @param to the address sweeped tokens were transferred to\n     * @param amount amount transferred out\n     */\n    event Sweep(address indexed token, address indexed to, uint256 amount);\n\n    function sweep(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        // Transfer out tokens from this cellar router contract that shouldn't be here.\n        token.safeTransfer(to, amount);\n\n        emit Sweep(address(token), to, amount);\n    }\n\n    // ========================================= HELPER FUNCTIONS =========================================\n\n    /**\n     * @notice Split a signature into its components.\n     * @param signature a valid secp256k1 signature\n     * @return v a component of the secp256k1 signature\n     * @return r a component of the secp256k1 signature\n     * @return s a component of the secp256k1 signature\n     */\n    function _splitSignature(bytes memory signature)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        if (signature.length != 65) revert USR_InvalidSignature(signature.length, 65);\n\n        // Read each parameter directly from the signature's memory region.\n        assembly {\n            // Place first word on the stack at r.\n            r := mload(add(signature, 32))\n\n            // Place second word on the stack at s.\n            s := mload(add(signature, 64))\n\n            // Place final byte on the stack at v.\n            v := byte(0, mload(add(signature, 96)))\n        }\n    }\n\n    /**\n     * @notice Perform a swap using Uniswap.\n     * @dev If using Uniswap V3 for swap, must specify the pool fee tier to use for each swap. For\n     *      example, if there are \"n\" addresses in path, there should be \"n-1\" values specifying the\n     *      fee tiers of each pool used for each swap. The current possible pool fee tiers for\n     *      Uniswap V3 are 0.01% (100), 0.05% (500), 0.3% (3000), and 1% (10000). If using Uniswap\n     *      V2, leave pool fees empty to use Uniswap V2 for swap.\n     * @param path array of [token1, token2, token3] that specifies the swap path on swap\n     * @param poolFees amount out of 1e4 (eg. 10000 == 1%) that represents the fee tier to use for each swap\n     * @param assets amount of assets to withdraw\n     * @param assetsOutMin minimum amount of assets received from swap\n     * @return assetsOut amount of assets received after swap\n     */\n    function _swap(\n        address[] calldata path,\n        uint24[] calldata poolFees,\n        uint256 assets,\n        uint256 assetsOutMin\n    ) internal returns (uint256 assetsOut) {\n        // Retrieve the asset being swapped.\n        ERC20 assetIn = ERC20(path[0]);\n\n        // Check whether to use Uniswap V2 or Uniswap V3 for swap.\n        if (poolFees.length == 0) {\n            // If no pool fees are specified, use Uniswap V2 for swap.\n\n            // Approve assets to be swapped through the router.\n            assetIn.safeApprove(address(uniswapV2Router), assets);\n\n            // Execute the swap.\n            uint256[] memory amountsOut = uniswapV2Router.swapExactTokensForTokens(\n                assets,\n                assetsOutMin,\n                path,\n                address(this),\n                block.timestamp + 60\n            );\n\n            assetsOut = amountsOut[amountsOut.length - 1];\n        } else {\n            // If pool fees are specified, use Uniswap V3 for swap.\n\n            // Approve assets to be swapped through the router.\n            assetIn.safeApprove(address(uniswapV3Router), assets);\n\n            // Encode swap parameters.\n            bytes memory encodePackedPath = abi.encodePacked(address(assetIn));\n            for (uint256 i = 1; i < path.length; i++)\n                encodePackedPath = abi.encodePacked(encodePackedPath, poolFees[i - 1], path[i]);\n\n            // Execute the swap.\n            assetsOut = uniswapV3Router.exactInput(\n                IUniswapV3Router.ExactInputParams({\n                    path: encodePackedPath,\n                    recipient: address(this),\n                    deadline: block.timestamp + 60,\n                    amountIn: assets,\n                    amountOutMinimum: assetsOutMin\n                })\n            );\n        }\n    }\n}\n"
84     },
85     "src/interfaces/ISwapRouter.sol": {
86       "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
87     },
88     "src/interfaces/IUniswapV2Router02.sol": {
89       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
90     },
91     "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
92       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
93     },
94     "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
95       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
96     },
97     "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
98       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
99     },
100     "src/mocks/MockAToken.sol": {
101       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport { MockLendingPool } from \"./MockLendingPool.sol\";\nimport { Math } from \"src/utils/Math.sol\";\n\nlibrary WadRayMath {\n    uint256 public constant RAY = 1e27;\n    uint256 public constant HALF_RAY = RAY / 2;\n\n    /**\n     * @dev Divides two ray, rounding half up to the nearest ray\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a/b, in ray\n     **/\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"cannot divide by zero\");\n        uint256 halfB = b / 2;\n\n        require(a <= (type(uint256).max - halfB) / RAY, \"math multiplication overflow\");\n\n        return (a * RAY + halfB) / b;\n    }\n\n    /**\n     * @dev Multiplies two ray, rounding down to the nearest ray\n     * @param a Ray\n     * @param b Ray\n     * @return The result of a*b, in ray\n     **/\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0 || b == 0) return 0;\n\n        require(a <= (type(uint256).max - HALF_RAY) / b, \"math multiplication overflow\");\n\n        return (a * b + HALF_RAY) / RAY;\n    }\n}\n\ncontract MockAToken is ERC20 {\n    address public underlyingAsset;\n    MockLendingPool public lendingPool;\n\n    constructor(\n        address _lendingPool,\n        address _underlyingAsset,\n        string memory _symbol\n    ) ERC20(_symbol, _symbol) {\n        lendingPool = MockLendingPool(_lendingPool);\n        underlyingAsset = _underlyingAsset;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return ERC20(underlyingAsset).decimals();\n    }\n\n    function mint(address user, uint256 amount) external {\n        uint256 amountScaled = WadRayMath.rayDiv(amount, lendingPool.index());\n        require(amountScaled != 0, \"CT_INVALID_MINT_AMOUNT\");\n        _mint(user, amountScaled);\n    }\n\n    function burn(address user, uint256 amount) external {\n        uint256 amountScaled = WadRayMath.rayDiv(amount, lendingPool.index());\n        require(amountScaled != 0, \"CT_INVALID_BURN_AMOUNT\");\n        _burn(user, amountScaled);\n    }\n\n    /**\n     * @dev Mints aTokens to `user`\n     * - Only callable by the LendingPool, as extra state updates there need to be managed\n     * @param user The address receiving the minted tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool) {\n        uint256 previousBalance = super.balanceOf(user);\n\n        uint256 amountScaled = WadRayMath.rayDiv(amount, index);\n        require(amountScaled != 0, \"CT_INVALID_MINT_AMOUNT\");\n        _mint(user, amountScaled);\n\n        return previousBalance == 0;\n    }\n\n    /**\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * - Only callable by the LendingPool, as extra state updates there need to be managed\n     * @param user The owner of the aTokens, getting them burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The new liquidity index of the reserve\n     */\n    function burn(\n        address user,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external {\n        uint256 amountScaled = WadRayMath.rayDiv(amount, index);\n        require(amountScaled != 0, \"CT_INVALID_BURN_AMOUNT\");\n        _burn(user, amountScaled);\n\n        ERC20(underlyingAsset).transfer(receiverOfUnderlying, amount);\n    }\n\n    /**\n     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n     * @param user The user whose balance is calculated\n     * @return The balance of the user\n     **/\n    function balanceOf(address user) public view override returns (uint256) {\n        return WadRayMath.rayMul(super.balanceOf(user), lendingPool.index());\n    }\n\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     **/\n    function scaledBalanceOf(address user) external view returns (uint256) {\n        return super.balanceOf(user);\n    }\n}\n"
102     },
103     "src/mocks/MockLendingPool.sol": {
104       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { MockAToken } from \"./MockAToken.sol\";\n\ncontract MockLendingPool {\n    mapping(address => address) public aTokens;\n    uint256 public index = 1000000000000000000000000000;\n\n    constructor() {}\n\n    // for testing purposes; not in actual contract\n    function setLiquidityIndex(uint256 _index) external {\n        index = _index;\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external {\n        ERC20(asset).transferFrom(onBehalfOf, aTokens[asset], amount);\n        MockAToken(aTokens[asset]).mint(onBehalfOf, amount, index);\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256) {\n        if (amount == type(uint256).max) amount = MockAToken(aTokens[asset]).balanceOf(msg.sender);\n\n        MockAToken(aTokens[asset]).burn(msg.sender, to, amount, index);\n\n        return amount;\n    }\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 configuration,\n            uint128 liquidityIndex,\n            uint128 variableBorrowIndex,\n            uint128 currentLiquidityRate,\n            uint128 currentVariableBorrowRate,\n            uint128 currentStableBorrowRate,\n            uint40 lastUpdateTimestamp,\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress,\n            address interestRateStrategyAddress,\n            uint8 id\n        )\n    {\n        asset;\n        configuration;\n        liquidityIndex = uint128(index);\n        variableBorrowIndex;\n        currentLiquidityRate;\n        currentVariableBorrowRate;\n        currentStableBorrowRate;\n        lastUpdateTimestamp;\n        aTokenAddress = aTokens[asset];\n        stableDebtTokenAddress;\n        variableDebtTokenAddress;\n        interestRateStrategyAddress;\n        id;\n    }\n\n    function getReserveNormalizedIncome(address) external view returns (uint256) {\n        return index;\n    }\n\n    function initReserve(address asset, address aTokenAddress) external {\n        aTokens[asset] = aTokenAddress;\n    }\n}\n"
105     },
106     "src/mocks/MockGravity.sol": {
107       "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"lib/solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"lib/solmate/src/utils/SafeTransferLib.sol\";\n\ncontract MockGravity {\n    using SafeTransferLib for ERC20;\n    error InvalidSendToCosmos();\n\n    function sendToCosmos(\n        address _tokenContract,\n        bytes32,\n        uint256 _amount\n    ) external {\n        // we snapshot our current balance of this token\n        uint256 ourStartingBalance = ERC20(_tokenContract).balanceOf(address(this));\n\n        // attempt to transfer the user specified amount\n        ERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // check what this particular ERC20 implementation actually gave us, since it doesn't\n        // have to be at all related to the _amount\n        uint256 ourEndingBalance = ERC20(_tokenContract).balanceOf(address(this));\n\n        // a very strange ERC20 may trigger this condition, if we didn't have this we would\n        // underflow, so it's mostly just an error message printer\n        if (ourEndingBalance <= ourStartingBalance) {\n            revert InvalidSendToCosmos();\n        }\n    }\n\n    receive() external payable {}\n}\n"
108     }
109   },
110   "settings": {
111     "optimizer": {
112       "enabled": true,
113       "runs": 200,
114       "details": {
115         "yul": true,
116         "yulDetails": {
117           "stackAllocation": true
118         }
119       }
120     },
121     "outputSelection": {
122       "*": {
123         "*": [
124           "evm.bytecode",
125           "evm.deployedBytecode",
126           "devdoc",
127           "userdoc",
128           "metadata",
129           "abi"
130         ]
131       }
132     },
133     "libraries": {}
134   }
135 }}