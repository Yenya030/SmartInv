1 pragma solidity ^0.4.23;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 // File: contracts/library/SafeMath.sol
7 // Extracted from a FundRaiser Contract and modified by WIMS
8 // Added enableMinting *Found necessary but is not to be abused else tokens will be burnt
9 // https://wims.io
10 // Compiled with version 0.4.23
11 
12 
13 /**
14  * @title Safe Math
15  *
16  * @dev Library for safe mathematical operations.
17  */
18 library SafeMath {
19     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
20         uint256 c = a * b;
21         assert(a == 0 || c / a == b);
22 
23         return c;
24     }
25 
26     function div(uint256 a, uint256 b) internal pure returns (uint256) {
27         uint256 c = a / b;
28 
29         return c;
30     }
31 
32     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
33         assert(b <= a);
34 
35         return a - b;
36     }
37 
38     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
39         uint256 c = a + b;
40         assert(c >= a);
41 
42         return c;
43     }
44 }
45 
46 // File: contracts/token/ERC20Token.sol
47 
48 /**
49  * @dev The standard ERC20 Token contract base.
50  */
51 contract ERC20Token {
52     
53 	uint256 public totalSupply;  /* shorthand for public function and a property */    
54     function balanceOf(address _owner) public view returns (uint256 balance);
55     function transfer(address _to, uint256 _value) public returns (bool success);
56     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
57     function approve(address _spender, uint256 _value) public returns (bool success);
58     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
59 
60     event Transfer(address indexed _from, address indexed _to, uint256 _value);
61     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
62 }
63 
64 /**
65  * @title Standard Token
66  *
67  * @dev The standard abstract implementation of the ERC20 interface.
68  */
69 contract StandardToken is ERC20Token {
70     using SafeMath for uint256;
71     string public name;
72     string public symbol;
73     uint8 public decimals;
74     
75     mapping (address => uint256) balances;
76     mapping (address => mapping (address => uint256)) internal allowed;
77     
78     /**
79      * @dev The constructor assigns the token name, symbols and decimals.
80      */
81     constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) internal {
82         name = _name;
83         symbol = _symbol;
84         decimals = _decimals;
85 		totalSupply = _totalSupply;
86     }
87 
88     /**
89      * @dev Get the balance of an address.
90      *
91      * @param _address The address which's balance will be checked.
92      *
93      * @return The current balance of the address.
94      */
95     function balanceOf(address _address) public view returns (uint256 balance) {
96         return balances[_address];
97     }
98 
99     /**
100      * @dev Checks the amount of tokens that an owner allowed to a spender.
101      *
102      * @param _owner The address which owns the funds allowed for spending by a third-party.
103      * @param _spender The third-party address that is allowed to spend the tokens.
104      *
105      * @return The number of tokens available to `_spender` to be spent.
106      */
107     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
108         return allowed[_owner][_spender];
109     }
110 
111     /**
112      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
113      * E.g. You place a buy or sell order on an exchange and in that example, the 
114      * `_spender` address is the address of the contract the exchange created to add your token to their 
115      * website and you are `msg.sender`.
116      *
117      * @param _spender The address which will spend the funds.
118      * @param _value The amount of tokens to be spent.
119      *
120      * @return Whether the approval process was successful or not.
121      */
122     function approve(address _spender, uint256 _value) public returns (bool) {
123         allowed[msg.sender][_spender] = _value;
124 
125         emit Approval(msg.sender, _spender, _value);
126 
127         return true;
128     }
129 
130     /**
131      * @dev Transfers `_value` number of tokens to the `_to` address.
132      *
133      * @param _to The address of the recipient.
134      * @param _value The number of tokens to be transferred.
135      */
136     function transfer(address _to, uint256 _value) public returns (bool) {
137         executeTransfer(msg.sender, _to, _value);
138 
139         return true;
140     }
141 
142     /**
143      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
144      *
145      * @param _from The address which approved you to spend tokens on their behalf.
146      * @param _to The address where you want to send tokens.
147      * @param _value The number of tokens to be sent.
148      *
149      * @return Whether the transfer was successful or not.
150      */
151     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
152        // require(_value <= allowed[_from][msg.sender]);        
153         //allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
154         executeTransfer(_from, _to, _value);
155 
156         return true;
157     }
158 
159     /**
160      * @dev Internal function that this reused by the transfer functions
161      */
162     function executeTransfer(address _from, address _to, uint256 _value) internal {
163         require(_to != address(0));
164         require(_value != 0 && _value <= balances[_from]);
165         
166         balances[_from] = balances[_from].minus(_value);
167         balances[_to] = balances[_to].plus(_value);
168 
169         emit Transfer(_from, _to, _value);
170     }
171 }
172 
173 // File: contracts/token/MintableToken.sol
174 
175 /**
176  * @title Mintable Token
177  *
178  * @dev Allows the creation of new tokens.
179  */
180 contract MintableToken is StandardToken {
181     /// @dev The only address allowed to mint coins
182     address public minter;
183 
184     /// @dev Indicates whether the token is still mintable.
185     bool public mintingDisabled = false;
186 
187     /**
188      * @dev Event fired when minting is no longer allowed.
189      */
190     event MintingDisabled();
191     
192     /**
193      * @dev Event fired when minting is no longer allowed.
194      */
195     event MintingEnabled();
196 
197     /**
198      * @dev Allows a function to be executed only if minting is still allowed.
199      */
200     modifier canMint() {
201         require(!mintingDisabled);
202         _;
203     }
204 
205     /**
206      * @dev Allows a function to be called only by the minter
207      */
208     modifier onlyMinter() {
209         require(msg.sender == minter);
210         _;
211     }
212 
213     /**
214      * @dev The constructor assigns the minter which is allowed to mind and disable minting
215      */
216     constructor(address _minter) internal {
217         minter = _minter;
218     }
219 
220     /**
221     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
222     *
223     * @param _to The address which will receive the freshly minted tokens.
224     * @param _value The number of tokens that will be created.
225     */
226     function mint(address _to, uint256 _value) public onlyMinter canMint {
227         totalSupply = totalSupply.plus(_value);
228         balances[_to] = balances[_to].plus(_value);
229 
230         emit Transfer(0x0, _to, _value);
231     }
232 
233     /**
234     * @dev Disable the minting of new tokens. Cannot be reversed.
235     *
236     * @return Whether or not the process was successful.
237     */
238     function disableMinting() public onlyMinter canMint {
239         mintingDisabled = true;
240        
241         emit MintingDisabled();
242     }
243     
244         /**
245     * @dev Enable the minting of new tokens. Can be reversed.
246     *
247     * @return Whether or not the process was successful.
248     */
249     function enableMinting() public onlyMinter canMint {
250         mintingDisabled = false;
251        
252         emit MintingEnabled();
253     }
254 }
255 
256 // File: contracts/token/BurnableToken.sol
257 
258 /**
259  * @title Burnable Token
260  *
261  * @dev Allows tokens to be destroyed.
262  */
263 contract BurnableToken is StandardToken {
264     /**
265      * @dev Event fired when tokens are burned.
266      *
267      * @param _from The address from which tokens will be removed.
268      * @param _value The number of tokens to be destroyed.
269      */
270     event Burn(address indexed _from, uint256 _value);
271 
272     /**
273      * @dev Burnes `_value` number of tokens.
274      *
275      * @param _value The number of tokens that will be burned.
276      */
277     function burn(uint256 _value) public {
278         require(_value != 0);
279 
280         address burner = msg.sender;
281         require(_value <= balances[burner]);
282 
283         balances[burner] = balances[burner].minus(_value);
284         totalSupply = totalSupply.minus(_value);
285 
286         emit Burn(burner, _value);
287         emit Transfer(burner, address(0), _value);
288     }
289 }
290 
291 // File: contracts/trait/HasOwner.sol
292 
293 /**
294  * @title HasOwner
295  *
296  * @dev Allows for exclusive access to certain functionality.
297  */
298 contract HasOwner {
299     // The current owner.
300     address public owner;
301 
302     // Conditionally the new owner.
303     address public newOwner;
304 
305     /**
306      * @dev The constructor.
307      *
308      * @param _owner The address of the owner.
309      */
310     constructor(address _owner) public {
311         owner = _owner;
312     }
313 
314     /** 
315      * @dev Access control modifier that allows only the current owner to call the function.
316      */
317     modifier onlyOwner {
318         require(msg.sender == owner);
319         _;
320     }
321 
322     /**
323      * @dev The event is fired when the current owner is changed.
324      *
325      * @param _oldOwner The address of the previous owner.
326      * @param _newOwner The address of the new owner.
327      */
328     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
329 
330     /**
331      * @dev Transfering the ownership is a two-step process, as we prepare
332      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
333      * the transfer. This prevents accidental lock-out if something goes wrong
334      * when passing the `newOwner` address.
335      *
336      * @param _newOwner The address of the proposed new owner.
337      */
338     function transferOwnership(address _newOwner) public onlyOwner {
339         newOwner = _newOwner;
340     }
341  
342     /**
343      * @dev The `newOwner` finishes the ownership transfer process by accepting the
344      * ownership.
345      */
346     function acceptOwnership() public {
347         require(msg.sender == newOwner);
348 
349         emit OwnershipTransfer(owner, newOwner);
350 
351         owner = newOwner;
352     }
353 }
354 
355 // File: contracts/token/PausableToken.sol
356 
357 /**
358  * @title Pausable Token
359  *
360  * @dev Allows you to pause/unpause transfers of your token.
361  **/
362 contract PausableToken is StandardToken, HasOwner {
363 
364     /// Indicates whether the token contract is paused or not.
365     bool public paused = false;
366 
367     /**
368      * @dev Event fired when the token contracts gets paused.
369      */
370     event Pause();
371 
372     /**
373      * @dev Event fired when the token contracts gets unpaused.
374      */
375     event Unpause();
376 
377     /**
378      * @dev Allows a function to be called only when the token contract is not paused.
379      */
380     modifier whenNotPaused() {
381         require(!paused);
382         _;
383     }
384 
385     /**
386      * @dev Pauses the token contract.
387      */
388     function pause() public onlyOwner whenNotPaused {
389         paused = true;
390         emit Pause();
391     }
392 
393     /**
394      * @dev Unpauses the token contract.
395      */
396     function unpause() public onlyOwner {
397         require(paused);
398 
399         paused = false;
400         emit Unpause();
401     }
402 
403     /// Overrides of the standard token's functions to add the paused/unpaused functionality.
404 
405     function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
406         return super.transfer(_to, _value);
407     }
408 
409     function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
410         return super.approve(_spender, _value);
411     }
412 
413     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
414         return super.transferFrom(_from, _to, _value);
415     }
416 }
417 
418 /**
419  * @title WIMT contract
420  */
421 contract WIMT is MintableToken, BurnableToken, PausableToken {
422     constructor(address _owner, address _minter,  string tokenName,  string tokenSymbol, uint8 tokenDecimals, uint256 __totalSupply)
423         StandardToken
424 		(
425             tokenName,   // Token name
426             tokenSymbol, // Token symbol
427             tokenDecimals,  // Token decimals
428 			__totalSupply //total token supply
429         )
430         HasOwner(_owner)
431         MintableToken(_minter)
432         public
433     {
434     }
435 }