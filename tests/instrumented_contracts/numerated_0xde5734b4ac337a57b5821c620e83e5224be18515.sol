1 /*
2  ____   _______  _______  _______  __   __    __   __  _______  __    _  ___   _  _______  __   __ 
3 |    | |  _    ||  _    ||       ||  | |  |  |  |_|  ||       ||  |  | ||   | | ||       ||  | |  |
4  |   | | | |   || | |   ||_     _||  |_|  |  |       ||   _   ||   |_| ||   |_| ||    ___||  |_|  |
5  |   | | | |   || | |   |  |   |  |       |  |       ||  | |  ||       ||      _||   |___ |       |
6  |   | | |_|   || |_|   |  |   |  |       |  |       ||  |_|  ||  _    ||     |_ |    ___||_     _|
7  |   | |       ||       |  |   |  |   _   |  | ||_|| ||       || | |   ||    _  ||   |___   |   |  
8  |___| |_______||_______|  |___|  |__| |__|  |_|   |_||_______||_|  |__||___| |_||_______|  |___|  
9 
10                                           
11                                            `oyyydssydy-                                             
12                                     `/so/`:hyyhhhyyhhhddyooo+/:-`                                   
13                                      `:dhhdhyhhyyhhyhhhhhhhhhhyyyso+-`                              
14                                `-+oyhhhhhhhhhhhhhhhhhhhhyysssyyyyysoos+/.                           
15                            `:oydhhhhhhhhhhhhhhhhhhhhhhyyyyyyysssssssso+/oo/`                        
16                         `/ydhhhhhhhhhhhhhhhhhhhhhhhyysssssssssssssssossso++s+`                      
17                       -sysyhhhhhhhhhhhhhhhhhhhhhyyssssssysssssssoooosooosso+oy+`                    
18                     .sy+ohhhhhhhhhhhhhhhhhhhhyyyyyyyyyyysssssssssssooosoossso+sy:                   
19                   `oy++syhhhhhhhhhhhhhhddhhhhhhhhhhhhhhhhhhhyysssssssssssssssoosys`                 
20                  :hs+oyhhhhhhhhhhhddddddhysyhhhhhhhhhhhhhhhhhhhhyysssssysssssyssssy`                
21                 ohosyhhhhhhhhhhhhhddddhhsyhyhhhhhhhhddddddddddddhhhyysssyysssyhyhyhh`  `----.       
22               `yhsyhhhhhhdddddddddddhhhyhyshhhhhddhyo+//:::://oshddhhhssshhysyhhhhdds:/-.```-/:`    
23              `yhhhhhhhhhhddmdddddhhhhhhhhhhhhddyo/:-------------:+yddhhyshhhhhhhddhy:`.-//+/-..+`   
24              yhhhhhhhhddddddddddmdddhhhhhhhhdy+:--:::::-----------:ohddhhhhhhhhddhs:-/oyysssyo-.o   
25             +hhhhhhdddhys+/////ydhddddhhdhdds/-:++/::---------------+dmdhhhhhddhho///ss++++++ss.::  
26            `dhhhhdddy+/:------/ddyshdhdddddy/-+s+/-::/+++++:--------:sdddhhhhddho/+ooo+++///++y:.o  
27     `-::::-+dhhhddh+:---::://:oh+/+dhdhsddd+--s////++:`./++oo/-------+hmdhhhddhdhdho+++oo+////+:`o  
28   .:-.`..-/dhhhddy/:-::::::/+os+//odddo+hdd/--:///o/` omo..:hy+------/hmddhdddmddmhddddyssyo///-`o  
29  ::`.-:////mhhhdh//------://++++:-/yddo//sd/:--//++  oNmy-.-sNh/-----/hmddddhdddddmmddyy+++s///--/  
30 ::`./ssooysmhhddo/-----/o/.`.:/o+:-:/os+:-:/:--:/s-  dNNNmmmNNNo-----/hmdddddddddddddyo++//////.o`  
31 +..:s+++++omdhdd+/----:s. :y:-/yyo:----::::-----/o:  sNNNNNNNNNo-----+dmdddddddddmmmmmmy///////:/   
32 o`-/s/////+dhhdd+/----++  mdo/+dNm+-------------:+s. `dNNNNNNNh/-----sddddddddddddmdyoos///////o    
33 o`-/o//:://yhhhdo/:---/o` dNNNNNNNy:-------------:/o-``+dNNNmdosoo+-/hmddddddddddmNddo++/////++     
34 +.-://+syssydhhhh//---:o: .dNNNNNNy:----::::::::::::+++/:+shho/----:ymdddddddddddNsso+++++//o/      
35 `+.-///+oyyhdhhhds/:---:o+.`/ydmdh+:/++//:::-:---::::////+yo:-----:ymmdddddddddddm////////+/`       
36  -/.:+/+oohdhhhhhds//----/++///+oo+/:-------------------://+::--:/hmmdddddddddddmmhs++++/:`         
37   :/./s/:ydhdhhhhhds//:--+soosss+:--------------------------//++sdmmmdddddddmmmmmmmh                
38    -+.-osy+odddhhhhdho//::---/+:-----------://:::--------------/odmmmdddddddmmmmmmd.                
39     `//--:++hyyhdhhhdmhs+///o/--:-:/:-----::-/++/----------------/sdmmddddddmmmmmd.                 
40       .//----:+oyddddddmmdhs/--+-/+oo+/:--:+++/+/-------------...-/ohmmddddmmmmmy`                  
41         `-:/++++/smmdddddmh/---:::++oo+/--//////:---------:++:--:///+hmmddmmmmd/                    
42               ``/hmmdddddd+:------::///:--:///::----------:/ooo+/////sdmmmmmdo`                     
43               -dmdmmmdhyhs//:-------------------------::/oss/////////odmmmh/`                       
44               d/`dmmmdo/:----::::::::::::::-------::/ooo+++//////////odh+.                          
45               . `d-+dmds+/:::---......-----::://+oo+:.``+o///////////s`                             
46                  `  /dy-+o++++++o+++++++ooo+++/:.`   -+s+///////////o-                              
47                      `.   +/////+oshddddy+-.`  `.-/oyhs/://////////o-                               
48                            :+///////+oyddddhhhhhhhhhs+:-/////////++.                                
49                             `//////////+oshhdhhhyso/:--:///////++-                                  
50                               ./+/////////:::::-....-://////+o/.                                    
51                                 `:/+/////////:::::///////++/-                                       
52                                     .::/++/////////+++/:-`                                          
53                                          `.-------.`        
54 
55 The game starts on Saturday, November 10, 2018 at 5:00:00 PM (GMT)
56 
57 https://monkey.game
58 https://discord.gg/3UQ4dNj
59 
60 DISCLAIMER:
61 
62 Please note, during your use of this contract, that online gambling is an entertainment vehicle, and that it carries with it a certain degree of financial risk. 
63 Players should be aware of this risk, and govern themselves accordingly. All users of this contract should exercise responsibility when playing in online casinos, lotteries, and dAPPS. 
64 CIRCUS FREAKS PRODUCTIONS have undertaken the appropriate steps to inform all those interested in online gaming about the dangers of excess play; that could potentially result from such an activity. 
65 There is nothing contained herein that constitutes a guarantee of winning, nor is there an intention to induce anyone into violating any local, state or national laws. 
66 Recognizing that the laws and regulations involving online gaming are different everywhere, readers are advised to check with the laws that exist within their own jurisdiction to ascertain the legality of the activities which are covered.
67 
68 */
69 
70 pragma solidity ^0.4.25;
71 
72 library SafeMath {
73 
74 	function mul(uint256 a, uint256 b) internal pure returns (uint256) {
75 		if (a == 0) {
76 			return 0;
77 		}
78 		uint256 c = a * b;
79 		require(c / a == b, "the SafeMath multiplication check failed");
80 		return c;
81 	}
82 
83 	function div(uint256 a, uint256 b) internal pure returns (uint256) {
84 		require(b > 0, "the SafeMath division check failed");
85 		uint256 c = a / b;
86 		return c;
87 	}
88 
89 	function sub(uint256 a, uint256 b) internal pure returns (uint256) {
90 		require(b <= a, "the SafeMath subtraction check failed");
91 		return a - b;
92 	}
93 
94 	function add(uint256 a, uint256 b) internal pure returns (uint256) {
95 		uint256 c = a + b;
96 		require(c >= a, "the SafeMath addition check failed");
97 		return c;
98 	}
99 
100 	function mod(uint256 a, uint256 b) internal pure returns (uint256) {
101 		require(b != 0, "the SafeMath modulo check failed");
102 		return a % b;
103 	}
104 }
105 
106 contract OneHundredthMonkey {
107 
108 	using SafeMath for uint256;
109 
110 	///////////
111 	//STORAGE//
112 	///////////
113 
114 	//ADMIN
115 	uint256 public adminBalance;
116 	uint256 public foundationBalance;
117 	address public adminBank;
118 	address public foundationFund;
119 	address[] public admins;
120 	mapping (address => bool) public isAdmin;
121 
122 	//GLOBAL
123 	bool public gameActive = false;
124 	bool public earlyResolveACalled = false;
125 	bool public earlyResolveBCalled = false;
126 	uint256 public activationTime = 1541869200; // (GMT): Saturday, November 10, 2018 5:00:00 PM
127 	uint256 public miniGamesPerRound = 100; 
128 	uint256 public miniGamesPerCycle = 1000; 
129 	uint256 public miniGamePotRate = 25; //25%
130 	uint256 public progressivePotRate = 25; //25%
131 	uint256 public roundDivRate = 20; //20%
132 	uint256 public miniGameDivRate = 10; //10%
133 	uint256 public referralRate = 10; //10%
134 	uint256 public miniGameAirdropRate = 5; //5%
135 	uint256 public adminFeeRate = 5; //5%
136 	uint256 public roundPotRate = 48; //48% of progressive pot 
137 	uint256 internal precisionFactor = 18; 
138 	uint256 public seedAreward = 25000000000000000; 
139 	uint256 public seedBreward = 25000000000000000; 
140 	mapping (uint256 => bool) public miniGameSeedAawarded;
141 	mapping (uint256 => bool) public miniGameSeedBawarded;
142 	
143 	//RNG
144 	uint256 internal RNGblockDelay = 1;
145 	uint256 internal salt = 0; 
146 	bytes32 internal hashA; 
147 	bytes32 internal hashB; 
148 
149 	//MINIGAME TRACKING
150 	bool public miniGameProcessing;
151 	uint256 public miniGameCount;
152 	uint256 public miniGameProcessingBegun;
153 	mapping (uint256 => bool) public miniGamePrizeClaimed;
154 	mapping (uint256 => bool) public miniGameAirdropClaimed;
155 	mapping (uint256 => uint256) public miniGameStartTime;
156 	mapping (uint256 => uint256) public miniGameEndTime;
157 	mapping (uint256 => uint256) public miniGameTokens;
158 	mapping (uint256 => uint256) public miniGameTokensLeft;
159 	mapping (uint256 => uint256) public miniGameTokensActive;
160 	mapping (uint256 => uint256) public miniGameTokenRangeMin;
161 	mapping (uint256 => uint256) public miniGameTokenRangeMax;
162 	mapping (uint256 => uint256) public miniGamePrizeNumber;
163 	mapping (uint256 => uint256) public miniGameAirdropNumber;
164 	mapping (uint256 => uint256) public miniGamePrizePot;
165 	mapping (uint256 => uint256) public miniGameAirdropPot;
166 	mapping (uint256 => uint256) public miniGameDivs;
167 	mapping (uint256 => uint256) public miniGameDivsClaimed;
168 	mapping (uint256 => address) public miniGamePrizeWinner;
169 	mapping (uint256 => address) public miniGameAirdropWinner;
170 
171 	//ROUND TRACKING
172 	uint256 public roundCount;
173 	mapping (uint256 => bool) public roundPrizeClaimed;
174 	mapping (uint256 => bool) public roundPrizeTokenRangeIdentified;
175 	mapping (uint256 => uint256) public roundStartTime;
176 	mapping (uint256 => uint256) public roundEndTime;
177 	mapping (uint256 => uint256) public roundTokens;
178 	mapping (uint256 => uint256) public roundTokensActive;
179 	mapping (uint256 => uint256) public roundTokenRangeMin;
180 	mapping (uint256 => uint256) public roundTokenRangeMax;
181 	mapping (uint256 => uint256) public roundPrizeNumber;
182 	mapping (uint256 => uint256) public roundPrizePot;
183 	mapping (uint256 => uint256) public roundDivs;
184 	mapping (uint256 => uint256) public roundDivsClaimed;
185 	mapping (uint256 => uint256) public roundPrizeInMinigame;
186 	mapping (uint256 => address) public roundPrizeWinner;
187 
188 	//CYCLE TRACKING
189 	bool public cycleOver = false;
190 	bool public cylcePrizeClaimed;
191 	bool public cyclePrizeTokenRangeIdentified;
192 	uint256 public totalVolume;
193 	uint256 public totalBuys;
194 	uint256 public tokenSupply;
195 	uint256 public cycleActiveTokens;
196 	uint256 public cycleCount;
197 	uint256 public cycleEnded;
198 	uint256 public cycleProgressivePot;
199 	uint256 public cyclePrizeWinningNumber;
200 	uint256 public cyclePrizeInMinigame;
201 	uint256 public cyclePrizeInRound;
202 	uint256 public cycleStartTime;
203 	address public cyclePrizeWinner;
204 
205 	//TOKEN TRACKING
206 	uint256 public tokenPrice = 0.001 ether; 
207 	uint256 public tokenPriceIncrement = 0.0005 ether; 
208 	uint256 public minTokensPerMiniGame = 10000; //between 1x and 2x this amount of tokens generated each minigame 
209 
210 	//USER TRACKING PUBLIC
211 	address[] public uniqueAddress;
212 	mapping (address => bool) public knownUsers;
213 	mapping (address => uint256) public userTokens;
214 	mapping (address => uint256) public userBalance;
215 	mapping (address => mapping (uint256 => uint256)) public userMiniGameTokens;
216 	mapping (address => mapping (uint256 => uint256)) public userRoundTokens;
217 	mapping (address => mapping (uint256 => uint256[])) public userMiniGameTokensMin;
218 	mapping (address => mapping (uint256 => uint256[])) public userMiniGameTokensMax;
219 
220 	//USER TRACKING INTERNAL
221 	mapping (address => bool) internal userCycleChecked;
222 	mapping (address => uint256) internal userLastMiniGameInteractedWith;
223 	mapping (address => uint256) internal userLastRoundInteractedWith;
224 	mapping (address => uint256) internal userLastMiniGameChecked;
225 	mapping (address => uint256) internal userLastRoundChecked;
226 	mapping (address => mapping (uint256 => uint256)) internal userShareMiniGame;
227 	mapping (address => mapping (uint256 => uint256)) internal userDivsMiniGameTotal;
228 	mapping (address => mapping (uint256 => uint256)) internal userDivsMiniGameClaimed;
229 	mapping (address => mapping (uint256 => uint256)) internal userDivsMiniGameUnclaimed;
230 	mapping (address => mapping (uint256 => uint256)) internal userShareRound;
231 	mapping (address => mapping (uint256 => uint256)) internal userDivsRoundTotal;
232 	mapping (address => mapping (uint256 => uint256)) internal userDivsRoundClaimed;
233 	mapping (address => mapping (uint256 => uint256)) internal userDivsRoundUnclaimed;
234 
235 	
236 	///////////////
237 	//CONSTRUCTOR//
238 	///////////////
239 
240 	constructor(address _adminBank, address _foundationFund, address _adminTwo, address _adminThree, address _adminFour) public {
241 		//set dev bank address and admins
242 		adminBank = _adminBank;
243 		foundationFund = _foundationFund;
244 		admins.push(msg.sender);
245 		isAdmin[msg.sender] = true;
246 		admins.push(_adminTwo);
247 		isAdmin[_adminTwo] = true; 
248 		admins.push(_adminThree);
249 		isAdmin[_adminThree] = true; 
250 		admins.push(_adminFour);
251 		isAdmin[_adminFour] = true; 
252 	}
253 
254 	
255 	/////////////
256 	//MODIFIERS//
257 	/////////////
258 
259 	modifier onlyAdmins() {
260 		require (isAdmin[msg.sender] == true, "you must be an admin");
261 		_;
262 	}
263 
264 	modifier onlyHumans() { 
265 	    require (msg.sender == tx.origin, "only approved contracts allowed"); 
266 	    _; 
267 	  }
268 
269 	modifier gameOpen() {
270 		require (gameActive == true || now >= activationTime, "the game must be open");
271 	  	if (miniGameProcessing == true) {
272 	  		require (block.number > miniGameProcessingBegun + RNGblockDelay, "the round is still processing. try again soon");
273 	  	}
274 	  	_;
275 	}
276     
277     
278     //////////
279 	//EVENTS//
280 	//////////
281 
282 	event adminWithdrew(
283 		uint256 _amount,
284 		address indexed _caller,
285 		string _message 
286 	);
287 
288 	event cycleStarted(
289 		address indexed _caller,
290 		string _message
291 	);
292 
293 	event adminAdded(
294 		address indexed _caller,
295 		address indexed _newAdmin,
296 		string _message
297 	);
298 
299 	event resolvedEarly(
300 		address indexed _caller,
301 		uint256 _pot,
302 		string _message
303 	);
304 
305 	event processingRestarted(
306 		address indexed _caller,
307 		string _message
308 	);
309 
310 	event contractDestroyed(
311 		address indexed _caller,
312 		uint256 _balance,
313 		string _message
314 	);
315 
316 	event userBought(
317 		address indexed _user,
318 		uint256 _tokensBought,
319 		uint256 indexed _miniGameID,
320 		string _message
321 	);
322 
323 	event userReinvested(
324 		address indexed _user,
325 		uint256 _amount,
326 		string _message
327 	);
328 
329 	event userWithdrew(
330 		address indexed _user,
331 		uint256 _amount,
332 		string _message
333 	);
334 
335 	event processingStarted(
336 		address indexed _caller,
337 		uint256 indexed _miniGameID,
338 		uint256 _blockNumber,
339 		string _message
340 	);
341 
342 	event processingFinished(
343 		address indexed _caller,
344 		uint256 indexed _miniGameID,
345 		uint256 _blockNumber,
346 		string _message
347 	);
348 
349 	event newMinigameStarted(
350 		uint256 indexed _miniGameID,
351 		uint256 _newTokens,
352 		string _message
353 	);
354 
355 	event miniGamePrizeAwarded(
356 		uint256 indexed _miniGameID,
357 		uint256 _winningNumber,
358 		uint256 _prize,
359 		string _message
360 	);
361 
362 	event miniGameAirdropAwarded(
363 		uint256 indexed _miniGameID,
364 		uint256 _winningNumber,
365 		uint256 _prize,
366 		string _message
367 	);
368 
369 	event roundPrizeAwarded(
370 		uint256 indexed _roundID,
371 		uint256 _winningNumber,
372 		uint256 _prize,
373 		string _message
374 	);
375 
376 	event cyclePrizeAwarded(
377 		uint256 _winningNumber,
378 		uint256 _prize,
379 		string _message
380 	);
381 
382 
383 	///////////////////
384 	//ADMIN FUNCTIONS//
385 	///////////////////
386 
387 	function adminWithdraw() external {
388 		require (isAdmin[msg.sender] == true || msg.sender == adminBank);
389 		require (adminBalance > 0, "there must be a balance");
390 		uint256 balance = adminBalance;
391 		adminBalance = 0;
392 		adminBank.call.value(balance).gas(100000)();
393 
394 		emit adminWithdrew(balance, msg.sender, "an admin just withdrew to the admin bank");
395 	}
396 
397 	function foundationWithdraw() external {
398 		require (isAdmin[msg.sender] == true || msg.sender == foundationFund);
399 		require (adminBalance > 0, "there must be a balance");
400 		uint256 balance = foundationBalance;
401 		foundationBalance = 0;
402 		foundationFund.call.value(balance).gas(100000)();
403 
404 		emit adminWithdrew(balance, msg.sender, "an admin just withdrew to the foundation fund");
405 	}
406 
407 	//this function begins resolving the round in the event that the game has stalled
408 	//it can be called no sooner than 1 week after the start of a minigame 
409 	//can only be called once. can be restarted with restartMiniGame if 256 blocks pass
410 	function earlyResolveA() external onlyAdmins() onlyHumans() gameOpen() {
411 		require (now > miniGameStartTime[miniGameCount] + 604800 && miniGameProcessing == false, "earlyResolveA cannot be called yet"); //1 week
412 		require (miniGamePrizePot[miniGameCount].sub(seedAreward).sub(seedBreward) >= 0);
413 		
414 		gameActive = false;
415 		earlyResolveACalled = true;
416 		generateSeedA();
417 	}
418 
419 	//this function comlpetes the resolution and ends the game 
420 	function earlyResolveB() external onlyAdmins() onlyHumans() {
421 		require (earlyResolveACalled == true && earlyResolveBCalled == false && miniGameProcessing == true && block.number > miniGameProcessingBegun + RNGblockDelay, "earlyResolveB cannot be called yet"); 
422 		
423 		earlyResolveBCalled = true;
424 		resolveCycle();
425 
426 		emit resolvedEarly(msg.sender, cycleProgressivePot, "the cycle was resolved early"); 
427 	}
428 
429 	//resets the first seed in case the processing is not completed within 256 blocks 
430 	function restartMiniGame() external onlyAdmins() onlyHumans() {
431 		require (miniGameProcessing == true && block.number > miniGameProcessingBegun + 256, "restartMiniGame cannot be called yet");
432 		
433 		generateSeedA();
434 
435 		emit processingRestarted(msg.sender, "mini-game processing was restarted");
436 	}
437 
438 	//admins can close the contract no sooner than 30 days after a full cycle completes 
439 	//users need to withdraw funds before this date or risk losing them
440 	function zeroOut() external onlyAdmins() onlyHumans() {
441 	    require (now >= cycleEnded + 30 days && cycleOver == true, "too early to close the contract"); 
442 	    
443 	  	//event emited before selfdestruct
444 	    emit contractDestroyed(msg.sender, address(this).balance, "contract destroyed"); 
445 
446 	    selfdestruct(foundationFund);
447 	}
448 
449 
450 	//////////////////
451 	//USER FUNCTIONS//
452 	//////////////////
453 
454 	function () external payable onlyHumans() gameOpen() {
455 		//funds sent directly to contract will trigger buy
456 		//no refferal on fallback 
457 		buyInternal(msg.value, 0x0);
458 	}
459 
460 	function buy(address _referral) public payable onlyHumans() gameOpen() {
461 		buyInternal(msg.value, _referral);
462 	}
463 	
464 	function reinvest(uint256 _amount, address _referral) external onlyHumans() gameOpen() {
465 		//update userBalance at beginning of function in case user has new funds to reinvest
466 		updateUserBalance(msg.sender);
467 
468 		require (_amount <= userBalance[msg.sender], "insufficient balance");
469 		require (_amount >= tokenPrice, "you must buy at least one token");
470 
471 		//take funds from user persistent storage and buy
472 		userBalance[msg.sender] = userBalance[msg.sender].sub(_amount);
473 		
474 		buyInternal(_amount, _referral);
475 
476 		emit userReinvested(msg.sender, _amount, "a user reinvested");
477 	}
478 
479 	function withdraw() external onlyHumans() {
480 		//update userBalance at beginning of function in case user has new funds to reinvest
481 		updateUserBalance(msg.sender);
482 
483 		require (userBalance[msg.sender] > 0, "no balance to withdraw");
484 		require (userBalance[msg.sender] <= address(this).balance, "you cannot withdraw more than the contract holds");
485 
486 		//update user accounting and transfer
487 		uint256 toTransfer = userBalance[msg.sender];
488 		userBalance[msg.sender] = 0;
489 		msg.sender.transfer(toTransfer);
490 
491 		emit userWithdrew(msg.sender, toTransfer, "a user withdrew");
492 	}
493 
494 
495 	//////////////////
496 	//VIEW FUNCTIONS//
497 	//////////////////
498 
499 	//helper function for front end token value
500 	function getValueOfRemainingTokens() public view returns(uint256 _tokenValue){
501 		return miniGameTokensLeft[miniGameCount].mul(tokenPrice);
502 	}
503 
504 	//helper function for front end minigame prize pot
505 	function getCurrentMinigamePrizePot() public view returns(uint256 _mgPrize){
506 	    return miniGamePrizePot[miniGameCount];
507 	}
508 
509 	//helper function for front end round prize pot
510 	function getCurrentRoundPrizePot() public view returns(uint256 _rndPrize){
511 	    return roundPrizePot[roundCount];
512 	}
513 
514 	//helper function to return contract balance 
515 	function contractBalance() external view returns(uint256 _contractBalance) {
516 	    return address(this).balance;
517 	}
518 
519 	//check for user divs available
520 	function checkUserDivsAvailable(address _user) external view returns(uint256 _userDivsAvailable) {
521 		return userBalance[_user] + checkDivsMgView(_user) + checkDivsRndView(_user) + checkPrizesView(_user);
522 	}
523 
524 	//user chance of winning minigame prize or airdrop
525 	function userOddsMiniGame(address _user) external view returns(uint256) {
526 		//returns percentage precise to two decimal places (eg 1428 == 14.28% odds)
527 		return userMiniGameTokens[_user][miniGameCount].mul(10 ** 5).div(miniGameTokensActive[miniGameCount]).add(5).div(10);
528 	}
529 
530 	//user chance of winning round prize or airdrop
531 	function userOddsRound(address _user) external view returns(uint256) {
532 		//returns percentage precise to two decimal places (eg 1428 == 14.28% odds)
533 		return userRoundTokens[_user][roundCount].mul(10 ** 5).div(roundTokensActive[roundCount]).add(5).div(10);
534 	}
535 
536 	//user chance of winning cycle prize
537 	function userOddsCycle(address _user) external view returns(uint256) {
538 		//returns percentage precise to two decimal places (eg 1428 == 14.28% odds)
539 		return userTokens[_user].mul(10 ** 5).div(cycleActiveTokens).add(5).div(10);
540 	}
541 
542 	//helper function for minigame data
543 	function miniGameInfo() external view returns(
544 		uint256 _id,
545 		uint256 _miniGameTokens,
546 		uint256 _miniGameTokensLeft,
547 		uint256 _miniGamePrizePot,
548 		uint256 _miniGameAirdropPot,
549 		uint256 _miniGameStartTime
550 		) {
551 
552 		return (
553 			miniGameCount,
554 			miniGameTokens[miniGameCount],
555 			miniGameTokensLeft[miniGameCount],
556 			miniGamePrizePot[miniGameCount],
557 			miniGameAirdropPot[miniGameCount],
558 			miniGameStartTime[miniGameCount]
559 		);
560 	}
561 
562 	//helper function for round data
563 	function roundInfo() external view returns(
564 		uint256 _id,
565 		uint256 _roundPrize,
566 		uint256 _roundStart
567 		) {
568 
569 		return (
570 			roundCount,
571 			cycleProgressivePot / 2,
572 			roundStartTime[roundCount]
573 		);
574 	}
575 
576 	//helper function for contract data
577 	function contractInfo() external view returns(
578 		uint256 _balance,
579 		uint256 _volume,
580 		uint256 _totalBuys,
581 		uint256 _totalUsers,
582 		uint256 _tokenSupply,
583 		uint256 _tokenPrice
584 		) {
585 
586 		return (
587 			address(this).balance,
588 			totalVolume,
589 			totalBuys,
590 			uniqueAddress.length,
591 			tokenSupply,
592 			tokenPrice
593 		);
594 	}
595 
596 	//cycle data	
597 	function cycleInfo() external view returns(
598 		bool _cycleComplete,
599 		uint256 _currentRound,
600 		uint256 _currentMinigame,
601 		uint256 _tokenSupply,
602 		uint256 _progressivePot,
603 		bool _prizeClaimed,
604 		uint256 _winningNumber
605 		) {
606 		bool isActive;
607 		if (miniGameCount < 1000) {
608 			isActive = true;
609 			} else {
610 				isActive = false;
611 			}
612 		
613 		return (
614 			isActive,
615 			roundCount,
616 			miniGameCount,
617 			tokenSupply,
618 			cycleProgressivePot,
619 			cylcePrizeClaimed,
620 			cyclePrizeWinningNumber
621 		);
622 	}
623 
624 
625 	//////////////////////
626 	//INTERNAL FUNCTIONS//
627 	//////////////////////
628 
629 	function startCycle() internal {
630 		require (gameActive == false && cycleCount == 0, "the cycle has already been started");
631 		
632 		gameActive = true;
633 		cycleStart();
634 		roundStart();
635 		miniGameStart();
636 
637 		emit cycleStarted(msg.sender, "a new cycle just started"); 
638 	}
639 
640 	function buyInternal(uint256 _amount, address _referral) internal {
641 		require (_amount >= tokenPrice, "you must buy at least one token");
642 		require (userMiniGameTokensMin[msg.sender][miniGameCount].length < 10, "you are buying too often in this round"); //sets up bounded loop 
643 
644 		//start cycle on first buy
645 		if (gameActive == false && now >= activationTime) {
646 			startCycle();
647 		}
648 
649 		//update divs here to prevent overwriting userLastRoundInteractedWith
650 		if (userLastRoundInteractedWith[msg.sender] < roundCount || userLastMiniGameInteractedWith[msg.sender] < miniGameCount) {
651 			updateUserBalance(msg.sender);
652 		}
653 
654 		//if this is the first tx after processing period is over, call generateSeedB
655 		if (miniGameProcessing == true && block.number > miniGameProcessingBegun + RNGblockDelay) {
656 			generateSeedB();
657 		}
658 
659 		//track user
660 		if (knownUsers[msg.sender] == false) {
661 			uniqueAddress.push(msg.sender);
662 			knownUsers[msg.sender] = true;
663 		}
664 
665 		//assign tokens
666 		uint256 tokensPurchased;
667 		uint256 ethSpent = _amount;
668 		uint256 valueOfRemainingTokens = miniGameTokensLeft[miniGameCount].mul(tokenPrice);
669 
670 		//if round tokens are all sold, push difference to user balance and call generateSeedA
671 		if (ethSpent >= valueOfRemainingTokens) {
672 			uint256 incomingValue = ethSpent;
673 			ethSpent = valueOfRemainingTokens;
674 			tokensPurchased = miniGameTokensLeft[miniGameCount];
675 			miniGameTokensLeft[miniGameCount] = 0;
676 			uint256 ethCredit = incomingValue.sub(ethSpent);
677 			userBalance[msg.sender] += ethCredit;
678 			generateSeedA();
679 		} else {
680 			tokensPurchased = ethSpent.div(tokenPrice);
681 		}
682 
683 		//update user token accounting
684 		userTokens[msg.sender] += tokensPurchased;
685 		userMiniGameTokens[msg.sender][miniGameCount] += tokensPurchased;
686 		userRoundTokens[msg.sender][roundCount] += tokensPurchased;
687 		//add min ranges and save in user accounting
688 		userMiniGameTokensMin[msg.sender][miniGameCount].push(cycleActiveTokens + 1);
689 		userMiniGameTokensMax[msg.sender][miniGameCount].push(cycleActiveTokens + tokensPurchased);
690 		//log last eligible rounds for withdraw checking 
691 		userLastMiniGameInteractedWith[msg.sender] = miniGameCount;
692 		userLastRoundInteractedWith[msg.sender] = roundCount;	
693 
694 		uint256 referralShare = (ethSpent.mul(referralRate)).div(100);
695 		//check referral
696 			if (_referral != 0x0000000000000000000000000000000000000000 && _referral != msg.sender) {
697 	      // assign refferal
698 	      userBalance[_referral] += referralShare;
699 	   	} else if (_referral == 0x0000000000000000000000000000000000000000 || _referral == msg.sender){
700 	   		//if no referral used, add to progessive pot 
701 	   		cycleProgressivePot += referralShare;
702 	   	}
703 
704 		//divide amount by various percentages and distribute
705 		uint256 adminShare = (ethSpent.mul(adminFeeRate)).div(100);
706 		adminBalance += adminShare;
707 
708 		uint256 mgDivs = (ethSpent.mul(miniGameDivRate)).div(100);
709 		miniGameDivs[miniGameCount] += mgDivs;
710 
711 		uint256 roundDivShare = ethSpent.mul(roundDivRate).div(100);
712 		roundDivs[roundCount] += roundDivShare;
713 
714 		uint256 miniGamePrize = ethSpent.mul(miniGamePotRate).div(100);
715 		miniGamePrizePot[miniGameCount] += miniGamePrize;
716 
717 		uint256 miniGameAirdrop = ethSpent.mul(miniGameAirdropRate).div(100);
718 		miniGameAirdropPot[miniGameCount] += miniGameAirdrop;
719 
720 		uint256 cyclePot = ethSpent.mul(progressivePotRate).div(100);
721 		cycleProgressivePot += cyclePot;
722 
723      	//update global token accounting 
724      	if (miniGameTokensLeft[miniGameCount] > 0) {
725 			miniGameTokensLeft[miniGameCount] = miniGameTokensLeft[miniGameCount].sub(tokensPurchased);
726 		}
727 		cycleActiveTokens += tokensPurchased;
728 		roundTokensActive[roundCount] += tokensPurchased;
729 		miniGameTokensActive[miniGameCount] += tokensPurchased;
730 		totalVolume += ethSpent;
731 		totalBuys++;
732 
733         //update user balance, if necessary. done here to keep ensure updateUserBalance never has to search through multiple minigames 
734 		updateUserBalance(msg.sender);
735 
736 		emit userBought(msg.sender, tokensPurchased, miniGameCount, "a user just bought tokens");
737 	}
738 
739 	function checkDivs(address _user) internal {
740 		//set up local shorthand
741 		uint256 _mg = userLastMiniGameInteractedWith[_user];
742 		uint256 _rnd = userLastRoundInteractedWith[_user];
743 
744 		//calculate minigame divs 
745 		userShareMiniGame[_user][_mg] = userMiniGameTokens[_user][_mg].mul(10 ** (precisionFactor + 1)).div(miniGameTokens[_mg] + 5).div(10);
746 	    userDivsMiniGameTotal[_user][_mg] = miniGameDivs[_mg].mul(userShareMiniGame[_user][_mg]).div(10 ** precisionFactor);
747 	    userDivsMiniGameUnclaimed[_user][_mg] = userDivsMiniGameTotal[_user][_mg].sub(userDivsMiniGameClaimed[_user][_mg]);
748 	    //add to user balance
749 	    if (userDivsMiniGameUnclaimed[_user][_mg] > 0) {
750 			//sanity check
751 			assert(userDivsMiniGameUnclaimed[_user][_mg] <= miniGameDivs[_mg]);
752 			assert(userDivsMiniGameUnclaimed[_user][_mg] <= address(this).balance);
753 			//update user accounting
754 			userDivsMiniGameClaimed[_user][_mg] = userDivsMiniGameTotal[_user][_mg];
755 			uint256 shareTempMg = userDivsMiniGameUnclaimed[_user][_mg];
756 			userDivsMiniGameUnclaimed[_user][_mg] = 0;
757 			userBalance[_user] += shareTempMg;
758 			miniGameDivsClaimed[_mg] += shareTempMg;
759 		    }
760 	    //calculate round divs 
761 		userShareRound[_user][_rnd] = userRoundTokens[_user][_rnd].mul(10 ** (precisionFactor + 1)).div(roundTokensActive[_rnd] + 5).div(10);
762 	    userDivsRoundTotal[_user][_rnd] = roundDivs[_rnd].mul(userShareRound[_user][_rnd]).div(10 ** precisionFactor);
763 	    userDivsRoundUnclaimed[_user][_rnd] = userDivsRoundTotal[_user][_rnd].sub(userDivsRoundClaimed[_user][_rnd]);
764 	    //add to user balance
765 	    if (userDivsRoundUnclaimed[_user][_rnd] > 0) {
766 			//sanity check
767 			assert(userDivsRoundUnclaimed[_user][_rnd] <= roundDivs[_rnd]);
768 			assert(userDivsRoundUnclaimed[_user][_rnd] <= address(this).balance);
769 			//update user accounting
770 			userDivsRoundClaimed[_user][_rnd] = userDivsRoundTotal[_user][_rnd];
771 			uint256 shareTempRnd = userDivsRoundUnclaimed[_user][_rnd];
772 			userDivsRoundUnclaimed[_user][_rnd] = 0;
773 			userBalance[_user] += shareTempRnd;
774 			roundDivsClaimed[_rnd] += shareTempRnd;
775 	    }	
776 	}
777 
778 	function checkPrizes(address _user) internal {
779 		//push cycle prizes to persistent storage
780 		if (cycleOver == true && userCycleChecked[_user] == false) {
781 			//get minigame cycle prize was in 
782 			uint256 mg = cyclePrizeInMinigame;
783 			//check if user won cycle prize 
784 			if (cylcePrizeClaimed == false && userMiniGameTokensMax[_user][mg].length > 0) {
785 				//check if user won minigame 
786 				//loop iterations bounded to a max of 10 on buy()
787 	  			for (uint256 i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
788 	  				if (cyclePrizeWinningNumber >= userMiniGameTokensMin[_user][mg][i] && cyclePrizeWinningNumber <= userMiniGameTokensMax[_user][mg][i]) {
789 	  					userBalance[_user] += cycleProgressivePot;
790 	  					cylcePrizeClaimed = true;
791 						cyclePrizeWinner = msg.sender;				
792 	  					break;
793 	  				}
794 	  			}
795 			}
796 			userCycleChecked[_user] = true;
797 		}
798 		//push round prizes to persistent storage
799 		if (roundPrizeClaimed[userLastRoundInteractedWith[_user]] == false && roundPrizeTokenRangeIdentified[userLastRoundInteractedWith[_user]]) {
800 			//get minigame round prize was in 
801 			uint256 rnd = userLastRoundInteractedWith[_user];
802 			uint256 mgp = roundPrizeInMinigame[rnd];
803 			//check if user won round prize
804 			for (i = 0; i < userMiniGameTokensMin[_user][mgp].length; i++) {
805 				if (roundPrizeNumber[rnd] >= userMiniGameTokensMin[_user][mgp][i] && roundPrizeNumber[rnd] <= userMiniGameTokensMax[_user][mgp][i]) {
806 					userBalance[_user] += roundPrizePot[mgp];
807 					roundPrizeClaimed[rnd] = true;
808 					roundPrizeWinner[rnd] = msg.sender;		
809 					break;
810 				}
811 			}
812 			userLastRoundChecked[_user] = userLastRoundInteractedWith[_user];
813 		}
814 		//push minigame prizes to persistent storage
815 		if (userLastMiniGameChecked[_user] < userLastMiniGameInteractedWith[_user] && miniGameCount > userLastMiniGameInteractedWith[_user]) {
816 			//check if user won minigame 
817 			mg = userLastMiniGameInteractedWith[_user];
818 			for (i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
819 				if (miniGamePrizeNumber[mg] >= userMiniGameTokensMin[_user][mg][i] && miniGamePrizeNumber[mg] <= userMiniGameTokensMax[_user][mg][i]) {
820 					userBalance[_user] += miniGamePrizePot[mg];
821 					miniGamePrizeClaimed[mg] = true;
822 					miniGamePrizeWinner[mg] = msg.sender;			
823 					break;
824 				}
825 			}
826 			//check if user won airdrop
827 			for (i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
828 				if (miniGameAirdropNumber[mg] >= userMiniGameTokensMin[_user][mg][i] && miniGameAirdropNumber[mg] <= userMiniGameTokensMax[_user][mg][i]) {
829 					userBalance[_user] += miniGameAirdropPot[mg];
830 					miniGameAirdropClaimed[mg] = true;
831 					miniGameAirdropWinner[mg] = msg.sender;
832 					break;
833 				}
834 			}
835 			//update last mini game checked 
836 			userLastMiniGameChecked[_user] = userLastMiniGameInteractedWith[_user];
837 		}
838 	}
839 
840 	function updateUserBalance(address _user) internal {
841 		checkDivs(_user);
842 		checkPrizes(_user);
843 	}
844 
845 	function miniGameStart() internal {
846 		require (cycleOver == false, "the cycle cannot be over");
847 		
848 		miniGameCount++;
849 		miniGameStartTime[miniGameCount] = now;
850 		//set up special case for correct token range on first minigame 
851 		if (tokenSupply != 0) {
852 			miniGameTokenRangeMin[miniGameCount] = tokenSupply + 1;
853 		} else {
854 			miniGameTokenRangeMin[miniGameCount] = 0;
855 		}
856 		//genreate tokens and update accounting 
857 		miniGameTokens[miniGameCount] = generateTokens();
858 		miniGameTokensLeft[miniGameCount] = miniGameTokens[miniGameCount];
859 		miniGameTokenRangeMax[miniGameCount] = tokenSupply;
860 		//increment token price after 1st minigame 
861 		if (miniGameCount > 1) {
862 			tokenPrice += tokenPriceIncrement;
863 		}
864 		//award prizes and start new round if current round is complete 
865 		if (miniGameCount % miniGamesPerRound == 0 && miniGameCount > 1) {
866 			awardRoundPrize();
867 			roundStart();
868 			tokenPrice = 0.001 ether + 0.0005 ether * roundCount.sub(1);
869 		}
870 		//award prize if cycle is complete 
871 		if (miniGameCount % (miniGamesPerCycle + 1) == 0 && miniGameCount > 1) {
872 			awardCyclePrize();
873 		}
874 
875 		emit newMinigameStarted(miniGameCount, miniGameTokens[miniGameCount], "new minigame started");
876 	}
877 
878 	function roundStart() internal {
879 		require (cycleOver == false, "the cycle cannot be over");
880 
881 		roundCount++;
882 		roundStartTime[roundCount] = now;
883 		//set up special case for correct token range on first round 
884 		if (tokenSupply != 0) {
885 			roundTokenRangeMin[roundCount] = miniGameTokenRangeMax[miniGameCount.sub(1)] + 1;
886 		} else {
887 			roundTokenRangeMin[roundCount] = 0;
888 		}
889 		//log max only when round is complete 
890 		if (roundCount >= 2) {
891 			roundTokenRangeMax[roundCount.sub(1)] = miniGameTokenRangeMax[miniGameCount.sub(1)];
892 			roundTokens[roundCount.sub(1)] = tokenSupply.sub(roundTokenRangeMin[roundCount.sub(1)]);
893 		}
894 	}
895 
896 	function cycleStart() internal {
897 		require (cycleOver == false, "the cycle cannot be over");
898 
899 		cycleCount++;
900 		cycleStartTime = now;
901 	}
902 
903 	function generateTokens() internal returns(uint256 _tokens) {
904 		bytes32 hash = keccak256(abi.encodePacked(salt, hashA, hashB));
905 		uint256 randTokens = uint256(hash).mod(minTokensPerMiniGame);
906     	uint256 newMinGameTokens = randTokens + minTokensPerMiniGame;
907 		tokenSupply += newMinGameTokens;
908 		salt++;
909 
910 		return newMinGameTokens;
911 	}
912 
913 	function generateSeedA() internal {
914 		require (miniGameProcessing == false || miniGameProcessing == true && block.number > miniGameProcessingBegun + 256, "seed A cannot be regenerated right now");
915 		require (miniGameTokensLeft[miniGameCount] == 0 || earlyResolveACalled == true, "active tokens remain in this minigame");
916 		
917 		miniGameProcessing = true;
918 		miniGameProcessingBegun = block.number;
919 		//generate seed 
920 		hashA = blockhash(miniGameProcessingBegun - 1);
921 		//log end times
922 		if (miniGameCount > 1) {
923 			miniGameEndTime[miniGameCount] = now;
924 		}
925 		if (miniGameCount % miniGamesPerRound == 0) {
926 			roundEndTime[roundCount] = now;
927 		}
928 		//award processing bounty
929 		if (miniGameSeedAawarded[miniGameCount] == false) {
930 			userBalance[msg.sender] += seedAreward;
931 			miniGameSeedAawarded[miniGameCount] = true;
932 		}
933 		salt++;
934 
935 		emit processingStarted(msg.sender, miniGameCount, block.number, "processing started");
936 	}
937 
938 	function generateSeedB() internal {
939 		//gererate seed 
940 		hashB = blockhash(miniGameProcessingBegun + RNGblockDelay);
941 		//awared prizes 
942 		awardMiniGamePrize();
943 		awardMiniGameAirdrop();
944 		//award processing bounty 
945 		if (miniGameSeedBawarded[miniGameCount] == false) {
946 			userBalance[msg.sender] += seedBreward;
947 			miniGameSeedBawarded[miniGameCount] = true;
948 		}
949 		//start next minigame
950 		miniGameStart();
951 		miniGameProcessing = false;
952 		salt++;
953 
954 		emit processingFinished(msg.sender, miniGameCount, block.number, "processing finished");
955 	}
956 
957 	function awardMiniGamePrize() internal {
958 		bytes32 hash = keccak256(abi.encodePacked(salt, hashA, hashB));
959 	    uint256 winningNumber = uint256(hash).mod(miniGameTokens[miniGameCount].sub(miniGameTokensLeft[miniGameCount]));
960 	    miniGamePrizeNumber[miniGameCount] = winningNumber + miniGameTokenRangeMin[miniGameCount];
961 	    miniGamePrizePot[miniGameCount] = miniGamePrizePot[miniGameCount].sub(seedAreward).sub(seedBreward);
962 	    salt++;
963 
964 	    emit miniGamePrizeAwarded(miniGameCount, winningNumber, miniGamePrizePot[miniGameCount], "minigame prize awarded");
965 	}
966 
967 	function awardMiniGameAirdrop() internal {
968 		bytes32 hash = keccak256(abi.encodePacked(salt, hashA, hashB));
969 	    uint256 winningNumber = uint256(hash).mod(miniGameTokens[miniGameCount].sub(miniGameTokensLeft[miniGameCount]));
970 	    miniGameAirdropNumber[miniGameCount] = winningNumber + miniGameTokenRangeMin[miniGameCount];
971 	    salt++;
972 
973 	    emit miniGameAirdropAwarded(miniGameCount, winningNumber, miniGameAirdropPot[miniGameCount], "minigame airdrop awarded");
974 	}
975 
976 	function awardRoundPrize() internal {
977 		bytes32 hash = keccak256(abi.encodePacked(salt, hashA, hashB));
978 		uint256 currentRoundTokens;
979 		if (miniGameCount > 1) {
980 			currentRoundTokens = miniGameTokenRangeMax[miniGameCount.sub(1)].sub(roundTokenRangeMin[roundCount]);
981 		//handles edge case of early resolve during the first minigame 
982 		} else if (miniGameCount == 1) {
983 			currentRoundTokens = miniGameTokensActive[1];
984 		}
985 	    uint256 winningNumber = uint256(hash).mod(currentRoundTokens);
986 	    roundPrizeNumber[roundCount] = winningNumber + roundTokenRangeMin[roundCount];
987 	    //calculate round prize here 
988 	    uint256 roundPrize = cycleProgressivePot.mul(roundPotRate).div(100);
989 		uint256 adminShare = cycleProgressivePot.mul(4).div(100);
990 		foundationBalance += adminShare;
991 	    roundPrizePot[roundCount] = roundPrize;
992 	    cycleProgressivePot = roundPrize;
993 	    narrowRoundPrize(roundCount);
994 	    salt++;
995 
996 		emit roundPrizeAwarded(roundCount, winningNumber, roundPrize, "round prize awarded");
997 	}
998 
999 	function awardCyclePrize() internal {
1000 		bytes32 hash = keccak256(abi.encodePacked(salt, hashA, hashB));
1001 	    uint256 winningNumber;
1002 	    if (miniGameCount > 1) {
1003 	    	winningNumber = uint256(hash).mod(miniGameTokenRangeMax[miniGameCount - 1]);
1004 	    //handles edge case of early resolve during the first minigame 
1005 	    } else if (miniGameCount == 1) {
1006 	    	winningNumber = uint256(hash).mod(miniGameTokensActive[1]);
1007 	    }
1008 	    cyclePrizeWinningNumber = winningNumber;
1009 	    gameActive = false;
1010 	    cycleEnded = now;
1011 	    cycleOver = true;
1012 	    narrowCyclePrize();
1013 	    salt++;
1014 
1015 		emit cyclePrizeAwarded(winningNumber, cycleProgressivePot, "cycle prize awarded");
1016 	}
1017 
1018 	function resolveCycle() internal {
1019 		//generate hashB here in instead of calling generateSeedB
1020 		hashB = blockhash(miniGameProcessingBegun + RNGblockDelay);
1021 		//award prizes 
1022 		awardMiniGamePrize();
1023 		awardMiniGameAirdrop();
1024 		awardRoundPrize();
1025 		awardCyclePrize();
1026 		//close game
1027 		miniGameProcessing = false;
1028 		gameActive = false;
1029 	}
1030 
1031 	//narrows down the token range of a round to a specific miniGame
1032 	//reduces the search space on user prize updates 
1033 	function narrowRoundPrize(uint256 _ID) internal returns(uint256 _miniGameID) {
1034 		//set up local accounting
1035 		uint256 miniGameRangeMin; 
1036 		uint256 miniGameRangeMax;
1037 		if (_ID == 1) {
1038 			miniGameRangeMin = 1;
1039 			miniGameRangeMax = miniGamesPerRound;
1040 		} else if (_ID >= 2) {
1041 			miniGameRangeMin = _ID.mul(miniGamesPerRound);
1042 			miniGameRangeMax = miniGameRangeMin + miniGamesPerRound - 1;
1043 		}	
1044 		//loop through each minigame to check prize number
1045 		//log globaly so this only needs to be called once per prize 
1046 	    for (uint256 i = miniGameRangeMin; i <= miniGameRangeMax; i++) {
1047 		    if (roundPrizeNumber[_ID] >= miniGameTokenRangeMin[i] && roundPrizeNumber[_ID] <= miniGameTokenRangeMax[i]) {
1048 	        roundPrizeInMinigame[_ID] = i;
1049 	        roundPrizeTokenRangeIdentified[_ID] = true;
1050 	        return roundPrizeInMinigame[_ID];
1051 	        break;
1052 		    }
1053 	    }	
1054 	}
1055 
1056 	//narrows down the token range of a round to a specific miniGame
1057 	//reduces the search space on user prize updates 
1058 	function narrowCyclePrize() internal returns(uint256 _miniGameID) {
1059 		//first identify round 
1060 	    for (uint256 i = 1; i <= roundCount; i++) {
1061 	      if (cyclePrizeWinningNumber >= roundTokenRangeMin[i] && cyclePrizeWinningNumber <= roundTokenRangeMax[i]) {
1062 	        cyclePrizeInRound = i;
1063 	        break;
1064 	      }
1065 	    }
1066 	    //set up minigame local accounting 
1067 	    uint256 miniGameRangeMin; 
1068 		uint256 miniGameRangeMax;
1069 		uint256 _ID = cyclePrizeInRound;
1070 		if (_ID == 1) {
1071 			miniGameRangeMin = 1;
1072 			miniGameRangeMax = miniGamesPerRound;
1073 		} else if (_ID >= 2) {
1074 			miniGameRangeMin = _ID.mul(miniGamesPerRound);
1075 			miniGameRangeMax = miniGameRangeMin + miniGamesPerRound - 1;
1076 		}	
1077 		//loop through each minigame to check prize number
1078 		//log globaly so this only needs to be called once per prize  
1079 	    for (i = miniGameRangeMin; i <= miniGameRangeMax; i++) {
1080 			if (cyclePrizeWinningNumber >= miniGameTokenRangeMin[i] && cyclePrizeWinningNumber <= miniGameTokenRangeMax[i]) {
1081 				cyclePrizeInMinigame = i;
1082 				cyclePrizeTokenRangeIdentified = true;
1083 				return cyclePrizeInMinigame;
1084 				break;
1085 			}
1086 	    }	
1087 	}
1088 
1089 	//helper function for up to date front end balances without state change
1090 	function checkDivsMgView(address _user) internal view returns(uint256 _divs) {
1091 		//set up local shorthand
1092 		uint256 _mg = userLastMiniGameChecked[_user];
1093 		uint256 mgShare = userShareMiniGame[_user][_mg];
1094 		uint256 mgTotal = userDivsMiniGameTotal[_user][_mg];
1095 		uint256 mgUnclaimed = userDivsMiniGameUnclaimed[_user][_mg];
1096 		//calculate minigame divs 
1097 		mgShare = userMiniGameTokens[_user][_mg].mul(10 ** (precisionFactor + 1)).div(miniGameTokens[_mg] + 5).div(10);
1098 	    mgTotal = miniGameDivs[_mg].mul(mgShare).div(10 ** precisionFactor);
1099 	    mgUnclaimed = mgTotal.sub(userDivsMiniGameClaimed[_user][_mg]);
1100 
1101 	    return mgUnclaimed;
1102 	}
1103 	
1104 	//helper function for up to date front end balances without state change
1105 	function checkDivsRndView(address _user) internal view returns(uint256 _divs) {
1106 		//set up local shorthand
1107 		uint256 _rnd = userLastRoundChecked[_user];
1108 		uint256 rndShare = userShareRound[_user][_rnd];
1109 		uint256 rndTotal = userDivsRoundTotal[_user][_rnd];
1110 		uint256 rndUnclaimed = userDivsRoundUnclaimed[_user][_rnd];
1111         //calculate round divs 
1112 		rndShare = userRoundTokens[_user][_rnd].mul(10 ** (precisionFactor + 1)).div(roundTokensActive[_rnd] + 5).div(10);
1113 	    rndTotal = roundDivs[_rnd].mul(rndShare).div(10 ** precisionFactor);
1114 	    rndUnclaimed = rndTotal.sub(userDivsRoundClaimed[_user][_rnd]);
1115 
1116 	    return rndUnclaimed;
1117 	}
1118 
1119 	//helper function for up to date front end balances without state change
1120 	function checkPrizesView(address _user) internal view returns(uint256 _prizes) {
1121 		//local accounting
1122 		uint256 prizeValue;
1123 		//push cycle prizes to persistent storage
1124 		if (cycleOver == true && userCycleChecked[_user] == false) {
1125 			//get minigame cycle prize was in 
1126 			uint256 mg;
1127 			if (cyclePrizeTokenRangeIdentified == true) {
1128 				mg = cyclePrizeInMinigame;
1129 			} else {
1130 				narrowCyclePrizeView();
1131 				mg = cyclePrizeInMinigame;
1132 			}
1133 			//check if user won cycle prize 
1134 			if (cylcePrizeClaimed == false && userMiniGameTokensMax[_user][mg].length > 0) {
1135 				//check if user won minigame 
1136 				//loop iterations bounded to a max of 10 on buy()
1137 				for (uint256 i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
1138 					if (cyclePrizeWinningNumber >= userMiniGameTokensMin[_user][mg][i] && cyclePrizeWinningNumber <= userMiniGameTokensMax[_user][mg][i]) {
1139 						prizeValue += cycleProgressivePot;			
1140 						break;
1141 					}
1142 				}
1143 			}
1144 		}
1145 		//push round prizes to persistent storage
1146 		if (userLastRoundChecked[_user] < userLastRoundInteractedWith[_user] && roundCount > userLastRoundInteractedWith[_user]) {
1147 			//get minigame round prize was in 
1148 			uint256 mgp;
1149 			uint256 _ID = userLastRoundChecked[_user];
1150 			if (roundPrizeTokenRangeIdentified[_ID] == true) {
1151 				mgp = roundPrizeInMinigame[_ID];
1152 			} else {
1153 				narrowRoundPrizeView(_ID);
1154 				mgp = roundPrizeInMinigame[_ID];
1155 			}
1156 			//check if user won round prize
1157 			for (i = 0; i < userMiniGameTokensMin[_user][mgp].length; i++) {
1158 				if (roundPrizeNumber[_ID] >= userMiniGameTokensMin[_user][mgp][i] && roundPrizeNumber[_ID] <= userMiniGameTokensMax[_user][mgp][i]) {
1159 					prizeValue += roundPrizePot[mgp];	
1160 					break;
1161 				}
1162 			}
1163 		}
1164 		//push minigame prizes to persistent storage
1165 		if (userLastMiniGameChecked[_user] < userLastMiniGameInteractedWith[_user] && miniGameCount > userLastMiniGameInteractedWith[_user]) {
1166 			//check if user won minigame 
1167 			mg = userLastMiniGameInteractedWith[_user];
1168 			for (i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
1169 				if (miniGamePrizeNumber[mg] >= userMiniGameTokensMin[_user][mg][i] && miniGamePrizeNumber[mg] <= userMiniGameTokensMax[_user][mg][i]) {
1170 					prizeValue += miniGamePrizePot[mg];			
1171 					break;
1172 				}
1173 			}
1174 			//check if user won airdrop
1175 			for (i = 0; i < userMiniGameTokensMin[_user][mg].length; i++) {
1176 				if (miniGameAirdropNumber[mg] >= userMiniGameTokensMin[_user][mg][i] && miniGameAirdropNumber[mg] <= userMiniGameTokensMax[_user][mg][i]) {
1177 					prizeValue += miniGameAirdropPot[mg];
1178 					break;
1179 				}
1180 			}
1181 		}
1182 		return prizeValue;
1183 	}
1184 
1185 	//helper function for up to date front end balances without state change
1186 	function narrowRoundPrizeView(uint256 _ID) internal view returns(uint256 _miniGameID) {
1187 		//set up local accounting
1188 		uint256 winningNumber = roundPrizeNumber[_ID];
1189 		uint256 miniGameRangeMin; 
1190 		uint256 miniGameRangeMax;
1191 		if (_ID == 1) {
1192 			miniGameRangeMin = 1;
1193 			miniGameRangeMax = miniGamesPerRound;
1194 		} else if (_ID >= 2) {
1195 			miniGameRangeMin = _ID.mul(miniGamesPerRound);
1196 			miniGameRangeMax = miniGameRangeMin + miniGamesPerRound - 1;
1197 		}	
1198 		//loop through each minigame to check prize number
1199 		//log globaly so this only needs to be called once per prize 
1200 	    for (uint256 i = miniGameRangeMin; i <= miniGameRangeMax; i++) {
1201 			if (winningNumber >= miniGameTokenRangeMin[i] && winningNumber <= miniGameTokenRangeMax[i]) {
1202 				return i;
1203 				break;
1204 			}
1205 	    }		
1206 	}
1207 
1208 	//helper function for up to date front end balances without state change
1209 	function narrowCyclePrizeView() internal view returns(uint256 _miniGameID) {
1210 		//set up local accounting
1211 		uint256 winningNumber = cyclePrizeWinningNumber;
1212 		uint256 rnd;
1213 		//first identify round 
1214 	    for (uint256 i = 1; i <= roundCount; i++) {
1215 			if (winningNumber >= roundTokenRangeMin[i] && winningNumber <= roundTokenRangeMax[i]) {
1216 				rnd = i;
1217 				break;
1218 			}
1219 	    }
1220 	    //set up minigame local accounting 
1221 	    uint256 miniGameRangeMin; 
1222 			uint256 miniGameRangeMax;
1223 			uint256 _ID = rnd;
1224 			if (_ID == 1) {
1225 				miniGameRangeMin = 1;
1226 				miniGameRangeMax = miniGamesPerRound;
1227 			} else if (_ID >= 2) {
1228 				miniGameRangeMin = _ID.mul(miniGamesPerRound);
1229 				miniGameRangeMax = miniGameRangeMin + miniGamesPerRound - 1;
1230 			}	
1231 			//loop through each minigame to check prize number
1232 			//log globaly so this only needs to be called once per prize  
1233 	    for (i = miniGameRangeMin; i <= miniGameRangeMax; i++) {
1234 			if (winningNumber >= miniGameTokenRangeMin[i] && winningNumber <= miniGameTokenRangeMax[i]) {
1235 				return i;
1236 				break;
1237 			}
1238 	    }			
1239 	}
1240 }