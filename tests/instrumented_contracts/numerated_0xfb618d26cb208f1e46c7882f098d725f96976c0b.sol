1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/solmate/src/auth/Owned.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
6     },
7     "lib/solmate/src/tokens/ERC1155.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
9     },
10     "lib/solmate/src/tokens/ERC721.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
12     },
13     "lib/solmate/src/utils/LibString.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"
15     },
16     "src/Mailbomb.sol": {
17       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {ERC1155} from \"solmate/tokens/ERC1155.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Main} from \"./Main.sol\";\n\n/** \n@title Mailbomb\n@author lzamenace.eth\n@notice This contract contains ERC-1155 Mailbomb tokens (BOMB) which are used as\nutility tokens for the Unaboomer NFT project and chain based game.\nMailbombs can be delivered to other players to \"kill\" tokens they hold, which \ntoggles the image to a dead / exploded image, and burns the underlying BOMB token. \n@dev All contract functions regarding token burning and minting are limited to \nthe Main interface where the logic and validation resides.\n*/\ncontract Mailbomb is ERC1155, Owned {\n\n    /// Track the total number of bombs assembled (tokens minted)\n    uint256 public bombsAssembled;\n    /// Track the number of bombs that have exploded (been burned)\n    uint256 public bombsExploded;\n    /// Base URI for the bomb image - all bombs use the same image\n    string public baseURI;\n    /// Contract address of the deployed Main contract interface to the game\n    Main public main;\n\n    constructor() ERC1155() Owned(msg.sender) {}\n\n    // =========================================================================\n    //                              Admin\n    // =========================================================================\n\n    /// Set metadata URI for all BOMB (token 1)\n    /// @param _baseURI IPFS hash or URL to retrieve JSON metadata\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    /// Set main contract address for executing functions\n    /// @param _address Contract address of the deployed Main contract\n    function setMainContract(address _address) external onlyOwner {\n        main = Main(_address);\n    }\n\n    // =========================================================================\n    //                              Modifiers\n    // =========================================================================\n\n    /// Limit function execution to deployed Main contract\n    modifier onlyMain {\n        require(msg.sender == address(main), \"invalid msg sender\");\n        _;\n    }\n\n    // =========================================================================\n    //                              Tokens\n    // =========================================================================\n\n    /// Mint tokens from main contract\n    /// @param _to Address to mint BOMB tokens to\n    /// @param _amount Amount of BOMB tokens to mint\n    function create(address _to, uint256 _amount) external onlyMain {\n        bombsAssembled += _amount;\n        super._mint(_to, 1, _amount, \"\");\n    }\n\n    /// Burn spent tokens from main contract\n    /// @param _from Address to burn BOMB tokens from\n    /// @param _amount Amount of BOMB tokens to burn\n    function explode(address _from, uint256 _amount) external onlyMain {\n        bombsExploded += _amount;\n        super._burn(_from, 1, _amount);\n    }\n\n    /// Get the total amount of bombs that have been assembled (minted)\n    /// @return supply Number of bombs assembled in totality (minted)\n    function totalSupply() public view returns (uint256 supply) {\n        return bombsAssembled;\n    }\n\n    /// Return URI to retrieve JSON metadata from - points to images and descriptions\n    /// @param _tokenId Unused as all bombs point to same metadata URI\n    /// @return string IPFS or HTTP URI to retrieve JSON metadata from\n    function uri(uint256 _tokenId) public view override returns (string memory) {\n        return baseURI;\n    }\n\n    /// Checks if contract supports a given interface\n    /// @param interfaceId The interface ID to check if contract supports\n    /// @return bool Boolean value if contract supports interface ID or not\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC1155) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
18     },
19     "src/Main.sol": {
20       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n//                                     ___ooo_..._.                                         \n//                                 .___.  o_      __.                                       \n//                             ._.._   ._o.         ..o_.                                   \n//                         _oo_...._._.              .._.                                 \n//                     __..      o.   ._               __                                \n//                     ._..       .o.....                  .o.                              \n//                 .o.     ....___.                        __.                            \n//                 __.     .... _o                             __.                          \n//             __       ..._.______..                   .__   _x_.                       \n//             __      .....   ..._ooxo__..                .__.  oo.                      \n//             o. .      .__ooo_.    ..__oxo__.              ..oo_xo                      \n//             ._...  ._oxxxxxoxxxx__.       ______._..          .oxx_                     \n//             __.  .oxx_ooo__oxo.xooxoo___.         .___          .oo                     \n//             __  _o__o_._.____o ____.oo_.oxx___.       .           .oo.                   \n//         ._. _oxoo_.o_ .x   o_....____. .xxoxx__.        ._        _o                   \n//         ._o._oxx_.o..o_ _xo  oo.._. o.    .x..o_xo__      .x_        __                  \n//     __._oxxo__.o..o.  __o_. .o.  o_o   o_o .._o_ox__    .oo.       __                 \n//     .o _xxxxo_  _o.oo_..._o___.._x__xoox_.___. ...ooxx_    oo_       _.                \n//     o _xxxxxo.......__.........     .._oooooo____.....___   .oo_     ..                \n//     _. _xxxxxo.._ooxxxxxxxxxxxxx_..__xxxxxxxxxxxxxxxxxx__.__   .o_                      \n//     _..oxxxxo._xooxxxxxxxxxxxxxxx.  _xo   ..oxxxxxxxxxxxxx._x_   .x.                    \n//     _..xxxxxxox..  ._.oxxxxxxxxxo...._xo.    ...oxxxxxxxxxx.xxo   .o.                   \n//     _..xxxxxxxxxx_.._xxxxxxxxxxo._..___xxo__oxxxxxxxxxxxxxx.xxx    _.                   \n//     _..xxoxxxxxxxxxxxxxxxxxxxxx o.   o_.xxxxxxxxxxxxxxxxxx_ xxx    _.                   \n//     _o.ox .xxoxxxxxxxxxxxxxxxx.__.   ox_.oxxxxxxxxxxxxxxx_  xxx_  .o.                   \n//     .._xo ox_ _xxxxxxxxxxxx_..._.  _ooo_._oxxxxxxxxxxxx_...xoxo  ._   ..               \n//     .._o.._o. ._oxxxxxx___...o_   .  ._..._ooxxxxxxo_..o o..ox.  _.  .o               \n//         _.xxo.o_ ...._oo_... .o._         __ _..._oo_..__. ._.oxxo  .o  __               \n//         xxx._x    .....   _oo.oo_..._o_.__     .....  ._ _xxxxxo     .o.               \n//         xxx._x           _..ox_oxxxxxxxxxx_         .ox. _xxxxxo     .x.               \n//         o.o_.x_       ...  .. . _oo_ _oxxo_..       oxx. _xxxxo.   oo _.               \n//         .o.oooo      ._ .__ ..__o._..___.___.      .xxx. _xxo.    ox_._                \n//             .xxxo       .x__._.______...____.__     _xx_ .ox.   .oox_ o.                \n//             .xxx_       _..    .......____._ _    .oxo..oo   .oxxxo  o                 \n//             _._xx_.            .._o_.            _xo_.oxo   _xxxxx_ _.                 \n//             .o_.oxx_.        ._________        .oo_.oxx_   oxxxo__ ._                  \n//                 __ _xxx_                       .oo_.oxxx_   _xo_ ._oo_                   \n//                 ._ .oxxx_.                  .oo__oxxxo.   ._  _oxxo.                    \n//                 __  _xx___              .____.oxxo_. __    .xxxxo                      \n//                 __  oxx _o_.  ........__..ooxo_. ___.   ._xxxooxo_..                  \n//                 ._xoo_xx_  _ox__________oxxx_. .__.    ..oxxxx_.  ._oo_.               \n//             ......_o__o_xox_  .o__...oxxxxxo__._oo______oxxxxxo_.__..  ..___.            \n//         ...... .___   .o_.ox_         oxxo. .o oxxxxxxooooooo_.     ___.   ..__.         \n// ._....   ._._       o_. .o_  _.  .oxo__oxx_.oo__                    .__.    ._..      \n// ...     .._.          o_.   __.xxxoo__xxo__o _.                          ._.    .._.    \n//         ..             o_.    .o._ooo__.   o__.                                          \n//                     o_.    .._.o.      _.__                                           \n//                     o_.    ..x_o.      o o                                            \n\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Unaboomer} from \"./Unaboomer.sol\";\nimport {Mailbomb} from \"./Mailbomb.sol\";\n\n/** \n@title UnaboomerNFT\n@author lzamenace.eth\n@notice This is the main contract interface for the Unaboomer NFT project drop and chain based game.\nIt contains the logic between an ERC-721 contract containing Unaboomer tokens (pixelated Unabomber \ninspired profile pictures) and an ERC-1155 contract containing Mailbomb tokens (utility tokens).\nUnaboomer is a chain based game with some mechanics based around \"killing\" other players by sending \nthem mailbombs until a certain amount of players or \"survivors\" remain. The motif was inspired by \nthe real life story of Theodore Kaczynski, known as the Unabomber, who conducted a nationwide \nmail bombing campaign against people he believed to be advancing modern technology and the \ndestruction of the environment. Ironic, isn't it? \n*/\ncontract Main is Owned {\n\n    /// Track the number of kills for each address\n    mapping(address => uint256) public killCount;\n    /// Index addresses to form a basic leaderboard\n    mapping(uint256 => address) public leaderboard;\n    /// Point to the latest leaderboard update\n    uint256 public leaderboardPointer;\n    /// Price of the Unaboomer ERC-721 token\n    uint256 public unaboomerPrice = 0.005 ether;\n    /// Price of the Mailbomb ERC-1155 token\n    uint256 public bombPrice = 0.0025 ether;\n    /// If mail bombs can be sent by players\n    bool public mayhem;\n    /// Unaboomer contract\n    Unaboomer public unaboomer;\n    /// Mailbomb contract\n    Mailbomb public mailbomb;\n\n    /// SentBomb event is for recording the results of sendBombs for real-time feedback to a frontend interface\n    /// @param from Sender of the bombs\n    /// @param tokenId Unaboomer token which was targeted\n    /// @param hit Whether or not the bomb killed the token or not (was a dud / already killed)\n    /// @param owned Whether or not the sender was the owner of the BOOMER token\n    event SentBomb(address indexed from, uint256 indexed tokenId, bool hit, bool owned);\n\n    constructor() Owned(msg.sender) {}\n\n    // =========================================================================\n    //                              Admin\n    // =========================================================================\n\n    /// Withdraw funds to contract owner\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        (bool success, ) = payable(msg.sender).call{value: balance}(\"\");\n        require(success, \"failed to withdraw\");\n    }\n\n    /// Set price per BOOMER\n    /// @param _price Price in wei to mint BOOMER token\n    function setBoomerPrice(uint256 _price) external onlyOwner {\n        unaboomerPrice = _price;\n    }\n\n    /// Set price per BOMB\n    /// @param _price Price in wei to mint BOMB token\n    function setBombPrice(uint256 _price) external onlyOwner {\n        bombPrice = _price;\n    }\n\n    /// Set contract address for Unaboomer tokens\n    /// @param _address Address of the Unaboomer / BOOMER contract\n    function setUnaboomerContract(address _address) external onlyOwner {\n        unaboomer = Unaboomer(_address);\n    }\n\n    /// Set contract address for Mailbomb tokens\n    /// @param _address Address of the Mailbomb / BOMB contract\n    function setMailbombContract(address _address) external onlyOwner {\n        mailbomb = Mailbomb(_address);\n    }\n\n    /// Toggle mayhem switch to enable mail bomb sending\n    function toggleMayhem() external onlyOwner {\n        mayhem = !mayhem;\n    }\n\n    // =========================================================================\n    //                              Modifiers\n    // =========================================================================\n\n    /// This modifier prevents actions once the Unaboomer survivor count is breached.\n    /// The game stops; no more bombing/killing. Survivors make it to the next round.\n    modifier missionNotCompleted {\n        require(\n            unaboomer.burned() < (unaboomer.MAX_SUPPLY() - unaboomer.MAX_SURVIVOR_COUNT()), \n            \"mission already completed\"\n        );\n        _;\n    }\n\n    // =========================================================================\n    //                              Getters\n    // =========================================================================\n\n    /// Get BOOMER token balance of wallet \n    /// @param _address Wallet address to query balance of BOOMER token\n    /// @return balance Amount of BOOMER tokens owned by _address\n    function unaboomerBalance(address _address) public view returns (uint256) {\n        return unaboomer.balanceOf(_address);\n    }\n\n    /// Get BOOMER amount minted (including ones that have been burned/killed)\n    /// @param _address Wallet address to query the amount of BOOMER token minted\n    /// @return balance Amount of BOOMER tokens that have been minted by _address\n    function unaboomersMinted(address _address) public view returns (uint256) {\n        return unaboomer.tokensMintedByWallet(_address);\n    }\n\n    /// Get BOOMER token total supply\n    /// @return supply Amount of BOOMER tokens minted in total\n    function unaboomersRadicalized() public view returns (uint256) {\n        return unaboomer.minted();\n    }\n\n    /// Get BOOMER kill count (unaboomers killed)\n    /// @return killCount Amount of BOOMER tokens \"killed\" (dead pfp)\n    function unaboomersKilled() public view returns (uint256) {\n        return unaboomer.burned();\n    }\n\n    /// Get BOOMER token max supply\n    /// @return maxSupply Maximum amount of BOOMER tokens that can ever exist\n    function unaboomerMaxSupply() public view returns (uint256) {\n        return unaboomer.MAX_SUPPLY();\n    }\n\n    /// Get BOOMER token survivor count\n    /// @return survivorCount Maximum amount of BOOMER survivor tokens that can ever exist\n    function unaboomerMaxSurvivorCount() public view returns (uint256) {\n        return unaboomer.MAX_SURVIVOR_COUNT();\n    }\n\n    /// Get BOOMER token max mint amount per wallet\n    /// @return mintAmount Maximum amount of BOOMER tokens that can be minted per wallet\n    function unaboomerMaxMintPerWallet() public view returns (uint256) {\n        return unaboomer.MAX_MINT_AMOUNT();\n    }\n\n    /// Get BOMB token balance of wallet\n    /// @param _address Wallet address to query balance of BOMB token\n    /// @return balance Amount of BOMB tokens owned by _address\n    function bombBalance(address _address) public view returns (uint256) {\n        return mailbomb.balanceOf(_address, 1);\n    }\n\n    /// Get BOMB token supply\n    /// @return supply Amount of BOMB tokens ever minted / \"assembled\"\n    function bombsAssembled() public view returns (uint256) {\n        return mailbomb.bombsAssembled();\n    }\n\n    /// Get BOMB exploded amount\n    /// @return exploded Amount of BOMB tokens that have burned / \"exploded\"\n    function bombsExploded() public view returns (uint256) {\n        return mailbomb.bombsExploded();\n    }\n\n    // =========================================================================\n    //                              Tokens\n    // =========================================================================\n\n    /// Radicalize a boomer to become a Unaboomer - start with 1 bomb\n    /// @param _amount Amount of Unaboomers to mint / \"radicalize\"\n    function radicalizeBoomers(uint256 _amount) external payable missionNotCompleted {\n        require(msg.value >= _amount * unaboomerPrice, \"not enough ether\");\n        unaboomer.radicalize(msg.sender, _amount);\n        mailbomb.create(msg.sender, _amount);\n    }\n\n    /// Assemble additional mailbombs to kill targets\n    /// @param _amount Amount of bombs mint / \"assemble\"\n    function assembleBombs(uint256 _amount) external payable missionNotCompleted {\n        require(msg.value >= _amount * bombPrice, \"not enough ether\");\n        mailbomb.create(msg.sender, _amount);\n    }\n\n    /// Send N bombs to pseudo-random Unaboomer tokenIds to kill them.\n    /// If the Unaboomer is already dead, the bomb is considered a dud.\n    /// Update a leaderboard with updated kill counts.\n    /// @dev Pick a pseudo-random tokenID from Unaboomer contract and toggle a mapping value  \n    /// @dev The likelihood of killing a boomer decreases as time goes on - i.e. more duds\n    /// @param _amount Amount of bombs to send to kill Unaboomers (dead pfps)\n    function sendBombs(uint256 _amount) external missionNotCompleted {\n        // Require mayhem is set (allow time to mint and trade)\n        require(mayhem, \"not ready for mayhem\");\n        // Ensure _amount will not exceed wallet balance of bombs, Unaboomer supply, and active Unaboomers\n        uint256 supply = unaboomersRadicalized();\n        uint256 bal = bombBalance(msg.sender);\n        require(_amount <= bal, \"not enough bombs\");\n        for (uint256 i; i < _amount; i++) {\n            // Pick a pseudo-random Unaboomer token - imperfectly derives token IDs so that repeats are probable\n            uint256 randomBoomer = (uint256(keccak256(abi.encodePacked(i, supply, bal, msg.sender))) % supply) + 1;\n            // Capture owner\n            address _owner = unaboomer.ownerOf(randomBoomer);\n            // Check if it was already killed\n            bool dud = _owner == address(0);\n            // Check if the sender owns it (misfired, killed own pfp)\n            bool senderOwned = msg.sender == _owner;\n            // Kill it (does nothing if already toggled as dead)\n            unaboomer.die(randomBoomer);\n            // Emit event for displaying in web app\n            emit SentBomb(msg.sender, randomBoomer, !dud, senderOwned);\n            // Increment kill count if successfully killed another player's Unaboomer\n            if(!dud && !senderOwned) {\n                killCount[msg.sender]++;\n            }\n        }\n        // Update the leaderboard and pointer for tracking the highest amount of kills for wallets\n        uint256 kills = killCount[msg.sender];\n        address leader = leaderboard[leaderboardPointer];\n        if (kills > killCount[leader]) {\n            if (leader != msg.sender) {\n                leaderboardPointer++;\n                leaderboard[leaderboardPointer] = msg.sender;\n            }\n        }\n        // Burn ERC-1155 BOMB tokens (bombs go away after sending / exploding)\n        mailbomb.explode(msg.sender, _amount);\n    }\n\n}"
21     },
22     "src/Unaboomer.sol": {
23       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Main} from \"./Main.sol\";\n\n/** \n@title Unaboomer\n@author lzamenace.eth\n@notice This contract contains ERC-721 Unaboomer tokens (BOOMER) which are the profile \npicture and membership tokens for the Unaboomer NFT project and chain based game.\nEach Unaboomer is a unique, dynamically generated pixel avatar in the likeness\nof the real-life Unabomber, Theodore Kaczynski. Unaboomers can be \"killed\" by\nother players by \"sending\" (burning) mailbombs. When Unaboomers are killed their\ncorresponding image is replaced with an explosion, rendering it worthless as any\nrarity associated with it ceases to exist. The game stops when MAX_SURVIVOR_COUNT\nthreshold is breached. The surviving players (any address which holds an \"alive\"\nUnaboomer) will advance to the next round of gameplay.\n@dev All contract functions regarding token burning and minting are limited to \nthe Main interface where the logic and validation resides.\n*/\ncontract Unaboomer is ERC721, Owned {\n    using LibString for uint256;\n\n    /// Track mints per wallet to enforce maximum\n    mapping(address => uint256) public tokensMintedByWallet;\n    /// Maximum supply of BOOMER tokens\n    uint256 public constant MAX_SUPPLY = 5000;\n    /// Maximum amount of survivors remaining to advance to the next round\n    uint256 public constant MAX_SURVIVOR_COUNT = 1000;\n    /// Maximum amount of mints per wallet - cut down on botters\n    uint256 public constant MAX_MINT_AMOUNT = 25;\n    /// Amount of Unaboomers killed (tokens burned)\n    uint256 public burned;\n    /// Amount of Unaboomers radicalized (tokens minted)\n    uint256 public minted;\n    /// Base URI for Unaboomers - original pixelated avatars and pixelated explosions\n    string public baseURI;\n    /// Contract address of the deployed Main contract interface to the game\n    Main public main;\n\n    constructor() ERC721(\"Unaboomer\", \"BOOMER\") Owned(msg.sender) {}\n\n    // =========================================================================\n    //                              Admin\n    // =========================================================================\n\n    /// Set metadata URI for Unaboomer PFPs and explosions\n    /// @param _baseURI IPFS hash or URL to retrieve JSON metadata for living Unaboomer tokens\n    function setBaseURI(string calldata _baseURI) external onlyOwner {\n        baseURI = _baseURI;\n    }\n\n    /// Set main contract address for executing functions\n    /// @param _address Contract address of the deployed Main contract\n    function setMainContract(address _address) external onlyOwner {\n        main = Main(_address);\n    }\n\n    // =========================================================================\n    //                              Modifiers\n    // =========================================================================\n    \n    /// Limit function execution to deployed Main contract\n    modifier onlyMain {\n        require(msg.sender == address(main), \"invalid msg sender\");\n        _;\n    }\n\n    // =========================================================================\n    //                              Tokens\n    // =========================================================================\n\n    /// Helper function to get supply minted\n    /// @return supply Number of Unaboomers radicalized in totality (minted)\n    function totalSupply() public view returns (uint256) {\n        return minted - burned;\n    }\n\n    /// Mint tokens from main contract\n    /// @param _to Address to mint BOOMER tokens to\n    /// @param _amount Amount of BOOMER tokens to mint\n    function radicalize(address _to, uint256 _amount) external onlyMain {\n        require(minted + _amount <= MAX_SUPPLY, \"supply reached\");\n        require(tokensMintedByWallet[_to] + _amount <= MAX_MINT_AMOUNT, \"cannot exceed maximum per wallet\");\n        for (uint256 i; i < _amount; i++) {\n            minted++;\n            _safeMint(_to, minted);\n        }\n        tokensMintedByWallet[_to] += _amount;\n    }\n\n    /// Toggle token state from living to dead\n    /// @param _tokenId Token ID of BOOMER to toggle living -> dead and increment kill count\n    function die(uint256 _tokenId) external onlyMain {\n        require(_tokenId <= minted, \"invalid token id\");\n        if (ownerOf(_tokenId) != address(0)) {\n            burned++;\n            _burn(_tokenId);\n        }\n    }\n\n    /// Retrieve owner of given token ID\n    /// @param _tokenId Token ID to check owner of\n    /// @return owner Address of owner\n    /// @dev Overridden from Solmate contract to allow zero address returns \n    function ownerOf(uint256 _tokenId) public view override returns (address owner) {\n        return _ownerOf[_tokenId];\n    }\n\n    // Return URI to retrieve JSON metadata from - points to images and descriptions\n    /// @param _tokenId Token ID of BOOMER to fetch URI for\n    /// @return string IPFS or HTTP URI to retrieve JSON metadata from\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        if (ownerOf(_tokenId) == address(0)) {\n            return string(abi.encodePacked(baseURI, \"dead.json\"));\n        } else {\n            return string(abi.encodePacked(baseURI, _tokenId.toString(), \".json\"));\n        }\n    }\n\n    /// Checks if contract supports a given interface\n    /// @param interfaceId The interface ID to check if contract supports\n    /// @return bool Boolean value if contract supports interface ID or not\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
24     }
25   },
26   "settings": {
27     "remappings": [
28       "ds-test/=lib/solmate/lib/ds-test/src/",
29       "erc721a/=lib/erc721a/contracts/",
30       "forge-std/=lib/forge-std/src/",
31       "solmate/=lib/solmate/src/"
32     ],
33     "optimizer": {
34       "enabled": true,
35       "runs": 200
36     },
37     "metadata": {
38       "bytecodeHash": "ipfs"
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "devdoc",
46           "userdoc",
47           "metadata",
48           "abi"
49         ]
50       }
51     },
52     "evmVersion": "london",
53     "libraries": {}
54   }
55 }}