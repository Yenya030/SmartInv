1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/KDOERewards.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./NFTWrapper.sol\";\nimport \"./TokenWrapper.sol\";\n\ncontract KDOERewards is TokenWrapper, NFTWrapper, Ownable {\n    IERC20 public rewardToken;\n    uint256 public rewardRate;\n    uint256 public periodFinish;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public rewardPerNFTStored;\n    bool public multiNftReward;\n    uint256 public maxNftRewardBalance;\n\t\n    struct UserRewards {\n        uint256 userRewardPerTokenPaid;\n        uint256 rewards;\n    }\n\t\n    mapping(address => UserRewards) public userRewards;\n\n    event RewardAdded(uint256 reward);\n    event RewardPaid(address indexed user, uint256 reward);\n\tevent UpdategKDOEAddress(IGKDOE indexed gKDOE);\n\tevent UpdategNFTRewardStatus(bool status);\n\tevent rewardWithdraw(address indexed user, uint256 reward);\n\n    constructor(IERC20 _rewardToken, IERC20 _stakedToken, IERC721 _stakedNFT) {\n        rewardToken = _rewardToken;\n        stakedToken = _stakedToken;\n        stakedNFT = _stakedNFT;\n    }\n\t\n    modifier updateReward(address account) {\n        uint256 _rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        rewardPerTokenStored = _rewardPerTokenStored;\n        userRewards[account].rewards = earned(account);\n        userRewards[account].userRewardPerTokenPaid = _rewardPerTokenStored;\n        _;\n    }\n\t\n    function setgKDOE(IGKDOE _gKDOE) external onlyOwner {\n        gKDOE = _gKDOE;\n\t\temit UpdategKDOEAddress(gKDOE);\n    }\n\t\n    function setMultiNftReward(bool _multiNftReward) external onlyOwner {\n        multiNftReward = _multiNftReward;\n\t\temit UpdategNFTRewardStatus(_multiNftReward);\n    }\n\t\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        uint256 blockTimestamp = uint256(block.timestamp);\n        return blockTimestamp < periodFinish ? blockTimestamp : periodFinish;\n    }\n\t\n    function rewardPerToken() public view returns (uint256) {\n        uint256 totalStakedSupply = totalSupply;\n        if (totalStakedSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        unchecked {\n            uint256 rewardDuration = lastTimeRewardApplicable() - lastUpdateTime;\n            return uint256(rewardPerTokenStored + (rewardDuration * rewardRate * 1e18) / totalStakedSupply);\n        }\n    }\n\t\n\t\n    function nftReward(uint256 nftBalance, uint256 newAmount) public view returns (uint256) {\n        if (multiNftReward) \n\t\t{\n            uint256 nftRewards = uint256(newAmount * (nftBalance * rewardPerNFTStored) / 100);\n            return nftRewards;\n        } \n\t\telse \n\t\t{\n            uint256 nftRewards = uint256(newAmount * rewardPerNFTStored / 100);\n            return nftRewards;\n        }\n    }\n\t\n    function earned(address account) public view returns (uint256) {\n        unchecked {\n            uint256 newAmount = uint256((balanceOf(account) * (rewardPerToken() - userRewards[account].userRewardPerTokenPaid)) / 1e18);\n            uint256 amount = uint256(newAmount + userRewards[account].rewards);\n\t\t\tuint256 nftBalance = uint256(balanceOfNFT(account));\n            if (nftBalance > 0) {\n                amount += nftReward(nftBalance, newAmount);\n            }\n            return amount;\n        }\n    }\n\t\n    function stake(uint256 amount) external payable updateReward(msg.sender){\n        super.stakeFor(msg.sender, amount);\n    }\n\t\n    function stakeNFT(uint256 tokenId) public payable updateReward(msg.sender) {\n\t    require(maxNftRewardBalance > balanceOfNFT(msg.sender), \"Max NFT already stake\");\n\t\tif(!multiNftReward)\n\t\t{\n\t\t    require(balanceOfNFT(msg.sender) == 0, \"Max NFT already stake\");\n\t\t}\n        super.stakeNFT(msg.sender, tokenId);\n    }\n\n    function withdraw(uint256 amount) public updateReward(msg.sender) {\n        super.withdraw(msg.sender, amount);\n    }\n\t\n    function withdrawForgKDOE(uint256 amount) public updateReward(msg.sender) {\n        super.withdrawForgKDOE(msg.sender, amount);\n    }\n\t\n\tfunction stakeForgKDOE(uint256 amount) public updateReward(msg.sender) {\n        super.stakeForgKDOE(msg.sender, amount);\n    }\n\n    function unstakeNFT(uint256 tokenId) public payable updateReward(msg.sender) {\n        super.unstakeNFT(msg.sender, tokenId);\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        require(reward > 0, \"No rewards to withdraw\");\n        userRewards[msg.sender].rewards = 0;\n        require(\n            rewardToken.transfer(msg.sender, reward),\n            \"reward transfer failed\"\n        );\n        emit RewardPaid(msg.sender, reward);\n    }\n\t\n    function setRewardParams( uint256 reward, uint256 duration, uint256 nftreward, uint256 maxNftBalance) external onlyOwner {\n        unchecked \n\t\t{\n            require(reward > 0, \"Reward can't be zero\");\n            rewardPerTokenStored = rewardPerToken();\n            uint256 blockTimestamp = uint256(block.timestamp);\n            uint256 maxRewardSupply = rewardToken.balanceOf(address(this));\n            if (rewardToken == stakedToken) maxRewardSupply -= totalSupply;\n            uint256 leftover = 0;\n            if (blockTimestamp >= periodFinish) \n\t\t\t{\n                rewardRate = reward / duration;\n            } \n\t\t\telse \n\t\t\t{\n                uint256 remaining = periodFinish - blockTimestamp;\n                leftover = remaining * rewardRate;\n                rewardRate = (reward + leftover) / duration;\n            }\n            rewardPerNFTStored = nftreward;\n            maxNftRewardBalance = maxNftBalance;\n            require(reward + leftover <= maxRewardSupply, \"not enough tokens\");\n            lastUpdateTime = blockTimestamp;\n            periodFinish = blockTimestamp + duration;\n            emit RewardAdded(reward);\n        }\n    }\n\t\n    function withdrawReward() external onlyOwner {\n        uint256 rewardSupply = rewardToken.balanceOf(address(this));\n        //ensure funds staked by users can't be transferred out\n        if (rewardToken == stakedToken) rewardSupply -= totalSupply;\n        require(rewardToken.transfer(msg.sender, rewardSupply), \"Error in transfer reward\");\n        rewardRate = 0;\n        periodFinish = uint256(block.timestamp);\n\t\t\n\t\temit rewardWithdraw(msg.sender, rewardSupply);\n    }\n}"
6     },
7     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
12     },
13     "@openzeppelin/contracts/access/Ownable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
15     },
16     "contracts/NFTWrapper.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract NFTWrapper is ERC721Holder {\n    IERC721 public stakedNFT;\n\n    mapping(address => uint256[]) private addressToTokenId;\n    mapping(uint256 => address) private tokenIdOwner;\n\n    function ownerOfNFT(uint256 tokenId) public view virtual returns (address) {\n        return tokenIdOwner[tokenId];\n    }\n\n    function balanceOfNFT(address account) public view returns (uint256) {\n        return addressToTokenId[account].length;\n    }\n\n    function addressToToken(address account)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return addressToTokenId[account];\n    }\n\n    function tokenToAddress(address account, uint256 tokenId) internal {\n        addressToTokenId[account].push(tokenId);\n    }\n\n    function removeTokenId(address account, uint256 tokenId) internal {\n        uint256 i = 0;\n        while (addressToTokenId[account][i] != tokenId) {\n            i++;\n        }\n        while (i < addressToTokenId[account].length - 1) {\n            addressToTokenId[account][i] = addressToTokenId[account][i + 1];\n            i++;\n        }\n        addressToTokenId[account].pop();\n    }\n\n    function stakeNFT(address account, uint256 tokenId) internal {\n        // transfer NFT to this contract\n        stakedNFT.safeTransferFrom(account, address(this), tokenId);\n\n        // add entry for tokenIdOwner\n        tokenIdOwner[tokenId] = account;\n        tokenToAddress(account, tokenId);\n    }\n\n    function unstakeNFT(address account, uint256 tokenId) internal{\n        require(tokenIdOwner[tokenId] == account, \"NOT OWNER OF NFT\");\n\n        delete tokenIdOwner[tokenId];\n        removeTokenId(account, tokenId);\n        stakedNFT.safeTransferFrom(address(this), account, tokenId);\n    }\n}"
18     },
19     "contracts/TokenWrapper.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IgKDOE.sol\";\n\ncontract TokenWrapper {\n    uint256 public totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => bool) private _gKDOEstakers;\n\n    IERC20 public stakedToken;\n    IGKDOE public gKDOE;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    string private constant _TransferErrorMessage = \"staked token transfer failed\";\n\n    function stakeFor(address account, uint256 amount) internal{\n        IERC20 st = stakedToken;\n        if (st == IERC20(address(0))) {\n            //eth\n            unchecked {\n                totalSupply += msg.value;\n                _balances[account] += msg.value;\n            }\n        } else {\n            require(msg.value == 0, \"non-zero eth\");\n            require(amount > 0, \"Cannot stake 0\");\n            require(\n                st.transferFrom(msg.sender, address(this), amount),\n                _TransferErrorMessage\n            );\n            unchecked {\n                totalSupply += amount;\n                _balances[account] += amount;\n            }\n        }\n        emit Staked(account, amount);\n    }\n\n    function stakeForgKDOE(address account, uint256 amount) internal {\n        require(amount > 0, \"Cannot stake 0\");\n\n        require(\n            gKDOE.depositForStaking(account, amount),\n            _TransferErrorMessage\n        );\n\t\t\n        unchecked {\n            totalSupply += amount;\n            _balances[account] += amount;\n            _gKDOEstakers[account] = true;\n        }\n\t\t\n        emit Staked(account, amount);\n    }\n\n    function withdrawForgKDOE(address account, uint256 amount) internal {\n        require(_gKDOEstakers[account] == true, \"Make have staked for gKDOE\");\n        require(amount <= _balances[account], \"withdraw: balance is lower\");\n\n        require(\n            gKDOE.withdrawFromStaking(account, uint256(amount)),\n            \"gKDOE not swapped back!\"\n        );\n\n        unchecked {\n            _balances[account] -= amount;\n            totalSupply = totalSupply - amount;\n        }\n\n        require(\n            stakedToken.transfer(account, amount),\n            _TransferErrorMessage\n        );\n\t\t\n\t\tif(_balances[account] == 0)\n\t\t{\n\t\t    _gKDOEstakers[account] == false;\n\t\t}\n\t\t\n        emit Withdrawn(account, amount);\n    }\n\n    function withdraw(address account, uint256 amount) internal virtual {\n        require(\n            _gKDOEstakers[account] == false,\n            \"Cannot unstake when staked for gKDOE\"\n        );\n\n        require(amount <= _balances[account], \"withdraw: balance is lower\");\n        unchecked {\n            _balances[account] -= amount;\n            totalSupply = totalSupply - amount;\n        }\n        IERC20 st = stakedToken;\n        if (st == IERC20(address(0))) {\n            //eth\n            (bool success, ) = msg.sender.call{value: amount}(\"\");\n            require(success, \"eth transfer failure\");\n        } else {\n            require(\n                stakedToken.transfer(msg.sender, amount),\n                _TransferErrorMessage\n            );\n        }\n        emit Withdrawn(msg.sender, amount);\n    }\n}"
21     },
22     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
24     },
25     "@openzeppelin/contracts/utils/Context.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
33     },
34     "contracts/IgKDOE.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IGKDOE {\n    function depositForStaking(address account, uint256 amount)\n        external\n        returns (bool);\n\n    function withdrawFromStaking(address account, uint256 amount)\n        external\n        returns (bool);\n}"
36     }
37   },
38   "settings": {
39     "optimizer": {
40       "enabled": false,
41       "runs": 200
42     },
43     "outputSelection": {
44       "*": {
45         "*": [
46           "evm.bytecode",
47           "evm.deployedBytecode",
48           "devdoc",
49           "userdoc",
50           "metadata",
51           "abi"
52         ]
53       }
54     },
55     "libraries": {}
56   }
57 }}