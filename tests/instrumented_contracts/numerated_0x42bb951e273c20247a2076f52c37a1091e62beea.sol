1 /*
2  Ever wanted to message to a fellow token holder? 
3  Or chat with yo anon fren from your favourite DAO? 
4 
5 Telegram: https://t.me/PepeChatApp
6 Twitter : https://twitter.com/PepeChatApp
7 Web     : https://PepeChat.app
8 
9 
10 ⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
11 ⠀⠀⠀⣠⡶⠛⠉⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⢦⡀⠀⢀⣴⠞⠋⠉⠉⠉⠉⠙⠛⠶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
12 ⠀⢀⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣶⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
13 ⢠⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠀⠸⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
14 ⠘⠀⠀⠀⠀⠀⠀⢀⣴⠖⠛⠋⠉⠉⠉⠉⠉⠉⠙⠛⠻⢦⣄⠀⠀⣀⣠⣤⣤⣤⣤⣤⣄⣀⠈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
15 ⠀⠀⠀⠀⠀⢠⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣏⠉⠀⠀⠀⠀⠀⠀⠈⠉⠙⠲⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
16 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
17 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣀⣀⣀⣀⣤⣄⣤⣤⣄⣀⣀⣤⣀⡈⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⡈⢻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
18 ⠀⠀⠀⠀⠀⠀⢀⡴⠟⠉⣉⣉⣩⣭⣽⠥⠦⣤⣌⣉⠛⠿⢦⣄⠈⠛⢶⣗⠀⠀⠀⠀⠀⢰⣞⣻⣽⣽⣭⣭⣭⣽⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀
19 ⠀⠀⠀⠀⢀⡴⢋⣠⠾⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⢦⣄⡙⢷⣄⠀⠹⣧⡀⠀⢀⡶⠟⣫⣭⢿⡿⠿⠿⠷⣦⡉⢻⣿⡄⠀⠀⠀⠀⠀⠀⠀
20 ⠀⠀⠀⠀⢻⣧⣾⣁⣤⡤⠴⠶⠖⣶⣶⣶⣶⣶⣶⣶⣶⠒⠛⠛⠳⣿⢷⣤⢺⣇⠀⠉⣢⣿⣿⣿⣾⣶⣶⣦⣄⡀⠹⣾⡏⠀⠀⠀⠀⠀⠀⠀⠀
21 ⠀⠀⠀⠀⠀⠀⠀⠉⠙⡳⠶⣄⣼⣿⣷⢾⣿⡟⠋⠛⣿⡇⠀⠀⠀⠈⣷⠘⢷⡟⢀⡾⣿⣿⣩⣿⣿⠿⢿⣧⠈⠙⠳⢾⣇⠀⠀⠀⠀⠀⠀⠀⠀
22 ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡈⠻⢿⣿⣼⣿⣷⣦⣾⣿⠇⠀⠀⠀⠀⠘⣧⢸⢣⡟⠀⣿⣿⣟⣿⣿⣤⣾⡿⠀⢀⣴⢿⡟⠀⠀⠀⠀⠀⠀⠀⠀
23 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⣀⠀⠉⠉⠛⠿⠿⠿⢤⣤⣤⡴⠖⠛⢉⣿⠈⢹⡓⢿⠿⠿⠿⠿⠿⠿⠷⠞⠋⣡⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀
24 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠛⠛⠛⠛⠳⠶⠤⠴⠶⢤⣴⠾⠋⠁⠀⠈⠛⠶⣤⡤⠤⠴⠆⢀⡾⢷⣾⢯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
25 ⠀⠀⠀⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠈⢳⣄⠀⠀⠛⠛⠛⠁⠀⢻⣆⠀⠀⠀⠀⠀⠀⠀⠀
26 ⠀⠀⣀⣠⣴⡶⠾⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⠶⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢧⠀⠀⠀⠀⠀⠀⠀⣿⣦⠀⠀⠀⠀⠀⠀⠀
27 ⠀⣼⢏⣿⠛⠿⠶⢤⣄⣀⡀⠀⠀⠀⠀⠐⠻⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠇⢸⡇⠀⠀⠀⠀⠀⠀
28 ⠀⠈⠘⣿⣄⠘⢷⣄⣀⠉⠙⠛⠒⠲⠶⣤⣤⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠃⣠⡟⠁⠀⠀⠀⠀⠀⠀
29 ⠀⠀⠀⠈⠙⠷⣄⣈⠉⠙⠳⠶⢤⣄⣀⡀⠀⠀⠉⠉⠉⠛⠛⠳⠶⠶⠶⠶⠶⠶⠤⢤⣤⣤⣤⣤⣤⣤⡤⠶⠾⠋⣠⣾⡋⠀⠀⠀⠀⠀⠀⠀⠀
30 ⠀⠀⠀⠀⠀⠀⠀⠙⠛⢦⣄⡀⠀⠈⠉⠙⠛⠛⠛⠛⠛⠛⠶⢦⣤⣤⣤⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣤⠾⠋⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀
31 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠳⢶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠀⠀⣰⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀
32 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠶⠦⠤⠤⢤⣄⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣠⣤⣄⣀⣀⣠⡤⠞⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
33 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⣉⣭⣉⠁⠀⣠⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
34 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡶⠛⠉⠉⠙⢷⣴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
35 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠛⠁⠀⠀⠀⠀⠀⠀⠹⠦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀
36 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡶⠒⠳⣦⠾⠛⢷⡄⠀⠀⣠⡴⢶⣤⣄⠀⣠⡌⠙⠷⣄⡀⠀⠀⠀⠀⠀⠀
37 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣄⠀⠀⠹⣦⣠⣾⣃⡴⠟⢁⡼⢋⣴⣯⠞⠋⠀⠀⠀⠈⠻⣆⠀⠀⠀⠀⠀
38 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠈⠉⢿⠁⢠⡼⣋⡴⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠙⢷⡄⠀⠀⠀
39 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⡄⠀⠀⢸⣶⢋⣼⠋⠀⠀⠀⠀⣀⡴⠟⠀⠀⠀⠀⠀⠀⢻⣄⠀⠀
40 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠙⠿⣧⡀⠀⠀⠀⣴⠏⠀⠀⠀⢀⣴⠆⠀⢀⠀⠻⣆⠀
41 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣇⠀⠀⠀⠀⠀⠈⠻⣦⣤⣼⠃⠀⠀⢀⣠⠞⠁⠀⣠⡾⠀⠀⠻⡆
42 ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠃⠹⠗⠀⠀⠀⠀⠀⠀⠀⠀⠙⠓⠀⠀⠾⠃⠀⠀⠸⠋⠀⠀⠀⠀⠿                                                                                          
43                                                                                                                                                             
44 */
45 
46 
47 // SPDX-License-Identifier: MIT
48 pragma solidity ^0.8.5;
49 library SafeMath {
50     function add(uint256 a, uint256 b) internal pure returns (uint256) {
51         uint256 c = a + b;
52         require(c >= a, "SafeMath: addition overflow");
53         return c;
54     }
55     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
56         return sub(a, b, "SafeMath: subtraction overflow");
57     }
58     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
59         require(b <= a, errorMessage);
60         uint256 c = a - b;
61         return c;
62     }
63     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
64         if (a == 0) {
65             return 0;
66         }
67         uint256 c = a * b;
68         require(c / a == b, "SafeMath: multiplication overflow");
69         return c;
70     }
71     function div(uint256 a, uint256 b) internal pure returns (uint256) {
72         return div(a, b, "SafeMath: division by zero");
73     }
74     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
75         require(b > 0, errorMessage);
76         uint256 c = a / b;
77         return c;
78     }
79 }
80 
81 interface ERC20 {
82     function totalSupply() external view returns (uint256);
83     function decimals() external view returns (uint8);
84     function symbol() external view returns (string memory);
85     function name() external view returns (string memory);
86     function getOwner() external view returns (address);
87     function balanceOf(address account) external view returns (uint256);
88     function transfer(address recipient, uint256 amount) external returns (bool);
89     function allowance(address _owner, address spender) external view returns (uint256);
90     function approve(address spender, uint256 amount) external returns (bool);
91     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
92     event Transfer(address indexed from, address indexed to, uint256 value);
93     event Approval(address indexed owner, address indexed spender, uint256 value);
94 }
95 
96 abstract contract Ownable {
97     address internal owner;
98     constructor(address _owner) {
99         owner = _owner;
100     }
101     modifier onlyOwner() {
102         require(isOwner(msg.sender), "!OWNER"); _;
103     }
104     function isOwner(address account) public view returns (bool) {
105         return account == owner;
106     }
107     function renounceOwnership() public onlyOwner {
108         owner = address(0);
109         emit OwnershipTransferred(address(0));
110     }  
111     event OwnershipTransferred(address owner);
112 }
113 
114 interface IDEXFactory {
115     function createPair(address tokenA, address tokenB) external returns (address pair);
116 }
117 
118 interface IDEXRouter {
119     function factory() external pure returns (address);
120     function WETH() external pure returns (address);
121     function addLiquidity(
122         address tokenA,
123         address tokenB,
124         uint amountADesired,
125         uint amountBDesired,
126         uint amountAMin,
127         uint amountBMin,
128         address to,
129         uint deadline
130     ) external returns (uint amountA, uint amountB, uint liquidity);
131     function addLiquidityETH(
132         address token,
133         uint amountTokenDesired,
134         uint amountTokenMin,
135         uint amountETHMin,
136         address to,
137         uint deadline
138     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
139     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
140         uint amountIn,
141         uint amountOutMin,
142         address[] calldata path,
143         address to,
144         uint deadline
145     ) external;
146     function swapExactETHForTokensSupportingFeeOnTransferTokens(
147         uint amountOutMin,
148         address[] calldata path,
149         address to,
150         uint deadline
151     ) external payable;
152     function swapExactTokensForETHSupportingFeeOnTransferTokens(
153         uint amountIn,
154         uint amountOutMin,
155         address[] calldata path,
156         address to,
157         uint deadline
158     ) external;
159 }
160 
161 contract PepeChat is ERC20, Ownable {
162     using SafeMath for uint256;
163     address routerAdress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
164     address DEAD = 0x000000000000000000000000000000000000dEaD;
165 
166     string constant _name = "PepeChat";
167     string constant _symbol = "PPC";
168     uint8 constant _decimals = 9;
169 
170     uint256 _totalSupply = 420000000 * (10 ** _decimals);
171     uint256 public _maxWalletAmount = (_totalSupply * 2) / 100;
172 
173     mapping (address => uint256) _balances;
174     mapping (address => mapping (address => uint256)) _allowances;
175 
176     mapping (address => bool) isFeeExempt;
177     mapping (address => bool) isTxLimitExempt;
178 
179     uint256 liquidityFee = 0; 
180     uint256 marketingFee = 5;
181     uint256 totalFee = liquidityFee + marketingFee;
182     uint256 feeDenominator = 100;
183 
184     address internal marketingFeeReceiver = 0x9BEA135E1c7C6732FEF10A2eD6D5cc013402e6E7;
185 
186     IDEXRouter public router;
187     address public pair;
188 
189     bool public swapEnabled = true;
190     uint256 public swapThreshold = _totalSupply / 1000 * 2; // 0.5%
191     bool inSwap;
192     modifier swapping() { inSwap = true; _; inSwap = false; }
193 
194     constructor () Ownable(msg.sender) {
195         router = IDEXRouter(routerAdress);
196         pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));
197         _allowances[address(this)][address(router)] = type(uint256).max;
198 
199         address _owner = owner;
200         isFeeExempt[0x9BEA135E1c7C6732FEF10A2eD6D5cc013402e6E7] = true;
201         isTxLimitExempt[_owner] = true;
202         isTxLimitExempt[0x9BEA135E1c7C6732FEF10A2eD6D5cc013402e6E7] = true;
203         isTxLimitExempt[DEAD] = true;
204 
205         _balances[_owner] = _totalSupply;
206         emit Transfer(address(0), _owner, _totalSupply);
207     }
208 
209     receive() external payable { }
210 
211     function totalSupply() external view override returns (uint256) { return _totalSupply; }
212     function decimals() external pure override returns (uint8) { return _decimals; }
213     function symbol() external pure override returns (string memory) { return _symbol; }
214     function name() external pure override returns (string memory) { return _name; }
215     function getOwner() external view override returns (address) { return owner; }
216     function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }
217     function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }
218 
219     function approve(address spender, uint256 amount) public override returns (bool) {
220         _allowances[msg.sender][spender] = amount;
221         emit Approval(msg.sender, spender, amount);
222         return true;
223     }
224 
225     function approveMax(address spender) external returns (bool) {
226         return approve(spender, type(uint256).max);
227     }
228 
229     function transfer(address recipient, uint256 amount) external override returns (bool) {
230         return _transferFrom(msg.sender, recipient, amount);
231     }
232 
233     function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
234         if(_allowances[sender][msg.sender] != type(uint256).max){
235             _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, "Insufficient Allowance");
236         }
237 
238         return _transferFrom(sender, recipient, amount);
239     }
240 
241     function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
242         if(inSwap){ return _basicTransfer(sender, recipient, amount); }
243         
244         if (recipient != pair && recipient != DEAD) {
245             require(isTxLimitExempt[recipient] || _balances[recipient] + amount <= _maxWalletAmount, "Transfer amount exceeds the bag size.");
246         }
247         
248         if(shouldSwapBack()){ swapBack(); } 
249 
250         _balances[sender] = _balances[sender].sub(amount, "Insufficient Balance");
251 
252         uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, amount) : amount;
253         _balances[recipient] = _balances[recipient].add(amountReceived);
254 
255         emit Transfer(sender, recipient, amountReceived);
256         return true;
257     }
258     
259     function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
260         _balances[sender] = _balances[sender].sub(amount, "Insufficient Balance");
261         _balances[recipient] = _balances[recipient].add(amount);
262         emit Transfer(sender, recipient, amount);
263         return true;
264     }
265 
266     function shouldTakeFee(address sender) internal view returns (bool) {
267         return !isFeeExempt[sender];
268     }
269 
270     function takeFee(address sender, uint256 amount) internal returns (uint256) {
271         uint256 feeAmount = amount.mul(totalFee).div(feeDenominator);
272         _balances[address(this)] = _balances[address(this)].add(feeAmount);
273         emit Transfer(sender, address(this), feeAmount);
274         return amount.sub(feeAmount);
275     }
276 
277     function shouldSwapBack() internal view returns (bool) {
278         return msg.sender != pair
279         && !inSwap
280         && swapEnabled
281         && _balances[address(this)] >= swapThreshold;
282     }
283 
284     function swapBack() internal swapping {
285         uint256 contractTokenBalance = swapThreshold;
286         uint256 amountToLiquify = contractTokenBalance.mul(liquidityFee).div(totalFee).div(2);
287         uint256 amountToSwap = contractTokenBalance.sub(amountToLiquify);
288 
289         address[] memory path = new address[](2);
290         path[0] = address(this);
291         path[1] = router.WETH();
292 
293         uint256 balanceBefore = address(this).balance;
294 
295         router.swapExactTokensForETHSupportingFeeOnTransferTokens(
296             amountToSwap,
297             0,
298             path,
299             address(this),
300             block.timestamp
301         );
302         uint256 amountETH = address(this).balance.sub(balanceBefore);
303         uint256 totalETHFee = totalFee.sub(liquidityFee.div(2));
304         uint256 amountETHLiquidity = amountETH.mul(liquidityFee).div(totalETHFee).div(2);
305         uint256 amountETHMarketing = amountETH.mul(marketingFee).div(totalETHFee);
306 
307 
308         (bool MarketingSuccess, /* bytes memory data */) = payable(marketingFeeReceiver).call{value: amountETHMarketing, gas: 30000}("");
309         require(MarketingSuccess, "receiver rejected ETH transfer");
310 
311         if(amountToLiquify > 0){
312             router.addLiquidityETH{value: amountETHLiquidity}(
313                 address(this),
314                 amountToLiquify,
315                 0,
316                 0,
317                0x9BEA135E1c7C6732FEF10A2eD6D5cc013402e6E7,
318                 block.timestamp
319             );
320             emit AutoLiquify(amountETHLiquidity, amountToLiquify);
321         }
322     }
323 
324     function buyTokens(uint256 amount, address to) internal swapping {
325         address[] memory path = new address[](2);
326         path[0] = router.WETH();
327         path[1] = address(this);
328 
329         router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(
330             0,
331             path,
332             to,
333             block.timestamp
334         );
335     }
336 
337     function clearStuckBalance() external {
338         payable(marketingFeeReceiver).transfer(address(this).balance);
339     }
340 
341     function setWalletLimit(uint256 amountPercent) external onlyOwner {
342         _maxWalletAmount = (_totalSupply * amountPercent ) / 1000;
343     }
344 
345     function setFee(uint256 _liquidityFee, uint256 _marketingFee) external onlyOwner {
346          liquidityFee = _liquidityFee; 
347          marketingFee = _marketingFee;
348          totalFee = liquidityFee + marketingFee;
349     }    
350     
351     event AutoLiquify(uint256 amountETH, uint256 amountBOG);
352 }