1 /*
2 * Generated by @Thrasher66099
3 * Email thrasher66099@gmail.com for your NFT launch needs
4 */
5 
6 pragma solidity ^0.8.0;
7 
8 /**
9  * @dev Interface of the ERC165 standard, as defined in the
10  * https://eips.ethereum.org/EIPS/eip-165[EIP].
11  *
12  * Implementers can declare support of contract interfaces, which can then be
13  * queried by others ({ERC165Checker}).
14  *
15  * For an implementation, see {ERC165}.
16  */
17 interface IERC165 {
18     /**
19      * @dev Returns true if this contract implements the interface defined by
20      * `interfaceId`. See the corresponding
21      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
22      * to learn more about how these ids are created.
23      *
24      * This function call must use less than 30 000 gas.
25      */
26     function supportsInterface(bytes4 interfaceId) external view returns (bool);
27 }
28 
29 
30 /**
31  * @dev Required interface of an ERC721 compliant contract.
32  */
33 interface IERC721 is IERC165 {
34     /**
35      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
36      */
37     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
38 
39     /**
40      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
41      */
42     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
43 
44     /**
45      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
46      */
47     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
48 
49     /**
50      * @dev Returns the number of tokens in ``owner``'s account.
51      */
52     function balanceOf(address owner) external view returns (uint256 balance);
53 
54     /**
55      * @dev Returns the owner of the `tokenId` token.
56      *
57      * Requirements:
58      *
59      * - `tokenId` must exist.
60      */
61     function ownerOf(uint256 tokenId) external view returns (address owner);
62 
63     /**
64      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
65      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
66      *
67      * Requirements:
68      *
69      * - `from` cannot be the zero address.
70      * - `to` cannot be the zero address.
71      * - `tokenId` token must exist and be owned by `from`.
72      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
73      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
74      *
75      * Emits a {Transfer} event.
76      */
77     function safeTransferFrom(
78         address from,
79         address to,
80         uint256 tokenId
81     ) external;
82 
83     /**
84      * @dev Transfers `tokenId` token from `from` to `to`.
85      *
86      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
87      *
88      * Requirements:
89      *
90      * - `from` cannot be the zero address.
91      * - `to` cannot be the zero address.
92      * - `tokenId` token must be owned by `from`.
93      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
94      *
95      * Emits a {Transfer} event.
96      */
97     function transferFrom(
98         address from,
99         address to,
100         uint256 tokenId
101     ) external;
102 
103     /**
104      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
105      * The approval is cleared when the token is transferred.
106      *
107      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
108      *
109      * Requirements:
110      *
111      * - The caller must own the token or be an approved operator.
112      * - `tokenId` must exist.
113      *
114      * Emits an {Approval} event.
115      */
116     function approve(address to, uint256 tokenId) external;
117 
118     /**
119      * @dev Returns the account approved for `tokenId` token.
120      *
121      * Requirements:
122      *
123      * - `tokenId` must exist.
124      */
125     function getApproved(uint256 tokenId) external view returns (address operator);
126 
127     /**
128      * @dev Approve or remove `operator` as an operator for the caller.
129      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
130      *
131      * Requirements:
132      *
133      * - The `operator` cannot be the caller.
134      *
135      * Emits an {ApprovalForAll} event.
136      */
137     function setApprovalForAll(address operator, bool _approved) external;
138 
139     /**
140      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
141      *
142      * See {setApprovalForAll}
143      */
144     function isApprovedForAll(address owner, address operator) external view returns (bool);
145 
146     /**
147      * @dev Safely transfers `tokenId` token from `from` to `to`.
148      *
149      * Requirements:
150      *
151      * - `from` cannot be the zero address.
152      * - `to` cannot be the zero address.
153      * - `tokenId` token must exist and be owned by `from`.
154      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
155      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
156      *
157      * Emits a {Transfer} event.
158      */
159     function safeTransferFrom(
160         address from,
161         address to,
162         uint256 tokenId,
163         bytes calldata data
164     ) external;
165 }
166 
167 
168 
169 /**
170  * @dev String operations.
171  */
172 library Strings {
173     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
174 
175     /**
176      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
177      */
178     function toString(uint256 value) internal pure returns (string memory) {
179         // Inspired by OraclizeAPI's implementation - MIT licence
180         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
181 
182         if (value == 0) {
183             return "0";
184         }
185         uint256 temp = value;
186         uint256 digits;
187         while (temp != 0) {
188             digits++;
189             temp /= 10;
190         }
191         bytes memory buffer = new bytes(digits);
192         while (value != 0) {
193             digits -= 1;
194             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
195             value /= 10;
196         }
197         return string(buffer);
198     }
199 
200 
201     /**
202      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation. 
203      */
204     function toHexString(uint256 value) internal pure returns (string memory) {
205         if (value == 0) {
206             return "0x00";
207         }
208         uint256 temp = value;
209         uint256 length = 0;
210         while (temp != 0) {
211             length++;
212             temp >>= 8;
213         }
214         return toHexString(value, length);
215     }
216 
217     /**
218      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
219      */
220     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
221         bytes memory buffer = new bytes(2 * length + 2);
222         buffer[0] = "0";
223         buffer[1] = "x";
224         for (uint256 i = 2 * length + 1; i > 1; --i) {
225             buffer[i] = _HEX_SYMBOLS[value & 0xf];
226             value >>= 4;
227         }
228         require(value == 0, "Strings: hex length insufficient");
229         return string(buffer);
230     }
231 }
232 
233 
234 /*
235  * @dev Provides information about the current execution context, including the
236  * sender of the transaction and its data. While these are generally available
237  * via msg.sender and msg.data, they should not be accessed in such a direct
238  * manner, since when dealing with meta-transactions the account sending and
239  * paying for execution may not be the actual sender (as far as an application
240  * is concerned).
241  *
242  * This contract is only required for intermediate, library-like contracts.
243  */
244 abstract contract Context {
245     function _msgSender() internal view virtual returns (address) {
246         return msg.sender;
247     }
248 
249     function _msgData() internal view virtual returns (bytes calldata) {
250         return msg.data;
251     }
252 }
253 
254 
255 /**
256  * @dev Contract module which provides a basic access control mechanism, where
257  * there is an account (an owner) that can be granted exclusive access to
258  * specific functions.
259  *
260  * By default, the owner account will be the one that deploys the contract. This
261  * can later be changed with {transferOwnership}.
262  *
263  * This module is used through inheritance. It will make available the modifier
264  * `onlyOwner`, which can be applied to your functions to restrict their use to
265  * the owner.
266  */
267 abstract contract Ownable is Context {
268     address private _owner;
269 
270     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
271 
272     /**
273      * @dev Initializes the contract setting the deployer as the initial owner.
274      */
275     constructor() {
276         _setOwner(_msgSender());
277     }
278 
279     /**
280      * @dev Returns the address of the current owner.
281      */
282     function owner() public view virtual returns (address) {
283         return _owner;
284     }
285 
286     /**
287      * @dev Throws if called by any account other than the owner.
288      */
289     modifier onlyOwner() {
290         require(owner() == _msgSender(), "Ownable: caller is not the owner");
291         _;
292     }
293 
294     /**
295      * @dev Leaves the contract without owner. It will not be possible to call
296      * `onlyOwner` functions anymore. Can only be called by the current owner.
297      *
298      * NOTE: Renouncing ownership will leave the contract without an owner,
299      * thereby removing any functionality that is only available to the owner.
300      */
301     function renounceOwnership() public virtual onlyOwner {
302         _setOwner(address(0));
303     }
304 
305     /**
306      * @dev Transfers ownership of the contract to a new account (`newOwner`).
307      * Can only be called by the current owner.
308      */
309     function transferOwnership(address newOwner) public virtual onlyOwner {
310         require(newOwner != address(0), "Ownable: new owner is the zero address");
311         _setOwner(newOwner);
312     }
313 
314     function _setOwner(address newOwner) private {
315         address oldOwner = _owner;
316         _owner = newOwner;
317         emit OwnershipTransferred(oldOwner, newOwner);
318     }
319 }
320 
321 
322 /**
323  * @dev Contract module that helps prevent reentrant calls to a function.
324  *
325  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
326  * available, which can be applied to functions to make sure there are no nested
327  * (reentrant) calls to them.
328  *
329  * Note that because there is a single `nonReentrant` guard, functions marked as
330  * `nonReentrant` may not call one another. This can be worked around by making
331  * those functions `private`, and then adding `external` `nonReentrant` entry
332  * points to them.
333  *
334  * TIP: If you would like to learn more about reentrancy and alternative ways
335  * to protect against it, check out our blog post
336  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
337  */
338 abstract contract ReentrancyGuard {
339     // Booleans are more expensive than uint256 or any type that takes up a full
340     // word because each write operation emits an extra SLOAD to first read the
341     // slot's contents, replace the bits taken up by the boolean, and then write
342     // back. This is the compiler's defense against contract upgrades and
343     // pointer aliasing, and it cannot be disabled.
344 
345     // The values being non-zero value makes deployment a bit more expensive,
346     // but in exchange the refund on every call to nonReentrant will be lower in
347     // amount. Since refunds are capped to a percentage of the total
348     // transaction's gas, it is best to keep them low in cases like this one, to
349     // increase the likelihood of the full refund coming into effect.
350     uint256 private constant _NOT_ENTERED = 1;
351     uint256 private constant _ENTERED = 2;
352 
353     uint256 private _status;
354 
355     constructor() {
356         _status = _NOT_ENTERED;
357     }
358 
359     /**
360      * @dev Prevents a contract from calling itself, directly or indirectly.
361      * Calling a `nonReentrant` function from another `nonReentrant`
362      * function is not supported. It is possible to prevent this from happening
363      * by making the `nonReentrant` function external, and make it call a
364      * `private` function that does the actual work.
365      */
366     modifier nonReentrant() {
367         // On the first call to nonReentrant, _notEntered will be true
368         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
369 
370         // Any calls to nonReentrant after this point will fail
371         _status = _ENTERED;
372 
373         _;
374 
375         // By storing the original value once again, a refund is triggered (see
376         // https://eips.ethereum.org/EIPS/eip-2200)
377         _status = _NOT_ENTERED;
378     }
379 }
380 
381 
382 
383 /**
384  * @title ERC721 token receiver interface
385  * @dev Interface for any contract that wants to support safeTransfers
386  * from ERC721 asset contracts.
387  */
388 interface IERC721Receiver {
389     /**
390      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
391      * by `operator` from `from`, this function is called.
392      *
393      * It must return its Solidity selector to confirm the token transfer.
394      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
395      *
396      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
397      */
398     function onERC721Received(
399         address operator,
400         address from,
401         uint256 tokenId,
402         bytes calldata data
403     ) external returns (bytes4);
404 }
405 
406 
407 /**
408  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
409  * @dev See https://eips.ethereum.org/EIPS/eip-721
410  */
411 interface IERC721Metadata is IERC721 {
412     /**
413      * @dev Returns the token collection name.
414      */
415     function name() external view returns (string memory);
416 
417     /**
418      * @dev Returns the token collection symbol.
419      */
420     function symbol() external view returns (string memory);
421 
422     /**
423      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
424      */
425     function tokenURI(uint256 tokenId) external view returns (string memory);
426 }
427 
428 
429 /**
430  * @dev Collection of functions related to the address type
431  */
432 library Address {
433     /**
434      * @dev Returns true if `account` is a contract.
435      *
436      * [IMPORTANT]
437      * ====
438      * It is unsafe to assume that an address for which this function returns
439      * false is an externally-owned account (EOA) and not a contract.
440      *
441      * Among others, `isContract` will return false for the following
442      * types of addresses:
443      *
444      *  - an externally-owned account
445      *  - a contract in construction
446      *  - an address where a contract will be created
447      *  - an address where a contract lived, but was destroyed
448      * ====
449      */
450     function isContract(address account) internal view returns (bool) {
451         // This method relies on extcodesize, which returns 0 for contracts in
452         // construction, since the code is only stored at the end of the
453         // constructor execution.
454 
455         uint256 size;
456         assembly {
457             size := extcodesize(account)
458         }
459         return size > 0;
460     }
461 
462     /**
463      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
464      * `recipient`, forwarding all available gas and reverting on errors.
465      *
466      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
467      * of certain opcodes, possibly making contracts go over the 2300 gas limit
468      * imposed by `transfer`, making them unable to receive funds via
469      * `transfer`. {sendValue} removes this limitation.
470      *
471      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
472      *
473      * IMPORTANT: because control is transferred to `recipient`, care must be
474      * taken to not create reentrancy vulnerabilities. Consider using
475      * {ReentrancyGuard} or the
476      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
477      */
478     function sendValue(address payable recipient, uint256 amount) internal {
479         require(address(this).balance >= amount, "Address: insufficient balance");
480 
481         (bool success, ) = recipient.call{value: amount}("");
482         require(success, "Address: unable to send value, recipient may have reverted");
483     }
484 
485     /**
486      * @dev Performs a Solidity function call using a low level `call`. A
487      * plain `call` is an unsafe replacement for a function call: use this
488      * function instead.
489      *
490      * If `target` reverts with a revert reason, it is bubbled up by this
491      * function (like regular Solidity function calls).
492      *
493      * Returns the raw returned data. To convert to the expected return value,
494      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
495      *
496      * Requirements:
497      *
498      * - `target` must be a contract.
499      * - calling `target` with `data` must not revert.
500      *
501      * _Available since v3.1._
502      */
503     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
504         return functionCall(target, data, "Address: low-level call failed");
505     }
506 
507     /**
508      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
509      * `errorMessage` as a fallback revert reason when `target` reverts.
510      *
511      * _Available since v3.1._
512      */
513     function functionCall(
514         address target,
515         bytes memory data,
516         string memory errorMessage
517     ) internal returns (bytes memory) {
518         return functionCallWithValue(target, data, 0, errorMessage);
519     }
520 
521     /**
522      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
523      * but also transferring `value` wei to `target`.
524      *
525      * Requirements:
526      *
527      * - the calling contract must have an ETH balance of at least `value`.
528      * - the called Solidity function must be `payable`.
529      *
530      * _Available since v3.1._
531      */
532     function functionCallWithValue(
533         address target,
534         bytes memory data,
535         uint256 value
536     ) internal returns (bytes memory) {
537         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
538     }
539 
540     /**
541      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
542      * with `errorMessage` as a fallback revert reason when `target` reverts.
543      *
544      * _Available since v3.1._
545      */
546     function functionCallWithValue(
547         address target,
548         bytes memory data,
549         uint256 value,
550         string memory errorMessage
551     ) internal returns (bytes memory) {
552         require(address(this).balance >= value, "Address: insufficient balance for call");
553         require(isContract(target), "Address: call to non-contract");
554 
555         (bool success, bytes memory returndata) = target.call{value: value}(data);
556         return _verifyCallResult(success, returndata, errorMessage);
557     }
558 
559     /**
560      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
561      * but performing a static call.
562      *
563      * _Available since v3.3._
564      */
565     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
566         return functionStaticCall(target, data, "Address: low-level static call failed");
567     }
568 
569     /**
570      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
571      * but performing a static call.
572      *
573      * _Available since v3.3._
574      */
575     function functionStaticCall(
576         address target,
577         bytes memory data,
578         string memory errorMessage
579     ) internal view returns (bytes memory) {
580         require(isContract(target), "Address: static call to non-contract");
581 
582         (bool success, bytes memory returndata) = target.staticcall(data);
583         return _verifyCallResult(success, returndata, errorMessage);
584     }
585 
586     /**
587      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
588      * but performing a delegate call.
589      *
590      * _Available since v3.4._
591      */
592     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
593         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
594     }
595 
596     /**
597      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
598      * but performing a delegate call.
599      *
600      * _Available since v3.4._
601      */
602     function functionDelegateCall(
603         address target,
604         bytes memory data,
605         string memory errorMessage
606     ) internal returns (bytes memory) {
607         require(isContract(target), "Address: delegate call to non-contract");
608 
609         (bool success, bytes memory returndata) = target.delegatecall(data);
610         return _verifyCallResult(success, returndata, errorMessage);
611     }
612 
613     function _verifyCallResult(
614         bool success,
615         bytes memory returndata,
616         string memory errorMessage
617     ) private pure returns (bytes memory) {
618         if (success) {
619             return returndata;
620         } else {
621             // Look for revert reason and bubble it up if present
622             if (returndata.length > 0) {
623                 // The easiest way to bubble the revert reason is using memory via assembly
624 
625                 assembly {
626                     let returndata_size := mload(returndata)
627                     revert(add(32, returndata), returndata_size)
628                 }
629             } else {
630                 revert(errorMessage);
631             }
632         }
633     }
634 }
635 
636 
637 
638 
639 /**
640  * @dev Implementation of the {IERC165} interface.
641  *
642  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
643  * for the additional interface id that will be supported. For example:
644  *
645  * ```solidity
646  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
647  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
648  * }
649  * ```
650  *
651  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
652  */
653 abstract contract ERC165 is IERC165 {
654     /**
655      * @dev See {IERC165-supportsInterface}.
656      */
657     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
658         return interfaceId == type(IERC165).interfaceId;
659     }
660 }
661 
662 
663 /**
664  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
665  * the Metadata extension, but not including the Enumerable extension, which is available separately as
666  * {ERC721Enumerable}.
667  */
668 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
669     using Address for address;
670     using Strings for uint256;
671 
672     // Token name
673     string private _name;
674 
675     // Token symbol
676     string private _symbol;
677 
678     // Mapping from token ID to owner address
679     mapping(uint256 => address) private _owners;
680 
681     // Mapping owner address to token count
682     mapping(address => uint256) private _balances;
683 
684     // Mapping from token ID to approved address
685     mapping(uint256 => address) private _tokenApprovals;
686 
687     // Mapping from owner to operator approvals
688     mapping(address => mapping(address => bool)) private _operatorApprovals;
689 
690     /**
691      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
692      */
693     constructor(string memory name_, string memory symbol_) {
694         _name = name_;
695         _symbol = symbol_;
696     }
697 
698     /**
699      * @dev See {IERC165-supportsInterface}.
700      */
701     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
702         return
703             interfaceId == type(IERC721).interfaceId ||
704             interfaceId == type(IERC721Metadata).interfaceId ||
705             super.supportsInterface(interfaceId);
706     }
707 
708     /**
709      * @dev See {IERC721-balanceOf}.
710      */
711     function balanceOf(address owner) public view virtual override returns (uint256) {
712         require(owner != address(0), "ERC721: balance query for the zero address");
713         return _balances[owner];
714     }
715 
716     /**
717      * @dev See {IERC721-ownerOf}.
718      */
719     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
720         address owner = _owners[tokenId];
721         require(owner != address(0), "ERC721: owner query for nonexistent token");
722         return owner;
723     }
724 
725     /**
726      * @dev See {IERC721Metadata-name}.
727      */
728     function name() public view virtual override returns (string memory) {
729         return _name;
730     }
731 
732     /**
733      * @dev See {IERC721Metadata-symbol}.
734      */
735     function symbol() public view virtual override returns (string memory) {
736         return _symbol;
737     }
738 
739     /**
740      * @dev See {IERC721Metadata-tokenURI}.
741      */
742     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
743         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
744 
745         string memory baseURI = _baseURI();
746         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
747     }
748 
749     /**
750      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
751      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
752      * by default, can be overriden in child contracts.
753      */
754     function _baseURI() internal view virtual returns (string memory) {
755         return "";
756     }
757 
758     /**
759      * @dev See {IERC721-approve}.
760      */
761     function approve(address to, uint256 tokenId) public virtual override {
762         address owner = ERC721.ownerOf(tokenId);
763         require(to != owner, "ERC721: approval to current owner");
764 
765         require(
766             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
767             "ERC721: approve caller is not owner nor approved for all"
768         );
769 
770         _approve(to, tokenId);
771     }
772 
773     /**
774      * @dev See {IERC721-getApproved}.
775      */
776     function getApproved(uint256 tokenId) public view virtual override returns (address) {
777         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
778 
779         return _tokenApprovals[tokenId];
780     }
781 
782     /**
783      * @dev See {IERC721-setApprovalForAll}.
784      */
785     function setApprovalForAll(address operator, bool approved) public virtual override {
786         require(operator != _msgSender(), "ERC721: approve to caller");
787 
788         _operatorApprovals[_msgSender()][operator] = approved;
789         emit ApprovalForAll(_msgSender(), operator, approved);
790     }
791 
792     /**
793      * @dev See {IERC721-isApprovedForAll}.
794      */
795     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
796         return _operatorApprovals[owner][operator];
797     }
798 
799     /**
800      * @dev See {IERC721-transferFrom}.
801      */
802     function transferFrom(
803         address from,
804         address to,
805         uint256 tokenId
806     ) public virtual override {
807         //solhint-disable-next-line max-line-length
808         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
809 
810         _transfer(from, to, tokenId);
811     }
812 
813     /**
814      * @dev See {IERC721-safeTransferFrom}.
815      */
816     function safeTransferFrom(
817         address from,
818         address to,
819         uint256 tokenId
820     ) public virtual override {
821         safeTransferFrom(from, to, tokenId, "");
822     }
823 
824     /**
825      * @dev See {IERC721-safeTransferFrom}.
826      */
827     function safeTransferFrom(
828         address from,
829         address to,
830         uint256 tokenId,
831         bytes memory _data
832     ) public virtual override {
833         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
834         _safeTransfer(from, to, tokenId, _data);
835     }
836 
837     /**
838      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
839      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
840      *
841      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
842      *
843      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
844      * implement alternative mechanisms to perform token transfer, such as signature-based.
845      *
846      * Requirements:
847      *
848      * - `from` cannot be the zero address.
849      * - `to` cannot be the zero address.
850      * - `tokenId` token must exist and be owned by `from`.
851      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
852      *
853      * Emits a {Transfer} event.
854      */
855     function _safeTransfer(
856         address from,
857         address to,
858         uint256 tokenId,
859         bytes memory _data
860     ) internal virtual {
861         _transfer(from, to, tokenId);
862         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
863     }
864 
865     /**
866      * @dev Returns whether `tokenId` exists.
867      *
868      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
869      *
870      * Tokens start existing when they are minted (`_mint`),
871      * and stop existing when they are burned (`_burn`).
872      */
873     function _exists(uint256 tokenId) internal view virtual returns (bool) {
874         return _owners[tokenId] != address(0);
875     }
876 
877     /**
878      * @dev Returns whether `spender` is allowed to manage `tokenId`.
879      *
880      * Requirements:
881      *
882      * - `tokenId` must exist.
883      */
884     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
885         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
886         address owner = ERC721.ownerOf(tokenId);
887         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
888     }
889 
890     /**
891      * @dev Safely mints `tokenId` and transfers it to `to`.
892      *
893      * Requirements:
894      *
895      * - `tokenId` must not exist.
896      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
897      *
898      * Emits a {Transfer} event.
899      */
900     function _safeMint(address to, uint256 tokenId) internal virtual {
901         _safeMint(to, tokenId, "");
902     }
903 
904     /**
905      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
906      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
907      */
908     function _safeMint(
909         address to,
910         uint256 tokenId,
911         bytes memory _data
912     ) internal virtual {
913         _mint(to, tokenId);
914         require(
915             _checkOnERC721Received(address(0), to, tokenId, _data),
916             "ERC721: transfer to non ERC721Receiver implementer"
917         );
918     }
919 
920     /**
921      * @dev Mints `tokenId` and transfers it to `to`.
922      *
923      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
924      *
925      * Requirements:
926      *
927      * - `tokenId` must not exist.
928      * - `to` cannot be the zero address.
929      *
930      * Emits a {Transfer} event.
931      */
932     function _mint(address to, uint256 tokenId) internal virtual {
933         require(to != address(0), "ERC721: mint to the zero address");
934         require(!_exists(tokenId), "ERC721: token already minted");
935 
936         _beforeTokenTransfer(address(0), to, tokenId);
937 
938         _balances[to] += 1;
939         _owners[tokenId] = to;
940 
941         emit Transfer(address(0), to, tokenId);
942     }
943 
944     /**
945      * @dev Destroys `tokenId`.
946      * The approval is cleared when the token is burned.
947      *
948      * Requirements:
949      *
950      * - `tokenId` must exist.
951      *
952      * Emits a {Transfer} event.
953      */
954     function _burn(uint256 tokenId) internal virtual {
955         address owner = ERC721.ownerOf(tokenId);
956 
957         _beforeTokenTransfer(owner, address(0), tokenId);
958 
959         // Clear approvals
960         _approve(address(0), tokenId);
961 
962         _balances[owner] -= 1;
963         delete _owners[tokenId];
964 
965         emit Transfer(owner, address(0), tokenId);
966     }
967 
968     /**
969      * @dev Transfers `tokenId` from `from` to `to`.
970      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
971      *
972      * Requirements:
973      *
974      * - `to` cannot be the zero address.
975      * - `tokenId` token must be owned by `from`.
976      *
977      * Emits a {Transfer} event.
978      */
979     function _transfer(
980         address from,
981         address to,
982         uint256 tokenId
983     ) internal virtual {
984         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
985         require(to != address(0), "ERC721: transfer to the zero address");
986 
987         _beforeTokenTransfer(from, to, tokenId);
988 
989         // Clear approvals from the previous owner
990         _approve(address(0), tokenId);
991 
992         _balances[from] -= 1;
993         _balances[to] += 1;
994         _owners[tokenId] = to;
995 
996         emit Transfer(from, to, tokenId);
997     }
998 
999     /**
1000      * @dev Approve `to` to operate on `tokenId`
1001      *
1002      * Emits a {Approval} event.
1003      */
1004     function _approve(address to, uint256 tokenId) internal virtual {
1005         _tokenApprovals[tokenId] = to;
1006         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1007     }
1008 
1009     /**
1010      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1011      * The call is not executed if the target address is not a contract.
1012      *
1013      * @param from address representing the previous owner of the given token ID
1014      * @param to target address that will receive the tokens
1015      * @param tokenId uint256 ID of the token to be transferred
1016      * @param _data bytes optional data to send along with the call
1017      * @return bool whether the call correctly returned the expected magic value
1018      */
1019     function _checkOnERC721Received(
1020         address from,
1021         address to,
1022         uint256 tokenId,
1023         bytes memory _data
1024     ) private returns (bool) {
1025         if (to.isContract()) {
1026             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1027                 return retval == IERC721Receiver(to).onERC721Received.selector;
1028             } catch (bytes memory reason) {
1029                 if (reason.length == 0) {
1030                     revert("ERC721: transfer to non ERC721Receiver implementer");
1031                 } else {
1032                     assembly {
1033                         revert(add(32, reason), mload(reason))
1034                     }
1035                 }
1036             }
1037         } else {
1038             return true;
1039         }
1040     }
1041 
1042     /**
1043      * @dev Hook that is called before any token transfer. This includes minting
1044      * and burning.
1045      *
1046      * Calling conditions:
1047      *
1048      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1049      * transferred to `to`.
1050      * - When `from` is zero, `tokenId` will be minted for `to`.
1051      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1052      * - `from` and `to` are never both zero.
1053      *
1054      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1055      */
1056     function _beforeTokenTransfer(
1057         address from,
1058         address to,
1059         uint256 tokenId
1060     ) internal virtual {}
1061 }
1062 
1063 
1064 
1065 /**
1066  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
1067  * @dev See https://eips.ethereum.org/EIPS/eip-721
1068  */
1069 interface IERC721Enumerable is IERC721 {
1070     /**
1071      * @dev Returns the total amount of tokens stored by the contract.
1072      */
1073     function totalSupply() external view returns (uint256);
1074 
1075     /**
1076      * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
1077      * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
1078      */
1079     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
1080 
1081     /**
1082      * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
1083      * Use along with {totalSupply} to enumerate all tokens.
1084      */
1085     function tokenByIndex(uint256 index) external view returns (uint256);
1086 }
1087 
1088 
1089 /**
1090  * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
1091  * enumerability of all the token ids in the contract as well as all token ids owned by each
1092  * account.
1093  */
1094 abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
1095     // Mapping from owner to list of owned token IDs
1096     mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
1097 
1098     // Mapping from token ID to index of the owner tokens list
1099     mapping(uint256 => uint256) private _ownedTokensIndex;
1100 
1101     // Array with all token ids, used for enumeration
1102     uint256[] private _allTokens;
1103 
1104     // Mapping from token id to position in the allTokens array
1105     mapping(uint256 => uint256) private _allTokensIndex;
1106 
1107     /**
1108      * @dev See {IERC165-supportsInterface}.
1109      */
1110     function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
1111         return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);
1112     }
1113 
1114     /**
1115      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1116      */
1117     function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
1118         require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
1119         return _ownedTokens[owner][index];
1120     }
1121 
1122     /**
1123      * @dev See {IERC721Enumerable-totalSupply}.
1124      */
1125     function totalSupply() public view virtual override returns (uint256) {
1126         return _allTokens.length;
1127     }
1128 
1129     /**
1130      * @dev See {IERC721Enumerable-tokenByIndex}.
1131      */
1132     function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
1133         require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
1134         return _allTokens[index];
1135     }
1136 
1137     /**
1138      * @dev Hook that is called before any token transfer. This includes minting
1139      * and burning.
1140      *
1141      * Calling conditions:
1142      *
1143      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1144      * transferred to `to`.
1145      * - When `from` is zero, `tokenId` will be minted for `to`.
1146      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1147      * - `from` cannot be the zero address.
1148      * - `to` cannot be the zero address.
1149      *
1150      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1151      */
1152     function _beforeTokenTransfer(
1153         address from,
1154         address to,
1155         uint256 tokenId
1156     ) internal virtual override {
1157         super._beforeTokenTransfer(from, to, tokenId);
1158 
1159         if (from == address(0)) {
1160             _addTokenToAllTokensEnumeration(tokenId);
1161         } else if (from != to) {
1162             _removeTokenFromOwnerEnumeration(from, tokenId);
1163         }
1164         if (to == address(0)) {
1165             _removeTokenFromAllTokensEnumeration(tokenId);
1166         } else if (to != from) {
1167             _addTokenToOwnerEnumeration(to, tokenId);
1168         }
1169     }
1170 
1171     /**
1172      * @dev Private function to add a token to this extension's ownership-tracking data structures.
1173      * @param to address representing the new owner of the given token ID
1174      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
1175      */
1176     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
1177         uint256 length = ERC721.balanceOf(to);
1178         _ownedTokens[to][length] = tokenId;
1179         _ownedTokensIndex[tokenId] = length;
1180     }
1181 
1182     /**
1183      * @dev Private function to add a token to this extension's token tracking data structures.
1184      * @param tokenId uint256 ID of the token to be added to the tokens list
1185      */
1186     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
1187         _allTokensIndex[tokenId] = _allTokens.length;
1188         _allTokens.push(tokenId);
1189     }
1190 
1191     /**
1192      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
1193      * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
1194      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
1195      * This has O(1) time complexity, but alters the order of the _ownedTokens array.
1196      * @param from address representing the previous owner of the given token ID
1197      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
1198      */
1199     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
1200         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
1201         // then delete the last slot (swap and pop).
1202 
1203         uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
1204         uint256 tokenIndex = _ownedTokensIndex[tokenId];
1205 
1206         // When the token to delete is the last token, the swap operation is unnecessary
1207         if (tokenIndex != lastTokenIndex) {
1208             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];
1209 
1210             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1211             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1212         }
1213 
1214         // This also deletes the contents at the last position of the array
1215         delete _ownedTokensIndex[tokenId];
1216         delete _ownedTokens[from][lastTokenIndex];
1217     }
1218 
1219     /**
1220      * @dev Private function to remove a token from this extension's token tracking data structures.
1221      * This has O(1) time complexity, but alters the order of the _allTokens array.
1222      * @param tokenId uint256 ID of the token to be removed from the tokens list
1223      */
1224     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
1225         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
1226         // then delete the last slot (swap and pop).
1227 
1228         uint256 lastTokenIndex = _allTokens.length - 1;
1229         uint256 tokenIndex = _allTokensIndex[tokenId];
1230 
1231         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
1232         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
1233         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
1234         uint256 lastTokenId = _allTokens[lastTokenIndex];
1235 
1236         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
1237         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
1238 
1239         // This also deletes the contents at the last position of the array
1240         delete _allTokensIndex[tokenId];
1241         _allTokens.pop();
1242     }
1243 }
1244 
1245 
1246 contract beckLoot is ERC721Enumerable, ReentrancyGuard, Ownable {
1247 
1248     uint BASE_CREDIT_VALUE = 250; // Multiply base credit value by probability of each classes spawn rate and their multiplier then add all of those values to get ~900k. We then 25 from this value and rand % 49 to get a range
1249     bool saleActive;
1250     bool whitelistActive;
1251     address regularMint;
1252     address rareMint;
1253     address handMint;
1254     bytes32[] _rootHash;
1255 
1256      // Mapping for wallet addresses that have previously minted
1257     mapping(address => uint8) private _previousMinters;
1258 
1259     string[] private class = [
1260         "Worker",
1261         "Grunt",
1262         "Assistant",
1263         "Driver",
1264         "Chat Support",
1265         "Builder",
1266         "Cook",
1267         "Bartender",
1268         "Corporate",
1269         "Punk",
1270         "Nerd",
1271         "Scavenger",
1272         "Officer",
1273         "Developer",
1274         "Club Promoter",
1275         "Chef",
1276         "Mercenary",
1277         "Samurai",
1278         "Tech Runner",
1279         "Cyberstreet Trader",
1280         "Club Owner",
1281         "NFT Artist",
1282         "Cyber Ninja",
1283         "Assassin",
1284         "Exectuive",
1285         "Tech Weapon Dealer",
1286         "Architect",
1287         "Wraith",
1288         "Slayer",
1289         "CEO",
1290         "Market Whale",
1291         "Day One Bitcoin Investor",
1292         "Celebrity",
1293         "Hand of Citadel"
1294     ];
1295     
1296     string[] private gender = [
1297         "Male",
1298         "Female"
1299     ];
1300     
1301     string[] private race = [
1302         "Human",
1303         "Android",
1304         "Mutant",
1305         "Albino",
1306         "Ape",
1307         "Ghost",
1308         "Demon",
1309         "Aeon",
1310         "Phantom"
1311     ];
1312 
1313     string[] private ability = [
1314         "Weapon Check",
1315         "Ghost Walk",
1316         "Locksmith",
1317         "Hard Gut",
1318         "Dead Eye",
1319         "Revive",
1320         "Shield",
1321         "Athele",
1322         "Dense"
1323     ];
1324 
1325     string[] private eyes = [
1326         "Tired",
1327         "Focused",
1328         "Skeptical",
1329         "Sad",
1330         "Suspicious",
1331         "Bloodshot",
1332         "Angry",
1333         "Scar",
1334         "Grumpy",
1335         "Paranoid",
1336         "Alien",
1337         "Cyborg",
1338         "Robot",
1339         "Demon Eyes",
1340         "Glowing",
1341         "Laser Eyes"
1342     ];
1343 
1344     string[] private creditYield = [
1345         "LOW",
1346         "Mid",
1347         "High",
1348         "Very High",
1349         "Excessive"
1350     ];
1351 
1352     function setSale() external onlyOwner
1353     {
1354         saleActive = !saleActive;
1355     }
1356 
1357     function setWhitelistState() external onlyOwner
1358     {
1359         whitelistActive = !whitelistActive;
1360     }
1361 
1362     function getCredits(uint256 tokenId) external view returns (string memory)
1363     {
1364         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1365         string memory output;
1366 
1367         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1368         output = dataContract.getCredits(tokenId);
1369 
1370         return output;
1371     }
1372     
1373     function getClass(uint256 tokenId) public view returns (string memory) {
1374         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1375         string memory output;
1376         
1377         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1378         output = dataContract.getClass(tokenId);
1379 
1380         return output;
1381     }
1382     
1383     function getRace(uint256 tokenId) public view returns (string memory) {
1384         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1385         string memory output;
1386         
1387         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1388         output = dataContract.getRace(tokenId);
1389 
1390         return output;
1391     }
1392     
1393     function getStrength(uint256 tokenId) public view returns (string memory) {
1394         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1395         string memory output;
1396         
1397         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1398         output = dataContract.getStrength(tokenId);
1399 
1400         return output;
1401     }
1402 
1403     function getIntelligence(uint256 tokenId) public view returns (string memory) {
1404         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1405         string memory output;
1406         
1407         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1408         output = dataContract.getIntelligence(tokenId);
1409 
1410         return output;
1411     }
1412     
1413     function getAttractiveness(uint256 tokenId) public view returns (string memory) {
1414         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1415         string memory output;
1416         
1417         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1418         output = dataContract.getAttractiveness(tokenId);
1419 
1420         return output;
1421     }
1422     
1423     function getTechSkill(uint256 tokenId) public view returns (string memory) {
1424         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1425         string memory output;
1426 
1427         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1428         output = dataContract.getTechSkill(tokenId);
1429 
1430         return output;
1431     }
1432     
1433     function getCool(uint256 tokenId) public view returns (string memory) {
1434         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1435         string memory output;
1436 
1437         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1438         output = dataContract.getCool(tokenId);
1439 
1440         return output;
1441     }
1442 
1443     function getEyes(uint256 tokenId) public view returns (string memory) {
1444         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1445         string memory output;
1446 
1447         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1448         output = dataContract.getEyes(tokenId);
1449 
1450         return output;
1451     }
1452 
1453     function getGender(uint256 tokenId) public view returns (string memory) {
1454         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1455         string memory output;
1456 
1457         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1458         output = dataContract.getGender(tokenId);
1459 
1460         return output;
1461     }
1462 
1463     function getAbility(uint256 tokenId) public view returns (string memory) {
1464         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1465         string memory output;
1466         
1467         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1468         output = dataContract.getAbility(tokenId);
1469 
1470         return output;
1471     }
1472 
1473     function tokenURI(uint256 tokenId) override public view returns (string memory) {
1474         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1475         
1476         string memory output;
1477 
1478         beckLoot dataContract = beckLoot(contractRouter(tokenId));
1479         output = dataContract.tokenURI(tokenId);
1480 
1481         return output;
1482     }
1483 
1484     function claim(uint256 tokenId) public nonReentrant {
1485         require(tokenId > 0 && tokenId < 2001, "Token ID invalid");
1486         require(saleActive, "Public claiming is currently closed");
1487         _safeMint(_msgSender(), tokenId);
1488     }
1489 
1490     function whitelistClaim(uint256 tokenId, uint256 spotInWhitelist, bytes32[] memory proof) public nonReentrant {
1491         require(whitelistActive, "The whitelist is not active yet");
1492         require(tokenId > 0 && tokenId < 2001, "Token ID invalid");
1493         require(whitelistValidated(_msgSender(), spotInWhitelist, proof), "You're not on the whitelist");
1494         require(_previousMinters[_msgSender()] < 1, "You've already minted");
1495 
1496         //Set the previousMinter value to 1 for this address as it will now mint
1497         _previousMinters[_msgSender()] = 1;
1498 
1499         _safeMint(_msgSender(), tokenId);
1500     }
1501     
1502     function ownerClaim(uint256 tokenId) public nonReentrant onlyOwner {
1503         require(tokenId > 2000 && tokenId < 2251, "Token ID invalid");
1504         _safeMint(owner(), tokenId);
1505     }
1506 
1507     function riddleClaim(address _to, uint256 tokenId) public nonReentrant onlyOwner {
1508         require(tokenId > 2250 && tokenId < 2281, "Token ID invalid");
1509         _safeMint(_to, tokenId);
1510     }
1511 
1512     function handClaim(address _to, uint256 tokenId) public nonReentrant onlyOwner {
1513         require(tokenId > 2280 && tokenId < 2288, "Token ID invalid");
1514         _safeMint(_to, tokenId);
1515     }
1516 
1517     function whitelistValidated(address wallet, uint256 index, bytes32[] memory proof) internal view returns (bool) {
1518         uint256 amount = 1;
1519 
1520         // Compute the merkle root
1521         bytes32 node = keccak256(abi.encodePacked(index, wallet, amount));
1522         uint256 path = index;
1523         for (uint16 i = 0; i < proof.length; i++) {
1524             if ((path & 0x01) == 1) {
1525                 node = keccak256(abi.encodePacked(proof[i], node));
1526             } else {
1527                 node = keccak256(abi.encodePacked(node, proof[i]));
1528             }
1529             path /= 2;
1530         }
1531 
1532         // Check the merkle proof against the root hash array
1533         for(uint i = 0; i < _rootHash.length; i++)
1534         {
1535             if (node == _rootHash[i])
1536             {
1537                 return true;
1538             }
1539         }
1540 
1541         return false;
1542     }
1543 
1544     function setMintContract(address contractAddress) public onlyOwner {
1545         regularMint = contractAddress;
1546     }
1547 
1548     function setRareMintContract(address contractAddress) public onlyOwner {
1549         rareMint = contractAddress;
1550     }
1551 
1552     function setHandMintContract(address contractAddress) public onlyOwner {
1553         handMint = contractAddress;
1554     }
1555 
1556     function contractRouter(uint256 tokenId) internal view returns (address) {
1557         address _address;
1558 
1559         if(tokenId < 2251)
1560         {
1561             _address = regularMint;
1562         }
1563         else if (tokenId < 2281)
1564         {
1565             _address = rareMint;
1566         }
1567         else
1568         {
1569             _address = handMint;
1570         }
1571 
1572         return _address;
1573     }
1574     
1575     
1576     function toString(uint256 value) internal pure returns (string memory) {
1577     // Inspired by OraclizeAPI's implementation - MIT license
1578     // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
1579 
1580         if (value == 0) {
1581             return "0";
1582         }
1583         uint256 temp = value;
1584         uint256 digits;
1585         while (temp != 0) {
1586             digits++;
1587             temp /= 10;
1588         }
1589         bytes memory buffer = new bytes(digits);
1590         while (value != 0) {
1591             digits -= 1;
1592             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
1593             value /= 10;
1594         }
1595         return string(buffer);
1596     }
1597     
1598     constructor() ERC721("Neo Tokyo: Identities", "NEOTI") Ownable() {
1599         _rootHash = new bytes32[](6);
1600         _rootHash[0] = 0x5d6050aa43daddf342a2a9f6c9bc060c0194c5db3f230ff1f8f3ade22ce37e85;
1601         _rootHash[1] = 0x5676c2086880e64e9d5beaec0c4d5cb08d2ea78ad845df1501a1dce077f07669;
1602         _rootHash[2] = 0x07d0b318229662e1d88d4594cc73524e366458fdaad3b392a1cccb60f0c6af56;
1603         _rootHash[3] = 0x152eb19e760325aec01d54ef614314b95c6e48a3dd1fa219d6c2267befa443c8;
1604         _rootHash[4] = 0xeff3ac3e9f30dfd8c3f3d8755d77b0f065d124008f165c014a2b9d3031caa278;
1605         _rootHash[5] = 0x67f3ca11ca57bad3a53c01f64e2c6d1bd7972befa75dae5a03f9c63b762195bf;
1606 
1607         regularMint = 0x79995D5dDDfAFD09eC17bB6Ee728B6F7f6cce1f7;
1608         rareMint = 0x0a35E3C53A1268b6C092f2137a7D83b260BA57E6;
1609         saleActive = false;
1610         whitelistActive = false;
1611     }
1612 }