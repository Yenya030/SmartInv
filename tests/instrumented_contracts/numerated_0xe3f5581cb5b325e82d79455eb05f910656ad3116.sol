1 //SPDX-License-Identifier: MIT
2 pragma solidity ^0.8.0;
3 
4 
5 interface LinkTokenInterface {
6 
7   function allowance(
8     address owner,
9     address spender
10   )
11     external
12     view
13     returns (
14       uint256 remaining
15     );
16 
17   function approve(
18     address spender,
19     uint256 value
20   )
21     external
22     returns (
23       bool success
24     );
25 
26   function balanceOf(
27     address owner
28   )
29     external
30     view
31     returns (
32       uint256 balance
33     );
34 
35   function decimals()
36     external
37     view
38     returns (
39       uint8 decimalPlaces
40     );
41 
42   function decreaseApproval(
43     address spender,
44     uint256 addedValue
45   )
46     external
47     returns (
48       bool success
49     );
50 
51   function increaseApproval(
52     address spender,
53     uint256 subtractedValue
54   ) external;
55 
56   function name()
57     external
58     view
59     returns (
60       string memory tokenName
61     );
62 
63   function symbol()
64     external
65     view
66     returns (
67       string memory tokenSymbol
68     );
69 
70   function totalSupply()
71     external
72     view
73     returns (
74       uint256 totalTokensIssued
75     );
76 
77   function transfer(
78     address to,
79     uint256 value
80   )
81     external
82     returns (
83       bool success
84     );
85 
86   function transferAndCall(
87     address to,
88     uint256 value,
89     bytes calldata data
90   )
91     external
92     returns (
93       bool success
94     );
95 
96   function transferFrom(
97     address from,
98     address to,
99     uint256 value
100   )
101     external
102     returns (
103       bool success
104     );
105 
106 }
107 
108 contract VRFRequestIDBase {
109 
110   /**
111    * @notice returns the seed which is actually input to the VRF coordinator
112    *
113    * @dev To prevent repetition of VRF output due to repetition of the
114    * @dev user-supplied seed, that seed is combined in a hash with the
115    * @dev user-specific nonce, and the address of the consuming contract. The
116    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
117    * @dev the final seed, but the nonce does protect against repetition in
118    * @dev requests which are included in a single block.
119    *
120    * @param _userSeed VRF seed input provided by user
121    * @param _requester Address of the requesting contract
122    * @param _nonce User-specific nonce at the time of the request
123    */
124   function makeVRFInputSeed(
125     bytes32 _keyHash,
126     uint256 _userSeed,
127     address _requester,
128     uint256 _nonce
129   )
130     internal
131     pure
132     returns (
133       uint256
134     )
135   {
136     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
137   }
138 
139   /**
140    * @notice Returns the id for this request
141    * @param _keyHash The serviceAgreement ID to be used for this request
142    * @param _vRFInputSeed The seed to be passed directly to the VRF
143    * @return The id for this request
144    *
145    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
146    * @dev contract, but the one generated by makeVRFInputSeed
147    */
148   function makeRequestId(
149     bytes32 _keyHash,
150     uint256 _vRFInputSeed
151   )
152     internal
153     pure
154     returns (
155       bytes32
156     )
157   {
158     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
159   }
160 }
161 
162 /** ****************************************************************************
163  * @notice Interface for contracts using VRF randomness
164  * *****************************************************************************
165  * @dev PURPOSE
166  *
167  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
168  * @dev to Vera the verifier in such a way that Vera can be sure he's not
169  * @dev making his output up to suit himself. Reggie provides Vera a public key
170  * @dev to which he knows the secret key. Each time Vera provides a seed to
171  * @dev Reggie, he gives back a value which is computed completely
172  * @dev deterministically from the seed and the secret key.
173  *
174  * @dev Reggie provides a proof by which Vera can verify that the output was
175  * @dev correctly computed once Reggie tells it to her, but without that proof,
176  * @dev the output is indistinguishable to her from a uniform random sample
177  * @dev from the output space.
178  *
179  * @dev The purpose of this contract is to make it easy for unrelated contracts
180  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
181  * @dev simple access to a verifiable source of randomness.
182  * *****************************************************************************
183  * @dev USAGE
184  *
185  * @dev Calling contracts must inherit from VRFConsumerBase, and can
186  * @dev initialize VRFConsumerBase's attributes in their constructor as
187  * @dev shown:
188  *
189  * @dev   contract VRFConsumer {
190  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
191  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
192  * @dev         <initialization with other arguments goes here>
193  * @dev       }
194  * @dev   }
195  *
196  * @dev The oracle will have given you an ID for the VRF keypair they have
197  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
198  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
199  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
200  * @dev want to generate randomness from.
201  *
202  * @dev Once the VRFCoordinator has received and validated the oracle's response
203  * @dev to your request, it will call your contract's fulfillRandomness method.
204  *
205  * @dev The randomness argument to fulfillRandomness is the actual random value
206  * @dev generated from your seed.
207  *
208  * @dev The requestId argument is generated from the keyHash and the seed by
209  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
210  * @dev requests open, you can use the requestId to track which seed is
211  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
212  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
213  * @dev if your contract could have multiple requests in flight simultaneously.)
214  *
215  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
216  * @dev differ. (Which is critical to making unpredictable randomness! See the
217  * @dev next section.)
218  *
219  * *****************************************************************************
220  * @dev SECURITY CONSIDERATIONS
221  *
222  * @dev A method with the ability to call your fulfillRandomness method directly
223  * @dev could spoof a VRF response with any random value, so it's critical that
224  * @dev it cannot be directly called by anything other than this base contract
225  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
226  *
227  * @dev For your users to trust that your contract's random behavior is free
228  * @dev from malicious interference, it's best if you can write it so that all
229  * @dev behaviors implied by a VRF response are executed *during* your
230  * @dev fulfillRandomness method. If your contract must store the response (or
231  * @dev anything derived from it) and use it later, you must ensure that any
232  * @dev user-significant behavior which depends on that stored value cannot be
233  * @dev manipulated by a subsequent VRF request.
234  *
235  * @dev Similarly, both miners and the VRF oracle itself have some influence
236  * @dev over the order in which VRF responses appear on the blockchain, so if
237  * @dev your contract could have multiple VRF requests in flight simultaneously,
238  * @dev you must ensure that the order in which the VRF responses arrive cannot
239  * @dev be used to manipulate your contract's user-significant behavior.
240  *
241  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
242  * @dev block in which the request is made, user-provided seeds have no impact
243  * @dev on its economic security properties. They are only included for API
244  * @dev compatability with previous versions of this contract.
245  *
246  * @dev Since the block hash of the block which contains the requestRandomness
247  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
248  * @dev miner could, in principle, fork the blockchain to evict the block
249  * @dev containing the request, forcing the request to be included in a
250  * @dev different block with a different hash, and therefore a different input
251  * @dev to the VRF. However, such an attack would incur a substantial economic
252  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
253  * @dev until it calls responds to a request.
254  */
255 abstract contract VRFConsumerBase is VRFRequestIDBase {
256 
257   /**
258    * @notice fulfillRandomness handles the VRF response. Your contract must
259    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
260    * @notice principles to keep in mind when implementing your fulfillRandomness
261    * @notice method.
262    *
263    * @dev VRFConsumerBase expects its subcontracts to have a method with this
264    * @dev signature, and will call it once it has verified the proof
265    * @dev associated with the randomness. (It is triggered via a call to
266    * @dev rawFulfillRandomness, below.)
267    *
268    * @param requestId The Id initially returned by requestRandomness
269    * @param randomness the VRF output
270    */
271   function fulfillRandomness(
272     bytes32 requestId,
273     uint256 randomness
274   )
275     internal
276     virtual;
277 
278   /**
279    * @dev In order to keep backwards compatibility we have kept the user
280    * seed field around. We remove the use of it because given that the blockhash
281    * enters later, it overrides whatever randomness the used seed provides.
282    * Given that it adds no security, and can easily lead to misunderstandings,
283    * we have removed it from usage and can now provide a simpler API.
284    */
285   uint256 constant private USER_SEED_PLACEHOLDER = 0;
286 
287   /**
288    * @notice requestRandomness initiates a request for VRF output given _seed
289    *
290    * @dev The fulfillRandomness method receives the output, once it's provided
291    * @dev by the Oracle, and verified by the vrfCoordinator.
292    *
293    * @dev The _keyHash must already be registered with the VRFCoordinator, and
294    * @dev the _fee must exceed the fee specified during registration of the
295    * @dev _keyHash.
296    *
297    * @dev The _seed parameter is vestigial, and is kept only for API
298    * @dev compatibility with older versions. It can't *hurt* to mix in some of
299    * @dev your own randomness, here, but it's not necessary because the VRF
300    * @dev oracle will mix the hash of the block containing your request into the
301    * @dev VRF seed it ultimately uses.
302    *
303    * @param _keyHash ID of public key against which randomness is generated
304    * @param _fee The amount of LINK to send with the request
305    *
306    * @return requestId unique ID for this request
307    *
308    * @dev The returned requestId can be used to distinguish responses to
309    * @dev concurrent requests. It is passed as the first argument to
310    * @dev fulfillRandomness.
311    */
312   function requestRandomness(
313     bytes32 _keyHash,
314     uint256 _fee
315   )
316     internal
317     returns (
318       bytes32 requestId
319     )
320   {
321     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
322     // This is the seed passed to VRFCoordinator. The oracle will mix this with
323     // the hash of the block containing this request to obtain the seed/input
324     // which is finally passed to the VRF cryptographic machinery.
325     uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
326     // nonces[_keyHash] must stay in sync with
327     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
328     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
329     // This provides protection against the user repeating their input seed,
330     // which would result in a predictable/duplicate output, if multiple such
331     // requests appeared in the same block.
332     nonces[_keyHash] = nonces[_keyHash] + 1;
333     return makeRequestId(_keyHash, vRFSeed);
334   }
335 
336   LinkTokenInterface immutable internal LINK;
337   address immutable private vrfCoordinator;
338 
339   // Nonces for each VRF key from which randomness has been requested.
340   //
341   // Must stay in sync with VRFCoordinator[_keyHash][this]
342   mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;
343 
344   /**
345    * @param _vrfCoordinator address of VRFCoordinator contract
346    * @param _link address of LINK token contract
347    *
348    * @dev https://docs.chain.link/docs/link-token-contracts
349    */
350   constructor(
351     address _vrfCoordinator,
352     address _link
353   ) {
354     vrfCoordinator = _vrfCoordinator;
355     LINK = LinkTokenInterface(_link);
356   }
357 
358   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
359   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
360   // the origin of the call
361   function rawFulfillRandomness(
362     bytes32 requestId,
363     uint256 randomness
364   )
365     external
366   {
367     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
368     fulfillRandomness(requestId, randomness);
369   }
370 }
371 
372 
373 /**
374  * @dev Wrappers over Solidity's arithmetic operations with added overflow
375  * checks.
376  *
377  * Arithmetic operations in Solidity wrap on overflow. This can easily result
378  * in bugs, because programmers usually assume that an overflow raises an
379  * error, which is the standard behavior in high level programming languages.
380  * `SafeMath` restores this intuition by reverting the transaction when an
381  * operation overflows.
382  *
383  * Using this library instead of the unchecked operations eliminates an entire
384  * class of bugs, so it's recommended to use it always.
385  */
386 library SafeMath {
387     /**
388      * @dev Returns the addition of two unsigned integers, reverting on
389      * overflow.
390      *
391      * Counterpart to Solidity's `+` operator.
392      *
393      * Requirements:
394      * - Addition cannot overflow.
395      */
396     function add(uint256 a, uint256 b) internal pure returns (uint256) {
397         uint256 c = a + b;
398         require(c >= a, "SafeMath: addition overflow");
399 
400         return c;
401     }
402 
403     /**
404      * @dev Returns the subtraction of two unsigned integers, reverting on
405      * overflow (when the result is negative).
406      *
407      * Counterpart to Solidity's `-` operator.
408      *
409      * Requirements:
410      * - Subtraction cannot overflow.
411      */
412     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
413         return sub(a, b, "SafeMath: subtraction overflow");
414     }
415 
416     /**
417      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
418      * overflow (when the result is negative).
419      *
420      * Counterpart to Solidity's `-` operator.
421      *
422      * Requirements:
423      * - Subtraction cannot overflow.
424      *
425      * _Available since v2.4.0._
426      */
427     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
428         require(b <= a, errorMessage);
429         uint256 c = a - b;
430 
431         return c;
432     }
433 
434     /**
435      * @dev Returns the multiplication of two unsigned integers, reverting on
436      * overflow.
437      *
438      * Counterpart to Solidity's `*` operator.
439      *
440      * Requirements:
441      * - Multiplication cannot overflow.
442      */
443     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
444         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
445         // benefit is lost if 'b' is also tested.
446         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
447         if (a == 0) {
448             return 0;
449         }
450 
451         uint256 c = a * b;
452         require(c / a == b, "SafeMath: multiplication overflow");
453 
454         return c;
455     }
456 
457     /**
458      * @dev Returns the integer division of two unsigned integers. Reverts on
459      * division by zero. The result is rounded towards zero.
460      *
461      * Counterpart to Solidity's `/` operator. Note: this function uses a
462      * `revert` opcode (which leaves remaining gas untouched) while Solidity
463      * uses an invalid opcode to revert (consuming all remaining gas).
464      *
465      * Requirements:
466      * - The divisor cannot be zero.
467      */
468     function div(uint256 a, uint256 b) internal pure returns (uint256) {
469         return div(a, b, "SafeMath: division by zero");
470     }
471 
472     /**
473      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
474      * division by zero. The result is rounded towards zero.
475      *
476      * Counterpart to Solidity's `/` operator. Note: this function uses a
477      * `revert` opcode (which leaves remaining gas untouched) while Solidity
478      * uses an invalid opcode to revert (consuming all remaining gas).
479      *
480      * Requirements:
481      * - The divisor cannot be zero.
482      *
483      * _Available since v2.4.0._
484      */
485     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
486         // Solidity only automatically asserts when dividing by 0
487         require(b > 0, errorMessage);
488         uint256 c = a / b;
489         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
490 
491         return c;
492     }
493 
494     /**
495      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
496      * Reverts when dividing by zero.
497      *
498      * Counterpart to Solidity's `%` operator. This function uses a `revert`
499      * opcode (which leaves remaining gas untouched) while Solidity uses an
500      * invalid opcode to revert (consuming all remaining gas).
501      *
502      * Requirements:
503      * - The divisor cannot be zero.
504      */
505     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
506         return mod(a, b, "SafeMath: modulo by zero");
507     }
508 
509     /**
510      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
511      * Reverts with custom message when dividing by zero.
512      *
513      * Counterpart to Solidity's `%` operator. This function uses a `revert`
514      * opcode (which leaves remaining gas untouched) while Solidity uses an
515      * invalid opcode to revert (consuming all remaining gas).
516      *
517      * Requirements:
518      * - The divisor cannot be zero.
519      *
520      * _Available since v2.4.0._
521      */
522     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
523         require(b != 0, errorMessage);
524         return a % b;
525     }
526 }
527 
528 /*
529  * @dev Provides information about the current execution context, including the
530  * sender of the transaction and its data. While these are generally available
531  * via msg.sender and msg.data, they should not be accessed in such a direct
532  * manner, since when dealing with GSN meta-transactions the account sending and
533  * paying for execution may not be the actual sender (as far as an application
534  * is concerned).
535  *
536  * This contract is only required for intermediate, library-like contracts.
537  */
538 contract Context {
539     // Empty internal constructor, to prevent people from mistakenly deploying
540     // an instance of this contract, which should be used via inheritance.
541     constructor () { }
542     // solhint-disable-previous-line no-empty-blocks
543 
544     function _msgSender() internal view returns (address) {
545         return msg.sender;
546     }
547 
548     function _msgData() internal view returns (bytes memory) {
549         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
550         return msg.data;
551     }
552 }
553 
554 /**
555  * @dev Contract module which provides a basic access control mechanism, where
556  * there is an account (an owner) that can be granted exclusive access to
557  * specific functions.
558  *
559  * This module is used through inheritance. It will make available the modifier
560  * `onlyOwner`, which can be applied to your functions to restrict their use to
561  * the owner.
562  */
563 contract Ownable is Context {
564     address private _owner;
565 
566     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
567 
568     /**
569      * @dev Initializes the contract setting the deployer as the initial owner.
570      */
571     constructor () {
572         address msgSender = _msgSender();
573         _owner = msgSender;
574         emit OwnershipTransferred(address(0), msgSender);
575     }
576 
577     /**
578      * @dev Returns the address of the current owner.
579      */
580     function owner() public view returns (address) {
581         return _owner;
582     }
583 
584     /**
585      * @dev Throws if called by any account other than the owner.
586      */
587     modifier onlyOwner() {
588         require(isOwner(), "Ownable: caller is not the owner");
589         _;
590     }
591 
592     /**
593      * @dev Returns true if the caller is the current owner.
594      */
595     function isOwner() public view returns (bool) {
596         return _msgSender() == _owner;
597     }
598 
599     /**
600      * @dev Leaves the contract without owner. It will not be possible to call
601      * `onlyOwner` functions anymore. Can only be called by the current owner.
602      *
603      * NOTE: Renouncing ownership will leave the contract without an owner,
604      * thereby removing any functionality that is only available to the owner.
605      */
606     function renounceOwnership() public onlyOwner {
607         emit OwnershipTransferred(_owner, address(0));
608         _owner = address(0);
609     }
610 
611     /**
612      * @dev Transfers ownership of the contract to a new account (`newOwner`).
613      * Can only be called by the current owner.
614      */
615     function transferOwnership(address newOwner) public onlyOwner {
616         _transferOwnership(newOwner);
617     }
618 
619     /**
620      * @dev Transfers ownership of the contract to a new account (`newOwner`).
621      */
622     function _transferOwnership(address newOwner) internal {
623         require(newOwner != address(0), "Ownable: new owner is the zero address");
624         emit OwnershipTransferred(_owner, newOwner);
625         _owner = newOwner;
626     }
627 }
628 
629 /**
630  * _Available since v3.1._
631  */
632 interface IERC1155Receiver {
633 
634     /**
635         @dev Handles the receipt of a single ERC1155 token type. This function is
636         called at the end of a `safeTransferFrom` after the balance has been updated.
637         To accept the transfer, this must return
638         `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
639         (i.e. 0xf23a6e61, or its own function selector).
640         @param operator The address which initiated the transfer (i.e. msg.sender)
641         @param from The address which previously owned the token
642         @param id The ID of the token being transferred
643         @param value The amount of tokens being transferred
644         @param data Additional data with no specified format
645         @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
646     */
647     function onERC1155Received(
648         address operator,
649         address from,
650         uint256 id,
651         uint256 value,
652         bytes calldata data
653     )
654         external
655         returns(bytes4);
656 
657     /**
658         @dev Handles the receipt of a multiple ERC1155 token types. This function
659         is called at the end of a `safeBatchTransferFrom` after the balances have
660         been updated. To accept the transfer(s), this must return
661         `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
662         (i.e. 0xbc197c81, or its own function selector).
663         @param operator The address which initiated the batch transfer (i.e. msg.sender)
664         @param from The address which previously owned the token
665         @param ids An array containing ids of each token being transferred (order and length must match values array)
666         @param values An array containing amounts of each token being transferred (order and length must match ids array)
667         @param data Additional data with no specified format
668         @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
669     */
670     function onERC1155BatchReceived(
671         address operator,
672         address from,
673         uint256[] calldata ids,
674         uint256[] calldata values,
675         bytes calldata data
676     )
677         external
678         returns(bytes4);
679 }
680 
681 
682 
683 interface MoonDoge {
684     
685 	function mint(
686 		address _to,
687 		uint256 _id,
688 		uint256 _quantity,
689 		bytes calldata _data
690 	) external;
691 
692 	function create(
693 		uint256 _maxSupply,
694 		uint256 _initialSupply,
695 		string calldata _uri,
696 		bytes calldata _data
697 	) external returns (uint256 tokenId);
698 
699 	function safeTransferFrom(
700 		address _from,
701 		address _to,
702 		uint256 _id,
703 		uint256 _amount,
704 		bytes calldata _data
705 	) external;
706 
707 	function safeBatchTransferFrom(
708 		address _from,
709 		address _to,
710 		uint256[] calldata _ids,
711 		uint256[] calldata _amounts,
712 		bytes calldata _data
713 	) external;
714 
715 	function balanceOf(address _owner, uint256 _id) external view returns (uint256);
716 
717 	function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)
718 		external
719 		view
720 		returns (uint256[] memory);
721 
722 	function setApprovalForAll(address _operator, bool _approved) external;
723 
724 	function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);
725 
726 	function tokenIdByTraits(bytes2 traits) external view returns (uint256 tokenId);
727 }
728     
729 interface IERC1155 {
730 	event TransferSingle(
731 		address indexed _operator,
732 		address indexed _from,
733 		address indexed _to,
734 		uint256 _id,
735 		uint256 _amount
736 	);
737 
738 	event TransferBatch(
739 		address indexed _operator,
740 		address indexed _from,
741 		address indexed _to,
742 		uint256[] _ids,
743 		uint256[] _amounts
744 	);
745 
746 	event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
747 
748 	event URI(string _amount, uint256 indexed _id);
749 
750 	function mint(
751 		address _to,
752 		uint256 _id,
753 		uint256 _quantity,
754 		bytes calldata _data
755 	) external;
756 
757 	function create(
758 		uint256 _maxSupply,
759 		uint256 _initialSupply,
760 		string calldata _uri,
761 		bytes calldata _data
762 	) external returns (uint256 tokenId);
763 
764 	function safeTransferFrom(
765 		address _from,
766 		address _to,
767 		uint256 _id,
768 		uint256 _amount,
769 		bytes calldata _data
770 	) external;
771 
772 	function safeBatchTransferFrom(
773 		address _from,
774 		address _to,
775 		uint256[] calldata _ids,
776 		uint256[] calldata _amounts,
777 		bytes calldata _data
778 	) external;
779 
780 	function balanceOf(address _owner, uint256 _id) external view returns (uint256);
781 
782 	function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)
783 		external
784 		view
785 		returns (uint256[] memory);
786 
787 	function setApprovalForAll(address _operator, bool _approved) external;
788 
789 	function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);
790 }
791 
792 /**
793  * @dev Interface of the ERC20 standard as defined in the EIP. Does not include
794  * the optional functions; to access them see {ERC20Detailed}.
795  */
796 interface IERC20 {
797     /**
798      * @dev Returns the amount of tokens in existence.
799      */
800     function totalSupply() external view returns (uint256);
801 
802     /**
803      * @dev Returns the amount of tokens owned by `account`.
804      */
805     function balanceOf(address account) external view returns (uint256);
806 
807     /**
808      * @dev Moves `amount` tokens from the caller's account to `recipient`.
809      *
810      * Returns a boolean value indicating whether the operation succeeded.
811      *
812      * Emits a {Transfer} event.
813      */
814     function transfer(address recipient, uint256 amount) external returns (bool);
815 
816     /**
817      * @dev Returns the remaining number of tokens that `spender` will be
818      * allowed to spend on behalf of `owner` through {transferFrom}. This is
819      * zero by default.
820      *
821      * This value changes when {approve} or {transferFrom} are called.
822      */
823     function allowance(address owner, address spender) external view returns (uint256);
824 
825     /**
826      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
827      *
828      * Returns a boolean value indicating whether the operation succeeded.
829      *
830      * IMPORTANT: Beware that changing an allowance with this method brings the risk
831      * that someone may use both the old and the new allowance by unfortunate
832      * transaction ordering. One possible solution to mitigate this race
833      * condition is to first reduce the spender's allowance to 0 and set the
834      * desired value afterwards:
835      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
836      *
837      * Emits an {Approval} event.
838      */
839     function approve(address spender, uint256 amount) external returns (bool);
840 
841     /**
842      * @dev Moves `amount` tokens from `sender` to `recipient` using the
843      * allowance mechanism. `amount` is then deducted from the caller's
844      * allowance.
845      *
846      * Returns a boolean value indicating whether the operation succeeded.
847      *
848      * Emits a {Transfer} event.
849      */
850     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
851 
852     /**
853      * @dev Emitted when `value` tokens are moved from one account (`from`) to
854      * another (`to`).
855      *
856      * Note that `value` may be zero.
857      */
858     event Transfer(address indexed from, address indexed to, uint256 value);
859 
860     /**
861      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
862      * a call to {approve}. `value` is the new allowance.
863      */
864     event Approval(address indexed owner, address indexed spender, uint256 value);
865 }
866 
867 contract dogeIncubator is Ownable, IERC1155Receiver, VRFConsumerBase {
868     using SafeMath for uint256;
869     
870     bytes2[] public availableDoges;
871     
872     uint256 public nftid;
873     address public eggAddress;
874     address public crackedEggAddress;
875     uint256 public crackedEggId;
876     address public dogeAddress;
877     bool public active = false;
878     
879     
880     bytes32 internal keyHash;
881     bytes32 public currentRequestId;
882     
883     event Request(bytes32 requestId);
884     event DogeBirth(bytes2 dogeType, uint256 pickedIndex);
885 
886     /*
887         Chainlink VRF:
888         LINK	0x514910771AF9Ca656af840dff83E8264EcF986CA
889         VRF Coordinator	0xf0d54349aDdcf704F77AE15b96510dEA15cb7952
890         Key Hash	0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445
891         Fee	2 LINK
892     */
893     
894     uint256 linkFee = 2 ether;
895     
896     // requestId => hatcher address
897     mapping (bytes32 => address) public eggHatcher;
898     // requestId => isFulfilled address
899     mapping (bytes32 => bool) public requestFulfilled;
900     
901     
902     constructor(address _eggAddress, uint256 _eggid, address _crackedEggAddress, uint256 _crackedEggId, address _dogeAddress) VRFConsumerBase(0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, 0x514910771AF9Ca656af840dff83E8264EcF986CA) {
903         eggAddress = _eggAddress;
904         nftid = _eggid;
905         crackedEggAddress = _crackedEggAddress;
906         crackedEggId = _crackedEggId;
907         dogeAddress = _dogeAddress;
908         keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;
909     }
910     
911     function hatchEgg() public {
912         require(active == true, "The incubator is currently disabled");
913         
914         // send user's eggs to this address
915         IERC1155(eggAddress).safeTransferFrom(msg.sender, address(this), nftid, 1, "");
916         
917         // send the user a cracked egg
918         IERC1155(crackedEggAddress).safeTransferFrom(address(this), msg.sender, crackedEggId, 1, "");
919         
920         currentRequestId = requestRandomness(keyHash, linkFee);
921         
922         eggHatcher[currentRequestId] = msg.sender;
923         
924         emit Request(currentRequestId);
925         
926     }
927     
928     // Skips eggs, cracked eggs, and incubator state check
929     function adminHatchEgg(address _receiver) public onlyOwner {
930         
931         currentRequestId = requestRandomness(keyHash, linkFee);
932         
933         eggHatcher[currentRequestId] = _receiver;
934         
935         emit Request(currentRequestId);
936         
937     }
938     
939     
940     function finishHatchingEgg(bytes32 requestId, uint256 randomNumber) private {
941         
942         require(availableDoges.length >= 1, "No more doges");
943         
944         uint256 randomDoge = 0;
945         
946         if(availableDoges.length > 1) {
947             randomDoge = randomNumber % (availableDoges.length-1);
948         }
949         
950         bytes2 pickedDoge = availableDoges[randomDoge];
951         availableDoges[randomDoge] = availableDoges[availableDoges.length - 1];
952         availableDoges.pop();
953         
954         emit DogeBirth(pickedDoge, randomDoge);
955         
956         uint256 pickedDogeId = MoonDoge(dogeAddress).tokenIdByTraits(pickedDoge);
957         
958         address hatcher = eggHatcher[requestId];
959         MoonDoge(dogeAddress).mint(hatcher, pickedDogeId, 1, "");
960         
961         requestFulfilled[requestId] = true;
962         
963     }
964     
965     function setActive(bool isActive) public onlyOwner {
966         active = isActive;
967     }
968     
969     function addAvailableDoges(bytes2[] memory doges, uint256[] memory amounts) public onlyOwner {
970         for (uint256 i = 0; i < doges.length; i++) {
971             for (uint256 j = 0; j < amounts[i]; j++) {
972                 availableDoges.push(doges[i]);
973             }
974         }
975     }
976     
977     function removeAvailableDoges(bool confirm) public onlyOwner {
978         require(confirm == true, "You need to confirm");
979         delete availableDoges;
980     }
981     
982     function withdrawCrackedEggs(address to) public onlyOwner {
983         uint256 amount = IERC1155(crackedEggAddress).balanceOf(address(this), crackedEggId);
984         IERC1155(crackedEggAddress).safeTransferFrom(address(this), to, crackedEggId, amount, "");
985     }
986     
987     function withdrawEther(address payable to, uint256 amount) public onlyOwner {
988         to.transfer(amount);
989     }
990 
991     function withdrawTokens(address token, address to, uint256 amount) public onlyOwner {
992         IERC20 token = IERC20(token);
993         token.transfer(to, amount);
994     }
995     
996     function onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) external override returns(bytes4) {
997         return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
998     }
999     
1000     function onERC1155BatchReceived(address operator, address from, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external override returns(bytes4) {
1001         return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"));
1002     }
1003     
1004     
1005     /// @dev Called by Chainlink VRF random number provider.
1006     function fulfillRandomness(bytes32 requestId, uint randomness) internal override {
1007         require(eggHatcher[requestId] != address(0), "The requestId is invalid.");
1008         require(requestFulfilled[requestId] == false, "This request is already fulfilled.");
1009         
1010         finishHatchingEgg(requestId, randomness);
1011     }
1012     
1013 }