1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/PledgeMint.sol": {
5       "content": "/// @notice Pledge Mint v1.2 contract by Culture Cubs\n// pledgemint.io\n//\n// For your ERC721 contract to be compatible, follow the following instructions:\n// - declare a variable for the pledgemint contract address:\n//   address public pledgeContractAddress;\n// - add the following function to allow Pledge Mint to mint NFT for your pledgers:\n//   function pledgeMint(address to, uint8 quantity) override\n//       external\n//       payable {\n//       require(pledgeContractAddress == msg.sender, \"The caller is not PledgeMint\");\n//       require(totalSupply() + quantity <= maxCollectionSize, \"reached max supply\");\n//       _mint(to, quantity);\n//   }\n//\n//    * Please ensure you test this method before deploying your contract.\n//    * PledgeMint will send the funds collected along with the mint call, minus the fee agreed upon.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./utils/Errors.sol\";\n\ninterface IERC721Pledge {\n    function pledgeMint(address to, uint8 quantity) external payable;\n}\n\ncontract PledgeMint is Ownable, ReentrancyGuard {\n    // Phases allow to have different cohorts of pledgers, with different contracts, prices and limits.\n    struct PhaseConfig {\n        address admin;\n        IERC721Pledge mintContract;\n        uint256 mintPrice;\n        uint8 maxPerWallet;\n        // When locked, the contract on which the mint happens cannot ever be changed again\n        bool mintContractLocked;\n        // Can only be set to true if mint contract is locked, which is irreversible.\n        // Owner of the contract can still trigger refunds - but not access anyone's funds.\n        bool pledgesLocked;\n        uint16 fee; // int representing the percentage with 2 digits. e.g. 1.75% -> 175\n        uint16 cap; // max number of NFTs to sell during this phase\n        uint256 startTime;\n        uint256 endTime;\n    }\n\n    // Mapping from phase Id to array of pledgers\n    mapping(uint16 => address[]) public pledgers;\n    // Mapping from phase Id to mapping from address to boolean allow value\n    mapping(uint16 => mapping(address => bool)) public allowlists;\n    // Mapping from phase Id to mapping from address to pladge number\n    mapping(uint16 => mapping(address => uint8)) public pledges;\n\n    uint256 public pledgeMintRevenue;\n\n    PhaseConfig[] public phases;\n\n    modifier callerIsUser() {\n        if (tx.origin != msg.sender) revert Errors.CallerIsContract();\n        _;\n    }\n\n    modifier onlyAdminOrOwner(uint16 phaseId) {\n        if (owner() != _msgSender() && phases[phaseId].admin != _msgSender())\n            revert Errors.CallerIsNotOwner();\n        _;\n    }\n\n    constructor() {}\n\n    function addPhase(\n        address admin,\n        IERC721Pledge mintContract,\n        uint256 mintPrice,\n        uint8 maxPerWallet,\n        uint16 fee,\n        uint16 cap,\n        uint startTime,\n        uint endTime\n    ) external onlyOwner {\n        phases.push(\n            PhaseConfig(\n                admin,\n                mintContract,\n                mintPrice,\n                maxPerWallet,\n                false,\n                false,\n                fee,\n                cap,\n                startTime,\n                endTime\n            )\n        );\n    }\n\n    function allowAddresses(uint16 phaseId, address[] calldata allowlist_)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        mapping(address => bool) storage _allowlist = allowlists[phaseId];\n        for (uint256 i; i < allowlist_.length; ) {\n            _allowlist[allowlist_[i]] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function pledgeWithCap(uint16 phaseId, uint8 number)\n        external\n        payable\n        callerIsUser\n    {\n        PhaseConfig memory phase = phases[phaseId];\n        if (block.timestamp < phase.startTime || phase.endTime > 0 && block.timestamp > phase.endTime) revert Errors.PhaseNotActive();\n        (uint256 nbPledged, ) = _nbNFTsPledge(phaseId);\n        if (phase.cap > 0 && nbPledged + number > phase.cap) revert Errors.OverPhaseCap();\n        if (number > phase.maxPerWallet) revert Errors.NFTAmountNotAllowed();\n        if (number < 1) revert Errors.AmountNeedsToBeGreaterThanZero();\n        if (msg.value != phase.mintPrice * number)\n            revert Errors.AmountMismatch();\n        if (pledges[phaseId][msg.sender] != 0) revert Errors.AlreadyPledged();\n        pledgers[phaseId].push(msg.sender);\n        pledges[phaseId][msg.sender] = number;\n    }\n\n    function pledge(uint16 phaseId, uint8 number)\n        external\n        payable\n        callerIsUser\n    {\n        PhaseConfig memory phase = phases[phaseId];\n        if (block.timestamp < phase.startTime || phase.endTime > 0 && block.timestamp > phase.endTime) revert Errors.PhaseNotActive();\n        if (number > phase.maxPerWallet) revert Errors.NFTAmountNotAllowed();\n        if (number < 1) revert Errors.AmountNeedsToBeGreaterThanZero();\n        if (msg.value != phase.mintPrice * number)\n            revert Errors.AmountMismatch();\n        if (pledges[phaseId][msg.sender] != 0) revert Errors.AlreadyPledged();\n        pledgers[phaseId].push(msg.sender);\n        pledges[phaseId][msg.sender] = number;\n    }\n\n    function unpledge(uint16 phaseId) external nonReentrant callerIsUser {\n        if (phases[phaseId].pledgesLocked == true)\n            revert Errors.PledgesAreLocked();\n\n        uint256 nbPledged = pledges[phaseId][msg.sender];\n        if (nbPledged < 1) revert Errors.NothingWasPledged();\n        pledges[phaseId][msg.sender] = 0;\n\n        (bool success, ) = msg.sender.call{\n            value: phases[phaseId].mintPrice * nbPledged\n        }(\"\");\n\n        if (!success) revert Errors.UnableToSendValue();\n    }\n\n    function lockPhase(uint16 phaseId) external onlyAdminOrOwner(phaseId) {\n        if (phases[phaseId].mintContractLocked == false)\n            revert Errors.CannotLockPledgeWithoutLockingMint();\n        phases[phaseId].pledgesLocked = true;\n    }\n\n    function unlockPhase(uint16 phaseId) external onlyAdminOrOwner(phaseId) {\n        phases[phaseId].pledgesLocked = false;\n    }\n\n    // mint for all participants\n    function mintPhase(uint16 phaseId) external onlyAdminOrOwner(phaseId) {\n        address[] memory _addresses = pledgers[phaseId];\n        _mintPhase(phaseId, _addresses, 0, _addresses.length, false);\n    }\n\n    // mint for all participants\n    function mintAllPledgesInPhase(uint16 phaseId)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        address[] memory _addresses = pledgers[phaseId];\n        _mintPhase(phaseId, _addresses, 0, _addresses.length, true);\n    }\n\n    // mint for all participants, paginated\n    function mintPhase(\n        uint16 phaseId,\n        uint256 startIdx,\n        uint256 length\n    ) external onlyAdminOrOwner(phaseId) {\n        address[] memory _addresses = pledgers[phaseId];\n        _mintPhase(phaseId, _addresses, startIdx, length, false);\n    }\n\n    // mint for select participants\n    // internal function checks eligibility and pledged number.\n    function mintPhase(uint16 phaseId, address[] calldata selectPledgers)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        _mintPhase(phaseId, selectPledgers, 0, selectPledgers.length, false);\n    }\n\n    function _mintPhase(\n        uint16 phaseId,\n        address[] memory addresses,\n        uint256 startIdx,\n        uint256 count,\n        bool allowAllMints\n    ) internal {\n        PhaseConfig memory _phase = phases[phaseId];\n        if (_phase.mintContractLocked == false)\n            revert Errors.CannotLaunchMintWithoutLockingContract();\n        mapping(address => uint8) storage _pledges = pledges[phaseId];\n        mapping(address => bool) storage _allowlist = allowlists[phaseId];\n        uint256 phaseRevenue;\n        for (uint256 i = startIdx; i < count; ) {\n            address addy = addresses[i];\n            uint8 quantity = _pledges[addy];\n\n            // Any address not allowed will have to withdraw their pledge manually. We skip them here.\n            if ((allowAllMints || _allowlist[addy]) && quantity > 0) {\n                _pledges[addy] = 0;\n                uint256 totalCost = _phase.mintPrice * quantity;\n                uint256 pmRevenue = (totalCost * _phase.fee) / 10000;\n                phaseRevenue += pmRevenue;\n                _phase.mintContract.pledgeMint{value: totalCost - pmRevenue}(\n                    addy,\n                    quantity\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        pledgeMintRevenue += phaseRevenue;\n    }\n\n    // These stats may decrease in case of refund or mint. They are not itended to archive states.\n    function currentPhaseStats(uint16 phaseId)\n        public\n        view\n        returns (\n            uint256 nbPledges,\n            uint256 nbNFTsPledged,\n            uint256 amountPledged,\n            uint256 nbAllowedPledges,\n            uint256 nbNAllowedFTsPledged,\n            uint256 allowedAmountPledged\n        )\n    {\n        PhaseConfig memory _phase = phases[phaseId];\n        mapping(address => uint8) storage _pledges = pledges[phaseId];\n        mapping(address => bool) storage _allowlist = allowlists[phaseId];\n        address[] storage _pledgers = pledgers[phaseId];\n        for (uint256 i; i < _pledgers.length; ) {\n            address addy = _pledgers[i];\n            uint8 quantity = _pledges[addy];\n            if (quantity > 0) {\n                nbPledges += 1;\n                nbNFTsPledged += quantity;\n                amountPledged += quantity * _phase.mintPrice;\n                if (_allowlist[addy]) {\n                    nbAllowedPledges += 1;\n                    nbNAllowedFTsPledged += quantity;\n                    allowedAmountPledged += quantity * _phase.mintPrice;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function refundPhase(uint16 phaseId)\n        external\n        onlyAdminOrOwner(phaseId)\n        nonReentrant\n    {\n        _refundPhase(phaseId);\n    }\n\n    function refundAll() external onlyOwner nonReentrant {\n        for (uint8 i; i < phases.length; ) {\n            _refundPhase(i);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function refundPhasePledger(uint16 phaseId, address pledger)\n        external\n        onlyAdminOrOwner(phaseId)\n        nonReentrant\n    {\n        uint256 amount = pledges[phaseId][pledger] * phases[phaseId].mintPrice;\n        pledges[phaseId][pledger] = 0;\n        (bool success, ) = pledger.call{value: amount}(\"\");\n        if (!success) revert Errors.UnableToSendValue();\n    }\n\n    function _refundPhase(uint16 phaseId) internal {\n        PhaseConfig memory _phase = phases[phaseId];\n        address[] storage _addresses = pledgers[phaseId];\n        for (uint8 i; i < _addresses.length; ) {\n            address addy = _addresses[i];\n            uint8 quantity = pledges[phaseId][addy];\n            if (quantity > 0) {\n                pledges[phaseId][addy] = 0;\n                (bool success, ) = addy.call{\n                    value: _phase.mintPrice * quantity\n                }(\"\");\n                if (!success) revert Errors.UnableToSendValue();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _nbNFTsPledge(uint16 phaseId)\n        internal\n        view\n        returns (\n            uint256 nbNFTsPledged,\n            uint256 nbNAllowedFTsPledged\n        )\n    {\n        mapping(address => uint8) storage _pledges = pledges[phaseId];\n        mapping(address => bool) storage _allowlist = allowlists[phaseId];\n        address[] storage _pledgers = pledgers[phaseId];\n        for (uint256 i; i < _pledgers.length; ) {\n            address addy = _pledgers[i];\n            uint8 quantity = _pledges[addy];\n            if (quantity > 0) {\n                nbNFTsPledged += quantity;\n                if (_allowlist[addy]) {\n                    nbNAllowedFTsPledged += quantity;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function emergencyRefund(\n        uint16 phaseId,\n        uint256 startIdx,\n        uint256 count\n    ) external onlyOwner {\n        PhaseConfig memory _phase = phases[phaseId];\n        for (uint256 i = startIdx; i < count; ) {\n            address addy = pledgers[phaseId][i];\n            uint8 quantity = pledges[phaseId][addy];\n\n            (bool success, ) = addy.call{value: _phase.mintPrice * quantity}(\n                \"\"\n            );\n            if (!success) revert Errors.UnableToSendValue();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function setMintContract(uint16 phaseId, IERC721Pledge mintContract_)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].mintContract = mintContract_;\n    }\n\n    function setFee(uint16 phaseId, uint16 fee)\n        external\n        onlyOwner\n    {\n        phases[phaseId].fee = fee;\n    }\n\n    function setStartTime(uint16 phaseId, uint256 startTime)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].startTime = startTime;   \n    }\n\n    function setEndTime(uint16 phaseId, uint256 endTime)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].endTime = endTime;   \n    }\n\n    function setPrice(uint16 phaseId, uint256 price)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].mintPrice = price;   \n    }\n\n    function setCap(uint16 phaseId, uint16 cap)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].cap = cap;   \n    }\n\n    function setAdmin(uint16 phaseId, address admin)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].admin = admin;\n    }\n\n    function setMaxPerWallet(uint16 phaseId, uint8 maxPerWallet)\n        external\n        onlyAdminOrOwner(phaseId)\n    {\n        phases[phaseId].maxPerWallet = maxPerWallet;   \n    }\n\n    function withdrawRevenue() \n        external\n        onlyOwner\n    {\n        (bool success, ) = msg.sender.call{value: pledgeMintRevenue}(\"\");\n        require(success, \"Transfer failed.\");\n        pledgeMintRevenue = 0;\n    }\n}"
6     },
7     "/contracts/utils/Errors.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4;\n\nlibrary Errors {\n    // PledgeMint.sol\n    error CallerIsContract();\n    error CallerIsNotOwner();\n    error NFTAmountNotAllowed();\n    error PhaseNotActive();\n    error OverPhaseCap();\n    error AmountNeedsToBeGreaterThanZero();\n    error AmountMismatch();\n    error AlreadyPledged();\n    error PledgesAreLocked();\n    error NothingWasPledged();\n    error UnableToSendValue();\n    error CannotLockPledgeWithoutLockingMint();\n    error CannotLaunchMintWithoutLockingContract();\n    error ContractCannotBeChanged();\n}\n"
9     },
10     "@openzeppelin/contracts/utils/Context.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/access/Ownable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
18     }
19   },
20   "settings": {
21     "remappings": [],
22     "optimizer": {
23       "enabled": false,
24       "runs": 200
25     },
26     "evmVersion": "london",
27     "libraries": {},
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   }
41 }}