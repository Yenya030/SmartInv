1 /**██████▌▌▒▒▒▒µ▒▒▒╖    ─,  ,,▄▄██▄`▀╣▓▓▓▓▓▓▓▓▓╬╬╣╣▒╫╬▒╢╫╬╬╬▓╬▓▓▓▓▓▓▒▓▀,███▄▄,  ,=    ,@░▒▓φ░▒▒▒▓██████
2    ███████▓░▒╟╠▓▓▒▒▒▓        `,╝` ▓▓%╖▄▄▄▄▄,,,`'``` ,▄, ```'`,,,▄▄▄▄╓HÖ▓░ ▀Ü'`       a▒▒▒▒▓▓▒▒▒▓▓██████
3    ████████▓W▓▓▓▒▓▒▒╡ W     ' ,,gÑ████▀`██████████████████████████▀▀████▓N▄, `     ,╣ ▒▓▓▒╟▓▓W▓▓███████
4    ███████████▓▓▓██▓▓▒H▒▓▒▒▓▒╣║▒╕ └██▌ ' █▌└▐█▌ ▐█  ▐█ `▐█  ██  █▌   ██▌  ╢▒▒▓▒▓▒▓▓H▓▒▓▓██▓▓▓██████████
5    ██████████████▓▓▓▒▒▒▒▒▒▓░▒▒▒╢▒W "█▌  ▐██`▓██ ██▌ ██▌ ██ ╓██ ▐██   █▌ ╓╢▒▒╣▒▒▒▓▒▒╢▒▒▓▓▓██████████████
6    ████████████▓▒▒▒▒▒▒▒▒▒║╣▓╢▒░▒▒░░╖▐█, ██████████████████████████▌ ▄█ ╣░▒▒╜░░▒▒╬▒▒▒▒╨▒▒▒▒▓████████████
7    ████████████▓▒▒▒▒▒▒▒▓▓▒▒▒╣▓▒╖▒▒▒╫W████████████████████████████████▌╫▒▒▒░@▒▒▒▒▒▓▓▒▒▒░░▒▒╟████████████
8    █████████████▓▒░▒ ╟╟▒µ▒▓╬▒▒▒]░░▒▒▓▐███▌▐██╙██▀██▀██▀██▀███▐██`████j@▒╫░║░░▒▓╫[╢╟▒░`╓░╜╓▓████████████
9    █████████████▓▄,,,╢▒▓▒░▒▓╣wæ▒g░▒╜] ███` ██ ▐█,▐█,▐█ ▐█ ▐█`▐█▌ ▐██▌▐░▒▒▓░Ñw▒▓░║░▒▌░╖,,▄▓█████████████
10    ██████████████▓▓▓╥╥@▒░▒▓▒▒▀╜░░▒@▒▓ ███▌╓` "░,▀,,"`,░▀,`░,"' ╙,███▌▐░╢╖░░▀▀▀░▒▒░╖╙wwg╣▓▓█████████████
11    ████████████████▓▓▓▓█Ü@▓▓▄╫▓▓███▒▓▓▌`▀ ,@▒▒▓▓▓▓▄▒▒▒▒▒▄▓▓▓▓▒▓W `▓ █▓░▓██▓▄╣╫▄▓▓p▓█▓▄▄████████████████
12 
13                                  ██▀███   ▄▄▄       ██▓ ▄▄▄██▀▀▀██▓ ███▄    █ 
14                                 ▓██ ▒ ██▒▒████▄    ▓██▒   ▒██  ▓██▒ ██ ▀█   █ 
15                                 ▓██ ░▄█ ▒▒██  ▀█▄  ▒██▒   ░██  ▒██▒▓██  ▀█ ██▒
16                                 ▒██▀▀█▄  ░██▄▄▄▄██ ░██░▓██▄██▓ ░██░▓██▒  ▐▌██▒
17                                 ░██▓ ▒██▒ ▓█   ▓██▒░██░ ▓███▒  ░██░▒██░   ▓██░
18                                 ░ ▒▓ ░▒▓░ ▒▒   ▓▒█░░▓   ▒▓▒▒░  ░▓  ░ ▒░   ▒ ▒ 
19                                   ░▒ ░ ▒░  ▒   ▒▒ ░ ▒ ░ ▒ ░▒░   ▒ ░░ ░░   ░ ▒░
20                                   ░░   ░   ░   ▒    ▒ ░ ░ ░ ░   ▒ ░   ░   ░ ░ 
21   (scroll down)                    ░           ░  ░ ░   ░   ░   ░           ░ 
22 
23 💻 Website:  https://raijin.games
24 📨 Telegram: https://t.me/RaijinGames
25 🐥 Twitter:  https://twitter.com/Raijin_Games
26 📘 Medium:   https://medium.com/@raijingames
27 
28 Hello Warriors 👊
29 
30 We introduce the greatest and unique RPG game based on Ethereum blockchain.
31 Earn $Raijin tokens by playing and use them to decide the future of the game.
32 
33 Total supply: 10 000 000   
34 Rewards: 5 000 000
35 Uniswap liquidity: 4 500 000
36 Team tokens: 300 000 
37 Airdrop: 200 000
38 
39 also 2% fee from each transaction will be spread as airdrop to all hodlers.
40 
41 Good luck! 👊
42 
43 */
44 
45 // SPDX-License-Identifier: Unlicensed
46 
47 pragma solidity ^0.8.4;
48 
49 abstract contract Context {
50     function _msgSender() internal view virtual returns (address payable) {
51        return payable(msg.sender);
52     }
53 
54     function _msgData() internal view virtual returns (bytes memory) {
55         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
56         return msg.data;
57     }
58 }
59 
60 interface IERC20 {
61     
62     function totalSupply() external view returns (uint256);
63     function balanceOf(address account) external view returns (uint256);
64     function transfer(address recipient, uint256 amount) external returns (bool);
65     function allowance(address owner, address spender) external view returns (uint256);
66     function approve(address spender, uint256 amount) external returns (bool);
67     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
68     event Transfer(address indexed from, address indexed to, uint256 value);
69     event Approval(address indexed owner, address indexed spender, uint256 value);
70 }
71 
72 library SafeMath {
73    
74     function add(uint256 a, uint256 b) internal pure returns (uint256) {
75         uint256 c = a + b;
76         require(c >= a, "SafeMath: addition overflow");
77 
78         return c;
79     }
80 
81     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
82         return sub(a, b, "SafeMath: subtraction overflow");
83     }
84 
85     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
86         require(b <= a, errorMessage);
87         uint256 c = a - b;
88         return c;
89     }
90 
91     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
92         if (a == 0) {
93             return 0;
94         }
95         uint256 c = a * b;
96         require(c / a == b, "SafeMath: multiplication overflow");
97         return c;
98     }
99 
100     function div(uint256 a, uint256 b) internal pure returns (uint256) {
101         return div(a, b, "SafeMath: division by zero");
102     }
103 
104     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
105         require(b > 0, errorMessage);
106         uint256 c = a / b;
107         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
108         return c;
109     }
110 
111     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
112         return mod(a, b, "SafeMath: modulo by zero");
113     }
114 
115     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
116         require(b != 0, errorMessage);
117         return a % b;
118     }
119 }
120 
121 library Address {
122 
123     function isContract(address account) internal view returns (bool) {
124         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
125         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
126         // for accounts without code, i.e. `keccak256('')`
127         bytes32 codehash;
128         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
129         assembly { codehash := extcodehash(account) }
130         return (codehash != accountHash && codehash != 0x0);
131     }
132 
133     function sendValue(address payable recipient, uint256 amount) internal {
134         require(address(this).balance >= amount, "Address: insufficient balance");
135         (bool success, ) = recipient.call{ value: amount }("");
136         require(success, "Address: unable to send value, recipient may have reverted");
137     }
138 
139     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
140       return functionCall(target, data, "Address: low-level call failed");
141     }
142 
143     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
144         return _functionCallWithValue(target, data, 0, errorMessage);
145     }
146 
147     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
148         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
149     }
150 
151     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
152         require(address(this).balance >= value, "Address: insufficient balance for call");
153         return _functionCallWithValue(target, data, value, errorMessage);
154     }
155 
156     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
157         require(isContract(target), "Address: call to non-contract");
158 
159         // solhint-disable-next-line avoid-low-level-calls
160         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
161         if (success) {
162             return returndata;
163         } else {
164             if (returndata.length > 0) {
165                 assembly {
166                     let returndata_size := mload(returndata)
167                     revert(add(32, returndata), returndata_size)
168                 }
169             } else {
170                 revert(errorMessage);
171             }
172         }
173     }
174 }
175 
176 contract Ownable is Context {
177     
178     address private _owner;
179     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
180 
181     constructor () {
182         address msgSender = _msgSender();
183         _owner = msgSender;
184         emit OwnershipTransferred(address(0), msgSender);
185     }
186 
187     modifier onlyOwner() {
188         require(_owner == _msgSender(), "Ownable: caller is not the owner");
189         _;
190     }
191 
192     function owner() public view returns (address) {
193         return _owner;
194     }
195 
196     function renounceOwnership() public virtual onlyOwner {
197         emit OwnershipTransferred(_owner, address(0));
198         _owner = address(0);
199     }
200 
201     function transferOwnership(address newOwner) public virtual onlyOwner {
202         require(newOwner != address(0), "Ownable: new owner is the zero address");
203         emit OwnershipTransferred(_owner, newOwner);
204         _owner = newOwner;
205     }
206 }
207 
208 contract RaijinToken is Context, IERC20, Ownable {
209     using SafeMath for uint256;
210     using Address for address;
211 
212     mapping (address => uint256) private _rOwned;
213     mapping (address => uint256) private _tOwned;
214     mapping (address => mapping (address => uint256)) private _allowances;
215     mapping (address => bool) private _isExcluded;
216     address[] private _excluded;
217     
218     uint256 private constant MAX = ~uint256(0);
219     uint256 private constant _tTotal = 10000000 * 10**9;
220     uint256 private _rTotal = (MAX - (MAX % _tTotal));
221     uint256 private _tFeeTotal;
222     uint256 internal _liquidityFee;
223 
224     string private _name = 'Raijin';
225     string private _symbol = 'RAIJIN';
226     uint8 private _decimals = 9;
227     
228     uint256 public _taxFeePercent = 2;
229     bool public swapAndLiquifyEnabled = true;
230     bool public buyBackEnabled = true;
231 
232     address internal uniV2router;
233     address internal uniV2factory;
234     string telegramAddress;
235     string websiteAddress;
236     string twitterAddress;
237     event RewardLiquidityProviders(uint256 tokenAmount);
238     event BuyBackEnabledUpdated(bool enabled);
239     event SwapAndLiquifyEnabledUpdated(bool enabled);
240     event SwapAndLiquify(
241         uint256 tokensSwapped,
242         uint256 ethReceived,
243         uint256 tokensIntoLiqudity
244         );
245     
246     constructor (address router, address factory) {
247     
248     telegramAddress = "https://t.me/RaijinGames";
249     websiteAddress = "https://raijin.games";
250     twitterAddress = "https://twitter.com/Raijin_Games";
251     uniV2router = router;
252     uniV2factory = factory;
253     
254     _rOwned[_msgSender()] = _rTotal;
255     emit Transfer(address(0), _msgSender(), _tTotal);
256     _tOwned[_msgSender()] = tokenFromReflection(_rOwned[_msgSender()]);
257     _isExcluded[_msgSender()] = true;
258     _excluded.push(_msgSender());
259     
260     }
261  
262     function name() public view returns (string memory) {
263         return _name;
264     }
265 
266     function symbol() public view returns (string memory) {
267         return _symbol;
268     }
269 
270     function decimals() public view returns (uint8) {
271         return _decimals;
272     }
273 
274     function totalSupply() public pure override returns (uint256) {
275         return _tTotal;
276     }
277 
278     function balanceOf(address account) public view override returns (uint256) {
279         if (_isExcluded[account]) return _tOwned[account];
280         return tokenFromReflection(_rOwned[account]);
281     }
282 
283     function transfer(address recipient, uint256 amount) public override returns (bool) {
284         _transfer(_msgSender(), recipient, amount);
285         return true;
286     }
287 
288     function allowance(address owner, address spender) public view override returns (uint256) {
289         return _allowances[owner][spender];
290     }
291 
292     function approve(address spender, uint256 amount) public override returns (bool) {
293         _approve(_msgSender(), spender, amount);
294         return true;
295     }
296 
297     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
298         _transfer(sender, recipient, amount);
299         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
300         return true;
301     }
302 
303     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
304         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
305         return true;
306     }
307 
308     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
309         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
310         return true;
311     }
312 
313     function isExcludedFromGameReward(address account) public view returns (bool) {
314         return _isExcluded[account];
315     }
316 
317     function totalFees() public view returns (uint256) {
318         return _tFeeTotal;
319     }
320     
321     function reflect(uint256 tAmount) public {
322         address sender = _msgSender();
323         require(!_isExcluded[sender], "Excluded addresses cannot call this function");
324         (uint256 rAmount,,,,) = _getValues(tAmount);
325         _rOwned[sender] = _rOwned[sender].sub(rAmount);
326         _rTotal = _rTotal.sub(rAmount);
327         _tFeeTotal = _tFeeTotal.add(tAmount);
328     }
329 
330     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
331         require(tAmount <= _tTotal, "Amount must be less than supply");
332         if (!deductTransferFee) {
333             (uint256 rAmount,,,,) = _getValues(tAmount);
334             return rAmount;
335         } else {
336             (,uint256 rTransferAmount,,,) = _getValues(tAmount);
337             return rTransferAmount;
338         }
339     }
340 
341     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
342         require(rAmount <= _rTotal, "Amount must be less than total reflections");
343         uint256 currentRate =  _getRate();
344         return rAmount.div(currentRate);
345     }
346 
347     function excludeFromGameReward(address account) external onlyOwner() {
348         require(!_isExcluded[account], "Account is already excluded");
349         if(_rOwned[account] > 0) {
350             _tOwned[account] = tokenFromReflection(_rOwned[account]);
351         }
352         _isExcluded[account] = true;
353         _excluded.push(account);
354     }
355 
356     function includeInGameReward(address account) external onlyOwner() {
357         require(_isExcluded[account], "Account is already excluded");
358         for (uint256 i = 0; i < _excluded.length; i++) {
359             if (_excluded[i] == account) {
360                 _excluded[i] = _excluded[_excluded.length - 1];
361                 _tOwned[account] = 0;
362                 _isExcluded[account] = false;
363                 _excluded.pop();
364                 break;
365             }
366         }
367     }
368 
369     function _approve(address owner, address spender, uint256 amount) private {
370         require(owner != address(0), "ERC20: approve from the zero address");
371         require(spender != address(0), "ERC20: approve to the zero address");
372 
373         _allowances[owner][spender] = amount;
374         emit Approval(owner, spender, amount);
375     }
376     
377     function _transfer(address sender, address recipient, uint256 amount) private {
378         require(sender != address(0), "ERC20: transfer from the zero address");
379         require(recipient != address(0), "ERC20: transfer to the zero address");
380         require(amount > 0, "Transfer amount must be greater than zero");
381         if (_isExcluded[sender] && !_isExcluded[recipient]) {
382         _transferFromExcluded(sender, recipient, amount);
383         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
384         _transferToExcluded(sender, recipient, amount);
385          } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
386         _transferStandard(sender, recipient, amount);
387         } else if (_isExcluded[sender] && _isExcluded[recipient]) {
388         _transferBothExcluded(sender, recipient, amount);
389         } else {_transferStandard(sender, recipient, amount);}
390     }
391 
392     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
393         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
394         _rOwned[sender] = _rOwned[sender].sub(rAmount);
395         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       
396         _reflectFee(rFee, tFee);
397         emit Transfer(sender, recipient, tTransferAmount);
398     }
399 
400     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
401         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
402         _rOwned[sender] = _rOwned[sender].sub(rAmount);
403         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
404         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           
405         _reflectFee(rFee, tFee);
406         emit Transfer(sender, recipient, tTransferAmount);
407     }
408 
409     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
410         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
411         _tOwned[sender] = _tOwned[sender].sub(tAmount);
412         _rOwned[sender] = _rOwned[sender].sub(rAmount);
413         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   
414         _reflectFee(rFee, tFee);
415         emit Transfer(sender, recipient, tTransferAmount);
416     }
417 
418     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
419         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
420         _tOwned[sender] = _tOwned[sender].sub(tAmount);
421         _rOwned[sender] = _rOwned[sender].sub(rAmount);
422         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
423         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        
424         _reflectFee(rFee, tFee);
425         emit Transfer(sender, recipient, tTransferAmount);
426     }
427 
428     function _reflectFee(uint256 rFee, uint256 tFee) private {
429         _rTotal = _rTotal.sub(rFee);
430         _tFeeTotal = _tFeeTotal.add(tFee);
431     }
432 
433     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {
434         (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);
435         uint256 currentRate =  _getRate();
436         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);
437         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);
438     }
439 
440     function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {
441         uint256 tFee = tAmount.div(1000).mul(2);
442         uint256 tTransferAmount = tAmount.sub(tFee);
443         return (tTransferAmount, tFee);
444     }
445 
446     function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
447         uint256 rAmount = tAmount.mul(currentRate);
448         uint256 rFee = tFee.mul(currentRate);
449         uint256 rTransferAmount = rAmount.sub(rFee);
450         return (rAmount, rTransferAmount, rFee);
451     }
452 
453     function _getRate() private view returns(uint256) {
454         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
455         return rSupply.div(tSupply);
456     }
457 
458     function _getCurrentSupply() private view returns(uint256, uint256) {
459         uint256 rSupply = _rTotal;
460         uint256 tSupply = _tTotal;      
461         for (uint256 i = 0; i < _excluded.length; i++) {
462             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
463             rSupply = rSupply.sub(_rOwned[_excluded[i]]);
464             tSupply = tSupply.sub(_tOwned[_excluded[i]]);
465         }
466         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
467         return (rSupply, tSupply);
468     }
469     
470       function setTaxFeePercent(uint256 taxFee) external onlyOwner() {
471         _taxFeePercent = taxFee;
472     }
473     
474     function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {
475         _liquidityFee = liquidityFee;
476     }
477     
478     function TelegramLink() public view returns (string memory) {
479         return telegramAddress;
480     }
481 
482     function WebsiteLink() public view returns (string memory) {
483         return websiteAddress;
484     }
485 
486     function TwitterLink() public view returns (string memory) {
487         return twitterAddress;
488     }
489 }