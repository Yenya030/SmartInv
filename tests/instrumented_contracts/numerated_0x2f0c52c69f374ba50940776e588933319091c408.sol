1 // SPDX-License-Identifier: UNLICENSED
2 
3 /* 
4 LFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFG
5                                                                                
6                                      %%.                                        
7                              ./.(&&&#*,/%&&&%,/..                               
8                     /%%%#(,,,,,,,,,,,,,,,,,,,,,,,,*%%%&%      .                 
9           *(&%&%&%&&%.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*#%%%&**,*(/%&&&#         
10        /&%/*,,,/%/,,&#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(&*.&%,,,,,,,,*&#       
11       %&/,,,,,,,*(&%*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(##,,,,,,,,,,(&,      
12       #&/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#&#      
13       #&/,,,,,,,,,,,,,,,,,&@@@*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#&/      
14       &&*,,,,,,,,,,,,,,,,/@@@@*,,,,,,,,,,,,,,,,,,,,,,,(@@@@&,,,,,,,,,,,#&/      
15       *&(,,,,,,,,,,,,,,,%@@@@@@@@@@@@@@(,%@@(.,,,,,,,,/@@@@@,,,,,,,,,,,*&(      
16       *%(,,,,,,,,,,,,,.@@@@@@@@@@@@@@@@.,,(@@@@%,,,,,,%@@@@*,,,,,,,,,,,(%*      
17       #&/,,,,,,,,,,,,(@@@@,.,,,,@@@@@.,,,,,,*@@@@@.,,&@@@@.,,,,,,,,,,,,/%,      
18       %%/,,,,,,,,,,/@@@@*,,,,,&@@@@@*,,,,,,,,,*@@/,&@@@@%,,,,,,,,,,,,,,/&,      
19       (%/,,,,,,,,,,,,,,*@@,&@@@@@@@,,,,,,,,,,,,,,,@@@@&,,,,,,,,,,,,,,,,*&/      
20       #&*,,,,,,,,,,,,(@@@@@@@@@@#.,,,,,,,,,,,,,/@@@@&,,,,,,,,,,,,,,,,,,/&(      
21       *#*,,,,,,,,,,,,%@@@@@@@@,,,,,,,,,,,,,,#@@@@@(,,,,,,,,,,,,,,,,,,,,*&/      
22       (&(,,,,,,,,,,,,,#@@@&,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*%/      
23       *%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/%(      
24       (%/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*&(      
25       (#*,,,,,,,,,,,,@@@@&,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,%(      
26       #&/,,,,,,,,,,,,/@@@%.,,/(((&@@@@&,,,,,,,,/(*,,,,,,,,,,,,,,,,,,,,,*&(      
27       #&/,,,,,,,,,,,,@@@@@@@@@@@@@@@@@@,,,*@@@@@@@@@@@@@@@.,,,,,,,,,,,,*#,      
28       #&*,,,,,,,,,,/@@@@@@@@*,,,,,,,,,,,,,,,,,,,,,@@%,,%@€/@@@(,,,,,,,,*&(      
29       (&*,,,,,,,.@@@@@@@@(@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@%,,,,,,,,*&/      
30       /&/,,,,,,,,,.%@@@%,,,,,,,*(@@@@/(#/,,./%%@@@@@&@@@(,,,,,,,,,,,,,,*&(      
31       %&/,,,,,,,,,&@#@@%,,,#@@/,,%@@@#,,,,@@@@@@@@@@@@@@@@#,,,,,,,,,,,,*%(      
32       /&/,,,,,,,,,,,,@@%,,(@@@@#,(@@@#,,,,*@@@@@&€/,,,,./%,,,,,,,,,,,,,*&(      
33       ,%/,,,,,,,,,,,,@@@*,,@@@@@@(@@@@,,,,,,/@@@@@@@@@@@@*,,,,,,,,,,,,,*&(      
34       %&/,,,,,,,,,,,%@@@/,,,&@@@@@@@@@,,,,,,,,,,,***€/*,,,,,,,,,,,,,,,,*&#      
35       (%/,,,,,,,,,,,,#@@*,,,,,@@@@@@@*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*&(      
36       /&*,,,,,,,,,,,,,,,,,,,,,,,./#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*&,      
37       #%/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,%(      
38       #%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@,,,,/@@@@@@*,,,,,,,,,,,,,,,,,,,*%(      
39       (&(,,,,,,,,,,,,,,,,,,,,,,.%&&@@@@@@@@@@@@@@@@&&&#,,,,,,,,,,,,,,,,,#(      
40       *#(,,,,,,,,,,,,,,,,,,,,,%@@@@%/%@@@@@@@@@@@@@@@@&,,,,,,,,,,,,,,,,*&#      
41       ,%,,,,,,,,,,,,,,,,,,,,,,(%@@@@@##@@(..,,,,,,,,,,,,,,,,,,,,,,,,,,,*%#      
42       %&(,,,,,,,,,,,,,,,,,,,,,,,,,,,@@@@@@@,,,,,,,,,,,,,,,,,,,,,,,,,,,,*%(      
43       #&*,,,,,,,,,,,,,,,,,,,,,,,,(@@@@@@@@@@&,,,,,,,,,,,,,,,,,,,,,,,,,,,#&,     
44       *&(,,,,,,,,,,,,,,,,,,,,,,,%@@@/.&@@(/@@@%,,,,,,,,,,,,,,,,,,,,,,,,*%#.     
45       (&(,,,,,,,,,,,,,,,,,,,,,,,&@@@@@@@%.,.@@@@%,,,,,,,,,,,,,,,,,,,,,,,##      
46       *&(,,,,,,,,,,,,,,,,,,,,,,,,#@%#*,,,,,,,.%@@/,,,,,,,,,,,,,,,,,,,,,,#%.     
47       *&/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#(      
48       ,&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,%%.     
49       /&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*%%.     
50       /#/,,,,,,,,,,,,,,..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(&,     
51       *&/,,,,,,,,,,,,,,@@.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,/#      
52       (&(,,,,,,,,,,,,,.@@.,,,,,,,,,,,,,,,,,,,,,,,%@*,,,,,,,,,,,,,,,,,,,,#%.     
53       *&/,,,,,,,,,,,,,&@@.,,,,,,,,,,,,,,,,,,,,,,,%@@,,,€/@@*,,,,,,,,,,,,##      
54       *&/,,,,,,,,,,,,,&@@.,,,,,,,,,(&(,,,,,,,,,,,%@@@@@@@@%,,,,,,,,,,,,,(&.     
55       *&(,,,,,,,,,,,,,&@@%,,,,,,,/@@@@,,,,,,,,.(%@@@%,,,,,,,,,,,,,,,,,,,##      
56       ,&(,,,,,,,,,,,,,(@@@**(%@@@@@@@/,,,,,.&@@@@@@@@@/.,,,,,,,,,,,,,,,,#&.     
57       *&(,,,,,,,,,,,,,,*@@@@@@@@@%/,,,,,,,,%@@@@@@@@&@@@@@@@/@,,,,,,,,,,(%.     
58       *%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.&@@@@@%,,,,,*&@@@@(,,,,,,,,,##      
59       /#/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(&.     
60       ,&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#&,     
61       *&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#&,     
62       /&(,,,,,,,,,,,,,,,,,,,,,,,,@@@@@@@@@/€/€/€,,,,,,,,,,,,,,,,,,,,,,,,(&.     
63       /%/,,,,,,,,,,,,,,,,,,,,,,,,.@@@@@@@@@@@@@@&,,,,,,,,,,,,,,,,,,,,,,,#&.     
64       *&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,@@,,,,,,,,,,,,,,,,,,,,,,,,#%.     
65       *&(,,,,,,,,,,,,,,,,,,,,,./&@@@@@@@@@@@@@@@#,,,,,,,,,,,,,,,,,,,,,,,(&.     
66       *&(,,,,,,,,,,,,,,,,,,,,,#@@&#(,,,,,,,.#@@@@/,,,,,,,,,,,,,,,,,,,,,,(&.     
67       ,%(,,,,,,,,,,,,,,,,,,,,,,,,,,./@,,,,/@@@@@&,,,,,,,,,,,,,,,,,,,,,,,(&.     
68       *&(,,,,,,,,,,,,,,,,,,,,,,,(@@@@#@@@@@@@@@/,,,,,,,,,,,,,,,,,,,,,,,,(&.     
69       *%(,,,,,,,,,,,,,,,,,,,,,,,@@@@@@@@@@@#*,,,,,,,,,,,,,,,,,,,,,,,,,,,((,     
70       *&(,,,,,,,,,,,,,,,,,,,,,,,,/@@&((,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,#%,     
71       *&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*%/     
72       *&/,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(&,     
73       *&(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(%*     
74       *&(,,,,,,,,(%%/,,#&/,,,,,,,,,,,,,,,,,,,,,,,,,,*#%&%**#%%%,,,,,,,,,*&*     
75       /&/,,,,,,*&#,,#%&#,,,,,,,,,,,,,,,,,,,,,,,,,,,*&#,,%%&&.,&%,,,,,,,,/%.     
76         /%&%#/@/@/@/@/@/@(&((%#,,,,,,,,,,,,,,,,,,,,,(#&%.%&(*.,,,,,,*#&@.      
77               /          ,./#&(&&&&%&%(%(%(&&&&&&&%%%/       //###%,#/.         
78                                                                                
79 LFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFGLFG
80 */
81 // File: @openzeppelin/contracts/utils/Strings.sol
82 
83 
84 // OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)
85 
86 pragma solidity ^0.8.0;
87 
88 /**
89  * @dev String operations.
90  */
91 library Strings {
92     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
93     uint8 private constant _ADDRESS_LENGTH = 20;
94 
95     /**
96      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
97      */
98     function toString(uint256 value) internal pure returns (string memory) {
99         // Inspired by OraclizeAPI's implementation - MIT licence
100         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
101 
102         if (value == 0) {
103             return "0";
104         }
105         uint256 temp = value;
106         uint256 digits;
107         while (temp != 0) {
108             digits++;
109             temp /= 10;
110         }
111         bytes memory buffer = new bytes(digits);
112         while (value != 0) {
113             digits -= 1;
114             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
115             value /= 10;
116         }
117         return string(buffer);
118     }
119 
120     /**
121      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
122      */
123     function toHexString(uint256 value) internal pure returns (string memory) {
124         if (value == 0) {
125             return "0x00";
126         }
127         uint256 temp = value;
128         uint256 length = 0;
129         while (temp != 0) {
130             length++;
131             temp >>= 8;
132         }
133         return toHexString(value, length);
134     }
135 
136     /**
137      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
138      */
139     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
140         bytes memory buffer = new bytes(2 * length + 2);
141         buffer[0] = "0";
142         buffer[1] = "x";
143         for (uint256 i = 2 * length + 1; i > 1; --i) {
144             buffer[i] = _HEX_SYMBOLS[value & 0xf];
145             value >>= 4;
146         }
147         require(value == 0, "Strings: hex length insufficient");
148         return string(buffer);
149     }
150 
151     /**
152      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
153      */
154     function toHexString(address addr) internal pure returns (string memory) {
155         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
156     }
157 }
158 
159 // File: @openzeppelin/contracts/utils/Context.sol
160 
161 
162 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
163 
164 pragma solidity ^0.8.0;
165 
166 /**
167  * @dev Provides information about the current execution context, including the
168  * sender of the transaction and its data. While these are generally available
169  * via msg.sender and msg.data, they should not be accessed in such a direct
170  * manner, since when dealing with meta-transactions the account sending and
171  * paying for execution may not be the actual sender (as far as an application
172  * is concerned).
173  *
174  * This contract is only required for intermediate, library-like contracts.
175  */
176 abstract contract Context {
177     function _msgSender() internal view virtual returns (address) {
178         return msg.sender;
179     }
180 
181     function _msgData() internal view virtual returns (bytes calldata) {
182         return msg.data;
183     }
184 }
185 
186 // File: @openzeppelin/contracts/access/Ownable.sol
187 
188 
189 // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
190 
191 pragma solidity ^0.8.0;
192 
193 
194 /**
195  * @dev Contract module which provides a basic access control mechanism, where
196  * there is an account (an owner) that can be granted exclusive access to
197  * specific functions.
198  *
199  * By default, the owner account will be the one that deploys the contract. This
200  * can later be changed with {transferOwnership}.
201  *
202  * This module is used through inheritance. It will make available the modifier
203  * `onlyOwner`, which can be applied to your functions to restrict their use to
204  * the owner.
205  */
206 abstract contract Ownable is Context {
207     address private _owner;
208 
209     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
210 
211     /**
212      * @dev Initializes the contract setting the deployer as the initial owner.
213      */
214     constructor() {
215         _transferOwnership(_msgSender());
216     }
217 
218     /**
219      * @dev Throws if called by any account other than the owner.
220      */
221     modifier onlyOwner() {
222         _checkOwner();
223         _;
224     }
225 
226     /**
227      * @dev Returns the address of the current owner.
228      */
229     function owner() public view virtual returns (address) {
230         return _owner;
231     }
232 
233     /**
234      * @dev Throws if the sender is not the owner.
235      */
236     function _checkOwner() internal view virtual {
237         require(owner() == _msgSender(), "Ownable: caller is not the owner");
238     }
239 
240     /**
241      * @dev Leaves the contract without owner. It will not be possible to call
242      * `onlyOwner` functions anymore. Can only be called by the current owner.
243      *
244      * NOTE: Renouncing ownership will leave the contract without an owner,
245      * thereby removing any functionality that is only available to the owner.
246      */
247     function renounceOwnership() public virtual onlyOwner {
248         _transferOwnership(address(0));
249     }
250 
251     /**
252      * @dev Transfers ownership of the contract to a new account (`newOwner`).
253      * Can only be called by the current owner.
254      */
255     function transferOwnership(address newOwner) public virtual onlyOwner {
256         require(newOwner != address(0), "Ownable: new owner is the zero address");
257         _transferOwnership(newOwner);
258     }
259 
260     /**
261      * @dev Transfers ownership of the contract to a new account (`newOwner`).
262      * Internal function without access restriction.
263      */
264     function _transferOwnership(address newOwner) internal virtual {
265         address oldOwner = _owner;
266         _owner = newOwner;
267         emit OwnershipTransferred(oldOwner, newOwner);
268     }
269 }
270 
271 // File: @openzeppelin/contracts/utils/Address.sol
272 
273 
274 // OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)
275 
276 pragma solidity ^0.8.1;
277 
278 /**
279  * @dev Collection of functions related to the address type
280  */
281 library Address {
282     /**
283      * @dev Returns true if `account` is a contract.
284      *
285      * [IMPORTANT]
286      * ====
287      * It is unsafe to assume that an address for which this function returns
288      * false is an externally-owned account (EOA) and not a contract.
289      *
290      * Among others, `isContract` will return false for the following
291      * types of addresses:
292      *
293      *  - an externally-owned account
294      *  - a contract in construction
295      *  - an address where a contract will be created
296      *  - an address where a contract lived, but was destroyed
297      * ====
298      *
299      * [IMPORTANT]
300      * ====
301      * You shouldn't rely on `isContract` to protect against flash loan attacks!
302      *
303      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
304      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
305      * constructor.
306      * ====
307      */
308     function isContract(address account) internal view returns (bool) {
309         // This method relies on extcodesize/address.code.length, which returns 0
310         // for contracts in construction, since the code is only stored at the end
311         // of the constructor execution.
312 
313         return account.code.length > 0;
314     }
315 
316     /**
317      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
318      * `recipient`, forwarding all available gas and reverting on errors.
319      *
320      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
321      * of certain opcodes, possibly making contracts go over the 2300 gas limit
322      * imposed by `transfer`, making them unable to receive funds via
323      * `transfer`. {sendValue} removes this limitation.
324      *
325      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
326      *
327      * IMPORTANT: because control is transferred to `recipient`, care must be
328      * taken to not create reentrancy vulnerabilities. Consider using
329      * {ReentrancyGuard} or the
330      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
331      */
332     function sendValue(address payable recipient, uint256 amount) internal {
333         require(address(this).balance >= amount, "Address: insufficient balance");
334 
335         (bool success, ) = recipient.call{value: amount}("");
336         require(success, "Address: unable to send value, recipient may have reverted");
337     }
338 
339     /**
340      * @dev Performs a Solidity function call using a low level `call`. A
341      * plain `call` is an unsafe replacement for a function call: use this
342      * function instead.
343      *
344      * If `target` reverts with a revert reason, it is bubbled up by this
345      * function (like regular Solidity function calls).
346      *
347      * Returns the raw returned data. To convert to the expected return value,
348      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
349      *
350      * Requirements:
351      *
352      * - `target` must be a contract.
353      * - calling `target` with `data` must not revert.
354      *
355      * _Available since v3.1._
356      */
357     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
358         return functionCall(target, data, "Address: low-level call failed");
359     }
360 
361     /**
362      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
363      * `errorMessage` as a fallback revert reason when `target` reverts.
364      *
365      * _Available since v3.1._
366      */
367     function functionCall(
368         address target,
369         bytes memory data,
370         string memory errorMessage
371     ) internal returns (bytes memory) {
372         return functionCallWithValue(target, data, 0, errorMessage);
373     }
374 
375     /**
376      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
377      * but also transferring `value` wei to `target`.
378      *
379      * Requirements:
380      *
381      * - the calling contract must have an ETH balance of at least `value`.
382      * - the called Solidity function must be `payable`.
383      *
384      * _Available since v3.1._
385      */
386     function functionCallWithValue(
387         address target,
388         bytes memory data,
389         uint256 value
390     ) internal returns (bytes memory) {
391         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
392     }
393 
394     /**
395      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
396      * with `errorMessage` as a fallback revert reason when `target` reverts.
397      *
398      * _Available since v3.1._
399      */
400     function functionCallWithValue(
401         address target,
402         bytes memory data,
403         uint256 value,
404         string memory errorMessage
405     ) internal returns (bytes memory) {
406         require(address(this).balance >= value, "Address: insufficient balance for call");
407         require(isContract(target), "Address: call to non-contract");
408 
409         (bool success, bytes memory returndata) = target.call{value: value}(data);
410         return verifyCallResult(success, returndata, errorMessage);
411     }
412 
413     /**
414      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
415      * but performing a static call.
416      *
417      * _Available since v3.3._
418      */
419     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
420         return functionStaticCall(target, data, "Address: low-level static call failed");
421     }
422 
423     /**
424      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
425      * but performing a static call.
426      *
427      * _Available since v3.3._
428      */
429     function functionStaticCall(
430         address target,
431         bytes memory data,
432         string memory errorMessage
433     ) internal view returns (bytes memory) {
434         require(isContract(target), "Address: static call to non-contract");
435 
436         (bool success, bytes memory returndata) = target.staticcall(data);
437         return verifyCallResult(success, returndata, errorMessage);
438     }
439 
440     /**
441      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
442      * but performing a delegate call.
443      *
444      * _Available since v3.4._
445      */
446     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
447         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
448     }
449 
450     /**
451      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
452      * but performing a delegate call.
453      *
454      * _Available since v3.4._
455      */
456     function functionDelegateCall(
457         address target,
458         bytes memory data,
459         string memory errorMessage
460     ) internal returns (bytes memory) {
461         require(isContract(target), "Address: delegate call to non-contract");
462 
463         (bool success, bytes memory returndata) = target.delegatecall(data);
464         return verifyCallResult(success, returndata, errorMessage);
465     }
466 
467     /**
468      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
469      * revert reason using the provided one.
470      *
471      * _Available since v4.3._
472      */
473     function verifyCallResult(
474         bool success,
475         bytes memory returndata,
476         string memory errorMessage
477     ) internal pure returns (bytes memory) {
478         if (success) {
479             return returndata;
480         } else {
481             // Look for revert reason and bubble it up if present
482             if (returndata.length > 0) {
483                 // The easiest way to bubble the revert reason is using memory via assembly
484                 /// @solidity memory-safe-assembly
485                 assembly {
486                     let returndata_size := mload(returndata)
487                     revert(add(32, returndata), returndata_size)
488                 }
489             } else {
490                 revert(errorMessage);
491             }
492         }
493     }
494 }
495 
496 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
497 
498 
499 // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
500 
501 pragma solidity ^0.8.0;
502 
503 /**
504  * @title ERC721 token receiver interface
505  * @dev Interface for any contract that wants to support safeTransfers
506  * from ERC721 asset contracts.
507  */
508 interface IERC721Receiver {
509     /**
510      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
511      * by `operator` from `from`, this function is called.
512      *
513      * It must return its Solidity selector to confirm the token transfer.
514      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
515      *
516      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
517      */
518     function onERC721Received(
519         address operator,
520         address from,
521         uint256 tokenId,
522         bytes calldata data
523     ) external returns (bytes4);
524 }
525 
526 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
527 
528 
529 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
530 
531 pragma solidity ^0.8.0;
532 
533 /**
534  * @dev Interface of the ERC165 standard, as defined in the
535  * https://eips.ethereum.org/EIPS/eip-165[EIP].
536  *
537  * Implementers can declare support of contract interfaces, which can then be
538  * queried by others ({ERC165Checker}).
539  *
540  * For an implementation, see {ERC165}.
541  */
542 interface IERC165 {
543     /**
544      * @dev Returns true if this contract implements the interface defined by
545      * `interfaceId`. See the corresponding
546      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
547      * to learn more about how these ids are created.
548      *
549      * This function call must use less than 30 000 gas.
550      */
551     function supportsInterface(bytes4 interfaceId) external view returns (bool);
552 }
553 
554 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
555 
556 
557 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
558 
559 pragma solidity ^0.8.0;
560 
561 
562 /**
563  * @dev Implementation of the {IERC165} interface.
564  *
565  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
566  * for the additional interface id that will be supported. For example:
567  *
568  * ```solidity
569  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
570  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
571  * }
572  * ```
573  *
574  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
575  */
576 abstract contract ERC165 is IERC165 {
577     /**
578      * @dev See {IERC165-supportsInterface}.
579      */
580     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
581         return interfaceId == type(IERC165).interfaceId;
582     }
583 }
584 
585 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
586 
587 
588 // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)
589 
590 pragma solidity ^0.8.0;
591 
592 
593 /**
594  * @dev Required interface of an ERC721 compliant contract.
595  */
596 interface IERC721 is IERC165 {
597     /**
598      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
599      */
600     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
601 
602     /**
603      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
604      */
605     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
606 
607     /**
608      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
609      */
610     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
611 
612     /**
613      * @dev Returns the number of tokens in ``owner``'s account.
614      */
615     function balanceOf(address owner) external view returns (uint256 balance);
616 
617     /**
618      * @dev Returns the owner of the `tokenId` token.
619      *
620      * Requirements:
621      *
622      * - `tokenId` must exist.
623      */
624     function ownerOf(uint256 tokenId) external view returns (address owner);
625 
626     /**
627      * @dev Safely transfers `tokenId` token from `from` to `to`.
628      *
629      * Requirements:
630      *
631      * - `from` cannot be the zero address.
632      * - `to` cannot be the zero address.
633      * - `tokenId` token must exist and be owned by `from`.
634      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
635      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
636      *
637      * Emits a {Transfer} event.
638      */
639     function safeTransferFrom(
640         address from,
641         address to,
642         uint256 tokenId,
643         bytes calldata data
644     ) external;
645 
646     /**
647      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
648      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
649      *
650      * Requirements:
651      *
652      * - `from` cannot be the zero address.
653      * - `to` cannot be the zero address.
654      * - `tokenId` token must exist and be owned by `from`.
655      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
656      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
657      *
658      * Emits a {Transfer} event.
659      */
660     function safeTransferFrom(
661         address from,
662         address to,
663         uint256 tokenId
664     ) external;
665 
666     /**
667      * @dev Transfers `tokenId` token from `from` to `to`.
668      *
669      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
670      *
671      * Requirements:
672      *
673      * - `from` cannot be the zero address.
674      * - `to` cannot be the zero address.
675      * - `tokenId` token must be owned by `from`.
676      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
677      *
678      * Emits a {Transfer} event.
679      */
680     function transferFrom(
681         address from,
682         address to,
683         uint256 tokenId
684     ) external;
685 
686     /**
687      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
688      * The approval is cleared when the token is transferred.
689      *
690      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
691      *
692      * Requirements:
693      *
694      * - The caller must own the token or be an approved operator.
695      * - `tokenId` must exist.
696      *
697      * Emits an {Approval} event.
698      */
699     function approve(address to, uint256 tokenId) external;
700 
701     /**
702      * @dev Approve or remove `operator` as an operator for the caller.
703      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
704      *
705      * Requirements:
706      *
707      * - The `operator` cannot be the caller.
708      *
709      * Emits an {ApprovalForAll} event.
710      */
711     function setApprovalForAll(address operator, bool _approved) external;
712 
713     /**
714      * @dev Returns the account approved for `tokenId` token.
715      *
716      * Requirements:
717      *
718      * - `tokenId` must exist.
719      */
720     function getApproved(uint256 tokenId) external view returns (address operator);
721 
722     /**
723      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
724      *
725      * See {setApprovalForAll}
726      */
727     function isApprovedForAll(address owner, address operator) external view returns (bool);
728 }
729 
730 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
731 
732 
733 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
734 
735 pragma solidity ^0.8.0;
736 
737 
738 /**
739  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
740  * @dev See https://eips.ethereum.org/EIPS/eip-721
741  */
742 interface IERC721Metadata is IERC721 {
743     /**
744      * @dev Returns the token collection name.
745      */
746     function name() external view returns (string memory);
747 
748     /**
749      * @dev Returns the token collection symbol.
750      */
751     function symbol() external view returns (string memory);
752 
753     /**
754      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
755      */
756     function tokenURI(uint256 tokenId) external view returns (string memory);
757 }
758 
759 // File: @openzeppelin/contracts/token/ERC721/ERC721.sol
760 
761 
762 // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)
763 
764 pragma solidity ^0.8.0;
765 
766 
767 
768 
769 
770 
771 
772 
773 /**
774  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
775  * the Metadata extension, but not including the Enumerable extension, which is available separately as
776  * {ERC721Enumerable}.
777  */
778 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
779     using Address for address;
780     using Strings for uint256;
781 
782     // Token name
783     string private _name;
784 
785     // Token symbol
786     string private _symbol;
787 
788     // Mapping from token ID to owner address
789     mapping(uint256 => address) private _owners;
790 
791     // Mapping owner address to token count
792     mapping(address => uint256) private _balances;
793 
794     // Mapping from token ID to approved address
795     mapping(uint256 => address) private _tokenApprovals;
796 
797     // Mapping from owner to operator approvals
798     mapping(address => mapping(address => bool)) private _operatorApprovals;
799 
800     /**
801      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
802      */
803     constructor(string memory name_, string memory symbol_) {
804         _name = name_;
805         _symbol = symbol_;
806     }
807 
808     /**
809      * @dev See {IERC165-supportsInterface}.
810      */
811     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
812         return
813             interfaceId == type(IERC721).interfaceId ||
814             interfaceId == type(IERC721Metadata).interfaceId ||
815             super.supportsInterface(interfaceId);
816     }
817 
818     /**
819      * @dev See {IERC721-balanceOf}.
820      */
821     function balanceOf(address owner) public view virtual override returns (uint256) {
822         require(owner != address(0), "ERC721: address zero is not a valid owner");
823         return _balances[owner];
824     }
825 
826     /**
827      * @dev See {IERC721-ownerOf}.
828      */
829     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
830         address owner = _owners[tokenId];
831         require(owner != address(0), "ERC721: invalid token ID");
832         return owner;
833     }
834 
835     /**
836      * @dev See {IERC721Metadata-name}.
837      */
838     function name() public view virtual override returns (string memory) {
839         return _name;
840     }
841 
842     /**
843      * @dev See {IERC721Metadata-symbol}.
844      */
845     function symbol() public view virtual override returns (string memory) {
846         return _symbol;
847     }
848 
849     /**
850      * @dev See {IERC721Metadata-tokenURI}.
851      */
852     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
853         _requireMinted(tokenId);
854 
855         string memory baseURI = _baseURI();
856         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
857     }
858 
859     /**
860      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
861      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
862      * by default, can be overridden in child contracts.
863      */
864     function _baseURI() internal view virtual returns (string memory) {
865         return "";
866     }
867 
868     /**
869      * @dev See {IERC721-approve}.
870      */
871     function approve(address to, uint256 tokenId) public virtual override {
872         address owner = ERC721.ownerOf(tokenId);
873         require(to != owner, "ERC721: approval to current owner");
874 
875         require(
876             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
877             "ERC721: approve caller is not token owner nor approved for all"
878         );
879 
880         _approve(to, tokenId);
881     }
882 
883     /**
884      * @dev See {IERC721-getApproved}.
885      */
886     function getApproved(uint256 tokenId) public view virtual override returns (address) {
887         _requireMinted(tokenId);
888 
889         return _tokenApprovals[tokenId];
890     }
891 
892     /**
893      * @dev See {IERC721-setApprovalForAll}.
894      */
895     function setApprovalForAll(address operator, bool approved) public virtual override {
896         _setApprovalForAll(_msgSender(), operator, approved);
897     }
898 
899     /**
900      * @dev See {IERC721-isApprovedForAll}.
901      */
902     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
903         return _operatorApprovals[owner][operator];
904     }
905 
906     /**
907      * @dev See {IERC721-transferFrom}.
908      */
909     function transferFrom(
910         address from,
911         address to,
912         uint256 tokenId
913     ) public virtual override {
914         //solhint-disable-next-line max-line-length
915         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
916 
917         _transfer(from, to, tokenId);
918     }
919 
920     /**
921      * @dev See {IERC721-safeTransferFrom}.
922      */
923     function safeTransferFrom(
924         address from,
925         address to,
926         uint256 tokenId
927     ) public virtual override {
928         safeTransferFrom(from, to, tokenId, "");
929     }
930 
931     /**
932      * @dev See {IERC721-safeTransferFrom}.
933      */
934     function safeTransferFrom(
935         address from,
936         address to,
937         uint256 tokenId,
938         bytes memory data
939     ) public virtual override {
940         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
941         _safeTransfer(from, to, tokenId, data);
942     }
943 
944     /**
945      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
946      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
947      *
948      * `data` is additional data, it has no specified format and it is sent in call to `to`.
949      *
950      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
951      * implement alternative mechanisms to perform token transfer, such as signature-based.
952      *
953      * Requirements:
954      *
955      * - `from` cannot be the zero address.
956      * - `to` cannot be the zero address.
957      * - `tokenId` token must exist and be owned by `from`.
958      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
959      *
960      * Emits a {Transfer} event.
961      */
962     function _safeTransfer(
963         address from,
964         address to,
965         uint256 tokenId,
966         bytes memory data
967     ) internal virtual {
968         _transfer(from, to, tokenId);
969         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
970     }
971 
972     /**
973      * @dev Returns whether `tokenId` exists.
974      *
975      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
976      *
977      * Tokens start existing when they are minted (`_mint`),
978      * and stop existing when they are burned (`_burn`).
979      */
980     function _exists(uint256 tokenId) internal view virtual returns (bool) {
981         return _owners[tokenId] != address(0);
982     }
983 
984     /**
985      * @dev Returns whether `spender` is allowed to manage `tokenId`.
986      *
987      * Requirements:
988      *
989      * - `tokenId` must exist.
990      */
991     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
992         address owner = ERC721.ownerOf(tokenId);
993         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
994     }
995 
996     /**
997      * @dev Safely mints `tokenId` and transfers it to `to`.
998      *
999      * Requirements:
1000      *
1001      * - `tokenId` must not exist.
1002      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1003      *
1004      * Emits a {Transfer} event.
1005      */
1006     function _safeMint(address to, uint256 tokenId) internal virtual {
1007         _safeMint(to, tokenId, "");
1008     }
1009 
1010     /**
1011      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1012      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1013      */
1014     function _safeMint(
1015         address to,
1016         uint256 tokenId,
1017         bytes memory data
1018     ) internal virtual {
1019         _mint(to, tokenId);
1020         require(
1021             _checkOnERC721Received(address(0), to, tokenId, data),
1022             "ERC721: transfer to non ERC721Receiver implementer"
1023         );
1024     }
1025 
1026     /**
1027      * @dev Mints `tokenId` and transfers it to `to`.
1028      *
1029      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1030      *
1031      * Requirements:
1032      *
1033      * - `tokenId` must not exist.
1034      * - `to` cannot be the zero address.
1035      *
1036      * Emits a {Transfer} event.
1037      */
1038     function _mint(address to, uint256 tokenId) internal virtual {
1039         require(to != address(0), "ERC721: mint to the zero address");
1040         require(!_exists(tokenId), "ERC721: token already minted");
1041 
1042         _beforeTokenTransfer(address(0), to, tokenId);
1043 
1044         _balances[to] += 1;
1045         _owners[tokenId] = to;
1046 
1047         emit Transfer(address(0), to, tokenId);
1048 
1049         _afterTokenTransfer(address(0), to, tokenId);
1050     }
1051 
1052     /**
1053      * @dev Destroys `tokenId`.
1054      * The approval is cleared when the token is burned.
1055      *
1056      * Requirements:
1057      *
1058      * - `tokenId` must exist.
1059      *
1060      * Emits a {Transfer} event.
1061      */
1062     function _burn(uint256 tokenId) internal virtual {
1063         address owner = ERC721.ownerOf(tokenId);
1064 
1065         _beforeTokenTransfer(owner, address(0), tokenId);
1066 
1067         // Clear approvals
1068         _approve(address(0), tokenId);
1069 
1070         _balances[owner] -= 1;
1071         delete _owners[tokenId];
1072 
1073         emit Transfer(owner, address(0), tokenId);
1074 
1075         _afterTokenTransfer(owner, address(0), tokenId);
1076     }
1077 
1078     /**
1079      * @dev Transfers `tokenId` from `from` to `to`.
1080      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1081      *
1082      * Requirements:
1083      *
1084      * - `to` cannot be the zero address.
1085      * - `tokenId` token must be owned by `from`.
1086      *
1087      * Emits a {Transfer} event.
1088      */
1089     function _transfer(
1090         address from,
1091         address to,
1092         uint256 tokenId
1093     ) internal virtual {
1094         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
1095         require(to != address(0), "ERC721: transfer to the zero address");
1096 
1097         _beforeTokenTransfer(from, to, tokenId);
1098 
1099         // Clear approvals from the previous owner
1100         _approve(address(0), tokenId);
1101 
1102         _balances[from] -= 1;
1103         _balances[to] += 1;
1104         _owners[tokenId] = to;
1105 
1106         emit Transfer(from, to, tokenId);
1107 
1108         _afterTokenTransfer(from, to, tokenId);
1109     }
1110 
1111     /**
1112      * @dev Approve `to` to operate on `tokenId`
1113      *
1114      * Emits an {Approval} event.
1115      */
1116     function _approve(address to, uint256 tokenId) internal virtual {
1117         _tokenApprovals[tokenId] = to;
1118         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1119     }
1120 
1121     /**
1122      * @dev Approve `operator` to operate on all of `owner` tokens
1123      *
1124      * Emits an {ApprovalForAll} event.
1125      */
1126     function _setApprovalForAll(
1127         address owner,
1128         address operator,
1129         bool approved
1130     ) internal virtual {
1131         require(owner != operator, "ERC721: approve to caller");
1132         _operatorApprovals[owner][operator] = approved;
1133         emit ApprovalForAll(owner, operator, approved);
1134     }
1135 
1136     /**
1137      * @dev Reverts if the `tokenId` has not been minted yet.
1138      */
1139     function _requireMinted(uint256 tokenId) internal view virtual {
1140         require(_exists(tokenId), "ERC721: invalid token ID");
1141     }
1142 
1143     /**
1144      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1145      * The call is not executed if the target address is not a contract.
1146      *
1147      * @param from address representing the previous owner of the given token ID
1148      * @param to target address that will receive the tokens
1149      * @param tokenId uint256 ID of the token to be transferred
1150      * @param data bytes optional data to send along with the call
1151      * @return bool whether the call correctly returned the expected magic value
1152      */
1153     function _checkOnERC721Received(
1154         address from,
1155         address to,
1156         uint256 tokenId,
1157         bytes memory data
1158     ) private returns (bool) {
1159         if (to.isContract()) {
1160             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
1161                 return retval == IERC721Receiver.onERC721Received.selector;
1162             } catch (bytes memory reason) {
1163                 if (reason.length == 0) {
1164                     revert("ERC721: transfer to non ERC721Receiver implementer");
1165                 } else {
1166                     /// @solidity memory-safe-assembly
1167                     assembly {
1168                         revert(add(32, reason), mload(reason))
1169                     }
1170                 }
1171             }
1172         } else {
1173             return true;
1174         }
1175     }
1176 
1177     /**
1178      * @dev Hook that is called before any token transfer. This includes minting
1179      * and burning.
1180      *
1181      * Calling conditions:
1182      *
1183      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1184      * transferred to `to`.
1185      * - When `from` is zero, `tokenId` will be minted for `to`.
1186      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1187      * - `from` and `to` are never both zero.
1188      *
1189      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1190      */
1191     function _beforeTokenTransfer(
1192         address from,
1193         address to,
1194         uint256 tokenId
1195     ) internal virtual {}
1196 
1197     /**
1198      * @dev Hook that is called after any transfer of tokens. This includes
1199      * minting and burning.
1200      *
1201      * Calling conditions:
1202      *
1203      * - when `from` and `to` are both non-zero.
1204      * - `from` and `to` are never both zero.
1205      *
1206      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1207      */
1208     function _afterTokenTransfer(
1209         address from,
1210         address to,
1211         uint256 tokenId
1212     ) internal virtual {}
1213 }
1214 
1215 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol
1216 
1217 
1218 // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)
1219 
1220 pragma solidity ^0.8.0;
1221 
1222 
1223 /**
1224  * @dev ERC721 token with storage based token URI management.
1225  */
1226 abstract contract ERC721URIStorage is ERC721 {
1227     using Strings for uint256;
1228 
1229     // Optional mapping for token URIs
1230     mapping(uint256 => string) private _tokenURIs;
1231 
1232     /**
1233      * @dev See {IERC721Metadata-tokenURI}.
1234      */
1235     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1236         _requireMinted(tokenId);
1237 
1238         string memory _tokenURI = _tokenURIs[tokenId];
1239         string memory base = _baseURI();
1240 
1241         // If there is no base URI, return the token URI.
1242         if (bytes(base).length == 0) {
1243             return _tokenURI;
1244         }
1245         // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
1246         if (bytes(_tokenURI).length > 0) {
1247             return string(abi.encodePacked(base, _tokenURI));
1248         }
1249 
1250         return super.tokenURI(tokenId);
1251     }
1252 
1253     /**
1254      * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
1255      *
1256      * Requirements:
1257      *
1258      * - `tokenId` must exist.
1259      */
1260     function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
1261         require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
1262         _tokenURIs[tokenId] = _tokenURI;
1263     }
1264 
1265     /**
1266      * @dev See {ERC721-_burn}. This override additionally checks to see if a
1267      * token-specific URI was set for the token, and if so, it deletes the token URI from
1268      * the storage mapping.
1269      */
1270     function _burn(uint256 tokenId) internal virtual override {
1271         super._burn(tokenId);
1272 
1273         if (bytes(_tokenURIs[tokenId]).length != 0) {
1274             delete _tokenURIs[tokenId];
1275         }
1276     }
1277 }
1278 
1279 // File: @openzeppelin/contracts/utils/Counters.sol
1280 
1281 
1282 // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
1283 
1284 pragma solidity ^0.8.0;
1285 
1286 /**
1287  * @title Counters
1288  * @author Matt Condon (@shrugs)
1289  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
1290  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
1291  *
1292  * Include with `using Counters for Counters.Counter;`
1293  */
1294 library Counters {
1295     struct Counter {
1296         // This variable should never be directly accessed by users of the library: interactions must be restricted to
1297         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
1298         // this feature: see https://github.com/ethereum/solidity/issues/4637
1299         uint256 _value; // default: 0
1300     }
1301 
1302     function current(Counter storage counter) internal view returns (uint256) {
1303         return counter._value;
1304     }
1305 
1306     function increment(Counter storage counter) internal {
1307         unchecked {
1308             counter._value += 1;
1309         }
1310     }
1311 
1312     function decrement(Counter storage counter) internal {
1313         uint256 value = counter._value;
1314         require(value > 0, "Counter: decrement overflow");
1315         unchecked {
1316             counter._value = value - 1;
1317         }
1318     }
1319 
1320     function reset(Counter storage counter) internal {
1321         counter._value = 0;
1322     }
1323 }
1324 
1325 // File: contracts/Market.sol
1326 
1327 
1328 pragma solidity ^0.8.4;
1329 
1330 
1331 
1332 
1333 
1334 interface IP {
1335     function totalSupply() external view returns (uint);
1336     function balanceOf(address account) external view returns (uint);
1337     function transfer(address recipient, uint amount) external returns (bool);
1338     function allowance(address owner, address spender) external view returns (uint);
1339     function approve(address spender, uint amount) external returns (bool);
1340     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
1341     event Transfer(address indexed from, address indexed to, uint value);
1342     event Approval(address indexed owner, address indexed spender, uint value);
1343 }
1344 
1345 contract IERC20NFTMintMarketplace is ERC721URIStorage, Ownable {
1346 
1347 
1348     using Counters for Counters.Counter;
1349 
1350     Counters.Counter private _Ids;
1351     Counters.Counter private _iSold;
1352     Counters.Counter private _mIds;
1353 
1354     // mika contract
1355     address public PTA; // payment Token Address done
1356     uint256 public minMintablePerSubmission = 1; //done
1357     uint256 public maxMintablePerSubmission = 1000; //done
1358     uint256 public maxMintablePerTX = 8; //done
1359     uint256 public listingPrice = 21000000 ether; //done
1360     uint public maxMintableDays = 15; //done
1361     // lowest percentage to mint to user
1362     uint public mintToUserPercentagePoint = 500; //done
1363     uint public mintToUserMaxCount = 10; //done
1364 
1365     uint inBids;
1366     uint public platformFees = 500; // done
1367     uint public platformFeesAftermarket = 150; //done
1368     uint public burnPercentagePoints = 6500;  // done
1369     uint public burnPercentagePointsMint = 1000;  // done
1370     uint256 fees;
1371     uint256 feesCollected;
1372     bool paused = false; // done
1373 
1374     mapping(uint256 => MI) m;
1375 
1376     mapping(uint256 => Offer[]) idOM; // idToOfferMint
1377 
1378     mapping(uint256 => Offer[]) idOT; //idToOffToken
1379 
1380     mapping(uint256 => MItem) idM; //idToMarketitem
1381 
1382     struct MI { // mintableItem
1383       address payable creator;
1384       uint256 mintPrice;
1385       uint256 close;
1386       uint256 max;
1387       string tokenURI; //arweave Hash
1388       uint supply;
1389       uint accrued;
1390       uint collected;
1391       uint id;
1392       bool approved;
1393       uint artistMints;
1394     }
1395 
1396 
1397 
1398     struct MItem { // Market Item
1399       uint256 tokenId;
1400       uint256 mintId;
1401       address payable seller;
1402       address payable owner;
1403       address payable creator;
1404       uint256 price;
1405       bool sold;
1406     }
1407     struct MItemO { // mintableItem
1408       MItem item;
1409       Offer[] oM;
1410       Offer[] oT;
1411     }
1412 
1413 
1414     struct Offer {
1415      address from;
1416      uint bid;
1417     }
1418 
1419 
1420 
1421     constructor(  address cAddress) ERC721("Seeing Red", "CNRED") {
1422       PTA = cAddress;
1423     }
1424 
1425     function ceil(uint a, uint mo) pure public returns (uint ) {
1426        return ((a + mo - 1) / mo) * mo;
1427    }
1428 
1429     function updateListingPrice(uint _price) public payable onlyOwner {
1430 
1431       listingPrice = _price;
1432     }
1433 
1434     function updateMaxMintsPerTX(uint _max) public payable onlyOwner {
1435 
1436       maxMintablePerTX = _max;
1437     }
1438     function updateMaxMintableDays(uint _max) public payable onlyOwner {
1439 
1440       maxMintableDays = _max;
1441     }
1442 
1443     function updateMintToUserMaxCount(uint _max) public payable onlyOwner {
1444 
1445       mintToUserMaxCount = _max;
1446     }
1447 
1448 
1449     function updateMaxMintablePerSubmission(uint _max) public payable onlyOwner {
1450 
1451       maxMintablePerSubmission = _max;
1452     }
1453 
1454     function updateMinMintablePerSubmission(uint _min) public payable onlyOwner {
1455 
1456       minMintablePerSubmission = _min;
1457     }
1458 
1459 
1460     function updatePlatFees(uint _fee) public payable onlyOwner {
1461 
1462       platformFees = _fee;
1463     }
1464 
1465     function updatePlatFeesAftermarket(uint _fee) public payable onlyOwner {
1466       platformFeesAftermarket = _fee;
1467     }
1468 
1469     function updatePaused(bool _p) public payable onlyOwner {
1470 
1471       paused = _p;
1472     }
1473 
1474     function updatePaymentToken(address _new) public payable onlyOwner {
1475 
1476       PTA = _new;
1477     }
1478 
1479 
1480     function updateMintToUserPoints(uint _min) public payable  onlyOwner {
1481       mintToUserPercentagePoint = _min;
1482     }
1483 
1484     function updateBurnPercentagePoints(uint _burnPoints) public payable  onlyOwner {
1485       burnPercentagePoints = _burnPoints;
1486     }
1487 
1488     function updateBurnPercentagePointsMint(uint _burnPointsM) public payable  onlyOwner {
1489       burnPercentagePointsMint = _burnPointsM;
1490     }
1491 
1492     function getListingPrice() public view returns (uint256) {
1493       return listingPrice;
1494     }
1495 
1496 
1497      function updateArweaveHash(uint id, string memory _hash) public onlyOwner(){
1498        uint iCT = _Ids.current();
1499        m[id].tokenURI = _hash;
1500 
1501        for (uint i=1; i <= iCT; i++) {
1502          if(idM[i].mintId == id){
1503            _setTokenURI(i, string(abi.encodePacked('https://arweave.net/',m[id].tokenURI)));
1504          }
1505        }
1506      }
1507 
1508      function offerOnMintId(uint id, uint bid) public payable{
1509 
1510        require(m[id].id == id,"id match");
1511        require(m[id].approved,'approved');
1512 
1513        require(bid>0,"0 bid");
1514        // is user approved allowance(address owner, address spender)
1515        require(IP(PTA).allowance(msg.sender, address(this)) >= bid, "allowance");
1516        // does user have enough balance?
1517        require(IP(PTA).balanceOf(msg.sender)>= bid,"bid");
1518 
1519        bool has = false;
1520        for (uint i; i < idOM[id].length ; i++) {
1521          if(idOM[id][i].from == msg.sender){
1522            idOM[id][i].bid = bid;
1523            has = true;
1524          }
1525        }
1526        if(!has){
1527           idOM[id].push(Offer(msg.sender, bid));
1528        }
1529 
1530        require(IP(PTA).transferFrom(msg.sender, address(this),bid),"transfer");
1531 
1532        inBids += bid;
1533 
1534 
1535      }
1536      function getFees() public view onlyOwner returns (uint256) {
1537        return fees;
1538      }
1539 
1540      function offerOnTokenId(uint id, uint bid) public payable{
1541 
1542        require(_exists(id),"exist");
1543 
1544        require(bid>0,"bid");
1545        // is user approved allowance(address owner, address spender)
1546        require(IP(PTA).allowance(msg.sender, address(this)) >= bid, "allowance");
1547        // does user have enough balance?
1548        require(IP(PTA).balanceOf(msg.sender)>= bid,"balance");
1549 
1550        bool has;
1551        for (uint i; i < idOT[id].length ; i++) {
1552          if(idOT[id][i].from == msg.sender){
1553            idOT[id][i].bid = bid;
1554            has = true;
1555          }
1556        }
1557        if(!has){
1558           idOT[id].push(Offer(msg.sender, bid));
1559        }
1560 
1561        require(IP(PTA).transferFrom(msg.sender, address(this),bid),"transfer");
1562 
1563        inBids += bid;
1564      }
1565 
1566      function cancelOfferOnMintId(uint id) public payable{
1567        uint removalIndex;
1568        bool has;
1569        for (uint i ; i < idOM[id].length ; i++) {
1570          if(idOM[id][i].from == msg.sender){
1571 
1572            require(IP(PTA).approve(address(this), idOM[id][i].bid), "approve");
1573            // transfer
1574            require(IP(PTA).transfer(msg.sender,  idOM[id][i].bid), "funds");
1575 
1576            inBids -= idOM[id][i].bid;
1577            idOM[id][i].bid = 0;
1578            has = true;
1579            removalIndex = i;
1580          }
1581        }
1582        if(has){
1583          removeMOffer(id,removalIndex);
1584        }
1585      }
1586 
1587      function removeMOffer(uint id, uint index) private{
1588       idOM[id][index] = idOM[id][idOM[id].length-1];
1589       idOM[id].pop();
1590     }
1591 
1592     function cancelOfferTokenId(uint id) public payable{
1593       uint removalIndex;
1594       bool has;
1595       for (uint i; i < idOT[id].length ; i++) {
1596         if(idOT[id][i].from == msg.sender){
1597 
1598           require(IP(PTA).approve(address(this), idOT[id][i].bid), "funds");
1599           // transfer
1600           require(IP(PTA).transfer(msg.sender,  idOT[id][i].bid), "funds");
1601 
1602           inBids -= idOT[id][i].bid;
1603           idOT[id][i].bid = 0;
1604           has = true;
1605           removalIndex = i;
1606         }
1607       }
1608       if(has){
1609         removeTOffer(id,removalIndex);
1610       }
1611     }
1612 
1613     function removeTOffer(uint id, uint index) private{
1614      idOT[id][index] = idOT[id][idOT[id].length-1];
1615      idOT[id].pop();
1616    }
1617 
1618    function acceptOffer(uint tId, uint mId, uint bid, address from, bool isTokenBuy) public payable {
1619       // owns tokenid // can only sell a token you own or have for sale.
1620       require(idM[tId].owner == msg.sender || idM[tId].seller == msg.sender, "owns");
1621 
1622       require(isTokenBuy ? true:idM[tId].mintId == mId, "mintId");
1623 
1624       Offer[] memory offers = isTokenBuy ? idOT[tId]:idOM[mId];
1625 
1626       bool hasBid;
1627       uint oI;
1628       for (uint i; i < offers.length ; i++) {
1629           if(offers[i].bid == bid && offers[i].from == from){
1630             hasBid = true;
1631             oI = i;
1632           }
1633         }
1634       require(hasBid,"no matching offer");
1635 
1636       // transer and set values
1637       if(!idM[tId].sold){
1638         _iSold.increment();
1639         idM[tId].sold = true;
1640       }
1641        if(idM[tId].owner == msg.sender){
1642          _transfer(msg.sender, from, tId);
1643        } else {
1644          _transfer(address(this), from, tId);
1645        }
1646 
1647 
1648        idM[tId].owner = payable(from);
1649        idM[tId].seller = payable(address(0));
1650        idM[tId].price = 0;
1651 
1652        inBids -= offers[oI].bid;
1653 
1654        uint platFees = (offers[oI].bid*platformFeesAftermarket)/10000;
1655        fees += platFees;
1656        uint256 toSeller = (offers[oI].bid-platFees);
1657 
1658         //take payment from contract and send from 'from' to 'msg.sender'
1659         require(IP(PTA).approve(address(this), toSeller));
1660         // transfer
1661         require(IP(PTA).transfer(msg.sender,  toSeller));
1662 
1663         isTokenBuy ? removeTOffer(tId,oI) : removeMOffer(mId,oI);
1664    }
1665 
1666 
1667     function createMintable(uint256 price, uint256 close, uint256 max, string memory tokenURI) public {
1668       require(!paused, "paused.");
1669       require(maxMintablePerSubmission>=max,"many");
1670       require(minMintablePerSubmission<=max,"low");
1671       require(close> (block.timestamp + (1 * 1 days)), "short");
1672       require(close<= (block.timestamp + (maxMintableDays * 1 days)), "long");
1673       // is user approved allowance(address owner, address spender)
1674       require(IP(PTA).allowance(msg.sender, address(this)) >= listingPrice,"NA");
1675       // does user have enough balance?
1676       require(IP(PTA).balanceOf(msg.sender)>= listingPrice,"balance");
1677 
1678 
1679       require(price > 0, "price");
1680 
1681       // Deal with fees....
1682       uint burn = (listingPrice*burnPercentagePoints)/10000;
1683       fees += (listingPrice-burn);
1684 
1685       require(IP(PTA).transferFrom(msg.sender, address(this),listingPrice),"Send");
1686       require(IP(PTA).transfer(0x000000000000000000000000000000000000dEaD, burn),"Burn");
1687 
1688       uint256 mId = _mIds.current();
1689 
1690       //figure out how many to mint user here.
1691       uint uM = ceil((max*mintToUserPercentagePoint)/10000,1);
1692       if(uM > mintToUserMaxCount){
1693         uM = mintToUserMaxCount;
1694       }
1695       m[mId] = MI(payable(msg.sender),price,close,max,tokenURI,0,0,0,mId, false, uM);
1696 
1697       _mIds.increment();
1698 
1699     }
1700 
1701 
1702     function artistMint(uint mId, uint count) public payable {
1703       require(!paused, "paused");
1704       require(msg.sender == m[mId].creator,"creator");
1705       require(m[mId].artistMints >= count,"avail");
1706 
1707       uint256 cMId = _mIds.current();
1708       require(mId<cMId,'ID');
1709       require(m[mId].approved == true,'NA');
1710       require(m[mId].supply+count<=m[mId].max, "many");
1711       require(m[mId].close>block.timestamp,"closed");
1712 
1713       inMint(mId, count);
1714       m[mId].artistMints = m[mId].artistMints - count;
1715       return;
1716     }
1717 
1718 
1719     function mint(uint mId, uint count) public payable {
1720       require(!paused, "paused");
1721       uint256 cMId = _mIds.current();
1722       require(mId<cMId,'id');
1723 
1724       require(m[mId].approved,'NA');
1725       require(m[mId].supply+count<=m[mId].max, "avail");
1726       require(m[mId].close>block.timestamp,"active");
1727 
1728       // is user approved  allowance(address owner, address spender)
1729       uint price = m[mId].mintPrice*count;
1730       require(IP(PTA).allowance(msg.sender, address(this)) >= price,"NA");
1731 
1732       uint burn = (price*burnPercentagePointsMint)/10000;
1733       uint platFees = (price*platformFees)/10000;
1734 
1735       // pay for mint and burn burnable
1736       require(IP(PTA).transferFrom(msg.sender, address(this),price),"send");
1737       require(IP(PTA).transfer(0x000000000000000000000000000000000000dEaD, burn),"burn");
1738 
1739       m[mId].accrued += (price-burn)-platFees;
1740       fees += platFees;
1741 
1742       inMint(mId, count);
1743 
1744       return;
1745     }
1746 
1747     function inMint(uint mId, uint count) private  {
1748       for (uint i; i < count; i++) {
1749         _iSold.increment();
1750         _Ids.increment();
1751         m[mId].supply ++;
1752 
1753         uint256 tId = _Ids.current();
1754 
1755         idM[tId] = MItem(tId,m[mId].id,payable(address(0)), payable(msg.sender),m[mId].creator,0,true);
1756 
1757         _mint(msg.sender, tId);
1758         _setTokenURI(tId, string(abi.encodePacked('https://arweave.net/',m[mId].tokenURI)));
1759 
1760       }
1761       return;
1762     }
1763 
1764     function approveMintable(uint mId, bool approved) public payable onlyOwner{
1765         m[mId].approved = approved;
1766     }
1767 
1768     function sellToken(uint256 tId, uint256 price) public payable {
1769       require(idM[tId].owner == msg.sender, "owns");
1770       require(price > 0, "price");
1771       idM[tId].sold = false;
1772       idM[tId].price = price;
1773       idM[tId].seller = payable(msg.sender);
1774       idM[tId].owner = payable(address(this));
1775       _iSold.decrement();
1776       _transfer(msg.sender, address(this), tId);
1777     }
1778 
1779     function buyToken(uint256 tId) public payable {
1780       uint price = idM[tId].price;
1781 
1782       // verify its for sale.
1783       require(idM[tId].sold ==false,"sold");
1784       // check its in our escrow...
1785       require(ownerOf(tId)>= address(this),"escrow");
1786 
1787       // does user have enough balance?
1788       require(IP(PTA).balanceOf(msg.sender)>= (price),"balance");
1789 
1790       // is user approved  allowance(address owner, address spender)
1791       require(IP(PTA).allowance(msg.sender, address(this)) >= (price),"NA");
1792 
1793 
1794       uint platFees = (price*platformFeesAftermarket)/10000;
1795 
1796       fees += platFees;
1797 
1798       uint256 toSeller = (price-platFees);
1799 
1800       require(IP(PTA).transferFrom(msg.sender, address(this),platFees),"fees");
1801       require(IP(PTA).transferFrom(msg.sender, address(idM[tId].seller),toSeller),"payment");
1802 
1803 
1804 
1805        idM[tId].owner = payable(msg.sender);
1806        idM[tId].sold = true;
1807        idM[tId].seller = payable(address(0));
1808        idM[tId].price = 0;
1809 
1810        _iSold.increment();
1811        _transfer(address(this), msg.sender, tId);
1812 
1813     }
1814 
1815 
1816     function cancelListing(uint256 tId) public payable {
1817 
1818       require(idM[tId].seller == msg.sender, "owner");
1819 
1820        idM[tId].owner = payable(msg.sender);
1821        idM[tId].sold = true;
1822        idM[tId].price = 0;
1823        idM[tId].seller = payable(address(0));
1824        _iSold.increment();
1825       _transfer(address(this), msg.sender, tId);
1826 
1827     }
1828 
1829     function fetchMintables(bool approved) public view returns (MI[] memory) {
1830       uint itemCount = _mIds.current();
1831 
1832       uint vMs;
1833 
1834       for (uint i; i < itemCount; i++) {
1835         bool p = approved ? m[i].approved:true;
1836         if(m[i].close > block.timestamp && p){
1837           vMs++;
1838         }
1839       }
1840 
1841       uint cI;
1842 
1843       MI[] memory it = new MI[](vMs);
1844 
1845       for (uint i; i <= itemCount; i++) {
1846         bool p = approved ? m[i].approved:true;
1847         if(m[i].close > block.timestamp && p){
1848 
1849           uint cID = i;
1850 
1851           MI storage cItem = m[cID];
1852 
1853           it[cI] = cItem;
1854 
1855           cI += 1;
1856 
1857         }
1858       }
1859 
1860       return it;
1861     }
1862 
1863 
1864     function fetchMyMintables(address mOwner) public view returns (MI[] memory) {
1865       uint iC = _mIds.current();
1866 
1867       uint vMs;
1868 
1869       for (uint i; i < iC + 1; i++) {
1870         if(m[i].creator == mOwner){
1871           vMs++;
1872         }
1873       }
1874 
1875       uint cI;
1876 
1877       MI[] memory it = new MI[](vMs);
1878 
1879       for (uint i; i < iC; i++) {
1880         if(m[i].creator == mOwner){
1881 
1882           uint cID = i;
1883 
1884           MI storage cItem = m[cID];
1885 
1886           it[cI] = cItem;
1887 
1888           cI += 1;
1889 
1890         }
1891       }
1892 
1893       return it;
1894     }
1895 
1896 
1897 
1898     function marketItems() public view returns (  MItemO[] memory) {
1899       uint iC = _Ids.current();
1900       uint cSold = _iSold.current();
1901       uint x = (_Ids.current() - cSold);
1902       uint cI;
1903       MItemO[] memory it = new MItemO[](x);
1904 
1905       if((_Ids.current() - cSold) == 0){
1906         return it;
1907       }
1908       for (uint i; i < iC; i++) {
1909 
1910         if (idM[i+1].owner == address(this)) {
1911 
1912           uint cID = i + 1;
1913 
1914           MItem storage cItem = idM[cID];
1915           it[cI] = MItemO(cItem,idOM[idM[cID].mintId],idOT[cID]);
1916 
1917           cI += 1;
1918         }
1919       }
1920 
1921       return it;
1922     }
1923 
1924     function myCollection(address user) public view returns (MItemO[] memory) {
1925       uint tIC = _Ids.current();
1926       uint iC;
1927       uint cI;
1928 
1929       for (uint i; i < tIC; i++) {
1930         // check if nft is mine
1931         if (idM[i+1].owner == user || idM[i+1].seller == user) {
1932           iC += 1;
1933         }
1934       }
1935 
1936       MItemO[] memory it = new MItemO[](iC);
1937       for (uint i; i < tIC; i++) {
1938 
1939         if (idM[i+1].owner == user || idM[i+1].seller == user) {
1940           uint cID = i+1;
1941           MItem storage cItem = idM[cID];
1942           it[cI] = MItemO(cItem,idOM[idM[cID].mintId],idOT[cID]);
1943           cI += 1;
1944         }
1945       }
1946       return it;
1947     }
1948     function getMarketItem(uint id) public view returns (MItemO memory){
1949       return MItemO(idM[id],idOM[idM[id].mintId],idOT[id]);
1950     }
1951     function listings() public view returns (MItemO[] memory) {
1952       uint tIC = _Ids.current();
1953       uint iC;
1954       uint cI;
1955 
1956       for (uint i; i < tIC; i++) {
1957         if (idM[i + 1].seller == msg.sender) {
1958           iC++;
1959         }
1960       }
1961 
1962       MItemO[] memory it = new MItemO[](iC);
1963       for (uint i; i < tIC; i++) {
1964         if (idM[i + 1].seller == msg.sender) {
1965           uint cID = i + 1;
1966           MItem storage cItem = idM[cID];
1967           it[cI] = MItemO(cItem,idOM[idM[cID].mintId],idOT[cID]);
1968           cI ++;
1969         }
1970       }
1971 
1972       return it;
1973     }
1974 
1975     function withdrawMikaForToken(uint id) external payable {
1976       require(m[id].creator == msg.sender,"creator");
1977       // approve move
1978       require(IP(PTA).approve(address(this), m[id].accrued));
1979       // transfer
1980       require(IP(PTA).transfer(msg.sender,  m[id].accrued));
1981 
1982       m[id].collected += m[id].accrued;
1983       m[id].accrued = 0;
1984     }
1985 
1986     function withdraw() external payable onlyOwner{
1987       // approve move
1988       require(IP(PTA).approve(address(this), fees));
1989       // transfer
1990       require(IP(PTA).transfer(msg.sender,  fees));
1991       // collected fees, so reset fees collectable.
1992       feesCollected += fees;
1993       fees = 0;
1994       payable(msg.sender).transfer(address(this).balance);
1995     }
1996 
1997     function _beforeTokenTransfer(address from, address to, uint256 tokenId) override internal {
1998           super._beforeTokenTransfer(from, to, tokenId);
1999           if(!(from == address(0) || ((to == address(this) && (from == idM[tokenId].seller||from == idM[tokenId].owner ))||(from == address(this) && (to == idM[tokenId].seller||to == idM[tokenId].owner )) ))) {
2000             if(idM[tokenId].sold == false){
2001               _iSold.increment();
2002               idM[tokenId].sold = true;
2003             }
2004             idM[tokenId].owner = payable(address(to));
2005             idM[tokenId].seller = payable(address(0));
2006             idM[tokenId].price = 0;
2007           }
2008     }
2009 
2010 }