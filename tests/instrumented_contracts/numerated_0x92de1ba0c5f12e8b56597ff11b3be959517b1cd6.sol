1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/PerpetualFutures.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport './interfaces/IERC20Decimals.sol';\nimport './interfaces/IFeeReducer.sol';\nimport './interfaces/IBokkyPooBahsDateTime.sol';\nimport './IndexHandler.sol';\nimport './pfYDF.sol';\n\ncontract PerpetualFutures is IndexHandler, KeeperCompatibleInterface, Ownable {\n  uint256 constant PERC_DEN = 100000;\n\n  pfYDF perpsNft;\n  IFeeReducer feeReducer;\n  IBokkyPooBahsDateTime timeLibrary =\n    IBokkyPooBahsDateTime(0x23d23d8F243e57d0b924bff3A3191078Af325101);\n\n  bool public enabled = true;\n\n  mapping(address => bool) public settlers;\n  uint8 maxLiquidationsPerUpkeep = 25;\n\n  address public mainCollateralToken =\n    0x30dcBa0405004cF124045793E1933C798Af9E66a;\n  mapping(address => bool) _validColl;\n  address[] _allCollTokens;\n  mapping(address => uint256) _allCollTokensInd;\n\n  uint16 public maxLeverage = 500; // 50x\n  uint8 public maxTriggerOrders = 2;\n  uint256 public minOpenTimeForProfit = 3 hours;\n  uint256 public minPriceDiffForProfit = (PERC_DEN * 15) / 1000; // 1.5%\n  uint256 public openFeePositionSize = (PERC_DEN * 1) / 1000; // 0.1%\n  uint256 public closeFeePositionSize = (PERC_DEN * 1) / 1000; // 0.1%\n  uint256 public closeFeePerDurationUnit = 1 hours;\n  uint256 public closeFeePerDuration = (PERC_DEN * 5) / 100000; // 0.005% / hour\n  uint256 public totalFees;\n  uint256 public totalAmountProfit;\n  uint256 public totalAmountLoss;\n\n  // collateral token => amount\n  mapping(address => uint256) public amtOpenLong;\n  mapping(address => uint256) public amtOpenShort;\n  mapping(address => uint256) public maxCollateralOpenDiff;\n\n  struct PositionIndexFeed {\n    IndexFeed feed;\n    uint16 phaseIdStart;\n    uint80 roundIdStart;\n    uint16 phaseIdSettle;\n    uint80 roundIdSettle;\n  }\n\n  struct TriggerOrder {\n    uint256 idxPriceCurrent;\n    uint256 idxPriceTarget;\n  }\n\n  struct PositionLifecycle {\n    uint256 openTime;\n    uint256 openFees;\n    uint256 closeTime;\n    uint256 closeFees;\n    uint256 settleCollPriceUSD; // For positions with alternate collateral, USD per collateral token extended to 18 decimals\n    uint256 settleMainPriceUSD; // For positions with alternate collateral, USD per main token extended to 18 decimals\n  }\n\n  struct Position {\n    PositionIndexFeed[] feeds;\n    PositionLifecycle lifecycle;\n    address collateralToken;\n    uint256 collateralCloseUnsettled;\n    uint256 collateralAmount;\n    uint256 positionAmount;\n    bool isLong;\n    uint16 leverage;\n    uint256 indexPriceStart;\n    uint256 indexPriceSettle;\n    uint256 amountWon;\n    uint256 amountLost;\n    bool isSettled;\n  }\n\n  // tokenId => Position\n  mapping(uint256 => Position) public positions;\n  // tokenId => address\n  mapping(uint256 => address) public positionOpeners;\n  // tokenId => address\n  mapping(uint256 => address) public positionClosers;\n  // tokenId => orders\n  mapping(uint256 => TriggerOrder[]) public positionTriggerOrders;\n  // tokenId[]\n  uint256[] public allOpenPositions;\n  // tokenId => allOpenPositions index\n  mapping(uint256 => uint256) internal _openPositionsIdx;\n  // tokenId[]\n  uint256[] public allUnsettledPositions;\n  // tokenId => allUnsettledPositions index\n  mapping(uint256 => uint256) internal _unsettledPositionsIdx;\n\n  event CloseUnsettledPosition(uint256 indexed tokenId);\n  event OpenPosition(\n    uint256 indexed tokenId,\n    address indexed user,\n    uint256 indexPriceStart,\n    uint256 positionCollateral,\n    bool isLong,\n    uint256 leverage\n  );\n  event ClosePosition(\n    uint256 indexed tokenId,\n    address indexed user,\n    uint256 indexPriceStart,\n    uint256 indexPriceSettle,\n    uint256 amountWon,\n    uint256 amountLost\n  );\n  event LiquidatePosition(uint256 tokenId);\n  event ClosePositionFromTriggerOrder(uint256 tokenId);\n  event SettlePosition(\n    uint256 tokenId,\n    uint256 mainTokenSettleAmt,\n    uint256 collSettlePrice,\n    uint256 mainSettlePrice\n  );\n\n  modifier onlyPositionOwner(uint256 _tokenId) {\n    require(msg.sender == perpsNft.ownerOf(_tokenId), 'must own position');\n    _;\n  }\n\n  modifier onlySettler() {\n    require(settlers[msg.sender], 'only settlers');\n    _;\n  }\n\n  constructor(string memory _tokenURI) {\n    perpsNft = new pfYDF(_tokenURI);\n    perpsNft.transferOwnership(msg.sender);\n  }\n\n  function getPerpsNFT() external view returns (address) {\n    return address(perpsNft);\n  }\n\n  function getAllIndexes() external view returns (Index[] memory) {\n    return indexes;\n  }\n\n  function getAllValidCollateralTokens()\n    external\n    view\n    returns (address[] memory)\n  {\n    return _allCollTokens;\n  }\n\n  function getAllUnsettledPositions() external view returns (uint256[] memory) {\n    return allUnsettledPositions;\n  }\n\n  function getAllPositionTriggerOrders(uint256 _tokenId)\n    external\n    view\n    returns (TriggerOrder[] memory)\n  {\n    return positionTriggerOrders[_tokenId];\n  }\n\n  function openPosition(\n    address _collToken,\n    uint256 _indexInd,\n    uint256 _collateral,\n    uint16 _leverage, // 10 == 1x, 1000 == 100x\n    bool _isLong,\n    uint256 _triggerOrderTargetPrice\n  ) external {\n    require(enabled, 'DISABLED');\n    require(_indexInd < indexes.length, 'INVIDX');\n    require(_leverage >= 10 && _leverage <= maxLeverage, 'LEV1');\n    require(canOpenPositionAgainstIndex(_indexInd, 0), 'INDOOB1');\n    require(\n      _collToken == address(0) ||\n        _collToken == mainCollateralToken ||\n        _validColl[_collToken],\n      'POSTOKEN1'\n    );\n\n    IERC20 _collCont = _collToken == address(0)\n      ? IERC20(mainCollateralToken)\n      : IERC20(_collToken);\n    require(_collCont.balanceOf(msg.sender) >= _collateral, 'BAL1');\n\n    uint256 _newTokenId = perpsNft.mint(msg.sender);\n    _collCont.transferFrom(msg.sender, address(this), _collateral);\n    uint256 _openFee = _getPositionOpenFee(_collateral, _leverage);\n    uint256 _finalPositionCollateral = _collateral - _openFee;\n    totalFees += _openFee;\n\n    Index memory _index = indexes[_indexInd];\n    Position storage _newPosition = positions[_newTokenId];\n    for (uint256 _i = 0; _i < _index.priceFeeds.length; _i++) {\n      IndexFeed memory _feed = _index.priceFeeds[_i];\n      (uint16 _phase, uint80 _round, ) = getLatestProxyInfo(_feed.proxy);\n      _newPosition.feeds.push(\n        PositionIndexFeed({\n          feed: _index.priceFeeds[_i],\n          phaseIdStart: _phase,\n          roundIdStart: _round,\n          phaseIdSettle: 0,\n          roundIdSettle: 0\n        })\n      );\n    }\n    uint256 _openPrice = getIndexPriceFromIndex(_indexInd);\n    positionOpeners[_newTokenId] = msg.sender;\n    _newPosition.lifecycle.openTime = block.timestamp;\n    _newPosition.lifecycle.openFees = _openFee;\n    _newPosition.collateralAmount = _finalPositionCollateral;\n    _newPosition.positionAmount = (_finalPositionCollateral * _leverage) / 10;\n    _newPosition.isLong = _isLong;\n    _newPosition.leverage = _leverage;\n    _newPosition.indexPriceStart = _openPrice;\n    _newPosition.collateralToken = address(_collCont);\n\n    _addOpenPosition(_newTokenId);\n    _validateAndUpdateOpenAmounts(_newTokenId);\n    if (_triggerOrderTargetPrice > 0) {\n      _addTriggerOrder(_newTokenId, _triggerOrderTargetPrice);\n    }\n\n    emit OpenPosition(\n      _newTokenId,\n      msg.sender,\n      _openPrice,\n      _finalPositionCollateral,\n      _isLong,\n      _leverage\n    );\n  }\n\n  function canOpenPositionAgainstIndex(uint256 _ind, uint256 _timestamp)\n    public\n    view\n    returns (bool)\n  {\n    _timestamp = _timestamp == 0 ? block.timestamp : _timestamp;\n    Index memory _index = indexes[_ind];\n    if (_index.dowOpenMin >= 1 && _index.dowOpenMax >= 1) {\n      uint256 _dow = timeLibrary.getDayOfWeek(_timestamp);\n      if (_dow < _index.dowOpenMin || _dow > _index.dowOpenMax) {\n        return false;\n      }\n    }\n    if (_index.hourOpenMin >= 1 || _index.hourOpenMax >= 1) {\n      uint256 _hour = timeLibrary.getHour(_timestamp);\n      if (_hour < _index.hourOpenMin || _hour > _index.hourOpenMax) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function closePosition(uint256 _tokenId) external {\n    _closePosition(_tokenId, false);\n  }\n\n  function _closePosition(uint256 _tokenId, bool _overrideOwner) internal {\n    Position storage _position = positions[_tokenId];\n    address _user = perpsNft.ownerOf(_tokenId);\n\n    require(_overrideOwner || msg.sender == _user, 'OWNLQ');\n    require(perpsNft.doesTokenExist(_tokenId), 'CLOSE1');\n\n    _getAndClosePositionPLInfo(_tokenId, _user);\n    _removeOpenPosition(_tokenId);\n    _closeIndividualFeeds(_tokenId);\n    _updateCloseAmounts(_tokenId);\n    perpsNft.burn(_tokenId);\n\n    positionClosers[_tokenId] = _user;\n\n    emit ClosePosition(\n      _tokenId,\n      _user,\n      _position.indexPriceStart,\n      _position.indexPriceSettle,\n      _position.amountWon,\n      _position.amountLost\n    );\n  }\n\n  function settleUnsettledPosition(\n    uint256 _tokenId,\n    uint256 _collPriceUSD,\n    uint256 _mainPriceUSD\n  ) external onlySettler {\n    Position storage _position = positions[_tokenId];\n    require(!_position.isSettled, 'SET1');\n    require(_position.collateralCloseUnsettled > 0, 'SET2');\n\n    _position.isSettled = true;\n    _position.lifecycle.settleCollPriceUSD = _collPriceUSD;\n    _position.lifecycle.settleMainPriceUSD = _mainPriceUSD;\n    uint256 _mainSettleAmt = (_position.collateralCloseUnsettled *\n      10**IERC20Decimals(mainCollateralToken).decimals() *\n      _collPriceUSD) /\n      _mainPriceUSD /\n      10**IERC20Decimals(_position.collateralToken).decimals();\n    IERC20(mainCollateralToken).transfer(\n      positionClosers[_tokenId],\n      _mainSettleAmt\n    );\n\n    // remove from unsettled positions array\n    uint256 _unsetPositionsIdx = _unsettledPositionsIdx[_tokenId];\n    uint256 _tokenIdMoving = allUnsettledPositions[\n      allUnsettledPositions.length - 1\n    ];\n    delete _unsettledPositionsIdx[_tokenId];\n    _unsettledPositionsIdx[_tokenIdMoving] = _unsetPositionsIdx;\n    allUnsettledPositions[_unsetPositionsIdx] = _tokenIdMoving;\n    allUnsettledPositions.pop();\n\n    emit SettlePosition(_tokenId, _mainSettleAmt, _collPriceUSD, _mainPriceUSD);\n  }\n\n  function getIndexAndPLInfo(uint256 _tokenId)\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      bool,\n      bool\n    )\n  {\n    Position memory _position = positions[_tokenId];\n    bool _canCloseInProfit = true;\n    uint256 _currentIndexPrice = getPositionIndexPrice(_tokenId);\n    bool _settlePriceIsHigher = _currentIndexPrice > _position.indexPriceStart;\n    bool _settlePriceIsLower = _currentIndexPrice < _position.indexPriceStart;\n    uint256 _indexAbsDiffFromOpen = _settlePriceIsHigher\n      ? _currentIndexPrice - _position.indexPriceStart\n      : _position.indexPriceStart - _currentIndexPrice;\n    uint256 _absolutePL = (_position.positionAmount * _indexAbsDiffFromOpen) /\n      _position.indexPriceStart;\n    bool _isProfit = _position.isLong\n      ? _settlePriceIsHigher\n      : _settlePriceIsLower;\n\n    uint256 _amountReturnToUser = _position.collateralAmount;\n    if (_isProfit) {\n      bool _isOverMinChange = _indexAbsDiffFromOpen >=\n        (_position.indexPriceStart * minPriceDiffForProfit) / PERC_DEN;\n      bool _isPastMinTime = block.timestamp >=\n        _position.lifecycle.openTime + minOpenTimeForProfit;\n      if (_isOverMinChange || _isPastMinTime) {\n        _amountReturnToUser += _absolutePL;\n      } else {\n        _canCloseInProfit = false;\n      }\n    } else {\n      if (_absolutePL > _amountReturnToUser) {\n        _amountReturnToUser = 0;\n      } else {\n        _amountReturnToUser -= _absolutePL;\n      }\n    }\n    return (\n      _currentIndexPrice,\n      _amountReturnToUser,\n      _absolutePL,\n      _isProfit,\n      _canCloseInProfit\n    );\n  }\n\n  function getLiquidationPriceChange(uint256 _tokenId)\n    public\n    view\n    returns (uint256)\n  {\n    // 90% of exact liquidation which would mean 100% deliquency\n    // NOTE: _position.leverage == 10 means 1x\n    // Ex. price start == 100, leverage == 15 (1.5x)\n    // (priceStart / (15 / 10)) * (9 / 10)\n    // (priceStart * 10 / 15) * (9 / 10)\n    // (priceStart / 15) * 9\n    // (priceStart * 9) / 15\n    return\n      (positions[_tokenId].indexPriceStart * 9) / positions[_tokenId].leverage;\n  }\n\n  function getPositionIndexPrice(uint256 _tokenId)\n    public\n    view\n    returns (uint256)\n  {\n    Position memory _position = positions[_tokenId];\n    address[] memory _proxies = new address[](_position.feeds.length);\n    uint256[] memory _multipliers = new uint256[](_position.feeds.length);\n    for (uint256 _i = 0; _i < _position.feeds.length; _i++) {\n      _proxies[_i] = _position.feeds[_i].feed.proxy;\n      _multipliers[_i] = _position.feeds[_i].feed.priceWeightMult;\n    }\n    return getIndexPriceFromFeeds(_proxies, _multipliers);\n  }\n\n  function getPositionCloseFees(uint256 _tokenId)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    address _owner = perpsNft.ownerOf(_tokenId);\n    (uint256 _percentOff, uint256 _percOffDenomenator) = _getFeeDiscount(\n      _owner\n    );\n    uint256 _closingFeePosition = (positions[_tokenId].positionAmount *\n      closeFeePositionSize) / PERC_DEN;\n    uint256 _closingFeeDurationPerUnit = (positions[_tokenId].positionAmount *\n      closeFeePerDuration) / PERC_DEN;\n    uint256 _closingFeeDurationTotal = (_closingFeeDurationPerUnit *\n      (block.timestamp - positions[_tokenId].lifecycle.openTime)) /\n      closeFeePerDurationUnit;\n\n    // user has discount from fees\n    if (_percentOff > 0) {\n      _closingFeePosition -=\n        (_closingFeePosition * _percentOff) /\n        _percOffDenomenator;\n      _closingFeeDurationTotal -=\n        (_closingFeeDurationTotal * _percentOff) /\n        _percOffDenomenator;\n    }\n    return (_closingFeePosition, _closingFeeDurationTotal);\n  }\n\n  function getPositionIndexProxies(uint256 _tokenId)\n    external\n    view\n    returns (address[] memory)\n  {\n    PositionIndexFeed[] memory _posFeeds = positions[_tokenId].feeds;\n    address[] memory _proxies = new address[](positions[_tokenId].feeds.length);\n    for (uint256 _i = 0; _i < _posFeeds.length; _i++) {\n      _proxies[_i] = _posFeeds[_i].feed.proxy;\n    }\n    return _proxies;\n  }\n\n  function addTriggerOrder(uint256 _tokenId, uint256 _idxPriceTarget)\n    external\n    onlyPositionOwner(_tokenId)\n  {\n    _addTriggerOrder(_tokenId, _idxPriceTarget);\n  }\n\n  function updateTriggerOrder(\n    uint256 _tokenId,\n    uint256 _idx,\n    uint256 _idxPriceTarget\n  ) external onlyPositionOwner(_tokenId) {\n    _updateTriggerOrder(_tokenId, _idx, _idxPriceTarget);\n  }\n\n  function removeTriggerOrder(uint256 _tokenId, uint256 _idx)\n    external\n    onlyPositionOwner(_tokenId)\n  {\n    _removeTriggerOrder(_tokenId, _idx);\n  }\n\n  function _addTriggerOrder(uint256 _tokenId, uint256 _idxPriceTarget)\n    internal\n  {\n    require(_idxPriceTarget > 0, 'TO0');\n    require(positionTriggerOrders[_tokenId].length < maxTriggerOrders, 'TO1');\n    uint256 _idxPriceCurr = getPositionIndexPrice(_tokenId);\n    require(_idxPriceCurr != _idxPriceTarget, 'TO2');\n\n    positionTriggerOrders[_tokenId].push(\n      TriggerOrder({\n        idxPriceCurrent: _idxPriceCurr,\n        idxPriceTarget: _idxPriceTarget\n      })\n    );\n  }\n\n  function _updateTriggerOrder(\n    uint256 _tokenId,\n    uint256 _idx,\n    uint256 _idxTargetPrice\n  ) internal {\n    require(_idxTargetPrice > 0, 'TO0');\n\n    TriggerOrder storage _order = positionTriggerOrders[_tokenId][_idx];\n    bool _isTargetLess = _order.idxPriceTarget < _order.idxPriceCurrent;\n    // if original target is less than original current, new target must\n    // remain less than, or vice versa for higher than prices\n    require(\n      _isTargetLess\n        ? _idxTargetPrice < _order.idxPriceCurrent\n        : _idxTargetPrice > _order.idxPriceCurrent,\n      'TO3'\n    );\n    _order.idxPriceTarget = _idxTargetPrice;\n  }\n\n  function _removeTriggerOrder(uint256 _tokenId, uint256 _idx) internal {\n    positionTriggerOrders[_tokenId][_idx] = positionTriggerOrders[_tokenId][\n      positionTriggerOrders[_tokenId].length - 1\n    ];\n    positionTriggerOrders[_tokenId].pop();\n  }\n\n  function setValidCollateralToken(address _token, bool _isValid)\n    external\n    onlyOwner\n  {\n    require(_validColl[_token] != _isValid, 'change state');\n    _validColl[_token] = _isValid;\n    if (_isValid) {\n      _allCollTokensInd[_token] = _allCollTokens.length;\n      _allCollTokens.push(_token);\n    } else {\n      uint256 _ind = _allCollTokensInd[_token];\n      delete _allCollTokensInd[_token];\n      _allCollTokens[_ind] = _allCollTokens[_allCollTokens.length - 1];\n      _allCollTokens.pop();\n    }\n  }\n\n  function setMainCollateralToken(address _token) external onlyOwner {\n    require(allOpenPositions.length == 0, 'MAINCOLL');\n    mainCollateralToken = _token;\n  }\n\n  // 10 == 1x, 1000 == 100x, etc.\n  function setMaxLeverage(uint16 _max) external onlyOwner {\n    require(_max <= 2500, 'max 250x');\n    maxLeverage = _max;\n  }\n\n  function setMaxTriggerOrders(uint8 _max) external onlyOwner {\n    maxTriggerOrders = _max;\n  }\n\n  function setMinOpenTimeForProfit(uint256 _seconds) external onlyOwner {\n    require(_seconds <= 1 days, 'max 1 days');\n    minOpenTimeForProfit = _seconds;\n  }\n\n  function setMinPriceDiffForProfit(uint256 _percentage) external onlyOwner {\n    require(_percentage < (PERC_DEN * 3) / 100, 'max 3%');\n    minPriceDiffForProfit = _percentage;\n  }\n\n  function setOpenPositionFeePositionSize(uint256 _percentage)\n    external\n    onlyOwner\n  {\n    require(_percentage < (PERC_DEN * 10) / 100, 'max 10%');\n    openFeePositionSize = _percentage;\n  }\n\n  function setClosePositionFeePositionSize(uint256 _percentage)\n    external\n    onlyOwner\n  {\n    require(_percentage < (PERC_DEN * 10) / 100, 'max 10%');\n    closeFeePositionSize = _percentage;\n  }\n\n  function setClosePositionFeePerDurationUnit(uint256 _seconds)\n    external\n    onlyOwner\n  {\n    require(_seconds >= 10 minutes, 'min 10m');\n    closeFeePerDurationUnit = _seconds;\n  }\n\n  function setClosePositionFeePerDuration(uint256 _percentage)\n    external\n    onlyOwner\n  {\n    require(_percentage < (PERC_DEN * 1) / 100, 'max 1%');\n    closeFeePerDuration = _percentage;\n  }\n\n  function setSettler(address _wallet, bool _isSettler) external onlyOwner {\n    require(settlers[_wallet] != _isSettler, 'SET3');\n    settlers[_wallet] = _isSettler;\n  }\n\n  function setMaxCollateralOpenDiff(address _collateral, uint256 _amount)\n    external\n    onlyOwner\n  {\n    maxCollateralOpenDiff[_collateral] = _amount;\n  }\n\n  function setMaxLiquidationsPerUpkeep(uint8 _max) external onlyOwner {\n    require(_max > 0, 'min 1');\n    maxLiquidationsPerUpkeep = _max;\n  }\n\n  function addIndex(\n    string memory _name,\n    address[] memory _proxies,\n    uint16[] memory _weights\n  ) external onlyOwner {\n    require(\n      _proxies.length > 0 && _proxies.length == _weights.length,\n      'same len'\n    );\n    Index storage _newIndex = indexes.push();\n    _newIndex.name = _name;\n\n    for (uint256 _i = 0; _i < _proxies.length; _i++) {\n      address _proxy = _proxies[_i];\n      (, , uint256 _priceUSD) = getLatestProxyInfo(_proxy);\n      require(_priceUSD > 0, 'invalid proxy');\n\n      _newIndex.weightsTotal += _proxies.length == 1 ? 0 : _weights[_i];\n      _newIndex.priceFeeds.push(\n        IndexFeed({\n          proxy: _proxy,\n          weight: _weights[_i],\n          priceWeightMult: _proxies.length == 1\n            ? 0\n            : (_weights[_i] * FACTOR**2) / _priceUSD\n        })\n      );\n    }\n  }\n\n  function removeIndex(uint256 _index) external onlyOwner {\n    indexes[_index] = indexes[indexes.length - 1];\n    indexes.pop();\n  }\n\n  function refreshIndexFeedWeights(uint256 _indexIdx) external onlyOwner {\n    Index storage _index = indexes[_indexIdx];\n    require(_index.priceFeeds.length > 1, 'ISIDX');\n    for (uint256 _i = 0; _i < _index.priceFeeds.length; _i++) {\n      (, , uint256 _priceUSD) = getLatestProxyInfo(_index.priceFeeds[_i].proxy);\n      _index.priceFeeds[_i].priceWeightMult =\n        (_index.priceFeeds[_i].weight * FACTOR**2) /\n        _priceUSD;\n    }\n  }\n\n  function updateIndexOpenTimeBounds(\n    uint256 _indexInd,\n    uint256 _dowOpenMin,\n    uint256 _dowOpenMax,\n    uint256 _hourOpenMin,\n    uint256 _hourOpenMax\n  ) external onlyOwner {\n    Index storage _index = indexes[_indexInd];\n    _index.dowOpenMin = _dowOpenMin;\n    _index.dowOpenMax = _dowOpenMax;\n    _index.hourOpenMin = _hourOpenMin;\n    _index.hourOpenMax = _hourOpenMax;\n  }\n\n  function setEnabled(bool _enabled) external onlyOwner {\n    enabled = _enabled;\n  }\n\n  function setFeeReducer(address _reducer) external onlyOwner {\n    feeReducer = IFeeReducer(_reducer);\n  }\n\n  function processFees(uint256 _amount) external onlyOwner {\n    IERC20(mainCollateralToken).transfer(mainCollateralToken, _amount);\n  }\n\n  function withdrawERC20(address _token, uint256 _amount) external onlyOwner {\n    IERC20 _contract = IERC20(_token);\n    _amount = _amount == 0 ? _contract.balanceOf(address(this)) : _amount;\n    require(_amount > 0);\n    _contract.transfer(owner(), _amount);\n  }\n\n  // https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/\n  function checkUpkeep(\n    bytes calldata /* checkData */\n  )\n    external\n    view\n    override\n    returns (\n      bool upkeepNeeded,\n      bytes memory /* performData */\n    )\n  {\n    for (uint256 _i = 0; _i < allOpenPositions.length; _i++) {\n      uint256 _tokenId = allOpenPositions[_i];\n      if (\n        shouldPositionLiquidate(_tokenId) ||\n        shouldPositionCloseFromTrigger(_tokenId)\n      ) {\n        upkeepNeeded = true;\n        break;\n      }\n    }\n  }\n\n  // https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/\n  function performUpkeep(\n    bytes calldata /* performData */\n  ) external override {\n    uint8 _liquidations;\n    for (uint256 _i = 0; _i < allOpenPositions.length; _i++) {\n      uint256 _tokenId = allOpenPositions[_i];\n      bool _shouldLiquidate = shouldPositionLiquidate(_tokenId);\n      bool _triggerClose = shouldPositionCloseFromTrigger(_tokenId);\n      if (_shouldLiquidate || _triggerClose) {\n        _closePosition(_tokenId, true);\n        _liquidations++;\n\n        if (_shouldLiquidate) {\n          emit LiquidatePosition(_tokenId);\n        } else if (_triggerClose) {\n          emit ClosePositionFromTriggerOrder(_tokenId);\n        }\n\n        if (_liquidations >= maxLiquidationsPerUpkeep) {\n          break;\n        }\n      }\n    }\n  }\n\n  function _getFeeDiscount(address _wallet)\n    internal\n    view\n    returns (uint256, uint256)\n  {\n    return\n      address(feeReducer) != address(0)\n        ? feeReducer.percentDiscount(_wallet)\n        : (0, 0);\n  }\n\n  function _getPositionOpenFee(uint256 _collateral, uint256 _leverage)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 _positionPreFee = (_collateral * _leverage) / 10;\n    uint256 _openFee = (_positionPreFee * openFeePositionSize) / PERC_DEN;\n    (uint256 _percentOff, uint256 _percOffDenomenator) = _getFeeDiscount(\n      msg.sender\n    );\n    // user has discount from fees\n    if (_percentOff > 0) {\n      _openFee -= (_openFee * _percentOff) / _percOffDenomenator;\n    }\n    return _openFee;\n  }\n\n  function _addOpenPosition(uint256 _tokenId) internal {\n    _openPositionsIdx[_tokenId] = allOpenPositions.length;\n    allOpenPositions.push(_tokenId);\n  }\n\n  function _removeOpenPosition(uint256 _tokenId) internal {\n    uint256 _allPositionsIdx = _openPositionsIdx[_tokenId];\n    uint256 _tokenIdMoving = allOpenPositions[allOpenPositions.length - 1];\n    delete _openPositionsIdx[_tokenId];\n    _openPositionsIdx[_tokenIdMoving] = _allPositionsIdx;\n    allOpenPositions[_allPositionsIdx] = _tokenIdMoving;\n    allOpenPositions.pop();\n  }\n\n  function _checkAndSettlePosition(\n    uint256 _tokenId,\n    address _closingUser,\n    uint256 _returnAmount\n  ) internal {\n    Position storage _position = positions[_tokenId];\n    if (_returnAmount > 0) {\n      if (_position.collateralToken == mainCollateralToken) {\n        _position.isSettled = true;\n        IERC20(_position.collateralToken).transfer(_closingUser, _returnAmount);\n      } else {\n        if (_returnAmount > _position.collateralAmount) {\n          IERC20(_position.collateralToken).transfer(\n            _closingUser,\n            _position.collateralAmount\n          );\n          _position.collateralCloseUnsettled =\n            _returnAmount -\n            _position.collateralAmount;\n          _unsettledPositionsIdx[_tokenId] = allUnsettledPositions.length;\n          allUnsettledPositions.push(_tokenId);\n          emit CloseUnsettledPosition(_tokenId);\n        } else {\n          _position.isSettled = true;\n          IERC20(_position.collateralToken).transfer(\n            _closingUser,\n            _returnAmount\n          );\n        }\n      }\n    } else {\n      _position.isSettled = true;\n    }\n  }\n\n  function _getAndClosePositionPLInfo(uint256 _tokenId, address _closingUser)\n    internal\n  {\n    Position storage _position = positions[_tokenId];\n    (\n      uint256 _closingFeePosition,\n      uint256 _closingFeeDurationTotal\n    ) = getPositionCloseFees(_tokenId);\n    uint256 _totalCloseFees = _closingFeePosition + _closingFeeDurationTotal;\n    totalFees += _totalCloseFees;\n\n    (\n      uint256 _currentIndexPrice,\n      uint256 _amountReturnToUser,\n      uint256 _absolutePL,\n      bool _isProfit,\n      bool _canCloseInProfit\n    ) = getIndexAndPLInfo(_tokenId);\n\n    if (_isProfit) {\n      if (_canCloseInProfit) {\n        totalAmountProfit += _absolutePL;\n      }\n    } else {\n      totalAmountLoss += _absolutePL;\n    }\n\n    // adjust amount returned based on closing fees incurred then transfer to position holder\n    _amountReturnToUser = _totalCloseFees > _amountReturnToUser\n      ? 0\n      : _amountReturnToUser - _totalCloseFees;\n    _checkAndSettlePosition(_tokenId, _closingUser, _amountReturnToUser);\n\n    _position.lifecycle.closeTime = block.timestamp;\n    _position.lifecycle.closeFees = _totalCloseFees;\n    _position.indexPriceSettle = _currentIndexPrice;\n    _position.amountWon = _isProfit && _canCloseInProfit ? _absolutePL : 0;\n    _position.amountLost = _isProfit\n      ? 0\n      : _absolutePL > _position.collateralAmount\n      ? _position.collateralAmount\n      : _absolutePL;\n  }\n\n  function _closeIndividualFeeds(uint256 _tokenId) internal {\n    Position storage _position = positions[_tokenId];\n    // update settle phase and round data for all proxies that make up the index\n    for (uint256 _i = 0; _i < _position.feeds.length; _i++) {\n      PositionIndexFeed storage _feed = _position.feeds[_i];\n      (uint16 _phase, uint80 _round, ) = getLatestProxyInfo(_feed.feed.proxy);\n      _feed.phaseIdSettle = _phase;\n      _feed.roundIdSettle = _round;\n    }\n  }\n\n  function _validateAndUpdateOpenAmounts(uint256 _tokenId) internal {\n    Position memory _position = positions[_tokenId];\n    if (_position.isLong) {\n      amtOpenLong[_position.collateralToken] += _position.positionAmount;\n    } else {\n      amtOpenShort[_position.collateralToken] += _position.positionAmount;\n    }\n    if (maxCollateralOpenDiff[_position.collateralToken] > 0) {\n      uint256 _openDiff = amtOpenLong[_position.collateralToken] >\n        amtOpenShort[_position.collateralToken]\n        ? amtOpenLong[_position.collateralToken] -\n          amtOpenShort[_position.collateralToken]\n        : amtOpenShort[_position.collateralToken] -\n          amtOpenLong[_position.collateralToken];\n      require(\n        _openDiff <= maxCollateralOpenDiff[_position.collateralToken],\n        'max collateral reached'\n      );\n    }\n  }\n\n  function _updateCloseAmounts(uint256 _tokenId) internal {\n    if (positions[_tokenId].isLong) {\n      amtOpenLong[positions[_tokenId].collateralToken] -= positions[_tokenId]\n        .positionAmount;\n    } else {\n      amtOpenShort[positions[_tokenId].collateralToken] -= positions[_tokenId]\n        .positionAmount;\n    }\n  }\n\n  function shouldPositionLiquidate(uint256 _tokenId)\n    public\n    view\n    returns (bool)\n  {\n    Position memory _position = positions[_tokenId];\n    uint256 _priceChangeForLiquidation = getLiquidationPriceChange(_tokenId);\n    (uint256 _closingFeeMain, uint256 _closingFeeTime) = getPositionCloseFees(\n      _tokenId\n    );\n    (\n      uint256 _currentIndexPrice,\n      uint256 _amountReturnToUser,\n      ,\n      bool _isProfit,\n\n    ) = getIndexAndPLInfo(_tokenId);\n    uint256 _indexPriceDelinquencyPrice = _position.isLong\n      ? _position.indexPriceStart - _priceChangeForLiquidation\n      : _position.indexPriceStart + _priceChangeForLiquidation;\n    bool _priceInLiquidation = _position.isLong\n      ? _currentIndexPrice <= _indexPriceDelinquencyPrice\n      : _currentIndexPrice >= _indexPriceDelinquencyPrice;\n    bool _feesExceedReturn = !_isProfit &&\n      _closingFeeMain + _closingFeeTime >= _amountReturnToUser;\n    return _priceInLiquidation || _feesExceedReturn;\n  }\n\n  function shouldPositionCloseFromTrigger(uint256 _tokenId)\n    public\n    view\n    returns (bool)\n  {\n    TriggerOrder[] memory _orders = positionTriggerOrders[_tokenId];\n    uint256 _currIdxPrice = getPositionIndexPrice(_tokenId);\n    for (uint256 _i = 0; _i < _orders.length; _i++) {\n      uint256 _target = _orders[_i].idxPriceTarget;\n      bool _lessThanEQ = _target < _orders[_i].idxPriceCurrent;\n      if (_lessThanEQ) {\n        if (_currIdxPrice <= _target) {\n          return true;\n        }\n      } else {\n        if (_currIdxPrice >= _target) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"
6     },
7     "@chainlink/contracts/src/v0.8/KeeperCompatible.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./KeeperBase.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
9     },
10     "@openzeppelin/contracts/access/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/interfaces/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
15     },
16     "contracts/interfaces/IERC20Decimals.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n\ninterface IERC20Decimals is IERC20 {\n  function decimals() external view returns (uint8);\n}\n"
18     },
19     "contracts/interfaces/IFeeReducer.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IFeeReducer {\n  function percentDiscount(address _user)\n    external\n    view\n    returns (uint256, uint256);\n}\n"
21     },
22     "contracts/interfaces/IBokkyPooBahsDateTime.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IBokkyPooBahsDateTime {\n  function getDayOfWeek(uint256 timestamp)\n    external\n    pure\n    returns (uint256 dayOfWeek);\n\n  function getHour(uint256 timestamp) external pure returns (uint256 hour);\n}\n"
24     },
25     "contracts/IndexHandler.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport './interfaces/PriceFeedProxy.sol';\n\ncontract IndexHandler {\n  uint256 constant FACTOR = 10**18;\n\n  struct IndexFeed {\n    address proxy;\n    uint16 weight;\n    uint256 priceWeightMult;\n  }\n\n  struct Index {\n    string name;\n    uint256 weightsTotal;\n    uint256 dowOpenMin;\n    uint256 dowOpenMax;\n    uint256 hourOpenMin;\n    uint256 hourOpenMax;\n    IndexFeed[] priceFeeds;\n  }\n\n  Index[] public indexes;\n\n  function getIndexPriceFromIndex(uint256 _index)\n    public\n    view\n    returns (uint256)\n  {\n    Index memory index = indexes[_index];\n    uint256 priceUSD;\n    for (uint256 i = 0; i < index.priceFeeds.length; i++) {\n      IndexFeed memory _proxy = index.priceFeeds[i];\n      (, , uint256 _feedPriceUSD) = getLatestProxyInfo(_proxy.proxy);\n      priceUSD += _proxy.priceWeightMult == 0\n        ? _feedPriceUSD\n        : (_feedPriceUSD * _proxy.priceWeightMult) / FACTOR;\n    }\n    return priceUSD;\n  }\n\n  function getIndexPriceFromFeeds(\n    address[] memory _proxies,\n    uint256[] memory _multipliers\n  ) public view returns (uint256) {\n    require(_proxies.length == _multipliers.length);\n    uint256 priceUSD;\n    for (uint256 i = 0; i < _proxies.length; i++) {\n      (, , uint256 _feedPriceUSD) = getLatestProxyInfo(_proxies[i]);\n      priceUSD += _proxies.length == 1\n        ? _feedPriceUSD\n        : (_feedPriceUSD * _multipliers[i]) / FACTOR;\n    }\n    return priceUSD;\n  }\n\n  function getLatestProxyInfo(address _proxy)\n    public\n    view\n    returns (\n      uint16,\n      uint80,\n      uint256\n    )\n  {\n    PriceFeedProxy _feed = PriceFeedProxy(_proxy);\n    uint16 _phaseId = _feed.phaseId();\n    uint8 _decimals = _feed.decimals();\n    (uint80 _proxyRoundId, int256 _price, , , ) = _feed.latestRoundData();\n    return (\n      _phaseId,\n      _proxyRoundId,\n      uint256(_price) * (10**18 / 10**_decimals)\n    );\n  }\n}\n"
27     },
28     "contracts/pfYDF.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport './IndexHandler.sol';\n\ncontract pfYDF is ERC721Enumerable, Ownable {\n  using Strings for uint256;\n  using Counters for Counters.Counter;\n\n  address public perpetualFutures;\n\n  Counters.Counter internal _ids;\n  string private baseTokenURI; // baseTokenURI can point to IPFS folder like https://ipfs.io/ipfs/{cid}/ while\n  address public royaltyAddress;\n\n  // Royalties basis points (percentage using 2 decimals - 1000 = 100, 500 = 50, 0 = 0)\n  uint256 private royaltyBasisPoints = 50; // 5%\n\n  // array of all the NFT token IDs owned by a user\n  mapping(address => uint256[]) public allUserOwned;\n  // the index in the token ID array at allUserOwned to save gas on operations\n  mapping(uint256 => uint256) public ownedIndex;\n\n  mapping(uint256 => uint256) public tokenMintedAt;\n  mapping(uint256 => uint256) public tokenLastTransferred;\n\n  event Burn(uint256 indexed tokenId, address indexed owner);\n  event Mint(uint256 indexed tokenId, address indexed owner);\n  event SetPaymentAddress(address indexed user);\n  event SetRoyaltyAddress(address indexed user);\n  event SetRoyaltyBasisPoints(uint256 indexed _royaltyBasisPoints);\n  event SetBaseTokenURI(string indexed newUri);\n\n  modifier onlyPerps() {\n    require(msg.sender == perpetualFutures, 'only perps');\n    _;\n  }\n\n  constructor(string memory _baseTokenURI)\n    ERC721('Yieldification Perpetual Futures', 'pfYDF')\n  {\n    baseTokenURI = _baseTokenURI;\n    perpetualFutures = msg.sender;\n  }\n\n  function mint(address owner) external onlyPerps returns (uint256) {\n    _ids.increment();\n    _safeMint(owner, _ids.current());\n    tokenMintedAt[_ids.current()] = block.timestamp;\n    emit Mint(_ids.current(), owner);\n    return _ids.current();\n  }\n\n  function burn(uint256 _tokenId) external onlyPerps {\n    address _user = ownerOf(_tokenId);\n    require(_exists(_tokenId));\n    _burn(_tokenId);\n    emit Burn(_tokenId, _user);\n  }\n\n  // Support royalty info - See {EIP-2981}: https://eips.ethereum.org/EIPS/eip-2981\n  function royaltyInfo(uint256, uint256 _salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount)\n  {\n    return (royaltyAddress, (_salePrice * royaltyBasisPoints) / 1000);\n  }\n\n  function tokenURI(uint256 _tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(_exists(_tokenId));\n    return string(abi.encodePacked(_baseURI(), _tokenId.toString(), '.json'));\n  }\n\n  // Contract metadata URI - Support for OpenSea: https://docs.opensea.io/docs/contract-level-metadata\n  function contractURI() public view returns (string memory) {\n    return string(abi.encodePacked(_baseURI(), 'contract.json'));\n  }\n\n  // Override supportsInterface - See {IERC165-supportsInterface}\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC721Enumerable)\n    returns (bool)\n  {\n    return super.supportsInterface(_interfaceId);\n  }\n\n  function getLastMintedTokenId() external view returns (uint256) {\n    return _ids.current();\n  }\n\n  function doesTokenExist(uint256 _tokenId) external view returns (bool) {\n    return _exists(_tokenId);\n  }\n\n  function setRoyaltyAddress(address _address) external onlyOwner {\n    royaltyAddress = _address;\n    emit SetRoyaltyAddress(_address);\n  }\n\n  function setRoyaltyBasisPoints(uint256 _points) external onlyOwner {\n    royaltyBasisPoints = _points;\n    emit SetRoyaltyBasisPoints(_points);\n  }\n\n  function setBaseURI(string memory _uri) external onlyOwner {\n    baseTokenURI = _uri;\n    emit SetBaseTokenURI(_uri);\n  }\n\n  function setPerpetualFutures(address _perps) external onlyOwner {\n    perpetualFutures = _perps;\n  }\n\n  function getAllUserOwned(address _user)\n    external\n    view\n    returns (uint256[] memory)\n  {\n    return allUserOwned[_user];\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    return baseTokenURI;\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override(ERC721Enumerable) {\n    tokenLastTransferred[_tokenId] = block.timestamp;\n\n    super._beforeTokenTransfer(_from, _to, _tokenId);\n  }\n\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) internal virtual override(ERC721) {\n    // if from == address(0), token is being minted\n    if (_from != address(0)) {\n      uint256 _currIndex = ownedIndex[_tokenId];\n      uint256 _tokenIdMovingIndices = allUserOwned[_from][\n        allUserOwned[_from].length - 1\n      ];\n      allUserOwned[_from][_currIndex] = allUserOwned[_from][\n        allUserOwned[_from].length - 1\n      ];\n      allUserOwned[_from].pop();\n      ownedIndex[_tokenIdMovingIndices] = _currIndex;\n    }\n\n    // if to == address(0), token is being burned\n    if (_to != address(0)) {\n      ownedIndex[_tokenId] = allUserOwned[_to].length;\n      allUserOwned[_to].push(_tokenId);\n    }\n\n    super._afterTokenTransfer(_from, _to, _tokenId);\n  }\n}\n"
30     },
31     "@chainlink/contracts/src/v0.8/KeeperBase.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract KeeperBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
33     },
34     "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
36     },
37     "@openzeppelin/contracts/utils/Context.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
39     },
40     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
42     },
43     "contracts/interfaces/PriceFeedProxy.sol": {
44       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol';\n\ninterface PriceFeedProxy is AggregatorV2V3Interface {\n  function aggregator() external view returns (address);\n\n  function phaseId() external view returns (uint16);\n}\n"
45     },
46     "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
47       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
48     },
49     "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
51     },
52     "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
53       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
54     },
55     "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
56       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
57     },
58     "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
59       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
60     },
61     "@openzeppelin/contracts/utils/Counters.sol": {
62       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
63     },
64     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
65       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
66     },
67     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
68       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
69     },
70     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
71       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
72     },
73     "@openzeppelin/contracts/utils/Address.sol": {
74       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
75     },
76     "@openzeppelin/contracts/utils/Strings.sol": {
77       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
78     },
79     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
80       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
81     },
82     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
83       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
84     },
85     "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
86       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
87     }
88   },
89   "settings": {
90     "metadata": {
91       "bytecodeHash": "none"
92     },
93     "optimizer": {
94       "enabled": true,
95       "runs": 200
96     },
97     "outputSelection": {
98       "*": {
99         "*": [
100           "evm.bytecode",
101           "evm.deployedBytecode",
102           "devdoc",
103           "userdoc",
104           "metadata",
105           "abi"
106         ]
107       }
108     },
109     "libraries": {}
110   }
111 }}