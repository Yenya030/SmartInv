1 //Lego Inu ($LEGO)
2 /*
3 🔸♦️🔷LEGO INU🔷♦️🔸
4 
5 Telegram: https://t.me/LegoInu1
6 Twitter: https://twitter.com/lego_inu
7 Reddit: https://www.reddit.com/r/LegoInu
8 Youtube: https://www.youtube.com/channel/UC4iw7KAtpNC-Zv5xfEzJP2g
9 Github: https://github.com/LegoInu/Lego
10 Website: https://legoinu.com
11 
12 ...................;LGGGGGGGGGGGGGGGGGGGGGGGG00Cf:..................
13 .................i@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8,................
14 .................8@@@0LLCCCCCCCCCCCCCCCCGGGGGGC@@@@f................
15 .................8@@@L,:;iiiiiiiiiiiiiii111111i8@@@f................
16 .................8@@@L,:;iiiiiiiiiiiiiii111111i8@@@f................
17 .................8@@@L,,;iiiiiiiiiiiiii;111111i8@@@f................
18 .........;C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8f,........
19 ......:0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@C......
20 .....0@@@@@Ci,:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ii1111i1L8@@@@@f....
21 ...,@@@@@;::;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii1111111C@@@@C...
22 ...G@@@0,,:tLLCGCLLf1i;;iiiiiiiiiiiiiiiiiiiii;;itLLCGGCLft11t@@@@t..
23 .:t@@@8LC0@@@@@@@@@@@@@@@@@@GLf1i;;;i1fLG@@@@@@@@@@@@@@@@@0LC8@@@0..
24 Gf.:f8@@@@@@@8800G008@@@@@@@0LtfC8@0LfC0@@@@@80GCCCCCG08@@@@@@8t,.CL
25 0fG@@@@@8CLLtttttf,1ttttttL8@@@@@@@@@@@@0fttttttf,ttttttfLLG@@@@@fC0
26 L8@@@@@0LLftttttf;;11tttttttt@@@@@@@@@@ftttttttt;;11ttttttLLC@@@@@80
27 .0@@@@@LLftttttt;;;1iitttttttG@@@@@@@@8tttttttt;;;iiitttttfLL0@@@@8:
28 ..t@@@8LLftttt1i1f:tf1;fttttt0@@@@@@@@@tttttt1i1t:tt1;ftttfLL0@@@8..
29 ..;@@@@LLftttt.iff;ff1:;ttttt@@@@C;8@@@Ltttt1,1ff:ff1:;tttfLL0@@@8..
30 ..;@@@@CLLtttf;ii;;i;1:fttttG@@@@iit@@@8ttttf:ii;:i;i:ftttLLC@@@@8..
31 ..;@@@@@LLftttt1ii;;1ifttttC@@@@1iiiL@@@8ttttt1ii;;1ittttfLL@@@@@8..
32 ..;@@@@@@CLLttttf:;;tttttt0@@@@tiiii;C@@@@Lttttf;;;tttttLLC@@@@@@8..
33 ..;@@@@@@@@GLLfttttftttf8@@@@8iiiiiiiif@@@@@GtttttfttfLL0@@@@@@@@@..
34 ..;@@@@G@@@@@@@88000@@@@@@@@fiiiiiiiiiiiG@@@@@@@@@@@@@@@@@@@0C@@@8..
35 ..;@@@@;,t8@@@@@@@@@@@@@@01iiiiiiiiiiiiii;t0@@@@@@@@@@@@@8L11C@@@8..
36 ..;@@@@;:,;i;itfLCCLfti;iiiiiiiiiiiiiiiiiiiii;;1fLLLft1111111C@@@@..
37 ..;@@@@;:,;iiiiiiiiiiiiiii;iiiiiiiiiiiiiiiiiiiiiiiiiii1111111C@@@@..
38 ..;@@@@;:,;iiiiiiiiiiiiit8081iiiiiiiiii;G00G;iiiiiiiii1111111C@@@8..
39 ..;@@@@;:,;iiiiiiiiiiiii;C0008Cti;;i1L00000iiiiiiiiiii1111111C@@@8..
40 ...@@@@f::;iiiiiiiiiiiiiiiiC80000000000001iiiiiiiiiiii11111118@@@C..
41 ...t@@@@t::;iiiiiiiiiiiiiiiii;ifLGGCLt;iiiiiiiiiiiiii1111111G@@@@:..
42 ....f@@@@8i,:;iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii1111111C@@@@@;...
43 .....:8@@@@@@80GGG000GGGGGGGGGGGGGGGGGGGGGGGGGG00G00000@@@@@@@G.....
44 .......,C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@f.......
45 ...........,1fLCC@@@@00088888888888888888888888@@@0CCCLti...........
46 .................8@@@;:;1iiiiiiiiiiiiii1111111L@@@L.................
47 .................t@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@;.................
48 ...................tG00000000000000000000000000C1...................
49 
50 
51 🔸♦️🔷LEGO INU🔷♦️🔸
52 
53 ONLY THE BEST IS GOOD ENOUGH. LET'S BUILD THE BEST COMMUNITY OF ALL, BRICK BY BRICK.
54 
55 ⏰⏰Lanuch time: Thursday 15/07/2021 @ 20:00 GMT
56 
57 💁🏻‍♂️LEGO INU is a reflective, NFT enriched and Lottery oriented ERC20 community-driven meme token with the vision of maximizing profit for LEGO holders employing many of its unique features.
58 
59 🧮 LEGO.NOMICS:
60 2,500,000,000,000 Total LEGOs 
61 7,500,000,000 initial buy limit 
62 1 Min Cooldown 
63 
64 💠 LEGO.TRUST (https://legoinu.com/):
65 Liquidity Locked on Unicrypt
66 Ownership Renounced after everything works as intended
67 
68 💲 LEGO.FEES:
69 5% LEGO Redistribution among Holders
70 15% Tax as following:
71        > 50% for Development
72        > 40% for Marketing and Buybacks
73        > 10% for LEGO.LOTTO to Reward Top Holders
74 
75 🎟 LEGO.LOTTO (https://legoinu.com/):
76 This is the most exciting part of our ecosystem. LEGO architect has designed a lottery system to incentivize community to hold and flaunt their holdings. 10% of all collected fees will be distributed to 3 lucky winners on every lottery draw. LEGO.LOTTO (https://legoinu.com/) has the following criteria:
77         1) You need to be among top 20 holders until the deadline of that lottery draw.
78         2) The amount of LEGO with which you are a top 20 holder, should have been bought by the same address and not transferred from another address. You got no place in LEGO.LOTTO you filthy multiple-address-smart-contract buyer.
79         3) If you were chosen as one of lucky winners, you must maintain the same amount of LEGO holdings until the next lottery draw. Otherwise, your spot will be given to the next person who has held until the next lottery draw (even though he was not among the 3 winners).
80         4) The first lottery draw will happen at 5 hours post launch, following by daily lottery draw at the same time of the day.
81         5) At the end of each deadline, a random number will be assigned to each of top 20 holders and before the draw, a google sheet containing all eligible entries will be shared in our telegram channel. 
82         6) The LEGO.POT for every draw is shown on the front page of the website live.
83 
84 🖼 LEGO.NFT:
85 This is the next area in which LEGO shines. With LEGO.NFT, you can mint your own LEGO themed NFT, every of which are unique and not mintable by anyone once deployed by LEGO stakers. All minted LEGO.NFTs will be tradable right away in NFT marketplaces such as OpenSea and Rarible. This has never done before and will be a game changer once live.
86 In order to be able to mint a LEGO.NFT, you should stake and burn a certain amount of LEGOs which will be decided before it is fully launched. Keep in mind that the burning requirement make LEGOs even more deflationary and valuable.
87 
88 */
89 //5% Deflationary yes
90 //Bot Protect yes
91 
92 // SPDX-License-Identifier: Unlicensed
93 pragma solidity ^0.8.4;
94 
95 abstract contract Context {
96     function _msgSender() internal view virtual returns (address) {
97         return msg.sender;
98     }
99 }
100 
101 interface IERC20 {
102     function totalSupply() external view returns (uint256);
103 
104     function balanceOf(address account) external view returns (uint256);
105 
106     function transfer(address recipient, uint256 amount)
107         external
108         returns (bool);
109 
110     function allowance(address owner, address spender)
111         external
112         view
113         returns (uint256);
114 
115     function approve(address spender, uint256 amount) external returns (bool);
116 
117     function transferFrom(
118         address sender,
119         address recipient,
120         uint256 amount
121     ) external returns (bool);
122 
123     event Transfer(address indexed from, address indexed to, uint256 value);
124     event Approval(
125         address indexed owner,
126         address indexed spender,
127         uint256 value
128     );
129 }
130 
131 library SafeMath {
132     function add(uint256 a, uint256 b) internal pure returns (uint256) {
133         uint256 c = a + b;
134         require(c >= a, "SafeMath: addition overflow");
135         return c;
136     }
137 
138     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
139         return sub(a, b, "SafeMath: subtraction overflow");
140     }
141 
142     function sub(
143         uint256 a,
144         uint256 b,
145         string memory errorMessage
146     ) internal pure returns (uint256) {
147         require(b <= a, errorMessage);
148         uint256 c = a - b;
149         return c;
150     }
151 
152     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
153         if (a == 0) {
154             return 0;
155         }
156         uint256 c = a * b;
157         require(c / a == b, "SafeMath: multiplication overflow");
158         return c;
159     }
160 
161     function div(uint256 a, uint256 b) internal pure returns (uint256) {
162         return div(a, b, "SafeMath: division by zero");
163     }
164 
165     function div(
166         uint256 a,
167         uint256 b,
168         string memory errorMessage
169     ) internal pure returns (uint256) {
170         require(b > 0, errorMessage);
171         uint256 c = a / b;
172         return c;
173     }
174 }
175 
176 contract Ownable is Context {
177     address private _owner;
178     address private _previousOwner;
179     event OwnershipTransferred(
180         address indexed previousOwner,
181         address indexed newOwner
182     );
183 
184     constructor() {
185         address msgSender = _msgSender();
186         _owner = msgSender;
187         emit OwnershipTransferred(address(0), msgSender);
188     }
189 
190     function owner() public view returns (address) {
191         return _owner;
192     }
193 
194     modifier onlyOwner() {
195         require(_owner == _msgSender(), "Ownable: caller is not the owner");
196         _;
197     }
198 
199     function renounceOwnership() public virtual onlyOwner {
200         emit OwnershipTransferred(_owner, address(0));
201         _owner = address(0);
202     }
203 }
204 
205 interface IUniswapV2Factory {
206     function createPair(address tokenA, address tokenB)
207         external
208         returns (address pair);
209 }
210 
211 interface IUniswapV2Router02 {
212     function swapExactTokensForETHSupportingFeeOnTransferTokens(
213         uint256 amountIn,
214         uint256 amountOutMin,
215         address[] calldata path,
216         address to,
217         uint256 deadline
218     ) external;
219 
220     function factory() external pure returns (address);
221 
222     function WETH() external pure returns (address);
223 
224     function addLiquidityETH(
225         address token,
226         uint256 amountTokenDesired,
227         uint256 amountTokenMin,
228         uint256 amountETHMin,
229         address to,
230         uint256 deadline
231     )
232         external
233         payable
234         returns (
235             uint256 amountToken,
236             uint256 amountETH,
237             uint256 liquidity
238         );
239 }
240 
241 contract LegoInu is Context, IERC20, Ownable {
242     using SafeMath for uint256;
243 
244     string private constant _name = "Lego Inu";
245     string private constant _symbol = "\xf0\x9f\x94\xb7LEGO\xf0\x9f\x94\xb6";
246     uint8 private constant _decimals = 8;
247 
248     // RFI
249     mapping(address => uint256) private _rOwned;
250     mapping(address => uint256) private _tOwned;
251     mapping(address => mapping(address => uint256)) private _allowances;
252     mapping(address => bool) private _isExcludedFromFee;
253     uint256 private constant MAX = ~uint256(0);
254     uint256 private constant _tTotal = 2500000000000 * 10**8;
255     uint256 private _rTotal = (MAX - (MAX % _tTotal));
256     uint256 private _tFeeTotal;
257     uint256 private _taxFee = 5;
258     uint256 private _teamFee = 15;
259 
260     // Bot detection
261     mapping(address => bool) private bots;
262     mapping(address => uint256) private cooldown;
263     address payable private _devWallet;
264     address payable private _marketingBuyback;
265     address payable private _lotteryWallet;
266     IUniswapV2Router02 private uniswapV2Router;
267     address private uniswapV2Pair;
268     bool private tradingOpen;
269     bool private inSwap = false;
270     bool private swapEnabled = false;
271     bool private cooldownEnabled = false;
272     uint256 private _maxTxAmount = _tTotal;
273 
274     event MaxTxAmountUpdated(uint256 _maxTxAmount);
275     modifier lockTheSwap {
276         inSwap = true;
277         _;
278         inSwap = false;
279     }
280 
281     constructor(address payable devWallet, address payable marketingBuyback, address payable lotteryWallet) {
282         _devWallet = devWallet;
283         _marketingBuyback = marketingBuyback;
284         _lotteryWallet = lotteryWallet;
285         _rOwned[_msgSender()] = _rTotal;
286         _isExcludedFromFee[owner()] = true;
287         _isExcludedFromFee[address(this)] = true;
288         _isExcludedFromFee[_devWallet] = true;
289         _isExcludedFromFee[_marketingBuyback] = true;
290         _isExcludedFromFee[_lotteryWallet] = true;
291         emit Transfer(address(0), _msgSender(), _tTotal);
292     }
293 
294     function name() public pure returns (string memory) {
295         return _name;
296     }
297 
298     function symbol() public pure returns (string memory) {
299         return _symbol;
300     }
301 
302     function decimals() public pure returns (uint8) {
303         return _decimals;
304     }
305 
306     function totalSupply() public pure override returns (uint256) {
307         return _tTotal;
308     }
309 
310     function balanceOf(address account) public view override returns (uint256) {
311         return tokenFromReflection(_rOwned[account]);
312     }
313 
314     function transfer(address recipient, uint256 amount)
315         public
316         override
317         returns (bool)
318     {
319         _transfer(_msgSender(), recipient, amount);
320         return true;
321     }
322 
323     function allowance(address owner, address spender)
324         public
325         view
326         override
327         returns (uint256)
328     {
329         return _allowances[owner][spender];
330     }
331 
332     function approve(address spender, uint256 amount)
333         public
334         override
335         returns (bool)
336     {
337         _approve(_msgSender(), spender, amount);
338         return true;
339     }
340 
341     function transferFrom(
342         address sender,
343         address recipient,
344         uint256 amount
345     ) public override returns (bool) {
346         _transfer(sender, recipient, amount);
347         _approve(
348             sender,
349             _msgSender(),
350             _allowances[sender][_msgSender()].sub(
351                 amount,
352                 "ERC20: transfer amount exceeds allowance"
353             )
354         );
355         return true;
356     }
357 
358     function setCooldownEnabled(bool onoff) external onlyOwner() {
359         cooldownEnabled = onoff;
360     }
361 
362     function tokenFromReflection(uint256 rAmount)
363         private
364         view
365         returns (uint256)
366     {
367         require(
368             rAmount <= _rTotal,
369             "Amount must be less than total reflections"
370         );
371         uint256 currentRate = _getRate();
372         return rAmount.div(currentRate);
373     }
374 
375     function removeAllFee() private {
376         if (_taxFee == 0 && _teamFee == 0) return;
377         _taxFee = 0;
378         _teamFee = 0;
379     }
380 
381     function restoreAllFee() private {
382         _taxFee = 5;
383         _teamFee = 15;
384     }
385 
386     function _approve(
387         address owner,
388         address spender,
389         uint256 amount
390     ) private {
391         require(owner != address(0), "ERC20: approve from the zero address");
392         require(spender != address(0), "ERC20: approve to the zero address");
393         _allowances[owner][spender] = amount;
394         emit Approval(owner, spender, amount);
395     }
396 
397     function _transfer(
398         address from,
399         address to,
400         uint256 amount
401     ) private {
402         require(from != address(0), "ERC20: transfer from the zero address");
403         require(to != address(0), "ERC20: transfer to the zero address");
404         require(amount > 0, "Transfer amount must be greater than zero");
405 
406         if (from != owner() && to != owner()) {
407             if (cooldownEnabled) {
408                 if (
409                     from != address(this) &&
410                     to != address(this) &&
411                     from != address(uniswapV2Router) &&
412                     to != address(uniswapV2Router)
413                 ) {
414                     require(
415                         _msgSender() == address(uniswapV2Router) ||
416                             _msgSender() == uniswapV2Pair,
417                         "ERR: Uniswap only"
418                     );
419                 }
420             }
421             require(amount <= _maxTxAmount);
422             require(!bots[from] && !bots[to]);
423             if (
424                 from == uniswapV2Pair &&
425                 to != address(uniswapV2Router) &&
426                 !_isExcludedFromFee[to] &&
427                 cooldownEnabled
428             ) {
429                 require(cooldown[to] < block.timestamp);
430                 cooldown[to] = block.timestamp + (60 seconds);
431             }
432             uint256 contractTokenBalance = balanceOf(address(this));
433             if (!inSwap && from != uniswapV2Pair && swapEnabled) {
434                 swapTokensForEth(contractTokenBalance);
435                 uint256 contractETHBalance = address(this).balance;
436                 if (contractETHBalance > 0) {
437                     sendETHToFee(address(this).balance);
438                 }
439             }
440         }
441         bool takeFee = true;
442 
443         if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {
444             takeFee = false;
445         }
446 
447         _tokenTransfer(from, to, amount, takeFee);
448     }
449 
450     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
451         address[] memory path = new address[](2);
452         path[0] = address(this);
453         path[1] = uniswapV2Router.WETH();
454         _approve(address(this), address(uniswapV2Router), tokenAmount);
455         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
456             tokenAmount,
457             0,
458             path,
459             address(this),
460             block.timestamp
461         );
462     }
463 
464 
465     function sendETHToFee(uint256 amount) private {
466         _devWallet.transfer(amount.mul(5).div(10));
467         _marketingBuyback.transfer(amount.mul(4).div(10));
468         _lotteryWallet.transfer(amount.mul(1).div(10));
469     }
470 
471     function openTrading() external onlyOwner() {
472         require(!tradingOpen, "trading is already open");
473         IUniswapV2Router02 _uniswapV2Router =
474             IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
475         uniswapV2Router = _uniswapV2Router;
476         _approve(address(this), address(uniswapV2Router), _tTotal);
477         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
478             .createPair(address(this), _uniswapV2Router.WETH());
479         uniswapV2Router.addLiquidityETH{value: address(this).balance}(
480             address(this),
481             balanceOf(address(this)),
482             0,
483             0,
484             owner(),
485             block.timestamp
486         );
487         swapEnabled = true;
488         cooldownEnabled = true;
489         _maxTxAmount = 7500000000 * 10**8;
490         tradingOpen = true;
491         IERC20(uniswapV2Pair).approve(
492             address(uniswapV2Router),
493             type(uint256).max
494         );
495     }
496 
497     function manualswap() external {
498         require(_msgSender() == _devWallet);
499         uint256 contractBalance = balanceOf(address(this));
500         swapTokensForEth(contractBalance);
501     }
502 
503     function manualsend() external {
504         require(_msgSender() == _devWallet);
505         uint256 contractETHBalance = address(this).balance;
506         sendETHToFee(contractETHBalance);
507     }
508 
509     function setBots(address[] memory bots_) public onlyOwner {
510         for (uint256 i = 0; i < bots_.length; i++) {
511             bots[bots_[i]] = true;
512         }
513     }
514 
515     function delBot(address notbot) public onlyOwner {
516         bots[notbot] = false;
517     }
518 
519     function _tokenTransfer(
520         address sender,
521         address recipient,
522         uint256 amount,
523         bool takeFee
524     ) private {
525         if (!takeFee) removeAllFee();
526         _transferStandard(sender, recipient, amount);
527         if (!takeFee) restoreAllFee();
528     }
529 
530     function _transferStandard(
531         address sender,
532         address recipient,
533         uint256 tAmount
534     ) private {
535         (
536             uint256 rAmount,
537             uint256 rTransferAmount,
538             uint256 rFee,
539             uint256 tTransferAmount,
540             uint256 tFee,
541             uint256 tTeam
542         ) = _getValues(tAmount);
543         _rOwned[sender] = _rOwned[sender].sub(rAmount);
544         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
545         _takeTeam(tTeam);
546         _reflectFee(rFee, tFee);
547         emit Transfer(sender, recipient, tTransferAmount);
548     }
549 
550     function _takeTeam(uint256 tTeam) private {
551         uint256 currentRate = _getRate();
552         uint256 rTeam = tTeam.mul(currentRate);
553         _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
554     }
555 
556     function _reflectFee(uint256 rFee, uint256 tFee) private {
557         _rTotal = _rTotal.sub(rFee);
558         _tFeeTotal = _tFeeTotal.add(tFee);
559     }
560 
561     receive() external payable {}
562 
563     function _getValues(uint256 tAmount)
564         private
565         view
566         returns (
567             uint256,
568             uint256,
569             uint256,
570             uint256,
571             uint256,
572             uint256
573         )
574     {
575         (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =
576             _getTValues(tAmount, _taxFee, 15);
577         uint256 currentRate = _getRate();
578         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =
579             _getRValues(tAmount, tFee, tTeam, currentRate);
580         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
581     }
582 
583     function _getTValues(
584         uint256 tAmount,
585         uint256 taxFee,
586         uint256 TeamFee
587     )
588         private
589         pure
590         returns (
591             uint256,
592             uint256,
593             uint256
594         )
595     {
596         uint256 tFee = tAmount.mul(taxFee).div(100);
597         uint256 tTeam = tAmount.mul(TeamFee).div(100);
598         uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
599         return (tTransferAmount, tFee, tTeam);
600     }
601 
602     function _getRValues(
603         uint256 tAmount,
604         uint256 tFee,
605         uint256 tTeam,
606         uint256 currentRate
607     )
608         private
609         pure
610         returns (
611             uint256,
612             uint256,
613             uint256
614         )
615     {
616         uint256 rAmount = tAmount.mul(currentRate);
617         uint256 rFee = tFee.mul(currentRate);
618         uint256 rTeam = tTeam.mul(currentRate);
619         uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
620         return (rAmount, rTransferAmount, rFee);
621     }
622 
623     function _getRate() private view returns (uint256) {
624         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
625         return rSupply.div(tSupply);
626     }
627 
628     function _getCurrentSupply() private view returns (uint256, uint256) {
629         uint256 rSupply = _rTotal;
630         uint256 tSupply = _tTotal;
631         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
632         return (rSupply, tSupply);
633     }
634 
635     function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
636         require(maxTxPercent > 0, "Amount must be greater than 0");
637         _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);
638         emit MaxTxAmountUpdated(_maxTxAmount);
639     }
640 }