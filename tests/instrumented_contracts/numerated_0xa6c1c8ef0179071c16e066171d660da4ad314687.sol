1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/OfficeHours.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author 0xBasset | Taken from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ncontract OfficeHours {\n\n    bytes32 constant public SALT = 0x30eaf58a3f477568e3a7924cf0a948bb5f3b8066d23d3667392501f4a858e012;\n\n    uint256 constant ONE_PERCENT  = type(uint256).max / 100;\n    uint256 constant MAX_PER_USER = 2;\n    \n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name   = \"Office Hours\";\n    string public symbol = \"OfficeHrs\";\n\n    /*//////////////////////////////////////////////////////////////\n                      STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n    address public calendar;\n    address public renderer;\n\n    uint256 public maxSupply = 3000;\n    uint256 public totalSupply;\n\n    mapping(uint256 => Data)        internal _tokenData;\n    mapping(address => AddressData) internal _balanceOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    struct Data { address owner; Details details; }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 minted;\n    }\n\n    struct Details {\n        uint8 profession;     // The profession gives work structure\n        uint8 timezone;       // The timezone where the worker is\n        uint40 overtimeUntil; // The timestamp up until this token is on overtime\n        uint40 hourlyRate;    // How much it costs to pay for overtime\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() { owner = msg.sender; }\n\n    /*//////////////////////////////////////////////////////////////\n                              OFFICE HOURS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /* \n        -------- HOW TO MINT -----------\n        \n        To keep bots away, I'm using a special function to generate a specific salt for each address.\n        If you wish to mint, you need to perform a series of hashing functions to correctly get the salt.\n\n        To do that, head to: https://emn178.github.io/online-tools/keccak_256.html\n\n        You will need to paste your wallet address into the input field and, in a new line, paste the SALT stored in this contract.\n        In the output box, a new hash will be generated. Copy this hash and and replace the SALT in the input box.\n\n        You need to do that 5 times and the resulting hash is the one used on this function.\n\n        IMPORTANT: Your wallet address needs to be checksummed! To do that, head to: https://ethsum.netlify.app/\n\n        Let's go over one example:\n        The wallet address is: 0xcA75e8851A68B0350fF5f1A3Ea488aEE37806e91\n        The SALT is:  0x30eaf58a3f477568e3a7924cf0a948bb5f3b8066d23d3667392501f4a858e012\n\n        The first resulting hash is: 006c3df3e6c09af250806f3d4e0404a09014cebb82797b2d847768b038efb64a\n        then we past that with the address (without the 0x prefix). It'll look like this in the input box:\n\n        ------\n        0xcA75e8851A68B0350fF5f1A3Ea488aEE37806e91\n        006c3df3e6c09af250806f3d4e0404a09014cebb82797b2d847768b038efb64a\n        ------\n\n        2nd hash: 0b3b215f050f734065c82dedffcb8f40e4e174e7cf75544ddf6a820cc8befcaf\n\n        3rd hash: 84093493c9ee89335ebcdb9301dc7e8aad05880820d23a8c87faed9fb2687d5b\n\n        4th hash: 851ecca06644e3e0182c78214ae714a926fa397574a0a7d7804ce13ac7d34ae4\n\n        5th hash: d4cfd9ef869cbb015fc9d53e3157f5fcdf3239efc6566d922a977ded118f9fe5.\n\n        The 5th hash will be the input used to mint!\n    */\n    function mint(uint256 amount, bytes32 salt) external {\n        require(msg.sender == tx.origin,                                \"not allowed\");\n        require(totalSupply + amount <= maxSupply,                      \"max supply reached\");\n        require(_balanceOf[msg.sender].minted + amount <= MAX_PER_USER, \"already minted\");\n\n        // Verifying salt\n        bytes32 currentHash = SALT;\n        for (uint256 i = 0; i < 5; i++) {\n            currentHash = keccak256(abi.encode(msg.sender, \"/n\", currentHash));\n        }\n\n        require(salt != bytes32(0), \"invalid salt\");\n\n        // Mint the token\n        _safeMint(msg.sender);\n    }\n\n    function zMint(uint256 amount, address to) external {\n        require(msg.sender == owner, \"not allowed\");\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(to);\n        }\n    } \n\n    function payOvertime(uint256 tokenId_) external payable { \n        uint256 hourlyRate = uint256(_tokenData[tokenId_].details.hourlyRate) * 1e16;\n        require(msg.value >= hourlyRate, \"Less than 1 hour\");\n        require(hourlyRate > 0,           \"Free worker\");\n\n        uint256 overtime = msg.value / (hourlyRate / 1 hours);\n        _tokenData[tokenId_].details.overtimeUntil += uint40(overtime);\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                              ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function setRenderer(address rend_) external {\n        require(msg.sender == owner, \"not owner\");\n        renderer = rend_;\n    }\n\n    function setCalendar(address cal_) external {\n        require(msg.sender == owner, \"not owner\");\n        calendar = cal_;\n    }\n\n    function withdraw(address recipient) external {\n        require(msg.sender == owner, \"not owner\");\n        (bool succ, ) = payable(recipient).call{value: address(this).balance }(\"\");\n        require(succ, \"withdraw failed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner_ = _tokenData[id].owner;\n\n        require(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner_, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    // Being sneaky to try stopping bots.\n    function mintOdd(uint256 amount, uint256 verification) external {\n        require(msg.sender == tx.origin,                                \"not allowed\");\n        require(verification == uint16(uint160(msg.sender)),            \"wrong verification\");\n        require(verification % 2 == 1,                                  \"wrong function\");\n        require(totalSupply + amount <= maxSupply,                      \"max supply reached\");\n        require(_balanceOf[msg.sender].minted + amount <= MAX_PER_USER, \"already minted\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(msg.sender);\n        }\n    } \n\n    function mintEven(uint256 amount, uint256 verification) external {\n        require(msg.sender == tx.origin,                                \"not allowed\");\n        require(verification == uint16(uint160(msg.sender)),            \"wrong verification\");\n        require(verification % 2 == 0,                                  \"wrong function\");\n        require(totalSupply + amount <= maxSupply,                      \"max supply reached\");\n        require(_balanceOf[msg.sender].minted + amount <= MAX_PER_USER, \"already minted\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(msg.sender);\n        }\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        _balanceOf[msg.sender].balance -= uint128(amount);\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            _balanceOf[to].balance += uint128(amount);\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _tokenData[id].owner, \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        Details memory details = _tokenData[id].details;\n        require(CalendarLike(calendar).canTransfer(details.profession, details.timezone, details.overtimeUntil), \"NOT_ON_DUTY\");\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from].balance--;\n\n            _balanceOf[to].balance++;\n        }\n\n        _tokenData[id].owner = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    uint256 public peopleTryingToBot;\n\n    function _safeMint(address ) internal {\n        peopleTryingToBot++;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 id) public view returns (string memory) {\n        Details memory details = _tokenData[id].details;\n        return RendererLike(renderer).getURI(id, details.profession, details.timezone, details.hourlyRate);\n    }\n\n    function ownerOf(uint256 id) public view virtual returns (address owner_) {\n        Details memory details = _tokenData[id].details;\n        require(CalendarLike(calendar).canTransfer(details.profession, details.timezone, details.overtimeUntil), \"NOT_ON_DUTY\");\n\n        require((owner_ = _tokenData[id].owner) != address(0), \"NOT_MINTED\");\n    }\n\n    function actualOwnerOf(uint256 id) public view virtual returns (address owner_) {\n        require((owner_ = _tokenData[id].owner) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner_) public view virtual returns (uint256) {\n        require(owner_ != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner_].balance;\n    }\n\n    function minted(address owner_) public view virtual returns (uint256) {\n        require(owner_ != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner_].minted;\n    }\n\n    function getDatails(uint256 id_) public view returns (uint256 profession_, uint256 location_, uint256 rate_, uint256 overtime_) {\n        Details memory details = _tokenData[id_].details;\n\n        profession_ = details.profession;\n        location_   = details.timezone;\n        rate_       = details.hourlyRate;\n        overtime_   = details.overtimeUntil;\n    }\n\n    function canTransfer(uint256 id_) public view returns (bool) {\n        Details memory details = _tokenData[id_].details;\n        return CalendarLike(calendar).canTransfer(details.profession, details.timezone, details.overtimeUntil);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n     function _mint(address account) internal {\n        // Generate token\n        uint256 id = ++totalSupply;\n\n        // Not the strongest entropy, but good enough for a mint\n        uint256 entropy = uint256(keccak256(abi.encode(account, block.coinbase, id, \"entropy\")));\n\n        // Generate traits\n        uint8 timezone = uint8(uint256(keccak256(abi.encode(entropy, \"TIMEZONE\"))) % 25) + 1;\n\n        uint256 profEntropy =  uint256(uint256(keccak256(abi.encode(entropy, \"PROF\"))));\n\n        uint8 profession = uint8(\n            // If entropy smaller than 50%\n            profEntropy <= 70 * ONE_PERCENT ? (profEntropy % 15) + 1 : \n            // If entropy between 50% and 85%\n            profEntropy <= 93 * ONE_PERCENT ? (profEntropy % 10) + 16 :\n            // If entropy between 85% and 98%\n            profEntropy <= (99 * ONE_PERCENT ) + (ONE_PERCENT / 2) ? (profEntropy % 6) + 26 :\n            // Else, select one of the rares\n            profEntropy % 6 + 32);\n\n        (uint8 start, uint8 end) = CalendarLike(calendar).rates(profession);\n\n        uint8 rate = (uint8(entropy) % (end - start)) + start;\n        \n        _tokenData[id].details.timezone      = timezone;\n        _tokenData[id].details.profession    = profession;\n        _tokenData[id].details.hourlyRate    = rate;\n        _tokenData[id].details.overtimeUntil = uint40(block.timestamp + 4 hours);\n\n        _mint(account, id);\n    }\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_tokenData[id].owner == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to].balance++;\n            _balanceOf[to].minted++;\n        }\n\n        _tokenData[id].owner = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner_ = _tokenData[id].owner;\n\n        require(owner_ != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner_].balance--;\n        }\n\n        delete _tokenData[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner_, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ninterface CalendarLike {\n    function canTransfer(uint256 profession, uint256 timezone, uint256 overtimeUntil) external view returns(bool);\n    function rates(uint256 profId) external pure returns(uint8 start, uint8 end);\n}\n\ninterface RendererLike {\n    function getURI(uint256 id, uint256 profession, uint256 timezone, uint256 hourlyRate) external pure returns(string memory uri);\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}