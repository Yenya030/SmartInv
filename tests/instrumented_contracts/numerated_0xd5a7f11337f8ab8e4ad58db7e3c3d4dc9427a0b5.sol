1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/MonsterZoneLandPayment.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ninterface IERC20 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IERC721 {\n    function mint(address to, uint256 tokenId) external;\n}\n\ncontract MonsterZoneLandPayment is AccessControl, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PRICE_UPDATER_ROLE = keccak256(\"PRICE_UPDATER_ROLE\");\n\n    IERC20 private TVK;\n    IERC721 private NFT;\n\n    uint256 private totalSupply;\n    uint256 private cappedSupply;\n    uint256 private slotCount;\n    uint256 private TVKperUSDprice;\n    uint256 private ETHperUSDprice;\n\n    address private signatureAddress;\n    address payable private withdrawAddress;\n\n    bool private ethPaymentEnabled;\n    bool private tvkPaymentEnabled;\n\n    mapping(string => categoryDetail) private landCategory;\n    mapping(uint256 => slotDetails) private slot;\n    mapping(bytes => bool) private signatures;\n\n    struct categoryDetail {\n        uint256 priceInUSD;\n        uint256 mintedCategorySupply;\n        uint256 maxCategorySupply;\n        uint256 startRange;\n        uint256 endRange;\n        bool status;\n        bool slotIndependent;\n    }\n\n    struct slotDetails {\n        uint256 startTime;\n        uint256 endTime;\n        mapping(string => slotCategoryDetails) slotSupply;\n    }\n\n    struct slotCategoryDetails {\n        uint256 maxSlotCategorySupply;\n        uint256 mintedSlotCategorySupply;\n    }\n\n    event landBoughtWithTVK(\n        uint256 indexed tokenId,\n        uint256 indexed price,\n        address indexed beneficiary,\n        string category,\n        uint256 slot,\n        bytes signature\n    );\n\n    event landBoughtWithETH(\n        uint256 indexed tokenId,\n        uint256 indexed price,\n        address indexed beneficiary,\n        string category,\n        uint256 slot,\n        bytes signature\n    );\n\n    event adminMintedItem(\n        string category,\n        uint256[] tokenId,\n        address[] beneficiary\n    );\n    event newLandCategoryAdded(\n        string indexed category,\n        uint256 indexed price,\n        uint256 indexed maxCategorySupply\n    );\n    event newSlotAdded(\n        uint256 indexed slot,\n        uint256 indexed startTime,\n        uint256 indexed endTime,\n        string[] category,\n        uint256[] slotSupply\n    );\n    event TVKperUSDpriceUpdated(uint256 indexed price);\n    event ETHperUSDpriceUpdated(uint256 indexed price);\n    event landCategoryPriceUpdated(\n        string indexed category,\n        uint256 indexed price\n    );\n    event categoryAvailabilityInSlotUpdated(\n        string indexed category,\n        uint256 indexed slot,\n        uint256 indexed slotSupply\n    );\n    event slotStartTimeUpdated(uint256 indexed slot, uint256 indexed startTime);\n    event slotEndTimeUpdated(uint256 indexed slot, uint256 indexed endTime);\n    event signatureAddressUpdated(address indexed newAddress);\n    event TVKAddressUpdated(address indexed newAddress);\n    event NFTAddressUpdated(address indexed newAddress);\n    event withdrawAddressUpdated(address indexed newAddress);\n    event ETHFundsWithdrawn(uint256 indexed amount);\n    event TVKFundsWithdrawn(uint256 indexed amount);\n\n    constructor(\n        address _TVKaddress,\n        address _NFTaddress,\n        address payable _withdrawAddress,\n        string[] memory _category,\n        bool[] memory _slotDependency,\n        uint256[][] memory _categoryDetail,\n        uint256[][] memory _slot,\n        uint256[][] memory _slotSupply\n    ) {\n        TVK = IERC20(_TVKaddress);\n        NFT = IERC721(_NFTaddress);\n        signatureAddress = 0xE3066b8a680B562Cc2B53f9542361078c666dE15;\n        withdrawAddress = _withdrawAddress;\n        TVKperUSDprice = 26470588235294116000; \n        ETHperUSDprice = 785064924869286; \n        cappedSupply = 6002;\n        totalSupply = 0;\n        ethPaymentEnabled = true;\n        tvkPaymentEnabled = true;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(ADMIN_ROLE, 0x6AB132Cf61F582535397fc7E36089DD49Fef5C59);\n        _setupRole(MINTER_ROLE, 0x93BD8b204D06C4510400048781cc279Baf8480e7);\n        _setupRole(PRICE_UPDATER_ROLE, 0xC9953804913e7092668487B49a2acd259217D2eD);\n\n        for (uint256 index = 0; index < _category.length; index++) {\n            landCategory[_category[index]].priceInUSD = _categoryDetail[index][\n                0\n            ].mul(1 ether);\n            landCategory[_category[index]].status = true;\n            landCategory[_category[index]].maxCategorySupply = _categoryDetail[\n                index\n            ][1];\n            landCategory[_category[index]].slotIndependent = _slotDependency[\n                index\n            ];\n            landCategory[_category[index]].startRange = _categoryDetail[index][\n                2\n            ];\n            landCategory[_category[index]].endRange = _categoryDetail[index][3];\n        }\n\n        for (uint256 index = 0; index < _slot.length; index++) {\n            slot[_slot[index][0]].startTime = _slot[index][1];\n            slot[_slot[index][0]].endTime = _slot[index][2];\n\n            slotCount++;\n\n            slot[_slot[index][0]]\n                .slotSupply[_category[0]]\n                .maxSlotCategorySupply = _slotSupply[index][0];\n            slot[_slot[index][0]]\n                .slotSupply[_category[1]]\n                .maxSlotCategorySupply = _slotSupply[index][1];\n            slot[_slot[index][0]]\n                .slotSupply[_category[2]]\n                .maxSlotCategorySupply = _slotSupply[index][2];\n            slot[_slot[index][0]]\n                .slotSupply[_category[3]]\n                .maxSlotCategorySupply = _slotSupply[index][3];\n            slot[_slot[index][0]]\n                .slotSupply[_category[4]]\n                .maxSlotCategorySupply = _slotSupply[index][4];\n        }\n    }\n\n    function buyLandWithTVK(\n        uint256 _slot,\n        string memory _category,\n        uint256 _tokenId,\n        bytes32 _hash,\n        bytes memory _signature\n    ) public {\n        uint256 _price = getlandPriceInTVK(_category);\n        require(tvkPaymentEnabled, \"Landsale: TVK payment disabled!\");\n        require(\n            block.timestamp >= slot[1].startTime,\n            \"LandSale: Sale not started yet!\"\n        );\n        require(landCategory[_category].status, \"Landsale: Invalid caetgory!\");\n        require(\n            _tokenId >= landCategory[_category].startRange &&\n                _tokenId <= landCategory[_category].endRange,\n            \"Landsale: Invalid token id for category range!\"\n        );\n        require(\n            recover(_hash, _signature) == signatureAddress,\n            \"Landsale: Invalid signature!\"\n        );\n        require(!signatures[_signature], \"Landsale: Signature already used!\");\n        require(\n            TVK.allowance(msg.sender, address(this)) >= _price,\n            \"Landsale: Allowance to spend token not enough!\"\n        );\n\n        TVK.transferFrom(msg.sender, address(this), _price);\n\n        slotValidation(_slot, _category, _tokenId, msg.sender);\n\n        signatures[_signature] = true;\n\n        emit landBoughtWithTVK(\n            _tokenId,\n            _price,\n            msg.sender,\n            _category,\n            _slot,\n            _signature\n        );\n    }\n\n    function buyLandWithETH(\n        uint256 _slot,\n        string memory _category,\n        uint256 _tokenId,\n        bytes32 _hash,\n        bytes memory _signature\n    ) public payable {\n        require(ethPaymentEnabled, \"Landsale: Eth payment disabled!\");\n        require(\n            block.timestamp >= slot[1].startTime,\n            \"LandSale: Sale not started yet!\"\n        );\n        require(\n            msg.value == getlandPriceInETH(_category),\n            \"Landsale: Invalid payment!\"\n        );\n        require(landCategory[_category].status, \"Landsale: Invalid caetgory!\");\n        require(\n            _tokenId >= landCategory[_category].startRange &&\n                _tokenId <= landCategory[_category].endRange,\n            \"Landsale! Invalid token id for category range!\"\n        );\n        require(\n            recover(_hash, _signature) == signatureAddress,\n            \"Landsale: Invalid signature!\"\n        );\n        require(!signatures[_signature], \"Landsale: Signature already used!\");\n\n        slotValidation(_slot, _category, _tokenId, msg.sender);\n\n        signatures[_signature] = true;\n\n        emit landBoughtWithETH(\n            _tokenId,\n            msg.value,\n            msg.sender,\n            _category,\n            _slot,\n            _signature\n        );\n    }\n\n    function adminMint(\n        uint256[] memory _tokenId,\n        string memory _category,\n        address[] memory _beneficiary\n    ) public {\n        require(\n            hasRole(MINTER_ROLE, _msgSender()),\n            \"Landsale: Must have price update role to mint.\"\n        );\n        require(landCategory[_category].status, \"Landsale: Invalid caetgory!\");\n        require(\n            landCategory[_category].mintedCategorySupply.add(_tokenId.length) <=\n                landCategory[_category].maxCategorySupply,\n            \"LandSale: Max category supply reached!\"\n        );\n        require(\n            totalSupply.add(_tokenId.length) <= cappedSupply,\n            \"Landsale: Max total supply reached!\"\n        );\n        require(\n            _tokenId.length == _beneficiary.length,\n            \"Landsale: Token ids and beneficiary addresses are not equal.\"\n        );\n\n        for (uint256 index = 0; index < _tokenId.length; index++) {\n            NFT.mint(_beneficiary[index], _tokenId[index]);\n        }\n\n        landCategory[_category].mintedCategorySupply = landCategory[_category]\n            .mintedCategorySupply\n            .add(_tokenId.length);\n        totalSupply = totalSupply.add(_tokenId.length);\n\n        emit adminMintedItem(_category, _tokenId, _beneficiary);\n    }\n\n    function slotValidation(\n        uint256 _slot,\n        string memory _category,\n        uint256 _tokenId,\n        address _beneficiary\n    ) internal {\n        if (landCategory[_category].slotIndependent) {\n            mintToken(_slot, _category, _tokenId, _beneficiary);\n        } else if (\n            block.timestamp >= slot[_slot].startTime &&\n            block.timestamp <= slot[_slot].endTime\n        ) {\n            require(\n                slot[_slot].slotSupply[_category].maxSlotCategorySupply > 0,\n                \"Landsale: This land category cannot be bought in this slot!\"\n            );\n\n            mintToken(_slot, _category, _tokenId, _beneficiary);\n        } else if (block.timestamp > slot[_slot].endTime) {\n            revert(\"Landsale: Slot ended!\");\n        } else if (block.timestamp < slot[_slot].startTime) {\n            revert(\"Landsale: Slot not started yet!\");\n        }\n    }\n\n    function mintToken(\n        uint256 _slot,\n        string memory _category,\n        uint256 _tokenId,\n        address _beneficiary\n    ) internal {\n        require(\n            landCategory[_category].mintedCategorySupply.add(1) <=\n                landCategory[_category].maxCategorySupply,\n            \"LandSale: Max category supply reached!\"\n        );\n        require(\n            slot[_slot].slotSupply[_category].mintedSlotCategorySupply.add(1) <=\n                slot[_slot].slotSupply[_category].maxSlotCategorySupply,\n            \"Landsale: Max slot category supply reached!\"\n        );\n        require(\n            totalSupply.add(1) <= cappedSupply,\n            \"Landsale: Max total supply reached!\"\n        );\n\n        slot[_slot].slotSupply[_category].mintedSlotCategorySupply++;\n        landCategory[_category].mintedCategorySupply++;\n        totalSupply++;\n\n        NFT.mint(_beneficiary, _tokenId);\n    }\n\n    function setEthPaymentToggle() public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to set eth toggle.\"\n        );\n        if (ethPaymentEnabled) {\n            ethPaymentEnabled = false;\n        } else {\n            ethPaymentEnabled = true;\n        }\n    }\n\n    function setTvkPaymentToggle() public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to set tvk toggle.\"\n        );\n        if (tvkPaymentEnabled) {\n            tvkPaymentEnabled = false;\n        } else {\n            tvkPaymentEnabled = true;\n        }\n    }\n\n    function addNewLandCategory(\n        string memory _category,\n        bool _slotIndependency,\n        uint256 _priceInUSD,\n        uint256 _maxCategorySupply,\n        uint256 _categoryStartRange,\n        uint256 _categoryEndRange\n    ) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to add new land category.\"\n        );\n        require(\n            landCategory[_category].status == false,\n            \"LandSale: Category already exist!\"\n        );\n        require(_priceInUSD > 0, \"LandSale: Invalid price in TVK!\");\n        require(_maxCategorySupply > 0, \"LandSale: Invalid max Supply!\");\n        require(_categoryStartRange <= _categoryEndRange , \"LandSale: Start range must be smaller than or equal to end range!\");\n        require(_categoryStartRange > 0, \"LandSale: Start range must be greater than 0!\");\n        require(_categoryEndRange > 0, \"LandSale: End range must be greater than 0!\");        \n\n        landCategory[_category].priceInUSD = _priceInUSD.mul(1 ether);\n        landCategory[_category].status = true;\n        landCategory[_category].maxCategorySupply = _maxCategorySupply;\n        landCategory[_category].slotIndependent = _slotIndependency;\n        landCategory[_category].startRange = _categoryStartRange;\n        landCategory[_category].endRange = _categoryEndRange;\n\n        cappedSupply = cappedSupply.add(_maxCategorySupply);\n\n        for (uint256 index = 1; index <= slotCount; index++) {\n            slot[index]\n                .slotSupply[_category]\n                .maxSlotCategorySupply = _maxCategorySupply;\n        }\n\n        emit newLandCategoryAdded(_category, _priceInUSD, _maxCategorySupply);\n    }\n\n    function addNewSlot(\n        uint256 _slot,\n        uint256 _startTime,\n        uint256 _endTime,\n        string[] memory _category,\n        uint256[] memory _slotSupply\n    ) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to add new slot.\"\n        );\n        require(_slot == slotCount.add(1), \"Landsale: New slot should increment of last slot.\");\n        require(_startTime >= block.timestamp, \"Landsale: Invalid start time!\");\n        require(_endTime > _startTime, \"Landsale: Invalid end time!\");\n        require(\n            _category.length == _slotSupply.length,\n            \"Landsale: Invalid length of category and status!\"\n        );\n\n        slot[_slot].startTime = _startTime;\n        slot[_slot].endTime = _endTime;\n\n        for (uint256 index = 0; index < _category.length; index++) {\n            slot[_slot]\n                .slotSupply[_category[index]]\n                .maxSlotCategorySupply = _slotSupply[index];\n        }\n        slotCount++;\n\n        emit newSlotAdded(_slot, _startTime, _endTime, _category, _slotSupply);\n    }\n\n    function updateTVKperUSDprice(uint256 _TVKperUSDprice) public {\n        require(\n            hasRole(PRICE_UPDATER_ROLE, _msgSender()),\n            \"Landsale: Must have price updater role to update tvk price\"\n        );\n        require(_TVKperUSDprice > 0, \"Landsale: Invalid price!\");\n        require(_TVKperUSDprice != TVKperUSDprice , \"Landsale: TVK price already same.\");\n\n        TVKperUSDprice = _TVKperUSDprice;\n\n        emit TVKperUSDpriceUpdated(_TVKperUSDprice);\n    }\n\n    function updateETHperUSDprice(uint256 _ETHperUSDprice) public {\n        require(\n            hasRole(PRICE_UPDATER_ROLE, _msgSender()),\n            \"Landsale: Must have price updater role to update eth price\"\n        );\n        require(_ETHperUSDprice > 0, \"Landsale: Invalid price!\");\n        require(_ETHperUSDprice != ETHperUSDprice, \"Landsale: ETH price already same\");\n\n        ETHperUSDprice = _ETHperUSDprice;\n\n        emit ETHperUSDpriceUpdated(_ETHperUSDprice);\n    }\n\n    function updateLandCategoryPriceInUSD(\n        string memory _category,\n        uint256 _price\n    ) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to update category price.\"\n        );\n        require(\n            landCategory[_category].status == true,\n            \"LandSale: Non-Existing category!\"\n        );\n        require(_price > 0, \"LandSale: Invalid price!\");\n\n        landCategory[_category].priceInUSD = _price.mul(1 ether); \n\n        emit landCategoryPriceUpdated(_category, _price);\n    }\n\n    function updateCategorySupplyInSlot(\n        string memory _category,\n        uint256 _slot,\n        uint256 _slotSupply\n    ) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to update category supply in slot.\"\n        );\n        require(landCategory[_category].status, \"Landsale: Invalid category!\");\n        require(\n            landCategory[_category].maxCategorySupply >= _slotSupply,\n            \"LandSale: Slot supply cannot be greater than max category supply!\"\n        );\n\n        slot[_slot].slotSupply[_category].maxSlotCategorySupply = _slotSupply;\n\n        emit categoryAvailabilityInSlotUpdated(_category, _slot, _slotSupply);\n    }\n\n    function updateSlotStartTime(uint256 _slot, uint256 _startTime) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to update slot time\"\n        );\n        require(_slot > 0 && _slot <= slotCount, \"Landsale: Invalid slot!\");\n        require(_startTime > block.timestamp, \"Landsale: Invalid start time!\");\n\n        slot[_slot].startTime = _startTime;\n\n        emit slotStartTimeUpdated(_slot, _startTime);\n    }\n\n    function updateSlotEndTime(uint256 _slot, uint256 _endTime) public {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to update slot time\"\n        );\n        require(_slot > 0 && _slot <= slotCount, \"Landsale: Invalid slot!\");\n        require(_endTime > slot[_slot].startTime, \"Landsale: Invalid start time!\");\n\n        slot[_slot].endTime = _endTime;\n\n        emit slotEndTimeUpdated(_slot, _endTime);\n    }\n\n    function updateSignatureAddress(address _signatureAddress)\n        public\n        onlyOwner\n    {\n        require(_signatureAddress != address(0), \"Landsale: Invalid address!\");\n        require(_signatureAddress != signatureAddress, \"Landsale: Address already exist.\");\n\n        signatureAddress = _signatureAddress;\n\n        emit signatureAddressUpdated(_signatureAddress);\n    }\n\n    function updateTVKAddress(address _address) public onlyOwner {\n        require(_address != address(0), \"Landsale: Invalid address!\");\n        require(IERC20(_address) != TVK, \"Landsale: Address already exist.\");\n        TVK = IERC20(_address);\n\n        emit TVKAddressUpdated(_address);\n    }\n\n    function updateNFTAddress(address _address) public onlyOwner {\n        require(_address != address(0), \"Landsale: Invalid address!\");\n        require(IERC721(_address) != NFT, \"Landsale: Address already exist.\");\n\n        NFT = IERC721(_address);\n\n        emit NFTAddressUpdated(_address);\n    }\n\n    function updateWithdrawAddress(address payable _withdrawAddress)\n        public\n        onlyOwner\n    {\n        require(_withdrawAddress != address(0), \"Landsale: Invalid address!\");\n        require(_withdrawAddress != withdrawAddress, \"Landsale: Address already exist.\");\n        withdrawAddress = _withdrawAddress;\n\n        emit withdrawAddressUpdated(_withdrawAddress);\n    }\n\n    function withdrawEthFunds() public onlyOwner nonReentrant {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"Dapp: invalid amount.\");\n        withdrawAddress.transfer(amount);\n\n        emit ETHFundsWithdrawn(amount);\n    }\n\n    function withdrawTokenFunds() public onlyOwner nonReentrant {\n        uint256 amount = TVK.balanceOf(address(this));\n        require(amount > 0, \"Landsale: invalid amount!\");\n        TVK.transfer(withdrawAddress, amount);\n\n        emit TVKFundsWithdrawn(amount);\n    }\n\n    function updateCategoryToSlotIndependent(\n        string memory _category,\n        bool _slotDependency\n    ) public  {\n        require(\n            hasRole(ADMIN_ROLE, _msgSender()),\n            \"Landsale: Must have admin role to add new land category.\"\n        );\n        require(landCategory[_category].status, \"Landsale: Invlaid category!\");\n\n        landCategory[_category].slotIndependent = _slotDependency;\n    }\n\n    function getTokenBalance() public view returns (uint256) {\n        return TVK.balanceOf(address(this));\n    }\n\n    function getWithdrawAddress() public view returns (address) {\n        return withdrawAddress;\n    }\n\n    function getSignatureAddress()\n        public\n        view\n        returns (address _signatureAddress)\n    {\n        _signatureAddress = signatureAddress;\n    }\n\n    function getTVKAddress() public view returns (IERC20 _TVK) {\n        _TVK = TVK;\n    }\n\n    function getNFTAddress() public view returns (IERC721 _NFT) {\n        _NFT = NFT;\n    }\n\n    function getSlotStartTimeAndEndTime(uint256 _slot)\n        public\n        view\n        returns (uint256 _startTime, uint256 _endTime)\n    {\n        _startTime = slot[_slot].startTime;\n        _endTime = slot[_slot].endTime;\n    }\n\n    function getCategorySupplyBySlot(string memory _category, uint256 _slot)\n        public\n        view\n        returns (uint256 _slotSupply)\n    {\n        _slotSupply = slot[_slot].slotSupply[_category].maxSlotCategorySupply;\n    }\n\n    function getCategoryDetails(string memory _category)\n        public\n        view\n        returns (\n            uint256 _priceInUSD,\n            uint256 _maxSlotCategorySupply,\n            uint256 _mintedCategorySupply,\n            bool _status,\n            bool _slotIndependent\n        )\n    {\n        _priceInUSD = landCategory[_category].priceInUSD;\n        _mintedCategorySupply = landCategory[_category].mintedCategorySupply;\n        _maxSlotCategorySupply = landCategory[_category].maxCategorySupply;\n        _status = landCategory[_category].status;\n        _slotIndependent = landCategory[_category].slotIndependent;\n    }\n\n    function getCategoryRanges(string memory _category)\n        public\n        view\n        returns (uint256 _startRange, uint256 _endRange)\n    {\n        _startRange = landCategory[_category].startRange;\n        _endRange = landCategory[_category].endRange;\n    }\n\n    function getlandPriceInTVK(string memory _category)\n        public\n        view\n        returns (uint256 _price)\n    {\n        _price = (landCategory[_category].priceInUSD.mul(TVKperUSDprice)).div(\n            1 ether\n        );\n    }\n\n    function getlandPriceInETH(string memory _category)\n        public\n        view\n        returns (uint256 _price)\n    {\n        _price = (landCategory[_category].priceInUSD.mul(ETHperUSDprice)).div(\n            1 ether\n        );\n    }\n\n    function checkSignatureValidity(bytes memory _signature)\n        public\n        view\n        returns (bool)\n    {\n        return signatures[_signature];\n    }\n\n    function getTotalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n\n    function getCappedSupply() public view returns (uint256) {\n        return cappedSupply;\n    }\n\n    function getSlotCount() public view returns (uint256) {\n        return slotCount;\n    }\n\n    function getTVKperUSDprice() public view returns (uint256) {\n        return TVKperUSDprice;\n    }\n\n    function getETHperUSDprice() public view returns (uint256) {\n        return ETHperUSDprice;\n    }\n\n    function getETHPaymentEnabled() public view returns (bool) {\n        return ethPaymentEnabled;\n    }\n\n    function getTVKPaymentEnabled() public view returns (bool) {\n        return tvkPaymentEnabled;\n    }\n\n    function recover(bytes32 _hash, bytes memory _signature)\n        public\n        pure\n        returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (_signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(_signature, 0x20))\n            s := mload(add(_signature, 0x40))\n            v := byte(0, mload(add(_signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(_hash, v, r, s);\n        }\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/math/SafeMath.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
12     },
13     "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
15     },
16     "@openzeppelin/contracts/utils/Strings.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Context.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
24     },
25     "@openzeppelin/contracts/access/Ownable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/access/AccessControl.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
30     }
31   },
32   "settings": {
33     "remappings": [],
34     "optimizer": {
35       "enabled": true,
36       "runs": 200
37     },
38     "evmVersion": "byzantium",
39     "libraries": {},
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "devdoc",
46           "userdoc",
47           "metadata",
48           "abi"
49         ]
50       }
51     }
52   }
53 }}