1 // $AstroLion | AstroLion Token
2 // Designed by @TristenEscolastico / Tristen Esco
3 // TG: t.me/AstroLionToken
4 // Web: https://astrolion.net
5 // Community Play
6 
7 // Audit & Fair Launch handled by FairLaunchCalls
8 // TG: t.me/FairLaunchCalls
9 // Twitter: FairLaunchCalls
10 // Always verify our contracts are legit on TG/Twitter before trading.
11 
12 // Fair Launch, no Dev Tokens. 98% LP, 2% to @TristenEscolastico / Tristen Esco
13 // Snipers will be nuked.
14 
15 // LP Burn immediately on launch.
16 // Ownership will be renounced after launch & botwave bans.
17 
18 // Slippage Recommended: 10%+
19 // 5% Supply limit per TX
20 
21 /**
22  *  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿
23  *  ⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
24  *  ⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
25  *  ⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
26  *  ⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
27  *  ⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
28  *  ⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
29  *  ⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
30  *  ⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
31  *  ⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
32  *  ⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
33  *  ⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
34  *  ⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
35  *  ⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
36  *  ⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
37  *  ⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
38  *  ⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
39  *  ⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
40  *  ⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
41  *  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
42  *  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
43  *  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
44  *  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
45  *  ⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
46  *  ⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄
47 */
48 
49 // SPDX-License-Identifier: Unlicensed
50 pragma solidity ^0.6.12;
51 
52 abstract contract Context {
53     function _msgSender() internal view virtual returns (address payable) {
54         return msg.sender;
55     }
56 
57     function _msgData() internal view virtual returns (bytes memory) {
58         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
59         return msg.data;
60     }
61 }
62 
63 interface IERC20 {
64     /**
65     * @dev Returns the amount of tokens in existence.
66     */
67     function totalSupply() external view returns (uint256);
68 
69     /**
70     * @dev Returns the amount of tokens owned by `account`.
71     */
72     function balanceOf(address account) external view returns (uint256);
73 
74     /**
75     * @dev Moves `amount` tokens from the caller's account to `recipient`.
76     *
77     * Returns a boolean value indicating whether the operation succeeded.
78     *
79     * Emits a {Transfer} event.
80     */
81     function transfer(address recipient, uint256 amount) external returns (bool);
82 
83     /**
84     * @dev Returns the remaining number of tokens that `spender` will be
85     * allowed to spend on behalf of `owner` through {transferFrom}. This is
86     * zero by default.
87     *
88     * This value changes when {approve} or {transferFrom} are called.
89     */
90     function allowance(address owner, address spender) external view returns (uint256);
91 
92     /**
93     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
94     *
95     * Returns a boolean value indicating whether the operation succeeded.
96     *
97     * IMPORTANT: Beware that changing an allowance with this method brings the risk
98     * that someone may use both the old and the new allowance by unfortunate
99     * transaction ordering. One possible solution to mitigate this race
100     * condition is to first reduce the spender's allowance to 0 and set the
101     * desired value afterwards:
102     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
103     *
104     * Emits an {Approval} event.
105     */
106     function approve(address spender, uint256 amount) external returns (bool);
107 
108     /**
109     * @dev Moves `amount` tokens from `sender` to `recipient` using the
110     * allowance mechanism. `amount` is then deducted from the caller's
111     * allowance.
112     *
113     * Returns a boolean value indicating whether the operation succeeded.
114     *
115     * Emits a {Transfer} event.
116     */
117     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
118 
119     /**
120     * @dev Emitted when `value` tokens are moved from one account (`from`) to
121     * another (`to`).
122     *
123     * Note that `value` may be zero.
124     */
125     event Transfer(address indexed from, address indexed to, uint256 value);
126 
127     /**
128     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
129     * a call to {approve}. `value` is the new allowance.
130     */
131     event Approval(address indexed owner, address indexed spender, uint256 value);
132 }
133 
134 library SafeMath {
135     /**
136     * @dev Returns the addition of two unsigned integers, reverting on
137     * overflow.
138     *
139     * Counterpart to Solidity's `+` operator.
140     *
141     * Requirements:
142     *
143     * - Addition cannot overflow.
144     */
145     function add(uint256 a, uint256 b) internal pure returns (uint256) {
146         uint256 c = a + b;
147         require(c >= a, "SafeMath: addition overflow");
148 
149         return c;
150     }
151 
152     /**
153     * @dev Returns the subtraction of two unsigned integers, reverting on
154     * overflow (when the result is negative).
155     *
156     * Counterpart to Solidity's `-` operator.
157     *
158     * Requirements:
159     *
160     * - Subtraction cannot overflow.
161     */
162     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
163         return sub(a, b, "SafeMath: subtraction overflow");
164     }
165 
166     /**
167     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
168     * overflow (when the result is negative).
169     *
170     * Counterpart to Solidity's `-` operator.
171     *
172     * Requirements:
173     *
174     * - Subtraction cannot overflow.
175     */
176     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
177         require(b <= a, errorMessage);
178         uint256 c = a - b;
179 
180         return c;
181     }
182 
183     /**
184     * @dev Returns the multiplication of two unsigned integers, reverting on
185     * overflow.
186     *
187     * Counterpart to Solidity's `*` operator.
188     *
189     * Requirements:
190     *
191     * - Multiplication cannot overflow.
192     */
193     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
194         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
195         // benefit is lost if 'b' is also tested.
196         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
197         if (a == 0) {
198             return 0;
199         }
200 
201         uint256 c = a * b;
202         require(c / a == b, "SafeMath: multiplication overflow");
203 
204         return c;
205     }
206 
207     /**
208     * @dev Returns the integer division of two unsigned integers. Reverts on
209     * division by zero. The result is rounded towards zero.
210     *
211     * Counterpart to Solidity's `/` operator. Note: this function uses a
212     * `revert` opcode (which leaves remaining gas untouched) while Solidity
213     * uses an invalid opcode to revert (consuming all remaining gas).
214     *
215     * Requirements:
216     *
217     * - The divisor cannot be zero.
218     */
219     function div(uint256 a, uint256 b) internal pure returns (uint256) {
220         return div(a, b, "SafeMath: division by zero");
221     }
222 
223     /**
224     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
225     * division by zero. The result is rounded towards zero.
226     *
227     * Counterpart to Solidity's `/` operator. Note: this function uses a
228     * `revert` opcode (which leaves remaining gas untouched) while Solidity
229     * uses an invalid opcode to revert (consuming all remaining gas).
230     *
231     * Requirements:
232     *
233     * - The divisor cannot be zero.
234     */
235     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
236         require(b > 0, errorMessage);
237         uint256 c = a / b;
238         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
239 
240         return c;
241     }
242 
243     /**
244     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
245     * Reverts when dividing by zero.
246     *
247     * Counterpart to Solidity's `%` operator. This function uses a `revert`
248     * opcode (which leaves remaining gas untouched) while Solidity uses an
249     * invalid opcode to revert (consuming all remaining gas).
250     *
251     * Requirements:
252     *
253     * - The divisor cannot be zero.
254     */
255     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
256         return mod(a, b, "SafeMath: modulo by zero");
257     }
258 
259     /**
260     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
261     * Reverts with custom message when dividing by zero.
262     *
263     * Counterpart to Solidity's `%` operator. This function uses a `revert`
264     * opcode (which leaves remaining gas untouched) while Solidity uses an
265     * invalid opcode to revert (consuming all remaining gas).
266     *
267     * Requirements:
268     *
269     * - The divisor cannot be zero.
270     */
271     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
272         require(b != 0, errorMessage);
273         return a % b;
274     }
275 }
276 
277 library Address {
278     /**
279     * @dev Returns true if `account` is a contract.
280     *
281     * [IMPORTANT]
282     * ====
283     * It is unsafe to assume that an address for which this function returns
284     * false is an externally-owned account (EOA) and not a contract.
285     *
286     * Among others, `isContract` will return false for the following
287     * types of addresses:
288     *
289     *  - an externally-owned account
290     *  - a contract in construction
291     *  - an address where a contract will be created
292     *  - an address where a contract lived, but was destroyed
293     * ====
294     */
295     function isContract(address account) internal view returns (bool) {
296         // According to EIP-1052, 0x0 is the value returned for not-yet created accounts
297         // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned
298         // for accounts without code, i.e. `keccak256('')`
299         bytes32 codehash;
300         bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
301         // solhint-disable-next-line no-inline-assembly
302         assembly { codehash := extcodehash(account) }
303         return (codehash != accountHash && codehash != 0x0);
304     }
305 
306     /**
307     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
308     * `recipient`, forwarding all available gas and reverting on errors.
309     *
310     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
311     * of certain opcodes, possibly making contracts go over the 2300 gas limit
312     * imposed by `transfer`, making them unable to receive funds via
313     * `transfer`. {sendValue} removes this limitation.
314     *
315     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
316     *
317     * IMPORTANT: because control is transferred to `recipient`, care must be
318     * taken to not create reentrancy vulnerabilities. Consider using
319     * {ReentrancyGuard} or the
320     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
321     */
322     function sendValue(address payable recipient, uint256 amount) internal {
323         require(address(this).balance >= amount, "Address: insufficient balance");
324 
325         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
326         (bool success, ) = recipient.call{ value: amount }("");
327         require(success, "Address: unable to send value, recipient may have reverted");
328     }
329 
330     /**
331     * @dev Performs a Solidity function call using a low level `call`. A
332     * plain`call` is an unsafe replacement for a function call: use this
333     * function instead.
334     *
335     * If `target` reverts with a revert reason, it is bubbled up by this
336     * function (like regular Solidity function calls).
337     *
338     * Returns the raw returned data. To convert to the expected return value,
339     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
340     *
341     * Requirements:
342     *
343     * - `target` must be a contract.
344     * - calling `target` with `data` must not revert.
345     *
346     * _Available since v3.1._
347     */
348     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
349         return functionCall(target, data, "Address: low-level call failed");
350     }
351 
352     /**
353     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
354     * `errorMessage` as a fallback revert reason when `target` reverts.
355     *
356     * _Available since v3.1._
357     */
358     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
359         return _functionCallWithValue(target, data, 0, errorMessage);
360     }
361 
362     /**
363     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
364     * but also transferring `value` wei to `target`.
365     *
366     * Requirements:
367     *
368     * - the calling contract must have an ETH balance of at least `value`.
369     * - the called Solidity function must be `payable`.
370     *
371     * _Available since v3.1._
372     */
373     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
374         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
375     }
376 
377     /**
378     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
379     * with `errorMessage` as a fallback revert reason when `target` reverts.
380     *
381     * _Available since v3.1._
382     */
383     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
384         require(address(this).balance >= value, "Address: insufficient balance for call");
385         return _functionCallWithValue(target, data, value, errorMessage);
386     }
387 
388     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {
389         require(isContract(target), "Address: call to non-contract");
390 
391         // solhint-disable-next-line avoid-low-level-calls
392         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);
393         if (success) {
394             return returndata;
395         } else {
396             // Look for revert reason and bubble it up if present
397             if (returndata.length > 0) {
398                 // The easiest way to bubble the revert reason is using memory via assembly
399 
400                 // solhint-disable-next-line no-inline-assembly
401                 assembly {
402                     let returndata_size := mload(returndata)
403                     revert(add(32, returndata), returndata_size)
404                 }
405             } else {
406                 revert(errorMessage);
407             }
408         }
409     }
410 }
411 
412 contract Ownable is Context {
413     address private _owner;
414     address private _previousOwner;
415     uint256 private _lockTime;
416 
417     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
418 
419     /**
420     * @dev Initializes the contract setting the deployer as the initial owner.
421     */
422     constructor () internal {
423         address msgSender = _msgSender();
424         _owner = msgSender;
425         emit OwnershipTransferred(address(0), msgSender);
426     }
427 
428     /**
429     * @dev Returns the address of the current owner.
430     */
431     function owner() public view returns (address) {
432         return _owner;
433     }
434 
435     /**
436     * @dev Throws if called by any account other than the owner.
437     */
438     modifier onlyOwner() {
439         require(_owner == _msgSender(), "Ownable: caller is not the owner");
440         _;
441     }
442 
443     /**
444     * @dev Leaves the contract without owner. It will not be possible to call
445     * `onlyOwner` functions anymore. Can only be called by the current owner.
446     *
447     * NOTE: Renouncing ownership will leave the contract without an owner,
448     * thereby removing any functionality that is only available to the owner.
449     */
450     function renounceOwnership() public virtual onlyOwner {
451         emit OwnershipTransferred(_owner, address(0));
452         _owner = address(0);
453     }
454 
455     /**
456     * @dev Transfers ownership of the contract to a new account (`newOwner`).
457     * Can only be called by the current owner.
458     */
459     function transferOwnership(address newOwner) public virtual onlyOwner {
460         require(newOwner != address(0), "Ownable: new owner is the zero address");
461         emit OwnershipTransferred(_owner, newOwner);
462         _owner = newOwner;
463     }
464 
465 }
466 
467 interface IUniswapV2Factory {
468     event PairCreated(address indexed token0, address indexed token1, address pair, uint);
469 
470     function feeTo() external view returns (address);
471     function feeToSetter() external view returns (address);
472 
473     function getPair(address tokenA, address tokenB) external view returns (address pair);
474     function allPairs(uint) external view returns (address pair);
475     function allPairsLength() external view returns (uint);
476 
477     function createPair(address tokenA, address tokenB) external returns (address pair);
478 
479     function setFeeTo(address) external;
480     function setFeeToSetter(address) external;
481 }
482 
483 interface IUniswapV2Pair {
484     event Approval(address indexed owner, address indexed spender, uint value);
485     event Transfer(address indexed from, address indexed to, uint value);
486 
487     function name() external pure returns (string memory);
488     function symbol() external pure returns (string memory);
489     function decimals() external pure returns (uint8);
490     function totalSupply() external view returns (uint);
491     function balanceOf(address owner) external view returns (uint);
492     function allowance(address owner, address spender) external view returns (uint);
493 
494     function approve(address spender, uint value) external returns (bool);
495     function transfer(address to, uint value) external returns (bool);
496     function transferFrom(address from, address to, uint value) external returns (bool);
497 
498     function DOMAIN_SEPARATOR() external view returns (bytes32);
499     function PERMIT_TYPEHASH() external pure returns (bytes32);
500     function nonces(address owner) external view returns (uint);
501 
502     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
503 
504     //NB: This is an INTERFACE FUNCTION on the default UniSwapV2 Library.
505     //Feel free to check the contract itself - there's no implementation/way to use it to mint tokens.
506     event Mint(address indexed sender, uint amount0, uint amount1);
507     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
508     event Swap(
509         address indexed sender,
510         uint amount0In,
511         uint amount1In,
512         uint amount0Out,
513         uint amount1Out,
514         address indexed to
515     );
516     event Sync(uint112 reserve0, uint112 reserve1);
517 
518     function MINIMUM_LIQUIDITY() external pure returns (uint);
519     function factory() external view returns (address);
520     function token0() external view returns (address);
521     function token1() external view returns (address);
522     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
523     function price0CumulativeLast() external view returns (uint);
524     function price1CumulativeLast() external view returns (uint);
525     function kLast() external view returns (uint);
526 
527     //NB: This is an INTERFACE FUNCTION on the default UniSwapV2 Library.
528     //Feel free to check the contract itself - there's no implementation/way to use it to mint tokens.
529     function mint(address to) external returns (uint liquidity);
530     function burn(address to) external returns (uint amount0, uint amount1);
531     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
532     function skim(address to) external;
533     function sync() external;
534 
535     function initialize(address, address) external;
536 }
537 
538 interface IUniswapV2Router01 {
539     function factory() external pure returns (address);
540     function WETH() external pure returns (address);
541 
542     function addLiquidity(
543         address tokenA,
544         address tokenB,
545         uint amountADesired,
546         uint amountBDesired,
547         uint amountAMin,
548         uint amountBMin,
549         address to,
550         uint deadline
551     ) external returns (uint amountA, uint amountB, uint liquidity);
552     function addLiquidityETH(
553         address token,
554         uint amountTokenDesired,
555         uint amountTokenMin,
556         uint amountETHMin,
557         address to,
558         uint deadline
559     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
560     function removeLiquidity(
561         address tokenA,
562         address tokenB,
563         uint liquidity,
564         uint amountAMin,
565         uint amountBMin,
566         address to,
567         uint deadline
568     ) external returns (uint amountA, uint amountB);
569     function removeLiquidityETH(
570         address token,
571         uint liquidity,
572         uint amountTokenMin,
573         uint amountETHMin,
574         address to,
575         uint deadline
576     ) external returns (uint amountToken, uint amountETH);
577     function removeLiquidityWithPermit(
578         address tokenA,
579         address tokenB,
580         uint liquidity,
581         uint amountAMin,
582         uint amountBMin,
583         address to,
584         uint deadline,
585         bool approveMax, uint8 v, bytes32 r, bytes32 s
586     ) external returns (uint amountA, uint amountB);
587     function removeLiquidityETHWithPermit(
588         address token,
589         uint liquidity,
590         uint amountTokenMin,
591         uint amountETHMin,
592         address to,
593         uint deadline,
594         bool approveMax, uint8 v, bytes32 r, bytes32 s
595     ) external returns (uint amountToken, uint amountETH);
596     function swapExactTokensForTokens(
597         uint amountIn,
598         uint amountOutMin,
599         address[] calldata path,
600         address to,
601         uint deadline
602     ) external returns (uint[] memory amounts);
603     function swapTokensForExactTokens(
604         uint amountOut,
605         uint amountInMax,
606         address[] calldata path,
607         address to,
608         uint deadline
609     ) external returns (uint[] memory amounts);
610     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
611     external
612     payable
613     returns (uint[] memory amounts);
614     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
615     external
616     returns (uint[] memory amounts);
617     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
618     external
619     returns (uint[] memory amounts);
620     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
621     external
622     payable
623     returns (uint[] memory amounts);
624 
625     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
626     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
627     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
628     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
629     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
630 }
631 
632 interface IUniswapV2Router02 is IUniswapV2Router01 {
633     function removeLiquidityETHSupportingFeeOnTransferTokens(
634         address token,
635         uint liquidity,
636         uint amountTokenMin,
637         uint amountETHMin,
638         address to,
639         uint deadline
640     ) external returns (uint amountETH);
641     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
642         address token,
643         uint liquidity,
644         uint amountTokenMin,
645         uint amountETHMin,
646         address to,
647         uint deadline,
648         bool approveMax, uint8 v, bytes32 r, bytes32 s
649     ) external returns (uint amountETH);
650 
651     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
652         uint amountIn,
653         uint amountOutMin,
654         address[] calldata path,
655         address to,
656         uint deadline
657     ) external;
658     function swapExactETHForTokensSupportingFeeOnTransferTokens(
659         uint amountOutMin,
660         address[] calldata path,
661         address to,
662         uint deadline
663     ) external payable;
664     function swapExactTokensForETHSupportingFeeOnTransferTokens(
665         uint amountIn,
666         uint amountOutMin,
667         address[] calldata path,
668         address to,
669         uint deadline
670     ) external;
671 }
672 
673 // Contract implementation
674 contract AstroLion is Context, IERC20, Ownable {
675     using SafeMath for uint256;
676     using Address for address;
677 
678     mapping (address => uint256) private _rOwned;
679     mapping (address => uint256) private _tOwned;
680     mapping (address => uint256) private _lastTx;
681     mapping (address => mapping (address => uint256)) private _allowances;
682 
683     mapping (address => bool) private _isExcludedFromFee;
684 
685     mapping (address => bool) private _isExcluded;
686     address[] private _excluded;
687 
688     uint256 private constant MAX = ~uint256(0);
689     uint256 private _tTotal = 1000000000000000000000000;
690     uint256 private _rTotal = (MAX - (MAX % _tTotal));
691     uint256 private _tFeeTotal;
692     uint256 public launchTime;
693     mapping (address => bool) private _isSniper;
694     address[] private _confirmedSnipers;
695 
696     string private _name = 'AstroLion | t.me/AstroLionToken';
697     string private _symbol = 'AstroLion';
698     uint8 private _decimals = 9;
699 
700     uint256 private _taxFee = 0;
701     uint256 private _teamDev = 0;
702     uint256 private _previousTaxFee = _taxFee;
703     uint256 private _previousTeamDev = _teamDev;
704 
705     address payable private _teamDevAddress;
706     address private _router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
707 
708     IUniswapV2Router02 public uniswapV2Router;
709     address public uniswapV2Pair;
710 
711     bool inSwap = false;
712     bool public swapEnabled = true;
713     bool public tradingOpen = false;
714     bool private snipeProtectionOn = false;
715 
716     uint256 public _maxTxAmount = 10000000000000000000000;
717     uint256 private _numOfTokensToExchangeForTeamDev = 50000000000000000;
718     bool _txLimitsEnabled = true;
719 
720     event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);
721     event SwapEnabledUpdated(bool enabled);
722 
723     modifier lockTheSwap {
724         inSwap = true;
725         _;
726         inSwap = false;
727     }
728 
729     constructor () public {
730         _rOwned[_msgSender()] = _rTotal;
731 
732         emit Transfer(address(0), _msgSender(), _tTotal);
733     }
734 
735     function initContract() external onlyOwner() {
736         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_router);
737         // Create a uniswap pair for this new token
738         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
739         .createPair(address(this), _uniswapV2Router.WETH());
740 
741         // set the rest of the contract variables
742         uniswapV2Router = _uniswapV2Router;
743         // Exclude owner and this contract from fee
744         _isExcludedFromFee[owner()] = true;
745         _isExcludedFromFee[address(this)] = true;
746 
747         // List of front-runner & sniper bots from t.me/FairLaunchCalls
748         _isSniper[address(0x7589319ED0fD750017159fb4E4d96C63966173C1)] = true;
749         _confirmedSnipers.push(address(0x7589319ED0fD750017159fb4E4d96C63966173C1));
750 
751         _isSniper[address(0x65A67DF75CCbF57828185c7C050e34De64d859d0)] = true;
752         _confirmedSnipers.push(address(0x65A67DF75CCbF57828185c7C050e34De64d859d0));
753 
754         _isSniper[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;
755         _confirmedSnipers.push(address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce));
756 
757         _isSniper[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;
758         _confirmedSnipers.push(address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce));
759 
760         _isSniper[address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345)] = true;
761         _confirmedSnipers.push(address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345));
762 
763         _isSniper[address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b)] = true;
764         _confirmedSnipers.push(address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b));
765 
766         _isSniper[address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95)] = true;
767         _confirmedSnipers.push(address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95));
768 
769         _isSniper[address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964)] = true;
770         _confirmedSnipers.push(address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964));
771 
772         _isSniper[address(0xDC81a3450817A58D00f45C86d0368290088db848)] = true;
773         _confirmedSnipers.push(address(0xDC81a3450817A58D00f45C86d0368290088db848));
774 
775         _isSniper[address(0x45fD07C63e5c316540F14b2002B085aEE78E3881)] = true;
776         _confirmedSnipers.push(address(0x45fD07C63e5c316540F14b2002B085aEE78E3881));
777 
778         _isSniper[address(0x27F9Adb26D532a41D97e00206114e429ad58c679)] = true;
779         _confirmedSnipers.push(address(0x27F9Adb26D532a41D97e00206114e429ad58c679));
780 
781         _isSniper[address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7)] = true;
782         _confirmedSnipers.push(address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7));
783 
784         _isSniper[address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533)] = true;
785         _confirmedSnipers.push(address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533));
786 
787         _isSniper[address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d)] = true;
788         _confirmedSnipers.push(address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d));
789 
790         _isSniper[address(0x000000000000084e91743124a982076C59f10084)] = true;
791         _confirmedSnipers.push(address(0x000000000000084e91743124a982076C59f10084));
792 
793         _isSniper[address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303)] = true;
794         _confirmedSnipers.push(address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303));
795 
796         _isSniper[address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595)] = true;
797         _confirmedSnipers.push(address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595));
798 
799         _isSniper[address(0x000000005804B22091aa9830E50459A15E7C9241)] = true;
800         _confirmedSnipers.push(address(0x000000005804B22091aa9830E50459A15E7C9241));
801 
802         _isSniper[address(0xA3b0e79935815730d942A444A84d4Bd14A339553)] = true;
803         _confirmedSnipers.push(address(0xA3b0e79935815730d942A444A84d4Bd14A339553));
804 
805         _isSniper[address(0xf6da21E95D74767009acCB145b96897aC3630BaD)] = true;
806         _confirmedSnipers.push(address(0xf6da21E95D74767009acCB145b96897aC3630BaD));
807 
808         _isSniper[address(0x0000000000007673393729D5618DC555FD13f9aA)] = true;
809         _confirmedSnipers.push(address(0x0000000000007673393729D5618DC555FD13f9aA));
810 
811         _isSniper[address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1)] = true;
812         _confirmedSnipers.push(address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1));
813 
814         _isSniper[address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6)] = true;
815         _confirmedSnipers.push(address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6));
816 
817         _isSniper[address(0x000000917de6037d52b1F0a306eeCD208405f7cd)] = true;
818         _confirmedSnipers.push(address(0x000000917de6037d52b1F0a306eeCD208405f7cd));
819 
820         _isSniper[address(0x7100e690554B1c2FD01E8648db88bE235C1E6514)] = true;
821         _confirmedSnipers.push(address(0x7100e690554B1c2FD01E8648db88bE235C1E6514));
822 
823         _isSniper[address(0x72b30cDc1583224381132D379A052A6B10725415)] = true;
824         _confirmedSnipers.push(address(0x72b30cDc1583224381132D379A052A6B10725415));
825 
826         _isSniper[address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE)] = true;
827         _confirmedSnipers.push(address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE));
828 
829         _isSniper[address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F)] = true;
830         _confirmedSnipers.push(address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F));
831 
832         _isSniper[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;
833         _confirmedSnipers.push(address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b));
834 
835         _isSniper[address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9)] = true;
836         _confirmedSnipers.push(address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9));
837 
838         _isSniper[address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7)] = true;
839         _confirmedSnipers.push(address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7));
840 
841         _isSniper[address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF)] = true;
842         _confirmedSnipers.push(address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF));
843 
844         _isSniper[address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290)] = true;
845         _confirmedSnipers.push(address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290));
846 
847         _isSniper[address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5)] = true;
848         _confirmedSnipers.push(address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5));
849 
850         _isSniper[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;
851         _confirmedSnipers.push(address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b));
852 
853         _isSniper[address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7)] = true;
854         _confirmedSnipers.push(address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7));
855 
856         _isSniper[address(0xbCb05a3F85d34f0194C70d5914d5C4E28f11Cc02)] = true;
857         _confirmedSnipers.push(address(0xbCb05a3F85d34f0194C70d5914d5C4E28f11Cc02));
858 
859         _isSniper[address(0x22246F9BCa9921Bfa9A3f8df5baBc5Bc8ee73850)] = true;
860         _confirmedSnipers.push(address(0x22246F9BCa9921Bfa9A3f8df5baBc5Bc8ee73850));
861 
862         _isSniper[address(0x42d4C197036BD9984cA652303e07dD29fA6bdB37)] = true;
863         _confirmedSnipers.push(address(0x42d4C197036BD9984cA652303e07dD29fA6bdB37));
864 
865         _isSniper[address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40)] = true;
866         _confirmedSnipers.push(address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40));
867 
868         _isSniper[address(0x231DC6af3C66741f6Cf618884B953DF0e83C1A2A)] = true;
869         _confirmedSnipers.push(address(0x231DC6af3C66741f6Cf618884B953DF0e83C1A2A));
870 
871         _isSniper[address(0xC6bF34596f74eb22e066a878848DfB9fC1CF4C65)] = true;
872         _confirmedSnipers.push(address(0xC6bF34596f74eb22e066a878848DfB9fC1CF4C65));
873 
874         _isSniper[address(0x20f6fCd6B8813c4f98c0fFbD88C87c0255040Aa3)] = true;
875         _confirmedSnipers.push(address(0x20f6fCd6B8813c4f98c0fFbD88C87c0255040Aa3));
876 
877         _isSniper[address(0xD334C5392eD4863C81576422B968C6FB90EE9f79)] = true;
878         _confirmedSnipers.push(address(0xD334C5392eD4863C81576422B968C6FB90EE9f79));
879 
880         _isSniper[address(0xFFFFF6E70842330948Ca47254F2bE673B1cb0dB7)] = true;
881         _confirmedSnipers.push(address(0xFFFFF6E70842330948Ca47254F2bE673B1cb0dB7));
882 
883         _isSniper[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;
884         _confirmedSnipers.push(address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a));
885 
886         _isSniper[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;
887         _confirmedSnipers.push(address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a));
888 
889         _taxFee = 0;
890         _teamDev = 9;
891         _teamDevAddress = payable(0xb7de10bf2700Cd28Cdf4fa74BBE9BDfa516ae560);
892     }
893 
894     function liftOpeningTXLimits() external onlyOwner() {
895         _maxTxAmount = 100000000000000000000000;
896     }
897 
898     function openTrading() external onlyOwner() {
899         swapEnabled = true;
900         tradingOpen = true;
901         launchTime = block.timestamp;
902     }
903 
904     function name() public view returns (string memory) {
905         return _name;
906     }
907 
908     function symbol() public view returns (string memory) {
909         return _symbol;
910     }
911 
912     function decimals() public view returns (uint8) {
913         return _decimals;
914     }
915 
916     function totalSupply() public view override returns (uint256) {
917         return _tTotal;
918     }
919 
920     function balanceOf(address account) public view override returns (uint256) {
921         if (_isExcluded[account]) return _tOwned[account];
922         return tokenFromReflection(_rOwned[account]);
923     }
924 
925     function transfer(address recipient, uint256 amount) public override returns (bool) {
926         _transfer(_msgSender(), recipient, amount);
927         return true;
928     }
929 
930     function allowance(address owner, address spender) public view override returns (uint256) {
931         return _allowances[owner][spender];
932     }
933 
934     function approve(address spender, uint256 amount) public override returns (bool) {
935         _approve(_msgSender(), spender, amount);
936         return true;
937     }
938 
939     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
940         _transfer(sender, recipient, amount);
941         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
942         return true;
943     }
944 
945     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
946         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
947         return true;
948     }
949 
950     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
951         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
952         return true;
953     }
954 
955     function isExcluded(address account) public view returns (bool) {
956         return _isExcluded[account];
957     }
958 
959     function setExcludeFromFee(address account, bool excluded) external onlyOwner() {
960         _isExcludedFromFee[account] = excluded;
961     }
962 
963     function totalFees() public view returns (uint256) {
964         return _tFeeTotal;
965     }
966 
967     function deliver(uint256 tAmount) public {
968         address sender = _msgSender();
969         require(!_isExcluded[sender], "Excluded addresses cannot call this function");
970         (uint256 rAmount,,,,,) = _getValues(tAmount);
971         _rOwned[sender] = _rOwned[sender].sub(rAmount);
972         _rTotal = _rTotal.sub(rAmount);
973         _tFeeTotal = _tFeeTotal.add(tAmount);
974     }
975 
976     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {
977         require(tAmount <= _tTotal, "Amount must be less than supply");
978         if (!deductTransferFee) {
979             (uint256 rAmount,,,,,) = _getValues(tAmount);
980             return rAmount;
981         } else {
982             (,uint256 rTransferAmount,,,,) = _getValues(tAmount);
983             return rTransferAmount;
984         }
985     }
986 
987     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {
988         require(rAmount <= _rTotal, "Amount must be less than total reflections");
989         uint256 currentRate =  _getRate();
990         return rAmount.div(currentRate);
991     }
992 
993     function excludeAccount(address account) external onlyOwner() {
994         require(account != _router, 'We can not exclude our router.');
995         require(!_isExcluded[account], "Account is already excluded");
996         if(_rOwned[account] > 0) {
997             _tOwned[account] = tokenFromReflection(_rOwned[account]);
998         }
999         _isExcluded[account] = true;
1000         _excluded.push(account);
1001     }
1002 
1003     function includeAccount(address account) external onlyOwner() {
1004         require(_isExcluded[account], "Account is already excluded");
1005         for (uint256 i = 0; i < _excluded.length; i++) {
1006             if (_excluded[i] == account) {
1007                 _excluded[i] = _excluded[_excluded.length - 1];
1008                 _tOwned[account] = 0;
1009                 _isExcluded[account] = false;
1010                 _excluded.pop();
1011                 break;
1012             }
1013         }
1014     }
1015 
1016     function removeAllFee() private {
1017         if(_taxFee == 0 && _teamDev == 0) return;
1018 
1019         _previousTaxFee = _taxFee;
1020         _previousTeamDev = _teamDev;
1021 
1022         _taxFee = 0;
1023         _teamDev = 0;
1024     }
1025 
1026     function restoreAllFee() private {
1027         _taxFee = _previousTaxFee;
1028         _teamDev = _previousTeamDev;
1029     }
1030 
1031     function isExcludedFromFee(address account) public view returns(bool) {
1032         return _isExcludedFromFee[account];
1033     }
1034 
1035     function _approve(address owner, address spender, uint256 amount) private {
1036         require(owner != address(0), "ERC20: approve from the zero address");
1037         require(spender != address(0), "ERC20: approve to the zero address");
1038 
1039         _allowances[owner][spender] = amount;
1040         emit Approval(owner, spender, amount);
1041     }
1042 
1043     function RemoveSniper(address account) external onlyOwner() {
1044         require(account != _router, 'We can not blacklist our router.');
1045         require(account != uniswapV2Pair, 'We can not blacklist our pair.');
1046         require(account != owner(), 'We can not blacklist the contract owner.');
1047         require(account != address(this), 'We can not blacklist the contract. Srsly?');
1048         require(!_isSniper[account], "Account is already blacklisted");
1049         _isSniper[account] = true;
1050         _confirmedSnipers.push(account);
1051     }
1052 
1053     function amnestySniper(address account) external onlyOwner() {
1054         require(_isSniper[account], "Account is not blacklisted");
1055         for (uint256 i = 0; i < _confirmedSnipers.length; i++) {
1056             if (_confirmedSnipers[i] == account) {
1057                 _confirmedSnipers[i] = _confirmedSnipers[_confirmedSnipers.length - 1];
1058                 _isSniper[account] = false;
1059                 _confirmedSnipers.pop();
1060                 break;
1061             }
1062         }
1063     }
1064 
1065     function _transfer(address sender, address recipient, uint256 amount) private {
1066         require(sender != address(0), "ERC20: transfer from the zero address");
1067         require(recipient != address(0), "ERC20: transfer to the zero address");
1068         require(amount > 0, "Transfer amount must be greater than zero");
1069         require(!_isSniper[recipient], "You have no power here!");
1070         require(!_isSniper[msg.sender], "You have no power here!");
1071         require(!_isSniper[sender], "You have no power here!");
1072 
1073         if(sender != owner() && recipient != owner()) {
1074 
1075             if (!tradingOpen) {
1076                 if (!(sender == address(this) || recipient == address(this)
1077                 || sender == address(owner()) || recipient == address(owner()))) {
1078                     require(tradingOpen, "Trading is not enabled");
1079                 }
1080             }
1081         }
1082 
1083         // is the token balance of this contract address over the min number of
1084         // tokens that we need to initiate a swap?
1085         // also, don't get caught in a circular charity event.
1086         // also, don't swap if sender is uniswap pair.
1087         uint256 contractTokenBalance = balanceOf(address(this));
1088 
1089         bool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForTeamDev;
1090         if (!inSwap && swapEnabled && overMinTokenBalance && sender != uniswapV2Pair) {
1091             // We need to swap the current tokens to ETH and send to the ext wallet
1092             swapTokensForEth(contractTokenBalance);
1093 
1094             uint256 contractETHBalance = address(this).balance;
1095             if(contractETHBalance > 0) {
1096                 sendETHToTeamDev(address(this).balance);
1097             }
1098         }
1099 
1100         //indicates if fee should be deducted from transfer
1101         bool takeFee = true;
1102 
1103         //if any account belongs to _isExcludedFromFee account then remove the fee
1104         if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){
1105             takeFee = false;
1106         }
1107 
1108         //transfer amount, it will take tax and fee
1109 
1110         _tokenTransfer(sender,recipient,amount,takeFee);
1111     }
1112 
1113     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap{
1114         // generate the uniswap pair path of token -> weth
1115         address[] memory path = new address[](2);
1116         path[0] = address(this);
1117         path[1] = uniswapV2Router.WETH();
1118 
1119         _approve(address(this), address(uniswapV2Router), tokenAmount);
1120 
1121         // make the swap
1122         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
1123             tokenAmount,
1124             0, // accept any amount of ETH
1125             path,
1126             address(this),
1127             block.timestamp
1128         );
1129     }
1130 
1131     function sendETHToTeamDev(uint256 amount) private {
1132         _teamDevAddress.transfer(amount.div(2));
1133     }
1134 
1135     // We are exposing these functions to be able to manual swap and send
1136     // in case the token is highly valued and 5M becomes too much
1137     function manualSwap() external onlyOwner() {
1138         uint256 contractBalance = balanceOf(address(this));
1139         swapTokensForEth(contractBalance);
1140     }
1141 
1142     function manualSend() external onlyOwner() {
1143         uint256 contractETHBalance = address(this).balance;
1144         sendETHToTeamDev(contractETHBalance);
1145     }
1146 
1147     function setSwapEnabled(bool enabled) external onlyOwner(){
1148         swapEnabled = enabled;
1149     }
1150 
1151     function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {
1152         if(!takeFee)
1153             removeAllFee();
1154 
1155         if (_isExcluded[sender] && !_isExcluded[recipient]) {
1156             _transferFromExcluded(sender, recipient, amount);
1157         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {
1158             _transferToExcluded(sender, recipient, amount);
1159         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
1160             _transferStandard(sender, recipient, amount);
1161         } else if (_isExcluded[sender] && _isExcluded[recipient]) {
1162             _transferBothExcluded(sender, recipient, amount);
1163         } else {
1164             _transferStandard(sender, recipient, amount);
1165         }
1166 
1167         if(!takeFee)
1168             restoreAllFee();
1169     }
1170 
1171     function _transferStandard(address sender, address recipient, uint256 tAmount) private {
1172         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);
1173         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1174         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1175         _takeCharity(tCharity);
1176         _reflectFee(rFee, tFee);
1177         emit Transfer(sender, recipient, tTransferAmount);
1178     }
1179 
1180     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
1181         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);
1182         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1183         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
1184         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1185         _takeCharity(tCharity);
1186         _reflectFee(rFee, tFee);
1187         emit Transfer(sender, recipient, tTransferAmount);
1188     }
1189 
1190     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
1191         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);
1192         _tOwned[sender] = _tOwned[sender].sub(tAmount);
1193         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1194         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1195         _takeCharity(tCharity);
1196         _reflectFee(rFee, tFee);
1197         emit Transfer(sender, recipient, tTransferAmount);
1198     }
1199 
1200     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
1201         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);
1202         _tOwned[sender] = _tOwned[sender].sub(tAmount);
1203         _rOwned[sender] = _rOwned[sender].sub(rAmount);
1204         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
1205         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
1206         _takeCharity(tCharity);
1207         _reflectFee(rFee, tFee);
1208         emit Transfer(sender, recipient, tTransferAmount);
1209     }
1210 
1211     function _takeCharity(uint256 tCharity) private {
1212         uint256 currentRate =  _getRate();
1213         uint256 rCharity = tCharity.mul(currentRate);
1214         _rOwned[address(this)] = _rOwned[address(this)].add(rCharity);
1215         if(_isExcluded[address(this)])
1216             _tOwned[address(this)] = _tOwned[address(this)].add(tCharity);
1217     }
1218 
1219     function _reflectFee(uint256 rFee, uint256 tFee) private {
1220         _rTotal = _rTotal.sub(rFee);
1221         _tFeeTotal = _tFeeTotal.add(tFee);
1222     }
1223 
1224     //to recieve ETH from uniswapV2Router when swaping
1225     receive() external payable {}
1226 
1227     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
1228         (uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getTValues(tAmount, _taxFee, _teamDev);
1229         uint256 currentRate =  _getRate();
1230         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);
1231         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tCharity);
1232     }
1233 
1234     function _getTValues(uint256 tAmount, uint256 taxFee, uint256 charityFee) private pure returns (uint256, uint256, uint256) {
1235         uint256 tFee = tAmount.mul(taxFee).div(100);
1236         uint256 tCharity = tAmount.mul(charityFee).div(100);
1237         uint256 tTransferAmount = tAmount.sub(tFee).sub(tCharity);
1238         return (tTransferAmount, tFee, tCharity);
1239     }
1240 
1241     function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
1242         uint256 rAmount = tAmount.mul(currentRate);
1243         uint256 rFee = tFee.mul(currentRate);
1244         uint256 rTransferAmount = rAmount.sub(rFee);
1245         return (rAmount, rTransferAmount, rFee);
1246     }
1247 
1248     function _getRate() private view returns(uint256) {
1249         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
1250         return rSupply.div(tSupply);
1251     }
1252 
1253     function _getCurrentSupply() private view returns(uint256, uint256) {
1254         uint256 rSupply = _rTotal;
1255         uint256 tSupply = _tTotal;
1256         for (uint256 i = 0; i < _excluded.length; i++) {
1257             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);
1258             rSupply = rSupply.sub(_rOwned[_excluded[i]]);
1259             tSupply = tSupply.sub(_tOwned[_excluded[i]]);
1260         }
1261         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
1262         return (rSupply, tSupply);
1263     }
1264 
1265     function _getTaxFee() private view returns(uint256) {
1266         return _taxFee;
1267     }
1268 
1269     function _getMaxTxAmount() private view returns(uint256) {
1270         return _maxTxAmount;
1271     }
1272 
1273     function _getETHBalance() public view returns(uint256 balance) {
1274         return address(this).balance;
1275     }
1276 
1277     function setExtWallet(address payable teamDevAddress) external onlyOwner() {
1278         _teamDevAddress = teamDevAddress;
1279     }
1280 }