1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/CRFTDMarketplace.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {utils} from \"./utils/utils.sol\";\nimport {choice} from \"./utils/choice.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nerror NotActive();\nerror NoSupplyLeft();\nerror NotAuthorized();\nerror InvalidReceiver();\nerror InvalidEthAmount();\nerror InsufficientValue();\nerror InvalidPaymentToken();\nerror MaxPurchasesReached();\nerror ContractCallNotAllowed();\nerror RandomSeedAlreadyChosen();\n\n//       ___           ___           ___                    _____\n//      /  /\\         /  /\\         /  /\\       ___        /  /::\\\n//     /  /:/        /  /::\\       /  /:/_     /__/\\      /  /:/\\:\\\n//    /  /:/        /  /:/\\:\\     /  /:/ /\\    \\  \\:\\    /  /:/  \\:\\\n//   /  /:/  ___   /  /::\\ \\:\\   /  /:/ /:/     \\__\\:\\  /__/:/ \\__\\:|\n//  /__/:/  /  /\\ /__/:/\\:\\_\\:\\ /__/:/ /:/      /  /::\\ \\  \\:\\ /  /:/\n//  \\  \\:\\ /  /:/ \\__\\/~|::\\/:/ \\  \\:\\/:/      /  /:/\\:\\ \\  \\:\\  /:/\n//   \\  \\:\\  /:/     |  |:|::/   \\  \\::/      /  /:/__\\/  \\  \\:\\/:/\n//    \\  \\:\\/:/      |  |:|\\/     \\  \\:\\     /__/:/        \\  \\::/\n//     \\  \\::/       |__|:|        \\  \\:\\    \\__\\/          \\__\\/\n//      \\__\\/         \\__\\|         \\__\\/\n\n/// @title CRFTDMarketplace\n/// @author phaze (https://github.com/0xPhaze)\n/// @notice Marketplace that supports purchasing limited off-chain items\ncontract CRFTDMarketplace is Owned(msg.sender) {\n    using SafeTransferLib for ERC20;\n\n    /* ------------- events ------------- */\n\n    event MarketItemPurchased(\n        uint256 indexed marketId,\n        bytes32 indexed itemHash,\n        address indexed account,\n        bytes32 userHash,\n        address paymentToken,\n        uint256 price\n    );\n\n    /* ------------- structs ------------- */\n\n    struct MarketItem {\n        uint256 marketId;\n        uint256 start;\n        uint256 end;\n        uint256 expiry;\n        uint256 maxPurchases;\n        uint256 maxSupply;\n        uint256 raffleNumPrizes;\n        address[] raffleControllers;\n        address receiver;\n        bytes32 dataHash;\n        address[] acceptedPaymentTokens;\n        uint256[] tokenPricesStart;\n        uint256[] tokenPricesEnd;\n    }\n\n    /* ------------- storage ------------- */\n\n    /// @dev (bytes32 itemHash) => (uint256 totalSupply)\n    mapping(bytes32 => uint256) public totalSupply;\n    /// @dev (bytes32 itemHash) => (address user) => (uint256 numPurchases)\n    mapping(bytes32 => mapping(address => uint256)) public numPurchases;\n    /// @dev (bytes32 itemHash) => (uint256 tokenId) => (address user)\n    mapping(bytes32 => mapping(uint256 => address)) public raffleEntries;\n    /// @dev (bytes32 itemHash) => (uint256 seed)\n    mapping(bytes32 => uint256) public raffleRandomSeeds;\n\n    /* ------------- external ------------- */\n\n    function purchaseMarketItems(\n        MarketItem[] calldata items,\n        address[] calldata paymentTokens,\n        bytes32 userHash\n    ) external payable {\n        uint256 msgValue = msg.value;\n\n        for (uint256 i; i < items.length; ++i) {\n            MarketItem calldata item = items[i];\n\n            bytes32 itemHash = keccak256(abi.encode(item));\n\n            uint256 supply = ++totalSupply[itemHash];\n\n            unchecked {\n                if (block.timestamp < item.start || item.expiry < block.timestamp) revert NotActive();\n                if (++numPurchases[itemHash][msg.sender] > item.maxPurchases) revert MaxPurchasesReached();\n                if (supply > item.maxSupply) revert NoSupplyLeft();\n            }\n\n            address paymentToken = paymentTokens[i];\n\n            (bool found, uint256 tokenIndex) = utils.indexOf(item.acceptedPaymentTokens, paymentToken);\n            if (!found) revert InvalidPaymentToken();\n\n            uint256 tokenPrice = item.tokenPricesStart[tokenIndex];\n\n            // dutch auction item\n            if (item.end != 0) {\n                uint256 timestamp = block.timestamp > item.end ? item.end : block.timestamp;\n\n                tokenPrice -=\n                    ((item.tokenPricesStart[tokenIndex] - item.tokenPricesEnd[tokenIndex]) * (timestamp - item.start)) /\n                    (item.end - item.start);\n            }\n\n            // raffle item; store id ownership\n            if (item.raffleNumPrizes != 0) {\n                raffleEntries[itemHash][supply] = msg.sender;\n            }\n\n            if (paymentToken == address(0)) {\n                msgValue -= tokenPrice;\n\n                payable(item.receiver).transfer(tokenPrice);\n            } else {\n                require(paymentToken.code.length != 0);\n\n                ERC20(paymentToken).safeTransferFrom(msg.sender, item.receiver, tokenPrice);\n            }\n\n            emit MarketItemPurchased(item.marketId, itemHash, msg.sender, userHash, paymentToken, tokenPrice);\n        }\n\n        if (msgValue != 0) payable(msg.sender).transfer(msgValue);\n    }\n\n    /* ------------- view (off-chain) ------------- */\n\n    function getRaffleEntrants(bytes32 itemHash) external view returns (address[] memory entrants) {\n        uint256 supply = totalSupply[itemHash];\n\n        entrants = new address[](supply);\n\n        for (uint256 i; i < supply; ++i) entrants[i] = raffleEntries[itemHash][i + 1];\n    }\n\n    function getRaffleWinners(bytes32 itemHash, uint256 numPrizes) public view returns (address[] memory winners) {\n        uint256 randomSeed = raffleRandomSeeds[itemHash];\n\n        if (randomSeed == 0) return winners;\n\n        uint256[] memory winnerIds = choice.selectNOfM(numPrizes, totalSupply[itemHash], randomSeed);\n\n        uint256 numWinners = winnerIds.length;\n\n        winners = new address[](numWinners);\n\n        for (uint256 i; i < numWinners; ++i) winners[i] = raffleEntries[itemHash][winnerIds[i] + 1];\n    }\n\n    /* ------------- restricted ------------- */\n\n    function revealRaffle(MarketItem calldata item) external {\n        bytes32 itemHash = keccak256(abi.encode(item));\n\n        if (block.timestamp < item.expiry) revert NotActive();\n\n        (bool found, ) = utils.indexOf(item.raffleControllers, msg.sender);\n\n        if (!found) revert NotAuthorized();\n\n        if (raffleRandomSeeds[itemHash] != 0) revert RandomSeedAlreadyChosen();\n\n        raffleRandomSeeds[itemHash] = uint256(keccak256(abi.encode(blockhash(block.number - 1), itemHash)));\n    }\n\n    /* ------------- owner ------------- */\n\n    function recoverToken(ERC20 token) external onlyOwner {\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function recoverNFT(ERC721 token, uint256 id) external onlyOwner {\n        token.transferFrom(address(this), msg.sender, id);\n    }\n}\n"
6     },
7     "src/utils/utils.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary utils {\n    function getOwnedIds(\n        mapping(uint256 => address) storage ownerOf,\n        address user,\n        uint256 collectionSize\n    ) internal view returns (uint256[] memory ids) {\n        uint256 memPtr;\n        uint256 idsLength;\n\n        assembly {\n            ids := mload(0x40)\n            memPtr := add(ids, 32)\n        }\n\n        unchecked {\n            uint256 end = collectionSize + 1;\n            for (uint256 id = 0; id < end; ++id) {\n                if (ownerOf[id] == user) {\n                    assembly {\n                        mstore(memPtr, id)\n                        memPtr := add(memPtr, 32)\n                        idsLength := add(idsLength, 1)\n                    }\n                }\n            }\n        }\n\n        assembly {\n            mstore(ids, idsLength)\n            mstore(0x40, memPtr)\n        }\n    }\n\n    function indexOf(address[] calldata arr, address addr) internal pure returns (bool found, uint256 index) {\n        unchecked {\n            for (uint256 i; i < arr.length; ++i) if (arr[i] == addr) return (true, i);\n        }\n        return (false, 0);\n    }\n}\n"
9     },
10     "src/utils/choice.sol": {
11       "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// author: phaze\n\n// assumption: n << m\n// caveats: splits random number into 16 parts for efficiency\n// this means that 65536 is the highest random number\n// (can skew uniform distributions when m is hight)\nlibrary choice {\n    function selectNOfM(\n        uint256 n,\n        uint256 m,\n        uint256 r\n    ) internal pure returns (uint256[] memory selected) {\n        if (n > m) n = m;\n\n        selected = new uint256[](n);\n\n        uint256 s;\n        uint256 slot;\n\n        uint256 j;\n        uint256 c;\n\n        bool invalidChoice;\n\n        unchecked {\n            for (uint256 i; i < n; ++i) {\n                do {\n                    slot = (s & 0xF) << 4;\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\n                    c = ((r >> slot) & 0xFFFF) % m;\n                    invalidChoice = false;\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = selected[j] == c;\n                    ++s;\n                } while (invalidChoice);\n\n                selected[i] = c;\n            }\n        }\n    }\n}\n"
12     },
13     "lib/solmate/src/tokens/ERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
15     },
16     "lib/solmate/src/auth/Owned.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
18     },
19     "lib/solmate/src/tokens/ERC721.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        if (to.code.length != 0)\n            require(\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                    ERC721TokenReceiver.onERC721Received.selector,\n                \"UNSAFE_RECIPIENT\"\n            );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
21     },
22     "lib/solmate/src/utils/SafeTransferLib.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(4, from) // Append the \"from\" argument.\n            mstore(36, to) // Append the \"to\" argument.\n            mstore(68, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 100, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(4, to) // Append the \"to\" argument.\n            mstore(36, amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                call(gas(), token, 0, 0, 68, 0, 32)\n            )\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
24     }
25   },
26   "settings": {
27     "remappings": [
28       "ArrayUtils/=lib/ArrayUtils/src/",
29       "CRFTD/=src/",
30       "UDS/=lib/UDS/src/",
31       "ds-test/=lib/solmate/lib/ds-test/src/",
32       "f-utils/=lib/f-utils/src/",
33       "forge-std/=lib/forge-std/src/",
34       "script/=script/",
35       "solmate/=lib/solmate/src/",
36       "src/=src/",
37       "test/=test/",
38       "src/=src/",
39       "test/=test/",
40       "script/=script/"
41     ],
42     "optimizer": {
43       "enabled": true,
44       "runs": 100000
45     },
46     "metadata": {
47       "bytecodeHash": "ipfs"
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "devdoc",
55           "userdoc",
56           "metadata",
57           "abi"
58         ]
59       }
60     },
61     "evmVersion": "london",
62     "libraries": {}
63   }
64 }}