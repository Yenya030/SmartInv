1 pragma solidity ^0.4.21;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 
7 // File: contracts/library/SafeMath.sol
8 
9 /**
10  * @title Safe Math
11  *
12  * @dev Library for safe mathematical operations.
13  */
14 library SafeMath {
15     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
16         uint256 c = a * b;
17         assert(a == 0 || c / a == b);
18 
19         return c;
20     }
21 
22     function div(uint256 a, uint256 b) internal pure returns (uint256) {
23         uint256 c = a / b;
24 
25         return c;
26     }
27 
28     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
29         assert(b <= a);
30 
31         return a - b;
32     }
33 
34     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
35         uint256 c = a + b;
36         assert(c >= a);
37 
38         return c;
39     }
40 }
41 
42 // File: contracts/token/ERC20Token.sol
43 
44 /**
45  * @dev The standard ERC20 Token contract base.
46  */
47 contract ERC20Token {
48     uint256 public totalSupply;  /* shorthand for public function and a property */
49     
50     function balanceOf(address _owner) public view returns (uint256 balance);
51     function transfer(address _to, uint256 _value) public returns (bool success);
52     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
53     function approve(address _spender, uint256 _value) public returns (bool success);
54     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
55 
56     event Transfer(address indexed _from, address indexed _to, uint256 _value);
57     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
58 }
59 
60 // File: contracts/token/StandardToken.sol
61 
62 /**
63  * @title Standard Token
64  *
65  * @dev The standard abstract implementation of the ERC20 interface.
66  */
67 contract StandardToken is ERC20Token {
68     using SafeMath for uint256;
69 
70     string public name;
71     string public symbol;
72     uint8 public decimals;
73     
74     mapping (address => uint256) balances;
75     mapping (address => mapping (address => uint256)) internal allowed;
76     
77     /**
78      * @dev The constructor assigns the token name, symbols and decimals.
79      */
80     constructor(string _name, string _symbol, uint8 _decimals) internal {
81         name = _name;
82         symbol = _symbol;
83         decimals = _decimals;
84     }
85 
86     /**
87      * @dev Get the balance of an address.
88      *
89      * @param _address The address which's balance will be checked.
90      *
91      * @return The current balance of the address.
92      */
93     function balanceOf(address _address) public view returns (uint256 balance) {
94         return balances[_address];
95     }
96 
97     /**
98      * @dev Checks the amount of tokens that an owner allowed to a spender.
99      *
100      * @param _owner The address which owns the funds allowed for spending by a third-party.
101      * @param _spender The third-party address that is allowed to spend the tokens.
102      *
103      * @return The number of tokens available to `_spender` to be spent.
104      */
105     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
106         return allowed[_owner][_spender];
107     }
108 
109     /**
110      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
111      * E.g. You place a buy or sell order on an exchange and in that example, the 
112      * `_spender` address is the address of the contract the exchange created to add your token to their 
113      * website and you are `msg.sender`.
114      *
115      * @param _spender The address which will spend the funds.
116      * @param _value The amount of tokens to be spent.
117      *
118      * @return Whether the approval process was successful or not.
119      */
120     function approve(address _spender, uint256 _value) public returns (bool) {
121         allowed[msg.sender][_spender] = _value;
122 
123         emit Approval(msg.sender, _spender, _value);
124 
125         return true;
126     }
127 
128     /**
129      * @dev Transfers `_value` number of tokens to the `_to` address.
130      *
131      * @param _to The address of the recipient.
132      * @param _value The number of tokens to be transferred.
133      */
134     function transfer(address _to, uint256 _value) public returns (bool) {
135         executeTransfer(msg.sender, _to, _value);
136 
137         return true;
138     }
139 
140     /**
141      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
142      *
143      * @param _from The address which approved you to spend tokens on their behalf.
144      * @param _to The address where you want to send tokens.
145      * @param _value The number of tokens to be sent.
146      *
147      * @return Whether the transfer was successful or not.
148      */
149     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
150         require(_value <= allowed[_from][msg.sender]);
151         
152         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
153         executeTransfer(_from, _to, _value);
154 
155         return true;
156     }
157 
158     /**
159      * @dev Internal function that this reused by the transfer functions
160      */
161     function executeTransfer(address _from, address _to, uint256 _value) internal {
162         require(_to != address(0));
163         require(_value != 0 && _value <= balances[_from]);
164         
165         balances[_from] = balances[_from].minus(_value);
166         balances[_to] = balances[_to].plus(_value);
167 
168         emit Transfer(_from, _to, _value);
169     }
170 }
171 
172 // File: contracts/token/MintableToken.sol
173 
174 /**
175  * @title Mintable Token
176  *
177  * @dev Allows the creation of new tokens.
178  */
179 contract MintableToken is StandardToken {
180     /// @dev The only address allowed to mint coins
181     address public minter;
182 
183     /// @dev Indicates whether the token is still mintable.
184     bool public mintingDisabled = false;
185 
186     /**
187      * @dev Event fired when minting is no longer allowed.
188      */
189     event MintingDisabled();
190 
191     /**
192      * @dev Allows a function to be executed only if minting is still allowed.
193      */
194     modifier canMint() {
195         require(!mintingDisabled);
196         _;
197     }
198 
199     /**
200      * @dev Allows a function to be called only by the minter
201      */
202     modifier onlyMinter() {
203         require(msg.sender == minter);
204         _;
205     }
206 
207     /**
208      * @dev The constructor assigns the minter which is allowed to mind and disable minting
209      */
210     constructor(address _minter) internal {
211         minter = _minter;
212     }
213 
214     /**
215     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
216     *
217     * @param _to The address which will receive the freshly minted tokens.
218     * @param _value The number of tokens that will be created.
219     */
220     function mint(address _to, uint256 _value) onlyMinter canMint public {
221         totalSupply = totalSupply.plus(_value);
222         balances[_to] = balances[_to].plus(_value);
223 
224         emit Transfer(0x0, _to, _value);
225     }
226 
227     /**
228     * @dev Disable the minting of new tokens. Cannot be reversed.
229     *
230     * @return Whether or not the process was successful.
231     */
232     function disableMinting() onlyMinter canMint public {
233         mintingDisabled = true;
234        
235         emit MintingDisabled();
236     }
237 }
238 
239 // File: contracts/trait/HasOwner.sol
240 
241 /**
242  * @title HasOwner
243  *
244  * @dev Allows for exclusive access to certain functionality.
245  */
246 contract HasOwner {
247     // The current owner.
248     address public owner;
249 
250     // Conditionally the new owner.
251     address public newOwner;
252 
253     /**
254      * @dev The constructor.
255      *
256      * @param _owner The address of the owner.
257      */
258     constructor(address _owner) public {
259         owner = _owner;
260     }
261 
262     /** 
263      * @dev Access control modifier that allows only the current owner to call the function.
264      */
265     modifier onlyOwner {
266         require(msg.sender == owner);
267         _;
268     }
269 
270     /**
271      * @dev The event is fired when the current owner is changed.
272      *
273      * @param _oldOwner The address of the previous owner.
274      * @param _newOwner The address of the new owner.
275      */
276     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
277 
278     /**
279      * @dev Transfering the ownership is a two-step process, as we prepare
280      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
281      * the transfer. This prevents accidental lock-out if something goes wrong
282      * when passing the `newOwner` address.
283      *
284      * @param _newOwner The address of the proposed new owner.
285      */
286     function transferOwnership(address _newOwner) public onlyOwner {
287         newOwner = _newOwner;
288     }
289  
290     /**
291      * @dev The `newOwner` finishes the ownership transfer process by accepting the
292      * ownership.
293      */
294     function acceptOwnership() public {
295         require(msg.sender == newOwner);
296 
297         emit OwnershipTransfer(owner, newOwner);
298 
299         owner = newOwner;
300     }
301 }
302 
303 // File: contracts/fundraiser/AbstractFundraiser.sol
304 
305 contract AbstractFundraiser {
306     /// The ERC20 token contract.
307     ERC20Token public token;
308 
309     /**
310      * @dev The event fires every time a new buyer enters the fundraiser.
311      *
312      * @param _address The address of the buyer.
313      * @param _ethers The number of ethers funded.
314      * @param _tokens The number of tokens purchased.
315      */
316     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
317 
318 
319     /**
320      * @dev The initialization method for the token
321      *
322      * @param _token The address of the token of the fundraiser
323      */
324     function initializeFundraiserToken(address _token) internal
325     {
326         token = ERC20Token(_token);
327     }
328 
329     /**
330      * @dev The default function which is executed when someone sends funds to this contract address.
331      */
332     function() public payable {
333         receiveFunds(msg.sender, msg.value);
334     }
335 
336     /**
337      * @dev this overridable function returns the current conversion rate for the fundraiser
338      */
339     function getConversionRate() public view returns (uint256);
340 
341     /**
342      * @dev checks whether the fundraiser passed `endTime`.
343      *
344      * @return whether the fundraiser has ended.
345      */
346     function hasEnded() public view returns (bool);
347 
348     /**
349      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
350      *
351      * @param _address The address of the receiver of tokens.
352      * @param _amount The amount of received funds in ether.
353      */
354     function receiveFunds(address _address, uint256 _amount) internal;
355     
356     /**
357      * @dev It throws an exception if the transaction does not meet the preconditions.
358      */
359     function validateTransaction() internal view;
360     
361     /**
362      * @dev this overridable function makes and handles tokens to buyers
363      */
364     function handleTokens(address _address, uint256 _tokens) internal;
365 
366     /**
367      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
368      */
369     function handleFunds(address _address, uint256 _ethers) internal;
370 
371 }
372 
373 // File: contracts/fundraiser/BasicFundraiser.sol
374 
375 /**
376  * @title Basic Fundraiser
377  *
378  * @dev An abstract contract that is a base for fundraisers. 
379  * It implements a generic procedure for handling received funds:
380  * 1. Validates the transaciton preconditions
381  * 2. Calculates the amount of tokens based on the conversion rate.
382  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
383  * 4. Delegate the handling of the funds
384  * 5. Emit event for received funds
385  */
386 contract BasicFundraiser is HasOwner, AbstractFundraiser {
387     using SafeMath for uint256;
388 
389     // The number of decimals for the token.
390     uint8 constant DECIMALS = 18;  // Enforced
391 
392     // Decimal factor for multiplication purposes.
393     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
394 
395     /// The start time of the fundraiser - Unix timestamp.
396     uint256 public startTime;
397 
398     /// The end time of the fundraiser - Unix timestamp.
399     uint256 public endTime;
400 
401     /// The address where funds collected will be sent.
402     address public beneficiary;
403 
404     /// The conversion rate with decimals difference adjustment,
405     /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
406     uint256 public conversionRate;
407 
408     /// The total amount of ether raised.
409     uint256 public totalRaised;
410 
411     /**
412      * @dev The event fires when the number of token conversion rate has changed.
413      *
414      * @param _conversionRate The new number of tokens per 1 ether.
415      */
416     event ConversionRateChanged(uint _conversionRate);
417 
418     /**
419      * @dev The basic fundraiser initialization method.
420      *
421      * @param _startTime The start time of the fundraiser - Unix timestamp.
422      * @param _endTime The end time of the fundraiser - Unix timestamp.
423      * @param _conversionRate The number of tokens create for 1 ETH funded.
424      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
425      */
426     function initializeBasicFundraiser(
427         uint256 _startTime,
428         uint256 _endTime,
429         uint256 _conversionRate,
430         address _beneficiary
431     )
432         internal
433     {
434         require(_endTime >= _startTime);
435         require(_conversionRate > 0);
436         require(_beneficiary != address(0));
437 
438         startTime = _startTime;
439         endTime = _endTime;
440         conversionRate = _conversionRate;
441         beneficiary = _beneficiary;
442     }
443 
444     /**
445      * @dev Sets the new conversion rate
446      *
447      * @param _conversionRate New conversion rate
448      */
449     function setConversionRate(uint256 _conversionRate) public onlyOwner {
450         require(_conversionRate > 0);
451 
452         conversionRate = _conversionRate;
453 
454         emit ConversionRateChanged(_conversionRate);
455     }
456 
457     /**
458      * @dev Sets The beneficiary of the fundraiser.
459      *
460      * @param _beneficiary The address of the beneficiary.
461      */
462     function setBeneficiary(address _beneficiary) public onlyOwner {
463         require(_beneficiary != address(0));
464 
465         beneficiary = _beneficiary;
466     }
467 
468     /**
469      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
470      *
471      * @param _address The address of the receiver of tokens.
472      * @param _amount The amount of received funds in ether.
473      */
474     function receiveFunds(address _address, uint256 _amount) internal {
475         validateTransaction();
476 
477         uint256 tokens = calculateTokens(_amount);
478         require(tokens > 0);
479 
480         totalRaised = totalRaised.plus(_amount);
481         handleTokens(_address, tokens);
482         handleFunds(_address, _amount);
483 
484         emit FundsReceived(_address, msg.value, tokens);
485     }
486 
487     /**
488      * @dev this overridable function returns the current conversion rate for the fundraiser
489      */
490     function getConversionRate() public view returns (uint256) {
491         return conversionRate;
492     }
493 
494     /**
495      * @dev this overridable function that calculates the tokens based on the ether amount
496      */
497     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
498         tokens = _amount.mul(getConversionRate());
499     }
500 
501     /**
502      * @dev It throws an exception if the transaction does not meet the preconditions.
503      */
504     function validateTransaction() internal view {
505         require(msg.value != 0);
506         require(now >= startTime && now < endTime);
507     }
508 
509     /**
510      * @dev checks whether the fundraiser passed `endtime`.
511      *
512      * @return whether the fundraiser is passed its deadline or not.
513      */
514     function hasEnded() public view returns (bool) {
515         return now >= endTime;
516     }
517 }
518 
519 // File: contracts/token/StandardMintableToken.sol
520 
521 contract StandardMintableToken is MintableToken {
522     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
523         StandardToken(_name, _symbol, _decimals)
524         MintableToken(_minter)
525         public
526     {
527     }
528 }
529 
530 // File: contracts/fundraiser/MintableTokenFundraiser.sol
531 
532 /**
533  * @title Fundraiser With Mintable Token
534  */
535 contract MintableTokenFundraiser is BasicFundraiser {
536     /**
537      * @dev The initialization method that creates a new mintable token.
538      *
539      * @param _name Token name
540      * @param _symbol Token symbol
541      * @param _decimals Token decimals
542      */
543     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
544         token = new StandardMintableToken(
545             address(this), // The fundraiser is the token minter
546             _name,
547             _symbol,
548             _decimals
549         );
550     }
551 
552     /**
553      * @dev Mint the specific amount tokens
554      */
555     function handleTokens(address _address, uint256 _tokens) internal {
556         MintableToken(token).mint(_address, _tokens);
557     }
558 }
559 
560 // File: contracts/fundraiser/IndividualCapsFundraiser.sol
561 
562 /**
563  * @title Fundraiser with individual caps
564  *
565  * @dev Allows you to set a hard cap on your fundraiser.
566  */
567 contract IndividualCapsFundraiser is BasicFundraiser {
568     uint256 public individualMinCap;
569     uint256 public individualMaxCap;
570     uint256 public individualMaxCapTokens;
571 
572 
573     event IndividualMinCapChanged(uint256 _individualMinCap);
574     event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);
575 
576     /**
577      * @dev The initialization method.
578      *
579      * @param _individualMinCap The minimum amount of ether contribution per address.
580      * @param _individualMaxCap The maximum amount of ether contribution per address.
581      */
582     function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {
583         individualMinCap = _individualMinCap;
584         individualMaxCap = _individualMaxCap;
585         individualMaxCapTokens = _individualMaxCap * conversionRate;
586     }
587 
588     function setConversionRate(uint256 _conversionRate) public onlyOwner {
589         super.setConversionRate(_conversionRate);
590 
591         if (individualMaxCap == 0) {
592             return;
593         }
594         
595         individualMaxCapTokens = individualMaxCap * _conversionRate;
596 
597         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
598     }
599 
600     function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {
601         individualMinCap = _individualMinCap;
602 
603         emit IndividualMinCapChanged(individualMinCap);
604     }
605 
606     function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {
607         individualMaxCap = _individualMaxCap;
608         individualMaxCapTokens = _individualMaxCap * conversionRate;
609 
610         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
611     }
612 
613     /**
614      * @dev Extends the transaction validation to check if the value this higher than the minumum cap.
615      */
616     function validateTransaction() internal view {
617         super.validateTransaction();
618         require(msg.value >= individualMinCap);
619     }
620 
621     /**
622      * @dev We validate the new amount doesn't surpass maximum contribution cap
623      */
624     function handleTokens(address _address, uint256 _tokens) internal {
625         require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);
626 
627         super.handleTokens(_address, _tokens);
628     }
629 }
630 
631 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
632 
633 /**
634  * @title GasPriceLimitFundraiser
635  *
636  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
637  */
638 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
639     uint256 public gasPriceLimit;
640 
641     event GasPriceLimitChanged(uint256 gasPriceLimit);
642 
643     /**
644      * @dev This function puts the initial gas limit
645      */
646     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
647         gasPriceLimit = _gasPriceLimit;
648     }
649 
650     /**
651      * @dev This function allows the owner to change the gas limit any time during the fundraiser
652      */
653     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
654         gasPriceLimit = _gasPriceLimit;
655 
656         emit GasPriceLimitChanged(_gasPriceLimit);
657     }
658 
659     /**
660      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
661      */
662     function validateTransaction() internal view {
663         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
664 
665         return super.validateTransaction();
666     }
667 }
668 
669 // File: contracts/fundraiser/ForwardFundsFundraiser.sol
670 
671 /**
672  * @title Forward Funds to Beneficiary Fundraiser
673  *
674  * @dev This contract forwards the funds received to the beneficiary.
675  */
676 contract ForwardFundsFundraiser is BasicFundraiser {
677     /**
678      * @dev Forward funds directly to beneficiary
679      */
680     function handleFunds(address, uint256 _ethers) internal {
681         // Forward the funds directly to the beneficiary
682         beneficiary.transfer(_ethers);
683     }
684 }
685 
686 // File: contracts/Fundraiser.sol
687 
688 /**
689  * @title pheenToken
690  */
691 
692 contract pheenToken is MintableToken {
693     constructor(address _minter)
694         StandardToken(
695             "pheentoken",   // Token name
696             "PHN", // Token symbol
697             18  // Token decimals
698         )
699         
700         MintableToken(_minter)
701         public
702     {
703     }
704 }
705 
706 
707 
708 
709 
710 
711 /**
712  * @title pheenTokenFundraiser
713  */
714 
715 contract pheenTokenFundraiser is MintableTokenFundraiser, IndividualCapsFundraiser, ForwardFundsFundraiser, GasPriceLimitFundraiser {
716     
717 
718     constructor()
719         HasOwner(msg.sender)
720         public
721     {
722         token = new pheenToken(
723         
724         address(this)  // The fundraiser is the minter
725         );
726 
727         
728 
729         initializeBasicFundraiser(
730             1536998400, // Start date = 2018-09-15 08:00 UTC
731             1546286400,  // End date = 2018-12-31 20:00 UTC
732             10000000, // Conversion rate = 10000000 PHN per 1 ether
733             0x5A6af685A0EaDe973Eb46d89B5123ECf57494F15     // Beneficiary
734         );
735 
736         initializeIndividualCapsFundraiser(
737             (0.01 ether), // Minimum contribution
738             (5 ether)  // Maximum individual cap
739         );
740 
741         initializeGasPriceLimitFundraiser(
742             10000000000 // Gas price limit in wei
743         );
744 
745         
746 
747         
748 
749         
750 
751         
752     }
753     
754 }