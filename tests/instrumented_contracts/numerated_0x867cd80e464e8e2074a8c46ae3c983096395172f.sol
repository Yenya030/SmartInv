1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/modules/NounletAuction.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {NounletMinter as Minter, Permission} from \"./NounletMinter.sol\";\nimport {NFTReceiver as Receiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {SafeCastLib} from \"@rari-capital/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\n\nimport {INounletAuction as IAuction, Auction, Vault} from \"../interfaces/INounletAuction.sol\";\nimport {INounletRegistry as IRegistry} from \"../interfaces/INounletRegistry.sol\";\nimport {INounletToken as INounlet} from \"../interfaces/INounletToken.sol\";\n\n/// @title NounletAuction\n/// @author Tessera\n/// @notice Module contract for holding auctions of newly minted fractions\ncontract NounletAuction is IAuction, Minter, Receiver, ReentrancyGuard, SafeSend {\n    /// @dev Using safe casting library for uint256 types\n    using SafeCastLib for uint256;\n    /// @notice Address of NounletRegistry contract\n    address public immutable registry;\n    /// @notice Duration time of each auction\n    uint48 public constant DURATION = 4 hours;\n    /// @notice Percentage of minimum bid increase\n    uint48 public constant MIN_INCREASE = 5;\n    /// @notice Duration time extension for bids placed in final 10 minutes\n    uint48 public constant TIME_BUFFER = 10 minutes;\n    /// @notice Total supply of Nounlet tokens for each Noun\n    uint48 public constant TOTAL_SUPPLY = 100;\n    /// @notice Mapping of Vault address to struct of vault curator and current token ID\n    mapping(address => Vault) public vaultInfo;\n    /// @notice Mapping of Vault address to id to auction struct with bidder, bid amount, and endtime\n    mapping(address => mapping(uint256 => Auction)) public auctionInfo;\n\n    /// @dev Initializes NounletRegistry and NounletSupply contracts\n    constructor(address _registry, address _supply) Minter(_supply) {\n        registry = _registry;\n    }\n\n    /// @notice Creates a new auction for the first Nounlet of each Noun\n    /// @param _vault Address of the vault\n    /// @param _curator Address of the Noun owner\n    /// @param _mintProof Merkle proof for minting new Nounlets\n    function createAuction(\n        address _vault,\n        address _curator,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if first token has already been minted\n        if (vaultInfo[_vault].currentId != 0) revert AuctionAlreadyCreated();\n\n        // Sets the vault info and mints the first Nounlet\n        vaultInfo[_vault] = Vault(_curator, 1);\n        _create(_vault, 1, _mintProof);\n    }\n\n    /// @notice Settles the current auction and mints the next Nounlet\n    /// @param _vault Address of the vault\n    /// @param _mintProof Merkle proof for minting new Nounlets\n    function settleAuction(address _vault, bytes32[] calldata _mintProof) external nonReentrant {\n        // Settles the current auction and increments current ID in memory\n        uint256 id = uint256(vaultInfo[_vault].currentId);\n        _settle(_vault, id);\n        // Mints the next Nounlet if total supply is greater than or equal to current ID\n        if (uint256(TOTAL_SUPPLY) >= ++id) _create(_vault, id, _mintProof);\n    }\n\n    /// @notice Creates a new bid on the current auction of a given vault\n    /// @param _vault Address of the vault\n    function bid(address _vault) external payable nonReentrant {\n        // Gets the current ID and declares auction info in storage\n        uint256 id = uint256(vaultInfo[_vault].currentId);\n        Auction storage auction = auctionInfo[_vault][id];\n        // Reverts if end time of auction is less than current time\n        uint256 endTime = uint256(auction.endTime);\n        if (endTime < block.timestamp) revert AuctionExpired();\n        // Reverts if current bid is not at least 5% greater than the previous bid\n        uint256 ethAmount = auction.amount;\n        if (msg.value < ethAmount + ((ethAmount * MIN_INCREASE) / 100)) revert InvalidBidIncrease();\n\n        // Updates auction end time if less than current time plus time buffer of 10 minutes\n        address token = IRegistry(registry).vaultToToken(_vault);\n        uint256 extendedTime = block.timestamp + TIME_BUFFER;\n        if (endTime < extendedTime) auction.endTime = extendedTime.safeCastTo32();\n\n        // Sets bidder and bid amount to auction info in storage\n        _sendEthOrWeth(auction.bidder, ethAmount);\n        auction.bidder = msg.sender;\n        auction.amount = msg.value.safeCastTo64();\n\n        // Emits bid event and transfers bid amount to this contract\n        emit Bid(_vault, token, id, msg.sender, msg.value, auction.endTime);\n    }\n\n    /// @dev Creates a new auction and initializes auction info\n    /// @param _vault Address of the vault\n    /// @param _id ID of the token\n    /// @param _mintProof Merkle proof for minting new Nounlets\n    function _create(\n        address _vault,\n        uint256 _id,\n        bytes32[] calldata _mintProof\n    ) internal {\n        // Mints a new fraction through NounletMinter module\n        _mintFraction(_vault, address(this), _id, _mintProof);\n\n        // Initializes end time and sets first bidder as vault curator\n        address token = IRegistry(registry).vaultToToken(_vault);\n        uint256 endTime = block.timestamp + DURATION;\n        auctionInfo[_vault][_id].endTime = endTime.safeCastTo32();\n        auctionInfo[_vault][_id].bidder = vaultInfo[_vault].curator;\n\n        // Emits event for creating new auction\n        emit Created(_vault, token, _id, endTime);\n    }\n\n    /// @dev Settles a finished auction\n    /// @param _vault Address of the vault\n    /// @param _id ID of the token\n    function _settle(address _vault, uint256 _id) internal {\n        // Reverts if auction end time is greater than current time\n        Auction memory auction = auctionInfo[_vault][_id];\n        if (uint256(auction.endTime) > block.timestamp) revert AuctionNotCompleted();\n        if (uint256(TOTAL_SUPPLY) < _id) revert AuctionExpired();\n\n        // Gets royalty info based on final bid amount\n        uint64 bidAmount = auction.amount;\n        address token = IRegistry(registry).vaultToToken(_vault);\n        (address beneficiary, uint256 royaltyAmount) = INounlet(token).royaltyInfo(_id, bidAmount);\n\n        //Transfers nounlet to winner\n        INounlet(token).transferFrom(address(this), auction.bidder, _id, 1, \"\");\n\n        // Increments current ID in storage\n        ++vaultInfo[_vault].currentId;\n\n        // Transfers bid amount to curator and royalties to creator\n        _sendEthOrWeth(vaultInfo[_vault].curator, bidAmount - royaltyAmount);\n        _sendEthOrWeth(beneficiary, royaltyAmount);\n\n        // Emits event for settling current auction\n        emit Settled(_vault, token, _id, auction.bidder, bidAmount);\n    }\n}\n"
6     },
7     "src/modules/NounletMinter.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {INounletMinter as IMinter, Permission} from \"../interfaces/INounletMinter.sol\";\nimport {INounletSupply as ISupply} from \"../interfaces/INounletSupply.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\n\n/// @title NounletMinter\n/// @author Tessera\n/// @notice Module contract for minting new fractions\ncontract NounletMinter is IMinter {\n    /// @notice Address of NounletSupply target contract\n    address public immutable supply;\n\n    /// @dev Initializes NounletSupply target contract\n    constructor(address _supply) {\n        supply = _supply;\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes A list of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        nodes = new bytes32[](permissions.length);\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions A list of Permission Structs\n    function getPermissions() public view returns (Permission[] memory permissions) {\n        permissions = new Permission[](1);\n        // Mint function selector from supply contract\n        permissions[0] = Permission(address(this), supply, ISupply.mint.selector);\n    }\n\n    /// @notice Mints a single fraction\n    /// @param _vault Address of the Vault\n    /// @param _to Address of the receiver\n    /// @param _id ID of the fractional token\n    /// @param _mintProof Merkle proof for minting fractions\n    function _mintFraction(\n        address _vault,\n        address _to,\n        uint256 _id,\n        bytes32[] calldata _mintProof\n    ) internal {\n        bytes memory data = abi.encodeCall(ISupply.mint, (_to, _id));\n        IVault(payable(_vault)).execute(supply, data, _mintProof);\n    }\n}\n"
9     },
10     "src/utils/NFTReceiver.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ERC721TokenReceiver} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {ERC1155TokenReceiver} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\n\n/// @title NFT Receiver\n/// @author Tessera\n/// @notice Plugin contract for handling receipts of non-fungible tokens\ncontract NFTReceiver is ERC721TokenReceiver, ERC1155TokenReceiver {\n    /// @notice Handles the receipt of a single ERC721 token\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n\n    /// @notice Handles the receipt of a single ERC1155 token type\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    /// @notice Handles the receipt of multiple ERC1155 token types\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
12     },
13     "lib/solmate/src/utils/ReentrancyGuard.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
15     },
16     "lib/solmate/src/utils/SafeCastLib.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
18     },
19     "src/utils/SafeSend.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {WETH} from \"@rari-capital/solmate/src/tokens/WETH.sol\";\n\n/// @title SafeSend\n/// @author Tessera\n/// @notice Utility contract for sending Ether or WETH value to an address\nabstract contract SafeSend {\n    /// @notice Address for WETH contract on mainnet\n    address payable public constant WETH_ADDRESS =\n        payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /// @notice Attempts to send ether to an address\n    /// @param _to Address attemping to send to\n    /// @param _value Amount to send\n    /// @return success Status of transfer\n    function _attemptETHTransfer(address _to, uint256 _value) internal returns (bool success) {\n        assembly {\n            success := call(gas(), _to, _value, 0, 0, 0, 0)\n        }\n    }\n\n    /// @notice Sends eth or weth to an address\n    /// @param _to Address to send to\n    /// @param _value Amount to send\n    function _sendEthOrWeth(address _to, uint256 _value) internal {\n        if (!_attemptETHTransfer(_to, _value)) {\n            WETH(WETH_ADDRESS).deposit{value: _value}();\n            WETH(WETH_ADDRESS).transfer(_to, _value);\n        }\n    }\n}\n"
21     },
22     "src/interfaces/INounletAuction.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule, Permission} from \"./IModule.sol\";\n\n/// @dev Auction information\nstruct Auction {\n    // Address of the highest bidder\n    address bidder;\n    // Amount of the highest bid\n    uint64 amount;\n    // End time of the auction\n    uint32 endTime;\n}\n\n/// @dev Vault information\nstruct Vault {\n    // Address of the vault curator\n    address curator;\n    // Current ID of the token\n    uint96 currentId;\n}\n\n/// @dev Interface for NounletAuction contract\ninterface INounletAuction is IModule {\n    /// @dev Emitted when the auction has already been created for the first Nounlet of a Noun\n    error AuctionAlreadyCreated();\n    /// @dev Emitted when the auction has not completed\n    error AuctionNotCompleted();\n    /// @dev Emitted when the auction has already ended\n    error AuctionExpired();\n    /// @dev Emitted when the minimum bid increase has not been met\n    error InvalidBidIncrease();\n    /// @dev Emitted when the caller is the not the auction winner\n    error NotWinner();\n\n    /// @dev Event log for creating a new auction\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token contract\n    /// @param _id ID of the token\n    /// @param _endTime End time of the auction\n    event Created(\n        address indexed _vault,\n        address indexed _token,\n        uint256 indexed _id,\n        uint256 _endTime\n    );\n\n    /// @dev Event log for bidding on an auction\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token contract\n    /// @param _id ID of the token\n    /// @param _bidder Address of the bidder\n    /// @param _value Ether value of the current bid\n    /// @param _endTime New end time if bid is placed in final 10 minutes\n    event Bid(\n        address indexed _vault,\n        address indexed _token,\n        uint256 indexed _id,\n        address _bidder,\n        uint256 _value,\n        uint256 _endTime\n    );\n\n    /// @dev Event log for settling a finished auction\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token contract\n    /// @param _id ID of the token\n    /// @param _winner Address of the highest bidder at auction end\n    /// @param _amount Ether value of the highest bid at auction end\n    event Settled(\n        address indexed _vault,\n        address indexed _token,\n        uint256 indexed _id,\n        address _winner,\n        uint256 _amount\n    );\n\n    function DURATION() external view returns (uint48);\n\n    function MIN_INCREASE() external view returns (uint48);\n\n    function TIME_BUFFER() external view returns (uint48);\n\n    function TOTAL_SUPPLY() external view returns (uint48);\n\n    function auctionInfo(address, uint256)\n        external\n        view\n        returns (\n            address bidder,\n            uint64 bid,\n            uint32 endTime\n        );\n\n    function bid(address _vault) external payable;\n\n    function registry() external view returns (address);\n\n    function createAuction(\n        address _vault,\n        address _curator,\n        bytes32[] calldata _mintProof\n    ) external;\n\n    function settleAuction(address _vault, bytes32[] calldata _mintProof) external;\n\n    function vaultInfo(address) external view returns (address curator, uint96 currentId);\n}\n"
24     },
25     "src/interfaces/INounletRegistry.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev Interface for NounletRegistry contract\ninterface INounletRegistry {\n    /// @dev Emitted when the caller is not a registered vault\n    error UnregisteredVault(address _sender);\n\n    /// @dev Event log for deploying vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    event VaultDeployed(address indexed _vault, address indexed _token);\n\n    function batchBurn(address _from, uint256[] memory _ids) external;\n\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors,\n        address _descriptor,\n        uint256 _nounId\n    ) external returns (address vault);\n\n    function factory() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function mint(address _to, uint256 _id) external;\n\n    function nounsToken() external view returns (address);\n\n    function royaltyBeneficiary() external view returns (address);\n\n    function uri(address _vault, uint256 _id) external view returns (string memory);\n\n    function vaultToToken(address) external view returns (address token);\n}\n"
27     },
28     "src/interfaces/INounletToken.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {INounsSeeder} from \"./INounsSeeder.sol\";\n\n/// @dev Checkpoint information\nstruct Checkpoint {\n    // Timestamp of checkpoint creation\n    uint64 fromTimestamp;\n    // Amount of votes\n    uint192 votes;\n}\n\n/// @dev Interface for NounletToken contract\ninterface INounletToken is IERC165 {\n    /// @dev Emitted when deadline for signature has passed\n    error SignatureExpired(uint256 _timestamp, uint256 _deadline);\n    /// @dev Emitted when caller is not required address\n    error InvalidSender(address _required, address _provided);\n    /// @dev Emitted when owner signature is invalid\n    error InvalidSignature(address _signer, address _owner);\n\n    /// @dev Event log for approving a spender of a token type\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    event SingleApproval(\n        address indexed _owner,\n        address indexed _operator,\n        uint256 _id,\n        bool _approved\n    );\n\n    function NOUNLET_REGISTRY() external pure returns (address);\n\n    function NOUNS_DESCRIPTOR() external pure returns (address);\n\n    function NOUNS_TOKEN_ID() external pure returns (uint256);\n\n    function ROYALTY_BENEFICIARY() external pure returns (address);\n\n    function batchBurn(address _from, uint256[] memory _ids) external;\n\n    function generateSeed(uint256 _id) external view returns (INounsSeeder.Seed memory);\n\n    function isApproved(\n        address,\n        address,\n        uint256\n    ) external view returns (bool);\n\n    function mint(\n        address _to,\n        uint256 _id,\n        bytes memory _data\n    ) external;\n\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) external;\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function batchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external;\n\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external;\n\n    function supportsInterface(bytes4 _interfaceId) external view returns (bool);\n\n    function uri(uint256 _id) external view returns (string memory);\n}\n"
30     },
31     "src/interfaces/INounletMinter.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IModule, Permission} from \"./IModule.sol\";\n\n/// @dev Interface for NounletMinter contract\ninterface INounletMinter is IModule {\n    function supply() external view returns (address);\n}\n"
33     },
34     "src/interfaces/INounletSupply.sol": {
35       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev Interface for NounletSupply target contract\ninterface INounletSupply {\n    function batchBurn(address _from, uint256[] memory _ids) external;\n\n    function mint(address _to, uint256 _id) external;\n}\n"
36     },
37     "src/interfaces/IVault.sol": {
38       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev Interface for Vault proxy contract\ninterface IVault {\n    /// @dev Emitted when execution reverted with no reason\n    error ExecutionReverted();\n    /// @dev Emitted when ownership of the proxy has been renounced\n    error Initialized(address _owner, address _newOwner, uint256 _nonce);\n    /// @dev Emitted when there is no implementation stored in methods for a function signature\n    error MethodNotFound();\n    /// @dev Emitted when length of input arrays don't match\n    error ArrayMismatch(uint256 _pluginsLength, uint256 _selectorsLength);\n    /// @dev Emitted when a plugin selector would overwrite an existing plugin\n    error InvalidSelector(bytes4 _selector);\n    /// @dev Emitted when the caller is not the owner\n    error NotAuthorized(address _caller, address _target, bytes4 _selector);\n    /// @dev Emitted when the caller is not the owner\n    error NotOwner(address _owner, address _caller);\n    /// @dev Emitted when the owner is changed during the DELEGATECALL\n    error OwnerChanged(address _originalOwner, address _newOwner);\n    /// @dev Emitted when passing an EOA or an undeployed contract as the target\n    error TargetInvalid(address _target);\n\n    /// @dev Event log for executing transactions\n    /// @param _target Address of target contract\n    /// @param _data Transaction data being executed\n    /// @param _response Return data of delegatecall\n    event Execute(address indexed _target, bytes _data, bytes _response);\n    /// @dev Event log for installing plugins\n    /// @param _selectors List of function selectors\n    /// @param _plugins List of plugin contracts\n    event UpdatedPlugins(bytes4[] _selectors, address[] _plugins);\n\n    function execute(\n        address _target,\n        bytes memory _data,\n        bytes32[] memory _proof\n    ) external payable returns (bool success, bytes memory response);\n\n    function setPlugins(address[] memory _plugins, bytes4[] memory _selectors) external;\n\n    function methods(bytes4) external view returns (address);\n\n    function MERKLE_ROOT() external view returns (bytes32);\n\n    function OWNER() external view returns (address);\n\n    function FACTORY() external view returns (address);\n}\n"
39     },
40     "lib/solmate/src/tokens/ERC721.sol": {
41       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
42     },
43     "lib/solmate/src/tokens/ERC1155.sol": {
44       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
45     },
46     "lib/solmate/src/tokens/WETH.sol": {
47       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
48     },
49     "src/interfaces/IModule.sol": {
50       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Permission} from \"./IVaultRegistry.sol\";\n\n/// @dev Interface for generic Module contract\ninterface IModule {\n    function getLeafNodes() external view returns (bytes32[] memory nodes);\n\n    function getPermissions() external view returns (Permission[] memory permissions);\n}\n"
51     },
52     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
53       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
54     },
55     "src/interfaces/INounsSeeder.sol": {
56       "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Interface for NounsSeeder\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.13;\n\nimport {INounsDescriptor} from \"./INounsDescriptor.sol\";\n\ninterface INounsSeeder {\n    struct Seed {\n        uint48 background;\n        uint48 body;\n        uint48 accessory;\n        uint48 head;\n        uint48 glasses;\n    }\n\n    function generateSeed(uint256 nounId, INounsDescriptor descriptor)\n        external\n        view\n        returns (Seed memory);\n}\n"
57     },
58     "lib/solmate/src/tokens/ERC20.sol": {
59       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
60     },
61     "lib/solmate/src/utils/SafeTransferLib.sol": {
62       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
63     },
64     "src/interfaces/IVaultRegistry.sol": {
65       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev Vault permissions\nstruct Permission {\n    // Address of module contract\n    address module;\n    // Address of target contract\n    address target;\n    // Function selector from target contract\n    bytes4 selector;\n}\n\n/// @dev Vault information\nstruct VaultInfo {\n    // Address of FERC1155 token contract\n    address token;\n    // ID of the token type\n    uint256 id;\n}\n\n/// @dev Interface for VaultRegistry contract\ninterface IVaultRegistry {\n    /// @dev Emitted when the caller is not the controller\n    error InvalidController(address _controller, address _sender);\n    /// @dev Emitted when the caller is not a registered vault\n    error UnregisteredVault(address _sender);\n\n    /// @dev Event log for deploying vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _id Id of the token\n    event VaultDeployed(address indexed _vault, address indexed _token, uint256 _id);\n\n    function burn(address _from, uint256 _value) external;\n\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault);\n\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token);\n\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token);\n\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault);\n\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault);\n\n    function factory() external view returns (address);\n\n    function fNFT() external view returns (address);\n\n    function fNFTImplementation() external view returns (address);\n\n    function mint(address _to, uint256 _value) external;\n\n    function nextId(address) external view returns (uint256);\n\n    function totalSupply(address _vault) external view returns (uint256);\n\n    function uri(address _vault) external view returns (string memory);\n\n    function vaultToToken(address) external view returns (address token, uint256 id);\n}\n"
66     },
67     "src/interfaces/INounsDescriptor.sol": {
68       "content": "// SPDX-License-Identifier: GPL-3.0\n\n/// @title Common interface for NounsDescriptor versions, as used by NounsToken and NounsSeeder.\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\npragma solidity ^0.8.13;\n\nimport {INounsSeeder} from \"./INounsSeeder.sol\";\n\ninterface INounsDescriptor {\n    function tokenURI(uint256 tokenId, INounsSeeder.Seed memory seed)\n        external\n        view\n        returns (string memory);\n\n    function dataURI(uint256 tokenId, INounsSeeder.Seed memory seed)\n        external\n        view\n        returns (string memory);\n\n    function backgroundCount() external view returns (uint256);\n\n    function bodyCount() external view returns (uint256);\n\n    function accessoryCount() external view returns (uint256);\n\n    function headCount() external view returns (uint256);\n\n    function glassesCount() external view returns (uint256);\n\n    function genericDataURI(\n        string calldata name,\n        string calldata description,\n        INounsSeeder.Seed memory seed\n    ) external view returns (string memory);\n}\n"
69     }
70   },
71   "settings": {
72     "remappings": [
73       "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
74       "@rari-capital/solmate/src/=lib/solmate/src/",
75       "base64-sol/=lib/base64/",
76       "base64/=lib/base64/",
77       "clones-with-immutable-args/=lib/clones-with-immutable-args/",
78       "ds-test/=lib/clones-with-immutable-args/lib/ds-test/src/",
79       "forge-std/=lib/forge-std/src/",
80       "nouns-contracts/=lib/nouns-monorepo/packages/nouns-contracts/",
81       "nouns-monorepo/=lib/nouns-monorepo/",
82       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
83       "solmate/=lib/solmate/src/"
84     ],
85     "optimizer": {
86       "enabled": true,
87       "runs": 200
88     },
89     "metadata": {
90       "bytecodeHash": "ipfs"
91     },
92     "outputSelection": {
93       "*": {
94         "*": [
95           "evm.bytecode",
96           "evm.deployedBytecode",
97           "devdoc",
98           "userdoc",
99           "metadata",
100           "abi"
101         ]
102       }
103     },
104     "evmVersion": "london",
105     "libraries": {}
106   }
107 }}