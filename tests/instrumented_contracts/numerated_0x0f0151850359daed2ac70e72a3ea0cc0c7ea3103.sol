1 //*********************************************************************//
2 //*********************************************************************//
3 //
4 // ,*,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*,**************************************
5 // ****,**********,,,,,,,,,,,,,,,,,,*******,*******,*,,,,,,,,,*,,,,,,,,,,,,,,,,,,**,***************************************
6 // ****,*******,***,,,,,,,,,,,,,***,*******,***,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,**************************************
7 // ,***************,(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@************////
8 // *****************(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#*/*********/*///
9 // *****************(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#//*****/*///////
10 // *****************(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(////***/////////
11 // *****************(@@@@@@@@@/******************************************************************@@@@@@@@@(//////*/////////
12 // *****************#@&@@@@@@@/******************************************************************@@@&@&@@@(////////////////
13 // *****************#@@@@@@@@@(******************************************************************@@@&@&@@@(////////////////
14 // *****************#@@@@@@@@@(******************************************************************@@@&@&@@@#////////////////
15 // *****************(@@@@@@@@@(**********************************/(******************************@@@&@@@@@#////////////////
16 // *****************(@@@@@@@@@(******************************&@@&&&&(#(%#&***********************@@@@@@@@@#////////////////
17 // *****************(@@@@@@@@@(****************************#@@@&@&&&@(((#%&**********************@@@@@@@@@(////////////////
18 // *****************(@@@@@@@@@#***************************@@&@@@@@((//,*#@@@*********************@@@@@@@@@(//(/////////////
19 // *****************(@@@@@@@@@#*************************#@@@@@@@@@@@(@@(%##%@%******************/@@@@@@@@@#(((((///////////
20 // ****************/(@@@@@@@@@#************************@@@@@@@@@@@@#(%#%(#%@@@&*****************/@@@@@@@@@(/((((///////////
21 // *****************(@@@@@@@@@#**********************@&@@@@@@@@@@@@@@@@@@@#(#((/&***************(@@@@@@@@@#((((((//////////
22 // *************////#@@@@@@@@@#**********************@@@@@@@@@@@&@&&&%&%@@@@@@@@(***************(@@@@@@@@@#((((((////////((
23 // ************/////#@@@@@@@@@#************************@@@@@@@@@&&&&@%&@@@@@@@@*****************#@@@@@@@@@#((((((///////(((
24 // *******/*////////#@&@@@@@@@%**************************@@@@@@@@@@@@@@&&@@@@@******************#@@@@@@@@@#((((((///////(((
25 // *******/////////(#@@@@@@@@@%***************************&@@@@%&@@@@@@@@@@@*******************/#@@@@@@@@@#((((((((//((((((
26 // *///////////////(#@@@@@@@@@%******************/@@@@@@@@@@@@@@&@@@@@@@@@@@********************#@@@@@@@@@#((((((((((((((((
27 // ////////////////(#@@@@@@@@@%************&@@@@@@@@@@@@@@@@@@&@@@@@@#@@,@/@&******************/#@@@@@@@@@#((((((((((((((((
28 // ////////////////(#@@@@@@@@@%**************@@&&@@@@@@@@@@@&@@@@,@@#@@@@(@@@@*****************/%@@@@@@@@@#((((((((((((((((
29 // ////////////////(#@@@@@@@@@&**************@@@@@&@@@@@@@@@@@@@@@@@@/@@@@@@@@***************///%@@@@@@@@@%((((((((((((((((
30 // ////////////////(#@@@@@@@@@&***********/%/@@@@@@@@&@@@@@@&@@@@@@@@@@@@@@@@@&%@************///#@@@@@@@@@#((((((((((((((((
31 // ////////////////(#@@@@@@@@@&**********&@@@@@@@@@@@@@@@@@@(@@@@@@@@@@@@@@@@@@&#&#&@*********//#@@@@@@@@@#((((((((((((((((
32 // ////////////////(#@@@@@@@@@@******@@@%(#%@@@@@@@@@@@@@@@&@@@@&&%@@@@@@@@@@@@@@@&%&&%(#&(****/%@@@@@@@@@#((((((((((((((((
33 // ///////////////((#@@@@@@@@@@****@%&%%#%%@@@@&@@@@@@@@@@@@@@&(@@@@@@&@@@@@@@@@@&&&&@%&%@@****/&@@@@@@@@@#((((((((((((((((
34 // ///////////////((#@@@@@@@@@@****@%&@%@&%@&&&@@@@@@&&&@&@@@@@@@@@%&&@&&&@@@@@@@@@&&@@@@@&&**//&@@@@@@@@@%((((((((((((((((
35 // //////////////(((#@@@@@@@@@@****@@&@@&&&@@@@&&&&@@&&&@&&&@@@@@@@@&&&&@@@@@@@@@&&&@@@@@@@@**//@@@@@@@@@@#((((((((((((((((
36 // ////////////(((((#@@@@@@@@@@***@@&@@@@&&@@@&&##&@@&&&@%@@@@&&@@&@&&@@&@@@@@@@@@&&&@@@@@@@@**/@@@@@@@@@@#((((((((((((((((
37 // //////////(((((((#@@@@@@@@@@***@@&&@@@@@&@@&@@@&@@@@@%%&@@@@&@%@@&&%&@@@@@@(@%(@@@@@@&@@@@**/@@@@@@@@@@#((((((((((((((((
38 // //////////(((((((#@@@@@@@@@@**&@@@@@@@@@&@@&@,@/,@,@@,@@#@@@(/@@@**@*%&&&@&%*@@(&@@@@&@@@@@//@@@@@@@@@@#((((((((((((((((
39 // /////////((((((((#@@@@@@@@@@**@@&@@@@@@@&@@&@,@(,@,@@,&%#@&&//@@/*@&**&&,@@(&*,@@@@@@@@@@@@//@@@@@@@@@@#((((((((((((((((
40 // /////////((((((((#@@@@@@@@@@*(@&@@@@@@@@&@@@@&&&@@@@@&@@&&&&&@@@@@@&@@@@@@@@&&&@@@@@@@@@@@@@/@@@@@@@@@@#((((((((((((((((
41 // ///((((((((((((((#@@@@@@@@@@*@&&@@@@@@@@&@@@@@&@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@/@@@@@@@@@@#((((((((((((((((
42 // /(((/(((/(((((((((@@@@@@@@@@*@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/@@@@@@@@@@#((((((((((((((((
43 // (((((((((((((((((#@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@%%%((#&@&&@@&@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@#((((((((((((((((
44 // ((((((((((((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((((((((((((((((
45 // (((((((((((((((((#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@#((((((((((((((((
46 // (((((((((((((((((#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@#((((((((((((((((
47 // (((((((((((((((((#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((((((((((((#(((
48 // (((((((((((((((((#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#(((((((((((#(((#
49 // (((((((((((((((((##%%%%%%%%%%%%####%%%%%%%%%%%%%%%%#########%##%#%##########%%%%%%%%%%%%&%%%%%###%%%%###(((((###(#######
50 // (((((((((((((((((((((((((((((((((((((((((((((#((((((((((((((((((((((((((((((((((((((((((((((((((#((((((((((((###########
51 // (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((#(((((##((#(##(############
52 //
53 //*********************************************************************//
54 //*********************************************************************//
55   
56 //-------------DEPENDENCIES--------------------------//
57 
58 // File: @openzeppelin/contracts/utils/Address.sol
59 
60 
61 // OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)
62 
63 pragma solidity ^0.8.1;
64 
65 /**
66  * @dev Collection of functions related to the address type
67  */
68 library Address {
69     /**
70      * @dev Returns true if account is a contract.
71      *
72      * [IMPORTANT]
73      * ====
74      * It is unsafe to assume that an address for which this function returns
75      * false is an externally-owned account (EOA) and not a contract.
76      *
77      * Among others, isContract will return false for the following
78      * types of addresses:
79      *
80      *  - an externally-owned account
81      *  - a contract in construction
82      *  - an address where a contract will be created
83      *  - an address where a contract lived, but was destroyed
84      * ====
85      *
86      * [IMPORTANT]
87      * ====
88      * You shouldn't rely on isContract to protect against flash loan attacks!
89      *
90      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
91      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
92      * constructor.
93      * ====
94      */
95     function isContract(address account) internal view returns (bool) {
96         // This method relies on extcodesize/address.code.length, which returns 0
97         // for contracts in construction, since the code is only stored at the end
98         // of the constructor execution.
99 
100         return account.code.length > 0;
101     }
102 
103     /**
104      * @dev Replacement for Solidity's transfer: sends amount wei to
105      * recipient, forwarding all available gas and reverting on errors.
106      *
107      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
108      * of certain opcodes, possibly making contracts go over the 2300 gas limit
109      * imposed by transfer, making them unable to receive funds via
110      * transfer. {sendValue} removes this limitation.
111      *
112      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
113      *
114      * IMPORTANT: because control is transferred to recipient, care must be
115      * taken to not create reentrancy vulnerabilities. Consider using
116      * {ReentrancyGuard} or the
117      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
118      */
119     function sendValue(address payable recipient, uint256 amount) internal {
120         require(address(this).balance >= amount, "Address: insufficient balance");
121 
122         (bool success, ) = recipient.call{value: amount}("");
123         require(success, "Address: unable to send value, recipient may have reverted");
124     }
125 
126     /**
127      * @dev Performs a Solidity function call using a low level call. A
128      * plain call is an unsafe replacement for a function call: use this
129      * function instead.
130      *
131      * If target reverts with a revert reason, it is bubbled up by this
132      * function (like regular Solidity function calls).
133      *
134      * Returns the raw returned data. To convert to the expected return value,
135      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[abi.decode].
136      *
137      * Requirements:
138      *
139      * - target must be a contract.
140      * - calling target with data must not revert.
141      *
142      * _Available since v3.1._
143      */
144     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
145         return functionCall(target, data, "Address: low-level call failed");
146     }
147 
148     /**
149      * @dev Same as {xref-Address-functionCall-address-bytes-}[functionCall], but with
150      * errorMessage as a fallback revert reason when target reverts.
151      *
152      * _Available since v3.1._
153      */
154     function functionCall(
155         address target,
156         bytes memory data,
157         string memory errorMessage
158     ) internal returns (bytes memory) {
159         return functionCallWithValue(target, data, 0, errorMessage);
160     }
161 
162     /**
163      * @dev Same as {xref-Address-functionCall-address-bytes-}[functionCall],
164      * but also transferring value wei to target.
165      *
166      * Requirements:
167      *
168      * - the calling contract must have an ETH balance of at least value.
169      * - the called Solidity function must be payable.
170      *
171      * _Available since v3.1._
172      */
173     function functionCallWithValue(
174         address target,
175         bytes memory data,
176         uint256 value
177     ) internal returns (bytes memory) {
178         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
179     }
180 
181     /**
182      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[functionCallWithValue], but
183      * with errorMessage as a fallback revert reason when target reverts.
184      *
185      * _Available since v3.1._
186      */
187     function functionCallWithValue(
188         address target,
189         bytes memory data,
190         uint256 value,
191         string memory errorMessage
192     ) internal returns (bytes memory) {
193         require(address(this).balance >= value, "Address: insufficient balance for call");
194         require(isContract(target), "Address: call to non-contract");
195 
196         (bool success, bytes memory returndata) = target.call{value: value}(data);
197         return verifyCallResult(success, returndata, errorMessage);
198     }
199 
200     /**
201      * @dev Same as {xref-Address-functionCall-address-bytes-}[functionCall],
202      * but performing a static call.
203      *
204      * _Available since v3.3._
205      */
206     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
207         return functionStaticCall(target, data, "Address: low-level static call failed");
208     }
209 
210     /**
211      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[functionCall],
212      * but performing a static call.
213      *
214      * _Available since v3.3._
215      */
216     function functionStaticCall(
217         address target,
218         bytes memory data,
219         string memory errorMessage
220     ) internal view returns (bytes memory) {
221         require(isContract(target), "Address: static call to non-contract");
222 
223         (bool success, bytes memory returndata) = target.staticcall(data);
224         return verifyCallResult(success, returndata, errorMessage);
225     }
226 
227     /**
228      * @dev Same as {xref-Address-functionCall-address-bytes-}[functionCall],
229      * but performing a delegate call.
230      *
231      * _Available since v3.4._
232      */
233     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
234         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
235     }
236 
237     /**
238      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[functionCall],
239      * but performing a delegate call.
240      *
241      * _Available since v3.4._
242      */
243     function functionDelegateCall(
244         address target,
245         bytes memory data,
246         string memory errorMessage
247     ) internal returns (bytes memory) {
248         require(isContract(target), "Address: delegate call to non-contract");
249 
250         (bool success, bytes memory returndata) = target.delegatecall(data);
251         return verifyCallResult(success, returndata, errorMessage);
252     }
253 
254     /**
255      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
256      * revert reason using the provided one.
257      *
258      * _Available since v4.3._
259      */
260     function verifyCallResult(
261         bool success,
262         bytes memory returndata,
263         string memory errorMessage
264     ) internal pure returns (bytes memory) {
265         if (success) {
266             return returndata;
267         } else {
268             // Look for revert reason and bubble it up if present
269             if (returndata.length > 0) {
270                 // The easiest way to bubble the revert reason is using memory via assembly
271 
272                 assembly {
273                     let returndata_size := mload(returndata)
274                     revert(add(32, returndata), returndata_size)
275                 }
276             } else {
277                 revert(errorMessage);
278             }
279         }
280     }
281 }
282 
283 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
284 
285 
286 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)
287 
288 pragma solidity ^0.8.0;
289 
290 /**
291  * @title ERC721 token receiver interface
292  * @dev Interface for any contract that wants to support safeTransfers
293  * from ERC721 asset contracts.
294  */
295 interface IERC721Receiver {
296     /**
297      * @dev Whenever an {IERC721} tokenId token is transferred to this contract via {IERC721-safeTransferFrom}
298      * by operator from from, this function is called.
299      *
300      * It must return its Solidity selector to confirm the token transfer.
301      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
302      *
303      * The selector can be obtained in Solidity with IERC721.onERC721Received.selector.
304      */
305     function onERC721Received(
306         address operator,
307         address from,
308         uint256 tokenId,
309         bytes calldata data
310     ) external returns (bytes4);
311 }
312 
313 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
314 
315 
316 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
317 
318 pragma solidity ^0.8.0;
319 
320 /**
321  * @dev Interface of the ERC165 standard, as defined in the
322  * https://eips.ethereum.org/EIPS/eip-165[EIP].
323  *
324  * Implementers can declare support of contract interfaces, which can then be
325  * queried by others ({ERC165Checker}).
326  *
327  * For an implementation, see {ERC165}.
328  */
329 interface IERC165 {
330     /**
331      * @dev Returns true if this contract implements the interface defined by
332      * interfaceId. See the corresponding
333      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
334      * to learn more about how these ids are created.
335      *
336      * This function call must use less than 30 000 gas.
337      */
338     function supportsInterface(bytes4 interfaceId) external view returns (bool);
339 }
340 
341 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
342 
343 
344 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
345 
346 pragma solidity ^0.8.0;
347 
348 
349 /**
350  * @dev Implementation of the {IERC165} interface.
351  *
352  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
353  * for the additional interface id that will be supported. For example:
354  *
355  * solidity
356  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
357  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
358  * }
359  * 
360  *
361  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
362  */
363 abstract contract ERC165 is IERC165 {
364     /**
365      * @dev See {IERC165-supportsInterface}.
366      */
367     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
368         return interfaceId == type(IERC165).interfaceId;
369     }
370 }
371 
372 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
373 
374 
375 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)
376 
377 pragma solidity ^0.8.0;
378 
379 
380 /**
381  * @dev Required interface of an ERC721 compliant contract.
382  */
383 interface IERC721 is IERC165 {
384     /**
385      * @dev Emitted when tokenId token is transferred from from to to.
386      */
387     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
388 
389     /**
390      * @dev Emitted when owner enables approved to manage the tokenId token.
391      */
392     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
393 
394     /**
395      * @dev Emitted when owner enables or disables (approved) operator to manage all of its assets.
396      */
397     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
398 
399     /**
400      * @dev Returns the number of tokens in owner's account.
401      */
402     function balanceOf(address owner) external view returns (uint256 balance);
403 
404     /**
405      * @dev Returns the owner of the tokenId token.
406      *
407      * Requirements:
408      *
409      * - tokenId must exist.
410      */
411     function ownerOf(uint256 tokenId) external view returns (address owner);
412 
413     /**
414      * @dev Safely transfers tokenId token from from to to, checking first that contract recipients
415      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
416      *
417      * Requirements:
418      *
419      * - from cannot be the zero address.
420      * - to cannot be the zero address.
421      * - tokenId token must exist and be owned by from.
422      * - If the caller is not from, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
423      * - If to refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
424      *
425      * Emits a {Transfer} event.
426      */
427     function safeTransferFrom(
428         address from,
429         address to,
430         uint256 tokenId
431     ) external;
432 
433     /**
434      * @dev Transfers tokenId token from from to to.
435      *
436      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
437      *
438      * Requirements:
439      *
440      * - from cannot be the zero address.
441      * - to cannot be the zero address.
442      * - tokenId token must be owned by from.
443      * - If the caller is not from, it must be approved to move this token by either {approve} or {setApprovalForAll}.
444      *
445      * Emits a {Transfer} event.
446      */
447     function transferFrom(
448         address from,
449         address to,
450         uint256 tokenId
451     ) external;
452 
453     /**
454      * @dev Gives permission to to to transfer tokenId token to another account.
455      * The approval is cleared when the token is transferred.
456      *
457      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
458      *
459      * Requirements:
460      *
461      * - The caller must own the token or be an approved operator.
462      * - tokenId must exist.
463      *
464      * Emits an {Approval} event.
465      */
466     function approve(address to, uint256 tokenId) external;
467 
468     /**
469      * @dev Returns the account approved for tokenId token.
470      *
471      * Requirements:
472      *
473      * - tokenId must exist.
474      */
475     function getApproved(uint256 tokenId) external view returns (address operator);
476 
477     /**
478      * @dev Approve or remove operator as an operator for the caller.
479      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
480      *
481      * Requirements:
482      *
483      * - The operator cannot be the caller.
484      *
485      * Emits an {ApprovalForAll} event.
486      */
487     function setApprovalForAll(address operator, bool _approved) external;
488 
489     /**
490      * @dev Returns if the operator is allowed to manage all of the assets of owner.
491      *
492      * See {setApprovalForAll}
493      */
494     function isApprovedForAll(address owner, address operator) external view returns (bool);
495 
496     /**
497      * @dev Safely transfers tokenId token from from to to.
498      *
499      * Requirements:
500      *
501      * - from cannot be the zero address.
502      * - to cannot be the zero address.
503      * - tokenId token must exist and be owned by from.
504      * - If the caller is not from, it must be approved to move this token by either {approve} or {setApprovalForAll}.
505      * - If to refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
506      *
507      * Emits a {Transfer} event.
508      */
509     function safeTransferFrom(
510         address from,
511         address to,
512         uint256 tokenId,
513         bytes calldata data
514     ) external;
515 }
516 
517 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol
518 
519 
520 // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)
521 
522 pragma solidity ^0.8.0;
523 
524 
525 /**
526  * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
527  * @dev See https://eips.ethereum.org/EIPS/eip-721
528  */
529 interface IERC721Enumerable is IERC721 {
530     /**
531      * @dev Returns the total amount of tokens stored by the contract.
532      */
533     function totalSupply() external view returns (uint256);
534 
535     /**
536      * @dev Returns a token ID owned by owner at a given index of its token list.
537      * Use along with {balanceOf} to enumerate all of owner's tokens.
538      */
539     function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
540 
541     /**
542      * @dev Returns a token ID at a given index of all the tokens stored by the contract.
543      * Use along with {totalSupply} to enumerate all tokens.
544      */
545     function tokenByIndex(uint256 index) external view returns (uint256);
546 }
547 
548 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
549 
550 
551 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
552 
553 pragma solidity ^0.8.0;
554 
555 
556 /**
557  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
558  * @dev See https://eips.ethereum.org/EIPS/eip-721
559  */
560 interface IERC721Metadata is IERC721 {
561     /**
562      * @dev Returns the token collection name.
563      */
564     function name() external view returns (string memory);
565 
566     /**
567      * @dev Returns the token collection symbol.
568      */
569     function symbol() external view returns (string memory);
570 
571     /**
572      * @dev Returns the Uniform Resource Identifier (URI) for tokenId token.
573      */
574     function tokenURI(uint256 tokenId) external view returns (string memory);
575 }
576 
577 // File: @openzeppelin/contracts/utils/Strings.sol
578 
579 
580 // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)
581 
582 pragma solidity ^0.8.0;
583 
584 /**
585  * @dev String operations.
586  */
587 library Strings {
588     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
589 
590     /**
591      * @dev Converts a uint256 to its ASCII string decimal representation.
592      */
593     function toString(uint256 value) internal pure returns (string memory) {
594         // Inspired by OraclizeAPI's implementation - MIT licence
595         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
596 
597         if (value == 0) {
598             return "0";
599         }
600         uint256 temp = value;
601         uint256 digits;
602         while (temp != 0) {
603             digits++;
604             temp /= 10;
605         }
606         bytes memory buffer = new bytes(digits);
607         while (value != 0) {
608             digits -= 1;
609             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
610             value /= 10;
611         }
612         return string(buffer);
613     }
614 
615     /**
616      * @dev Converts a uint256 to its ASCII string hexadecimal representation.
617      */
618     function toHexString(uint256 value) internal pure returns (string memory) {
619         if (value == 0) {
620             return "0x00";
621         }
622         uint256 temp = value;
623         uint256 length = 0;
624         while (temp != 0) {
625             length++;
626             temp >>= 8;
627         }
628         return toHexString(value, length);
629     }
630 
631     /**
632      * @dev Converts a uint256 to its ASCII string hexadecimal representation with fixed length.
633      */
634     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
635         bytes memory buffer = new bytes(2 * length + 2);
636         buffer[0] = "0";
637         buffer[1] = "x";
638         for (uint256 i = 2 * length + 1; i > 1; --i) {
639             buffer[i] = _HEX_SYMBOLS[value & 0xf];
640             value >>= 4;
641         }
642         require(value == 0, "Strings: hex length insufficient");
643         return string(buffer);
644     }
645 }
646 
647 // File: @openzeppelin/contracts/security/ReentrancyGuard.sol
648 
649 
650 // OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)
651 
652 pragma solidity ^0.8.0;
653 
654 /**
655  * @dev Contract module that helps prevent reentrant calls to a function.
656  *
657  * Inheriting from ReentrancyGuard will make the {nonReentrant} modifier
658  * available, which can be applied to functions to make sure there are no nested
659  * (reentrant) calls to them.
660  *
661  * Note that because there is a single nonReentrant guard, functions marked as
662  * nonReentrant may not call one another. This can be worked around by making
663  * those functions private, and then adding external nonReentrant entry
664  * points to them.
665  *
666  * TIP: If you would like to learn more about reentrancy and alternative ways
667  * to protect against it, check out our blog post
668  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
669  */
670 abstract contract ReentrancyGuard {
671     // Booleans are more expensive than uint256 or any type that takes up a full
672     // word because each write operation emits an extra SLOAD to first read the
673     // slot's contents, replace the bits taken up by the boolean, and then write
674     // back. This is the compiler's defense against contract upgrades and
675     // pointer aliasing, and it cannot be disabled.
676 
677     // The values being non-zero value makes deployment a bit more expensive,
678     // but in exchange the refund on every call to nonReentrant will be lower in
679     // amount. Since refunds are capped to a percentage of the total
680     // transaction's gas, it is best to keep them low in cases like this one, to
681     // increase the likelihood of the full refund coming into effect.
682     uint256 private constant _NOT_ENTERED = 1;
683     uint256 private constant _ENTERED = 2;
684 
685     uint256 private _status;
686 
687     constructor() {
688         _status = _NOT_ENTERED;
689     }
690 
691     /**
692      * @dev Prevents a contract from calling itself, directly or indirectly.
693      * Calling a nonReentrant function from another nonReentrant
694      * function is not supported. It is possible to prevent this from happening
695      * by making the nonReentrant function external, and making it call a
696      * private function that does the actual work.
697      */
698     modifier nonReentrant() {
699         // On the first call to nonReentrant, _notEntered will be true
700         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
701 
702         // Any calls to nonReentrant after this point will fail
703         _status = _ENTERED;
704 
705         _;
706 
707         // By storing the original value once again, a refund is triggered (see
708         // https://eips.ethereum.org/EIPS/eip-2200)
709         _status = _NOT_ENTERED;
710     }
711 }
712 
713 // File: @openzeppelin/contracts/utils/Context.sol
714 
715 
716 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
717 
718 pragma solidity ^0.8.0;
719 
720 /**
721  * @dev Provides information about the current execution context, including the
722  * sender of the transaction and its data. While these are generally available
723  * via msg.sender and msg.data, they should not be accessed in such a direct
724  * manner, since when dealing with meta-transactions the account sending and
725  * paying for execution may not be the actual sender (as far as an application
726  * is concerned).
727  *
728  * This contract is only required for intermediate, library-like contracts.
729  */
730 abstract contract Context {
731     function _msgSender() internal view virtual returns (address) {
732         return msg.sender;
733     }
734 
735     function _msgData() internal view virtual returns (bytes calldata) {
736         return msg.data;
737     }
738 }
739 
740 // File: @openzeppelin/contracts/access/Ownable.sol
741 
742 
743 // OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)
744 
745 pragma solidity ^0.8.0;
746 
747 
748 /**
749  * @dev Contract module which provides a basic access control mechanism, where
750  * there is an account (an owner) that can be granted exclusive access to
751  * specific functions.
752  *
753  * By default, the owner account will be the one that deploys the contract. This
754  * can later be changed with {transferOwnership}.
755  *
756  * This module is used through inheritance. It will make available the modifier
757  * onlyOwner, which can be applied to your functions to restrict their use to
758  * the owner.
759  */
760 abstract contract Ownable is Context {
761     address private _owner;
762 
763     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
764 
765     /**
766      * @dev Initializes the contract setting the deployer as the initial owner.
767      */
768     constructor() {
769         _transferOwnership(_msgSender());
770     }
771 
772     /**
773      * @dev Returns the address of the current owner.
774      */
775     function owner() public view virtual returns (address) {
776         return _owner;
777     }
778 
779     /**
780      * @dev Throws if called by any account other than the owner.
781      */
782     modifier onlyOwner() {
783         require(owner() == _msgSender(), "Ownable: caller is not the owner");
784         _;
785     }
786 
787     /**
788      * @dev Leaves the contract without owner. It will not be possible to call
789      * onlyOwner functions anymore. Can only be called by the current owner.
790      *
791      * NOTE: Renouncing ownership will leave the contract without an owner,
792      * thereby removing any functionality that is only available to the owner.
793      */
794     function renounceOwnership() public virtual onlyOwner {
795         _transferOwnership(address(0));
796     }
797 
798     /**
799      * @dev Transfers ownership of the contract to a new account (newOwner).
800      * Can only be called by the current owner.
801      */
802     function transferOwnership(address newOwner) public virtual onlyOwner {
803         require(newOwner != address(0), "Ownable: new owner is the zero address");
804         _transferOwnership(newOwner);
805     }
806 
807     /**
808      * @dev Transfers ownership of the contract to a new account (newOwner).
809      * Internal function without access restriction.
810      */
811     function _transferOwnership(address newOwner) internal virtual {
812         address oldOwner = _owner;
813         _owner = newOwner;
814         emit OwnershipTransferred(oldOwner, newOwner);
815     }
816 }
817 //-------------END DEPENDENCIES------------------------//
818 
819 
820   
821 // Rampp Contracts v2.1 (Teams.sol)
822 
823 pragma solidity ^0.8.0;
824 
825 /**
826 * Teams is a contract implementation to extend upon Ownable that allows multiple controllers
827 * of a single contract to modify specific mint settings but not have overall ownership of the contract.
828 * This will easily allow cross-collaboration via Mintplex.xyz.
829 **/
830 abstract contract Teams is Ownable{
831   mapping (address => bool) internal team;
832 
833   /**
834   * @dev Adds an address to the team. Allows them to execute protected functions
835   * @param _address the ETH address to add, cannot be 0x and cannot be in team already
836   **/
837   function addToTeam(address _address) public onlyOwner {
838     require(_address != address(0), "Invalid address");
839     require(!inTeam(_address), "This address is already in your team.");
840   
841     team[_address] = true;
842   }
843 
844   /**
845   * @dev Removes an address to the team.
846   * @param _address the ETH address to remove, cannot be 0x and must be in team
847   **/
848   function removeFromTeam(address _address) public onlyOwner {
849     require(_address != address(0), "Invalid address");
850     require(inTeam(_address), "This address is not in your team currently.");
851   
852     team[_address] = false;
853   }
854 
855   /**
856   * @dev Check if an address is valid and active in the team
857   * @param _address ETH address to check for truthiness
858   **/
859   function inTeam(address _address)
860     public
861     view
862     returns (bool)
863   {
864     require(_address != address(0), "Invalid address to check.");
865     return team[_address] == true;
866   }
867 
868   /**
869   * @dev Throws if called by any account other than the owner or team member.
870   */
871   modifier onlyTeamOrOwner() {
872     bool _isOwner = owner() == _msgSender();
873     bool _isTeam = inTeam(_msgSender());
874     require(_isOwner || _isTeam, "Team: caller is not the owner or in Team.");
875     _;
876   }
877 }
878 
879 
880   
881   
882 /**
883  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
884  * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.
885  *
886  * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
887  * 
888  * Assumes the number of issuable tokens (collection size) is capped and fits in a uint128.
889  *
890  * Does not support burning tokens to address(0).
891  */
892 contract ERC721A is
893   Context,
894   ERC165,
895   IERC721,
896   IERC721Metadata,
897   IERC721Enumerable,
898   Teams
899 {
900   using Address for address;
901   using Strings for uint256;
902 
903   struct TokenOwnership {
904     address addr;
905     uint64 startTimestamp;
906   }
907 
908   struct AddressData {
909     uint128 balance;
910     uint128 numberMinted;
911   }
912 
913   uint256 private currentIndex;
914 
915   uint256 public immutable collectionSize;
916   uint256 public maxBatchSize;
917 
918   // Token name
919   string private _name;
920 
921   // Token symbol
922   string private _symbol;
923 
924   // Mapping from token ID to ownership details
925   // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.
926   mapping(uint256 => TokenOwnership) private _ownerships;
927 
928   // Mapping owner address to address data
929   mapping(address => AddressData) private _addressData;
930 
931   // Mapping from token ID to approved address
932   mapping(uint256 => address) private _tokenApprovals;
933 
934   // Mapping from owner to operator approvals
935   mapping(address => mapping(address => bool)) private _operatorApprovals;
936 
937   /* @dev Mapping of restricted operator approvals set by contract Owner
938   * This serves as an optional addition to ERC-721 so
939   * that the contract owner can elect to prevent specific addresses/contracts
940   * from being marked as the approver for a token. The reason for this
941   * is that some projects may want to retain control of where their tokens can/can not be listed
942   * either due to ethics, loyalty, or wanting trades to only occur on their personal marketplace.
943   * By default, there are no restrictions. The contract owner must deliberatly block an address 
944   */
945   mapping(address => bool) public restrictedApprovalAddresses;
946 
947   /**
948    * @dev
949    * maxBatchSize refers to how much a minter can mint at a time.
950    * collectionSize_ refers to how many tokens are in the collection.
951    */
952   constructor(
953     string memory name_,
954     string memory symbol_,
955     uint256 maxBatchSize_,
956     uint256 collectionSize_
957   ) {
958     require(
959       collectionSize_ > 0,
960       "ERC721A: collection must have a nonzero supply"
961     );
962     require(maxBatchSize_ > 0, "ERC721A: max batch size must be nonzero");
963     _name = name_;
964     _symbol = symbol_;
965     maxBatchSize = maxBatchSize_;
966     collectionSize = collectionSize_;
967     currentIndex = _startTokenId();
968   }
969 
970   /**
971   * To change the starting tokenId, please override this function.
972   */
973   function _startTokenId() internal view virtual returns (uint256) {
974     return 1;
975   }
976 
977   /**
978    * @dev See {IERC721Enumerable-totalSupply}.
979    */
980   function totalSupply() public view override returns (uint256) {
981     return _totalMinted();
982   }
983 
984   function currentTokenId() public view returns (uint256) {
985     return _totalMinted();
986   }
987 
988   function getNextTokenId() public view returns (uint256) {
989       return _totalMinted() + 1;
990   }
991 
992   /**
993   * Returns the total amount of tokens minted in the contract.
994   */
995   function _totalMinted() internal view returns (uint256) {
996     unchecked {
997       return currentIndex - _startTokenId();
998     }
999   }
1000 
1001   /**
1002    * @dev See {IERC721Enumerable-tokenByIndex}.
1003    */
1004   function tokenByIndex(uint256 index) public view override returns (uint256) {
1005     require(index < totalSupply(), "ERC721A: global index out of bounds");
1006     return index;
1007   }
1008 
1009   /**
1010    * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
1011    * This read function is O(collectionSize). If calling from a separate contract, be sure to test gas first.
1012    * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.
1013    */
1014   function tokenOfOwnerByIndex(address owner, uint256 index)
1015     public
1016     view
1017     override
1018     returns (uint256)
1019   {
1020     require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
1021     uint256 numMintedSoFar = totalSupply();
1022     uint256 tokenIdsIdx = 0;
1023     address currOwnershipAddr = address(0);
1024     for (uint256 i = 0; i < numMintedSoFar; i++) {
1025       TokenOwnership memory ownership = _ownerships[i];
1026       if (ownership.addr != address(0)) {
1027         currOwnershipAddr = ownership.addr;
1028       }
1029       if (currOwnershipAddr == owner) {
1030         if (tokenIdsIdx == index) {
1031           return i;
1032         }
1033         tokenIdsIdx++;
1034       }
1035     }
1036     revert("ERC721A: unable to get token of owner by index");
1037   }
1038 
1039   /**
1040    * @dev See {IERC165-supportsInterface}.
1041    */
1042   function supportsInterface(bytes4 interfaceId)
1043     public
1044     view
1045     virtual
1046     override(ERC165, IERC165)
1047     returns (bool)
1048   {
1049     return
1050       interfaceId == type(IERC721).interfaceId ||
1051       interfaceId == type(IERC721Metadata).interfaceId ||
1052       interfaceId == type(IERC721Enumerable).interfaceId ||
1053       super.supportsInterface(interfaceId);
1054   }
1055 
1056   /**
1057    * @dev See {IERC721-balanceOf}.
1058    */
1059   function balanceOf(address owner) public view override returns (uint256) {
1060     require(owner != address(0), "ERC721A: balance query for the zero address");
1061     return uint256(_addressData[owner].balance);
1062   }
1063 
1064   function _numberMinted(address owner) internal view returns (uint256) {
1065     require(
1066       owner != address(0),
1067       "ERC721A: number minted query for the zero address"
1068     );
1069     return uint256(_addressData[owner].numberMinted);
1070   }
1071 
1072   function ownershipOf(uint256 tokenId)
1073     internal
1074     view
1075     returns (TokenOwnership memory)
1076   {
1077     uint256 curr = tokenId;
1078 
1079     unchecked {
1080         if (_startTokenId() <= curr && curr < currentIndex) {
1081             TokenOwnership memory ownership = _ownerships[curr];
1082             if (ownership.addr != address(0)) {
1083                 return ownership;
1084             }
1085 
1086             // Invariant:
1087             // There will always be an ownership that has an address and is not burned
1088             // before an ownership that does not have an address and is not burned.
1089             // Hence, curr will not underflow.
1090             while (true) {
1091                 curr--;
1092                 ownership = _ownerships[curr];
1093                 if (ownership.addr != address(0)) {
1094                     return ownership;
1095                 }
1096             }
1097         }
1098     }
1099 
1100     revert("ERC721A: unable to determine the owner of token");
1101   }
1102 
1103   /**
1104    * @dev See {IERC721-ownerOf}.
1105    */
1106   function ownerOf(uint256 tokenId) public view override returns (address) {
1107     return ownershipOf(tokenId).addr;
1108   }
1109 
1110   /**
1111    * @dev See {IERC721Metadata-name}.
1112    */
1113   function name() public view virtual override returns (string memory) {
1114     return _name;
1115   }
1116 
1117   /**
1118    * @dev See {IERC721Metadata-symbol}.
1119    */
1120   function symbol() public view virtual override returns (string memory) {
1121     return _symbol;
1122   }
1123 
1124   /**
1125    * @dev See {IERC721Metadata-tokenURI}.
1126    */
1127   function tokenURI(uint256 tokenId)
1128     public
1129     view
1130     virtual
1131     override
1132     returns (string memory)
1133   {
1134     string memory baseURI = _baseURI();
1135     string memory extension = _baseURIExtension();
1136     return
1137       bytes(baseURI).length > 0
1138         ? string(abi.encodePacked(baseURI, tokenId.toString(), extension))
1139         : "";
1140   }
1141 
1142   /**
1143    * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1144    * token will be the concatenation of the baseURI and the tokenId. Empty
1145    * by default, can be overriden in child contracts.
1146    */
1147   function _baseURI() internal view virtual returns (string memory) {
1148     return "";
1149   }
1150 
1151   /**
1152    * @dev Base URI extension used for computing {tokenURI}. If set, the resulting URI for each
1153    * token will be the concatenation of the baseURI, tokenId, and this value. Empty
1154    * by default, can be overriden in child contracts.
1155    */
1156   function _baseURIExtension() internal view virtual returns (string memory) {
1157     return "";
1158   }
1159 
1160   /**
1161    * @dev Sets the value for an address to be in the restricted approval address pool.
1162    * Setting an address to true will disable token owners from being able to mark the address
1163    * for approval for trading. This would be used in theory to prevent token owners from listing
1164    * on specific marketplaces or protcols. Only modifible by the contract owner/team.
1165    * @param _address the marketplace/user to modify restriction status of
1166    * @param _isRestricted restriction status of the _address to be set. true => Restricted, false => Open
1167    */
1168   function setApprovalRestriction(address _address, bool _isRestricted) public onlyTeamOrOwner {
1169     restrictedApprovalAddresses[_address] = _isRestricted;
1170   }
1171 
1172   /**
1173    * @dev See {IERC721-approve}.
1174    */
1175   function approve(address to, uint256 tokenId) public override {
1176     address owner = ERC721A.ownerOf(tokenId);
1177     require(to != owner, "ERC721A: approval to current owner");
1178     require(restrictedApprovalAddresses[to] == false, "ERC721RestrictedApproval: Address to approve has been restricted by contract owner and is not allowed to be marked for approval");
1179 
1180     require(
1181       _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1182       "ERC721A: approve caller is not owner nor approved for all"
1183     );
1184 
1185     _approve(to, tokenId, owner);
1186   }
1187 
1188   /**
1189    * @dev See {IERC721-getApproved}.
1190    */
1191   function getApproved(uint256 tokenId) public view override returns (address) {
1192     require(_exists(tokenId), "ERC721A: approved query for nonexistent token");
1193 
1194     return _tokenApprovals[tokenId];
1195   }
1196 
1197   /**
1198    * @dev See {IERC721-setApprovalForAll}.
1199    */
1200   function setApprovalForAll(address operator, bool approved) public override {
1201     require(operator != _msgSender(), "ERC721A: approve to caller");
1202     require(restrictedApprovalAddresses[operator] == false, "ERC721RestrictedApproval: Operator address has been restricted by contract owner and is not allowed to be marked for approval");
1203 
1204     _operatorApprovals[_msgSender()][operator] = approved;
1205     emit ApprovalForAll(_msgSender(), operator, approved);
1206   }
1207 
1208   /**
1209    * @dev See {IERC721-isApprovedForAll}.
1210    */
1211   function isApprovedForAll(address owner, address operator)
1212     public
1213     view
1214     virtual
1215     override
1216     returns (bool)
1217   {
1218     return _operatorApprovals[owner][operator];
1219   }
1220 
1221   /**
1222    * @dev See {IERC721-transferFrom}.
1223    */
1224   function transferFrom(
1225     address from,
1226     address to,
1227     uint256 tokenId
1228   ) public override {
1229     _transfer(from, to, tokenId);
1230   }
1231 
1232   /**
1233    * @dev See {IERC721-safeTransferFrom}.
1234    */
1235   function safeTransferFrom(
1236     address from,
1237     address to,
1238     uint256 tokenId
1239   ) public override {
1240     safeTransferFrom(from, to, tokenId, "");
1241   }
1242 
1243   /**
1244    * @dev See {IERC721-safeTransferFrom}.
1245    */
1246   function safeTransferFrom(
1247     address from,
1248     address to,
1249     uint256 tokenId,
1250     bytes memory _data
1251   ) public override {
1252     _transfer(from, to, tokenId);
1253     require(
1254       _checkOnERC721Received(from, to, tokenId, _data),
1255       "ERC721A: transfer to non ERC721Receiver implementer"
1256     );
1257   }
1258 
1259   /**
1260    * @dev Returns whether tokenId exists.
1261    *
1262    * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1263    *
1264    * Tokens start existing when they are minted (_mint),
1265    */
1266   function _exists(uint256 tokenId) internal view returns (bool) {
1267     return _startTokenId() <= tokenId && tokenId < currentIndex;
1268   }
1269 
1270   function _safeMint(address to, uint256 quantity, bool isAdminMint) internal {
1271     _safeMint(to, quantity, isAdminMint, "");
1272   }
1273 
1274   /**
1275    * @dev Mints quantity tokens and transfers them to to.
1276    *
1277    * Requirements:
1278    *
1279    * - there must be quantity tokens remaining unminted in the total collection.
1280    * - to cannot be the zero address.
1281    * - quantity cannot be larger than the max batch size.
1282    *
1283    * Emits a {Transfer} event.
1284    */
1285   function _safeMint(
1286     address to,
1287     uint256 quantity,
1288     bool isAdminMint,
1289     bytes memory _data
1290   ) internal {
1291     uint256 startTokenId = currentIndex;
1292     require(to != address(0), "ERC721A: mint to the zero address");
1293     // We know if the first token in the batch doesn't exist, the other ones don't as well, because of serial ordering.
1294     require(!_exists(startTokenId), "ERC721A: token already minted");
1295 
1296     // For admin mints we do not want to enforce the maxBatchSize limit
1297     if (isAdminMint == false) {
1298         require(quantity <= maxBatchSize, "ERC721A: quantity to mint too high");
1299     }
1300 
1301     _beforeTokenTransfers(address(0), to, startTokenId, quantity);
1302 
1303     AddressData memory addressData = _addressData[to];
1304     _addressData[to] = AddressData(
1305       addressData.balance + uint128(quantity),
1306       addressData.numberMinted + (isAdminMint ? 0 : uint128(quantity))
1307     );
1308     _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));
1309 
1310     uint256 updatedIndex = startTokenId;
1311 
1312     for (uint256 i = 0; i < quantity; i++) {
1313       emit Transfer(address(0), to, updatedIndex);
1314       require(
1315         _checkOnERC721Received(address(0), to, updatedIndex, _data),
1316         "ERC721A: transfer to non ERC721Receiver implementer"
1317       );
1318       updatedIndex++;
1319     }
1320 
1321     currentIndex = updatedIndex;
1322     _afterTokenTransfers(address(0), to, startTokenId, quantity);
1323   }
1324 
1325   /**
1326    * @dev Transfers tokenId from from to to.
1327    *
1328    * Requirements:
1329    *
1330    * - to cannot be the zero address.
1331    * - tokenId token must be owned by from.
1332    *
1333    * Emits a {Transfer} event.
1334    */
1335   function _transfer(
1336     address from,
1337     address to,
1338     uint256 tokenId
1339   ) private {
1340     TokenOwnership memory prevOwnership = ownershipOf(tokenId);
1341 
1342     bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||
1343       getApproved(tokenId) == _msgSender() ||
1344       isApprovedForAll(prevOwnership.addr, _msgSender()));
1345 
1346     require(
1347       isApprovedOrOwner,
1348       "ERC721A: transfer caller is not owner nor approved"
1349     );
1350 
1351     require(
1352       prevOwnership.addr == from,
1353       "ERC721A: transfer from incorrect owner"
1354     );
1355     require(to != address(0), "ERC721A: transfer to the zero address");
1356 
1357     _beforeTokenTransfers(from, to, tokenId, 1);
1358 
1359     // Clear approvals from the previous owner
1360     _approve(address(0), tokenId, prevOwnership.addr);
1361 
1362     _addressData[from].balance -= 1;
1363     _addressData[to].balance += 1;
1364     _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));
1365 
1366     // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
1367     // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
1368     uint256 nextTokenId = tokenId + 1;
1369     if (_ownerships[nextTokenId].addr == address(0)) {
1370       if (_exists(nextTokenId)) {
1371         _ownerships[nextTokenId] = TokenOwnership(
1372           prevOwnership.addr,
1373           prevOwnership.startTimestamp
1374         );
1375       }
1376     }
1377 
1378     emit Transfer(from, to, tokenId);
1379     _afterTokenTransfers(from, to, tokenId, 1);
1380   }
1381 
1382   /**
1383    * @dev Approve to to operate on tokenId
1384    *
1385    * Emits a {Approval} event.
1386    */
1387   function _approve(
1388     address to,
1389     uint256 tokenId,
1390     address owner
1391   ) private {
1392     _tokenApprovals[tokenId] = to;
1393     emit Approval(owner, to, tokenId);
1394   }
1395 
1396   uint256 public nextOwnerToExplicitlySet = 0;
1397 
1398   /**
1399    * @dev Explicitly set owners to eliminate loops in future calls of ownerOf().
1400    */
1401   function _setOwnersExplicit(uint256 quantity) internal {
1402     uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;
1403     require(quantity > 0, "quantity must be nonzero");
1404     if (currentIndex == _startTokenId()) revert('No Tokens Minted Yet');
1405 
1406     uint256 endIndex = oldNextOwnerToSet + quantity - 1;
1407     if (endIndex > collectionSize - 1) {
1408       endIndex = collectionSize - 1;
1409     }
1410     // We know if the last one in the group exists, all in the group exist, due to serial ordering.
1411     require(_exists(endIndex), "not enough minted yet for this cleanup");
1412     for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {
1413       if (_ownerships[i].addr == address(0)) {
1414         TokenOwnership memory ownership = ownershipOf(i);
1415         _ownerships[i] = TokenOwnership(
1416           ownership.addr,
1417           ownership.startTimestamp
1418         );
1419       }
1420     }
1421     nextOwnerToExplicitlySet = endIndex + 1;
1422   }
1423 
1424   /**
1425    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1426    * The call is not executed if the target address is not a contract.
1427    *
1428    * @param from address representing the previous owner of the given token ID
1429    * @param to target address that will receive the tokens
1430    * @param tokenId uint256 ID of the token to be transferred
1431    * @param _data bytes optional data to send along with the call
1432    * @return bool whether the call correctly returned the expected magic value
1433    */
1434   function _checkOnERC721Received(
1435     address from,
1436     address to,
1437     uint256 tokenId,
1438     bytes memory _data
1439   ) private returns (bool) {
1440     if (to.isContract()) {
1441       try
1442         IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)
1443       returns (bytes4 retval) {
1444         return retval == IERC721Receiver(to).onERC721Received.selector;
1445       } catch (bytes memory reason) {
1446         if (reason.length == 0) {
1447           revert("ERC721A: transfer to non ERC721Receiver implementer");
1448         } else {
1449           assembly {
1450             revert(add(32, reason), mload(reason))
1451           }
1452         }
1453       }
1454     } else {
1455       return true;
1456     }
1457   }
1458 
1459   /**
1460    * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.
1461    *
1462    * startTokenId - the first token id to be transferred
1463    * quantity - the amount to be transferred
1464    *
1465    * Calling conditions:
1466    *
1467    * - When from and to are both non-zero, from's tokenId will be
1468    * transferred to to.
1469    * - When from is zero, tokenId will be minted for to.
1470    */
1471   function _beforeTokenTransfers(
1472     address from,
1473     address to,
1474     uint256 startTokenId,
1475     uint256 quantity
1476   ) internal virtual {}
1477 
1478   /**
1479    * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes
1480    * minting.
1481    *
1482    * startTokenId - the first token id to be transferred
1483    * quantity - the amount to be transferred
1484    *
1485    * Calling conditions:
1486    *
1487    * - when from and to are both non-zero.
1488    * - from and to are never both zero.
1489    */
1490   function _afterTokenTransfers(
1491     address from,
1492     address to,
1493     uint256 startTokenId,
1494     uint256 quantity
1495   ) internal virtual {}
1496 }
1497 
1498 // @title An implementation of ERC-721A with additonal context for 1:1 redemption with another ERC-721
1499 // @author Mintplex.xyz (Rampp Labs Inc) (Twitter: @MintplexNFT)
1500 // @notice -- See Medium article --
1501 // @custom:experimental This is an experimental contract interface. Mintplex assumes no responsibility for functionality or security.
1502 abstract contract ERC721ARedemption is ERC721A {
1503   // @dev Emitted when someone exchanges an NFT for this contracts NFT via token redemption swap
1504   event Redeemed(address indexed from, uint256 indexed tokenId, address indexed contractAddress);
1505 
1506   // @dev Emitted when someone proves ownership of an NFT for this contracts NFT via token redemption swap
1507   event VerifiedClaim(address indexed from, uint256 indexed tokenId, address indexed contractAddress);
1508   
1509   uint256 public redemptionSurcharge = 0 ether;
1510   bool public redemptionModeEnabled;
1511   bool public verifiedClaimModeEnabled;
1512   address public redemptionAddress = 0x000000000000000000000000000000000000dEaD; // address burned tokens are sent, default is dEaD.
1513   mapping(address => bool) public redemptionContracts;
1514   mapping(address => mapping(uint256 => bool)) public tokenRedemptions;
1515 
1516   // @dev Allow owner/team to set the contract as eligable for redemption for this contract
1517   function setRedeemableContract(address _contractAddress, bool _status) public onlyTeamOrOwner {
1518     redemptionContracts[_contractAddress] = _status;
1519   }
1520 
1521   // @dev Allow owner/team to determine if contract is accepting redemption mints
1522   function setRedemptionMode(bool _newStatus) public onlyTeamOrOwner {
1523     redemptionModeEnabled = _newStatus;
1524   }
1525 
1526   // @dev Allow owner/team to determine if contract is accepting verified claim mints
1527   function setVerifiedClaimMode(bool _newStatus) public onlyTeamOrOwner {
1528     verifiedClaimModeEnabled = _newStatus;
1529   }
1530 
1531   // @dev Set the fee that it would cost a minter to be able to burn/validtion mint a token on this contract. 
1532   function setRedemptionSurcharge(uint256 _newSurchargeInWei) public onlyTeamOrOwner {
1533     redemptionSurcharge = _newSurchargeInWei;
1534   }
1535 
1536   // @dev Set the redemption address where redeemed NFTs will be transferred when "burned". 
1537   // @notice Must be a wallet address or implement IERC721Receiver.
1538   // Cannot be null address as this will break any ERC-721A implementation without a proper
1539   // burn mechanic as ownershipOf cannot handle 0x00 holdings mid batch.
1540   function setRedemptionAddress(address _newRedemptionAddress) public onlyTeamOrOwner {
1541     require(_newRedemptionAddress != address(0), "New redemption address cannot be null address.");
1542     redemptionAddress = _newRedemptionAddress;
1543   }
1544 
1545   /**
1546   * @dev allows redemption or "burning" of a single tokenID. Must be owned by the owner
1547   * @notice this does not impact the total supply of the burned token and the transfer destination address may be set by
1548   * the contract owner or Team => redemptionAddress. 
1549   * @param tokenId the token to be redeemed.
1550   * Emits a {Redeemed} event.
1551   **/
1552   function redeem(address redemptionContract, uint256 tokenId) public payable {
1553     require(getNextTokenId() <= collectionSize, "Cannot mint over supply cap of 5000");
1554     require(redemptionModeEnabled, "ERC721 Redeemable: Redemption mode is not enabled currently");
1555     require(redemptionContract != address(0), "ERC721 Redeemable: Redemption contract cannot be null.");
1556     require(redemptionContracts[redemptionContract], "ERC721 Redeemable: Redemption contract is not eligable for redeeming.");
1557     require(msg.value == redemptionSurcharge, "ERC721 Redeemable: Redemption fee not sent by redeemer.");
1558     require(tokenRedemptions[redemptionContract][tokenId] == false, "ERC721 Redeemable: Token has already been redeemed.");
1559     
1560     IERC721 _targetContract = IERC721(redemptionContract);
1561     require(_targetContract.ownerOf(tokenId) == _msgSender(), "ERC721 Redeemable: Redeemer not owner of token to be claimed against.");
1562     require(_targetContract.getApproved(tokenId) == address(this), "ERC721 Redeemable: This contract is not approved for specific token on redempetion contract.");
1563     
1564     // Warning: Since there is no standarized return value for transfers of ERC-721
1565     // It is possible this function silently fails and a mint still occurs. The owner of the contract is
1566     // responsible for ensuring that the redemption contract does not lock or have staked controls preventing
1567     // movement of the token. As an added measure we keep a mapping of tokens redeemed to prevent multiple single-token redemptions, 
1568     // but the NFT may not have been sent to the redemptionAddress.
1569     _targetContract.safeTransferFrom(_msgSender(), redemptionAddress, tokenId);
1570     tokenRedemptions[redemptionContract][tokenId] = true;
1571 
1572     emit Redeemed(_msgSender(), tokenId, redemptionContract);
1573     _safeMint(_msgSender(), 1, false);
1574   }
1575 
1576   /**
1577   * @dev allows for verified claim mint against a single tokenID. Must be owned by the owner
1578   * @notice this mint action allows the original NFT to remain in the holders wallet, but its claim is logged.
1579   * @param tokenId the token to be redeemed.
1580   * Emits a {VerifiedClaim} event.
1581   **/
1582   function verifedClaim(address redemptionContract, uint256 tokenId) public payable {
1583     require(getNextTokenId() <= collectionSize, "Cannot mint over supply cap of 5000");
1584     require(verifiedClaimModeEnabled, "ERC721 Redeemable: Verified claim mode is not enabled currently");
1585     require(redemptionContract != address(0), "ERC721 Redeemable: Redemption contract cannot be null.");
1586     require(redemptionContracts[redemptionContract], "ERC721 Redeemable: Redemption contract is not eligable for redeeming.");
1587     require(msg.value == redemptionSurcharge, "ERC721 Redeemable: Redemption fee not sent by redeemer.");
1588     require(tokenRedemptions[redemptionContract][tokenId] == false, "ERC721 Redeemable: Token has already been redeemed.");
1589     
1590     tokenRedemptions[redemptionContract][tokenId] = true;
1591     emit VerifiedClaim(_msgSender(), tokenId, redemptionContract);
1592     _safeMint(_msgSender(), 1, false);
1593   }
1594 }
1595 
1596 
1597   
1598 abstract contract Ramppable {
1599   address public RAMPPADDRESS = 0xa9dAC8f3aEDC55D0FE707B86B8A45d246858d2E1;
1600 
1601   modifier isRampp() {
1602       require(msg.sender == RAMPPADDRESS, "Ownable: caller is not RAMPP");
1603       _;
1604   }
1605 }
1606 
1607 
1608   
1609   
1610 interface IERC20 {
1611   function allowance(address owner, address spender) external view returns (uint256);
1612   function transfer(address _to, uint256 _amount) external returns (bool);
1613   function balanceOf(address account) external view returns (uint256);
1614   function transferFrom(address from, address to, uint256 amount) external returns (bool);
1615 }
1616 
1617 // File: WithdrawableV2
1618 // This abstract allows the contract to be able to mint and ingest ERC-20 payments for mints.
1619 // ERC-20 Payouts are limited to a single payout address. This feature 
1620 // will charge a small flat fee in native currency that is not subject to regular rev sharing.
1621 // This contract also covers the normal functionality of accepting native base currency rev-sharing
1622 abstract contract WithdrawableV2 is Teams, Ramppable {
1623   struct acceptedERC20 {
1624     bool isActive;
1625     uint256 chargeAmount;
1626   }
1627 
1628   
1629   mapping(address => acceptedERC20) private allowedTokenContracts;
1630   address[] public payableAddresses = [0x5cCa867939aA9CBbd8757339659bfDbf3948091B,0x41788BCd2cc518b5cd0e75dd0254791d10b7C65F,0xDCD67FBf5FEcd832ffbb3951860e8ce3EA265eB3];
1631   address public erc20Payable = 0x41788BCd2cc518b5cd0e75dd0254791d10b7C65F;
1632   uint256[] public payableFees = [2,91,7];
1633   uint256 public payableAddressCount = 3;
1634   bool public onlyERC20MintingMode = false;
1635   
1636 
1637   /**
1638   * @dev Calculates the true payable balance of the contract
1639   */
1640   function calcAvailableBalance() public view returns(uint256) {
1641     return address(this).balance;
1642   }
1643 
1644   function withdrawAll() public onlyTeamOrOwner {
1645       require(calcAvailableBalance() > 0);
1646       _withdrawAll();
1647   }
1648   
1649   function withdrawAllRampp() public isRampp {
1650       require(calcAvailableBalance() > 0);
1651       _withdrawAll();
1652   }
1653 
1654   function _withdrawAll() private {
1655       uint256 balance = calcAvailableBalance();
1656       
1657       for(uint i=0; i < payableAddressCount; i++ ) {
1658           _widthdraw(
1659               payableAddresses[i],
1660               (balance * payableFees[i]) / 100
1661           );
1662       }
1663   }
1664   
1665   function _widthdraw(address _address, uint256 _amount) private {
1666       (bool success, ) = _address.call{value: _amount}("");
1667       require(success, "Transfer failed.");
1668   }
1669 
1670   /**
1671   * @dev Allow contract owner to withdraw ERC-20 balance from contract
1672   * in the event ERC-20 tokens are paid to the contract for mints.
1673   * @param _tokenContract contract of ERC-20 token to withdraw
1674   * @param _amountToWithdraw balance to withdraw according to balanceOf of ERC-20 token in wei
1675   */
1676   function withdrawERC20(address _tokenContract, uint256 _amountToWithdraw) public onlyTeamOrOwner {
1677     require(_amountToWithdraw > 0);
1678     IERC20 tokenContract = IERC20(_tokenContract);
1679     require(tokenContract.balanceOf(address(this)) >= _amountToWithdraw, "WithdrawV2: Contract does not own enough tokens");
1680     tokenContract.transfer(erc20Payable, _amountToWithdraw); // Payout ERC-20 tokens to recipient
1681   }
1682 
1683   /**
1684   * @dev check if an ERC-20 contract is a valid payable contract for executing a mint.
1685   * @param _erc20TokenContract address of ERC-20 contract in question
1686   */
1687   function isApprovedForERC20Payments(address _erc20TokenContract) public view returns(bool) {
1688     return allowedTokenContracts[_erc20TokenContract].isActive == true;
1689   }
1690 
1691   /**
1692   * @dev get the value of tokens to transfer for user of an ERC-20
1693   * @param _erc20TokenContract address of ERC-20 contract in question
1694   */
1695   function chargeAmountForERC20(address _erc20TokenContract) public view returns(uint256) {
1696     require(isApprovedForERC20Payments(_erc20TokenContract), "This ERC-20 contract is not approved to make payments on this contract!");
1697     return allowedTokenContracts[_erc20TokenContract].chargeAmount;
1698   }
1699 
1700   /**
1701   * @dev Explicity sets and ERC-20 contract as an allowed payment method for minting
1702   * @param _erc20TokenContract address of ERC-20 contract in question
1703   * @param _isActive default status of if contract should be allowed to accept payments
1704   * @param _chargeAmountInTokens fee (in tokens) to charge for mints for this specific ERC-20 token
1705   */
1706   function addOrUpdateERC20ContractAsPayment(address _erc20TokenContract, bool _isActive, uint256 _chargeAmountInTokens) public onlyTeamOrOwner {
1707     allowedTokenContracts[_erc20TokenContract].isActive = _isActive;
1708     allowedTokenContracts[_erc20TokenContract].chargeAmount = _chargeAmountInTokens;
1709   }
1710 
1711   /**
1712   * @dev Add an ERC-20 contract as being a valid payment method. If passed a contract which has not been added
1713   * it will assume the default value of zero. This should not be used to create new payment tokens.
1714   * @param _erc20TokenContract address of ERC-20 contract in question
1715   */
1716   function enableERC20ContractAsPayment(address _erc20TokenContract) public onlyTeamOrOwner {
1717     allowedTokenContracts[_erc20TokenContract].isActive = true;
1718   }
1719 
1720   /**
1721   * @dev Disable an ERC-20 contract as being a valid payment method. If passed a contract which has not been added
1722   * it will assume the default value of zero. This should not be used to create new payment tokens.
1723   * @param _erc20TokenContract address of ERC-20 contract in question
1724   */
1725   function disableERC20ContractAsPayment(address _erc20TokenContract) public onlyTeamOrOwner {
1726     allowedTokenContracts[_erc20TokenContract].isActive = false;
1727   }
1728 
1729   /**
1730   * @dev Enable only ERC-20 payments for minting on this contract
1731   */
1732   function enableERC20OnlyMinting() public onlyTeamOrOwner {
1733     onlyERC20MintingMode = true;
1734   }
1735 
1736   /**
1737   * @dev Disable only ERC-20 payments for minting on this contract
1738   */
1739   function disableERC20OnlyMinting() public onlyTeamOrOwner {
1740     onlyERC20MintingMode = false;
1741   }
1742 
1743   /**
1744   * @dev Set the payout of the ERC-20 token payout to a specific address
1745   * @param _newErc20Payable new payout addresses of ERC-20 tokens
1746   */
1747   function setERC20PayableAddress(address _newErc20Payable) public onlyTeamOrOwner {
1748     require(_newErc20Payable != address(0), "WithdrawableV2: new ERC-20 payout cannot be the zero address");
1749     require(_newErc20Payable != erc20Payable, "WithdrawableV2: new ERC-20 payout is same as current payout");
1750     erc20Payable = _newErc20Payable;
1751   }
1752 
1753   /**
1754   * @dev Allows Rampp wallet to update its own reference.
1755   * @param _newAddress updated Rampp Address
1756   */
1757   function setRamppAddress(address _newAddress) public isRampp {
1758     require(_newAddress != RAMPPADDRESS, "WithdrawableV2: New Rampp address must be different");
1759     RAMPPADDRESS = _newAddress;
1760   }
1761 }
1762 
1763 
1764   
1765   
1766   
1767   
1768 abstract contract RamppERC721A is 
1769     Ownable,
1770     Teams,
1771     ERC721ARedemption,
1772     WithdrawableV2,
1773     ReentrancyGuard 
1774      
1775      
1776     
1777 {
1778   constructor(
1779     string memory tokenName,
1780     string memory tokenSymbol
1781   ) ERC721A(tokenName, tokenSymbol, 1, 505) { }
1782     uint8 public CONTRACT_VERSION = 2;
1783     string public _baseTokenURI = "ipfs://bafybeibyusi3fvmrml4xr3rglouzbufbmmruhufbd4b5y5nipqfcn7yw3u/";
1784     string public _baseTokenExtension = "";
1785 
1786     bool public mintingOpen = false;
1787     bool public isRevealed = false;
1788     
1789     uint256 public MAX_WALLET_MINTS = 1;
1790 
1791   
1792     /////////////// Admin Mint Functions
1793     /**
1794      * @dev Mints a token to an address with a tokenURI.
1795      * This is owner only and allows a fee-free drop
1796      * @param _to address of the future owner of the token
1797      * @param _qty amount of tokens to drop the owner
1798      */
1799      function mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{
1800          require(_qty > 0, "Must mint at least 1 token.");
1801          require(currentTokenId() + _qty <= collectionSize, "Cannot mint over supply cap of 505");
1802          _safeMint(_to, _qty, true);
1803      }
1804 
1805   
1806     /////////////// PUBLIC MINT FUNCTIONS
1807     /**
1808     * @dev Mints tokens to an address in batch.
1809     * fee may or may not be required*
1810     * @param _to address of the future owner of the token
1811     * @param _amount number of tokens to mint
1812     */
1813     function mintToMultiple(address _to, uint256 _amount) public payable {
1814         require(onlyERC20MintingMode == false, "Only minting with ERC-20 tokens is enabled.");
1815         require(_amount >= 1, "Must mint at least 1 token");
1816         require(_amount <= maxBatchSize, "Cannot mint more than max mint per transaction");
1817         require(mintingOpen == true, "Minting is not open right now!");
1818         
1819         require(canMintAmount(_to, _amount), "Wallet address is over the maximum allowed mints");
1820         require(currentTokenId() + _amount <= collectionSize, "Cannot mint over supply cap of 505");
1821         
1822 
1823         _safeMint(_to, _amount, false);
1824     }
1825 
1826     /**
1827      * @dev Mints tokens to an address in batch using an ERC-20 token for payment
1828      * fee may or may not be required*
1829      * @param _to address of the future owner of the token
1830      * @param _amount number of tokens to mint
1831      * @param _erc20TokenContract erc-20 token contract to mint with
1832      */
1833     function mintToMultipleERC20(address _to, uint256 _amount, address _erc20TokenContract) public payable {
1834       require(_amount >= 1, "Must mint at least 1 token");
1835       require(_amount <= maxBatchSize, "Cannot mint more than max mint per transaction");
1836       require(getNextTokenId() <= collectionSize, "Cannot mint over supply cap of 505");
1837       require(mintingOpen == true, "Minting is not open right now!");
1838       
1839       require(canMintAmount(_to, 1), "Wallet address is over the maximum allowed mints");
1840 
1841       // ERC-20 Specific pre-flight checks
1842       require(isApprovedForERC20Payments(_erc20TokenContract), "ERC-20 Token is not approved for minting!");
1843       uint256 tokensQtyToTransfer = chargeAmountForERC20(_erc20TokenContract) * _amount;
1844       IERC20 payableToken = IERC20(_erc20TokenContract);
1845 
1846       require(payableToken.balanceOf(_to) >= tokensQtyToTransfer, "Buyer does not own enough of token to complete purchase");
1847       require(payableToken.allowance(_to, address(this)) >= tokensQtyToTransfer, "Buyer did not approve enough of ERC-20 token to complete purchase");
1848 
1849       bool transferComplete = payableToken.transferFrom(_to, address(this), tokensQtyToTransfer);
1850       require(transferComplete, "ERC-20 token was unable to be transferred");
1851       
1852       _safeMint(_to, _amount, false);
1853     }
1854 
1855     function openMinting() public onlyTeamOrOwner {
1856         mintingOpen = true;
1857     }
1858 
1859     function stopMinting() public onlyTeamOrOwner {
1860         mintingOpen = false;
1861     }
1862 
1863   
1864 
1865   
1866     /**
1867     * @dev Check if wallet over MAX_WALLET_MINTS
1868     * @param _address address in question to check if minted count exceeds max
1869     */
1870     function canMintAmount(address _address, uint256 _amount) public view returns(bool) {
1871         require(_amount >= 1, "Amount must be greater than or equal to 1");
1872         return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;
1873     }
1874 
1875     /**
1876     * @dev Update the maximum amount of tokens that can be minted by a unique wallet
1877     * @param _newWalletMax the new max of tokens a wallet can mint. Must be >= 1
1878     */
1879     function setWalletMax(uint256 _newWalletMax) public onlyTeamOrOwner {
1880         require(_newWalletMax >= 1, "Max mints per wallet must be at least 1");
1881         MAX_WALLET_MINTS = _newWalletMax;
1882     }
1883     
1884 
1885   
1886     /**
1887      * @dev Allows owner to set Max mints per tx
1888      * @param _newMaxMint maximum amount of tokens allowed to mint per tx. Must be >= 1
1889      */
1890      function setMaxMint(uint256 _newMaxMint) public onlyTeamOrOwner {
1891          require(_newMaxMint >= 1, "Max mint must be at least 1");
1892          maxBatchSize = _newMaxMint;
1893      }
1894     
1895 
1896   
1897     function unveil(string memory _updatedTokenURI) public onlyTeamOrOwner {
1898         require(isRevealed == false, "Tokens are already unveiled");
1899         _baseTokenURI = _updatedTokenURI;
1900         isRevealed = true;
1901     }
1902     
1903 
1904   function _baseURI() internal view virtual override returns(string memory) {
1905     return _baseTokenURI;
1906   }
1907 
1908   function _baseURIExtension() internal view virtual override returns(string memory) {
1909     return _baseTokenExtension;
1910   }
1911 
1912   function baseTokenURI() public view returns(string memory) {
1913     return _baseTokenURI;
1914   }
1915 
1916   function setBaseURI(string calldata baseURI) external onlyTeamOrOwner {
1917     _baseTokenURI = baseURI;
1918   }
1919 
1920   function setBaseTokenExtension(string calldata baseExtension) external onlyTeamOrOwner {
1921     _baseTokenExtension = baseExtension;
1922   }
1923 
1924   function getOwnershipData(uint256 tokenId) external view returns(TokenOwnership memory) {
1925     return ownershipOf(tokenId);
1926   }
1927 }
1928 
1929 
1930   
1931 // File: contracts/BblockCorpArmyContract.sol
1932 //SPDX-License-Identifier: MIT
1933 
1934 pragma solidity ^0.8.0;
1935 
1936 contract BblockCorpArmyContract is RamppERC721A {
1937     constructor() RamppERC721A("bblockCorp Army", "BLCK"){}
1938 }
1939   
1940 //*********************************************************************//
1941 //*********************************************************************//  
1942 //                       Mintplex v3.0.0
1943 //
1944 //         This smart contract was generated by mintplex.xyz.
1945 //            Mintplex allows creators like you to launch 
1946 //             large scale NFT communities without code!
1947 //
1948 //    Mintplex is not responsible for the content of this contract and
1949 //        hopes it is being used in a responsible and kind way.  
1950 //       Mintplex is not associated or affiliated with this project.                                                    
1951 //             Twitter: @MintplexNFT ---- mintplex.xyz
1952 //*********************************************************************//                                                     
1953 //*********************************************************************// 
