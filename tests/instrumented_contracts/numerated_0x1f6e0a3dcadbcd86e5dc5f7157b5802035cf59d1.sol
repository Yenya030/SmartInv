1 pragma solidity ^0.5.2;
2 
3 // File: @daostack/infra/contracts/votingMachines/IntVoteInterface.sol
4 
5 interface IntVoteInterface {
6     //When implementing this interface please do not only override function and modifier,
7     //but also to keep the modifiers on the overridden functions.
8     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
9     modifier votable(bytes32 _proposalId) {revert(); _;}
10 
11     event NewProposal(
12         bytes32 indexed _proposalId,
13         address indexed _organization,
14         uint256 _numOfChoices,
15         address _proposer,
16         bytes32 _paramsHash
17     );
18 
19     event ExecuteProposal(bytes32 indexed _proposalId,
20         address indexed _organization,
21         uint256 _decision,
22         uint256 _totalReputation
23     );
24 
25     event VoteProposal(
26         bytes32 indexed _proposalId,
27         address indexed _organization,
28         address indexed _voter,
29         uint256 _vote,
30         uint256 _reputation
31     );
32 
33     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
34     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
35 
36     /**
37      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
38      * generated by calculating keccak256 of a incremented counter.
39      * @param _numOfChoices number of voting choices
40      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
41      * @param _proposer address
42      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
43      * @return proposal's id.
44      */
45     function propose(
46         uint256 _numOfChoices,
47         bytes32 _proposalParameters,
48         address _proposer,
49         address _organization
50         ) external returns(bytes32);
51 
52     function vote(
53         bytes32 _proposalId,
54         uint256 _vote,
55         uint256 _rep,
56         address _voter
57     )
58     external
59     returns(bool);
60 
61     function cancelVote(bytes32 _proposalId) external;
62 
63     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
64 
65     function isVotable(bytes32 _proposalId) external view returns(bool);
66 
67     /**
68      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
69      * @param _proposalId the ID of the proposal
70      * @param _choice the index in the
71      * @return voted reputation for the given choice
72      */
73     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
74 
75     /**
76      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
77      * @return bool true or false
78      */
79     function isAbstainAllow() external pure returns(bool);
80 
81     /**
82      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
83      * @return min - minimum number of choices
84                max - maximum number of choices
85      */
86     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
87 }
88 
89 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
90 
91 /**
92  * @title ERC20 interface
93  * @dev see https://github.com/ethereum/EIPs/issues/20
94  */
95 interface IERC20 {
96     function transfer(address to, uint256 value) external returns (bool);
97 
98     function approve(address spender, uint256 value) external returns (bool);
99 
100     function transferFrom(address from, address to, uint256 value) external returns (bool);
101 
102     function totalSupply() external view returns (uint256);
103 
104     function balanceOf(address who) external view returns (uint256);
105 
106     function allowance(address owner, address spender) external view returns (uint256);
107 
108     event Transfer(address indexed from, address indexed to, uint256 value);
109 
110     event Approval(address indexed owner, address indexed spender, uint256 value);
111 }
112 
113 // File: @daostack/infra/contracts/votingMachines/VotingMachineCallbacksInterface.sol
114 
115 interface VotingMachineCallbacksInterface {
116     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
117     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
118 
119     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
120     external
121     returns(bool);
122 
123     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
124     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
125     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
126 }
127 
128 // File: openzeppelin-solidity/contracts/ownership/Ownable.sol
129 
130 /**
131  * @title Ownable
132  * @dev The Ownable contract has an owner address, and provides basic authorization control
133  * functions, this simplifies the implementation of "user permissions".
134  */
135 contract Ownable {
136     address private _owner;
137 
138     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
139 
140     /**
141      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
142      * account.
143      */
144     constructor () internal {
145         _owner = msg.sender;
146         emit OwnershipTransferred(address(0), _owner);
147     }
148 
149     /**
150      * @return the address of the owner.
151      */
152     function owner() public view returns (address) {
153         return _owner;
154     }
155 
156     /**
157      * @dev Throws if called by any account other than the owner.
158      */
159     modifier onlyOwner() {
160         require(isOwner());
161         _;
162     }
163 
164     /**
165      * @return true if `msg.sender` is the owner of the contract.
166      */
167     function isOwner() public view returns (bool) {
168         return msg.sender == _owner;
169     }
170 
171     /**
172      * @dev Allows the current owner to relinquish control of the contract.
173      * @notice Renouncing to ownership will leave the contract without an owner.
174      * It will not be possible to call the functions with the `onlyOwner`
175      * modifier anymore.
176      */
177     function renounceOwnership() public onlyOwner {
178         emit OwnershipTransferred(_owner, address(0));
179         _owner = address(0);
180     }
181 
182     /**
183      * @dev Allows the current owner to transfer control of the contract to a newOwner.
184      * @param newOwner The address to transfer ownership to.
185      */
186     function transferOwnership(address newOwner) public onlyOwner {
187         _transferOwnership(newOwner);
188     }
189 
190     /**
191      * @dev Transfers control of the contract to a newOwner.
192      * @param newOwner The address to transfer ownership to.
193      */
194     function _transferOwnership(address newOwner) internal {
195         require(newOwner != address(0));
196         emit OwnershipTransferred(_owner, newOwner);
197         _owner = newOwner;
198     }
199 }
200 
201 // File: @daostack/infra/contracts/Reputation.sol
202 
203 /**
204  * @title Reputation system
205  * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .
206  * A reputation is use to assign influence measure to a DAO'S peers.
207  * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.
208  * The Reputation contract maintain a map of address to reputation value.
209  * It provides an onlyOwner functions to mint and burn reputation _to (or _from) a specific address.
210  */
211 
212 contract Reputation is Ownable {
213 
214     uint8 public decimals = 18;             //Number of decimals of the smallest unit
215     // Event indicating minting of reputation to an address.
216     event Mint(address indexed _to, uint256 _amount);
217     // Event indicating burning of reputation for an address.
218     event Burn(address indexed _from, uint256 _amount);
219 
220       /// @dev `Checkpoint` is the structure that attaches a block number to a
221       ///  given value, the block number attached is the one that last changed the
222       ///  value
223     struct Checkpoint {
224 
225     // `fromBlock` is the block number that the value was generated from
226         uint128 fromBlock;
227 
228           // `value` is the amount of reputation at a specific block number
229         uint128 value;
230     }
231 
232       // `balances` is the map that tracks the balance of each address, in this
233       //  contract when the balance changes the block number that the change
234       //  occurred is also included in the map
235     mapping (address => Checkpoint[]) balances;
236 
237       // Tracks the history of the `totalSupply` of the reputation
238     Checkpoint[] totalSupplyHistory;
239 
240     /// @notice Constructor to create a Reputation
241     constructor(
242     ) public
243     {
244     }
245 
246     /// @dev This function makes it easy to get the total number of reputation
247     /// @return The total number of reputation
248     function totalSupply() public view returns (uint256) {
249         return totalSupplyAt(block.number);
250     }
251 
252   ////////////////
253   // Query balance and totalSupply in History
254   ////////////////
255     /**
256     * @dev return the reputation amount of a given owner
257     * @param _owner an address of the owner which we want to get his reputation
258     */
259     function balanceOf(address _owner) public view returns (uint256 balance) {
260         return balanceOfAt(_owner, block.number);
261     }
262 
263       /// @dev Queries the balance of `_owner` at a specific `_blockNumber`
264       /// @param _owner The address from which the balance will be retrieved
265       /// @param _blockNumber The block number when the balance is queried
266       /// @return The balance at `_blockNumber`
267     function balanceOfAt(address _owner, uint256 _blockNumber)
268     public view returns (uint256)
269     {
270         if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {
271             return 0;
272           // This will return the expected balance during normal situations
273         } else {
274             return getValueAt(balances[_owner], _blockNumber);
275         }
276     }
277 
278       /// @notice Total amount of reputation at a specific `_blockNumber`.
279       /// @param _blockNumber The block number when the totalSupply is queried
280       /// @return The total amount of reputation at `_blockNumber`
281     function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {
282         if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {
283             return 0;
284           // This will return the expected totalSupply during normal situations
285         } else {
286             return getValueAt(totalSupplyHistory, _blockNumber);
287         }
288     }
289 
290       /// @notice Generates `_amount` reputation that are assigned to `_owner`
291       /// @param _user The address that will be assigned the new reputation
292       /// @param _amount The quantity of reputation generated
293       /// @return True if the reputation are generated correctly
294     function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {
295         uint256 curTotalSupply = totalSupply();
296         require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow
297         uint256 previousBalanceTo = balanceOf(_user);
298         require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow
299         updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);
300         updateValueAtNow(balances[_user], previousBalanceTo + _amount);
301         emit Mint(_user, _amount);
302         return true;
303     }
304 
305       /// @notice Burns `_amount` reputation from `_owner`
306       /// @param _user The address that will lose the reputation
307       /// @param _amount The quantity of reputation to burn
308       /// @return True if the reputation are burned correctly
309     function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {
310         uint256 curTotalSupply = totalSupply();
311         uint256 amountBurned = _amount;
312         uint256 previousBalanceFrom = balanceOf(_user);
313         if (previousBalanceFrom < amountBurned) {
314             amountBurned = previousBalanceFrom;
315         }
316         updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);
317         updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);
318         emit Burn(_user, amountBurned);
319         return true;
320     }
321 
322   ////////////////
323   // Internal helper functions to query and set a value in a snapshot array
324   ////////////////
325 
326       /// @dev `getValueAt` retrieves the number of reputation at a given block number
327       /// @param checkpoints The history of values being queried
328       /// @param _block The block number to retrieve the value at
329       /// @return The number of reputation being queried
330     function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {
331         if (checkpoints.length == 0) {
332             return 0;
333         }
334 
335           // Shortcut for the actual value
336         if (_block >= checkpoints[checkpoints.length-1].fromBlock) {
337             return checkpoints[checkpoints.length-1].value;
338         }
339         if (_block < checkpoints[0].fromBlock) {
340             return 0;
341         }
342 
343           // Binary search of the value in the array
344         uint256 min = 0;
345         uint256 max = checkpoints.length-1;
346         while (max > min) {
347             uint256 mid = (max + min + 1) / 2;
348             if (checkpoints[mid].fromBlock<=_block) {
349                 min = mid;
350             } else {
351                 max = mid-1;
352             }
353         }
354         return checkpoints[min].value;
355     }
356 
357       /// @dev `updateValueAtNow` used to update the `balances` map and the
358       ///  `totalSupplyHistory`
359       /// @param checkpoints The history of data being updated
360       /// @param _value The new number of reputation
361     function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {
362         require(uint128(_value) == _value); //check value is in the 128 bits bounderies
363         if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {
364             Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];
365             newCheckPoint.fromBlock = uint128(block.number);
366             newCheckPoint.value = uint128(_value);
367         } else {
368             Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];
369             oldCheckPoint.value = uint128(_value);
370         }
371     }
372 }
373 
374 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
375 
376 
377 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol
378 
379 /**
380  * @title SafeMath
381  * @dev Unsigned math operations with safety checks that revert on error
382  */
383 library SafeMath {
384     /**
385     * @dev Multiplies two unsigned integers, reverts on overflow.
386     */
387     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
388         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
389         // benefit is lost if 'b' is also tested.
390         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
391         if (a == 0) {
392             return 0;
393         }
394 
395         uint256 c = a * b;
396         require(c / a == b);
397 
398         return c;
399     }
400 
401     /**
402     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
403     */
404     function div(uint256 a, uint256 b) internal pure returns (uint256) {
405         // Solidity only automatically asserts when dividing by 0
406         require(b > 0);
407         uint256 c = a / b;
408         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
409 
410         return c;
411     }
412 
413     /**
414     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
415     */
416     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
417         require(b <= a);
418         uint256 c = a - b;
419 
420         return c;
421     }
422 
423     /**
424     * @dev Adds two unsigned integers, reverts on overflow.
425     */
426     function add(uint256 a, uint256 b) internal pure returns (uint256) {
427         uint256 c = a + b;
428         require(c >= a);
429 
430         return c;
431     }
432 
433     /**
434     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
435     * reverts when dividing by zero.
436     */
437     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
438         require(b != 0);
439         return a % b;
440     }
441 }
442 
443 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol
444 
445 /**
446  * @title Standard ERC20 token
447  *
448  * @dev Implementation of the basic standard token.
449  * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
450  * Originally based on code by FirstBlood:
451  * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
452  *
453  * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for
454  * all accounts just by listening to said events. Note that this isn't required by the specification, and other
455  * compliant implementations may not do it.
456  */
457 contract ERC20 is IERC20 {
458     using SafeMath for uint256;
459 
460     mapping (address => uint256) private _balances;
461 
462     mapping (address => mapping (address => uint256)) private _allowed;
463 
464     uint256 private _totalSupply;
465 
466     /**
467     * @dev Total number of tokens in existence
468     */
469     function totalSupply() public view returns (uint256) {
470         return _totalSupply;
471     }
472 
473     /**
474     * @dev Gets the balance of the specified address.
475     * @param owner The address to query the balance of.
476     * @return An uint256 representing the amount owned by the passed address.
477     */
478     function balanceOf(address owner) public view returns (uint256) {
479         return _balances[owner];
480     }
481 
482     /**
483      * @dev Function to check the amount of tokens that an owner allowed to a spender.
484      * @param owner address The address which owns the funds.
485      * @param spender address The address which will spend the funds.
486      * @return A uint256 specifying the amount of tokens still available for the spender.
487      */
488     function allowance(address owner, address spender) public view returns (uint256) {
489         return _allowed[owner][spender];
490     }
491 
492     /**
493     * @dev Transfer token for a specified address
494     * @param to The address to transfer to.
495     * @param value The amount to be transferred.
496     */
497     function transfer(address to, uint256 value) public returns (bool) {
498         _transfer(msg.sender, to, value);
499         return true;
500     }
501 
502     /**
503      * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
504      * Beware that changing an allowance with this method brings the risk that someone may use both the old
505      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
506      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
507      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
508      * @param spender The address which will spend the funds.
509      * @param value The amount of tokens to be spent.
510      */
511     function approve(address spender, uint256 value) public returns (bool) {
512         require(spender != address(0));
513 
514         _allowed[msg.sender][spender] = value;
515         emit Approval(msg.sender, spender, value);
516         return true;
517     }
518 
519     /**
520      * @dev Transfer tokens from one address to another.
521      * Note that while this function emits an Approval event, this is not required as per the specification,
522      * and other compliant implementations may not emit the event.
523      * @param from address The address which you want to send tokens from
524      * @param to address The address which you want to transfer to
525      * @param value uint256 the amount of tokens to be transferred
526      */
527     function transferFrom(address from, address to, uint256 value) public returns (bool) {
528         _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
529         _transfer(from, to, value);
530         emit Approval(from, msg.sender, _allowed[from][msg.sender]);
531         return true;
532     }
533 
534     /**
535      * @dev Increase the amount of tokens that an owner allowed to a spender.
536      * approve should be called when allowed_[_spender] == 0. To increment
537      * allowed value is better to use this function to avoid 2 calls (and wait until
538      * the first transaction is mined)
539      * From MonolithDAO Token.sol
540      * Emits an Approval event.
541      * @param spender The address which will spend the funds.
542      * @param addedValue The amount of tokens to increase the allowance by.
543      */
544     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
545         require(spender != address(0));
546 
547         _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
548         emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
549         return true;
550     }
551 
552     /**
553      * @dev Decrease the amount of tokens that an owner allowed to a spender.
554      * approve should be called when allowed_[_spender] == 0. To decrement
555      * allowed value is better to use this function to avoid 2 calls (and wait until
556      * the first transaction is mined)
557      * From MonolithDAO Token.sol
558      * Emits an Approval event.
559      * @param spender The address which will spend the funds.
560      * @param subtractedValue The amount of tokens to decrease the allowance by.
561      */
562     function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
563         require(spender != address(0));
564 
565         _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
566         emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
567         return true;
568     }
569 
570     /**
571     * @dev Transfer token for a specified addresses
572     * @param from The address to transfer from.
573     * @param to The address to transfer to.
574     * @param value The amount to be transferred.
575     */
576     function _transfer(address from, address to, uint256 value) internal {
577         require(to != address(0));
578 
579         _balances[from] = _balances[from].sub(value);
580         _balances[to] = _balances[to].add(value);
581         emit Transfer(from, to, value);
582     }
583 
584     /**
585      * @dev Internal function that mints an amount of the token and assigns it to
586      * an account. This encapsulates the modification of balances such that the
587      * proper events are emitted.
588      * @param account The account that will receive the created tokens.
589      * @param value The amount that will be created.
590      */
591     function _mint(address account, uint256 value) internal {
592         require(account != address(0));
593 
594         _totalSupply = _totalSupply.add(value);
595         _balances[account] = _balances[account].add(value);
596         emit Transfer(address(0), account, value);
597     }
598 
599     /**
600      * @dev Internal function that burns an amount of the token of a given
601      * account.
602      * @param account The account whose tokens will be burnt.
603      * @param value The amount that will be burnt.
604      */
605     function _burn(address account, uint256 value) internal {
606         require(account != address(0));
607 
608         _totalSupply = _totalSupply.sub(value);
609         _balances[account] = _balances[account].sub(value);
610         emit Transfer(account, address(0), value);
611     }
612 
613     /**
614      * @dev Internal function that burns an amount of the token of a given
615      * account, deducting from the sender's allowance for said account. Uses the
616      * internal burn function.
617      * Emits an Approval event (reflecting the reduced allowance).
618      * @param account The account whose tokens will be burnt.
619      * @param value The amount that will be burnt.
620      */
621     function _burnFrom(address account, uint256 value) internal {
622         _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
623         _burn(account, value);
624         emit Approval(account, msg.sender, _allowed[account][msg.sender]);
625     }
626 }
627 
628 // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol
629 
630 /**
631  * @title Burnable Token
632  * @dev Token that can be irreversibly burned (destroyed).
633  */
634 contract ERC20Burnable is ERC20 {
635     /**
636      * @dev Burns a specific amount of tokens.
637      * @param value The amount of token to be burned.
638      */
639     function burn(uint256 value) public {
640         _burn(msg.sender, value);
641     }
642 
643     /**
644      * @dev Burns a specific amount of tokens from the target address and decrements allowance
645      * @param from address The address which you want to send tokens from
646      * @param value uint256 The amount of token to be burned
647      */
648     function burnFrom(address from, uint256 value) public {
649         _burnFrom(from, value);
650     }
651 }
652 
653 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/DAOToken.sol
654 
655 /**
656  * @title DAOToken, base on zeppelin contract.
657  * @dev ERC20 compatible token. It is a mintable, burnable token.
658  */
659 
660 contract DAOToken is ERC20, ERC20Burnable, Ownable {
661 
662     string public name;
663     string public symbol;
664     // solhint-disable-next-line const-name-snakecase
665     uint8 public constant decimals = 18;
666     uint256 public cap;
667 
668     /**
669     * @dev Constructor
670     * @param _name - token name
671     * @param _symbol - token symbol
672     * @param _cap - token cap - 0 value means no cap
673     */
674     constructor(string memory _name, string memory _symbol, uint256 _cap)
675     public {
676         name = _name;
677         symbol = _symbol;
678         cap = _cap;
679     }
680 
681     /**
682      * @dev Function to mint tokens
683      * @param _to The address that will receive the minted tokens.
684      * @param _amount The amount of tokens to mint.
685      */
686     function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {
687         if (cap > 0)
688             require(totalSupply().add(_amount) <= cap);
689         _mint(_to, _amount);
690         return true;
691     }
692 }
693 
694 // File: openzeppelin-solidity/contracts/utils/Address.sol
695 
696 /**
697  * Utility library of inline functions on addresses
698  */
699 library Address {
700     /**
701      * Returns whether the target address is a contract
702      * @dev This function will return false if invoked during the constructor of a contract,
703      * as the code is not actually created until after the constructor finishes.
704      * @param account address of the account to check
705      * @return whether the target address is a contract
706      */
707     function isContract(address account) internal view returns (bool) {
708         uint256 size;
709         // XXX Currently there is no better way to check if there is a contract in an address
710         // than to check the size of the code at that address.
711         // See https://ethereum.stackexchange.com/a/14016/36603
712         // for more details about how this works.
713         // TODO Check this again before the Serenity release, because all addresses will be
714         // contracts then.
715         // solhint-disable-next-line no-inline-assembly
716         assembly { size := extcodesize(account) }
717         return size > 0;
718     }
719 }
720 
721 // File: /Users/oren/daostack/daostack2/daostack/contracts/libs/SafeERC20.sol
722 
723 /*
724 
725 SafeERC20 by daostack.
726 The code is based on a fix by SECBIT Team.
727 
728 USE WITH CAUTION & NO WARRANTY
729 
730 REFERENCE & RELATED READING
731 - https://github.com/ethereum/solidity/issues/4116
732 - https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c
733 - https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
734 - https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61
735 
736 */
737 pragma solidity ^0.5.2;
738 
739 
740 
741 library SafeERC20 {
742     using Address for address;
743 
744     bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));
745     bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));
746     bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes("approve(address,uint256)")));
747 
748     function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {
749 
750         // Must be a contract addr first!
751         require(_erc20Addr.isContract());
752 
753         (bool success, bytes memory returnValue) =
754         // solhint-disable-next-line avoid-low-level-calls
755         _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));
756         // call return false when something wrong
757         require(success);
758         //check return value
759         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
760     }
761 
762     function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {
763 
764         // Must be a contract addr first!
765         require(_erc20Addr.isContract());
766 
767         (bool success, bytes memory returnValue) =
768         // solhint-disable-next-line avoid-low-level-calls
769         _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));
770         // call return false when something wrong
771         require(success);
772         //check return value
773         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
774     }
775 
776     function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {
777 
778         // Must be a contract addr first!
779         require(_erc20Addr.isContract());
780 
781         // safeApprove should only be called when setting an initial allowance,
782         // or when resetting it to zero.
783         require((_value == 0) || (IERC20(_erc20Addr).allowance(msg.sender, _spender) == 0));
784 
785         (bool success, bytes memory returnValue) =
786         // solhint-disable-next-line avoid-low-level-calls
787         _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));
788         // call return false when something wrong
789         require(success);
790         //check return value
791         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
792     }
793 }
794 
795 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/Avatar.sol
796 
797 /**
798  * @title An Avatar holds tokens, reputation and ether for a controller
799  */
800 contract Avatar is Ownable {
801     using SafeERC20 for address;
802 
803     string public orgName;
804     DAOToken public nativeToken;
805     Reputation public nativeReputation;
806 
807     event GenericCall(address indexed _contract, bytes _params, bool _success);
808     event SendEther(uint256 _amountInWei, address indexed _to);
809     event ExternalTokenTransfer(address indexed _externalToken, address indexed _to, uint256 _value);
810     event ExternalTokenTransferFrom(address indexed _externalToken, address _from, address _to, uint256 _value);
811     event ExternalTokenApproval(address indexed _externalToken, address _spender, uint256 _value);
812     event ReceiveEther(address indexed _sender, uint256 _value);
813 
814     /**
815     * @dev the constructor takes organization name, native token and reputation system
816     and creates an avatar for a controller
817     */
818     constructor(string memory _orgName, DAOToken _nativeToken, Reputation _nativeReputation) public {
819         orgName = _orgName;
820         nativeToken = _nativeToken;
821         nativeReputation = _nativeReputation;
822     }
823 
824     /**
825     * @dev enables an avatar to receive ethers
826     */
827     function() external payable {
828         emit ReceiveEther(msg.sender, msg.value);
829     }
830 
831     /**
832     * @dev perform a generic call to an arbitrary contract
833     * @param _contract  the contract's address to call
834     * @param _data ABI-encoded contract call to call `_contract` address.
835     * @return bool    success or fail
836     *         bytes - the return bytes of the called contract's function.
837     */
838     function genericCall(address _contract, bytes memory _data)
839     public
840     onlyOwner
841     returns(bool success, bytes memory returnValue) {
842       // solhint-disable-next-line avoid-low-level-calls
843         (success, returnValue) = _contract.call(_data);
844         emit GenericCall(_contract, _data, success);
845     }
846 
847     /**
848     * @dev send ethers from the avatar's wallet
849     * @param _amountInWei amount to send in Wei units
850     * @param _to send the ethers to this address
851     * @return bool which represents success
852     */
853     function sendEther(uint256 _amountInWei, address payable _to) public onlyOwner returns(bool) {
854         _to.transfer(_amountInWei);
855         emit SendEther(_amountInWei, _to);
856         return true;
857     }
858 
859     /**
860     * @dev external token transfer
861     * @param _externalToken the token contract
862     * @param _to the destination address
863     * @param _value the amount of tokens to transfer
864     * @return bool which represents success
865     */
866     function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value)
867     public onlyOwner returns(bool)
868     {
869         address(_externalToken).safeTransfer(_to, _value);
870         emit ExternalTokenTransfer(address(_externalToken), _to, _value);
871         return true;
872     }
873 
874     /**
875     * @dev external token transfer from a specific account
876     * @param _externalToken the token contract
877     * @param _from the account to spend token from
878     * @param _to the destination address
879     * @param _value the amount of tokens to transfer
880     * @return bool which represents success
881     */
882     function externalTokenTransferFrom(
883         IERC20 _externalToken,
884         address _from,
885         address _to,
886         uint256 _value
887     )
888     public onlyOwner returns(bool)
889     {
890         address(_externalToken).safeTransferFrom(_from, _to, _value);
891         emit ExternalTokenTransferFrom(address(_externalToken), _from, _to, _value);
892         return true;
893     }
894 
895     /**
896     * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens
897     *      on behalf of msg.sender.
898     * @param _externalToken the address of the Token Contract
899     * @param _spender address
900     * @param _value the amount of ether (in Wei) which the approval is referring to.
901     * @return bool which represents a success
902     */
903     function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value)
904     public onlyOwner returns(bool)
905     {
906         address(_externalToken).safeApprove(_spender, _value);
907         emit ExternalTokenApproval(address(_externalToken), _spender, _value);
908         return true;
909     }
910 
911 }
912 
913 // File: /Users/oren/daostack/daostack2/daostack/contracts/universalSchemes/UniversalSchemeInterface.sol
914 
915 contract UniversalSchemeInterface {
916 
917     function updateParameters(bytes32 _hashedParameters) public;
918 
919     function getParametersFromController(Avatar _avatar) internal view returns(bytes32);
920 }
921 
922 // File: /Users/oren/daostack/daostack2/daostack/contracts/globalConstraints/GlobalConstraintInterface.sol
923 
924 contract GlobalConstraintInterface {
925 
926     enum CallPhase { Pre, Post, PreAndPost }
927 
928     function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
929     function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
930     /**
931      * @dev when return if this globalConstraints is pre, post or both.
932      * @return CallPhase enum indication  Pre, Post or PreAndPost.
933      */
934     function when() public returns(CallPhase);
935 }
936 
937 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/ControllerInterface.sol
938 
939 /**
940  * @title Controller contract
941  * @dev A controller controls the organizations tokens ,reputation and avatar.
942  * It is subject to a set of schemes and constraints that determine its behavior.
943  * Each scheme has it own parameters and operation permissions.
944  */
945 interface ControllerInterface {
946 
947     /**
948      * @dev Mint `_amount` of reputation that are assigned to `_to` .
949      * @param  _amount amount of reputation to mint
950      * @param _to beneficiary address
951      * @return bool which represents a success
952     */
953     function mintReputation(uint256 _amount, address _to, address _avatar)
954     external
955     returns(bool);
956 
957     /**
958      * @dev Burns `_amount` of reputation from `_from`
959      * @param _amount amount of reputation to burn
960      * @param _from The address that will lose the reputation
961      * @return bool which represents a success
962      */
963     function burnReputation(uint256 _amount, address _from, address _avatar)
964     external
965     returns(bool);
966 
967     /**
968      * @dev mint tokens .
969      * @param  _amount amount of token to mint
970      * @param _beneficiary beneficiary address
971      * @param _avatar address
972      * @return bool which represents a success
973      */
974     function mintTokens(uint256 _amount, address _beneficiary, address _avatar)
975     external
976     returns(bool);
977 
978   /**
979    * @dev register or update a scheme
980    * @param _scheme the address of the scheme
981    * @param _paramsHash a hashed configuration of the usage of the scheme
982    * @param _permissions the permissions the new scheme will have
983    * @param _avatar address
984    * @return bool which represents a success
985    */
986     function registerScheme(address _scheme, bytes32 _paramsHash, bytes4 _permissions, address _avatar)
987     external
988     returns(bool);
989 
990     /**
991      * @dev unregister a scheme
992      * @param _avatar address
993      * @param _scheme the address of the scheme
994      * @return bool which represents a success
995      */
996     function unregisterScheme(address _scheme, address _avatar)
997     external
998     returns(bool);
999 
1000     /**
1001      * @dev unregister the caller's scheme
1002      * @param _avatar address
1003      * @return bool which represents a success
1004      */
1005     function unregisterSelf(address _avatar) external returns(bool);
1006 
1007     /**
1008      * @dev add or update Global Constraint
1009      * @param _globalConstraint the address of the global constraint to be added.
1010      * @param _params the constraint parameters hash.
1011      * @param _avatar the avatar of the organization
1012      * @return bool which represents a success
1013      */
1014     function addGlobalConstraint(address _globalConstraint, bytes32 _params, address _avatar)
1015     external returns(bool);
1016 
1017     /**
1018      * @dev remove Global Constraint
1019      * @param _globalConstraint the address of the global constraint to be remove.
1020      * @param _avatar the organization avatar.
1021      * @return bool which represents a success
1022      */
1023     function removeGlobalConstraint (address _globalConstraint, address _avatar)
1024     external  returns(bool);
1025 
1026   /**
1027     * @dev upgrade the Controller
1028     *      The function will trigger an event 'UpgradeController'.
1029     * @param  _newController the address of the new controller.
1030     * @param _avatar address
1031     * @return bool which represents a success
1032     */
1033     function upgradeController(address _newController, Avatar _avatar)
1034     external returns(bool);
1035 
1036     /**
1037     * @dev perform a generic call to an arbitrary contract
1038     * @param _contract  the contract's address to call
1039     * @param _data ABI-encoded contract call to call `_contract` address.
1040     * @param _avatar the controller's avatar address
1041     * @return bool -success
1042     *         bytes  - the return value of the called _contract's function.
1043     */
1044     function genericCall(address _contract, bytes calldata _data, Avatar _avatar)
1045     external
1046     returns(bool, bytes memory);
1047 
1048   /**
1049    * @dev send some ether
1050    * @param _amountInWei the amount of ether (in Wei) to send
1051    * @param _to address of the beneficiary
1052    * @param _avatar address
1053    * @return bool which represents a success
1054    */
1055     function sendEther(uint256 _amountInWei, address payable _to, Avatar _avatar)
1056     external returns(bool);
1057 
1058     /**
1059     * @dev send some amount of arbitrary ERC20 Tokens
1060     * @param _externalToken the address of the Token Contract
1061     * @param _to address of the beneficiary
1062     * @param _value the amount of ether (in Wei) to send
1063     * @param _avatar address
1064     * @return bool which represents a success
1065     */
1066     function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value, Avatar _avatar)
1067     external
1068     returns(bool);
1069 
1070     /**
1071     * @dev transfer token "from" address "to" address
1072     *      One must to approve the amount of tokens which can be spend from the
1073     *      "from" account.This can be done using externalTokenApprove.
1074     * @param _externalToken the address of the Token Contract
1075     * @param _from address of the account to send from
1076     * @param _to address of the beneficiary
1077     * @param _value the amount of ether (in Wei) to send
1078     * @param _avatar address
1079     * @return bool which represents a success
1080     */
1081     function externalTokenTransferFrom(
1082     IERC20 _externalToken,
1083     address _from,
1084     address _to,
1085     uint256 _value,
1086     Avatar _avatar)
1087     external
1088     returns(bool);
1089 
1090     /**
1091     * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens
1092     *      on behalf of msg.sender.
1093     * @param _externalToken the address of the Token Contract
1094     * @param _spender address
1095     * @param _value the amount of ether (in Wei) which the approval is referring to.
1096     * @return bool which represents a success
1097     */
1098     function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value, Avatar _avatar)
1099     external
1100     returns(bool);
1101 
1102     /**
1103      * @dev getNativeReputation
1104      * @param _avatar the organization avatar.
1105      * @return organization native reputation
1106      */
1107     function getNativeReputation(address _avatar)
1108     external
1109     view
1110     returns(address);
1111 
1112     function isSchemeRegistered( address _scheme, address _avatar) external view returns(bool);
1113 
1114     function getSchemeParameters(address _scheme, address _avatar) external view returns(bytes32);
1115 
1116     function getGlobalConstraintParameters(address _globalConstraint, address _avatar) external view returns(bytes32);
1117 
1118     function getSchemePermissions(address _scheme, address _avatar) external view returns(bytes4);
1119 
1120     /**
1121      * @dev globalConstraintsCount return the global constraint pre and post count
1122      * @return uint256 globalConstraintsPre count.
1123      * @return uint256 globalConstraintsPost count.
1124      */
1125     function globalConstraintsCount(address _avatar) external view returns(uint, uint);
1126 
1127     function isGlobalConstraintRegistered(address _globalConstraint, address _avatar) external view returns(bool);
1128 }
1129 
1130 // File: /Users/oren/daostack/daostack2/daostack/contracts/universalSchemes/UniversalScheme.sol
1131 
1132 contract UniversalScheme is Ownable, UniversalSchemeInterface {
1133     bytes32 public hashedParameters; // For other parameters.
1134 
1135     function updateParameters(
1136         bytes32 _hashedParameters
1137     )
1138         public
1139         onlyOwner
1140     {
1141         hashedParameters = _hashedParameters;
1142     }
1143 
1144     /**
1145     *  @dev get the parameters for the current scheme from the controller
1146     */
1147     function getParametersFromController(Avatar _avatar) internal view returns(bytes32) {
1148         require(ControllerInterface(_avatar.owner()).isSchemeRegistered(address(this), address(_avatar)),
1149         "scheme is not registered");
1150         return ControllerInterface(_avatar.owner()).getSchemeParameters(address(this), address(_avatar));
1151     }
1152 }
1153 
1154 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
1155 
1156 /**
1157  * @title Elliptic curve signature operations
1158  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
1159  * TODO Remove this library once solidity supports passing a signature to ecrecover.
1160  * See https://github.com/ethereum/solidity/issues/864
1161  */
1162 
1163 library ECDSA {
1164     /**
1165      * @dev Recover signer address from a message by using their signature
1166      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
1167      * @param signature bytes signature, the signature is generated using web3.eth.sign()
1168      */
1169     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
1170         bytes32 r;
1171         bytes32 s;
1172         uint8 v;
1173 
1174         // Check the signature length
1175         if (signature.length != 65) {
1176             return (address(0));
1177         }
1178 
1179         // Divide the signature in r, s and v variables
1180         // ecrecover takes the signature parameters, and the only way to get them
1181         // currently is to use assembly.
1182         // solhint-disable-next-line no-inline-assembly
1183         assembly {
1184             r := mload(add(signature, 0x20))
1185             s := mload(add(signature, 0x40))
1186             v := byte(0, mload(add(signature, 0x60)))
1187         }
1188 
1189         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
1190         if (v < 27) {
1191             v += 27;
1192         }
1193 
1194         // If the version is correct return the signer address
1195         if (v != 27 && v != 28) {
1196             return (address(0));
1197         } else {
1198             return ecrecover(hash, v, r, s);
1199         }
1200     }
1201 
1202     /**
1203      * toEthSignedMessageHash
1204      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
1205      * and hash the result
1206      */
1207     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
1208         // 32 is the length in bytes of hash,
1209         // enforced by the type signature above
1210         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
1211     }
1212 }
1213 
1214 
1215 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/libs/RealMath.sol
1216 
1217 /**
1218  * RealMath: fixed-point math library, based on fractional and integer parts.
1219  * Using uint256 as real216x40, which isn't in Solidity yet.
1220  * 40 fractional bits gets us down to 1E-12 precision, while still letting us
1221  * go up to galaxy scale counting in meters.
1222  * Internally uses the wider uint256 for some math.
1223  *
1224  * Note that for addition, subtraction, and mod (%), you should just use the
1225  * built-in Solidity operators. Functions for these operations are not provided.
1226  *
1227  */
1228 
1229 
1230 library RealMath {
1231 
1232     /**
1233      * How many total bits are there?
1234      */
1235     uint256 constant private REAL_BITS = 256;
1236 
1237     /**
1238      * How many fractional bits are there?
1239      */
1240     uint256 constant private REAL_FBITS = 40;
1241 
1242     /**
1243      * What's the first non-fractional bit
1244      */
1245     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
1246 
1247     /**
1248      * Raise a real number to any positive integer power
1249      */
1250     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
1251 
1252         uint256 tempRealBase = realBase;
1253         uint256 tempExponent = exponent;
1254 
1255         // Start with the 0th power
1256         uint256 realResult = REAL_ONE;
1257         while (tempExponent != 0) {
1258             // While there are still bits set
1259             if ((tempExponent & 0x1) == 0x1) {
1260                 // If the low bit is set, multiply in the (many-times-squared) base
1261                 realResult = mul(realResult, tempRealBase);
1262             }
1263             // Shift off the low bit
1264             tempExponent = tempExponent >> 1;
1265             // Do the squaring
1266             tempRealBase = mul(tempRealBase, tempRealBase);
1267         }
1268 
1269         // Return the final result.
1270         return uint216(realResult / REAL_ONE);
1271     }
1272 
1273     /**
1274      * Create a real from a rational fraction.
1275      */
1276     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
1277         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
1278     }
1279 
1280     /**
1281      * Multiply one real by another. Truncates overflows.
1282      */
1283     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
1284         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
1285         // So we just have to clip off the extra REAL_FBITS fractional bits.
1286         return uint256((uint256(realA) * uint256(realB)) >> REAL_FBITS);
1287     }
1288 
1289     /**
1290      * Divide one real by another real. Truncates overflows.
1291      */
1292     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
1293         // We use the reverse of the multiplication trick: convert numerator from
1294         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
1295         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
1296     }
1297 
1298 }
1299 
1300 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/VotingMachineCallbacksInterface.sol
1301 
1302 
1303 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/ProposalExecuteInterface.sol
1304 
1305 interface ProposalExecuteInterface {
1306     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
1307 }
1308 
1309 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
1310 
1311 
1312 // File: openzeppelin-solidity/contracts/math/Math.sol
1313 
1314 /**
1315  * @title Math
1316  * @dev Assorted math operations
1317  */
1318 library Math {
1319     /**
1320     * @dev Returns the largest of two numbers.
1321     */
1322     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1323         return a >= b ? a : b;
1324     }
1325 
1326     /**
1327     * @dev Returns the smallest of two numbers.
1328     */
1329     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1330         return a < b ? a : b;
1331     }
1332 
1333     /**
1334     * @dev Calculates the average of two numbers. Since these are integers,
1335     * averages of an even and odd number cannot be represented, and will be
1336     * rounded down.
1337     */
1338     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1339         // (a + b) / 2 can overflow, so we distribute
1340         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
1341     }
1342 }
1343 
1344 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/GenesisProtocolLogic.sol
1345 
1346 /**
1347  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1348  */
1349 contract GenesisProtocolLogic is IntVoteInterface {
1350     using SafeMath for uint;
1351     using Math for uint;
1352     using RealMath for uint216;
1353     using RealMath for uint256;
1354     using Address for address;
1355 
1356     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
1357     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
1358 
1359     //Organization's parameters
1360     struct Parameters {
1361         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
1362         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
1363         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
1364         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
1365                                           //to be in an preparation state (stable) before boosted.
1366         uint256 thresholdConst; //constant  for threshold calculation .
1367                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
1368         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
1369                                    //in the threshold calculation to prevent overflow
1370         uint256 quietEndingPeriod; //quite ending period
1371         uint256 proposingRepReward;//proposer reputation reward.
1372         uint256 votersReputationLossRatio;//Unsuccessful pre booster
1373                                           //voters lose votersReputationLossRatio% of their reputation.
1374         uint256 minimumDaoBounty;
1375         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
1376                                //(daoBountyConst * averageBoostDownstakes)/100 .
1377         uint256 activationTime;//the point in time after which proposals can be created.
1378         //if this address is set so only this address is allowed to vote of behalf of someone else.
1379         address voteOnBehalf;
1380     }
1381 
1382     struct Voter {
1383         uint256 vote; // YES(1) ,NO(2)
1384         uint256 reputation; // amount of voter's reputation
1385         bool preBoosted;
1386     }
1387 
1388     struct Staker {
1389         uint256 vote; // YES(1) ,NO(2)
1390         uint256 amount; // amount of staker's stake
1391         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
1392     }
1393 
1394     struct Proposal {
1395         bytes32 organizationId; // the organization unique identifier the proposal is target to.
1396         address callbacks;    // should fulfill voting callbacks interface.
1397         ProposalState state;
1398         uint256 winningVote; //the winning vote.
1399         address proposer;
1400         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
1401         uint256 currentBoostedVotePeriodLimit;
1402         bytes32 paramsHash;
1403         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
1404         uint256 daoBounty;
1405         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
1406         uint256 confidenceThreshold;
1407         //The percentage from upper stakes which the caller for the expiration was given.
1408         uint256 expirationCallBountyPercentage;
1409         uint[3] times; //times[0] - submittedTime
1410                        //times[1] - boostedPhaseTime
1411                        //times[2] -preBoostedPhaseTime;
1412         //      vote      reputation
1413         mapping(uint256   =>  uint256    ) votes;
1414         //      vote      reputation
1415         mapping(uint256   =>  uint256    ) preBoostedVotes;
1416         //      address     voter
1417         mapping(address =>  Voter    ) voters;
1418         //      vote        stakes
1419         mapping(uint256   =>  uint256    ) stakes;
1420         //      address  staker
1421         mapping(address  => Staker   ) stakers;
1422     }
1423 
1424     event Stake(bytes32 indexed _proposalId,
1425         address indexed _organization,
1426         address indexed _staker,
1427         uint256 _vote,
1428         uint256 _amount
1429     );
1430 
1431     event Redeem(bytes32 indexed _proposalId,
1432         address indexed _organization,
1433         address indexed _beneficiary,
1434         uint256 _amount
1435     );
1436 
1437     event RedeemDaoBounty(bytes32 indexed _proposalId,
1438         address indexed _organization,
1439         address indexed _beneficiary,
1440         uint256 _amount
1441     );
1442 
1443     event RedeemReputation(bytes32 indexed _proposalId,
1444         address indexed _organization,
1445         address indexed _beneficiary,
1446         uint256 _amount
1447     );
1448 
1449     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
1450     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
1451     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1452 
1453     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
1454     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
1455     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
1456            //organizationId => organization
1457     mapping(bytes32        => address     ) public organizations;
1458           //organizationId => averageBoostDownstakes
1459     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
1460     uint256 constant public NUM_OF_CHOICES = 2;
1461     uint256 constant public NO = 2;
1462     uint256 constant public YES = 1;
1463     uint256 public proposalsCnt; // Total number of proposals
1464     IERC20 public stakingToken;
1465     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
1466     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
1467 
1468     /**
1469      * @dev Constructor
1470      */
1471     constructor(IERC20 _stakingToken) public {
1472       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
1473       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
1474       //If such contract address does not exist in the network (e.g ganache)
1475       //the contract will use the _stakingToken param as the
1476       //staking token address.
1477         if (address(GEN_TOKEN_ADDRESS).isContract()) {
1478             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
1479         } else {
1480             stakingToken = _stakingToken;
1481         }
1482     }
1483 
1484   /**
1485    * @dev Check that the proposal is votable
1486    * a proposal is votable if it is in one of the following states:
1487    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
1488    */
1489     modifier votable(bytes32 _proposalId) {
1490         require(_isVotable(_proposalId));
1491         _;
1492     }
1493 
1494     /**
1495      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
1496      * generated by calculating keccak256 of a incremented counter.
1497      * @param _paramsHash parameters hash
1498      * @param _proposer address
1499      * @param _organization address
1500      */
1501     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
1502         external
1503         returns(bytes32)
1504     {
1505       // solhint-disable-next-line not-rely-on-time
1506         require(now > parameters[_paramsHash].activationTime, "not active yet");
1507         //Check parameters existence.
1508         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
1509         // Generate a unique ID:
1510         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
1511         proposalsCnt = proposalsCnt.add(1);
1512          // Open proposal:
1513         Proposal memory proposal;
1514         proposal.callbacks = msg.sender;
1515         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
1516 
1517         proposal.state = ProposalState.Queued;
1518         // solhint-disable-next-line not-rely-on-time
1519         proposal.times[0] = now;//submitted time
1520         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
1521         proposal.proposer = _proposer;
1522         proposal.winningVote = NO;
1523         proposal.paramsHash = _paramsHash;
1524         if (organizations[proposal.organizationId] == address(0)) {
1525             if (_organization == address(0)) {
1526                 organizations[proposal.organizationId] = msg.sender;
1527             } else {
1528                 organizations[proposal.organizationId] = _organization;
1529             }
1530         }
1531         //calc dao bounty
1532         uint256 daoBounty =
1533         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
1534         if (daoBounty < parameters[_paramsHash].minimumDaoBounty) {
1535             proposal.daoBountyRemain = parameters[_paramsHash].minimumDaoBounty;
1536         } else {
1537             proposal.daoBountyRemain = daoBounty;
1538         }
1539         proposal.totalStakes = proposal.daoBountyRemain;
1540         proposals[proposalId] = proposal;
1541         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
1542         Staker storage staker = proposals[proposalId].stakers[organizations[proposal.organizationId]];
1543         staker.vote = NO;
1544         staker.amount = proposal.daoBountyRemain;
1545 
1546         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
1547         return proposalId;
1548     }
1549 
1550     /**
1551       * @dev executeBoosted try to execute a boosted proposal if it is expired
1552       * @param _proposalId the id of the proposal
1553       * @return uint256 expirationCallBounty the bounty amount for the expiration call
1554      */
1555     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
1556         Proposal storage proposal = proposals[_proposalId];
1557         require(proposal.state == ProposalState.Boosted);
1558         require(_execute(_proposalId), "proposal need to expire");
1559         uint256 expirationCallBountyPercentage =
1560         // solhint-disable-next-line not-rely-on-time
1561         (uint(1).add(now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1])).div(15)));
1562         if (expirationCallBountyPercentage > 100) {
1563             expirationCallBountyPercentage = 100;
1564         }
1565         proposal.expirationCallBountyPercentage = expirationCallBountyPercentage;
1566         expirationCallBounty = expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100);
1567         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
1568         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
1569     }
1570 
1571     /**
1572      * @dev hash the parameters, save them if necessary, and return the hash value
1573      * @param _params a parameters array
1574      *    _params[0] - _queuedVoteRequiredPercentage,
1575      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
1576      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
1577      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
1578      *                  state (stable) before boosted.
1579      *    _params[4] -_thresholdConst
1580      *    _params[5] -_quietEndingPeriod
1581      *    _params[6] -_proposingRepReward
1582      *    _params[7] -_votersReputationLossRatio
1583      *    _params[8] -_minimumDaoBounty
1584      *    _params[9] -_daoBountyConst
1585      *    _params[10] -_activationTime
1586      * @param _voteOnBehalf - authorized to vote on behalf of others.
1587     */
1588     function setParameters(
1589         uint[11] calldata _params, //use array here due to stack too deep issue.
1590         address _voteOnBehalf
1591     )
1592     external
1593     returns(bytes32)
1594     {
1595         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
1596         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
1597         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
1598         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
1599         require(_params[8] > 0, "minimumDaoBounty should be > 0");
1600         require(_params[9] > 0, "daoBountyConst should be > 0");
1601 
1602         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
1603         //set a limit for power for a given alpha to prevent overflow
1604         uint256 limitExponent = 172;//for alpha less or equal 2
1605         uint256 j = 2;
1606         for (uint256 i = 2000; i < 16000; i = i*2) {
1607             if ((_params[4] > i) && (_params[4] <= i*2)) {
1608                 limitExponent = limitExponent/j;
1609                 break;
1610             }
1611             j++;
1612         }
1613 
1614         parameters[paramsHash] = Parameters({
1615             queuedVoteRequiredPercentage: _params[0],
1616             queuedVotePeriodLimit: _params[1],
1617             boostedVotePeriodLimit: _params[2],
1618             preBoostedVotePeriodLimit: _params[3],
1619             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
1620             limitExponentValue:limitExponent,
1621             quietEndingPeriod: _params[5],
1622             proposingRepReward: _params[6],
1623             votersReputationLossRatio:_params[7],
1624             minimumDaoBounty:_params[8],
1625             daoBountyConst:_params[9],
1626             activationTime:_params[10],
1627             voteOnBehalf:_voteOnBehalf
1628         });
1629         return paramsHash;
1630     }
1631 
1632     /**
1633      * @dev redeem a reward for a successful stake, vote or proposing.
1634      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
1635      * users to redeem on behalf of someone else.
1636      * @param _proposalId the ID of the proposal
1637      * @param _beneficiary - the beneficiary address
1638      * @return rewards -
1639      *           [0] stakerTokenReward
1640      *           [1] voterReputationReward
1641      *           [2] proposerReputationReward
1642      */
1643      // solhint-disable-next-line function-max-lines,code-complexity
1644     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
1645         Proposal storage proposal = proposals[_proposalId];
1646         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
1647         "Proposal should be Executed or ExpiredInQueue");
1648         Parameters memory params = parameters[proposal.paramsHash];
1649         uint256 lostReputation;
1650         if (proposal.winningVote == YES) {
1651             lostReputation = proposal.preBoostedVotes[NO];
1652         } else {
1653             lostReputation = proposal.preBoostedVotes[YES];
1654         }
1655         lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
1656         //as staker
1657         Staker storage staker = proposal.stakers[_beneficiary];
1658         if (staker.amount > 0) {
1659             if (proposal.state == ProposalState.ExpiredInQueue) {
1660                 //Stakes of a proposal that expires in Queue are sent back to stakers
1661                 rewards[0] = staker.amount;
1662             } else if (staker.vote == proposal.winningVote) {
1663                 uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
1664                 uint256 totalStakes = proposal.stakes[YES].add(proposal.stakes[NO]);
1665                 if (staker.vote == YES) {
1666                     uint256 _totalStakes =
1667                     ((totalStakes.mul(100 - proposal.expirationCallBountyPercentage))/100) - proposal.daoBounty;
1668                     rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
1669                 } else {
1670                     rewards[0] = (staker.amount.mul(totalStakes))/totalWinningStakes;
1671                     if (organizations[proposal.organizationId] == _beneficiary) {
1672                           //dao redeem it reward
1673                         rewards[0] = rewards[0].sub(proposal.daoBounty);
1674                     }
1675                 }
1676             }
1677             staker.amount = 0;
1678         }
1679         //as voter
1680         Voter storage voter = proposal.voters[_beneficiary];
1681         if ((voter.reputation != 0) && (voter.preBoosted)) {
1682             if (proposal.state == ProposalState.ExpiredInQueue) {
1683               //give back reputation for the voter
1684                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
1685             } else if (proposal.winningVote == voter.vote) {
1686                 uint256 preBoostedVotes = proposal.preBoostedVotes[YES].add(proposal.preBoostedVotes[NO]);
1687                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
1688                 .add((voter.reputation.mul(lostReputation))/preBoostedVotes);
1689             }
1690             voter.reputation = 0;
1691         }
1692         //as proposer
1693         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
1694             rewards[2] = params.proposingRepReward;
1695             proposal.proposer = address(0);
1696         }
1697         if (rewards[0] != 0) {
1698             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
1699             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
1700             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
1701         }
1702         if (rewards[1].add(rewards[2]) != 0) {
1703             VotingMachineCallbacksInterface(proposal.callbacks)
1704             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
1705             emit RedeemReputation(
1706             _proposalId,
1707             organizations[proposal.organizationId],
1708             _beneficiary,
1709             rewards[1].add(rewards[2])
1710             );
1711         }
1712     }
1713 
1714     /**
1715      * @dev redeemDaoBounty a reward for a successful stake.
1716      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
1717      * users to redeem on behalf of someone else.
1718      * @param _proposalId the ID of the proposal
1719      * @param _beneficiary - the beneficiary address
1720      * @return redeemedAmount - redeem token amount
1721      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
1722      */
1723     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
1724     public
1725     returns(uint256 redeemedAmount, uint256 potentialAmount) {
1726         Proposal storage proposal = proposals[_proposalId];
1727         require(proposal.state == ProposalState.Executed);
1728         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
1729         Staker storage staker = proposal.stakers[_beneficiary];
1730         if (
1731             (staker.amount4Bounty > 0)&&
1732             (staker.vote == proposal.winningVote)&&
1733             (proposal.winningVote == YES)&&
1734             (totalWinningStakes != 0)) {
1735             //as staker
1736                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
1737             }
1738         if ((potentialAmount != 0)&&
1739             (VotingMachineCallbacksInterface(proposal.callbacks)
1740             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
1741             staker.amount4Bounty = 0;
1742             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
1743             require(
1744             VotingMachineCallbacksInterface(proposal.callbacks)
1745             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
1746             redeemedAmount = potentialAmount;
1747             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
1748         }
1749     }
1750 
1751     /**
1752      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
1753      * @param _proposalId the ID of the proposal
1754      * @return bool true or false.
1755      */
1756     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
1757         Proposal memory proposal = proposals[_proposalId];
1758         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
1759     }
1760 
1761     /**
1762      * @dev threshold return the organization's score threshold which required by
1763      * a proposal to shift to boosted state.
1764      * This threshold is dynamically set and it depend on the number of boosted proposal.
1765      * @param _organizationId the organization identifier
1766      * @param _paramsHash the organization parameters hash
1767      * @return uint256 organization's score threshold.
1768      */
1769     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
1770         uint256 power = orgBoostedProposalsCnt[_organizationId];
1771         Parameters storage params = parameters[_paramsHash];
1772 
1773         if (power > params.limitExponentValue) {
1774             power = params.limitExponentValue;
1775         }
1776 
1777         return params.thresholdConst.pow(power);
1778     }
1779 
1780   /**
1781    * @dev hashParameters returns a hash of the given parameters
1782    */
1783     function getParametersHash(
1784         uint[11] memory _params,//use array here due to stack too deep issue.
1785         address _voteOnBehalf
1786     )
1787         public
1788         pure
1789         returns(bytes32)
1790         {
1791         //double call to keccak256 to avoid deep stack issue when call with too many params.
1792         return keccak256(
1793             abi.encodePacked(
1794             keccak256(
1795             abi.encodePacked(
1796                 _params[0],
1797                 _params[1],
1798                 _params[2],
1799                 _params[3],
1800                 _params[4],
1801                 _params[5],
1802                 _params[6],
1803                 _params[7],
1804                 _params[8],
1805                 _params[9],
1806                 _params[10])
1807             ),
1808             _voteOnBehalf
1809         ));
1810     }
1811 
1812     /**
1813       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1814       * @param _proposalId the id of the proposal
1815       * @return bool true - the proposal has been executed
1816       *              false - otherwise.
1817      */
1818      // solhint-disable-next-line function-max-lines,code-complexity
1819     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
1820         Proposal storage proposal = proposals[_proposalId];
1821         Parameters memory params = parameters[proposal.paramsHash];
1822         Proposal memory tmpProposal = proposal;
1823         uint256 totalReputation =
1824         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
1825         //first divide by 100 to prevent overflow
1826         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
1827         ExecutionState executionState = ExecutionState.None;
1828         uint256 averageDownstakesOfBoosted;
1829         uint256 confidenceThreshold;
1830 
1831         if (proposal.votes[proposal.winningVote] > executionBar) {
1832          // someone crossed the absolute vote execution bar.
1833             if (proposal.state == ProposalState.Queued) {
1834                 executionState = ExecutionState.QueueBarCrossed;
1835             } else if (proposal.state == ProposalState.PreBoosted) {
1836                 executionState = ExecutionState.PreBoostedBarCrossed;
1837             } else {
1838                 executionState = ExecutionState.BoostedBarCrossed;
1839             }
1840             proposal.state = ProposalState.Executed;
1841         } else {
1842             if (proposal.state == ProposalState.Queued) {
1843                 // solhint-disable-next-line not-rely-on-time
1844                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
1845                     proposal.state = ProposalState.ExpiredInQueue;
1846                     proposal.winningVote = NO;
1847                     executionState = ExecutionState.QueueTimeOut;
1848                 } else {
1849                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1850                     if (_score(_proposalId) > confidenceThreshold) {
1851                         //change proposal mode to PreBoosted mode.
1852                         proposal.state = ProposalState.PreBoosted;
1853                         // solhint-disable-next-line not-rely-on-time
1854                         proposal.times[2] = now;
1855                         proposal.confidenceThreshold = confidenceThreshold;
1856                     }
1857                 }
1858             }
1859 
1860             if (proposal.state == ProposalState.PreBoosted) {
1861                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1862               // solhint-disable-next-line not-rely-on-time
1863                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
1864                     if ((_score(_proposalId) > confidenceThreshold) &&
1865                         (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)) {
1866                        //change proposal mode to Boosted mode.
1867                         proposal.state = ProposalState.Boosted;
1868                        // solhint-disable-next-line not-rely-on-time
1869                         proposal.times[1] = now;
1870                         orgBoostedProposalsCnt[proposal.organizationId]++;
1871                        //add a value to average -> average = average + ((value - average) / nbValues)
1872                         averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1873                         // solium-disable-next-line indentation
1874                         averagesDownstakesOfBoosted[proposal.organizationId] =
1875                             uint256(int256(averageDownstakesOfBoosted) +
1876                             ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
1877                             int256(orgBoostedProposalsCnt[proposal.organizationId])));
1878                     }
1879                 } else { //check the Confidence level is stable
1880                     uint256 proposalScore = _score(_proposalId);
1881                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
1882                         proposal.state = ProposalState.Queued;
1883                     } else if (proposal.confidenceThreshold > proposalScore) {
1884                         proposal.confidenceThreshold = confidenceThreshold;
1885                     }
1886                 }
1887             }
1888         }
1889 
1890         if ((proposal.state == ProposalState.Boosted) ||
1891             (proposal.state == ProposalState.QuietEndingPeriod)) {
1892             // solhint-disable-next-line not-rely-on-time
1893             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
1894                 proposal.state = ProposalState.Executed;
1895                 executionState = ExecutionState.BoostedTimeOut;
1896             }
1897         }
1898 
1899         if (executionState != ExecutionState.None) {
1900             if ((executionState == ExecutionState.BoostedTimeOut) ||
1901                 (executionState == ExecutionState.BoostedBarCrossed)) {
1902                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
1903                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1904                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
1905                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1906                 if (boostedProposals == 0) {
1907                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1908                 } else {
1909                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1910                     averagesDownstakesOfBoosted[proposal.organizationId] =
1911                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1912                 }
1913             }
1914             emit ExecuteProposal(
1915             _proposalId,
1916             organizations[proposal.organizationId],
1917             proposal.winningVote,
1918             totalReputation
1919             );
1920             emit GPExecuteProposal(_proposalId, executionState);
1921             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1922             proposal.daoBounty = proposal.daoBountyRemain;
1923         }
1924         if (tmpProposal.state != proposal.state) {
1925             emit StateChange(_proposalId, proposal.state);
1926         }
1927         return (executionState != ExecutionState.None);
1928     }
1929 
1930     /**
1931      * @dev staking function
1932      * @param _proposalId id of the proposal
1933      * @param _vote  NO(2) or YES(1).
1934      * @param _amount the betting amount
1935      * @return bool true - the proposal has been executed
1936      *              false - otherwise.
1937      */
1938     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1939         // 0 is not a valid vote.
1940         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1941         require(_amount > 0, "staking amount should be >0");
1942 
1943         if (_execute(_proposalId)) {
1944             return true;
1945         }
1946         Proposal storage proposal = proposals[_proposalId];
1947 
1948         if ((proposal.state != ProposalState.PreBoosted) &&
1949             (proposal.state != ProposalState.Queued)) {
1950             return false;
1951         }
1952 
1953         // enable to increase stake only on the previous stake vote
1954         Staker storage staker = proposal.stakers[_staker];
1955         if ((staker.amount > 0) && (staker.vote != _vote)) {
1956             return false;
1957         }
1958 
1959         uint256 amount = _amount;
1960         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1961         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1962         staker.amount = staker.amount.add(amount);
1963         //This is to prevent average downstakes calculation overflow
1964         //Note that any how GEN cap is 100000000 ether.
1965         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1966         require(proposal.totalStakes <= 0x100000000000000000000000000000000, "total stakes is too high");
1967 
1968         if (_vote == YES) {
1969             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1970         }
1971         staker.vote = _vote;
1972 
1973         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1974         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1975         return _execute(_proposalId);
1976     }
1977 
1978     /**
1979      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1980      * @param _proposalId id of the proposal
1981      * @param _voter used in case the vote is cast for someone else
1982      * @param _vote a value between 0 to and the proposal's number of choices.
1983      * @param _rep how many reputation the voter would like to stake for this vote.
1984      *         if  _rep==0 so the voter full reputation will be use.
1985      * @return true in case of proposal execution otherwise false
1986      * throws if proposal is not open or if it has been executed
1987      * NB: executes the proposal if a decision has been reached
1988      */
1989      // solhint-disable-next-line function-max-lines,code-complexity
1990     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1991         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1992         if (_execute(_proposalId)) {
1993             return true;
1994         }
1995 
1996         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1997         Proposal storage proposal = proposals[_proposalId];
1998 
1999         // Check voter has enough reputation:
2000         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
2001         require(reputation > 0, "_voter must have reputation");
2002         require(reputation >= _rep, "reputation >= _rep");
2003         uint256 rep = _rep;
2004         if (rep == 0) {
2005             rep = reputation;
2006         }
2007         // If this voter has already voted, return false.
2008         if (proposal.voters[_voter].reputation != 0) {
2009             return false;
2010         }
2011         // The voting itself:
2012         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
2013         //check if the current winningVote changed or there is a tie.
2014         //for the case there is a tie the current winningVote set to NO.
2015         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
2016             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
2017             proposal.winningVote == YES)) {
2018             if (proposal.state == ProposalState.Boosted &&
2019             // solhint-disable-next-line not-rely-on-time
2020                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
2021                 proposal.state == ProposalState.QuietEndingPeriod) {
2022                 //quietEndingPeriod
2023                 if (proposal.state != ProposalState.QuietEndingPeriod) {
2024                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
2025                     proposal.state = ProposalState.QuietEndingPeriod;
2026                 }
2027                 // solhint-disable-next-line not-rely-on-time
2028                 proposal.times[1] = now;
2029             }
2030             proposal.winningVote = _vote;
2031         }
2032         proposal.voters[_voter] = Voter({
2033             reputation: rep,
2034             vote: _vote,
2035             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
2036         });
2037         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
2038             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
2039             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
2040             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
2041         }
2042         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
2043         return _execute(_proposalId);
2044     }
2045 
2046     /**
2047      * @dev _score return the proposal score (Confidence level)
2048      * For dual choice proposal S = (S+)/(S-)
2049      * @param _proposalId the ID of the proposal
2050      * @return uint256 proposal score.
2051      */
2052     function _score(bytes32 _proposalId) internal view returns(uint256) {
2053         Proposal storage proposal = proposals[_proposalId];
2054         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
2055         return proposal.stakes[YES]/proposal.stakes[NO];
2056     }
2057 
2058     /**
2059       * @dev _isVotable check if the proposal is votable
2060       * @param _proposalId the ID of the proposal
2061       * @return bool true or false
2062     */
2063     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
2064         ProposalState pState = proposals[_proposalId].state;
2065         return ((pState == ProposalState.PreBoosted)||
2066                 (pState == ProposalState.Boosted)||
2067                 (pState == ProposalState.QuietEndingPeriod)||
2068                 (pState == ProposalState.Queued)
2069         );
2070     }
2071 }
2072 
2073 // File: @daostack/infra/contracts/votingMachines/GenesisProtocol.sol
2074 
2075 /**
2076  * @title GenesisProtocol implementation -an organization's voting machine scheme.
2077  */
2078 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
2079     using ECDSA for bytes32;
2080 
2081     // Digest describing the data the user signs according EIP 712.
2082     // Needs to match what is passed to Metamask.
2083     bytes32 public constant DELEGATION_HASH_EIP712 =
2084     keccak256(abi.encodePacked(
2085     "address GenesisProtocolAddress",
2086     "bytes32 ProposalId",
2087     "uint256 Vote",
2088     "uint256 AmountToStake",
2089     "uint256 Nonce"
2090     ));
2091 
2092     mapping(address=>uint256) public stakesNonce; //stakes Nonce
2093 
2094     /**
2095      * @dev Constructor
2096      */
2097     constructor(IERC20 _stakingToken)
2098     public
2099     // solhint-disable-next-line no-empty-blocks
2100     GenesisProtocolLogic(_stakingToken) {
2101     }
2102 
2103     /**
2104      * @dev staking function
2105      * @param _proposalId id of the proposal
2106      * @param _vote  NO(2) or YES(1).
2107      * @param _amount the betting amount
2108      * @return bool true - the proposal has been executed
2109      *              false - otherwise.
2110      */
2111     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
2112         return _stake(_proposalId, _vote, _amount, msg.sender);
2113     }
2114 
2115     /**
2116      * @dev stakeWithSignature function
2117      * @param _proposalId id of the proposal
2118      * @param _vote  NO(2) or YES(1).
2119      * @param _amount the betting amount
2120      * @param _nonce nonce value ,it is part of the signature to ensure that
2121               a signature can be received only once.
2122      * @param _signatureType signature type
2123               1 - for web3.eth.sign
2124               2 - for eth_signTypedData according to EIP #712.
2125      * @param _signature  - signed data by the staker
2126      * @return bool true - the proposal has been executed
2127      *              false - otherwise.
2128      */
2129     function stakeWithSignature(
2130         bytes32 _proposalId,
2131         uint256 _vote,
2132         uint256 _amount,
2133         uint256 _nonce,
2134         uint256 _signatureType,
2135         bytes calldata _signature
2136         )
2137         external
2138         returns(bool)
2139         {
2140         // Recreate the digest the user signed
2141         bytes32 delegationDigest;
2142         if (_signatureType == 2) {
2143             delegationDigest = keccak256(
2144                 abi.encodePacked(
2145                     DELEGATION_HASH_EIP712, keccak256(
2146                         abi.encodePacked(
2147                         address(this),
2148                         _proposalId,
2149                         _vote,
2150                         _amount,
2151                         _nonce)
2152                     )
2153                 )
2154             );
2155         } else {
2156             delegationDigest = keccak256(
2157                         abi.encodePacked(
2158                         address(this),
2159                         _proposalId,
2160                         _vote,
2161                         _amount,
2162                         _nonce)
2163                     ).toEthSignedMessageHash();
2164         }
2165         address staker = delegationDigest.recover(_signature);
2166         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
2167         require(staker != address(0), "staker address cannot be 0");
2168         require(stakesNonce[staker] == _nonce);
2169         stakesNonce[staker] = stakesNonce[staker].add(1);
2170         return _stake(_proposalId, _vote, _amount, staker);
2171     }
2172 
2173     /**
2174      * @dev voting function
2175      * @param _proposalId id of the proposal
2176      * @param _vote NO(2) or YES(1).
2177      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
2178      * @param _voter voter address
2179      * @return bool true - the proposal has been executed
2180      *              false - otherwise.
2181      */
2182     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
2183     external
2184     votable(_proposalId)
2185     returns(bool) {
2186         Proposal storage proposal = proposals[_proposalId];
2187         Parameters memory params = parameters[proposal.paramsHash];
2188         address voter;
2189         if (params.voteOnBehalf != address(0)) {
2190             require(msg.sender == params.voteOnBehalf);
2191             voter = _voter;
2192         } else {
2193             voter = msg.sender;
2194         }
2195         return internalVote(_proposalId, voter, _vote, _amount);
2196     }
2197 
2198   /**
2199    * @dev Cancel the vote of the msg.sender.
2200    * cancel vote is not allow in genesisProtocol so this function doing nothing.
2201    * This function is here in order to comply to the IntVoteInterface .
2202    */
2203     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
2204        //this is not allowed
2205         return;
2206     }
2207 
2208     /**
2209       * @dev execute check if the proposal has been decided, and if so, execute the proposal
2210       * @param _proposalId the id of the proposal
2211       * @return bool true - the proposal has been executed
2212       *              false - otherwise.
2213      */
2214     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
2215         return _execute(_proposalId);
2216     }
2217 
2218   /**
2219     * @dev getNumberOfChoices returns the number of choices possible in this proposal
2220     * @return uint256 that contains number of choices
2221     */
2222     function getNumberOfChoices(bytes32) external view returns(uint256) {
2223         return NUM_OF_CHOICES;
2224     }
2225 
2226     /**
2227       * @dev getProposalTimes returns proposals times variables.
2228       * @param _proposalId id of the proposal
2229       * @return proposals times array
2230       */
2231     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
2232         return proposals[_proposalId].times;
2233     }
2234 
2235     /**
2236      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
2237      * @param _proposalId the ID of the proposal
2238      * @param _voter the address of the voter
2239      * @return uint256 vote - the voters vote
2240      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
2241      */
2242     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
2243         Voter memory voter = proposals[_proposalId].voters[_voter];
2244         return (voter.vote, voter.reputation);
2245     }
2246 
2247     /**
2248     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
2249     * @param _proposalId the ID of the proposal
2250     * @param _choice the index in the
2251     * @return voted reputation for the given choice
2252     */
2253     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
2254         return proposals[_proposalId].votes[_choice];
2255     }
2256 
2257     /**
2258     * @dev isVotable check if the proposal is votable
2259     * @param _proposalId the ID of the proposal
2260     * @return bool true or false
2261     */
2262     function isVotable(bytes32 _proposalId) external view returns(bool) {
2263         return _isVotable(_proposalId);
2264     }
2265 
2266     /**
2267     * @dev proposalStatus return the total votes and stakes for a given proposal
2268     * @param _proposalId the ID of the proposal
2269     * @return uint256 preBoostedVotes YES
2270     * @return uint256 preBoostedVotes NO
2271     * @return uint256 total stakes YES
2272     * @return uint256 total stakes NO
2273     */
2274     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
2275         return (
2276                 proposals[_proposalId].preBoostedVotes[YES],
2277                 proposals[_proposalId].preBoostedVotes[NO],
2278                 proposals[_proposalId].stakes[YES],
2279                 proposals[_proposalId].stakes[NO]
2280         );
2281     }
2282 
2283   /**
2284     * @dev getProposalOrganization return the organizationId for a given proposal
2285     * @param _proposalId the ID of the proposal
2286     * @return bytes32 organization identifier
2287     */
2288     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
2289         return (proposals[_proposalId].organizationId);
2290     }
2291 
2292     /**
2293       * @dev getStaker return the vote and stake amount for a given proposal and staker
2294       * @param _proposalId the ID of the proposal
2295       * @param _staker staker address
2296       * @return uint256 vote
2297       * @return uint256 amount
2298     */
2299     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
2300         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
2301     }
2302 
2303     /**
2304       * @dev voteStake return the amount stakes for a given proposal and vote
2305       * @param _proposalId the ID of the proposal
2306       * @param _vote vote number
2307       * @return uint256 stake amount
2308     */
2309     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
2310         return proposals[_proposalId].stakes[_vote];
2311     }
2312 
2313   /**
2314     * @dev voteStake return the winningVote for a given proposal
2315     * @param _proposalId the ID of the proposal
2316     * @return uint256 winningVote
2317     */
2318     function winningVote(bytes32 _proposalId) external view returns(uint256) {
2319         return proposals[_proposalId].winningVote;
2320     }
2321 
2322     /**
2323       * @dev voteStake return the state for a given proposal
2324       * @param _proposalId the ID of the proposal
2325       * @return ProposalState proposal state
2326     */
2327     function state(bytes32 _proposalId) external view returns(ProposalState) {
2328         return proposals[_proposalId].state;
2329     }
2330 
2331    /**
2332     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
2333     * @return bool true or false
2334     */
2335     function isAbstainAllow() external pure returns(bool) {
2336         return false;
2337     }
2338 
2339     /**
2340      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
2341      * @return min - minimum number of choices
2342                max - maximum number of choices
2343      */
2344     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
2345         return (YES, NO);
2346     }
2347 
2348     /**
2349      * @dev score return the proposal score
2350      * @param _proposalId the ID of the proposal
2351      * @return uint256 proposal score.
2352      */
2353     function score(bytes32 _proposalId) public view returns(uint256) {
2354         return  _score(_proposalId);
2355     }
2356 }
2357 
2358 // File: /Users/oren/daostack/daostack2/daostack/contracts/votingMachines/VotingMachineCallbacks.sol
2359 
2360 contract VotingMachineCallbacks is VotingMachineCallbacksInterface {
2361 
2362     struct ProposalInfo {
2363         uint256 blockNumber; // the proposal's block number
2364         Avatar avatar; // the proposal's avatar
2365         address votingMachine;
2366     }
2367 
2368     modifier onlyVotingMachine(bytes32 _proposalId) {
2369         require(msg.sender == proposalsInfo[_proposalId].votingMachine, "only VotingMachine");
2370         _;
2371     }
2372 
2373             //proposalId ->     ProposalInfo
2374     mapping(bytes32      =>     ProposalInfo    ) public proposalsInfo;
2375 
2376     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId)
2377     external
2378     onlyVotingMachine(_proposalId)
2379     returns(bool)
2380     {
2381         Avatar avatar = proposalsInfo[_proposalId].avatar;
2382         if (avatar == Avatar(0)) {
2383             return false;
2384         }
2385         return ControllerInterface(avatar.owner()).mintReputation(_amount, _beneficiary, address(avatar));
2386     }
2387 
2388     function burnReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId)
2389     external
2390     onlyVotingMachine(_proposalId)
2391     returns(bool)
2392     {
2393         Avatar avatar = proposalsInfo[_proposalId].avatar;
2394         if (avatar == Avatar(0)) {
2395             return false;
2396         }
2397         return ControllerInterface(avatar.owner()).burnReputation(_amount, _beneficiary, address(avatar));
2398     }
2399 
2400     function stakingTokenTransfer(
2401         IERC20 _stakingToken,
2402         address _beneficiary,
2403         uint256 _amount,
2404         bytes32 _proposalId)
2405     external
2406     onlyVotingMachine(_proposalId)
2407     returns(bool)
2408     {
2409         Avatar avatar = proposalsInfo[_proposalId].avatar;
2410         if (avatar == Avatar(0)) {
2411             return false;
2412         }
2413         return ControllerInterface(avatar.owner()).externalTokenTransfer(_stakingToken, _beneficiary, _amount, avatar);
2414     }
2415 
2416     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256) {
2417         Avatar avatar = proposalsInfo[_proposalId].avatar;
2418         if (proposalsInfo[_proposalId].avatar == Avatar(0)) {
2419             return 0;
2420         }
2421         return _stakingToken.balanceOf(address(avatar));
2422     }
2423 
2424     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256) {
2425         ProposalInfo memory proposal = proposalsInfo[_proposalId];
2426         if (proposal.avatar == Avatar(0)) {
2427             return 0;
2428         }
2429         return proposal.avatar.nativeReputation().totalSupplyAt(proposal.blockNumber);
2430     }
2431 
2432     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256) {
2433         ProposalInfo memory proposal = proposalsInfo[_proposalId];
2434         if (proposal.avatar == Avatar(0)) {
2435             return 0;
2436         }
2437         return proposal.avatar.nativeReputation().balanceOfAt(_owner, proposal.blockNumber);
2438     }
2439 }
2440 
2441 // File: contracts/universalSchemes/GenericScheme.sol
2442 
2443 /**
2444  * @title GenericScheme.
2445  * @dev  A scheme for proposing and executing calls to an arbitrary function
2446  * on a specific contract on behalf of the organization avatar.
2447  */
2448 contract GenericScheme is UniversalScheme, VotingMachineCallbacks, ProposalExecuteInterface {
2449     event NewCallProposal(
2450         address indexed _avatar,
2451         bytes32 indexed _proposalId,
2452         bytes   _callData,
2453         string  _descriptionHash
2454     );
2455 
2456     event ProposalExecuted(
2457         address indexed _avatar,
2458         bytes32 indexed _proposalId,
2459         bytes _genericCallReturnValue
2460     );
2461 
2462     event ProposalExecutedByVotingMachine(
2463         address indexed _avatar,
2464         bytes32 indexed _proposalId,
2465         int256 _param
2466     );
2467 
2468     event ProposalDeleted(address indexed _avatar, bytes32 indexed _proposalId);
2469 
2470     // Details of a voting proposal:
2471     struct CallProposal {
2472         bytes callData;
2473         bool exist;
2474         bool passed;
2475     }
2476 
2477     // A mapping from the organization (Avatar) address to the saved data of the organization:
2478     mapping(address=>mapping(bytes32=>CallProposal)) public organizationsProposals;
2479 
2480     struct Parameters {
2481         IntVoteInterface intVote;
2482         bytes32 voteParams;
2483         address contractToCall;
2484     }
2485 
2486     // A mapping from hashes to parameters (use to store a particular configuration on the controller)
2487     mapping(bytes32=>Parameters) public parameters;
2488 
2489     /**
2490     * @dev execution of proposals, can only be called by the voting machine in which the vote is held.
2491     * @param _proposalId the ID of the voting in the voting machine
2492     * @param _decision a parameter of the voting result, 1 yes and 2 is no.
2493     * @return bool success
2494     */
2495     function executeProposal(bytes32 _proposalId, int256 _decision)
2496     external
2497     onlyVotingMachine(_proposalId)
2498     returns(bool) {
2499         Avatar avatar = proposalsInfo[_proposalId].avatar;
2500         CallProposal storage proposal = organizationsProposals[address(avatar)][_proposalId];
2501         require(proposal.exist, "must be a live proposal");
2502         require(proposal.passed == false, "cannot execute twice");
2503 
2504         if (_decision == 1) {
2505             proposal.passed = true;
2506             execute(_proposalId);
2507         } else {
2508             delete organizationsProposals[address(avatar)][_proposalId];
2509             emit ProposalDeleted(address(avatar), _proposalId);
2510         }
2511 
2512         emit ProposalExecutedByVotingMachine(address(avatar), _proposalId, _decision);
2513         return true;
2514     }
2515 
2516     /**
2517     * @dev execution of proposals after it has been decided by the voting machine
2518     * @param _proposalId the ID of the voting in the voting machine
2519     */
2520     function execute(bytes32 _proposalId) public {
2521         Avatar avatar = proposalsInfo[_proposalId].avatar;
2522         Parameters memory params = parameters[getParametersFromController(avatar)];
2523         CallProposal storage proposal = organizationsProposals[address(avatar)][_proposalId];
2524         require(proposal.exist, "must be a live proposal");
2525         require(proposal.passed, "proposal must passed by voting machine");
2526         proposal.exist = false;
2527         bytes memory genericCallReturnValue;
2528         bool success;
2529         ControllerInterface controller = ControllerInterface(Avatar(avatar).owner());
2530         (success, genericCallReturnValue) = controller.genericCall(params.contractToCall, proposal.callData, avatar);
2531         if (success) {
2532             delete organizationsProposals[address(avatar)][_proposalId];
2533             emit ProposalDeleted(address(avatar), _proposalId);
2534             emit ProposalExecuted(address(avatar), _proposalId, genericCallReturnValue);
2535         } else {
2536             proposal.exist = true;
2537         }
2538     }
2539 
2540     /**
2541     * @dev Hash the parameters, save them if necessary, and return the hash value
2542     * @param _voteParams -  voting parameters
2543     * @param _intVote  - voting machine contract.
2544     * @return bytes32 -the parameters hash
2545     */
2546     function setParameters(
2547         bytes32 _voteParams,
2548         IntVoteInterface _intVote,
2549         address _contractToCall
2550     ) public returns(bytes32)
2551     {
2552         bytes32 paramsHash = getParametersHash(_voteParams, _intVote, _contractToCall);
2553         parameters[paramsHash].voteParams = _voteParams;
2554         parameters[paramsHash].intVote = _intVote;
2555         parameters[paramsHash].contractToCall = _contractToCall;
2556         return paramsHash;
2557     }
2558 
2559     /**
2560     * @dev Hash the parameters, and return the hash value
2561     * @param _voteParams -  voting parameters
2562     * @param _intVote  - voting machine contract.
2563     * @return bytes32 -the parameters hash
2564     */
2565     function getParametersHash(
2566         bytes32 _voteParams,
2567         IntVoteInterface _intVote,
2568         address _contractToCall
2569     ) public pure returns(bytes32)
2570     {
2571         return keccak256(abi.encodePacked(_voteParams, _intVote, _contractToCall));
2572     }
2573 
2574     /**
2575     * @dev propose to call on behalf of the _avatar
2576     *      The function trigger NewCallProposal event
2577     * @param _callData - The abi encode data for the call
2578     * @param _avatar avatar of the organization
2579     * @param _descriptionHash proposal description hash
2580     * @return an id which represents the proposal
2581     */
2582     function proposeCall(Avatar _avatar, bytes memory _callData, string memory _descriptionHash)
2583     public
2584     returns(bytes32)
2585     {
2586         Parameters memory params = parameters[getParametersFromController(_avatar)];
2587         IntVoteInterface intVote = params.intVote;
2588 
2589         bytes32 proposalId = intVote.propose(2, params.voteParams, msg.sender, address(_avatar));
2590 
2591         organizationsProposals[address(_avatar)][proposalId] = CallProposal({
2592             callData: _callData,
2593             exist: true,
2594             passed: false
2595         });
2596         proposalsInfo[proposalId] = ProposalInfo({
2597             blockNumber:block.number,
2598             avatar:_avatar,
2599             votingMachine:address(params.intVote)
2600         });
2601         emit NewCallProposal(address(_avatar), proposalId, _callData, _descriptionHash);
2602         return proposalId;
2603     }
2604 
2605     /**
2606     * @dev getContractToCall return the contract this scheme is calling
2607     * @param _avatar address of the organization's avatar
2608     * @return address the address of the contract this scheme is calling to
2609     * on behalf of the avatar
2610     */
2611     function getContractToCall(Avatar _avatar) public view returns(address) {
2612         return parameters[getParametersFromController(_avatar)].contractToCall;
2613     }
2614 
2615 }