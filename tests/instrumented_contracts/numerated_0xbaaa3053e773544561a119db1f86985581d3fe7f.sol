1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/stakerewardV2pool.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"./IesLBR.sol\";\nimport \"./IERC20.sol\";\n\ninterface IesLBRBoost {\n    function getUserBoost(\n        address user,\n        uint256 userUpdatedAt,\n        uint256 finishAt\n    ) external view returns (uint256);\n\n    function getUnlockTime(address user)\n        external\n        view\n        returns (uint256 unlockTime);\n}\n\ninterface IlybraFund {\n    function refreshReward(address user) external;\n}\n\ncontract StakingRewardsV2 {\n    // Immutable variables for staking and rewards tokens\n    IERC20 public immutable stakingToken;\n    IesLBR public immutable rewardsToken;\n    IesLBRBoost public esLBRBoost;\n    IlybraFund public lybraFund;\n    address public owner;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint256 public duration = 2_592_000;\n    // Timestamp of when the rewards finish\n    uint256 public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n    // Reward to be paid out per second\n    uint256 public rewardRate;\n    // Sum of (reward rate * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userUpdatedAt;\n\n    // Total staked\n    uint256 public totalSupply;\n    // User address => staked amount\n    mapping(address => uint256) public balanceOf;\n\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _boost,\n        address _fund\n    ) {\n        owner = msg.sender;\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IesLBR(_rewardToken);\n        esLBRBoost = IesLBRBoost(_boost);\n        lybraFund = IlybraFund(_fund);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not authorized\");\n        _;\n    }\n\n    // Update user's claimable reward data and record the timestamp.\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n            userUpdatedAt[_account] = block.timestamp;\n        }\n        _;\n    }\n\n    // Returns the last time the reward was applicable\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    // Calculates and returns the reward per token\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n            rewardPerTokenStored +\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\n            totalSupply;\n    }\n\n    // Allows users to stake a specified amount of tokens\n    function stake(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[msg.sender] += _amount;\n        totalSupply += _amount;\n    }\n\n    // Allows users to withdraw a specified amount of staked tokens\n    function withdraw(uint256 _amount) external updateReward(msg.sender) {\n        require(_amount > 0, \"amount = 0\");\n        balanceOf[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n    }\n\n    function getBoost(address _account) public view returns (uint256) {\n        return 100 * 1e18 + esLBRBoost.getUserBoost(\n            _account,\n            userUpdatedAt[_account],\n            finishAt\n        );\n    }\n\n    // Calculates and returns the earned rewards for a user\n    function earned(address _account) public view returns (uint256) {\n        return\n            ((balanceOf[_account] *\n                getBoost(_account) *\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e38) +\n            rewards[_account];\n    }\n\n    // Allows users to claim their earned rewards\n    function getReward() external updateReward(msg.sender) {\n        require(\n            block.timestamp >= esLBRBoost.getUnlockTime(msg.sender),\n            \"Your lock-in period has not ended. You can't claim your esLBR now.\"\n        );\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            lybraFund.refreshReward(msg.sender);\n            rewardsToken.mint(msg.sender, reward);\n        }\n    }\n\n    // Allows the owner to set the rewards duration\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    // Allows the owner to set the boost contract address\n    function setBoost(address _boost) external onlyOwner {\n        esLBRBoost = IesLBRBoost(_boost);\n    }\n\n    // Allows the owner to set the mining rewards.\n    function notifyRewardAmount(uint256 _amount)\n        external\n        onlyOwner\n        updateReward(address(0))\n    {\n        if (block.timestamp >= finishAt) {\n            rewardRate = _amount / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) *\n                rewardRate;\n            rewardRate = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n"
6     },
7     "contracts/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}"
9     },
10     "contracts/IesLBR.sol": {
11       "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\ninterface IesLBR {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function mint(address user, uint256 amount) external returns(bool);\r\n    function burn(address user, uint256 amount) external returns(bool);\r\n}"
12     }
13   },
14   "settings": {
15     "optimizer": {
16       "enabled": true,
17       "runs": 200
18     },
19     "outputSelection": {
20       "*": {
21         "*": [
22           "evm.bytecode",
23           "evm.deployedBytecode",
24           "devdoc",
25           "userdoc",
26           "metadata",
27           "abi"
28         ]
29       }
30     }
31   }
32 }}