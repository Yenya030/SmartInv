1 pragma solidity ^0.4.21;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 
7 // File: contracts/library/SafeMath.sol
8 
9 /**
10  * @title Safe Math
11  *
12  * @dev Library for safe mathematical operations.
13  */
14 library SafeMath {
15     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
16         uint256 c = a * b;
17         assert(a == 0 || c / a == b);
18 
19         return c;
20     }
21 
22     function div(uint256 a, uint256 b) internal pure returns (uint256) {
23         uint256 c = a / b;
24 
25         return c;
26     }
27 
28     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
29         assert(b <= a);
30 
31         return a - b;
32     }
33 
34     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
35         uint256 c = a + b;
36         assert(c >= a);
37 
38         return c;
39     }
40 }
41 
42 // File: contracts/token/ERC20Token.sol
43 
44 /**
45  * @dev The standard ERC20 Token contract base.
46  */
47 contract ERC20Token {
48     uint256 public totalSupply;  /* shorthand for public function and a property */
49     
50     function balanceOf(address _owner) public view returns (uint256 balance);
51     function transfer(address _to, uint256 _value) public returns (bool success);
52     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
53     function approve(address _spender, uint256 _value) public returns (bool success);
54     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
55 
56     event Transfer(address indexed _from, address indexed _to, uint256 _value);
57     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
58 }
59 
60 // File: contracts/component/TokenSafe.sol
61 
62 /**
63  * @title TokenSafe
64  *
65  * @dev Abstract contract that serves as a base for the token safes. It is a multi-group token safe, where each group
66  *      has it's own release time and multiple accounts with locked tokens.
67  */
68 contract TokenSafe {
69     using SafeMath for uint;
70 
71     // The ERC20 token contract.
72     ERC20Token token;
73 
74     struct Group {
75         // The release date for the locked tokens
76         // Note: Unix timestamp fits in uint32, however block.timestamp is uint256
77         uint256 releaseTimestamp;
78         // The total remaining tokens in the group.
79         uint256 remaining;
80         // The individual account token balances in the group.
81         mapping (address => uint) balances;
82     }
83 
84     // The groups of locked tokens
85     mapping (uint8 => Group) public groups;
86 
87     /**
88      * @dev The constructor.
89      *
90      * @param _token The address of the Fabric Token (fundraiser) contract.
91      */
92     constructor(address _token) public {
93         token = ERC20Token(_token);
94     }
95 
96     /**
97      * @dev The function initializes a group with a release date.
98      *
99      * @param _id Group identifying number.
100      * @param _releaseTimestamp Unix timestamp of the time after which the tokens can be released
101      */
102     function init(uint8 _id, uint _releaseTimestamp) internal {
103         require(_releaseTimestamp > 0);
104         
105         Group storage group = groups[_id];
106         group.releaseTimestamp = _releaseTimestamp;
107     }
108 
109     /**
110      * @dev Add new account with locked token balance to the specified group id.
111      *
112      * @param _id Group identifying number.
113      * @param _account The address of the account to be added.
114      * @param _balance The number of tokens to be locked.
115      */
116     function add(uint8 _id, address _account, uint _balance) internal {
117         Group storage group = groups[_id];
118         group.balances[_account] = group.balances[_account].plus(_balance);
119         group.remaining = group.remaining.plus(_balance);
120     }
121 
122     /**
123      * @dev Allows an account to be released if it meets the time constraints of the group.
124      *
125      * @param _id Group identifying number.
126      * @param _account The address of the account to be released.
127      */
128     function release(uint8 _id, address _account) public {
129         Group storage group = groups[_id];
130         require(now >= group.releaseTimestamp);
131         
132         uint tokens = group.balances[_account];
133         require(tokens > 0);
134         
135         group.balances[_account] = 0;
136         group.remaining = group.remaining.minus(tokens);
137         
138         if (!token.transfer(_account, tokens)) {
139             revert();
140         }
141     }
142 }
143 
144 // File: contracts/token/StandardToken.sol
145 
146 /**
147  * @title Standard Token
148  *
149  * @dev The standard abstract implementation of the ERC20 interface.
150  */
151 contract StandardToken is ERC20Token {
152     using SafeMath for uint256;
153 
154     string public name;
155     string public symbol;
156     uint8 public decimals;
157     
158     mapping (address => uint256) balances;
159     mapping (address => mapping (address => uint256)) internal allowed;
160     
161     /**
162      * @dev The constructor assigns the token name, symbols and decimals.
163      */
164     constructor(string _name, string _symbol, uint8 _decimals) internal {
165         name = _name;
166         symbol = _symbol;
167         decimals = _decimals;
168     }
169 
170     /**
171      * @dev Get the balance of an address.
172      *
173      * @param _address The address which's balance will be checked.
174      *
175      * @return The current balance of the address.
176      */
177     function balanceOf(address _address) public view returns (uint256 balance) {
178         return balances[_address];
179     }
180 
181     /**
182      * @dev Checks the amount of tokens that an owner allowed to a spender.
183      *
184      * @param _owner The address which owns the funds allowed for spending by a third-party.
185      * @param _spender The third-party address that is allowed to spend the tokens.
186      *
187      * @return The number of tokens available to `_spender` to be spent.
188      */
189     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
190         return allowed[_owner][_spender];
191     }
192 
193     /**
194      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
195      * E.g. You place a buy or sell order on an exchange and in that example, the 
196      * `_spender` address is the address of the contract the exchange created to add your token to their 
197      * website and you are `msg.sender`.
198      *
199      * @param _spender The address which will spend the funds.
200      * @param _value The amount of tokens to be spent.
201      *
202      * @return Whether the approval process was successful or not.
203      */
204     function approve(address _spender, uint256 _value) public returns (bool) {
205         allowed[msg.sender][_spender] = _value;
206 
207         emit Approval(msg.sender, _spender, _value);
208 
209         return true;
210     }
211 
212     /**
213      * @dev Transfers `_value` number of tokens to the `_to` address.
214      *
215      * @param _to The address of the recipient.
216      * @param _value The number of tokens to be transferred.
217      */
218     function transfer(address _to, uint256 _value) public returns (bool) {
219         executeTransfer(msg.sender, _to, _value);
220 
221         return true;
222     }
223 
224     /**
225      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
226      *
227      * @param _from The address which approved you to spend tokens on their behalf.
228      * @param _to The address where you want to send tokens.
229      * @param _value The number of tokens to be sent.
230      *
231      * @return Whether the transfer was successful or not.
232      */
233     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
234         require(_value <= allowed[_from][msg.sender]);
235         
236         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
237         executeTransfer(_from, _to, _value);
238 
239         return true;
240     }
241 
242     /**
243      * @dev Internal function that this reused by the transfer functions
244      */
245     function executeTransfer(address _from, address _to, uint256 _value) internal {
246         require(_to != address(0));
247         require(_value != 0 && _value <= balances[_from]);
248         
249         balances[_from] = balances[_from].minus(_value);
250         balances[_to] = balances[_to].plus(_value);
251 
252         emit Transfer(_from, _to, _value);
253     }
254 }
255 
256 // File: contracts/token/MintableToken.sol
257 
258 /**
259  * @title Mintable Token
260  *
261  * @dev Allows the creation of new tokens.
262  */
263 contract MintableToken is StandardToken {
264     /// @dev The only address allowed to mint coins
265     address public minter;
266 
267     /// @dev Indicates whether the token is still mintable.
268     bool public mintingDisabled = false;
269 
270     /**
271      * @dev Event fired when minting is no longer allowed.
272      */
273     event MintingDisabled();
274 
275     /**
276      * @dev Allows a function to be executed only if minting is still allowed.
277      */
278     modifier canMint() {
279         require(!mintingDisabled);
280         _;
281     }
282 
283     /**
284      * @dev Allows a function to be called only by the minter
285      */
286     modifier onlyMinter() {
287         require(msg.sender == minter);
288         _;
289     }
290 
291     /**
292      * @dev The constructor assigns the minter which is allowed to mind and disable minting
293      */
294     constructor(address _minter) internal {
295         minter = _minter;
296     }
297 
298     /**
299     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
300     *
301     * @param _to The address which will receive the freshly minted tokens.
302     * @param _value The number of tokens that will be created.
303     */
304     function mint(address _to, uint256 _value) public onlyMinter canMint {
305         totalSupply = totalSupply.plus(_value);
306         balances[_to] = balances[_to].plus(_value);
307 
308         emit Transfer(0x0, _to, _value);
309     }
310 
311     /**
312     * @dev Disable the minting of new tokens. Cannot be reversed.
313     *
314     * @return Whether or not the process was successful.
315     */
316     function disableMinting() public onlyMinter canMint {
317         mintingDisabled = true;
318        
319         emit MintingDisabled();
320     }
321 }
322 
323 // File: contracts/token/BurnableToken.sol
324 
325 /**
326  * @title Burnable Token
327  *
328  * @dev Allows tokens to be destroyed.
329  */
330 contract BurnableToken is StandardToken {
331     /**
332      * @dev Event fired when tokens are burned.
333      *
334      * @param _from The address from which tokens will be removed.
335      * @param _value The number of tokens to be destroyed.
336      */
337     event Burn(address indexed _from, uint256 _value);
338 
339     /**
340      * @dev Burnes `_value` number of tokens.
341      *
342      * @param _value The number of tokens that will be burned.
343      */
344     function burn(uint256 _value) public {
345         require(_value != 0);
346 
347         address burner = msg.sender;
348         require(_value <= balances[burner]);
349 
350         balances[burner] = balances[burner].minus(_value);
351         totalSupply = totalSupply.minus(_value);
352 
353         emit Burn(burner, _value);
354         emit Transfer(burner, address(0), _value);
355     }
356 }
357 
358 // File: contracts/trait/HasOwner.sol
359 
360 /**
361  * @title HasOwner
362  *
363  * @dev Allows for exclusive access to certain functionality.
364  */
365 contract HasOwner {
366     // The current owner.
367     address public owner;
368 
369     // Conditionally the new owner.
370     address public newOwner;
371 
372     /**
373      * @dev The constructor.
374      *
375      * @param _owner The address of the owner.
376      */
377     constructor(address _owner) public {
378         owner = _owner;
379     }
380 
381     /** 
382      * @dev Access control modifier that allows only the current owner to call the function.
383      */
384     modifier onlyOwner {
385         require(msg.sender == owner);
386         _;
387     }
388 
389     /**
390      * @dev The event is fired when the current owner is changed.
391      *
392      * @param _oldOwner The address of the previous owner.
393      * @param _newOwner The address of the new owner.
394      */
395     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
396 
397     /**
398      * @dev Transfering the ownership is a two-step process, as we prepare
399      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
400      * the transfer. This prevents accidental lock-out if something goes wrong
401      * when passing the `newOwner` address.
402      *
403      * @param _newOwner The address of the proposed new owner.
404      */
405     function transferOwnership(address _newOwner) public onlyOwner {
406         newOwner = _newOwner;
407     }
408  
409     /**
410      * @dev The `newOwner` finishes the ownership transfer process by accepting the
411      * ownership.
412      */
413     function acceptOwnership() public {
414         require(msg.sender == newOwner);
415 
416         emit OwnershipTransfer(owner, newOwner);
417 
418         owner = newOwner;
419     }
420 }
421 
422 // File: contracts/token/PausableToken.sol
423 
424 /**
425  * @title Pausable Token
426  *
427  * @dev Allows you to pause/unpause transfers of your token.
428  **/
429 contract PausableToken is StandardToken, HasOwner {
430 
431     /// Indicates whether the token contract is paused or not.
432     bool public paused = false;
433 
434     /**
435      * @dev Event fired when the token contracts gets paused.
436      */
437     event Pause();
438 
439     /**
440      * @dev Event fired when the token contracts gets unpaused.
441      */
442     event Unpause();
443 
444     /**
445      * @dev Allows a function to be called only when the token contract is not paused.
446      */
447     modifier whenNotPaused() {
448         require(!paused);
449         _;
450     }
451 
452     /**
453      * @dev Pauses the token contract.
454      */
455     function pause() public onlyOwner whenNotPaused {
456         paused = true;
457         emit Pause();
458     }
459 
460     /**
461      * @dev Unpauses the token contract.
462      */
463     function unpause() public onlyOwner {
464         require(paused);
465 
466         paused = false;
467         emit Unpause();
468     }
469 
470     /// Overrides of the standard token's functions to add the paused/unpaused functionality.
471 
472     function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
473         return super.transfer(_to, _value);
474     }
475 
476     function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
477         return super.approve(_spender, _value);
478     }
479 
480     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
481         return super.transferFrom(_from, _to, _value);
482     }
483 }
484 
485 // File: contracts/fundraiser/AbstractFundraiser.sol
486 
487 contract AbstractFundraiser {
488     /// The ERC20 token contract.
489     ERC20Token public token;
490 
491     /**
492      * @dev The event fires every time a new buyer enters the fundraiser.
493      *
494      * @param _address The address of the buyer.
495      * @param _ethers The number of ethers funded.
496      * @param _tokens The number of tokens purchased.
497      */
498     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
499 
500 
501     /**
502      * @dev The initialization method for the token
503      *
504      * @param _token The address of the token of the fundraiser
505      */
506     function initializeFundraiserToken(address _token) internal
507     {
508         token = ERC20Token(_token);
509     }
510 
511     /**
512      * @dev The default function which is executed when someone sends funds to this contract address.
513      */
514     function() public payable {
515         receiveFunds(msg.sender, msg.value);
516     }
517 
518     /**
519      * @dev this overridable function returns the current conversion rate for the fundraiser
520      */
521     function getConversionRate() public view returns (uint256);
522 
523     /**
524      * @dev checks whether the fundraiser passed `endTime`.
525      *
526      * @return whether the fundraiser has ended.
527      */
528     function hasEnded() public view returns (bool);
529 
530     /**
531      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
532      *
533      * @param _address The address of the receiver of tokens.
534      * @param _amount The amount of received funds in ether.
535      */
536     function receiveFunds(address _address, uint256 _amount) internal;
537     
538     /**
539      * @dev It throws an exception if the transaction does not meet the preconditions.
540      */
541     function validateTransaction() internal view;
542     
543     /**
544      * @dev this overridable function makes and handles tokens to buyers
545      */
546     function handleTokens(address _address, uint256 _tokens) internal;
547 
548     /**
549      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
550      */
551     function handleFunds(address _address, uint256 _ethers) internal;
552 
553 }
554 
555 // File: contracts/fundraiser/BasicFundraiser.sol
556 
557 /**
558  * @title Basic Fundraiser
559  *
560  * @dev An abstract contract that is a base for fundraisers. 
561  * It implements a generic procedure for handling received funds:
562  * 1. Validates the transaciton preconditions
563  * 2. Calculates the amount of tokens based on the conversion rate.
564  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
565  * 4. Delegate the handling of the funds
566  * 5. Emit event for received funds
567  */
568 contract BasicFundraiser is HasOwner, AbstractFundraiser {
569     using SafeMath for uint256;
570 
571     // The number of decimals for the token.
572     uint8 constant DECIMALS = 18;  // Enforced
573 
574     // Decimal factor for multiplication purposes.
575     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
576 
577     // The start time of the fundraiser - Unix timestamp.
578     uint256 public startTime;
579 
580     // The end time of the fundraiser - Unix timestamp.
581     uint256 public endTime;
582 
583     // The address where funds collected will be sent.
584     address public beneficiary;
585 
586     // The conversion rate with decimals difference adjustment,
587     // When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
588     uint256 public conversionRate;
589 
590     // The total amount of ether raised.
591     uint256 public totalRaised;
592 
593     /**
594      * @dev The event fires when the number of token conversion rate has changed.
595      *
596      * @param _conversionRate The new number of tokens per 1 ether.
597      */
598     event ConversionRateChanged(uint _conversionRate);
599 
600     /**
601      * @dev The basic fundraiser initialization method.
602      *
603      * @param _startTime The start time of the fundraiser - Unix timestamp.
604      * @param _endTime The end time of the fundraiser - Unix timestamp.
605      * @param _conversionRate The number of tokens create for 1 ETH funded.
606      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
607      */
608     function initializeBasicFundraiser(
609         uint256 _startTime,
610         uint256 _endTime,
611         uint256 _conversionRate,
612         address _beneficiary
613     )
614         internal
615     {
616         require(_endTime >= _startTime);
617         require(_conversionRate > 0);
618         require(_beneficiary != address(0));
619 
620         startTime = _startTime;
621         endTime = _endTime;
622         conversionRate = _conversionRate;
623         beneficiary = _beneficiary;
624     }
625 
626     /**
627      * @dev Sets the new conversion rate
628      *
629      * @param _conversionRate New conversion rate
630      */
631     function setConversionRate(uint256 _conversionRate) public onlyOwner {
632         require(_conversionRate > 0);
633 
634         conversionRate = _conversionRate;
635 
636         emit ConversionRateChanged(_conversionRate);
637     }
638 
639     /**
640      * @dev Sets The beneficiary of the fundraiser.
641      *
642      * @param _beneficiary The address of the beneficiary.
643      */
644     function setBeneficiary(address _beneficiary) public onlyOwner {
645         require(_beneficiary != address(0));
646 
647         beneficiary = _beneficiary;
648     }
649 
650     /**
651      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
652      *
653      * @param _address The address of the receiver of tokens.
654      * @param _amount The amount of received funds in ether.
655      */
656     function receiveFunds(address _address, uint256 _amount) internal {
657         validateTransaction();
658 
659         uint256 tokens = calculateTokens(_amount);
660         require(tokens > 0);
661 
662         totalRaised = totalRaised.plus(_amount);
663         handleTokens(_address, tokens);
664         handleFunds(_address, _amount);
665 
666         emit FundsReceived(_address, msg.value, tokens);
667     }
668 
669     /**
670      * @dev this overridable function returns the current conversion rate multiplied by the conversion rate factor
671      */
672     function getConversionRate() public view returns (uint256) {
673         return conversionRate;
674     }
675 
676     /**
677      * @dev this overridable function that calculates the tokens based on the ether amount
678      */
679     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
680         tokens = _amount.mul(getConversionRate());
681     }
682 
683     /**
684      * @dev It throws an exception if the transaction does not meet the preconditions.
685      */
686     function validateTransaction() internal view {
687         require(msg.value != 0);
688         require(now >= startTime && now < endTime);
689     }
690 
691     /**
692      * @dev checks whether the fundraiser passed `endtime`.
693      *
694      * @return whether the fundraiser is passed its deadline or not.
695      */
696     function hasEnded() public view returns (bool) {
697         return now >= endTime;
698     }
699 }
700 
701 // File: contracts/token/StandardMintableToken.sol
702 
703 contract StandardMintableToken is MintableToken {
704     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
705         StandardToken(_name, _symbol, _decimals)
706         MintableToken(_minter)
707         public
708     {
709     }
710 }
711 
712 // File: contracts/fundraiser/MintableTokenFundraiser.sol
713 
714 /**
715  * @title Fundraiser With Mintable Token
716  */
717 contract MintableTokenFundraiser is BasicFundraiser {
718     /**
719      * @dev The initialization method that creates a new mintable token.
720      *
721      * @param _name Token name
722      * @param _symbol Token symbol
723      * @param _decimals Token decimals
724      */
725     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
726         token = new StandardMintableToken(
727             address(this), // The fundraiser is the token minter
728             _name,
729             _symbol,
730             _decimals
731         );
732     }
733 
734     /**
735      * @dev Mint the specific amount tokens
736      */
737     function handleTokens(address _address, uint256 _tokens) internal {
738         MintableToken(token).mint(_address, _tokens);
739     }
740 }
741 
742 // File: contracts/fundraiser/IndividualCapsFundraiser.sol
743 
744 /**
745  * @title Fundraiser with individual caps
746  *
747  * @dev Allows you to set a hard cap on your fundraiser.
748  */
749 contract IndividualCapsFundraiser is BasicFundraiser {
750     uint256 public individualMinCap;
751     uint256 public individualMaxCap;
752     uint256 public individualMaxCapTokens;
753 
754 
755     event IndividualMinCapChanged(uint256 _individualMinCap);
756     event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);
757 
758     /**
759      * @dev The initialization method.
760      *
761      * @param _individualMinCap The minimum amount of ether contribution per address.
762      * @param _individualMaxCap The maximum amount of ether contribution per address.
763      */
764     function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {
765         individualMinCap = _individualMinCap;
766         individualMaxCap = _individualMaxCap;
767         individualMaxCapTokens = _individualMaxCap * conversionRate;
768     }
769 
770     function setConversionRate(uint256 _conversionRate) public onlyOwner {
771         super.setConversionRate(_conversionRate);
772 
773         if (individualMaxCap == 0) {
774             return;
775         }
776         
777         individualMaxCapTokens = individualMaxCap * _conversionRate;
778 
779         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
780     }
781 
782     function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {
783         individualMinCap = _individualMinCap;
784 
785         emit IndividualMinCapChanged(individualMinCap);
786     }
787 
788     function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {
789         individualMaxCap = _individualMaxCap;
790         individualMaxCapTokens = _individualMaxCap * conversionRate;
791 
792         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
793     }
794 
795     /**
796      * @dev Extends the transaction validation to check if the value this higher than the minumum cap.
797      */
798     function validateTransaction() internal view {
799         super.validateTransaction();
800         require(msg.value >= individualMinCap);
801     }
802 
803     /**
804      * @dev We validate the new amount doesn't surpass maximum contribution cap
805      */
806     function handleTokens(address _address, uint256 _tokens) internal {
807         require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);
808 
809         super.handleTokens(_address, _tokens);
810     }
811 }
812 
813 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
814 
815 /**
816  * @title GasPriceLimitFundraiser
817  *
818  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
819  */
820 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
821     uint256 public gasPriceLimit;
822 
823     event GasPriceLimitChanged(uint256 gasPriceLimit);
824 
825     /**
826      * @dev This function puts the initial gas limit
827      */
828     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
829         gasPriceLimit = _gasPriceLimit;
830     }
831 
832     /**
833      * @dev This function allows the owner to change the gas limit any time during the fundraiser
834      */
835     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
836         gasPriceLimit = _gasPriceLimit;
837 
838         emit GasPriceLimitChanged(_gasPriceLimit);
839     }
840 
841     /**
842      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
843      */
844     function validateTransaction() internal view {
845         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
846 
847         return super.validateTransaction();
848     }
849 }
850 
851 // File: contracts/fundraiser/ForwardFundsFundraiser.sol
852 
853 /**
854  * @title Forward Funds to Beneficiary Fundraiser
855  *
856  * @dev This contract forwards the funds received to the beneficiary.
857  */
858 contract ForwardFundsFundraiser is BasicFundraiser {
859     /**
860      * @dev Forward funds directly to beneficiary
861      */
862     function handleFunds(address, uint256 _ethers) internal {
863         // Forward the funds directly to the beneficiary
864         beneficiary.transfer(_ethers);
865     }
866 }
867 
868 // File: contracts/fundraiser/TieredFundraiser.sol
869 
870 /**
871  * @title TieredFundraiser
872  *
873  * @dev A fundraiser that improves the base conversion precision to allow percent bonuses
874  */
875 
876 contract TieredFundraiser is BasicFundraiser {
877     // Conversion rate factor for better precision.
878     uint256 constant CONVERSION_RATE_FACTOR = 100;
879 
880     /**
881       * @dev Define conversion rates based on the tier start and end date
882       */
883     function getConversionRate() public view returns (uint256) {
884         return super.getConversionRate().mul(CONVERSION_RATE_FACTOR);
885     }
886 
887     /**
888      * @dev this overridable function that calculates the tokens based on the ether amount
889      */
890     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
891         return super.calculateTokens(_amount).div(CONVERSION_RATE_FACTOR);
892     }
893 
894     /**
895      * @dev this overridable function returns the current conversion rate factor
896      */
897     function getConversionRateFactor() public pure returns (uint256) {
898         return CONVERSION_RATE_FACTOR;
899     }
900 }
901 
902 // File: contracts/Fundraiser.sol
903 
904 /**
905  * @title AdultXToken
906  */
907 
908 contract AdultXToken is MintableToken, BurnableToken, PausableToken {
909     constructor(address _owner, address _minter)
910         StandardToken(
911             "Adult X Token",   // Token name
912             "ADUX", // Token symbol
913             18  // Token decimals
914         )
915         HasOwner(_owner)
916         MintableToken(_minter)
917         public
918     {
919     }
920 }
921 
922 
923 
924 /**
925  * @title AdultXTokenSafe
926  */
927 
928 contract AdultXTokenSafe is TokenSafe {
929   constructor(address _token)
930     TokenSafe(_token)
931     public
932   {
933     
934     // Group "Airdrop"
935     init(
936       1, // Group Id
937       1543881540 // Release date = 2018-12-03 23:59 UTC
938     );
939     add(
940       1, // Group Id
941       0x1f98908f6857de3227fb735fACa75CCD5b9403c5,  // Token Safe Entry Address
942       50000000000000000000000000  // Allocated tokens
943     );
944     
945     // Group "Marketing"
946     init(
947       2, // Group Id
948       1543881540 // Release date = 2018-12-03 23:59 UTC
949     );
950     add(
951       2, // Group Id
952       0x1f98908f6857de3227fb735fACa75CCD5b9403c5,  // Token Safe Entry Address
953       100000000000000000000000000  // Allocated tokens
954     );
955     
956     // Group "Team and Partners"
957     init(
958       3, // Group Id
959       1543881540 // Release date = 2018-12-03 23:59 UTC
960     );
961     add(
962       3, // Group Id
963       0x1f98908f6857de3227fb735fACa75CCD5b9403c5,  // Token Safe Entry Address
964       50000000000000000000000000  // Allocated tokens
965     );
966   }
967 }
968 
969 
970 
971 /**
972  * @title AdultXTokenFundraiser
973  */
974 
975 contract AdultXTokenFundraiser is MintableTokenFundraiser, IndividualCapsFundraiser, ForwardFundsFundraiser, TieredFundraiser, GasPriceLimitFundraiser {
976     AdultXTokenSafe public tokenSafe;
977 
978     constructor()
979         HasOwner(msg.sender)
980         public
981     {
982         token = new AdultXToken(
983         msg.sender,  // Owner
984         address(this)  // The fundraiser is the minter
985         );
986 
987         tokenSafe = new AdultXTokenSafe(token);
988         MintableToken(token).mint(address(tokenSafe), 200000000000000000000000000);
989 
990         initializeBasicFundraiser(
991             1543795140, // Start date = 2018-12-02 23:59 UTC
992             1609459140,  // End date = 2020-12-31 23:59 UTC
993             6000, // Conversion rate = 6000 ADUX per 1 ether
994             0x1f98908f6857de3227fb735fACa75CCD5b9403c5     // Beneficiary
995         );
996 
997         initializeIndividualCapsFundraiser(
998             (0.1 ether), // Minimum contribution
999             (0 ether)  // Maximum individual cap
1000         );
1001 
1002         initializeGasPriceLimitFundraiser(
1003             0 // Gas price limit in wei
1004         );
1005 
1006         
1007 
1008         
1009 
1010         
1011 
1012         
1013     }
1014     
1015     /**
1016       * @dev Define conversion rates based on the tier start and end date
1017       */
1018     function getConversionRate() public view returns (uint256) {
1019         uint256 rate = super.getConversionRate();
1020         if (now >= 1543795140 && now < 1544918340)
1021             return rate.mul(125).div(100);
1022         
1023         if (now >= 1544918340 && now < 1546300740)
1024             return rate.mul(120).div(100);
1025         
1026         if (now >= 1546300740 && now < 1547855940)
1027             return rate.mul(110).div(100);
1028         
1029 
1030         return rate;
1031     }
1032 
1033     /**
1034       * @dev Fundraiser with mintable token allows the owner to mint through the Fundraiser contract
1035       */
1036     function mint(address _to, uint256 _value) public onlyOwner {
1037         MintableToken(token).mint(_to, _value);
1038     }
1039 
1040     /**
1041       * @dev Irreversibly disable minting
1042       */
1043     function disableMinting() public onlyOwner {
1044         MintableToken(token).disableMinting();
1045     }
1046     
1047 }