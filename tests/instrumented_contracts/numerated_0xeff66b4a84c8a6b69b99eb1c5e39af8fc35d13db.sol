1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Staking.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.14;\n\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/InitializableOwnable.sol\";\n\ncontract Staking is InitializableOwnable, IStaking {\n\n    /* ========== HELPER STRUCTURES ========== */\n\n    struct UserInfo {\n        uint amount;\n        uint rewardAccountedForHarvest;\n        uint availableHarvest;\n        uint lastHarvestTimestamp;\n    }\n\n    /* ========== CONSTANTS ========== */\n\n    IERC20 public immutable stakingToken;\n\n    string public name;\n    string public symbol;\n    uint public immutable harvestInterval;\n    uint8 public immutable decimals;\n\n    uint public constant calcDecimals = 1e14;\n    uint public constant secondsInYear = 31557600;\n    uint public constant aprDenominator = 10000;\n\n    /* ========== STATE VARIABLES ========== */\n\n    address public admin;\n    bool public paused;\n    bool public unstakePermitted;\n    uint public aprBasisPoints;\n\n    uint public amountStaked;\n    uint public accumulatedRewardPerShare;\n    uint public lastRewardTimestamp;\n\n    mapping(address => UserInfo) public userInfo;\n    mapping(address => mapping(address => uint)) public allowances;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        IERC20 token_,\n        string memory name_,\n        string memory symbol_,\n        uint aprBasisPoints_,\n        uint harvestInterval_\n    ) {\n        initOwner(msg.sender);\n        stakingToken = token_;\n        name = name_;\n        symbol = symbol_;\n        aprBasisPoints = aprBasisPoints_;\n        harvestInterval = harvestInterval_;\n        lastRewardTimestamp = block.timestamp;\n        decimals = IERC20Metadata(address(token_)).decimals();\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return amountStaked; \n    }\n\n    function currentRewardDelta() public view returns (uint) {\n        uint timeDelta = block.timestamp - lastRewardTimestamp;\n        return (timeDelta * aprBasisPoints * calcDecimals) / (aprDenominator * secondsInYear);\n    }\n\n    function calculateRewardForStake(uint amount) internal view returns (uint) {\n        return accumulatedRewardPerShare * amount / calcDecimals;\n    }\n\n    function balanceOf(address user_) external view returns(uint) {\n        UserInfo storage user = userInfo[user_];\n        uint updAccumulatedRewardPerShare = accumulatedRewardPerShare + currentRewardDelta();\n\n        uint virtualReward = \n            updAccumulatedRewardPerShare * user.amount / calcDecimals \n            - user.rewardAccountedForHarvest;\n        return user.amount + user.availableHarvest + virtualReward;\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return allowances[owner][spender];\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(\n        address spender, \n        uint amount\n    ) external whenNotPaused virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(\n        address sender_,\n        address recipient_,\n        uint amount\n    ) internal {\n        updateRewardPool();\n        require(sender_ != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient_ != address(0), \"ERC20: transfer to the zero address\");\n\n        UserInfo storage sender = userInfo[sender_];\n        UserInfo storage recipient = userInfo[recipient_];\n        require(amount <= sender.amount, \"ERC20: transfer amount exceeds balance\");\n\n        sender.availableHarvest += calculateRewardForStake(sender.amount) - sender.rewardAccountedForHarvest;\n        sender.amount -= amount; \n        sender.rewardAccountedForHarvest = calculateRewardForStake(sender.amount);\n\n        recipient.availableHarvest += calculateRewardForStake(recipient.amount) - recipient.rewardAccountedForHarvest;\n        recipient.amount += amount; \n        recipient.rewardAccountedForHarvest = calculateRewardForStake(recipient.amount);\n\n        emit Transfer(sender_, recipient_, amount);\n    }\n\n    function transfer(\n        address recipient, \n        uint256 amount\n    ) external whenNotPaused virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    } \n\n    function transferFrom(\n        address spender,\n        address recipient,\n        uint256 amount\n    ) external whenNotPaused virtual override returns (bool) {\n        _transfer(spender, recipient, amount);\n        uint256 currentAllowance = allowances[spender][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(spender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    function updateRewardPool() public canUnstake {\n        accumulatedRewardPerShare += currentRewardDelta();\n        lastRewardTimestamp = block.timestamp;\n    }\n\n    function stake(\n        uint amount, \n        address to\n    ) external whenNotPaused {\n        updateRewardPool();\n        require(amount > 0, \"Staking: Nothing to deposit\");\n        require(to != address(0));\n        require(stakingToken.transferFrom(msg.sender, address(this), amount), \"Staking: transfer failed\");\n\n        UserInfo storage user = userInfo[to];\n        user.availableHarvest += calculateRewardForStake(user.amount) - user.rewardAccountedForHarvest;\n        amountStaked += amount;\n        user.amount += amount;\n        user.rewardAccountedForHarvest = calculateRewardForStake(user.amount);\n        emit Transfer(address(0), to, amount);\n        emit Stake(to, amount);\n    }\n\n    function harvest(uint256 amount) external whenNotPaused {\n        updateRewardPool();\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.lastHarvestTimestamp + harvestInterval <= block.timestamp || \n            user.lastHarvestTimestamp == 0, \"Staking: less than 24 hours since last harvest\");\n        user.lastHarvestTimestamp = block.timestamp;\n        uint reward = calculateRewardForStake(user.amount);\n        user.availableHarvest += reward - user.rewardAccountedForHarvest;\n        user.rewardAccountedForHarvest = reward;\n\n        require(amount > 0, \"Staking: Nothing to harvest\");\n        require(amount <= user.availableHarvest, \"Staking: Insufficient to harvest\");\n        user.availableHarvest -= amount;\n        require(stakingToken.transfer(msg.sender, amount), \"Staking: transfer failed\");\n        emit Harvest(msg.sender, amount);\n    }\n\n    function unstake(\n        address to, \n        uint256 amount\n    ) external canUnstake {\n        updateRewardPool();\n        require(amount > 0, \"Staking: Nothing to unstake\");\n        require(to != address(0));\n\n        UserInfo storage user = userInfo[msg.sender];\n        require(amount <= user.amount, \"Staking: Insufficient share\");\n        user.availableHarvest += calculateRewardForStake(user.amount) - user.rewardAccountedForHarvest;\n        amountStaked -= amount;\n        user.amount -= amount;\n        user.rewardAccountedForHarvest = calculateRewardForStake(user.amount);\n\n        require(stakingToken.transfer(to, amount), \"Staking: Not enough token to transfer\");\n        emit Transfer(to, address(0), amount);\n        emit Unstake(to, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setApr(uint aprBasisPoints_) external onlyOwner {\n        updateRewardPool();\n        uint oldAprBasisPoints = aprBasisPoints;\n        aprBasisPoints = aprBasisPoints_;\n        emit SetApr(oldAprBasisPoints, aprBasisPoints);\n    }\n\n    function togglePause() external onlyOwner {\n        paused = !paused;\n        emit Pause(paused);\n    }\n\n    function toggleUnstake() external onlyOwner {\n        unstakePermitted = !unstakePermitted;\n        emit UnstakePermit(unstakePermitted);\n    }\n\n    function withdrawToken(\n        IERC20 tokenToWithdraw, \n        address to, \n        uint amount\n    ) external onlyOwner {\n        require(tokenToWithdraw.transfer(to, amount));\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier whenNotPaused() {\n        require(!paused, \"Staking: contract paused.\");\n        _;\n    }\n\n    modifier canUnstake() {\n        require(unstakePermitted || (!paused), \"Staking: contract paused or unstake denied.\");\n        _;\n    }\n}\n"
6     },
7     "contracts/interfaces/IStaking.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.14;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IStaking is IERC20, IERC20Metadata {\n\n     /* ========== CONSTANTS ========== */\n\n    function calcDecimals() external view returns (uint);\n\n    function secondsInYear() external view returns (uint);\n\n    function aprDenominator() external view returns (uint);\n\n    /* ========== STATE VARIABLES ========== */\n\n    function aprBasisPoints() external view returns (uint);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function updateRewardPool() external;\n\n    function stake(uint amount, address to) external;\n\n    function harvest(uint256 amount) external;\n\n    function unstake(address to, uint256 amount) external;\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setApr(uint _aprBasisPoints) external;\n\n    function togglePause() external;\n\n    function toggleUnstake() external;\n\n    function withdrawToken(IERC20 tokenToWithdraw, address to, uint amount) external;\n\n    /* ========== EVENTS ========== */\n\n    event Pause(bool indexed flag);\n    event UnstakePermit(bool indexed flag);\n    event SetApr(uint indexed oldBasisPoints, uint indexed newBasisPoints);\n    event Stake(address indexed user, uint indexed amount);\n    event Unstake(address indexed user, uint indexed amount);\n    event Harvest(address indexed user, uint indexed amount);\n}\n"
9     },
10     "contracts/interfaces/InitializableOwnable.sol": {
11       "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.8.14;\n\ncontract InitializableOwnable {\n\n    address public owner;\n    address public newOwner;\n\n    bool internal initialized;\n\n    // ============ Events ============\n\n    event OwnerTransferRequested(\n        address indexed oldOwner, \n        address indexed newOwner\n    );\n\n    event OwnershipTransferred(\n        address indexed oldOwner, \n        address indexed newOwner\n    );\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function initOwner(address _newOwner) public notInitialized {\n        initialized = true;\n        owner = _newOwner;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        emit OwnerTransferRequested(owner, _newOwner);\n        newOwner = _newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == newOwner, \"Claim from wrong address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier notInitialized() {\n        require(!initialized, \"Not initialized\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
15     },
16     "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 800
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}