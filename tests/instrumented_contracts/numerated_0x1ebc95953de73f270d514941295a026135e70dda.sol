1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/MFER/Create2Deployer.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\ninterface IERC721 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface INonfungiblePositionManager is IERC721 {\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    function collect(CollectParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n}\n\ninterface IHumanVerifier {\n    function humanVerified(address account) external view returns (bool);\n}\n\ncontract ERC20 is Context, IERC20, Ownable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bool private humanVerificationRequired = true;\n\n    address private UNISWAP_UNIVERSAL_ROUTER =\n        0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD;\n    address private UNISWAP_UNIVERSAL_ROUTER_OLD =\n        0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B;\n    address private UNISWAP_V3_ROUTER_2 =\n        0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n\n    IHumanVerifier private humanVerifier;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 supply,\n        address owner,\n        address humanVerifier_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        humanVerifier = IHumanVerifier(humanVerifier_);\n        _mint(owner, supply);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _verify(from, to);\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _verify(address from, address to) internal virtual {\n        if (\n            from != owner() &&\n            to != owner() &&\n            to != address(0) &&\n            to != address(0xdead)\n        ) {\n            if (\n                to != UNISWAP_UNIVERSAL_ROUTER &&\n                to != UNISWAP_UNIVERSAL_ROUTER_OLD &&\n                to != UNISWAP_V3_ROUTER_2\n            ) {\n                if (humanVerificationRequired) {\n                    require(\n                        humanVerifier.humanVerified(to) == true,\n                        \"Human not verified.\"\n                    );\n                }\n            }\n        }\n    }\n\n    function humanVerified(address account) external view returns (bool) {\n        return humanVerifier.humanVerified(account);\n    }\n\n    function setHumanVerifier(address account) public onlyOwner {\n        require(account != address(0), \"ERC20: account is zero address\");\n        humanVerifier = IHumanVerifier(account);\n    }\n\n    function setHumanVerificationRequired(bool onOff) public onlyOwner {\n        humanVerificationRequired = onOff;\n    }\n}\n\ncontract HumanVerifier is Ownable {\n    bool private verifyAllowed = false;\n\n    mapping(address => bool) private _humanVerified;\n\n    address private _signerAddress;\n    address private _uniswapV3Quoter;\n\n    string private _salt;\n\n    event HumanVerified(address signer);\n\n    constructor() {\n        _salt = \"MFER\";\n        _signerAddress = 0x361335Bbf5dC98363119d8a2bCdAeD05335cb8db;\n        _uniswapV3Quoter = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\n        _humanVerified[owner()] = true;\n        _humanVerified[_uniswapV3Quoter] = true;\n    }\n\n    function verifyHuman(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (bool) {\n        require(verifyAllowed, \"Verify is not allowed yet\");\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 hash = keccak256(\n            abi.encodePacked(address(this), _msgSender(), _salt)\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n        address recovered = ecrecover(prefixedHash, _v, _r, _s);\n\n        if (recovered == _signerAddress) {\n            _humanVerified[_msgSender()] = true;\n            emit HumanVerified(_msgSender());\n        } else {\n            revert(\"Human not verified.\");\n        }\n        return true;\n    }\n\n    function humanVerified(address account) external view returns (bool) {\n        return _humanVerified[account];\n    }\n\n    function allowVerify(bool allow) public onlyOwner {\n        verifyAllowed = allow;\n    }\n\n    function verify(address account, bool verified) public onlyOwner {\n        require(account != address(0), \"account cannot be 0\");\n        _humanVerified[account] = verified;\n    }\n\n    function setSignerAddress(address signerAddress) public onlyOwner {\n        require(signerAddress != address(0), \"_signerAddress cannot be 0\");\n        _signerAddress = signerAddress;\n    }\n\n    function setUniswapV3Quoter(address uniswapV3Quoter) public onlyOwner {\n        require(uniswapV3Quoter != address(0), \"_uniswapV3Quoter cannot be 0\");\n        _uniswapV3Quoter = uniswapV3Quoter;\n    }\n\n    function setSalt(string memory salt) public onlyOwner {\n        _salt = salt;\n    }\n}\n\ncontract MFERLPLocker {\n    address NONFUNGIBLE_POSITION_MANAGER =\n        0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n    INonfungiblePositionManager _positionManager;\n\n    address public feeCollector;\n\n    uint256 public lockUpDeadline;\n\n    bool public lpNFTLocked = false;\n    bool public withdrawTriggered = false;\n\n    modifier onlyFeeCollector() {\n        require(msg.sender == feeCollector);\n        _;\n    }\n\n    constructor(address owner) {\n        _positionManager = INonfungiblePositionManager(\n            NONFUNGIBLE_POSITION_MANAGER\n        );\n        feeCollector = owner;\n    }\n\n    function lockNFT(uint256 _tokenId) external onlyFeeCollector {\n        require(!lpNFTLocked, \"NFT is already locked\");\n\n        IERC721(NONFUNGIBLE_POSITION_MANAGER).transferFrom(\n            msg.sender,\n            address(this),\n            _tokenId\n        );\n\n        lpNFTLocked = true;\n    }\n\n    function triggerNFTWithdrawal() external onlyFeeCollector {\n        require(lpNFTLocked, \"NFT is not locked\");\n        require(lockUpDeadline == 0, \"Withdrawal has been already triggered\");\n        lockUpDeadline = block.timestamp + (90 days);\n        withdrawTriggered = true;\n    }\n\n    function cancelNFTWithdrawal() external onlyFeeCollector {\n        require(lpNFTLocked, \"NFT is not locked\");\n        require(lockUpDeadline != 0, \"Withdrawal has not been triggered\");\n\n        lockUpDeadline = 0;\n        withdrawTriggered = false;\n    }\n\n    function withdrawNFT(uint256 _tokenId) external onlyFeeCollector {\n        require(lpNFTLocked, \"NFT is not locked\");\n        require(lockUpDeadline != 0, \"Withdrawal  has not been triggered\");\n        require(\n            block.timestamp >= lockUpDeadline,\n            \"Lock-up period has not ended yet\"\n        );\n\n        IERC721(NONFUNGIBLE_POSITION_MANAGER).transferFrom(\n            address(this),\n            msg.sender,\n            _tokenId\n        );\n\n        lpNFTLocked = false;\n        lockUpDeadline = 0;\n        withdrawTriggered = false;\n    }\n\n    function collectLPFees(uint256 _tokenId) external onlyFeeCollector {\n        _positionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: feeCollector,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function changeFeeCollector(address account) external onlyFeeCollector {\n        require(account != address(0), \"Address 0\");\n        feeCollector = account;\n    }\n\n    function changeNFTPositionManager(address account)\n        external\n        onlyFeeCollector\n    {\n        require(account != address(0), \"Address 0\");\n        NONFUNGIBLE_POSITION_MANAGER = account;\n        _positionManager = INonfungiblePositionManager(account);\n    }\n}\n\ncontract Create2Deployer is Ownable {\n    event Deployed(address addr);\n\n    function deployToken(\n        uint256 _salt,\n        string memory name,\n        string memory symbol,\n        uint256 supply,\n        address owner,\n        address humanVerifier\n    ) public onlyOwner {\n        bytes32 salt = keccak256(abi.encodePacked(_salt, owner));\n        ERC20 _contract = new ERC20{salt: salt}(\n            name,\n            symbol,\n            supply,\n            owner,\n            humanVerifier\n        );\n\n        _contract.transferOwnership(owner);\n\n        emit Deployed(address(_contract));\n    }\n\n    function deployVerifier(uint256 _salt) public onlyOwner {\n        bytes32 salt = keccak256(abi.encodePacked(_salt, owner()));\n        HumanVerifier _contract = new HumanVerifier{salt: salt}();\n\n        _contract.transferOwnership(owner());\n\n        emit Deployed(address(_contract));\n    }\n\n    function deployLPLocker(uint256 _salt, address owner) public onlyOwner {\n        bytes32 salt = keccak256(abi.encodePacked(_salt, owner));\n        MFERLPLocker _contract = new MFERLPLocker{salt: salt}(owner);\n\n        emit Deployed(address(_contract));\n    }\n\n    function withdraw(address tkn) public onlyOwner {\n        bool success;\n        if (tkn == address(0))\n            (success, ) = address(msg.sender).call{\n                value: address(this).balance\n            }(\"\");\n        else {\n            require(IERC20(tkn).balanceOf(address(this)) > 0, \"No tokens\");\n            uint256 amount = IERC20(tkn).balanceOf(address(this));\n            IERC20(tkn).transfer(msg.sender, amount);\n        }\n    }\n}\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}