1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/LICENSE.sol": {
5       "content": "// Copyright (c) 2022-2023 Fellowship\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies\n// or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
6     },
7     "contracts/PPPArtworkAuction.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022-2023 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./Delegation.sol\";\nimport \"./EarlyAccessSale.sol\";\nimport \"./MintableById.sol\";\nimport \"./Shuffler.sol\";\n\nstruct AuctionStage {\n    /// @notice Amount that the price drops (in wei) every slot (every 12 seconds)\n    uint256 priceDropPerSlot;\n    /// @notice Price where this auction stage ends (in wei)\n    uint256 endPrice;\n    /// @notice The duration of time that this stage will last, in seconds\n    uint256 duration;\n}\n\nstruct AuctionStageConfiguration {\n    /// @notice Amount that the price drops (in wei) every slot (every 12 seconds)\n    uint256 priceDropPerSlot;\n    /// @notice Price where this auction stage ends (in wei)\n    uint256 endPrice;\n}\n\ncontract PPPArtworkAuction is EarlyAccessSale, Shuffler {\n    string private publicLimitRevertMessage;\n\n    /// @notice The number of mints available for each pass\n    uint256 public passLimit;\n\n    /// @notice The number of mints available without a pass (per address), after the early access period\n    uint256 public publicLimit;\n\n    /// @notice The total number of mints available until the auction is sold out\n    uint256 public mintLimit;\n\n    /// @notice ERC-721 contract whose tokens are minted by this auction\n    /// @dev Must implement MintableById and allow minting out of order\n    MintableById public tokenContract;\n\n    /// @notice Starting price for the Dutch auction (in wei)\n    uint256 public startPrice;\n\n    /// @notice Lowest price at which a token was minted (in wei)\n    uint256 public lowestPrice;\n\n    /// @notice Stages for this auction, in order\n    AuctionStage[] public auctionStages;\n\n    /// @notice Number of reserveTokens that have been minted\n    uint256 public reserveCount = 0;\n\n    /// @notice Number of tokens that have been minted per address\n    mapping(address => uint256) public mintCount;\n    /// @notice Total amount paid to mint per address\n    mapping(address => uint256) public mintPayment;\n\n    /// @notice Number of tokens that have been minted without a pass, per address\n    /// @dev May over count public mints on the final sale transaction, so not publicly exposed\n    mapping(address => uint256) private publicMintCount;\n\n    uint256 private previousPayment = 0;\n\n    /// @notice An event emitted upon purchases\n    event Purchase(address purchaser, uint256 mintId, uint256 tokenId, uint256 price, bool passMint);\n\n    /// @notice An event emitted when reserve tokens are minted\n    event Reservation(address recipient, uint256 quantity, uint256 totalReserved);\n\n    /// @notice An event emitted when a refund is sent to a minter\n    event Refund(address recipient, uint256 amount);\n\n    /// @notice An error returned when the auction has reached its `mintLimit`\n    error SoldOut();\n\n    error FailedWithdraw(uint256 amount, bytes data);\n\n    constructor(\n        MintableById tokenContract_,\n        uint256 startTime_,\n        uint256 startPrice_,\n        uint256 earlyPriceDrop,\n        uint256 transitionPrice,\n        uint256 latePriceDrop,\n        uint256 restPrice,\n        uint256 mintLimit_,\n        uint256 publicLimit_,\n        uint256 passLimit_,\n        uint256 earlyAccessDuration_\n    ) EarlyAccessSale(startTime_, earlyAccessDuration_) Shuffler(mintLimit_) {\n        // CHECKS inputs\n        require(address(tokenContract_) != address(0), \"Token contract must not be the zero address\");\n\n        require(restPrice > 1e15, \"Rest price too low: check that prices are in wei\");\n        require(startPrice_ >= transitionPrice, \"Start price must not be lower than transition price\");\n        require(transitionPrice >= restPrice, \"Transition price must not be lower than rest price\");\n\n        uint256 earlyPriceDifference;\n        uint256 latePriceDifference;\n        unchecked {\n            earlyPriceDifference = startPrice_ - transitionPrice;\n            latePriceDifference = transitionPrice - restPrice;\n        }\n        require(earlyPriceDrop * 25 <= earlyPriceDifference, \"Initial stage must last at least 5 minutes\");\n        require(latePriceDrop * 25 <= latePriceDifference, \"Final stage must last at least 5 minutes\");\n        require(earlyPriceDifference % earlyPriceDrop == 0, \"Transition price must be reachable by earlyPriceDrop\");\n        require(latePriceDifference % latePriceDrop == 0, \"Resting price must be reachable by latePriceDrop\");\n        require(\n            earlyPriceDrop * (5 * 60 * 12) >= earlyPriceDifference,\n            \"Initial stage must not last longer than 12 hours\"\n        );\n        require(latePriceDrop * (5 * 60 * 12) >= latePriceDifference, \"Final stage must not last longer than 12 hours\");\n\n        require(mintLimit_ >= 10, \"Mint limit too low\");\n        require(passLimit_ != 0, \"Pass limit must not be zero\");\n        require(publicLimit_ != 0, \"Public limit must not be zero\");\n        require(passLimit_ < mintLimit_, \"Pass limit must be lower than mint limit\");\n        require(publicLimit_ < mintLimit_, \"Public limit must be lower than mint limit\");\n\n        // EFFECTS\n        tokenContract = tokenContract_;\n        lowestPrice = startPrice = startPrice_;\n\n        unchecked {\n            AuctionStage storage earlyStage = auctionStages.push();\n            earlyStage.priceDropPerSlot = earlyPriceDrop;\n            earlyStage.endPrice = transitionPrice;\n            earlyStage.duration = (12 * earlyPriceDifference) / earlyPriceDrop;\n\n            AuctionStage storage lateStage = auctionStages.push();\n            lateStage.priceDropPerSlot = latePriceDrop;\n            lateStage.endPrice = restPrice;\n            lateStage.duration = (12 * latePriceDifference) / latePriceDrop;\n        }\n\n        mintLimit = mintLimit_;\n        passLimit = passLimit_;\n        publicLimit = publicLimit_;\n\n        publicLimitRevertMessage = publicLimit_ == 1\n            ? \"Limited to one purchase without a pass\"\n            : string.concat(\"Limited to \", Strings.toString(publicLimit_), \" purchases without a pass\");\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Mint a token on the `tokenContract` contract. Must include at least `currentPrice`.\n    function mint() external payable publicMint {\n        // CHECKS\n        require(publicMintCount[msg.sender] < publicLimit, publicLimitRevertMessage);\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: publicMintCount cannot exceed publicLimit\n            publicMintCount[msg.sender]++;\n        }\n\n        // Proceed to core mint logic (including all CHECKS + EFFECTS + INTERACTIONS)\n        _mint(false);\n    }\n\n    /// @notice Mint multiple tokens on the `tokenContract` contract. Must pay at least `currentPrice` * `quantity`.\n    /// @param quantity The number of tokens to mint: must not be greater than `publicLimit`\n    function mintMultiple(uint256 quantity) public payable virtual publicMint whenNotPaused {\n        // CHECKS state and inputs\n        uint256 remaining = remainingValueCount;\n        if (remaining == 0) revert SoldOut();\n        uint256 alreadyMinted = mintCount[msg.sender];\n        require(quantity > 0, \"Must mint at least one token\");\n\n        uint256 publicMinted = publicMintCount[msg.sender];\n        require(publicMinted < publicLimit && quantity <= publicLimit, publicLimitRevertMessage);\n\n        uint256 price = msg.value / quantity;\n        uint256 slotPrice = currentPrice();\n        require(price >= slotPrice, \"Insufficient payment\");\n\n        // EFFECTS\n        if (quantity > remaining) {\n            quantity = remaining;\n        }\n\n        unchecked {\n            if (publicMinted + quantity > publicLimit) {\n                quantity = publicLimit - publicMinted;\n            }\n\n            // Unchecked arithmetic: mintCount cannot exceed mintLimit\n            mintCount[msg.sender] = alreadyMinted + quantity;\n            // Unchecked arithmetic: publicMintCount cannot exceed publicLimit\n            publicMintCount[msg.sender] += quantity;\n            // Unchecked arithmetic: can't exceed total existing wei; not expected to exceed mintLimit * startPrice\n            mintPayment[msg.sender] += msg.value;\n        }\n\n        if (slotPrice < lowestPrice) {\n            lowestPrice = slotPrice;\n        }\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        unchecked {\n            uint256 startMintId = mintLimit - remainingValueCount;\n            for (uint256 i = 0; i < quantity; i++) {\n                uint256 tokenId = drawNext();\n                emit Purchase(msg.sender, startMintId + i, tokenId, price, false);\n                tokenContract.mint(msg.sender, tokenId);\n            }\n        }\n    }\n\n    /// @notice Send any available refund to the message sender\n    function refund() external returns (uint256) {\n        // CHECK available refund\n        uint256 refundAmount = refundAvailable(msg.sender);\n        require(refundAmount > 0, \"No refund available\");\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: refundAmount will always be less than mintPayment\n            mintPayment[msg.sender] -= refundAmount;\n        }\n\n        emit Refund(msg.sender, refundAmount);\n\n        // INTERACTIONS\n        (bool refunded, ) = msg.sender.call{value: refundAmount}(\"\");\n        require(refunded, \"Refund transfer was reverted\");\n\n        return refundAmount;\n    }\n\n    // PASS HOLDER FUNCTIONS\n\n    /// @notice Mint a token on the `tokenContract` to the caller, using a pass\n    /// @param passId The pass token ID: caller must be owner or operator and pass must have at least one mint remaining\n    function mintFromPass(uint256 passId) external payable started {\n        // CHECKS that the caller has permissions and the pass can be used\n        require(passAllowance(passId) > 0, \"No mints remaining for provided pass\");\n\n        // INTERACTIONS: mark the pass as used (known contract with no external interactions)\n        passes.logPassUse(passId, passProjectId);\n\n        // Proceed to core mint logic (including all CHECKS + EFFECTS + INTERACTIONS)\n        _mint(true);\n    }\n\n    /// @notice Mint multiple tokens on the `tokenContract` to the caller, using passes\n    /// @param passIds The pass token IDs: caller must be owner or operator and passes must have mints remaining\n    function mintMultipleFromPasses(\n        uint256 quantity,\n        uint256[] calldata passIds\n    ) external payable started whenNotPaused {\n        // CHECKS state and inputs\n        uint256 remaining = remainingValueCount;\n        if (remaining == 0) revert SoldOut();\n        require(quantity > 0, \"Must mint at least one token\");\n        require(quantity <= mintLimit, \"Quantity exceeds auction size\");\n\n        uint256 price = msg.value / quantity;\n        uint256 slotPrice = currentPrice();\n        require(price >= slotPrice, \"Insufficient payment\");\n\n        uint256 passCount = passIds.length;\n        require(passCount > 0, \"Must include at least one pass\");\n\n        // EFFECTS\n        if (quantity > remaining) {\n            quantity = remaining;\n        }\n\n        // CHECKS: check passes and log their usages\n        uint256 passUses = 0;\n        for (uint256 i = 0; i < passCount; i++) {\n            uint256 passId = passIds[i];\n\n            // CHECKS\n            uint256 allowance = passAllowance(passId);\n\n            // INTERACTIONS\n            for (uint256 j = 0; j < allowance && passUses < quantity; j++) {\n                passes.logPassUse(passId, passProjectId);\n                passUses++;\n            }\n\n            // Don't check more passes than needed\n            if (passUses == quantity) break;\n        }\n\n        require(passUses > 0, \"No mints remaining for provided passes\");\n        quantity = passUses;\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: mintCount cannot exceed passLimit * number of existing passes\n            mintCount[msg.sender] += quantity;\n            // Unchecked arithmetic: can't exceed total existing wei; not expected to exceed mintLimit * startPrice\n            mintPayment[msg.sender] += msg.value;\n        }\n\n        if (slotPrice < lowestPrice) {\n            lowestPrice = slotPrice;\n        }\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        unchecked {\n            uint256 startMintId = mintLimit - remainingValueCount;\n            for (uint256 i = 0; i < quantity; i++) {\n                uint256 tokenId = drawNext();\n                emit Purchase(msg.sender, startMintId + i, tokenId, price, true);\n                tokenContract.mint(msg.sender, tokenId);\n            }\n        }\n    }\n\n    // OWNER FUNCTIONS\n\n    /// @notice Mint reserve tokens to the designated `recipient`\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function reserve(address recipient, uint256 quantity) external unstarted onlyOwner {\n        // CHECKS contract state\n        uint256 remaining = remainingValueCount;\n        if (remaining == 0) revert SoldOut();\n\n        // EFFECTS\n        if (quantity > remaining) {\n            quantity = remaining;\n        }\n\n        unchecked {\n            // Unchecked arithmetic: neither value can exceed mintLimit\n            reserveCount += quantity;\n        }\n\n        emit Reservation(recipient, quantity, reserveCount);\n\n        // INTERACTIONS\n        unchecked {\n            for (uint256 i = 0; i < quantity; i++) {\n                tokenContract.mint(recipient, drawNext());\n            }\n        }\n    }\n\n    /// @notice withdraw auction proceeds\n    /// @dev Can only be called by the contract `owner`. Reverts if the final price is unknown, if proceeds have already\n    ///  been withdrawn, or if the fund transfer fails.\n    function withdraw(address recipient) external onlyOwner {\n        // CHECKS contract state\n        uint256 remaining = remainingValueCount;\n        bool soldOut = remaining == 0;\n        uint256 finalPrice = lowestPrice;\n        if (!soldOut) {\n            finalPrice = auctionStages[auctionStages.length - 1].endPrice;\n\n            // Only allow a withdraw before the auction is sold out if the price has finished falling\n            require(currentPrice() == finalPrice, \"Price is still falling\");\n        }\n\n        uint256 totalPayment = (mintLimit - remaining - reserveCount) * finalPrice;\n        require(totalPayment > previousPayment, \"All funds have been withdrawn\");\n\n        // EFFECTS\n        uint256 outstandingPayment = totalPayment - previousPayment;\n        uint256 balance = address(this).balance;\n        if (outstandingPayment > balance) {\n            // Escape hatch to prevent stuck funds, but this shouldn't happen\n            require(balance > 0, \"All funds have been withdrawn\");\n            outstandingPayment = balance;\n        }\n\n        previousPayment += outstandingPayment;\n        (bool success, bytes memory data) = recipient.call{value: outstandingPayment}(\"\");\n        if (!success) revert FailedWithdraw(outstandingPayment, data);\n    }\n\n    /// @notice Update the tokenContract contract address\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setMintable(MintableById tokenContract_) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(address(tokenContract_) != address(0), \"Token contract must not be the zero address\");\n        // EFFECTS\n        tokenContract = tokenContract_;\n    }\n\n    /// @notice Update the auction price ranges and rates of decrease\n    /// @dev Since the values are validated against each other, they are all set together. Can only be called by the\n    ///  contract `owner`. Reverts if the auction has already started.\n    function setPricing(\n        uint256 startPrice_,\n        AuctionStageConfiguration[] calldata stages_\n    ) external unstarted onlyOwner {\n        // CHECKS inputs\n        uint256 stageCount = stages_.length;\n        require(stageCount > 0, \"Must specify at least one auction stage\");\n\n        // EFFECTS + additional CHECKS\n        uint256 previousPrice = startPrice = startPrice_;\n        delete auctionStages;\n\n        for (uint256 i; i < stageCount; i++) {\n            AuctionStageConfiguration calldata config = stages_[i];\n            require(config.endPrice < previousPrice, \"Each stage price must be lower than the previous price\");\n            require(config.endPrice > 1e15, \"Stage price too low: check that prices are in wei\");\n\n            uint256 priceDifference = previousPrice - config.endPrice;\n            require(config.priceDropPerSlot * 25 <= priceDifference, \"Each stage must last at least 5 minutes\");\n            require(\n                priceDifference % config.priceDropPerSlot == 0,\n                \"Stage end price must be reachable by slot price drop\"\n            );\n            require(\n                config.priceDropPerSlot * (5 * 60 * 12) >= priceDifference,\n                \"Stage must not last longer than 12 hours\"\n            );\n\n            AuctionStage storage newStage = auctionStages.push();\n            newStage.duration = (12 * priceDifference) / config.priceDropPerSlot;\n            newStage.priceDropPerSlot = config.priceDropPerSlot;\n            newStage.endPrice = previousPrice = config.endPrice;\n        }\n    }\n\n    /// @notice Update the number of total mints\n    function setMintLimit(uint256 mintLimit_) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(reserveCount == 0, 'Cannot change the mint limit once tokens have been reserved');\n        require(mintLimit_ >= 10, \"Mint limit too low\");\n        require(passLimit < mintLimit_, \"Mint limit must be higher than pass limit\");\n        require(publicLimit < mintLimit_, \"Mint limit must be higher than public limit\");\n\n        // EFFECTS\n        mintLimit = remainingValueCount = mintLimit_;\n    }\n\n    /// @notice Update the per-pass mint limit\n    function setPassLimit(uint256 passLimit_) external onlyOwner {\n        // CHECKS inputs\n        require(passLimit_ != 0, \"Pass limit must not be zero\");\n        require(passLimit_ < mintLimit, \"Pass limit must be lower than mint limit\");\n\n        // EFFECTS\n        passLimit = passLimit_;\n    }\n\n    /// @notice Update the public per-wallet mint limit\n    function setPublicLimit(uint256 publicLimit_) external onlyOwner {\n        // CHECKS inputs\n        require(publicLimit_ != 0, \"Public limit must not be zero\");\n        require(publicLimit_ < mintLimit, \"Public limit must be lower than mint limit\");\n\n        // EFFECTS\n        publicLimit = publicLimit_;\n        publicLimitRevertMessage = publicLimit_ == 1\n            ? \"Limited to one purchase without a pass\"\n            : string.concat(\"Limited to \", Strings.toString(publicLimit_), \" purchases without a pass\");\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @notice Query the current price\n    function currentPrice() public view returns (uint256 price) {\n        uint256 time = timeElapsed();\n\n        price = startPrice;\n        uint256 stageCount = auctionStages.length;\n        uint256 stageDuration;\n        AuctionStage storage stage;\n        for (uint256 i = 0; i < stageCount; i++) {\n            stage = auctionStages[i];\n            stageDuration = stage.duration;\n            if (time < stageDuration) {\n                unchecked {\n                    uint256 drop = stage.priceDropPerSlot * (time / 12);\n                    return price - drop;\n                }\n            }\n\n            // Proceed to the next stage\n            unchecked {\n                time -= stageDuration;\n            }\n            price = auctionStages[i].endPrice;\n        }\n\n        // Auction has reached resting price\n        return price;\n    }\n\n    /// @notice Query the refund available for the specified `minter`\n    function refundAvailable(address minter) public view returns (uint256) {\n        uint256 minted = mintCount[minter];\n        if (minted == 0) return 0;\n\n        uint256 refundPrice = remainingValueCount == 0 ? lowestPrice : currentPrice();\n\n        uint256 payment = mintPayment[minter];\n        uint256 newPayment;\n        uint256 refundAmount;\n        unchecked {\n            // Unchecked arithmetic: newPayment cannot exceed mintLimit * startPrice\n            newPayment = minted * refundPrice;\n            // Unchecked arithmetic: value only used if newPayment < payment\n            refundAmount = payment - newPayment;\n        }\n\n        return (newPayment < payment) ? refundAmount : 0;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function _mint(bool passMint) internal whenNotPaused {\n        // CHECKS state and inputs\n        uint256 remaining = remainingValueCount;\n        if (remaining == 0) revert SoldOut();\n        uint256 slotPrice = currentPrice();\n        require(msg.value >= slotPrice, \"Insufficient payment\");\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: mintCount cannot exceed mintLimit\n            mintCount[msg.sender]++;\n            // Unchecked arithmetic: can't exceed this.balance; not expected to exceed mintLimit * startPrice\n            mintPayment[msg.sender] += msg.value;\n        }\n\n        if (slotPrice < lowestPrice) {\n            lowestPrice = slotPrice;\n        }\n\n        uint256 mintId = mintLimit - remainingValueCount;\n        uint256 tokenId = drawNext();\n        emit Purchase(msg.sender, mintId, tokenId, msg.value, passMint);\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        tokenContract.mint(msg.sender, tokenId);\n    }\n\n    // INTERNAL VIEW FUNCTIONS\n\n    function passAllowance(uint256 passId) internal view returns (uint256) {\n        // Uses view functions of the passes contract\n        require(Delegation.check(msg.sender, passes, passId), \"Caller is not pass owner or approved\");\n\n        uint256 uses = passes.passUses(passId, passProjectId);\n        unchecked {\n            return uses >= passLimit ? 0 : passLimit - uses;\n        }\n    }\n}\n"
9     },
10     "contracts/Delegation.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2023 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IDelegationRegistry {\n    function checkDelegateForToken(\n        address delegate,\n        address vault,\n        address contract_,\n        uint256 tokenId\n    ) external view returns (bool);\n}\n\nlibrary Delegation {\n    IDelegationRegistry public constant DELEGATION_REGISTRY =\n        IDelegationRegistry(0x00000000000076A84feF008CDAbe6409d2FE638B);\n\n    function check(address operator, IERC721 contract_, uint256 tokenId) internal view returns (bool) {\n        address owner = contract_.ownerOf(tokenId);\n        return (operator == owner ||\n            contract_.isApprovedForAll(owner, operator) ||\n            contract_.getApproved(tokenId) == operator ||\n            (address(DELEGATION_REGISTRY).code.length > 0 &&\n                DELEGATION_REGISTRY.checkDelegateForToken(operator, owner, address(contract_), tokenId)));\n    }\n}\n"
12     },
13     "contracts/EarlyAccessSale.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 - 2023 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nabstract contract PatronPass is IERC721 {\n    function logPassUse(uint256 tokenId, uint256 projectId) external virtual;\n\n    function passUses(uint256 tokenId, uint256 projectId) external view virtual returns (uint256);\n\n    function projectInfo(uint256 projectId) external view virtual returns (address, address, string memory);\n}\n\ncontract EarlyAccessSale is Ownable {\n    /// @notice Timestamp when this auction starts allowing minting\n    uint256 public startTime;\n\n    /// @notice Duration of the early access period where minting is limited to pass holders\n    uint256 public earlyAccessDuration;\n\n    /// @notice The contract that is used to gate minting during the early access period\n    PatronPass public passes;\n\n    /// @notice The project id for this auction in `passes`\n    uint256 internal passProjectId;\n\n    /// @notice Whether or not this contract is paused\n    /// @dev The exact meaning of \"paused\" will vary by contract, but in general paused contracts should prevent most\n    ///  interactions from non-owners\n    bool public isPaused = false;\n    uint256 private pauseStart;\n    uint256 internal pastPauseDelay;\n\n    event Paused();\n    event Unpaused();\n\n    /// @notice An error returned when the auction has already started\n    error AlreadyStarted();\n    /// @notice An error returned when the auction has not yet started\n    error NotYetStarted();\n\n    /// @notice An error returned when minting during early access without a pass\n    error EarlyAccessWithoutPass();\n\n    error ContractIsPaused();\n    error ContractNotPaused();\n\n    constructor(uint256 startTime_, uint256 earlyAccessDuration_) {\n        // CHECKS inputs\n        require(startTime_ >= block.timestamp, \"Start time cannot be in the past\");\n        require(earlyAccessDuration_ >= 60 * 5, \"Early access must last at least 5 minutes\");\n        require(earlyAccessDuration_ <= 60 * 60 * 24, \"Early access must not last longer than 24 hours\");\n\n        // EFFECTS\n        startTime = startTime_;\n        earlyAccessDuration = earlyAccessDuration_;\n    }\n\n    modifier started() {\n        if (!isStarted()) revert NotYetStarted();\n        _;\n    }\n    modifier unstarted() {\n        if (isStarted()) revert AlreadyStarted();\n        _;\n    }\n\n    modifier publicMint() {\n        if (!isPublic()) revert EarlyAccessWithoutPass();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!isPaused) revert ContractNotPaused();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (isPaused) revert ContractIsPaused();\n        _;\n    }\n\n    // OWNER FUNCTIONS\n\n    /// @notice Pause this contract\n    /// @dev Can only be called by the contract `owner`\n    function pause() public virtual whenNotPaused onlyOwner {\n        // EFFECTS (checks already handled by modifiers)\n        isPaused = true;\n        pauseStart = block.timestamp;\n        emit Paused();\n    }\n\n    /// @notice Resume this contract\n    /// @dev Can only be called by the contract `owner`\n    function unpause() public virtual whenPaused onlyOwner {\n        // EFFECTS (checks already handled by modifiers)\n        isPaused = false;\n        emit Unpaused();\n\n        // See if pastPauseDelay needs updated\n        if (block.timestamp <= startTime) {\n            return;\n        }\n        // Find the amount time the auction should have been live, but was paused\n        unchecked {\n            // Unchecked arithmetic: computed value will be < block.timestamp and >= 0\n            if (pauseStart < startTime) {\n                pastPauseDelay = block.timestamp - startTime;\n            } else {\n                pastPauseDelay += (block.timestamp - pauseStart);\n            }\n        }\n    }\n\n    /// @notice Update the auction start time\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setStartTime(uint256 startTime_) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(startTime_ >= block.timestamp, \"New start time cannot be in the past\");\n        // EFFECTS\n        startTime = startTime_;\n    }\n\n    /// @notice Update the duration of the early access period\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setEarlyAccessDuration(uint256 duration) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(duration >= 60 * 5, \"Early access must last at least 5 minutes\");\n        require(duration <= 60 * 60 * 24, \"Early access must not last longer than 24 hours\");\n\n        // EFFECTS\n        earlyAccessDuration = duration;\n    }\n\n    /// @notice Update the pass contract for the early access period\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setPassContract(PatronPass passContract, uint256 projectId) external unstarted onlyOwner {\n        // CHECKS inputs\n        (address projectMinter, , ) = passContract.projectInfo(projectId);\n        require(projectMinter == address(this), \"Specified pass project is not configured for this auction\");\n\n        // EFFECTS\n        passes = passContract;\n        passProjectId = projectId;\n\n        if (isStarted()) {\n            // If setting the contract started the auction, then we need to pretend we were paused up to this point\n            unchecked {\n                // Unchecked arithmetic: startTime <= block.timestamp because the auction has started\n                pastPauseDelay = block.timestamp - startTime;\n            }\n        }\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @notice Query if the early access period has ended\n    function isPublic() public view returns (bool) {\n        return isStarted() && block.timestamp >= (startTime + pastPauseDelay + earlyAccessDuration);\n    }\n\n    /// @notice Query if this contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @return `true` if `interfaceID` is implemented and is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x7f5828d0 || // ERC-173 Contract Ownership Standard\n            interfaceId == 0x01ffc9a7; // ERC-165 Standard Interface Detection\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function isStarted() internal view virtual returns (bool) {\n        return address(passes) != address(0) && (isPaused ? pauseStart : block.timestamp) >= startTime;\n    }\n\n    function timeElapsed() internal view returns (uint256) {\n        if (!isStarted()) return 0;\n        unchecked {\n            // pastPauseDelay cannot be greater than the time passed since startTime\n            if (!isPaused) {\n                return block.timestamp - startTime - pastPauseDelay;\n            }\n\n            // pastPauseDelay cannot be greater than the time between startTime and pauseStart\n            return pauseStart - startTime - pastPauseDelay;\n        }\n    }\n}\n"
15     },
16     "contracts/MintableById.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2023 Fellowship\n\npragma solidity ^0.8.7;\n\nabstract contract MintableById {\n    function mint(address to, uint256 tokenId) external virtual;\n}\n"
18     },
19     "contracts/Shuffler.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2023 Fellowship\n\npragma solidity ^0.8.7;\n\n/// @notice A contract that draws (without replacement) pseudorandom shuffled values\n/// @dev Uses prevrandao and Fisher-Yates shuffle to return values one at a time\ncontract Shuffler {\n    uint256 internal remainingValueCount;\n    /// @notice Mapping that lets `drawNext` find values that are still available\n    /// @dev This is effectively the Fisher-Yates in-place array. Zero values stand in for their key to avoid costly\n    ///  initialization. All other values are off-by-one so that zero can be represented. Keys from remainingValueCount\n    ///  onward have their values set back to zero since they aren't needed once they've been drawn.\n    mapping(uint256 => uint256) private shuffleValues;\n\n    constructor(uint256 shuffleSize) {\n        // CHECKS\n        require(shuffleSize <= type(uint16).max, \"Shuffle size is too large\");\n\n        // EFFECTS\n        remainingValueCount = shuffleSize;\n    }\n\n    function drawNext() internal returns (uint256) {\n        // CHECKS\n        require(remainingValueCount > 0, \"Shuffled values have been exhausted\");\n\n        // EFFECTS\n        uint256 swapValue;\n        unchecked {\n            // Unchecked arithmetic: remainingValueCount is nonzero\n            swapValue = shuffleValues[remainingValueCount - 1];\n        }\n        if (swapValue == 0) {\n            swapValue = remainingValueCount;\n        } else {\n            shuffleValues[remainingValueCount - 1] = 0;\n        }\n\n        if (remainingValueCount == 1) {\n            // swapValue is the last value left; just return it\n            remainingValueCount = 0;\n            unchecked {\n                return swapValue - 1;\n            }\n        }\n\n        uint256 randomIndex = uint256(keccak256(abi.encodePacked(remainingValueCount, block.difficulty))) %\n            remainingValueCount;\n        unchecked {\n            // Unchecked arithmetic: remainingValueCount is nonzero\n            remainingValueCount--;\n            // Check if swapValue was drawn\n            // Unchecked arithmetic: swapValue is nonzero\n            if (randomIndex == remainingValueCount) return swapValue - 1;\n        }\n\n        // Draw the value at randomIndex and put swapValue in its place\n        uint256 drawnValue = shuffleValues[randomIndex];\n        shuffleValues[randomIndex] = swapValue;\n\n        unchecked {\n            // Unchecked arithmetic: only subtract if drawnValue is nonzero\n            return drawnValue > 0 ? drawnValue - 1 : randomIndex;\n        }\n    }\n}\n"
21     },
22     "contracts/OPENZEPPELIN_LICENSE.sol": {
23       "content": "// OpenZeppelin Contracts\n//\n// Copyright (c) 2016-2023 zOS Global Limited and contributors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
24     },
25     "@openzeppelin/contracts/access/Ownable.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
30     },
31     "@openzeppelin/contracts/utils/Context.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
33     },
34     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
36     },
37     "@openzeppelin/contracts/utils/math/Math.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
39     },
40     "@openzeppelin/contracts/utils/Strings.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
42     }
43   },
44   "settings": {
45     "optimizer": {
46       "enabled": true,
47       "runs": 200
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "abi"
55         ]
56       }
57     }
58   }
59 }}