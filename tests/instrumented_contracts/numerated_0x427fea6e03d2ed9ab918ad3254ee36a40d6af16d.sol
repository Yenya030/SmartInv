1 pragma solidity ^0.4.21;
2 
3 // Generated by TokenGen and the Fabric Token platform.
4 // https://tokengen.io
5 // https://fabrictoken.io
6 
7 // File: contracts/library/SafeMath.sol
8 
9 /**
10  * @title Safe Math
11  *
12  * @dev Library for safe mathematical operations.
13  */
14 library SafeMath {
15     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
16         uint256 c = a * b;
17         assert(a == 0 || c / a == b);
18 
19         return c;
20     }
21 
22     function div(uint256 a, uint256 b) internal pure returns (uint256) {
23         uint256 c = a / b;
24 
25         return c;
26     }
27 
28     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
29         assert(b <= a);
30 
31         return a - b;
32     }
33 
34     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
35         uint256 c = a + b;
36         assert(c >= a);
37 
38         return c;
39     }
40 }
41 
42 // File: contracts/token/ERC20Token.sol
43 
44 /**
45  * @dev The standard ERC20 Token contract base.
46  */
47 contract ERC20Token {
48     uint256 public totalSupply;  /* shorthand for public function and a property */
49     
50     function balanceOf(address _owner) public view returns (uint256 balance);
51     function transfer(address _to, uint256 _value) public returns (bool success);
52     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
53     function approve(address _spender, uint256 _value) public returns (bool success);
54     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
55 
56     event Transfer(address indexed _from, address indexed _to, uint256 _value);
57     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
58 }
59 
60 // File: contracts/component/TokenSafe.sol
61 
62 /**
63  * @title TokenSafe
64  *
65  * @dev Abstract contract that serves as a base for the token safes. It is a multi-group token safe, where each group
66  *      has it's own release time and multiple accounts with locked tokens.
67  */
68 contract TokenSafe {
69     using SafeMath for uint;
70 
71     // The ERC20 token contract.
72     ERC20Token token;
73 
74     struct Group {
75         // The release date for the locked tokens
76         // Note: Unix timestamp fits in uint32, however block.timestamp is uint256
77         uint256 releaseTimestamp;
78         // The total remaining tokens in the group.
79         uint256 remaining;
80         // The individual account token balances in the group.
81         mapping (address => uint) balances;
82     }
83 
84     // The groups of locked tokens
85     mapping (uint8 => Group) public groups;
86 
87     /**
88      * @dev The constructor.
89      *
90      * @param _token The address of the Fabric Token (fundraiser) contract.
91      */
92     constructor(address _token) public {
93         token = ERC20Token(_token);
94     }
95 
96     /**
97      * @dev The function initializes a group with a release date.
98      *
99      * @param _id Group identifying number.
100      * @param _releaseTimestamp Unix timestamp of the time after which the tokens can be released
101      */
102     function init(uint8 _id, uint _releaseTimestamp) internal {
103         require(_releaseTimestamp > 0);
104         
105         Group storage group = groups[_id];
106         group.releaseTimestamp = _releaseTimestamp;
107     }
108 
109     /**
110      * @dev Add new account with locked token balance to the specified group id.
111      *
112      * @param _id Group identifying number.
113      * @param _account The address of the account to be added.
114      * @param _balance The number of tokens to be locked.
115      */
116     function add(uint8 _id, address _account, uint _balance) internal {
117         Group storage group = groups[_id];
118         group.balances[_account] = group.balances[_account].plus(_balance);
119         group.remaining = group.remaining.plus(_balance);
120     }
121 
122     /**
123      * @dev Allows an account to be released if it meets the time constraints of the group.
124      *
125      * @param _id Group identifying number.
126      * @param _account The address of the account to be released.
127      */
128     function release(uint8 _id, address _account) public {
129         Group storage group = groups[_id];
130         require(now >= group.releaseTimestamp);
131         
132         uint tokens = group.balances[_account];
133         require(tokens > 0);
134         
135         group.balances[_account] = 0;
136         group.remaining = group.remaining.minus(tokens);
137         
138         if (!token.transfer(_account, tokens)) {
139             revert();
140         }
141     }
142 }
143 
144 // File: contracts/token/StandardToken.sol
145 
146 /**
147  * @title Standard Token
148  *
149  * @dev The standard abstract implementation of the ERC20 interface.
150  */
151 contract StandardToken is ERC20Token {
152     using SafeMath for uint256;
153 
154     string public name;
155     string public symbol;
156     uint8 public decimals;
157     
158     mapping (address => uint256) balances;
159     mapping (address => mapping (address => uint256)) internal allowed;
160     
161     /**
162      * @dev The constructor assigns the token name, symbols and decimals.
163      */
164     constructor(string _name, string _symbol, uint8 _decimals) internal {
165         name = _name;
166         symbol = _symbol;
167         decimals = _decimals;
168     }
169 
170     /**
171      * @dev Get the balance of an address.
172      *
173      * @param _address The address which's balance will be checked.
174      *
175      * @return The current balance of the address.
176      */
177     function balanceOf(address _address) public view returns (uint256 balance) {
178         return balances[_address];
179     }
180 
181     /**
182      * @dev Checks the amount of tokens that an owner allowed to a spender.
183      *
184      * @param _owner The address which owns the funds allowed for spending by a third-party.
185      * @param _spender The third-party address that is allowed to spend the tokens.
186      *
187      * @return The number of tokens available to `_spender` to be spent.
188      */
189     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
190         return allowed[_owner][_spender];
191     }
192 
193     /**
194      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
195      * E.g. You place a buy or sell order on an exchange and in that example, the 
196      * `_spender` address is the address of the contract the exchange created to add your token to their 
197      * website and you are `msg.sender`.
198      *
199      * @param _spender The address which will spend the funds.
200      * @param _value The amount of tokens to be spent.
201      *
202      * @return Whether the approval process was successful or not.
203      */
204     function approve(address _spender, uint256 _value) public returns (bool) {
205         allowed[msg.sender][_spender] = _value;
206 
207         emit Approval(msg.sender, _spender, _value);
208 
209         return true;
210     }
211 
212     /**
213      * @dev Transfers `_value` number of tokens to the `_to` address.
214      *
215      * @param _to The address of the recipient.
216      * @param _value The number of tokens to be transferred.
217      */
218     function transfer(address _to, uint256 _value) public returns (bool) {
219         executeTransfer(msg.sender, _to, _value);
220 
221         return true;
222     }
223 
224     /**
225      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
226      *
227      * @param _from The address which approved you to spend tokens on their behalf.
228      * @param _to The address where you want to send tokens.
229      * @param _value The number of tokens to be sent.
230      *
231      * @return Whether the transfer was successful or not.
232      */
233     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
234         require(_value <= allowed[_from][msg.sender]);
235         
236         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
237         executeTransfer(_from, _to, _value);
238 
239         return true;
240     }
241 
242     /**
243      * @dev Internal function that this reused by the transfer functions
244      */
245     function executeTransfer(address _from, address _to, uint256 _value) internal {
246         require(_to != address(0));
247         require(_value != 0 && _value <= balances[_from]);
248         
249         balances[_from] = balances[_from].minus(_value);
250         balances[_to] = balances[_to].plus(_value);
251 
252         emit Transfer(_from, _to, _value);
253     }
254 }
255 
256 // File: contracts/token/MintableToken.sol
257 
258 /**
259  * @title Mintable Token
260  *
261  * @dev Allows the creation of new tokens.
262  */
263 contract MintableToken is StandardToken {
264     /// @dev The only address allowed to mint coins
265     address public minter;
266 
267     /// @dev Indicates whether the token is still mintable.
268     bool public mintingDisabled = false;
269 
270     /**
271      * @dev Event fired when minting is no longer allowed.
272      */
273     event MintingDisabled();
274 
275     /**
276      * @dev Allows a function to be executed only if minting is still allowed.
277      */
278     modifier canMint() {
279         require(!mintingDisabled);
280         _;
281     }
282 
283     /**
284      * @dev Allows a function to be called only by the minter
285      */
286     modifier onlyMinter() {
287         require(msg.sender == minter);
288         _;
289     }
290 
291     /**
292      * @dev The constructor assigns the minter which is allowed to mind and disable minting
293      */
294     constructor(address _minter) internal {
295         minter = _minter;
296     }
297 
298     /**
299     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
300     *
301     * @param _to The address which will receive the freshly minted tokens.
302     * @param _value The number of tokens that will be created.
303     */
304     function mint(address _to, uint256 _value) onlyMinter canMint public {
305         totalSupply = totalSupply.plus(_value);
306         balances[_to] = balances[_to].plus(_value);
307 
308         emit Transfer(0x0, _to, _value);
309     }
310 
311     /**
312     * @dev Disable the minting of new tokens. Cannot be reversed.
313     *
314     * @return Whether or not the process was successful.
315     */
316     function disableMinting() onlyMinter canMint public {
317         mintingDisabled = true;
318        
319         emit MintingDisabled();
320     }
321 }
322 
323 // File: contracts/token/BurnableToken.sol
324 
325 /**
326  * @title Burnable Token
327  *
328  * @dev Allows tokens to be destroyed.
329  */
330 contract BurnableToken is StandardToken {
331     /**
332      * @dev Event fired when tokens are burned.
333      *
334      * @param _from The address from which tokens will be removed.
335      * @param _value The number of tokens to be destroyed.
336      */
337     event Burn(address indexed _from, uint256 _value);
338 
339     /**
340      * @dev Burnes `_value` number of tokens.
341      *
342      * @param _value The number of tokens that will be burned.
343      */
344     function burn(uint256 _value) public {
345         require(_value != 0);
346 
347         address burner = msg.sender;
348         require(_value <= balances[burner]);
349 
350         balances[burner] = balances[burner].minus(_value);
351         totalSupply = totalSupply.minus(_value);
352 
353         emit Burn(burner, _value);
354         emit Transfer(burner, address(0), _value);
355     }
356 }
357 
358 // File: contracts/trait/HasOwner.sol
359 
360 /**
361  * @title HasOwner
362  *
363  * @dev Allows for exclusive access to certain functionality.
364  */
365 contract HasOwner {
366     // The current owner.
367     address public owner;
368 
369     // Conditionally the new owner.
370     address public newOwner;
371 
372     /**
373      * @dev The constructor.
374      *
375      * @param _owner The address of the owner.
376      */
377     constructor(address _owner) public {
378         owner = _owner;
379     }
380 
381     /** 
382      * @dev Access control modifier that allows only the current owner to call the function.
383      */
384     modifier onlyOwner {
385         require(msg.sender == owner);
386         _;
387     }
388 
389     /**
390      * @dev The event is fired when the current owner is changed.
391      *
392      * @param _oldOwner The address of the previous owner.
393      * @param _newOwner The address of the new owner.
394      */
395     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
396 
397     /**
398      * @dev Transfering the ownership is a two-step process, as we prepare
399      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
400      * the transfer. This prevents accidental lock-out if something goes wrong
401      * when passing the `newOwner` address.
402      *
403      * @param _newOwner The address of the proposed new owner.
404      */
405     function transferOwnership(address _newOwner) public onlyOwner {
406         newOwner = _newOwner;
407     }
408  
409     /**
410      * @dev The `newOwner` finishes the ownership transfer process by accepting the
411      * ownership.
412      */
413     function acceptOwnership() public {
414         require(msg.sender == newOwner);
415 
416         emit OwnershipTransfer(owner, newOwner);
417 
418         owner = newOwner;
419     }
420 }
421 
422 // File: contracts/fundraiser/AbstractFundraiser.sol
423 
424 contract AbstractFundraiser {
425     /// The ERC20 token contract.
426     ERC20Token public token;
427 
428     /**
429      * @dev The event fires every time a new buyer enters the fundraiser.
430      *
431      * @param _address The address of the buyer.
432      * @param _ethers The number of ethers funded.
433      * @param _tokens The number of tokens purchased.
434      */
435     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
436 
437 
438     /**
439      * @dev The initialization method for the token
440      *
441      * @param _token The address of the token of the fundraiser
442      */
443     function initializeFundraiserToken(address _token) internal
444     {
445         token = ERC20Token(_token);
446     }
447 
448     /**
449      * @dev The default function which is executed when someone sends funds to this contract address.
450      */
451     function() public payable {
452         receiveFunds(msg.sender, msg.value);
453     }
454 
455     /**
456      * @dev this overridable function returns the current conversion rate for the fundraiser
457      */
458     function getConversionRate() public view returns (uint256);
459 
460     /**
461      * @dev checks whether the fundraiser passed `endTime`.
462      *
463      * @return whether the fundraiser has ended.
464      */
465     function hasEnded() public view returns (bool);
466 
467     /**
468      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
469      *
470      * @param _address The address of the receiver of tokens.
471      * @param _amount The amount of received funds in ether.
472      */
473     function receiveFunds(address _address, uint256 _amount) internal;
474     
475     /**
476      * @dev It throws an exception if the transaction does not meet the preconditions.
477      */
478     function validateTransaction() internal view;
479     
480     /**
481      * @dev this overridable function makes and handles tokens to buyers
482      */
483     function handleTokens(address _address, uint256 _tokens) internal;
484 
485     /**
486      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
487      */
488     function handleFunds(address _address, uint256 _ethers) internal;
489 
490 }
491 
492 // File: contracts/fundraiser/BasicFundraiser.sol
493 
494 /**
495  * @title Basic Fundraiser
496  *
497  * @dev An abstract contract that is a base for fundraisers. 
498  * It implements a generic procedure for handling received funds:
499  * 1. Validates the transaciton preconditions
500  * 2. Calculates the amount of tokens based on the conversion rate.
501  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
502  * 4. Delegate the handling of the funds
503  * 5. Emit event for received funds
504  */
505 contract BasicFundraiser is HasOwner, AbstractFundraiser {
506     using SafeMath for uint256;
507 
508     // The number of decimals for the token.
509     uint8 constant DECIMALS = 18;  // Enforced
510 
511     // Decimal factor for multiplication purposes.
512     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
513 
514     /// The start time of the fundraiser - Unix timestamp.
515     uint256 public startTime;
516 
517     /// The end time of the fundraiser - Unix timestamp.
518     uint256 public endTime;
519 
520     /// The address where funds collected will be sent.
521     address public beneficiary;
522 
523     /// The conversion rate with decimals difference adjustment,
524     /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
525     uint256 public conversionRate;
526 
527     /// The total amount of ether raised.
528     uint256 public totalRaised;
529 
530     /**
531      * @dev The event fires when the number of token conversion rate has changed.
532      *
533      * @param _conversionRate The new number of tokens per 1 ether.
534      */
535     event ConversionRateChanged(uint _conversionRate);
536 
537     /**
538      * @dev The basic fundraiser initialization method.
539      *
540      * @param _startTime The start time of the fundraiser - Unix timestamp.
541      * @param _endTime The end time of the fundraiser - Unix timestamp.
542      * @param _conversionRate The number of tokens create for 1 ETH funded.
543      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
544      */
545     function initializeBasicFundraiser(
546         uint256 _startTime,
547         uint256 _endTime,
548         uint256 _conversionRate,
549         address _beneficiary
550     )
551         internal
552     {
553         require(_endTime >= _startTime);
554         require(_conversionRate > 0);
555         require(_beneficiary != address(0));
556 
557         startTime = _startTime;
558         endTime = _endTime;
559         conversionRate = _conversionRate;
560         beneficiary = _beneficiary;
561     }
562 
563     /**
564      * @dev Sets the new conversion rate
565      *
566      * @param _conversionRate New conversion rate
567      */
568     function setConversionRate(uint256 _conversionRate) public onlyOwner {
569         require(_conversionRate > 0);
570 
571         conversionRate = _conversionRate;
572 
573         emit ConversionRateChanged(_conversionRate);
574     }
575 
576     /**
577      * @dev Sets The beneficiary of the fundraiser.
578      *
579      * @param _beneficiary The address of the beneficiary.
580      */
581     function setBeneficiary(address _beneficiary) public onlyOwner {
582         require(_beneficiary != address(0));
583 
584         beneficiary = _beneficiary;
585     }
586 
587     /**
588      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
589      *
590      * @param _address The address of the receiver of tokens.
591      * @param _amount The amount of received funds in ether.
592      */
593     function receiveFunds(address _address, uint256 _amount) internal {
594         validateTransaction();
595 
596         uint256 tokens = calculateTokens(_amount);
597         require(tokens > 0);
598 
599         totalRaised = totalRaised.plus(_amount);
600         handleTokens(_address, tokens);
601         handleFunds(_address, _amount);
602 
603         emit FundsReceived(_address, msg.value, tokens);
604     }
605 
606     /**
607      * @dev this overridable function returns the current conversion rate for the fundraiser
608      */
609     function getConversionRate() public view returns (uint256) {
610         return conversionRate;
611     }
612 
613     /**
614      * @dev this overridable function that calculates the tokens based on the ether amount
615      */
616     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
617         tokens = _amount.mul(getConversionRate());
618     }
619 
620     /**
621      * @dev It throws an exception if the transaction does not meet the preconditions.
622      */
623     function validateTransaction() internal view {
624         require(msg.value != 0);
625         require(now >= startTime && now < endTime);
626     }
627 
628     /**
629      * @dev checks whether the fundraiser passed `endtime`.
630      *
631      * @return whether the fundraiser is passed its deadline or not.
632      */
633     function hasEnded() public view returns (bool) {
634         return now >= endTime;
635     }
636 }
637 
638 // File: contracts/token/StandardMintableToken.sol
639 
640 contract StandardMintableToken is MintableToken {
641     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
642         StandardToken(_name, _symbol, _decimals)
643         MintableToken(_minter)
644         public
645     {
646     }
647 }
648 
649 // File: contracts/fundraiser/MintableTokenFundraiser.sol
650 
651 /**
652  * @title Fundraiser With Mintable Token
653  */
654 contract MintableTokenFundraiser is BasicFundraiser {
655     /**
656      * @dev The initialization method that creates a new mintable token.
657      *
658      * @param _name Token name
659      * @param _symbol Token symbol
660      * @param _decimals Token decimals
661      */
662     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
663         token = new StandardMintableToken(
664             address(this), // The fundraiser is the token minter
665             _name,
666             _symbol,
667             _decimals
668         );
669     }
670 
671     /**
672      * @dev Mint the specific amount tokens
673      */
674     function handleTokens(address _address, uint256 _tokens) internal {
675         MintableToken(token).mint(_address, _tokens);
676     }
677 }
678 
679 // File: contracts/fundraiser/IndividualCapsFundraiser.sol
680 
681 /**
682  * @title Fundraiser with individual caps
683  *
684  * @dev Allows you to set a hard cap on your fundraiser.
685  */
686 contract IndividualCapsFundraiser is BasicFundraiser {
687     uint256 public individualMinCap;
688     uint256 public individualMaxCap;
689     uint256 public individualMaxCapTokens;
690 
691 
692     event IndividualMinCapChanged(uint256 _individualMinCap);
693     event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);
694 
695     /**
696      * @dev The initialization method.
697      *
698      * @param _individualMinCap The minimum amount of ether contribution per address.
699      * @param _individualMaxCap The maximum amount of ether contribution per address.
700      */
701     function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {
702         individualMinCap = _individualMinCap;
703         individualMaxCap = _individualMaxCap;
704         individualMaxCapTokens = _individualMaxCap * conversionRate;
705     }
706 
707     function setConversionRate(uint256 _conversionRate) public onlyOwner {
708         super.setConversionRate(_conversionRate);
709 
710         if (individualMaxCap == 0) {
711             return;
712         }
713         
714         individualMaxCapTokens = individualMaxCap * _conversionRate;
715 
716         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
717     }
718 
719     function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {
720         individualMinCap = _individualMinCap;
721 
722         emit IndividualMinCapChanged(individualMinCap);
723     }
724 
725     function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {
726         individualMaxCap = _individualMaxCap;
727         individualMaxCapTokens = _individualMaxCap * conversionRate;
728 
729         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
730     }
731 
732     /**
733      * @dev Extends the transaction validation to check if the value this higher than the minumum cap.
734      */
735     function validateTransaction() internal view {
736         super.validateTransaction();
737         require(msg.value >= individualMinCap);
738     }
739 
740     /**
741      * @dev We validate the new amount doesn't surpass maximum contribution cap
742      */
743     function handleTokens(address _address, uint256 _tokens) internal {
744         require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);
745 
746         super.handleTokens(_address, _tokens);
747     }
748 }
749 
750 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
751 
752 /**
753  * @title GasPriceLimitFundraiser
754  *
755  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
756  */
757 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
758     uint256 public gasPriceLimit;
759 
760     event GasPriceLimitChanged(uint256 gasPriceLimit);
761 
762     /**
763      * @dev This function puts the initial gas limit
764      */
765     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
766         gasPriceLimit = _gasPriceLimit;
767     }
768 
769     /**
770      * @dev This function allows the owner to change the gas limit any time during the fundraiser
771      */
772     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
773         gasPriceLimit = _gasPriceLimit;
774 
775         emit GasPriceLimitChanged(_gasPriceLimit);
776     }
777 
778     /**
779      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
780      */
781     function validateTransaction() internal view {
782         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
783 
784         return super.validateTransaction();
785     }
786 }
787 
788 // File: contracts/fundraiser/CappedFundraiser.sol
789 
790 /**
791  * @title Capped Fundraiser
792  *
793  * @dev Allows you to set a hard cap on your fundraiser.
794  */
795 contract CappedFundraiser is BasicFundraiser {
796     /// The maximum amount of ether allowed for the fundraiser.
797     uint256 public hardCap;
798 
799     /**
800      * @dev The initialization method.
801      *
802      * @param _hardCap The maximum amount of ether allowed to be raised.
803      */
804     function initializeCappedFundraiser(uint256 _hardCap) internal {
805         require(_hardCap > 0);
806 
807         hardCap = _hardCap;
808     }
809 
810     /**
811      * @dev Adds additional check if the hard cap has been reached.
812      *
813      * @return Whether the token purchase will be allowed.
814      */
815     function validateTransaction() internal view {
816         super.validateTransaction();
817         require(totalRaised < hardCap);
818     }
819 
820     /**
821      * @dev Overrides the method from the default `Fundraiser` contract
822      * to additionally check if the `hardCap` is reached.
823      *
824      * @return Whether or not the fundraiser has ended.
825      */
826     function hasEnded() public view returns (bool) {
827         return (super.hasEnded() || totalRaised >= hardCap);
828     }
829 }
830 
831 // File: contracts/fundraiser/FinalizableFundraiser.sol
832 
833 /**
834  * @title Finalizable Fundraiser
835  *
836  * @dev Allows the owner of this contract to finalize the fundraiser at any given time
837  * after certain conditions are met, such as hard cap reached,
838  * and also do extra work when finalized.
839  */
840 contract FinalizableFundraiser is BasicFundraiser {
841     /// Flag indicating whether or not the fundraiser is finalized.
842     bool public isFinalized = false;
843 
844     /**
845      * @dev Event fires if the finalization of the fundraiser is successful.
846      */
847     event Finalized();
848 
849     /**
850      * @dev Finalizes the fundraiser. Cannot be reversed.
851      */
852     function finalize() onlyOwner public {
853         require(!isFinalized);
854         require(hasEnded());
855 
856         finalization();
857         emit Finalized();
858 
859         isFinalized = true;
860     }
861 
862     /**
863      * @dev Override this function to add extra work when a fundraiser is finalized.
864      * Don't forget to add super.finalization() to execute this part.
865      */
866     function finalization() internal {
867         beneficiary.transfer(address(this).balance);
868     }
869 
870 
871     /**
872      * @dev Do nothing, wait for finalization
873      */
874     function handleFunds(address, uint256) internal {
875     }
876     
877 }
878 
879 // File: contracts/component/RefundSafe.sol
880 
881 /**
882  * @title Refund Safe
883  *
884  * @dev Allows your fundraiser to offer refunds if soft cap is not reached 
885  * while the fundraiser is active.
886  */
887 contract RefundSafe is HasOwner {
888     using SafeMath for uint256;
889 
890     /// The state of the refund safe.
891     /// ACTIVE    - the default state while the fundraiser is active.
892     /// REFUNDING - the refund safe allows participants in the fundraiser to get refunds.
893     /// CLOSED    - the refund safe is closed for business.
894     enum State {ACTIVE, REFUNDING, CLOSED}
895 
896     /// Holds all ETH deposits of participants in the fundraiser.
897     mapping(address => uint256) public deposits;
898 
899     /// The address which will receive the funds if the fundraiser is successful.
900     address public beneficiary;
901 
902     /// The state variable which will control the lifecycle of the refund safe.
903     State public state;
904 
905     /**
906      * @dev Event fired when the refund safe is closed.
907      */
908     event RefundsClosed();
909 
910     /**
911      * @dev Event fired when refunds are allowed.
912      */
913     event RefundsAllowed();
914 
915     /**
916      * @dev Event fired when a participant in the fundraiser is successfully refunded.
917      *
918      * @param _address The address of the participant.
919      * @param _value The number of ETH which were refunded.
920      */
921     event RefundSuccessful(address indexed _address, uint256 _value);
922 
923     /**
924      * @dev Constructor.
925      *
926      * @param _beneficiary The address which will receive the funds if the fundraiser is a success.
927      */
928     constructor(address _owner, address _beneficiary)
929         HasOwner(_owner)
930         public
931     {
932         require(_beneficiary != 0x0);
933 
934         beneficiary = _beneficiary;
935         state = State.ACTIVE;
936     }
937 
938     /**
939      * @dev Sets The beneficiary address.
940      *
941      * @param _beneficiary The address of the beneficiary.
942      */
943     function setBeneficiary(address _beneficiary) public onlyOwner {
944         require(_beneficiary != address(0));
945 
946         beneficiary = _beneficiary;
947     }
948 
949     /**
950      * @dev Deposits ETH into the refund safe.
951      *
952      * @param _address The address of the participant in the fundraiser.
953      */
954     function deposit(address _address) onlyOwner public payable {
955         require(state == State.ACTIVE);
956 
957         deposits[_address] = deposits[_address].plus(msg.value);
958     }
959 
960     /**
961      * @dev Closes the refund safe.
962      */
963     function close() onlyOwner public {
964         require(state == State.ACTIVE);
965 
966         state = State.CLOSED;
967 
968         emit RefundsClosed();
969 
970         beneficiary.transfer(address(this).balance);
971     }
972 
973     /**
974      * @dev Moves the refund safe into a state of refund.
975      */
976     function allowRefunds() onlyOwner public {
977         require(state == State.ACTIVE);
978 
979         state = State.REFUNDING;
980 
981         emit RefundsAllowed();
982     }
983 
984     /**
985      * @dev Refunds a participant in the fundraiser.
986      *
987      * @param _address The address of the participant.
988      */
989     function refund(address _address) public {
990         require(state == State.REFUNDING);
991 
992         uint256 amount = deposits[_address];
993         // We do not want to emit RefundSuccessful events for empty accounts with zero ether
994         require(amount != 0);
995         // Zeroing the deposit early prevents reentrancy issues
996         deposits[_address] = 0;
997         _address.transfer(amount);
998 
999         emit RefundSuccessful(_address, amount);
1000     }
1001 }
1002 
1003 // File: contracts/fundraiser/RefundableFundraiser.sol
1004 
1005 /**
1006  * @title Refundable fundraiser
1007  *
1008  * @dev Allows your fundraiser to offer refunds to token buyers if it failed to reach the `softCap` in its duration.
1009  */
1010 contract RefundableFundraiser is FinalizableFundraiser {
1011     /// The minimum amount of funds (in ETH) to be gathered in order for the 
1012     /// fundraiser to be considered successful.
1013     uint256 public softCap;
1014 
1015     /// The instance of the refund safe which holds all ETH funds until the fundraiser
1016     /// is finalized.
1017     RefundSafe public refundSafe;
1018 
1019     /**
1020      * @dev The constructor.
1021      *
1022      * @param _softCap The minimum amount of funds (in ETH) that need to be reached.
1023      */
1024     function initializeRefundableFundraiser(uint256 _softCap) internal {
1025         require(_softCap > 0);
1026 
1027         refundSafe = new RefundSafe(address(this), beneficiary);
1028         softCap = _softCap;
1029     }
1030 
1031     /**
1032      * @dev Defines the abstract function from `BaseFundraiser` to add the funds to the `refundSafe`
1033      */
1034     function handleFunds(address _address, uint256 _ethers) internal {
1035         refundSafe.deposit.value(_ethers)(_address);
1036     }
1037 
1038     /**
1039      * @dev Checks if the soft cap was reached by the fundraiser.
1040      *
1041      * @return Whether `softCap` is reached or not.
1042      */
1043     function softCapReached() public view returns (bool) {
1044         return totalRaised >= softCap;
1045     }
1046 
1047     /**
1048      * @dev If the fundraiser failed to reach the soft cap,
1049      * participants can use this method to get their ether back.
1050      */
1051     function getRefund() public {
1052         require(isFinalized);
1053         require(!softCapReached());
1054 
1055         refundSafe.refund(msg.sender);
1056     }
1057 
1058     /**
1059      * @dev Overrides the setBeneficiation fucntion to set the beneficiary of the refund safe
1060      *
1061      * @param _beneficiary The address of the beneficiary.
1062      */
1063     function setBeneficiary(address _beneficiary) public onlyOwner {
1064         super.setBeneficiary(_beneficiary);
1065         refundSafe.setBeneficiary(_beneficiary);
1066     }
1067 
1068     /**
1069      * @dev Overrides the default function from `FinalizableFundraiser`
1070      * to check if soft cap was reached and appropriatelly allow refunds
1071      * or simply close the refund safe.
1072      */
1073     function finalization() internal {
1074         super.finalization();
1075 
1076         if (softCapReached()) {
1077             refundSafe.close();
1078         } else {
1079             refundSafe.allowRefunds();
1080         }
1081     }
1082 }
1083 
1084 // File: contracts/fundraiser/PresaleFundraiser.sol
1085 
1086 /**
1087  * @title PresaleFundraiser
1088  *
1089  * @dev This is the standard fundraiser contract which allows
1090  * you to raise ETH in exchange for your tokens.
1091  */
1092 contract PresaleFundraiser is MintableTokenFundraiser {
1093     /// @dev The token hard cap for the pre-sale
1094     uint256 public presaleSupply;
1095 
1096     /// @dev The token hard cap for the pre-sale
1097     uint256 public presaleMaxSupply;
1098 
1099     /// @dev The start time of the pre-sale (Unix timestamp).
1100     uint256 public presaleStartTime;
1101 
1102     /// @dev The end time of the pre-sale (Unix timestamp).
1103     uint256 public presaleEndTime;
1104 
1105     /// @dev The conversion rate for the pre-sale
1106     uint256 public presaleConversionRate;
1107 
1108     /**
1109      * @dev The initialization method.
1110      *
1111      * @param _startTime The timestamp of the moment when the pre-sale starts
1112      * @param _endTime The timestamp of the moment when the pre-sale ends
1113      * @param _conversionRate The conversion rate during the pre-sale
1114      */
1115     function initializePresaleFundraiser(
1116         uint256 _presaleMaxSupply,
1117         uint256 _startTime,
1118         uint256 _endTime,
1119         uint256 _conversionRate
1120     )
1121         internal
1122     {
1123         require(_endTime >= _startTime);
1124         require(_conversionRate > 0);
1125 
1126         presaleMaxSupply = _presaleMaxSupply;
1127         presaleStartTime = _startTime;
1128         presaleEndTime = _endTime;
1129         presaleConversionRate = _conversionRate;
1130     }
1131 
1132     /**
1133      * @dev Internal funciton that helps to check if the pre-sale is active
1134      */
1135     
1136     function isPresaleActive() internal view returns (bool) {
1137         return now < presaleEndTime && now >= presaleStartTime;
1138     }
1139     /**
1140      * @dev this function different conversion rate while in presale
1141      */
1142     function getConversionRate() public view returns (uint256) {
1143         if (isPresaleActive()) {
1144             return presaleConversionRate;
1145         }
1146         return super.getConversionRate();
1147     }
1148 
1149     /**
1150      * @dev It throws an exception if the transaction does not meet the preconditions.
1151      */
1152     function validateTransaction() internal view {
1153         require(msg.value != 0);
1154         require(now >= startTime && now < endTime || isPresaleActive());
1155     }
1156 
1157     function handleTokens(address _address, uint256 _tokens) internal {
1158         if (isPresaleActive()) {
1159             presaleSupply = presaleSupply.plus(_tokens);
1160             require(presaleSupply <= presaleMaxSupply);
1161         }
1162 
1163         super.handleTokens(_address, _tokens);
1164     }
1165 
1166 }
1167 
1168 // File: contracts/Fundraiser.sol
1169 
1170 /**
1171  * @title AdultXToken
1172  */
1173  
1174 
1175 contract AdultXToken is MintableToken, BurnableToken {
1176   constructor(address _minter)
1177     StandardToken(
1178       "Adult X Token",   // Token name
1179       "ADUX", // Token symbol
1180       18  // Token decimals
1181     )
1182     
1183     MintableToken(_minter)
1184     public
1185   {
1186   }
1187 }
1188 
1189 
1190 /**
1191  * @title AdultXTokenSafe
1192  */
1193  
1194 contract AdultXTokenSafe is TokenSafe {
1195   constructor(address _token) 
1196     TokenSafe(_token)
1197     public
1198   {
1199     // Group "Team and Advisors"
1200     init(
1201       0, // Group Id
1202       1535716800 // Release date = 31 Aug 2018 12:00 UTC
1203     );
1204     add(
1205       0, // Group Id
1206       0x10A7201e2B59b4e37Ae34588Ed16fe2BB2013765, // Token Safe Entry Address
1207       50000000000000000000000000  // Allocated tokens
1208     );
1209     // Group "Marketing"
1210     init(
1211       1, // Group Id
1212       1535716800 // Release date = 31 Aug 2018 12:00 UTC
1213     );
1214     add(
1215       1, // Group Id
1216       0x7be89481CDd9Cd407D5A6e2c73d9c6B9B6DdfDBb, // Token Safe Entry Address
1217       100000000000000000000000000  // Allocated tokens
1218     );
1219     // Group "Airdrop"
1220     init(
1221       2, // Group Id
1222       1543665600 // Release date = 01 Dec 2018 12:00 UTC
1223     );
1224     add(
1225       2, // Group Id
1226       0xAc2582953a509804D303ad47b5E12D1bE5f3E044, // Token Safe Entry Address
1227       50000000000000000000000000  // Allocated tokens
1228     );
1229   }
1230 }
1231 
1232 
1233 /**
1234  * @title AdultXTokenFundraiser
1235  */
1236 
1237 contract AdultXTokenFundraiser is MintableTokenFundraiser, PresaleFundraiser, IndividualCapsFundraiser, CappedFundraiser, RefundableFundraiser, GasPriceLimitFundraiser {
1238   AdultXTokenSafe public tokenSafe;
1239 
1240   constructor()
1241     HasOwner(msg.sender)
1242     public
1243   {
1244     token = new AdultXToken(
1245       
1246       address(this)  // The fundraiser is the minter
1247     );
1248 
1249     tokenSafe = new AdultXTokenSafe(token);
1250     MintableToken(token).mint(address(tokenSafe), 200000000000000000000000000);
1251 
1252     initializeBasicFundraiser(
1253       1540987200, // Start date = 31 Oct 2018 12:00 UTC
1254       1543579200,  // End date = 30 Nov 2018 12:00 UTC
1255       10000, // Conversion rate = 10000 ADUX per 1 ether
1256       0x1f98908f6857de3227fb735fACa75CCD5b9403c5     // Beneficiary
1257     );
1258 
1259     initializeIndividualCapsFundraiser(
1260       (0.2 ether), // Minimum contribution
1261       (0 ether)  // Maximum individual cap
1262     );
1263 
1264     initializeGasPriceLimitFundraiser(
1265         0 // Gas price limit in wei
1266     );
1267 
1268     initializePresaleFundraiser(
1269         50000000000000000000000000,
1270         1535716800, // Start =  
1271         1540987200,   // End = 
1272         14000
1273     );
1274 
1275     initializeCappedFundraiser(
1276       (35000 ether) // Hard cap
1277     );
1278 
1279     initializeRefundableFundraiser(
1280       (3500 ether)  // Soft cap
1281     );
1282     
1283     
1284   }
1285   
1286   /**
1287     * @dev Disable minting upon finalization
1288     */
1289   function finalization() internal {
1290       super.finalization();
1291       MintableToken(token).disableMinting();
1292   }
1293 }