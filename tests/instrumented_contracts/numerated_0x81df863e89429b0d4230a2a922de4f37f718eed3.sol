1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/2.0/PSPStakingMigratorV1.sol": {
5       "content": "pragma solidity 0.8.6;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"./utils/Utils.sol\";\n\nerror IndexOutOfRange(uint8 index);\n\ninterface I_sPSP is IERC20 {\n    function leave(uint256 _stakedAmount) external;\n\n    function withdraw(int256 id) external;\n\n    function userVsNextID(address owner) external returns (int256);\n}\n\ninterface I_stkPSPBpt is IERC20 {\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n}\n\ninterface I_sePSP is IERC20 {\n    function deposit(uint256 amount) external;\n}\n\ninterface I_sePSP2 is I_sePSP {\n    function depositPSPAndEth(\n        uint256 pspAmount,\n        uint256 minBptOut,\n        bytes memory pspPermit\n    ) external payable;\n\n    function depositPSPAndWeth(\n        uint256 pspAmount,\n        uint256 wethAmount,\n        uint256 minBptOut,\n        bytes memory pspPermit\n    ) external;\n}\n\ncontract PSPStakingMigratorV1 {\n    IERC20 public immutable PSP;\n    IERC20 public immutable WETH;\n\n    I_sePSP public immutable sePSP;\n    I_sePSP2 public immutable sePSP2;\n\n    I_stkPSPBpt public immutable stkPSPBpt;\n    IERC20 public immutable BPT;\n\n    I_sPSP[] public SPSPs;\n\n    struct RequestSPSP {\n        uint8 index;\n        uint256 amount;\n        bytes permitData;\n    }\n\n    constructor(\n        IERC20 _PSP,\n        IERC20 _WETH,\n        IERC20 _bpt,\n        I_sePSP _sePSP,\n        I_sePSP2 _sePSP2,\n        I_stkPSPBpt _stkPSPBpt,\n        I_sPSP[] memory _SPSPs\n    ) {\n        PSP = _PSP;\n        WETH = _WETH;\n        BPT = _bpt;\n\n        sePSP = _sePSP;\n        sePSP2 = _sePSP2;\n\n        stkPSPBpt = _stkPSPBpt;\n        SPSPs = _SPSPs;\n    }\n\n    function depositSPSPsForSePSP(RequestSPSP[] calldata reqs) external {\n        _unstakeSPSPsAndGetPSP(reqs);\n\n        uint256 pspBalance = PSP.balanceOf(address(this));\n\n        PSP.approve(address(sePSP), pspBalance);\n        sePSP.deposit(pspBalance);\n\n        sePSP.transfer(msg.sender, pspBalance); // 1:1 between sePSP and PSP\n    }\n\n    function depositStkPSPBptForSePSP2(uint256 bptAmount, bytes calldata stkPSPBptPermit) external {\n        Utils.permit(stkPSPBpt, stkPSPBptPermit);\n\n        stkPSPBpt.transferFrom(msg.sender, address(this), bptAmount);\n        stkPSPBpt.cooldown();\n        stkPSPBpt.redeem(address(this), bptAmount);\n\n        BPT.approve(address(sePSP2), bptAmount);\n        sePSP2.deposit(bptAmount);\n\n        sePSP2.transfer(msg.sender, bptAmount); // 1:1 between stkPSPBpt, BPT and sePSP2\n    }\n\n    function depositSPSPsAndETHForSePSP2(RequestSPSP[] calldata reqs, uint256 minBptOut) external payable {\n        _unstakeSPSPsAndGetPSP(reqs);\n\n        uint256 pspAmount = PSP.balanceOf(address(this));\n        PSP.approve(address(sePSP2), pspAmount);\n        sePSP2.depositPSPAndEth{ value: msg.value }(pspAmount, minBptOut, \"\");\n\n        uint256 sePSP2Balance = sePSP2.balanceOf(address(this));\n        sePSP2.transfer(msg.sender, sePSP2Balance);\n    }\n\n    function depositSPSPsAndWETHForSePSP2(\n        RequestSPSP[] calldata reqs,\n        uint256 wethAmount,\n        uint256 minBptOut\n    ) external {\n        _unstakeSPSPsAndGetPSP(reqs);\n        WETH.transferFrom(msg.sender, address(this), wethAmount);\n\n        uint256 pspAmount = PSP.balanceOf(address(this));\n\n        PSP.approve(address(sePSP2), pspAmount);\n        WETH.approve(address(sePSP2), wethAmount);\n        sePSP2.depositPSPAndWeth(pspAmount, wethAmount, minBptOut, \"\");\n\n        uint256 sePSP2Balance = sePSP2.balanceOf(address(this));\n        sePSP2.transfer(msg.sender, sePSP2Balance);\n    }\n\n    function _unstakeSPSPsAndGetPSP(RequestSPSP[] calldata reqs) internal {\n        for (uint8 i; i < reqs.length; i++) {\n            RequestSPSP memory req = reqs[i];\n\n            if (req.index >= SPSPs.length) {\n                revert IndexOutOfRange(req.index);\n            }\n\n            I_sPSP sPSP = SPSPs[req.index];\n\n            Utils.permit(sPSP, req.permitData);\n\n            sPSP.transferFrom(msg.sender, address(this), req.amount);\n\n            int256 id = sPSP.userVsNextID(address(this));\n            sPSP.leave(req.amount);\n            sPSP.withdraw(id);\n        }\n    }\n}\n"
6     },
7     "contracts/2.0/utils/Utils.sol": {
8       "content": "pragma solidity 0.8.6;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nerror PermitFailed();\nerror TransferEthFailed();\n\nlibrary Utils {\n    function permit(IERC20 token, bytes memory permit) internal {\n        if (permit.length == 32 * 7) {\n            (bool success, ) = address(token).call(abi.encodePacked(IERC20Permit.permit.selector, permit));\n            if (!success) {\n                revert PermitFailed();\n            }\n        }\n    }\n\n    function transferETH(address payable destination, uint256 amount) internal {\n        if (amount > 0) {\n            (bool result, ) = destination.call{ value: amount }(\"\");\n            if (!result) {\n                revert TransferEthFailed();\n            }\n        }\n    }\n}\n"
9     },
10     "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
12     },
13     "openzeppelin-solidity/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 100000
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     },
34     "metadata": {
35       "useLiteralContent": true
36     },
37     "libraries": {}
38   }
39 }}