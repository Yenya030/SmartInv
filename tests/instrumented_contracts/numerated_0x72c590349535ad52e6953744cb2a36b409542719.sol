1 {{
2   "language": "Solidity",
3   "sources": {
4     "BorrowerOperations.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"SafeERC20.sol\";\nimport \"IERC20.sol\";\nimport \"ITroveManager.sol\";\nimport \"IDebtToken.sol\";\nimport \"PrismaBase.sol\";\nimport \"PrismaMath.sol\";\nimport \"PrismaOwnable.sol\";\nimport \"DelegatedOps.sol\";\n\n/**\n    @title Prisma Borrower Operations\n    @notice Based on Liquity's `BorrowerOperations`\n            https://github.com/liquity/dev/blob/main/packages/contracts/contracts/BorrowerOperations.sol\n\n            Prisma's implementation is modified to support multiple collaterals. There is a 1:n\n            relationship between `BorrowerOperations` and each `TroveManager` / `SortedTroves` pair.\n */\ncontract BorrowerOperations is PrismaBase, PrismaOwnable, DelegatedOps {\n    using SafeERC20 for IERC20;\n\n    IDebtToken public immutable debtToken;\n    address public immutable factory;\n    uint256 public minNetDebt;\n\n    mapping(ITroveManager => TroveManagerData) public troveManagersData;\n    ITroveManager[] internal _troveManagers;\n\n    struct TroveManagerData {\n        IERC20 collateralToken;\n        uint16 index;\n    }\n\n    struct SystemBalances {\n        uint256[] collaterals;\n        uint256[] debts;\n        uint256[] prices;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 price;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        uint256 collChange;\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 debt;\n        uint256 coll;\n        uint256 newDebt;\n        uint256 newColl;\n        uint256 stake;\n        uint256 debtChange;\n        address account;\n        uint256 MCR;\n    }\n\n    struct LocalVariables_openTrove {\n        uint256 price;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 NICR;\n        uint256 stake;\n        uint256 arrayIndex;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 stake,\n        BorrowerOperation operation\n    );\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 stake, uint8 operation);\n    event BorrowingFeePaid(address indexed borrower, uint256 amount);\n    event CollateralConfigured(ITroveManager troveManager, IERC20 collateralToken);\n    event TroveManagerRemoved(ITroveManager troveManager);\n\n    constructor(\n        address _prismaCore,\n        address _debtTokenAddress,\n        address _factory,\n        uint256 _minNetDebt,\n        uint256 _gasCompensation\n    ) PrismaOwnable(_prismaCore) PrismaBase(_gasCompensation) {\n        debtToken = IDebtToken(_debtTokenAddress);\n        factory = _factory;\n        _setMinNetDebt(_minNetDebt);\n    }\n\n    function setMinNetDebt(uint256 _minNetDebt) public onlyOwner {\n        _setMinNetDebt(_minNetDebt);\n    }\n\n    function _setMinNetDebt(uint256 _minNetDebt) internal {\n        require(_minNetDebt > 0);\n        minNetDebt = _minNetDebt;\n    }\n\n    function configureCollateral(ITroveManager troveManager, IERC20 collateralToken) external {\n        require(msg.sender == factory, \"!factory\");\n        troveManagersData[troveManager] = TroveManagerData(collateralToken, uint16(_troveManagers.length));\n        _troveManagers.push(troveManager);\n        emit CollateralConfigured(troveManager, collateralToken);\n    }\n\n    function removeTroveManager(ITroveManager troveManager) external {\n        TroveManagerData memory tmData = troveManagersData[troveManager];\n        require(\n            address(tmData.collateralToken) != address(0) &&\n                troveManager.sunsetting() &&\n                troveManager.getEntireSystemDebt() == 0,\n            \"Trove Manager cannot be removed\"\n        );\n        delete troveManagersData[troveManager];\n        uint256 lastIndex = _troveManagers.length - 1;\n        if (tmData.index < lastIndex) {\n            ITroveManager lastTm = _troveManagers[lastIndex];\n            _troveManagers[tmData.index] = lastTm;\n            troveManagersData[lastTm].index = tmData.index;\n        }\n\n        _troveManagers.pop();\n        emit TroveManagerRemoved(troveManager);\n    }\n\n    /**\n        @notice Get the global total collateral ratio\n        @dev Not a view because fetching from the oracle is state changing.\n             Can still be accessed as a view from within the UX.\n     */\n    function getTCR() external returns (uint256 globalTotalCollateralRatio) {\n        SystemBalances memory balances = fetchBalances();\n        (globalTotalCollateralRatio, , ) = _getTCRData(balances);\n        return globalTotalCollateralRatio;\n    }\n\n    /**\n        @notice Get total collateral and debt balances for all active collaterals, as well as\n                the current collateral prices\n        @dev Not a view because fetching from the oracle is state changing.\n             Can still be accessed as a view from within the UX.\n     */\n    function fetchBalances() public returns (SystemBalances memory balances) {\n        uint256 loopEnd = _troveManagers.length;\n        balances = SystemBalances({\n            collaterals: new uint256[](loopEnd),\n            debts: new uint256[](loopEnd),\n            prices: new uint256[](loopEnd)\n        });\n        for (uint256 i; i < loopEnd; ) {\n            ITroveManager troveManager = _troveManagers[i];\n            (uint256 collateral, uint256 debt, uint256 price) = troveManager.getEntireSystemBalances();\n            balances.collaterals[i] = collateral;\n            balances.debts[i] = debt;\n            balances.prices[i] = price;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function checkRecoveryMode(uint256 TCR) public pure returns (bool) {\n        return TCR < CCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external view returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        ITroveManager troveManager,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collateralAmount,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Deposits are paused\");\n        IERC20 collateralToken;\n        LocalVariables_openTrove memory vars;\n        bool isRecoveryMode;\n        (\n            collateralToken,\n            vars.price,\n            vars.totalPricedCollateral,\n            vars.totalDebt,\n            isRecoveryMode\n        ) = _getCollateralAndTCRData(troveManager);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage);\n\n        vars.netDebt = _debtAmount;\n\n        if (!isRecoveryMode) {\n            vars.netDebt = vars.netDebt + _triggerBorrowingFee(troveManager, account, _maxFeePercentage, _debtAmount);\n        }\n        _requireAtLeastMinNetDebt(vars.netDebt);\n\n        // ICR is based on the composite debt, i.e. the requested Debt amount + Debt borrowing fee + Debt gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n        vars.ICR = PrismaMath._computeCR(_collateralAmount, vars.compositeDebt, vars.price);\n        vars.NICR = PrismaMath._computeNominalCR(_collateralAmount, vars.compositeDebt);\n\n        if (isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR, troveManager.MCR());\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                vars.totalPricedCollateral,\n                vars.totalDebt,\n                _collateralAmount * vars.price,\n                true,\n                vars.compositeDebt,\n                true\n            ); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n\n        // Create the trove\n        (vars.stake, vars.arrayIndex) = troveManager.openTrove(\n            account,\n            _collateralAmount,\n            vars.compositeDebt,\n            vars.NICR,\n            _upperHint,\n            _lowerHint,\n            isRecoveryMode\n        );\n        emit TroveCreated(account, vars.arrayIndex);\n\n        // Move the collateral to the Trove Manager\n        collateralToken.safeTransferFrom(msg.sender, address(troveManager), _collateralAmount);\n\n        //  and mint the DebtAmount to the caller and gas compensation for Gas Pool\n        debtToken.mintWithGasCompensation(msg.sender, _debtAmount);\n\n        emit TroveUpdated(account, vars.compositeDebt, _collateralAmount, vars.stake, BorrowerOperation.openTrove);\n    }\n\n    // Send collateral to a trove\n    function addColl(\n        ITroveManager troveManager,\n        address account,\n        uint256 _collateralAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Trove adjustments are paused\");\n        _adjustTrove(troveManager, account, 0, _collateralAmount, 0, 0, false, _upperHint, _lowerHint);\n    }\n\n    // Withdraw collateral from a trove\n    function withdrawColl(\n        ITroveManager troveManager,\n        address account,\n        uint256 _collWithdrawal,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        _adjustTrove(troveManager, account, 0, 0, _collWithdrawal, 0, false, _upperHint, _lowerHint);\n    }\n\n    // Withdraw Debt tokens from a trove: mint new Debt tokens to the owner, and increase the trove's debt accordingly\n    function withdrawDebt(\n        ITroveManager troveManager,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require(!PRISMA_CORE.paused(), \"Withdrawals are paused\");\n        _adjustTrove(troveManager, account, _maxFeePercentage, 0, 0, _debtAmount, true, _upperHint, _lowerHint);\n    }\n\n    // Repay Debt tokens to a Trove: Burn the repaid Debt tokens, and reduce the trove's debt accordingly\n    function repayDebt(\n        ITroveManager troveManager,\n        address account,\n        uint256 _debtAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        _adjustTrove(troveManager, account, 0, 0, 0, _debtAmount, false, _upperHint, _lowerHint);\n    }\n\n    function adjustTrove(\n        ITroveManager troveManager,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collDeposit,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) external callerOrDelegated(account) {\n        require((_collDeposit == 0 && !_isDebtIncrease) || !PRISMA_CORE.paused(), \"Trove adjustments are paused\");\n        require(_collDeposit == 0 || _collWithdrawal == 0, \"BorrowerOperations: Cannot withdraw and add coll\");\n        _adjustTrove(\n            troveManager,\n            account,\n            _maxFeePercentage,\n            _collDeposit,\n            _collWithdrawal,\n            _debtChange,\n            _isDebtIncrease,\n            _upperHint,\n            _lowerHint\n        );\n    }\n\n    function _adjustTrove(\n        ITroveManager troveManager,\n        address account,\n        uint256 _maxFeePercentage,\n        uint256 _collDeposit,\n        uint256 _collWithdrawal,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint\n    ) internal {\n        require(\n            _collDeposit != 0 || _collWithdrawal != 0 || _debtChange != 0,\n            \"BorrowerOps: There must be either a collateral change or a debt change\"\n        );\n\n        IERC20 collateralToken;\n        LocalVariables_adjustTrove memory vars;\n        bool isRecoveryMode;\n        (\n            collateralToken,\n            vars.price,\n            vars.totalPricedCollateral,\n            vars.totalDebt,\n            isRecoveryMode\n        ) = _getCollateralAndTCRData(troveManager);\n\n        (vars.coll, vars.debt) = troveManager.applyPendingRewards(account);\n\n        // Get the collChange based on whether or not collateral was sent in the transaction\n        (vars.collChange, vars.isCollIncrease) = _getCollChange(_collDeposit, _collWithdrawal);\n        vars.netDebtChange = _debtChange;\n        vars.debtChange = _debtChange;\n        vars.account = account;\n        vars.MCR = troveManager.MCR();\n\n        if (_isDebtIncrease) {\n            require(_debtChange > 0, \"BorrowerOps: Debt increase requires non-zero debtChange\");\n            _requireValidMaxFeePercentage(_maxFeePercentage);\n            if (!isRecoveryMode) {\n                // If the adjustment incorporates a debt increase and system is in Normal Mode, trigger a borrowing fee\n                vars.netDebtChange += _triggerBorrowingFee(troveManager, msg.sender, _maxFeePercentage, _debtChange);\n            }\n        }\n\n        // Calculate old and new ICRs and check if adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            vars.totalPricedCollateral,\n            vars.totalDebt,\n            isRecoveryMode,\n            _collWithdrawal,\n            _isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough Debt\n        if (!_isDebtIncrease && _debtChange > 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt) - vars.netDebtChange);\n        }\n\n        // If we are incrasing collateral, send tokens to the trove manager prior to adjusting the trove\n        if (vars.isCollIncrease) collateralToken.safeTransferFrom(msg.sender, address(troveManager), vars.collChange);\n\n        (vars.newColl, vars.newDebt, vars.stake) = troveManager.updateTroveFromAdjustment(\n            isRecoveryMode,\n            _isDebtIncrease,\n            vars.debtChange,\n            vars.netDebtChange,\n            vars.isCollIncrease,\n            vars.collChange,\n            _upperHint,\n            _lowerHint,\n            vars.account,\n            msg.sender\n        );\n\n        emit TroveUpdated(vars.account, vars.newDebt, vars.newColl, vars.stake, BorrowerOperation.adjustTrove);\n    }\n\n    function closeTrove(ITroveManager troveManager, address account) external callerOrDelegated(account) {\n        IERC20 collateralToken;\n\n        uint256 price;\n        bool isRecoveryMode;\n        uint256 totalPricedCollateral;\n        uint256 totalDebt;\n        (collateralToken, price, totalPricedCollateral, totalDebt, isRecoveryMode) = _getCollateralAndTCRData(\n            troveManager\n        );\n        require(!isRecoveryMode, \"BorrowerOps: Operation not permitted during Recovery Mode\");\n\n        (uint256 coll, uint256 debt) = troveManager.applyPendingRewards(account);\n\n        uint256 newTCR = _getNewTCRFromTroveChange(totalPricedCollateral, totalDebt, coll * price, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        troveManager.closeTrove(account, msg.sender, coll, debt);\n\n        emit TroveUpdated(account, 0, 0, 0, BorrowerOperation.closeTrove);\n\n        // Burn the repaid Debt from the user's balance and the gas compensation from the Gas Pool\n        debtToken.burnWithGasCompensation(msg.sender, debt - DEBT_GAS_COMPENSATION);\n    }\n\n    // --- Helper functions ---\n\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        address _caller,\n        uint256 _maxFeePercentage,\n        uint256 _debtAmount\n    ) internal returns (uint256) {\n        uint256 debtFee = _troveManager.decayBaseRateAndGetBorrowingFee(_debtAmount);\n\n        _requireUserAcceptsFee(debtFee, _debtAmount, _maxFeePercentage);\n\n        debtToken.mint(PRISMA_CORE.feeReceiver(), debtFee);\n\n        emit BorrowingFeePaid(_caller, debtFee);\n\n        return debtFee;\n    }\n\n    function _getCollChange(\n        uint256 _collReceived,\n        uint256 _requestedCollWithdrawal\n    ) internal pure returns (uint256 collChange, bool isCollIncrease) {\n        if (_collReceived != 0) {\n            collChange = _collReceived;\n            isCollIncrease = true;\n        } else {\n            collChange = _requestedCollWithdrawal;\n        }\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        uint256 totalPricedCollateral,\n        uint256 totalDebt,\n        bool _isRecoveryMode,\n        uint256 _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal pure {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n\n        // Get the trove's old ICR before the adjustment\n        uint256 oldICR = PrismaMath._computeCR(_vars.coll, _vars.debt, _vars.price);\n\n        // Get the trove's new ICR after the adjustment\n        uint256 newICR = _getNewICRFromTroveChange(\n            _vars.coll,\n            _vars.debt,\n            _vars.collChange,\n            _vars.isCollIncrease,\n            _vars.netDebtChange,\n            _isDebtIncrease,\n            _vars.price\n        );\n\n        if (_isRecoveryMode) {\n            require(_collWithdrawal == 0, \"BorrowerOps: Collateral withdrawal not permitted Recovery Mode\");\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(newICR);\n                _requireNewICRisAboveOldICR(newICR, oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(newICR, _vars.MCR);\n            uint256 newTCR = _getNewTCRFromTroveChange(\n                totalPricedCollateral,\n                totalDebt,\n                _vars.collChange * _vars.price,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR, uint256 MCR) internal pure {\n        require(_newICR >= MCR, \"BorrowerOps: An operation that would result in ICR < MCR is not permitted\");\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR >= CCR, \"BorrowerOps: Operation must leave trove with ICR >= CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(_newICR >= _oldICR, \"BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode\");\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(_newTCR >= CCR, \"BorrowerOps: An operation that would result in TCR < CCR is not permitted\");\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal view {\n        require(_netDebt >= minNetDebt, \"BorrowerOps: Trove's net debt must be greater than minimum\");\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal pure {\n        require(_maxFeePercentage <= DECIMAL_PRECISION, \"Max fee percentage must less than or equal to 100%\");\n    }\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease,\n        uint256 _price\n    ) internal pure returns (uint256) {\n        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(\n            _coll,\n            _debt,\n            _collChange,\n            _isCollIncrease,\n            _debtChange,\n            _isDebtIncrease\n        );\n\n        uint256 newICR = PrismaMath._computeCR(newColl, newDebt, _price);\n        return newICR;\n    }\n\n    function _getNewTroveAmounts(\n        uint256 _coll,\n        uint256 _debt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256, uint256) {\n        uint256 newColl = _coll;\n        uint256 newDebt = _debt;\n\n        newColl = _isCollIncrease ? _coll + _collChange : _coll - _collChange;\n        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;\n\n        return (newColl, newDebt);\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 totalColl,\n        uint256 totalDebt,\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        totalDebt = _isDebtIncrease ? totalDebt + _debtChange : totalDebt - _debtChange;\n        totalColl = _isCollIncrease ? totalColl + _collChange : totalColl - _collChange;\n\n        uint256 newTCR = PrismaMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function _getTCRData(\n        SystemBalances memory balances\n    ) internal pure returns (uint256 amount, uint256 totalPricedCollateral, uint256 totalDebt) {\n        uint256 loopEnd = balances.collaterals.length;\n        for (uint256 i; i < loopEnd; ) {\n            totalPricedCollateral += (balances.collaterals[i] * balances.prices[i]);\n            totalDebt += balances.debts[i];\n            unchecked {\n                ++i;\n            }\n        }\n        amount = PrismaMath._computeCR(totalPricedCollateral, totalDebt);\n\n        return (amount, totalPricedCollateral, totalDebt);\n    }\n\n    function _getCollateralAndTCRData(\n        ITroveManager troveManager\n    )\n        internal\n        returns (\n            IERC20 collateralToken,\n            uint256 price,\n            uint256 totalPricedCollateral,\n            uint256 totalDebt,\n            bool isRecoveryMode\n        )\n    {\n        TroveManagerData storage t = troveManagersData[troveManager];\n        uint256 index;\n        (collateralToken, index) = (t.collateralToken, t.index);\n\n        require(address(collateralToken) != address(0), \"Collateral not enabled\");\n\n        uint256 amount;\n        SystemBalances memory balances = fetchBalances();\n        (amount, totalPricedCollateral, totalDebt) = _getTCRData(balances);\n        isRecoveryMode = checkRecoveryMode(amount);\n\n        return (collateralToken, balances.prices[index], totalPricedCollateral, totalDebt, isRecoveryMode);\n    }\n\n    function getGlobalSystemBalances() external returns (uint256 totalPricedCollateral, uint256 totalDebt) {\n        SystemBalances memory balances = fetchBalances();\n        (, totalPricedCollateral, totalDebt) = _getTCRData(balances);\n    }\n}\n"
6     },
7     "SafeERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"draft-IERC20Permit.sol\";\nimport \"Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
9     },
10     "IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
12     },
13     "draft-IERC20Permit.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
15     },
16     "Address.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
18     },
19     "ITroveManager.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ITroveManager {\n    event BaseRateUpdated(uint256 _baseRate);\n    event CollateralSent(address _to, uint256 _amount);\n    event LTermsUpdated(uint256 _L_collateral, uint256 _L_debt);\n    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);\n    event Redemption(\n        uint256 _attemptedDebtAmount,\n        uint256 _actualDebtAmount,\n        uint256 _collateralSent,\n        uint256 _collateralFee\n    );\n    event RewardClaimed(address indexed account, address indexed recipient, uint256 claimed);\n    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\n    event TotalStakesUpdated(uint256 _newTotalStakes);\n    event TroveIndexUpdated(address _borrower, uint256 _newIndex);\n    event TroveSnapshotsUpdated(uint256 _L_collateral, uint256 _L_debt);\n    event TroveUpdated(address indexed _borrower, uint256 _debt, uint256 _coll, uint256 _stake, uint8 _operation);\n\n    function addCollateralSurplus(address borrower, uint256 collSurplus) external;\n\n    function applyPendingRewards(address _borrower) external returns (uint256 coll, uint256 debt);\n\n    function claimCollateral(address _receiver) external;\n\n    function claimReward(address receiver) external returns (uint256);\n\n    function closeTrove(address _borrower, address _receiver, uint256 collAmount, uint256 debtAmount) external;\n\n    function closeTroveByLiquidation(address _borrower) external;\n\n    function collectInterests() external;\n\n    function decayBaseRateAndGetBorrowingFee(uint256 _debt) external returns (uint256);\n\n    function decreaseDebtAndSendCollateral(address account, uint256 debt, uint256 coll) external;\n\n    function fetchPrice() external returns (uint256);\n\n    function finalizeLiquidation(\n        address _liquidator,\n        uint256 _debt,\n        uint256 _coll,\n        uint256 _collSurplus,\n        uint256 _debtGasComp,\n        uint256 _collGasComp\n    ) external;\n\n    function getEntireSystemBalances() external returns (uint256, uint256, uint256);\n\n    function movePendingTroveRewardsToActiveBalances(uint256 _debt, uint256 _collateral) external;\n\n    function notifyRegisteredId(uint256[] calldata _assignedIds) external returns (bool);\n\n    function openTrove(\n        address _borrower,\n        uint256 _collateralAmount,\n        uint256 _compositeDebt,\n        uint256 NICR,\n        address _upperHint,\n        address _lowerHint,\n        bool _isRecoveryMode\n    ) external returns (uint256 stake, uint256 arrayIndex);\n\n    function redeemCollateral(\n        uint256 _debtAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint256 _partialRedemptionHintNICR,\n        uint256 _maxIterations,\n        uint256 _maxFeePercentage\n    ) external;\n\n    function setAddresses(address _priceFeedAddress, address _sortedTrovesAddress, address _collateralToken) external;\n\n    function setParameters(\n        uint256 _minuteDecayFactor,\n        uint256 _redemptionFeeFloor,\n        uint256 _maxRedemptionFee,\n        uint256 _borrowingFeeFloor,\n        uint256 _maxBorrowingFee,\n        uint256 _interestRateInBPS,\n        uint256 _maxSystemDebt,\n        uint256 _MCR\n    ) external;\n\n    function setPaused(bool _paused) external;\n\n    function setPriceFeed(address _priceFeedAddress) external;\n\n    function startSunset() external;\n\n    function updateBalances() external;\n\n    function updateTroveFromAdjustment(\n        bool _isRecoveryMode,\n        bool _isDebtIncrease,\n        uint256 _debtChange,\n        uint256 _netDebtChange,\n        bool _isCollIncrease,\n        uint256 _collChange,\n        address _upperHint,\n        address _lowerHint,\n        address _borrower,\n        address _receiver\n    ) external returns (uint256, uint256, uint256);\n\n    function vaultClaimReward(address claimant, address) external returns (uint256);\n\n    function BOOTSTRAP_PERIOD() external view returns (uint256);\n\n    function CCR() external view returns (uint256);\n\n    function DEBT_GAS_COMPENSATION() external view returns (uint256);\n\n    function DECIMAL_PRECISION() external view returns (uint256);\n\n    function L_collateral() external view returns (uint256);\n\n    function L_debt() external view returns (uint256);\n\n    function MAX_INTEREST_RATE_IN_BPS() external view returns (uint256);\n\n    function MCR() external view returns (uint256);\n\n    function PERCENT_DIVISOR() external view returns (uint256);\n\n    function PRISMA_CORE() external view returns (address);\n\n    function SUNSETTING_INTEREST_RATE() external view returns (uint256);\n\n    function Troves(\n        address\n    )\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 coll,\n            uint256 stake,\n            uint8 status,\n            uint128 arrayIndex,\n            uint256 activeInterestIndex\n        );\n\n    function accountLatestMint(address) external view returns (uint32 amount, uint32 week, uint32 day);\n\n    function activeInterestIndex() external view returns (uint256);\n\n    function baseRate() external view returns (uint256);\n\n    function borrowerOperationsAddress() external view returns (address);\n\n    function borrowingFeeFloor() external view returns (uint256);\n\n    function claimableReward(address account) external view returns (uint256);\n\n    function collateralToken() external view returns (address);\n\n    function dailyMintReward(uint256) external view returns (uint256);\n\n    function debtToken() external view returns (address);\n\n    function defaultedCollateral() external view returns (uint256);\n\n    function defaultedDebt() external view returns (uint256);\n\n    function emissionId() external view returns (uint16 debt, uint16 minting);\n\n    function getBorrowingFee(uint256 _debt) external view returns (uint256);\n\n    function getBorrowingFeeWithDecay(uint256 _debt) external view returns (uint256);\n\n    function getBorrowingRate() external view returns (uint256);\n\n    function getBorrowingRateWithDecay() external view returns (uint256);\n\n    function getCurrentICR(address _borrower, uint256 _price) external view returns (uint256);\n\n    function getEntireDebtAndColl(\n        address _borrower\n    ) external view returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollateralReward);\n\n    function getEntireSystemColl() external view returns (uint256);\n\n    function getEntireSystemDebt() external view returns (uint256);\n\n    function getNominalICR(address _borrower) external view returns (uint256);\n\n    function getPendingCollAndDebtRewards(address _borrower) external view returns (uint256, uint256);\n\n    function getRedemptionFeeWithDecay(uint256 _collateralDrawn) external view returns (uint256);\n\n    function getRedemptionRate() external view returns (uint256);\n\n    function getRedemptionRateWithDecay() external view returns (uint256);\n\n    function getTotalActiveCollateral() external view returns (uint256);\n\n    function getTotalActiveDebt() external view returns (uint256);\n\n    function getTotalMints(uint256 week) external view returns (uint32[7] memory);\n\n    function getTroveCollAndDebt(address _borrower) external view returns (uint256 coll, uint256 debt);\n\n    function getTroveFromTroveOwnersArray(uint256 _index) external view returns (address);\n\n    function getTroveOwnersCount() external view returns (uint256);\n\n    function getTroveStake(address _borrower) external view returns (uint256);\n\n    function getTroveStatus(address _borrower) external view returns (uint256);\n\n    function getWeek() external view returns (uint256 week);\n\n    function getWeekAndDay() external view returns (uint256, uint256);\n\n    function guardian() external view returns (address);\n\n    function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function interestPayable() external view returns (uint256);\n\n    function interestRate() external view returns (uint256);\n\n    function lastActiveIndexUpdate() external view returns (uint256);\n\n    function lastCollateralError_Redistribution() external view returns (uint256);\n\n    function lastDebtError_Redistribution() external view returns (uint256);\n\n    function lastFeeOperationTime() external view returns (uint256);\n\n    function lastUpdate() external view returns (uint32);\n\n    function liquidationManager() external view returns (address);\n\n    function maxBorrowingFee() external view returns (uint256);\n\n    function maxRedemptionFee() external view returns (uint256);\n\n    function maxSystemDebt() external view returns (uint256);\n\n    function minuteDecayFactor() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function paused() external view returns (bool);\n\n    function periodFinish() external view returns (uint32);\n\n    function priceFeed() external view returns (address);\n\n    function redemptionFeeFloor() external view returns (uint256);\n\n    function rewardIntegral() external view returns (uint256);\n\n    function rewardIntegralFor(address) external view returns (uint256);\n\n    function rewardRate() external view returns (uint128);\n\n    function rewardSnapshots(address) external view returns (uint256 collateral, uint256 debt);\n\n    function sortedTroves() external view returns (address);\n\n    function sunsetting() external view returns (bool);\n\n    function surplusBalances(address) external view returns (uint256);\n\n    function systemDeploymentTime() external view returns (uint256);\n\n    function totalCollateralSnapshot() external view returns (uint256);\n\n    function totalStakes() external view returns (uint256);\n\n    function totalStakesSnapshot() external view returns (uint256);\n\n    function vault() external view returns (address);\n}\n"
21     },
22     "IDebtToken.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IDebtToken {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint256 _amount);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint256 _amount);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint256 _minDstGas);\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function burn(address _account, uint256 _amount) external;\n\n    function burnWithGasCompensation(address _account, uint256 _amount) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function enableTroveManager(address _troveManager) external;\n\n    function flashLoan(address receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function mintWithGasCompensation(address _account, uint256 _amount) external returns (bool);\n\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function renounceOwnership() external;\n\n    function returnFromPool(address _poolAddress, address _receiver, uint256 _amount) external;\n\n    function sendToSP(address _sender, uint256 _amount) external;\n\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint256 _minGas) external;\n\n    function setPayloadSizeLimit(uint16 _dstChainId, uint256 _size) external;\n\n    function setPrecrime(address _precrime) external;\n\n    function setReceiveVersion(uint16 _version) external;\n\n    function setSendVersion(uint16 _version) external;\n\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _path) external;\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external;\n\n    function setUseCustomAdapterParams(bool _useCustomAdapterParams) external;\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function transferOwnership(address newOwner) external;\n\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external payable;\n\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        address _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    function DEBT_GAS_COMPENSATION() external view returns (uint256);\n\n    function DEFAULT_PAYLOAD_SIZE_LIMIT() external view returns (uint256);\n\n    function FLASH_LOAN_FEE() external view returns (uint256);\n\n    function NO_EXTRA_GAS() external view returns (uint256);\n\n    function PT_SEND() external view returns (uint16);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function borrowerOperationsAddress() external view returns (address);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function domainSeparator() external view returns (bytes32);\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint256 _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n    function factory() external view returns (address);\n\n    function failedMessages(uint16, bytes calldata, uint64) external view returns (bytes32);\n\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    function gasPool() external view returns (address);\n\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint256 _configType\n    ) external view returns (bytes memory);\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory);\n\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    function lzEndpoint() external view returns (address);\n\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    function minDstGasLookup(uint16, uint16) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function payloadSizeLimitLookup(uint16) external view returns (uint256);\n\n    function permitTypeHash() external view returns (bytes32);\n\n    function precrime() external view returns (address);\n\n    function stabilityPoolAddress() external view returns (address);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function token() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    function troveManager(address) external view returns (bool);\n\n    function trustedRemoteLookup(uint16) external view returns (bytes memory);\n\n    function useCustomAdapterParams() external view returns (bool);\n\n    function version() external view returns (string memory);\n}\n"
24     },
25     "PrismaBase.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/*\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\n * common functions.\n */\ncontract PrismaBase {\n    uint256 public constant DECIMAL_PRECISION = 1e18;\n\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\n    uint256 public constant CCR = 1500000000000000000; // 150%\n\n    // Amount of debt to be locked in gas pool on opening troves\n    uint256 public immutable DEBT_GAS_COMPENSATION;\n\n    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\n\n    constructor(uint256 _gasCompensation) {\n        DEBT_GAS_COMPENSATION = _gasCompensation;\n    }\n\n    // --- Gas compensation functions ---\n\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\n    function _getCompositeDebt(uint256 _debt) internal view returns (uint256) {\n        return _debt + DEBT_GAS_COMPENSATION;\n    }\n\n    function _getNetDebt(uint256 _debt) internal view returns (uint256) {\n        return _debt - DEBT_GAS_COMPENSATION;\n    }\n\n    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.\n    function _getCollGasCompensation(uint256 _entireColl) internal pure returns (uint256) {\n        return _entireColl / PERCENT_DIVISOR;\n    }\n\n    function _requireUserAcceptsFee(uint256 _fee, uint256 _amount, uint256 _maxFeePercentage) internal pure {\n        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\n    }\n}\n"
27     },
28     "PrismaMath.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nlibrary PrismaMath {\n    uint256 internal constant DECIMAL_PRECISION = 1e18;\n\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\n     *\n     * - Making it “too high” could lead to overflows.\n     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.\n     *\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39,\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\n     *\n     */\n    uint256 internal constant NICR_PRECISION = 1e20;\n\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a < _b) ? _a : _b;\n    }\n\n    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a : _b;\n    }\n\n    /*\n     * Multiply two decimal numbers and use normal rounding rules:\n     * -round product up if 19'th mantissa digit >= 5\n     * -round product down if 19'th mantissa digit < 5\n     *\n     * Used only inside the exponentiation, _decPow().\n     */\n    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\n        uint256 prod_xy = x * y;\n\n        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\n    }\n\n    /*\n     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\n     *\n     * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity.\n     *\n     * Called by two functions that represent time in units of minutes:\n     * 1) TroveManager._calcDecayedBaseRate\n     * 2) CommunityIssuance._getCumulativeIssuanceFraction\n     *\n     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\n     * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\n     *\n     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\n     * negligibly different from just passing the cap, since:\n     *\n     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\n     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\n     */\n    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\n        if (_minutes > 525600000) {\n            _minutes = 525600000;\n        } // cap to avoid overflow\n\n        if (_minutes == 0) {\n            return DECIMAL_PRECISION;\n        }\n\n        uint256 y = DECIMAL_PRECISION;\n        uint256 x = _base;\n        uint256 n = _minutes;\n\n        // Exponentiation-by-squaring\n        while (n > 1) {\n            if (n % 2 == 0) {\n                x = decMul(x, x);\n                n = n / 2;\n            } else {\n                // if (n % 2 != 0)\n                y = decMul(x, y);\n                x = decMul(x, x);\n                n = (n - 1) / 2;\n            }\n        }\n\n        return decMul(x, y);\n    }\n\n    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a >= _b) ? _a - _b : _b - _a;\n    }\n\n    function _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n        if (_debt > 0) {\n            return (_coll * NICR_PRECISION) / _debt;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    function _computeCR(uint256 _coll, uint256 _debt, uint256 _price) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = (_coll * _price) / _debt;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n\n    function _computeCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\n        if (_debt > 0) {\n            uint256 newCollRatio = (_coll) / _debt;\n\n            return newCollRatio;\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2 ** 256 - 1;\n        }\n    }\n}\n"
30     },
31     "PrismaOwnable.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"IPrismaCore.sol\";\n\n/**\n    @title Prisma Ownable\n    @notice Contracts inheriting `PrismaOwnable` have the same owner as `PrismaCore`.\n            The ownership cannot be independently modified or renounced.\n */\ncontract PrismaOwnable {\n    IPrismaCore public immutable PRISMA_CORE;\n\n    constructor(address _prismaCore) {\n        PRISMA_CORE = IPrismaCore(_prismaCore);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == PRISMA_CORE.owner(), \"Only owner\");\n        _;\n    }\n\n    function owner() public view returns (address) {\n        return PRISMA_CORE.owner();\n    }\n\n    function guardian() public view returns (address) {\n        return PRISMA_CORE.guardian();\n    }\n}\n"
33     },
34     "IPrismaCore.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IPrismaCore {\n    event FeeReceiverSet(address feeReceiver);\n    event GuardianSet(address guardian);\n    event NewOwnerAccepted(address oldOwner, address owner);\n    event NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);\n    event NewOwnerRevoked(address owner, address revokedOwner);\n    event Paused();\n    event PriceFeedSet(address priceFeed);\n    event Unpaused();\n\n    function acceptTransferOwnership() external;\n\n    function commitTransferOwnership(address newOwner) external;\n\n    function revokeTransferOwnership() external;\n\n    function setFeeReceiver(address _feeReceiver) external;\n\n    function setGuardian(address _guardian) external;\n\n    function setPaused(bool _paused) external;\n\n    function setPriceFeed(address _priceFeed) external;\n\n    function OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);\n\n    function feeReceiver() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function ownershipTransferDeadline() external view returns (uint256);\n\n    function paused() external view returns (bool);\n\n    function pendingOwner() external view returns (address);\n\n    function priceFeed() external view returns (address);\n\n    function startTime() external view returns (uint256);\n}\n"
36     },
37     "DelegatedOps.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\n/**\n    @title Prisma Delegated Operations\n    @notice Allows delegation to specific contract functionality. Useful for creating\n            wrapper contracts to bundle multiple interactions into a single call.\n\n            Functions that supports delegation should include an `account` input allowing\n            the delegated caller to indicate who they are calling on behalf of. In executing\n            the call, all internal state updates should be applied for `account` and all\n            value transfers should occur to or from the caller.\n\n            For example: a delegated call to `openTrove` should transfer collateral\n            from the caller, create the debt position for `account`, and send newly\n            minted tokens to the caller.\n */\ncontract DelegatedOps {\n    mapping(address owner => mapping(address caller => bool isApproved)) public isApprovedDelegate;\n\n    modifier callerOrDelegated(address _account) {\n        require(msg.sender == _account || isApprovedDelegate[_account][msg.sender], \"Delegate not approved\");\n        _;\n    }\n\n    function setDelegateApproval(address _delegate, bool _isApproved) external {\n        isApprovedDelegate[msg.sender][_delegate] = _isApproved;\n    }\n}\n"
39     }
40   },
41   "settings": {
42     "evmVersion": "paris",
43     "optimizer": {
44       "enabled": true,
45       "runs": 200
46     },
47     "libraries": {
48       "BorrowerOperations.sol": {}
49     },
50     "outputSelection": {
51       "*": {
52         "*": [
53           "evm.bytecode",
54           "evm.deployedBytecode",
55           "devdoc",
56           "userdoc",
57           "metadata",
58           "abi"
59         ]
60       }
61     }
62   }
63 }}