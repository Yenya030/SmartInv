1 /*
2  * This file was generated by EGOLD  (https://egold.trade/)
3  * The complete code could be found at https://github.com/EGOLDtrade/
4  * Copyright (C) 2018 MyWish
5  *
6  *
7  * You should have received a copy of the GNU Lesser General Public License
8  * along with this program. If not, see <http://www.gnu.org/licenses/>.
9  */
10 
11 pragma solidity ^0.4.20;
12 
13 
14 
15 contract ERC20Basic {
16   uint256 public totalSupply;
17   function balanceOf(address who) public view returns (uint256);
18   function transfer(address to, uint256 value) public returns (bool);
19   event Transfer(address indexed from, address indexed to, uint256 value);
20 }
21 
22 
23 
24 /**
25  * @title SafeMath
26  * @dev Math operations with safety checks that throw on error
27  */
28 library SafeMath {
29   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
30     if (a == 0) {
31       return 0;
32     }
33     uint256 c = a * b;
34     assert(c / a == b);
35     return c;
36   }
37 
38   function div(uint256 a, uint256 b) internal pure returns (uint256) {
39     // assert(b > 0); // Solidity automatically throws when dividing by 0
40     uint256 c = a / b;
41     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
42     return c;
43   }
44 
45   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
46     assert(b <= a);
47     return a - b;
48   }
49 
50   function add(uint256 a, uint256 b) internal pure returns (uint256) {
51     uint256 c = a + b;
52     assert(c >= a);
53     return c;
54   }
55 }
56 
57 
58 
59 /**
60  * @title Basic token
61  * @dev Basic version of StandardToken, with no allowances.
62  */
63 contract BasicToken is ERC20Basic {
64   using SafeMath for uint256;
65 
66   mapping(address => uint256) balances;
67 
68   /**
69   * @dev transfer token for a specified address
70   * @param _to The address to transfer to.
71   * @param _value The amount to be transferred.
72   */
73   function transfer(address _to, uint256 _value) public returns (bool) {
74     require(_to != address(0));
75     require(_value <= balances[msg.sender]);
76 
77     // SafeMath.sub will throw if there is not enough balance.
78     balances[msg.sender] = balances[msg.sender].sub(_value);
79     balances[_to] = balances[_to].add(_value);
80     Transfer(msg.sender, _to, _value);
81     return true;
82   }
83 
84   /**
85   * @dev Gets the balance of the specified address.
86   * @param _owner The address to query the the balance of.
87   * @return An uint256 representing the amount owned by the passed address.
88   */
89   function balanceOf(address _owner) public view returns (uint256 balance) {
90     return balances[_owner];
91   }
92 
93 }
94 
95 
96 
97 /**
98  * @title ERC20 interface
99  * @dev see https://github.com/ethereum/EIPs/issues/20
100  */
101 contract ERC20 is ERC20Basic {
102   function allowance(address owner, address spender) public view returns (uint256);
103   function transferFrom(address from, address to, uint256 value) public returns (bool);
104   function approve(address spender, uint256 value) public returns (bool);
105   event Approval(address indexed owner, address indexed spender, uint256 value);
106 }
107 
108 
109 
110 /**
111  * @title Standard ERC20 token
112  *
113  * @dev Implementation of the basic standard token.
114  * @dev https://github.com/ethereum/EIPs/issues/20
115  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
116  */
117 contract StandardToken is ERC20, BasicToken {
118 
119   mapping (address => mapping (address => uint256)) internal allowed;
120 
121 
122   /**
123    * @dev Transfer tokens from one address to another
124    * @param _from address The address which you want to send tokens from
125    * @param _to address The address which you want to transfer to
126    * @param _value uint256 the amount of tokens to be transferred
127    */
128   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
129     require(_to != address(0));
130     require(_value <= balances[_from]);
131     require(_value <= allowed[_from][msg.sender]);
132 
133     balances[_from] = balances[_from].sub(_value);
134     balances[_to] = balances[_to].add(_value);
135     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
136     Transfer(_from, _to, _value);
137     return true;
138   }
139 
140   /**
141    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
142    *
143    * Beware that changing an allowance with this method brings the risk that someone may use both the old
144    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
145    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
146    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
147    * @param _spender The address which will spend the funds.
148    * @param _value The amount of tokens to be spent.
149    */
150   function approve(address _spender, uint256 _value) public returns (bool) {
151     allowed[msg.sender][_spender] = _value;
152     Approval(msg.sender, _spender, _value);
153     return true;
154   }
155 
156   /**
157    * @dev Function to check the amount of tokens that an owner allowed to a spender.
158    * @param _owner address The address which owns the funds.
159    * @param _spender address The address which will spend the funds.
160    * @return A uint256 specifying the amount of tokens still available for the spender.
161    */
162   function allowance(address _owner, address _spender) public view returns (uint256) {
163     return allowed[_owner][_spender];
164   }
165 
166   /**
167    * approve should be called when allowed[_spender] == 0. To increment
168    * allowed value is better to use this function to avoid 2 calls (and wait until
169    * the first transaction is mined)
170    * From MonolithDAO Token.sol
171    */
172   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
173     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
174     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
175     return true;
176   }
177 
178   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
179     uint oldValue = allowed[msg.sender][_spender];
180     if (_subtractedValue > oldValue) {
181       allowed[msg.sender][_spender] = 0;
182     } else {
183       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
184     }
185     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
186     return true;
187   }
188 
189 }
190 
191 
192 
193 /**
194  * @title Ownable
195  * @dev The Ownable contract has an owner address, and provides basic authorization control
196  * functions, this simplifies the implementation of "user permissions".
197  */
198 contract Ownable {
199   address public owner;
200 
201 
202   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
203 
204 
205   /**
206    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
207    * account.
208    */
209   function Ownable() public {
210     owner = msg.sender;
211   }
212 
213 
214   /**
215    * @dev Throws if called by any account other than the owner.
216    */
217   modifier onlyOwner() {
218     require(msg.sender == owner);
219     _;
220   }
221 
222 
223   /**
224    * @dev Allows the current owner to transfer control of the contract to a newOwner.
225    * @param newOwner The address to transfer ownership to.
226    */
227   function transferOwnership(address newOwner) public onlyOwner {
228     require(newOwner != address(0));
229     OwnershipTransferred(owner, newOwner);
230     owner = newOwner;
231   }
232 
233 }
234 
235 
236 
237 /**
238  * @title Mintable token
239  * @dev Simple ERC20 Token example, with mintable token creation
240  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
241  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
242  */
243 
244 contract MintableToken is StandardToken, Ownable {
245   event Mint(address indexed to, uint256 amount);
246   event MintFinished();
247 
248   bool public mintingFinished = false;
249 
250 
251   modifier canMint() {
252     require(!mintingFinished);
253     _;
254   }
255 
256   /**
257    * @dev Function to mint tokens
258    * @param _to The address that will receive the minted tokens.
259    * @param _amount The amount of tokens to mint.
260    * @return A boolean that indicates if the operation was successful.
261    */
262   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
263     totalSupply = totalSupply.add(_amount);
264     balances[_to] = balances[_to].add(_amount);
265     Mint(_to, _amount);
266     Transfer(address(0), _to, _amount);
267     return true;
268   }
269 
270   /**
271    * @dev Function to stop minting new tokens.
272    * @return True if the operation was successful.
273    */
274   function finishMinting() onlyOwner canMint public returns (bool) {
275     mintingFinished = true;
276     MintFinished();
277     return true;
278   }
279 }
280 
281 
282 
283 contract FreezableToken is StandardToken {
284     // freezing chains
285     mapping (bytes32 => uint64) internal chains;
286     // freezing amounts for each chain
287     mapping (bytes32 => uint) internal freezings;
288     // total freezing balance per address
289     mapping (address => uint) internal freezingBalance;
290 
291     event Freezed(address indexed to, uint64 release, uint amount);
292     event Released(address indexed owner, uint amount);
293 
294 
295     /**
296      * @dev Gets the balance of the specified address include freezing tokens.
297      * @param _owner The address to query the the balance of.
298      * @return An uint256 representing the amount owned by the passed address.
299      */
300     function balanceOf(address _owner) public view returns (uint256 balance) {
301         return super.balanceOf(_owner) + freezingBalance[_owner];
302     }
303 
304     /**
305      * @dev Gets the balance of the specified address without freezing tokens.
306      * @param _owner The address to query the the balance of.
307      * @return An uint256 representing the amount owned by the passed address.
308      */
309     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
310         return super.balanceOf(_owner);
311     }
312 
313     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
314         return freezingBalance[_owner];
315     }
316 
317     /**
318      * @dev gets freezing count
319      * @param _addr Address of freeze tokens owner.
320      */
321     function freezingCount(address _addr) public view returns (uint count) {
322         uint64 release = chains[toKey(_addr, 0)];
323         while (release != 0) {
324             count ++;
325             release = chains[toKey(_addr, release)];
326         }
327     }
328 
329     /**
330      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
331      * @param _addr Address of freeze tokens owner.
332      * @param _index Freezing portion index. It ordered by release date descending.
333      */
334     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
335         for (uint i = 0; i < _index + 1; i ++) {
336             _release = chains[toKey(_addr, _release)];
337             if (_release == 0) {
338                 return;
339             }
340         }
341         _balance = freezings[toKey(_addr, _release)];
342     }
343 
344     /**
345      * @dev freeze your tokens to the specified address.
346      *      Be careful, gas usage is not deterministic,
347      *      and depends on how many freezes _to address already has.
348      * @param _to Address to which token will be freeze.
349      * @param _amount Amount of token to freeze.
350      * @param _until Release date, must be in future.
351      */
352     function freezeTo(address _to, uint _amount, uint64 _until) public {
353         require(_to != address(0));
354         require(_amount <= balances[msg.sender]);
355 
356         balances[msg.sender] = balances[msg.sender].sub(_amount);
357 
358         bytes32 currentKey = toKey(_to, _until);
359         freezings[currentKey] = freezings[currentKey].add(_amount);
360         freezingBalance[_to] = freezingBalance[_to].add(_amount);
361 
362         freeze(_to, _until);
363         Freezed(_to, _until, _amount);
364     }
365 
366     /**
367      * @dev release first available freezing tokens.
368      */
369     function releaseOnce() public {
370         bytes32 headKey = toKey(msg.sender, 0);
371         uint64 head = chains[headKey];
372         require(head != 0);
373         require(uint64(block.timestamp) > head);
374         bytes32 currentKey = toKey(msg.sender, head);
375 
376         uint64 next = chains[currentKey];
377 
378         uint amount = freezings[currentKey];
379         delete freezings[currentKey];
380 
381         balances[msg.sender] = balances[msg.sender].add(amount);
382         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
383 
384         if (next == 0) {
385             delete chains[headKey];
386         }
387         else {
388             chains[headKey] = next;
389             delete chains[currentKey];
390         }
391         Released(msg.sender, amount);
392     }
393 
394     /**
395      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
396      * @return how many tokens was released
397      */
398     function releaseAll() public returns (uint tokens) {
399         uint release;
400         uint balance;
401         (release, balance) = getFreezing(msg.sender, 0);
402         while (release != 0 && block.timestamp > release) {
403             releaseOnce();
404             tokens += balance;
405             (release, balance) = getFreezing(msg.sender, 0);
406         }
407     }
408 
409     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
410         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
411         assembly {
412             result := or(result, mul(_addr, 0x10000000000000000))
413             result := or(result, _release)
414         }
415     }
416 
417     function freeze(address _to, uint64 _until) internal {
418         require(_until > block.timestamp);
419         bytes32 key = toKey(_to, _until);
420         bytes32 parentKey = toKey(_to, uint64(0));
421         uint64 next = chains[parentKey];
422 
423         if (next == 0) {
424             chains[parentKey] = _until;
425             return;
426         }
427 
428         bytes32 nextKey = toKey(_to, next);
429         uint parent;
430 
431         while (next != 0 && _until > next) {
432             parent = next;
433             parentKey = nextKey;
434 
435             next = chains[nextKey];
436             nextKey = toKey(_to, next);
437         }
438 
439         if (_until == next) {
440             return;
441         }
442 
443         if (next != 0) {
444             chains[key] = next;
445         }
446 
447         chains[parentKey] = _until;
448     }
449 }
450 
451 /**
452 * @title Contract that will work with ERC223 tokens.
453 */
454 
455 contract ERC223Receiver {
456     /**
457      * @dev Standard ERC223 function that will handle incoming token transfers.
458      *
459      * @param _from  Token sender address.
460      * @param _value Amount of tokens.
461      * @param _data  Transaction metadata.
462      */
463     function tokenFallback(address _from, uint _value, bytes _data) public;
464 }
465 
466 contract ERC223Basic is ERC20Basic {
467     function transfer(address to, uint value, bytes data) public returns (bool);
468     event Transfer(address indexed from, address indexed to, uint value, bytes data);
469 }
470 
471 
472 contract SuccessfulERC223Receiver is ERC223Receiver {
473     event Invoked(address from, uint value, bytes data);
474 
475     function tokenFallback(address _from, uint _value, bytes _data) public {
476         Invoked(_from, _value, _data);
477     }
478 }
479 
480 contract FailingERC223Receiver is ERC223Receiver {
481     function tokenFallback(address, uint, bytes) public {
482         revert();
483     }
484 }
485 
486 contract ERC223ReceiverWithoutTokenFallback {
487 }
488 
489 /**
490  * @title Burnable Token
491  * @dev Token that can be irreversibly burned (destroyed).
492  */
493 contract BurnableToken is StandardToken {
494 
495     event Burn(address indexed burner, uint256 value);
496 
497     /**
498      * @dev Burns a specific amount of tokens.
499      * @param _value The amount of token to be burned.
500      */
501     function burn(uint256 _value) public {
502         require(_value > 0);
503         require(_value <= balances[msg.sender]);
504         // no need to require value <= totalSupply, since that would imply the
505         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
506 
507         address burner = msg.sender;
508         balances[burner] = balances[burner].sub(_value);
509         totalSupply = totalSupply.sub(_value);
510         Burn(burner, _value);
511     }
512 }
513 
514 
515 
516 /**
517  * @title Pausable
518  * @dev Base contract which allows children to implement an emergency stop mechanism.
519  */
520 contract Pausable is Ownable {
521   event Pause();
522   event Unpause();
523 
524   bool public paused = false;
525 
526 
527   /**
528    * @dev Modifier to make a function callable only when the contract is not paused.
529    */
530   modifier whenNotPaused() {
531     require(!paused);
532     _;
533   }
534 
535   /**
536    * @dev Modifier to make a function callable only when the contract is paused.
537    */
538   modifier whenPaused() {
539     require(paused);
540     _;
541   }
542 
543   /**
544    * @dev called by the owner to pause, triggers stopped state
545    */
546   function pause() onlyOwner whenNotPaused public {
547     paused = true;
548     Pause();
549   }
550 
551   /**
552    * @dev called by the owner to unpause, returns to normal state
553    */
554   function unpause() onlyOwner whenPaused public {
555     paused = false;
556     Unpause();
557   }
558 }
559 
560 
561 
562 contract FreezableMintableToken is FreezableToken, MintableToken {
563     /**
564      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
565      *      Be careful, gas usage is not deterministic,
566      *      and depends on how many freezes _to address already has.
567      * @param _to Address to which token will be freeze.
568      * @param _amount Amount of token to mint and freeze.
569      * @param _until Release date, must be in future.
570      * @return A boolean that indicates if the operation was successful.
571      */
572     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
573         totalSupply = totalSupply.add(_amount);
574 
575         bytes32 currentKey = toKey(_to, _until);
576         freezings[currentKey] = freezings[currentKey].add(_amount);
577         freezingBalance[_to] = freezingBalance[_to].add(_amount);
578 
579         freeze(_to, _until);
580         Mint(_to, _amount);
581         Freezed(_to, _until, _amount);
582         return true;
583     }
584 }
585 
586 contract Consts {
587     uint constant TOKEN_DECIMALS = 18;
588     uint8 constant TOKEN_DECIMALS_UINT8 = 18;
589     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
590 
591     string constant TOKEN_NAME = "EGOLD";
592     string constant TOKEN_SYMBOL = "EGD";
593     bool constant PAUSED = false;
594     address constant TARGET_USER = 0x8f71659fb57E6C6Be3Ab563D0dD45101235ae762;
595     
596     bool constant CONTINUE_MINTING = false;
597 }
598 
599 
600 
601 
602 /**
603  * @title Reference implementation of the ERC223 standard token.
604  */
605 contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {
606     using SafeMath for uint;
607 
608     /**
609      * @dev Transfer the specified amount of tokens to the specified address.
610      *      Invokes the `tokenFallback` function if the recipient is a contract.
611      *      The token transfer fails if the recipient is a contract
612      *      but does not implement the `tokenFallback` function
613      *      or the fallback function to receive funds.
614      *
615      * @param _to    Receiver address.
616      * @param _value Amount of tokens that will be transferred.
617      * @param _data  Transaction metadata.
618      */
619     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
620         // Standard function transfer similar to ERC20 transfer with no _data .
621         // Added due to backwards compatibility reasons .
622         uint codeLength;
623 
624         assembly {
625             // Retrieve the size of the code on target address, this needs assembly.
626             codeLength := extcodesize(_to)
627         }
628 
629         balances[msg.sender] = balances[msg.sender].sub(_value);
630         balances[_to] = balances[_to].add(_value);
631         if(codeLength > 0) {
632             ERC223Receiver receiver = ERC223Receiver(_to);
633             receiver.tokenFallback(msg.sender, _value, _data);
634         }
635         Transfer(msg.sender, _to, _value, _data);
636         return true;
637     }
638 
639     /**
640      * @dev Transfer the specified amount of tokens to the specified address.
641      *      This function works the same with the previous one
642      *      but doesn't contain `_data` param.
643      *      Added due to backwards compatibility reasons.
644      *
645      * @param _to    Receiver address.
646      * @param _value Amount of tokens that will be transferred.
647      */
648     function transfer(address _to, uint256 _value) public returns (bool) {
649         bytes memory empty;
650         return transfer(_to, _value, empty);
651     }
652 }
653 
654 
655 contract EGOLD is Consts, FreezableMintableToken, BurnableToken, Pausable
656     
657 {
658     
659     event Initialized();
660     bool public initialized = false;
661 
662     function MainToken() public {
663         init();
664         transferOwnership(TARGET_USER);
665     }
666 
667     function init() private {
668         require(!initialized);
669         initialized = true;
670 
671         if (PAUSED) {
672             pause();
673         }
674 
675         
676         address[1] memory addresses = [address(0x8f71659fb57E6C6Be3Ab563D0dD45101235ae762)];
677         uint[1] memory amounts = [uint(100000000000000000000000000)];
678         uint64[1] memory freezes = [uint64(0)];
679 
680         for (uint i = 0; i < addresses.length; i++) {
681             if (freezes[i] == 0) {
682                 mint(addresses[i], amounts[i]);
683             } else {
684                 mintAndFreeze(addresses[i], amounts[i], freezes[i]);
685             }
686         }
687         
688 
689         if (!CONTINUE_MINTING) {
690             finishMinting();
691         }
692 
693         Initialized();
694     }
695     
696 
697     function name() pure public returns (string _name) {
698         return TOKEN_NAME;
699     }
700 
701     function symbol() pure public returns (string _symbol) {
702         return TOKEN_SYMBOL;
703     }
704 
705     function decimals() pure public returns (uint8 _decimals) {
706         return TOKEN_DECIMALS_UINT8;
707     }
708 
709     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
710         require(!paused);
711         return super.transferFrom(_from, _to, _value);
712     }
713 
714     function transfer(address _to, uint256 _value) public returns (bool _success) {
715         require(!paused);
716         return super.transfer(_to, _value);
717     }
718 }