1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/ForgeStaking.sol": {
5       "content": "//SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * Staking Contract:\r\n * 1- holders of Radiate token can stake their tokens in this contract and receive an APY of 180%\r\n * 2- rewards are paid from staking vault\r\n */\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\npragma solidity 0.8.8;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ForgeStaking is Ownable, DSMath {\r\n    //  So we said were doing the tier system, so for the first tier no time limit, 2nd is 7 days, 3rd is 14 days, 4th is 30 days\r\n    // ex : No unstake limit : 50% APY , 7 days : 75% APY , 14 days : 100% APY , 30 days : 160% APY ?\r\n    //On the dapp/website for staking call the tiers of staking : 1. Electromagnetic Staking, 2. Neutron Staking, 3. Beta Staking, 4. Alpha Staking\r\n    struct Pool {\r\n        uint256 Id;\r\n        uint256 APY;\r\n        uint256 MinTime;\r\n    }\r\n\r\n    struct StakeProfile {\r\n        uint256 totalStaked;\r\n        uint256 stakeEnd;\r\n        uint256 stakeId;\r\n        uint256 paidRewards;\r\n        uint256 stakeStart;\r\n    }\r\n\r\n    //Pool Electromagnetic\r\n    Pool private Bronze = Pool(0, 50, 0);\r\n    //Pool Neutron\r\n    Pool private Gold = Pool(0, 75, 7 days);\r\n    //Pool Beta\r\n    Pool private Platinum = Pool(0, 100, 14 days);\r\n    //Pool Alpha\r\n    Pool private Diamond = Pool(0, 160, 30 days);\r\n\r\n    mapping(uint256=>Pool) Pools;\r\n\r\n    //Staking Settings\r\n    IERC20 public stakingToken;\r\n    address public stakingVault;\r\n\r\n    //Stakers\r\n    uint256 public totalStaked;\r\n    mapping(uint256=>mapping(address=>StakeProfile)) stakers;\r\n\r\n\r\n    constructor() {\r\n        Pools[0] = Bronze;\r\n        Pools[1] = Gold;\r\n        Pools[2] = Platinum;\r\n        Pools[3] = Diamond;\r\n    }\r\n\r\n\r\n    function stake(uint256 _stakeNumber, uint256 poolId) external {\r\n        //Validating...\r\n        require(_stakeNumber > 0, \"can not stake 0 tokens!\");\r\n        require(poolId < 4, \"Invalid Pool!\");\r\n\r\n        //Getting corresponding stake pool\r\n        Pool memory targetPool = Pools[poolId];\r\n\r\n        //updating staker profile:\r\n        StakeProfile memory profile = stakers[poolId][msg.sender];\r\n        //Adding tokens to staker profile\r\n        profile.totalStaked += _stakeNumber;\r\n        //Setting stake end time but first making sure that we are not overwriting it!\r\n        if(profile.stakeEnd == 0){\r\n            profile.stakeEnd = block.timestamp + targetPool.MinTime;\r\n        }\r\n        //Setting stake start time if not already set\r\n        if(profile.stakeStart == 0){\r\n            profile.stakeStart = block.timestamp;\r\n        }\r\n        //setting stake Id\r\n        profile.stakeId = poolId;\r\n \r\n        stakers[poolId][msg.sender] = profile;\r\n\r\n        //Transfering tokens and increasing total staked amount\r\n        totalStaked += _stakeNumber;\r\n        stakingToken.transferFrom(msg.sender, address(this), _stakeNumber);\r\n    }\r\n\r\n\r\n    function unstake(uint256 _unstakeNumber, uint256 poolId) external {\r\n        //getting corresponding stake profile\r\n        StakeProfile memory profile = stakers[poolId][msg.sender];\r\n\r\n        //Validating\r\n        require(profile.totalStaked >= _unstakeNumber, \"Can't unstake more than balance.\");\r\n        require(block.timestamp >= profile.stakeEnd, \"Can't unstake before end time!\");\r\n        require(poolId < 4, \"Invalid Pool!\");\r\n\r\n        //calculating rewards if there is any\r\n        uint256 totalRewards = getRewards(msg.sender, poolId);\r\n\r\n        //Updating staker profile\r\n        //- Reducing unstake amount\r\n        profile.totalStaked -= _unstakeNumber;\r\n\r\n        if(totalRewards > 0){\r\n            profile.paidRewards += totalRewards;\r\n        }\r\n\r\n        //- Reseting time if unstaked all\r\n        if(profile.totalStaked == 0){\r\n            profile.stakeEnd = 0;\r\n            profile.stakeStart = 0;\r\n            profile.paidRewards = 0;\r\n        }\r\n        //- Writing updated profile to storage\r\n        stakers[poolId][msg.sender] = profile;\r\n\r\n        //- Reducing from total staked\r\n        totalStaked -= _unstakeNumber;\r\n\r\n        //sending tokens to staker\r\n        if(stakingToken.balanceOf(stakingVault) >= totalRewards && totalRewards > 0){\r\n            stakingToken.transferFrom(stakingVault, msg.sender, totalRewards);\r\n        }\r\n        stakingToken.transfer(msg.sender, _unstakeNumber);\r\n    }\r\n\r\n    //Setters\r\n    function setStakingVault(address newVault) external onlyOwner{\r\n        stakingVault = newVault;\r\n    }\r\n\r\n    function setStakingToken(address newStakingToken) external onlyOwner{\r\n        stakingToken = IERC20(newStakingToken);\r\n    }\r\n\r\n    //Getters\r\n    function getRewards(address _staker, uint256 poolId) public view returns(uint256){\r\n        //getting corresponding stake profile\r\n        StakeProfile memory profile = stakers[poolId][_staker];\r\n        if(profile.totalStaked == 0){\r\n            return 0;\r\n        }\r\n        uint256 elapsedTime = block.timestamp - profile.stakeStart;\r\n        uint256 apy = Pools[poolId].APY;\r\n        uint256 Interest = calculateInteresetInSeconds(profile.totalStaked, apy, elapsedTime);\r\n        if(Interest > profile.totalStaked + profile.paidRewards){\r\n            return Interest - (profile.totalStaked + profile.paidRewards);\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    //put apy in %, example : 100% == 100, 160% = 160\r\n    function calculateInteresetInSeconds(uint256 principal, uint256 apy, uint256 _seconds) public pure returns(uint256){\r\n        //Calculating the ratio per second\r\n        //ratio per seconds\r\n        uint256 _ratio = ratio(apy);\r\n        //Interest after _seconds\r\n        return accrueInterest(principal, _ratio, _seconds);\r\n    }\r\n\r\n    function ratio(uint256 n) internal pure returns(uint256){\r\n        uint256 numerator = n * 10 ** 25;\r\n        uint256 denominator = 365 * 86400;\r\n        uint256 result = uint256(10 ** 27) + uint256(numerator / denominator);\r\n        return result;\r\n    }\r\n\r\n    function accrueInterest(uint _principal, uint _rate, uint _age) internal pure returns (uint) {\r\n        return rmul(_principal, rpow(_rate, _age));\r\n    }\r\n\r\n    function getStakerProfile(address _staker, uint256 _poolId) public view returns(StakeProfile memory){\r\n        return stakers[_poolId][_staker];\r\n    }\r\n\r\n    function getPoolInfo(uint256 poolId) public view returns(Pool memory){\r\n        return Pools[poolId];\r\n    }\r\n\r\n    function getStakedInPool(address account, uint256 poolId) public view returns(uint256){\r\n        return stakers[poolId][account].totalStaked;\r\n    }\r\n}"
6     },
7     "@openzeppelin/contracts/access/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
12     },
13     "@openzeppelin/contracts/utils/Context.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": false,
20       "runs": 200
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     }
34   }
35 }}