1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 
20 pragma solidity ^0.4.20;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   uint256 public totalSupply;
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
43     if (a == 0) {
44       return 0;
45     }
46     uint256 c = a * b;
47     assert(c / a == b);
48     return c;
49   }
50 
51   function div(uint256 a, uint256 b) internal pure returns (uint256) {
52     // assert(b > 0); // Solidity automatically throws when dividing by 0
53     uint256 c = a / b;
54     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
55     return c;
56   }
57 
58   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
59     assert(b <= a);
60     return a - b;
61   }
62 
63   function add(uint256 a, uint256 b) internal pure returns (uint256) {
64     uint256 c = a + b;
65     assert(c >= a);
66     return c;
67   }
68 }
69 
70 
71 
72 /**
73  * @title Basic token
74  * @dev Basic version of StandardToken, with no allowances.
75  */
76 contract BasicToken is ERC20Basic {
77   using SafeMath for uint256;
78 
79   mapping(address => uint256) balances;
80 
81   /**
82   * @dev transfer token for a specified address
83   * @param _to The address to transfer to.
84   * @param _value The amount to be transferred.
85   */
86   function transfer(address _to, uint256 _value) public returns (bool) {
87     require(_to != address(0));
88     require(_value <= balances[msg.sender]);
89 
90     // SafeMath.sub will throw if there is not enough balance.
91     balances[msg.sender] = balances[msg.sender].sub(_value);
92     balances[_to] = balances[_to].add(_value);
93     Transfer(msg.sender, _to, _value);
94     return true;
95   }
96 
97   /**
98   * @dev Gets the balance of the specified address.
99   * @param _owner The address to query the the balance of.
100   * @return An uint256 representing the amount owned by the passed address.
101   */
102   function balanceOf(address _owner) public view returns (uint256 balance) {
103     return balances[_owner];
104   }
105 
106 }
107 
108 
109 
110 /**
111  * @title ERC20 interface
112  * @dev see https://github.com/ethereum/EIPs/issues/20
113  */
114 contract ERC20 is ERC20Basic {
115   function allowance(address owner, address spender) public view returns (uint256);
116   function transferFrom(address from, address to, uint256 value) public returns (bool);
117   function approve(address spender, uint256 value) public returns (bool);
118   event Approval(address indexed owner, address indexed spender, uint256 value);
119 }
120 
121 
122 
123 /**
124  * @title Standard ERC20 token
125  *
126  * @dev Implementation of the basic standard token.
127  * @dev https://github.com/ethereum/EIPs/issues/20
128  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
129  */
130 contract StandardToken is ERC20, BasicToken {
131 
132   mapping (address => mapping (address => uint256)) internal allowed;
133 
134 
135   /**
136    * @dev Transfer tokens from one address to another
137    * @param _from address The address which you want to send tokens from
138    * @param _to address The address which you want to transfer to
139    * @param _value uint256 the amount of tokens to be transferred
140    */
141   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
142     require(_to != address(0));
143     require(_value <= balances[_from]);
144     require(_value <= allowed[_from][msg.sender]);
145 
146     balances[_from] = balances[_from].sub(_value);
147     balances[_to] = balances[_to].add(_value);
148     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
149     Transfer(_from, _to, _value);
150     return true;
151   }
152 
153   /**
154    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
155    *
156    * Beware that changing an allowance with this method brings the risk that someone may use both the old
157    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
158    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
159    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
160    * @param _spender The address which will spend the funds.
161    * @param _value The amount of tokens to be spent.
162    */
163   function approve(address _spender, uint256 _value) public returns (bool) {
164     allowed[msg.sender][_spender] = _value;
165     Approval(msg.sender, _spender, _value);
166     return true;
167   }
168 
169   /**
170    * @dev Function to check the amount of tokens that an owner allowed to a spender.
171    * @param _owner address The address which owns the funds.
172    * @param _spender address The address which will spend the funds.
173    * @return A uint256 specifying the amount of tokens still available for the spender.
174    */
175   function allowance(address _owner, address _spender) public view returns (uint256) {
176     return allowed[_owner][_spender];
177   }
178 
179   /**
180    * approve should be called when allowed[_spender] == 0. To increment
181    * allowed value is better to use this function to avoid 2 calls (and wait until
182    * the first transaction is mined)
183    * From MonolithDAO Token.sol
184    */
185   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
186     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
187     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
188     return true;
189   }
190 
191   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
192     uint oldValue = allowed[msg.sender][_spender];
193     if (_subtractedValue > oldValue) {
194       allowed[msg.sender][_spender] = 0;
195     } else {
196       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
197     }
198     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
199     return true;
200   }
201 
202 }
203 
204 
205 
206 /**
207  * @title Ownable
208  * @dev The Ownable contract has an owner address, and provides basic authorization control
209  * functions, this simplifies the implementation of "user permissions".
210  */
211 contract Ownable {
212   address public owner;
213 
214 
215   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
216 
217 
218   /**
219    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
220    * account.
221    */
222   function Ownable() public {
223     owner = msg.sender;
224   }
225 
226 
227   /**
228    * @dev Throws if called by any account other than the owner.
229    */
230   modifier onlyOwner() {
231     require(msg.sender == owner);
232     _;
233   }
234 
235 
236   /**
237    * @dev Allows the current owner to transfer control of the contract to a newOwner.
238    * @param newOwner The address to transfer ownership to.
239    */
240   function transferOwnership(address newOwner) public onlyOwner {
241     require(newOwner != address(0));
242     OwnershipTransferred(owner, newOwner);
243     owner = newOwner;
244   }
245 
246 }
247 
248 
249 
250 /**
251  * @title Mintable token
252  * @dev Simple ERC20 Token example, with mintable token creation
253  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
254  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
255  */
256 
257 contract MintableToken is StandardToken, Ownable {
258   event Mint(address indexed to, uint256 amount);
259   event MintFinished();
260 
261   bool public mintingFinished = false;
262 
263 
264   modifier canMint() {
265     require(!mintingFinished);
266     _;
267   }
268 
269   /**
270    * @dev Function to mint tokens
271    * @param _to The address that will receive the minted tokens.
272    * @param _amount The amount of tokens to mint.
273    * @return A boolean that indicates if the operation was successful.
274    */
275   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
276     totalSupply = totalSupply.add(_amount);
277     balances[_to] = balances[_to].add(_amount);
278     Mint(_to, _amount);
279     Transfer(address(0), _to, _amount);
280     return true;
281   }
282 
283   /**
284    * @dev Function to stop minting new tokens.
285    * @return True if the operation was successful.
286    */
287   function finishMinting() onlyOwner canMint public returns (bool) {
288     mintingFinished = true;
289     MintFinished();
290     return true;
291   }
292 }
293 
294 
295 /**
296  * @title Crowdsale
297  * @dev Crowdsale is a base contract for managing a token crowdsale.
298  * Crowdsales have a start and end timestamps, where investors can make
299  * token purchases and the crowdsale will assign them tokens based
300  * on a token per ETH rate. Funds collected are forwarded to a wallet
301  * as they arrive.
302  */
303 contract Crowdsale {
304   using SafeMath for uint256;
305 
306   // The token being sold
307   MintableToken public token;
308 
309   // start and end timestamps where investments are allowed (both inclusive)
310   uint256 public startTime;
311   uint256 public endTime;
312 
313   // address where funds are collected
314   address public wallet;
315 
316   // how many token units a buyer gets per wei
317   uint256 public rate;
318 
319   // amount of raised money in wei
320   uint256 public weiRaised;
321 
322   /**
323    * event for token purchase logging
324    * @param purchaser who paid for the tokens
325    * @param beneficiary who got the tokens
326    * @param value weis paid for purchase
327    * @param amount amount of tokens purchased
328    */
329   event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
330 
331 
332   function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
333     require(_startTime >= now);
334     require(_endTime >= _startTime);
335     require(_rate > 0);
336     require(_wallet != address(0));
337 
338     token = createTokenContract();
339     startTime = _startTime;
340     endTime = _endTime;
341     rate = _rate;
342     wallet = _wallet;
343   }
344 
345   // creates the token to be sold.
346   // override this method to have crowdsale of a specific mintable token.
347   function createTokenContract() internal returns (MintableToken) {
348     return new MintableToken();
349   }
350 
351 
352   // fallback function can be used to buy tokens
353   function () external payable {
354     buyTokens(msg.sender);
355   }
356 
357   // low level token purchase function
358   function buyTokens(address beneficiary) public payable {
359     require(beneficiary != address(0));
360     require(validPurchase());
361 
362     uint256 weiAmount = msg.value;
363 
364     // calculate token amount to be created
365     uint256 tokens = weiAmount.mul(rate);
366 
367     // update state
368     weiRaised = weiRaised.add(weiAmount);
369 
370     token.mint(beneficiary, tokens);
371     TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
372 
373     forwardFunds();
374   }
375 
376   // send ether to the fund collection wallet
377   // override to create custom fund forwarding mechanisms
378   function forwardFunds() internal {
379     wallet.transfer(msg.value);
380   }
381 
382   // @return true if the transaction can buy tokens
383   function validPurchase() internal view returns (bool) {
384     bool withinPeriod = now >= startTime && now <= endTime;
385     bool nonZeroPurchase = msg.value != 0;
386     return withinPeriod && nonZeroPurchase;
387   }
388 
389   // @return true if crowdsale event has ended
390   function hasEnded() public view returns (bool) {
391     return now > endTime;
392   }
393 
394 
395 }
396 
397 
398 /**
399  * @title FinalizableCrowdsale
400  * @dev Extension of Crowdsale where an owner can do extra work
401  * after finishing.
402  */
403 contract FinalizableCrowdsale is Crowdsale, Ownable {
404   using SafeMath for uint256;
405 
406   bool public isFinalized = false;
407 
408   event Finalized();
409 
410   /**
411    * @dev Must be called after crowdsale ends, to do some extra finalization
412    * work. Calls the contract's finalization function.
413    */
414   function finalize() onlyOwner public {
415     require(!isFinalized);
416     require(hasEnded());
417 
418     finalization();
419     Finalized();
420 
421     isFinalized = true;
422   }
423 
424   /**
425    * @dev Can be overridden to add finalization logic. The overriding function
426    * should call super.finalization() to ensure the chain of finalization is
427    * executed entirely.
428    */
429   function finalization() internal {
430   }
431 }
432 
433 
434 /**
435  * @title RefundVault
436  * @dev This contract is used for storing funds while a crowdsale
437  * is in progress. Supports refunding the money if crowdsale fails,
438  * and forwarding it if crowdsale is successful.
439  */
440 contract RefundVault is Ownable {
441   using SafeMath for uint256;
442 
443   enum State { Active, Refunding, Closed }
444 
445   mapping (address => uint256) public deposited;
446   address public wallet;
447   State public state;
448 
449   event Closed();
450   event RefundsEnabled();
451   event Refunded(address indexed beneficiary, uint256 weiAmount);
452 
453   function RefundVault(address _wallet) public {
454     require(_wallet != address(0));
455     wallet = _wallet;
456     state = State.Active;
457   }
458 
459   function deposit(address investor) onlyOwner public payable {
460     require(state == State.Active);
461     deposited[investor] = deposited[investor].add(msg.value);
462   }
463 
464   function close() onlyOwner public {
465     require(state == State.Active);
466     state = State.Closed;
467     Closed();
468     wallet.transfer(this.balance);
469   }
470 
471   function enableRefunds() onlyOwner public {
472     require(state == State.Active);
473     state = State.Refunding;
474     RefundsEnabled();
475   }
476 
477   function refund(address investor) public {
478     require(state == State.Refunding);
479     uint256 depositedValue = deposited[investor];
480     deposited[investor] = 0;
481     investor.transfer(depositedValue);
482     Refunded(investor, depositedValue);
483   }
484 }
485 
486 
487 
488 contract FreezableToken is StandardToken {
489     // freezing chains
490     mapping (bytes32 => uint64) internal chains;
491     // freezing amounts for each chain
492     mapping (bytes32 => uint) internal freezings;
493     // total freezing balance per address
494     mapping (address => uint) internal freezingBalance;
495 
496     event Freezed(address indexed to, uint64 release, uint amount);
497     event Released(address indexed owner, uint amount);
498 
499 
500     /**
501      * @dev Gets the balance of the specified address include freezing tokens.
502      * @param _owner The address to query the the balance of.
503      * @return An uint256 representing the amount owned by the passed address.
504      */
505     function balanceOf(address _owner) public view returns (uint256 balance) {
506         return super.balanceOf(_owner) + freezingBalance[_owner];
507     }
508 
509     /**
510      * @dev Gets the balance of the specified address without freezing tokens.
511      * @param _owner The address to query the the balance of.
512      * @return An uint256 representing the amount owned by the passed address.
513      */
514     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
515         return super.balanceOf(_owner);
516     }
517 
518     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
519         return freezingBalance[_owner];
520     }
521 
522     /**
523      * @dev gets freezing count
524      * @param _addr Address of freeze tokens owner.
525      */
526     function freezingCount(address _addr) public view returns (uint count) {
527         uint64 release = chains[toKey(_addr, 0)];
528         while (release != 0) {
529             count ++;
530             release = chains[toKey(_addr, release)];
531         }
532     }
533 
534     /**
535      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
536      * @param _addr Address of freeze tokens owner.
537      * @param _index Freezing portion index. It ordered by release date descending.
538      */
539     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
540         for (uint i = 0; i < _index + 1; i ++) {
541             _release = chains[toKey(_addr, _release)];
542             if (_release == 0) {
543                 return;
544             }
545         }
546         _balance = freezings[toKey(_addr, _release)];
547     }
548 
549     /**
550      * @dev freeze your tokens to the specified address.
551      *      Be careful, gas usage is not deterministic,
552      *      and depends on how many freezes _to address already has.
553      * @param _to Address to which token will be freeze.
554      * @param _amount Amount of token to freeze.
555      * @param _until Release date, must be in future.
556      */
557     function freezeTo(address _to, uint _amount, uint64 _until) public {
558         require(_to != address(0));
559         require(_amount <= balances[msg.sender]);
560 
561         balances[msg.sender] = balances[msg.sender].sub(_amount);
562 
563         bytes32 currentKey = toKey(_to, _until);
564         freezings[currentKey] = freezings[currentKey].add(_amount);
565         freezingBalance[_to] = freezingBalance[_to].add(_amount);
566 
567         freeze(_to, _until);
568         Freezed(_to, _until, _amount);
569     }
570 
571     /**
572      * @dev release first available freezing tokens.
573      */
574     function releaseOnce() public {
575         bytes32 headKey = toKey(msg.sender, 0);
576         uint64 head = chains[headKey];
577         require(head != 0);
578         require(uint64(block.timestamp) > head);
579         bytes32 currentKey = toKey(msg.sender, head);
580 
581         uint64 next = chains[currentKey];
582 
583         uint amount = freezings[currentKey];
584         delete freezings[currentKey];
585 
586         balances[msg.sender] = balances[msg.sender].add(amount);
587         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
588 
589         if (next == 0) {
590             delete chains[headKey];
591         }
592         else {
593             chains[headKey] = next;
594             delete chains[currentKey];
595         }
596         Released(msg.sender, amount);
597     }
598 
599     /**
600      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
601      * @return how many tokens was released
602      */
603     function releaseAll() public returns (uint tokens) {
604         uint release;
605         uint balance;
606         (release, balance) = getFreezing(msg.sender, 0);
607         while (release != 0 && block.timestamp > release) {
608             releaseOnce();
609             tokens += balance;
610             (release, balance) = getFreezing(msg.sender, 0);
611         }
612     }
613 
614     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
615         // WISH masc to increase entropy
616         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
617         assembly {
618             result := or(result, mul(_addr, 0x10000000000000000))
619             result := or(result, _release)
620         }
621     }
622 
623     function freeze(address _to, uint64 _until) internal {
624         require(_until > block.timestamp);
625         bytes32 key = toKey(_to, _until);
626         bytes32 parentKey = toKey(_to, uint64(0));
627         uint64 next = chains[parentKey];
628 
629         if (next == 0) {
630             chains[parentKey] = _until;
631             return;
632         }
633 
634         bytes32 nextKey = toKey(_to, next);
635         uint parent;
636 
637         while (next != 0 && _until > next) {
638             parent = next;
639             parentKey = nextKey;
640 
641             next = chains[nextKey];
642             nextKey = toKey(_to, next);
643         }
644 
645         if (_until == next) {
646             return;
647         }
648 
649         if (next != 0) {
650             chains[key] = next;
651         }
652 
653         chains[parentKey] = _until;
654     }
655 }
656 
657 /**
658 * @title Contract that will work with ERC223 tokens.
659 */
660 
661 contract ERC223Receiver {
662     /**
663      * @dev Standard ERC223 function that will handle incoming token transfers.
664      *
665      * @param _from  Token sender address.
666      * @param _value Amount of tokens.
667      * @param _data  Transaction metadata.
668      */
669     function tokenFallback(address _from, uint _value, bytes _data) public;
670 }
671 
672 contract ERC223Basic is ERC20Basic {
673     function transfer(address to, uint value, bytes data) public returns (bool);
674     event Transfer(address indexed from, address indexed to, uint value, bytes data);
675 }
676 
677 
678 contract SuccessfulERC223Receiver is ERC223Receiver {
679     event Invoked(address from, uint value, bytes data);
680 
681     function tokenFallback(address _from, uint _value, bytes _data) public {
682         Invoked(_from, _value, _data);
683     }
684 }
685 
686 contract FailingERC223Receiver is ERC223Receiver {
687     function tokenFallback(address, uint, bytes) public {
688         revert();
689     }
690 }
691 
692 contract ERC223ReceiverWithoutTokenFallback {
693 }
694 
695 /**
696  * @title Burnable Token
697  * @dev Token that can be irreversibly burned (destroyed).
698  */
699 contract BurnableToken is StandardToken {
700 
701     event Burn(address indexed burner, uint256 value);
702 
703     /**
704      * @dev Burns a specific amount of tokens.
705      * @param _value The amount of token to be burned.
706      */
707     function burn(uint256 _value) public {
708         require(_value > 0);
709         require(_value <= balances[msg.sender]);
710         // no need to require value <= totalSupply, since that would imply the
711         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
712 
713         address burner = msg.sender;
714         balances[burner] = balances[burner].sub(_value);
715         totalSupply = totalSupply.sub(_value);
716         Burn(burner, _value);
717     }
718 }
719 
720 
721 
722 /**
723  * @title Pausable
724  * @dev Base contract which allows children to implement an emergency stop mechanism.
725  */
726 contract Pausable is Ownable {
727   event Pause();
728   event Unpause();
729 
730   bool public paused = false;
731 
732 
733   /**
734    * @dev Modifier to make a function callable only when the contract is not paused.
735    */
736   modifier whenNotPaused() {
737     require(!paused);
738     _;
739   }
740 
741   /**
742    * @dev Modifier to make a function callable only when the contract is paused.
743    */
744   modifier whenPaused() {
745     require(paused);
746     _;
747   }
748 
749   /**
750    * @dev called by the owner to pause, triggers stopped state
751    */
752   function pause() onlyOwner whenNotPaused public {
753     paused = true;
754     Pause();
755   }
756 
757   /**
758    * @dev called by the owner to unpause, returns to normal state
759    */
760   function unpause() onlyOwner whenPaused public {
761     paused = false;
762     Unpause();
763   }
764 }
765 
766 
767 
768 contract FreezableMintableToken is FreezableToken, MintableToken {
769     /**
770      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
771      *      Be careful, gas usage is not deterministic,
772      *      and depends on how many freezes _to address already has.
773      * @param _to Address to which token will be freeze.
774      * @param _amount Amount of token to mint and freeze.
775      * @param _until Release date, must be in future.
776      * @return A boolean that indicates if the operation was successful.
777      */
778     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
779         totalSupply = totalSupply.add(_amount);
780 
781         bytes32 currentKey = toKey(_to, _until);
782         freezings[currentKey] = freezings[currentKey].add(_amount);
783         freezingBalance[_to] = freezingBalance[_to].add(_amount);
784 
785         freeze(_to, _until);
786         Mint(_to, _amount);
787         Freezed(_to, _until, _amount);
788         return true;
789     }
790 }
791 
792 contract Consts {
793     uint constant TOKEN_DECIMALS = 8;
794     uint8 constant TOKEN_DECIMALS_UINT8 = 8;
795     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
796 
797     string constant TOKEN_NAME = "DICO";
798     string constant TOKEN_SYMBOL = "DICO";
799     bool constant PAUSED = true;
800     address constant TARGET_USER = 0x429B892e0e3B66accA6AeAE26A6892a1948d650D;
801     
802     uint constant START_TIME = 1527346800;
803     
804     bool constant CONTINUE_MINTING = true;
805 }
806 
807 
808 
809 
810 /**
811  * @title Reference implementation of the ERC223 standard token.
812  */
813 contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {
814     using SafeMath for uint;
815 
816     /**
817      * @dev Transfer the specified amount of tokens to the specified address.
818      *      Invokes the `tokenFallback` function if the recipient is a contract.
819      *      The token transfer fails if the recipient is a contract
820      *      but does not implement the `tokenFallback` function
821      *      or the fallback function to receive funds.
822      *
823      * @param _to    Receiver address.
824      * @param _value Amount of tokens that will be transferred.
825      * @param _data  Transaction metadata.
826      */
827     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
828         // Standard function transfer similar to ERC20 transfer with no _data .
829         // Added due to backwards compatibility reasons .
830         uint codeLength;
831 
832         assembly {
833             // Retrieve the size of the code on target address, this needs assembly.
834             codeLength := extcodesize(_to)
835         }
836 
837         balances[msg.sender] = balances[msg.sender].sub(_value);
838         balances[_to] = balances[_to].add(_value);
839         if(codeLength > 0) {
840             ERC223Receiver receiver = ERC223Receiver(_to);
841             receiver.tokenFallback(msg.sender, _value, _data);
842         }
843         Transfer(msg.sender, _to, _value, _data);
844         return true;
845     }
846 
847     /**
848      * @dev Transfer the specified amount of tokens to the specified address.
849      *      This function works the same with the previous one
850      *      but doesn't contain `_data` param.
851      *      Added due to backwards compatibility reasons.
852      *
853      * @param _to    Receiver address.
854      * @param _value Amount of tokens that will be transferred.
855      */
856     function transfer(address _to, uint256 _value) public returns (bool) {
857         bytes memory empty;
858         return transfer(_to, _value, empty);
859     }
860 }
861 
862 
863 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
864     
865 {
866     
867 
868     function name() pure public returns (string _name) {
869         return TOKEN_NAME;
870     }
871 
872     function symbol() pure public returns (string _symbol) {
873         return TOKEN_SYMBOL;
874     }
875 
876     function decimals() pure public returns (uint8 _decimals) {
877         return TOKEN_DECIMALS_UINT8;
878     }
879 
880     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
881         require(!paused);
882         return super.transferFrom(_from, _to, _value);
883     }
884 
885     function transfer(address _to, uint256 _value) public returns (bool _success) {
886         require(!paused);
887         return super.transfer(_to, _value);
888     }
889 }
890 
891 
892 
893 
894 /**
895  * @title CappedCrowdsale
896  * @dev Extension of Crowdsale with a max amount of funds raised
897  */
898 contract CappedCrowdsale is Crowdsale {
899   using SafeMath for uint256;
900 
901   uint256 public cap;
902 
903   function CappedCrowdsale(uint256 _cap) public {
904     require(_cap > 0);
905     cap = _cap;
906   }
907 
908   // overriding Crowdsale#validPurchase to add extra cap logic
909   // @return true if investors can buy at the moment
910   function validPurchase() internal view returns (bool) {
911     bool withinCap = weiRaised.add(msg.value) <= cap;
912     return super.validPurchase() && withinCap;
913   }
914 
915   // overriding Crowdsale#hasEnded to add cap logic
916   // @return true if crowdsale event has ended
917   function hasEnded() public view returns (bool) {
918     bool capReached = weiRaised >= cap;
919     return super.hasEnded() || capReached;
920   }
921 
922 }
923 
924 
925 
926 /**
927  * @title RefundableCrowdsale
928  * @dev Extension of Crowdsale contract that adds a funding goal, and
929  * the possibility of users getting a refund if goal is not met.
930  * Uses a RefundVault as the crowdsale's vault.
931  */
932 contract RefundableCrowdsale is FinalizableCrowdsale {
933   using SafeMath for uint256;
934 
935   // minimum amount of funds to be raised in weis
936   uint256 public goal;
937 
938   // refund vault used to hold funds while crowdsale is running
939   RefundVault public vault;
940 
941   function RefundableCrowdsale(uint256 _goal) public {
942     require(_goal > 0);
943     vault = new RefundVault(wallet);
944     goal = _goal;
945   }
946 
947   // We're overriding the fund forwarding from Crowdsale.
948   // In addition to sending the funds, we want to call
949   // the RefundVault deposit function
950   function forwardFunds() internal {
951     vault.deposit.value(msg.value)(msg.sender);
952   }
953 
954   // if crowdsale is unsuccessful, investors can claim refunds here
955   function claimRefund() public {
956     require(isFinalized);
957     require(!goalReached());
958 
959     vault.refund(msg.sender);
960   }
961 
962   // vault finalization task, called when owner calls finalize()
963   function finalization() internal {
964     if (goalReached()) {
965       vault.close();
966     } else {
967       vault.enableRefunds();
968     }
969 
970     super.finalization();
971   }
972 
973   function goalReached() public view returns (bool) {
974     return weiRaised >= goal;
975   }
976 
977 }
978 
979 
980 contract MainCrowdsale is Consts, FinalizableCrowdsale {
981     function hasStarted() public constant returns (bool) {
982         return now >= startTime;
983     }
984 
985     function finalization() internal {
986         super.finalization();
987 
988         if (PAUSED) {
989             MainToken(token).unpause();
990         }
991 
992         if (!CONTINUE_MINTING) {
993             token.finishMinting();
994         }
995 
996         token.transferOwnership(TARGET_USER);
997     }
998 
999     function buyTokens(address beneficiary) public payable {
1000         require(beneficiary != address(0));
1001         require(validPurchase());
1002 
1003         uint256 weiAmount = msg.value;
1004 
1005         // calculate token amount to be created
1006         uint256 tokens = weiAmount.mul(rate).div(1 ether);
1007 
1008         // update state
1009         weiRaised = weiRaised.add(weiAmount);
1010 
1011         token.mint(beneficiary, tokens);
1012         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1013 
1014         forwardFunds();
1015     }
1016 }
1017 
1018 
1019 contract Checkable {
1020     address private serviceAccount;
1021     /**
1022      * Flag means that contract accident already occurs.
1023      */
1024     bool private triggered = false;
1025 
1026     // Occurs when accident happened.
1027     event Triggered(uint balance);
1028 
1029     function Checkable() public {
1030         serviceAccount = msg.sender;
1031     }
1032 
1033     /**
1034      * @dev Replace service account with new one.
1035      * @param _account Valid service account address.
1036      */
1037     function changeServiceAccount(address _account) onlyService public {
1038         assert(_account != 0);
1039         serviceAccount = _account;
1040     }
1041 
1042     /**
1043      * @dev Is caller (sender) service account.
1044      */
1045     function isServiceAccount() view public returns (bool) {
1046         return msg.sender == serviceAccount;
1047     }
1048 
1049     /**
1050      * Public check method.
1051      */
1052     function check() onlyService notTriggered payable public {
1053         if (internalCheck()) {
1054             Triggered(this.balance);
1055             triggered = true;
1056             internalAction();
1057         }
1058     }
1059 
1060     /**
1061      * @dev Do inner check.
1062      * @return bool true of accident triggered, false otherwise.
1063      */
1064     function internalCheck() internal returns (bool);
1065 
1066     /**
1067      * @dev Do inner action if check was success.
1068      */
1069     function internalAction() internal;
1070 
1071     modifier onlyService {
1072         require(msg.sender == serviceAccount);
1073         _;
1074     }
1075 
1076     modifier notTriggered() {
1077         require(!triggered);
1078         _;
1079     }
1080 }
1081 
1082 
1083 contract BonusableCrowdsale is Consts, Crowdsale {
1084 
1085     function buyTokens(address beneficiary) public payable {
1086         require(beneficiary != address(0));
1087         require(validPurchase());
1088 
1089         uint256 weiAmount = msg.value;
1090 
1091         // calculate token amount to be created
1092         uint256 bonusRate = getBonusRate(weiAmount);
1093         uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);
1094 
1095         // update state
1096         weiRaised = weiRaised.add(weiAmount);
1097 
1098         token.mint(beneficiary, tokens);
1099         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1100 
1101         forwardFunds();
1102     }
1103 
1104     function getBonusRate(uint256 weiAmount) internal view returns (uint256) {
1105         uint256 bonusRate = rate;
1106 
1107         
1108         // apply bonus for time & weiRaised
1109         uint[3] memory weiRaisedStartsBoundaries = [uint(0),uint(0),uint(0)];
1110         uint[3] memory weiRaisedEndsBoundaries = [uint(50000000000000000000000),uint(50000000000000000000000),uint(50000000000000000000000)];
1111         uint64[3] memory timeStartsBoundaries = [uint64(1527346800),uint64(1528642740),uint64(1529852340)];
1112         uint64[3] memory timeEndsBoundaries = [uint64(1528642740),uint64(1529852340),uint64(1532271535)];
1113         uint[3] memory weiRaisedAndTimeRates = [uint(500),uint(300),uint(100)];
1114 
1115         for (uint i = 0; i < 3; i++) {
1116             bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);
1117             bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);
1118             if (weiRaisedInBound && timeInBound) {
1119                 bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;
1120             }
1121         }
1122         
1123 
1124         
1125 
1126         return bonusRate;
1127     }
1128 }
1129 
1130 
1131 
1132 contract TemplateCrowdsale is Consts, MainCrowdsale
1133     
1134     , BonusableCrowdsale
1135     
1136     
1137     , CappedCrowdsale
1138     
1139 {
1140     event Initialized();
1141     bool public initialized = false;
1142 
1143     function TemplateCrowdsale(MintableToken _token) public
1144         Crowdsale(START_TIME > now ? START_TIME : now, 1532271540, 10000 * TOKEN_DECIMAL_MULTIPLIER, 0x429B892e0e3B66accA6AeAE26A6892a1948d650D)
1145         CappedCrowdsale(50000000000000000000000)
1146         
1147     {
1148         token = _token;
1149     }
1150 
1151     function init() public onlyOwner {
1152         require(!initialized);
1153         initialized = true;
1154 
1155         if (PAUSED) {
1156             MainToken(token).pause();
1157         }
1158 
1159         
1160         address[3] memory addresses = [address(0xc5d388779f168b527f8a99bb5f8c9e457221f2a7),address(0x68bdc087bfcff41944d51da0ca76a6d246a88c3f),address(0x5eb398ce3d48bc0e33feae2865ee78695ecf0866)];
1161         uint[3] memory amounts = [uint(20000000000000000),uint(20000000000000000),uint(10000000000000000)];
1162         uint64[3] memory freezes = [uint64(0),uint64(0),uint64(0)];
1163 
1164         for (uint i = 0; i < addresses.length; i++) {
1165             if (freezes[i] == 0) {
1166                 MainToken(token).mint(addresses[i], amounts[i]);
1167             } else {
1168                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1169             }
1170         }
1171         
1172 
1173         transferOwnership(TARGET_USER);
1174 
1175         Initialized();
1176     }
1177 
1178     /**
1179      * @dev override token creation to set token address in constructor.
1180      */
1181     function createTokenContract() internal returns (MintableToken) {
1182         return MintableToken(0);
1183     }
1184 
1185     
1186 
1187     
1188     /**
1189      * @dev override purchase validation to add extra value logic.
1190      * @return true if sended more than minimal value
1191      */
1192     function validPurchase() internal view returns (bool) {
1193         
1194         bool minValue = msg.value >= 500000000000000000;
1195         
1196         
1197         bool maxValue = msg.value <= 2000000000000000000000;
1198         
1199 
1200         return
1201         
1202             minValue &&
1203         
1204         
1205             maxValue &&
1206         
1207             super.validPurchase();
1208     }
1209     
1210 
1211     
1212     /**
1213      * @dev override hasEnded to add minimal value logic
1214      * @return true if remained to achieve less than minimal
1215      */
1216     function hasEnded() public view returns (bool) {
1217         bool remainValue = cap.sub(weiRaised) < 500000000000000000;
1218         return super.hasEnded() || remainValue;
1219     }
1220     
1221 
1222 }