1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/TSAggregatorGeneric.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { SafeTransferLib } from \"../lib/SafeTransferLib.sol\";\nimport { TSAggregator } from \"./TSAggregator.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IThorchainRouter } from \"./interfaces/IThorchainRouter.sol\";\nimport { TSAggregatorTokenTransferProxy } from './TSAggregatorTokenTransferProxy.sol';\n\ncontract TSAggregatorGeneric is TSAggregator {\n    using SafeTransferLib for address;\n\n    constructor(address _ttp) TSAggregator(_ttp) {\n    }\n\n    // Use 1inch's swap API endpoint to get data to send\n    // e.g. https://api.1inch.io/v4.0/1/swap?toTokenAddress=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE&fromTokenAddress=0x111111111117dc0aa78b770fa6a738034120c302&amount=10000000000000000&fromAddress=0x2f8aedd149afbdb5206ecaf8b1a3abb9186c8053&slippage=1&disableEstimate=true\n    // toTokenAddress needs to be 0xeeee so ETH is sent back to swapIn\n    // fromAddress needs to be the address of this contract\n    // disableEstimate makes the API return a result even if there's no token balance in the contract\n    function swapIn(\n        address tcRouter,\n        address tcVault,\n        string calldata tcMemo,\n        address token,\n        uint amount,\n        address router,\n        bytes calldata data,\n        uint deadline\n    ) public nonReentrant {\n        require(router != address(tokenTransferProxy), \"no calling ttp\");\n        tokenTransferProxy.transferTokens(token, msg.sender, address(this), amount);\n        token.safeApprove(address(router), 0); // USDT quirk\n        token.safeApprove(address(router), amount);\n\n        (bool success,) = router.call(data);\n        require(success, \"failed to swap\");\n\n        uint256 amountOut = address(this).balance;\n        amountOut = skimFee(amountOut);\n        IThorchainRouter(tcRouter).depositWithExpiry{value: amountOut}(\n            payable(tcVault),\n            address(0), // ETH\n            amountOut,\n            tcMemo,\n            deadline\n        );\n    }\n}\n"
6     },
7     "lib/SafeTransferLib.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n"
9     },
10     "src/TSAggregator.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { SafeTransferLib } from \"../lib/SafeTransferLib.sol\";\nimport { ReentrancyGuard } from \"../lib/ReentrancyGuard.sol\";\nimport { Owners } from \"./Owners.sol\";\nimport { TSAggregatorTokenTransferProxy } from './TSAggregatorTokenTransferProxy.sol';\n\nabstract contract TSAggregator is Owners, ReentrancyGuard {\n    using SafeTransferLib for address;\n\n    event FeeSet(uint256 fee, address feeRecipient);\n\n    uint256 public fee;\n    address public feeRecipient;\n    TSAggregatorTokenTransferProxy public tokenTransferProxy;\n\n    constructor(address _tokenTransferProxy) {\n        _setOwner(msg.sender, true);\n        tokenTransferProxy = TSAggregatorTokenTransferProxy(_tokenTransferProxy);\n    }\n\n    // Needed for the swap router to be able to send back ETH\n    receive() external payable {}\n\n    function setFee(uint256 _fee, address _feeRecipient) public isOwner {\n        require(_fee <= 1000, \"fee can not be more than 10%\");\n        fee = _fee;\n        feeRecipient = _feeRecipient;\n        emit FeeSet(_fee, _feeRecipient);\n    }\n\n    function skimFee(uint256 amount) internal returns (uint256) {\n        if (fee != 0 && feeRecipient != address(0)) {\n            uint256 feeAmount = (amount * fee) / 10000;\n            feeRecipient.safeTransferETH(feeAmount);\n            amount -= feeAmount;\n        }\n        return amount;\n    }\n}\n"
12     },
13     "src/interfaces/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
15     },
16     "src/interfaces/IThorchainRouter.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IThorchainRouter {\n    function depositWithExpiry(\n        address payable vault,\n        address asset,\n        uint amount,\n        string memory memo,\n        uint expiration\n    ) external payable;\n}\n"
18     },
19     "src/TSAggregatorTokenTransferProxy.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { SafeTransferLib } from \"../lib/SafeTransferLib.sol\";\nimport { Owners } from \"./Owners.sol\";\n\ncontract TSAggregatorTokenTransferProxy is Owners {\n    using SafeTransferLib for address;\n\n    constructor() {\n        _setOwner(msg.sender, true);\n    }\n\n    function transferTokens(address token, address from, address to, uint256 amount) external isOwner {\n        require(from == tx.origin || _isContract(from), \"Invalid from address\");\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
21     },
22     "lib/ReentrancyGuard.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
24     },
25     "src/Owners.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nabstract contract Owners {\n    event OwnerSet(address indexed owner, bool active);\n\n    mapping(address => bool) public owners;\n\n    modifier isOwner() {\n        require(owners[msg.sender], \"Unauthorized\");\n        _;\n    }\n\n    function _setOwner(address owner, bool active) internal virtual {\n      owners[owner] = active;\n      emit OwnerSet(owner, active);\n    }\n\n    function setOwner(address owner, bool active) public virtual isOwner {\n      _setOwner(owner, active);\n    }\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 10000
33     },
34     "outputSelection": {
35       "*": {
36         "*": [
37           "evm.bytecode",
38           "evm.deployedBytecode",
39           "devdoc",
40           "userdoc",
41           "metadata",
42           "abi"
43         ]
44       }
45     },
46     "libraries": {}
47   }
48 }}