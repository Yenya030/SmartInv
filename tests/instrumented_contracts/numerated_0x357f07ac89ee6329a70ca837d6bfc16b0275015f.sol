1 // 1.	The Ethereum Sweepstake is NOT a company, it is a smart contract written using the Ethereum protocols, which runs on the Ethereum Blockchain. 
2 // 2.	Ethereum Sweepstakes is only available to users from countries where applicable law allows.
3 // 3.	You Must be at least 18 years of age to participate
4 // 4.	The Ethereum Sweepstake is a smart contract that enables contributors to acquire up to 4,000,000 SWEEP coins, at a price of 1 ETHER per 1 SWEEP token.  
5 // 5.	A minimum of 57% of all ETHERs received are kept on smart contract wallet and guaranteed to be transferred as prizes.
6 // 6.	The Ethereum Sweepstake is not affiliated to the Ethereum Foundation, and is only made possible by the Ethereum Bockchain and its smart contract application.  Ethereum is a trademark owned by the Ethereum Foundation. A total of five percent (5%) of the Ethereum Sweepstake sale will be donated to the Ethereum Foundation for the continued support and development of the Ethereum Blockchain.
7 // 7.	The Ethereum Sweepstake was invented by Hladun Rostyslav a citizen of the Ukraine, residing in the city of Lviv.  The Ethereum Sweepstake will pay the inventor and or to his nominee a total of five percent (5%) of the remaining Ethers.
8 // 8.	The Ethereum Sweepstake and its SWEEP token are a smart contract which is transacted on the Ethereum Blockchain and as such are subject to Private International Law.  The  jurisdiction of the transaction(s) including the promotions sent to and or received by the users, the purchases of SWEEP Tokens, drawing of the winners and the payment of the winnings are deemed to be in the jurisdiction of the country of Costa Rica and all users of the Ethereum Sweepstake agree to said legal jurisdiction regardless of conflicts of law including whether minimum contact can be established within another jurisdiction. 
9 // 9.	
10 // 10.	Upon selling the last SWEEP coin, a random selection running on the blockchain will be activated and the winners of the Ethereum Sweepstake will automatically be transferred the number of Ethers for the respective prizes.  Winning Ethers will only be sent to personal wallet address used to enter the Ethereum Sweepstakes and purchase the SWEEP coins.
11 // 11.	Ethereum sent from an exchange and or brokerage accounts will be void and will not receive any potential winnings. We will no be liable for any losses in entries or potential winnings as a result of Ethereum being transferred from a brokerage and or exchange wallet.
12 // 12.	Transactions to enter Ethereum Sweepstakes are managed and confirmed via the Ethereum blockchain. You understand that your Ethereum public address will be made publicly visible when you enter the Ethereum Sweepstake.
13 // 13.	If you decide to enter the Ethereum Sweepstake, we have no ability to reverse the transactions.  We also have no ability to payout any potential winnings to wallet address other than the wallet used to enter the Ethereum sweepstake. We will have no liability to you or to any third party for any claims or damages that may arise as a result of any transactions that you engage in via our website, or independently using our Smart Contract.
14 // 14.	Ethereum requires the payment of a transaction fee (a “Gas Fee”) for every transaction that occurs on the Ethereum network. The Gas Fee funds the network of computers that run the decentralized Ethereum network. This means that, even if you elect to interact directly via the Ethereum network, you will still need to pay a Gas Fee for each transaction that occurs via the Ethereum network.
15 
16 // Disclaimer of Warranties
17 // YOU EXPRESSLY UNDERSTAND AND AGREE THAT YOUR ACCESS TO AND USE OF THE ETHEREUM SWEEPSTAKE  IS AT YOUR SOLE RISK, AND THAT THE ETHEREUM SWEEPSTAKE iS PROVIDED "AS IS" AND "AS AVAILABLE" WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED. TO THE FULLEST EXTENT PERMISSIBLE PURSUANT TO APPLICABLE LAW, WE, THE INVENTOR, THE OWNER, THE SERVICE PROVIDERS, OFFICERS, DIRECTORS, EMPLOYEES, LEGAL COUNSEL, OUR SUBSIDIARIES, AFFILIATES, AND LICENSORS MAKE NO EXPRESS WARRANTIES AND HEREBY DISCLAIM ALL IMPLIED WARRANTIES REGARDING THE ETHEREUM SWEEPSTAKE AND ANY PART OF IT (INCLUDING, WITHOUT LIMITATION, THE SITE, ANY SMART CONTRACT, OR ANY EXTERNAL WEBSITES), INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, CORRECTNESS, ACCURACY, OR RELIABILITY. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, WE, THE INVENTOR, THE OWNER, THE SERVICE PROVIDERS, OFFICERS, DIRECTORS, EMPLOYEES, LEGAL COUNSEL,OUR SUBSIDIARIES, AFFILIATES, AND LICENSORS DO NOT REPRESENT OR WARRANT TO YOU THAT: (I) YOUR ACCESS TO OR USE OF THE APP, WEBSITE, AND OR SMART CONTRACT WILL MEET YOUR REQUIREMENTS, (II) YOUR ACCESS TO OR USE OF THE APP, WEBSITE, AND OR SMART CONTRACT WILL BE UNINTERRUPTED, TIMELY, SECURE OR FREE FROM ERROR, (III) USAGE DATA PROVIDED THROUGH THE APP, WEBSITE, AND OR SMART CONTRACT WILL BE ACCURATE, OR (III) THE APP OR ANY CONTENT, SERVICES, OR FEATURES MADE AVAILABLE ON OR THROUGH THE APP, WEBSITE AND OR SMART CONTRACT ARE FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.
18 
19 // Limitation of Liability
20 // 1.	YOU UNDERSTAND AND AGREE THAT WE, THE INVENTOR, THE OWNER, THE SERVICE PROVIDERS, OFFICERS, DIRECTORS, EMPLOYEES, LEGAL COUNSEL, OUR SUBSIDIARIES, AFFILIATES, AND LICENSORS WILL NOT BE LIABLE TO YOU OR TO ANY THIRD PARTY FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, OR EXEMPLARY DAMAGES WHICH YOU MAY INCUR, HOWSOEVER CAUSED AND UNDER ANY THEORY OF LIABILITY, INCLUDING, WITHOUT LIMITATION, ANY LOSS OF PROFITS (WHETHER INCURRED DIRECTLY OR INDIRECTLY), LOSS OF GOODWILL OR BUSINESS REPUTATION, LOSS OF DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR ANY OTHER INTANGIBLE LOSS, EVEN IF WE HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
21 // 2.	YOU ACKNOWLEDGE AND AGREE THAT WE HAVE MADE THE APP, WEBSITE AND OR SMART CONTRACT AVAILABLE TO YOU AND ENTERED INTO THESE TERMS IN RELIANCE UPON THE WARRANTY DISCLAIMERS AND LIMITATIONS OF LIABILITY SET FORTH HEREIN, WHICH REFLECT A REASONABLE AND FAIR ALLOCATION OF RISK BETWEEN THE PARTIES AND FORM AN ESSENTIAL BASIS OF THE BARGAIN BETWEEN US. WE WOULD NOT BE ABLE TO PROVIDE THE ETHEREUM SWEEPSTAKE TO YOU WITHOUT THESE LIMITATIONS.
22 
23 // Indemnification
24 
25 // 1.	You agree to hold harmless and indemnify THE ETHEREUM SWEEPSTAKE and its owner, inventor, subsidiaries, affiliates, officers, directors, agents, employees, advertisers, licensors, suppliers or partners from and against any claim, liability, loss, damage (actual and consequential) of any kind or nature, suit, judgment, litigation cost, and attorneys’ fees arising out of or in any way related to (i) your breach of these Terms, or (ii) your violation of applicable laws, rules or regulations in connection with your access to or use of the Ethereum Sweepstake.
26 // 2.	Taxation. The Users bears the sole responsibility to determine if the Ethereum Sweepstake winnings shall be a taxable event for the User. The Users bear full responsibility for timely and correct calculation and payment of all taxes due in accordance with the legislation applicable to the Users. The Service is not a tax agent of the User, as well as it does not advise the User on the order of calculation and/or the payment of taxes.
27 
28 // Notification About Risks
29 // 1.	The User understands and accepts the risks in connection with transferring ETHERS to the Ethereum Sweepstake and creating a SWEEP Token as exemplary set forth above and hereinafter. In particular, but not limited, the User understands the inherent risks listed hereinafter:
30 // 2.	Risk of software weaknesses: The User understands and accepts that the Ethereum Sweepstake concept, the underlying software application and software platform (i.e. the Ethereum blockchain) is still in an early development stage and unproven, why there is no warranty that the process for creating Tokens will be uninterrupted or error-free and why there is an inherent risk that the software could contain weaknesses, vulnerabilities or bugs causing, inter alia, the complete loss of ETH and/or Tokens.
31 // 3.	Regulatory risk: The User understands and accepts that the blockchain technology allows new forms of interaction and that it is possible that certain jurisdictions will apply existing regulations on, or introduce new regulations addressing, blockchain technology based applications, which may be contrary to the current setup of the Ethereum Sweepstake and which may, inter alia, result in substantial modifications of the Ethereum Sweepstakes, including its termination and the loss of ETHERS/Tokens for the User.
32 // 4.	Risk of Loss of private key: Tokens can only be accessed with a wallet seed or combination of private key and password. The private key is encrypted with a password. The User understands and accepts that if his wallet file or password respectively his private key got lost or stolen, the obtained Tokens associated with the User's Wallet or password will be unrecoverable and will be permanently lost with the Risk of theft: The User understands and accepts that the Ethereum Sweepstake concept, the underlying software application and software platform (i.e. the Ethereum blockchain) may be exposed to attacks by hackers or other individuals that that could result in theft or loss of Sweep Tokens or ETHERS, impacting the ability to complete the Ethereum Sweepstake.
33 // 5.   Risk of Ethereum mining attacks: The User understands and accepts that, as with other cryptocurrencies, the blockchain used for the Ethereum Sweepstakes is susceptible to mining attacks, including but not limited to double-spend attacks, majority mining power attacks, “selfish-mining” attacks, and race condition attacks. Any successful attacks present a risk to the Ethereum Sweepstake, expected proper execution and sequencing of ETH/Token transactions, and expected proper execution and sequencing of contract computations.
34 
35 pragma solidity ^0.4.18;
36 
37 // <ORACLIZE_API>
38 /*
39 Copyright (c) 2015-2016 Oraclize SRL
40 Copyright (c) 2016 Oraclize LTD
41 
42 
43 
44 Permission is hereby granted, free of charge, to any person obtaining a copy
45 of this software and associated documentation files (the "Software"), to deal
46 in the Software without restriction, including without limitation the rights
47 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
48 copies of the Software, and to permit persons to whom the Software is
49 furnished to do so, subject to the following conditions:
50 
51 
52 
53 The above copyright notice and this permission notice shall be included in
54 all copies or substantial portions of the Software.
55 
56 
57 
58 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
59 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
60 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
61 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
62 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
63 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
64 THE SOFTWARE.
65 */
66 
67 // This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary
68 pragma solidity ^0.4.18;
69 
70 contract OraclizeI {
71     address public cbAddress;
72     function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
73     function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
74     function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
75     function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);
76     function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);
77     function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);
78     function getPrice(string _datasource) public returns (uint _dsprice);
79     function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);
80     function setProofType(byte _proofType) external;
81     function setCustomGasPrice(uint _gasPrice) external;
82     function randomDS_getSessionPubKeyHash() external constant returns(bytes32);
83 }
84 contract OraclizeAddrResolverI {
85     function getAddress() public returns (address _addr);
86 }
87 contract usingOraclize {
88     uint constant day = 60*60*24;
89     uint constant week = 60*60*24*7;
90     uint constant month = 60*60*24*30;
91     byte constant proofType_NONE = 0x00;
92     byte constant proofType_TLSNotary = 0x10;
93     byte constant proofType_Android = 0x20;
94     byte constant proofType_Ledger = 0x30;
95     byte constant proofType_Native = 0xF0;
96     byte constant proofStorage_IPFS = 0x01;
97     uint8 constant networkID_auto = 0;
98     uint8 constant networkID_mainnet = 1;
99     uint8 constant networkID_testnet = 2;
100     uint8 constant networkID_morden = 2;
101     uint8 constant networkID_consensys = 161;
102 
103     OraclizeAddrResolverI OAR;
104 
105     OraclizeI oraclize;
106     modifier oraclizeAPI {
107         if((address(OAR)==0)||(getCodeSize(address(OAR))==0))
108             oraclize_setNetwork(networkID_auto);
109 
110         if(address(oraclize) != OAR.getAddress())
111             oraclize = OraclizeI(OAR.getAddress());
112 
113         _;
114     }
115     modifier coupon(string code){
116         oraclize = OraclizeI(OAR.getAddress());
117         _;
118     }
119 
120     function oraclize_setNetwork(uint8 networkID) internal returns(bool){
121       return oraclize_setNetwork();
122       networkID; // silence the warning and remain backwards compatible
123     }
124     function oraclize_setNetwork() internal returns(bool){
125         if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet
126             OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);
127             oraclize_setNetworkName("eth_mainnet");
128             return true;
129         }
130         if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet
131             OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);
132             oraclize_setNetworkName("eth_ropsten3");
133             return true;
134         }
135         if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet
136             OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);
137             oraclize_setNetworkName("eth_kovan");
138             return true;
139         }
140         if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet
141             OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);
142             oraclize_setNetworkName("eth_rinkeby");
143             return true;
144         }
145         if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge
146             OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
147             return true;
148         }
149         if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide
150             OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);
151             return true;
152         }
153         if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity
154             OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);
155             return true;
156         }
157         return false;
158     }
159 
160     function __callback(bytes32 myid, string result) public {
161         __callback(myid, result, new bytes(0));
162     }
163     function __callback(bytes32 myid, string result, bytes proof) public {
164       return;
165       myid; result; proof; // Silence compiler warnings
166     }
167 
168     function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){
169         return oraclize.getPrice(datasource);
170     }
171 
172     function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){
173         return oraclize.getPrice(datasource, gaslimit);
174     }
175 
176     function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
177         uint price = oraclize.getPrice(datasource);
178         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
179         return oraclize.query.value(price)(0, datasource, arg);
180     }
181     function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){
182         uint price = oraclize.getPrice(datasource);
183         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
184         return oraclize.query.value(price)(timestamp, datasource, arg);
185     }
186     function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
187         uint price = oraclize.getPrice(datasource, gaslimit);
188         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
189         return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);
190     }
191     function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
192         uint price = oraclize.getPrice(datasource, gaslimit);
193         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
194         return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);
195     }
196     function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
197         uint price = oraclize.getPrice(datasource);
198         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
199         return oraclize.query2.value(price)(0, datasource, arg1, arg2);
200     }
201     function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){
202         uint price = oraclize.getPrice(datasource);
203         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
204         return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);
205     }
206     function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
207         uint price = oraclize.getPrice(datasource, gaslimit);
208         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
209         return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);
210     }
211     function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
212         uint price = oraclize.getPrice(datasource, gaslimit);
213         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
214         return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);
215     }
216     function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
217         uint price = oraclize.getPrice(datasource);
218         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
219         bytes memory args = stra2cbor(argN);
220         return oraclize.queryN.value(price)(0, datasource, args);
221     }
222     function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){
223         uint price = oraclize.getPrice(datasource);
224         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
225         bytes memory args = stra2cbor(argN);
226         return oraclize.queryN.value(price)(timestamp, datasource, args);
227     }
228     function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
229         uint price = oraclize.getPrice(datasource, gaslimit);
230         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
231         bytes memory args = stra2cbor(argN);
232         return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
233     }
234     function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
235         uint price = oraclize.getPrice(datasource, gaslimit);
236         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
237         bytes memory args = stra2cbor(argN);
238         return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
239     }
240     function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
241         string[] memory dynargs = new string[](1);
242         dynargs[0] = args[0];
243         return oraclize_query(datasource, dynargs);
244     }
245     function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {
246         string[] memory dynargs = new string[](1);
247         dynargs[0] = args[0];
248         return oraclize_query(timestamp, datasource, dynargs);
249     }
250     function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
251         string[] memory dynargs = new string[](1);
252         dynargs[0] = args[0];
253         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
254     }
255     function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
256         string[] memory dynargs = new string[](1);
257         dynargs[0] = args[0];
258         return oraclize_query(datasource, dynargs, gaslimit);
259     }
260 
261     function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
262         string[] memory dynargs = new string[](2);
263         dynargs[0] = args[0];
264         dynargs[1] = args[1];
265         return oraclize_query(datasource, dynargs);
266     }
267     function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {
268         string[] memory dynargs = new string[](2);
269         dynargs[0] = args[0];
270         dynargs[1] = args[1];
271         return oraclize_query(timestamp, datasource, dynargs);
272     }
273     function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
274         string[] memory dynargs = new string[](2);
275         dynargs[0] = args[0];
276         dynargs[1] = args[1];
277         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
278     }
279     function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
280         string[] memory dynargs = new string[](2);
281         dynargs[0] = args[0];
282         dynargs[1] = args[1];
283         return oraclize_query(datasource, dynargs, gaslimit);
284     }
285     function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
286         string[] memory dynargs = new string[](3);
287         dynargs[0] = args[0];
288         dynargs[1] = args[1];
289         dynargs[2] = args[2];
290         return oraclize_query(datasource, dynargs);
291     }
292     function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {
293         string[] memory dynargs = new string[](3);
294         dynargs[0] = args[0];
295         dynargs[1] = args[1];
296         dynargs[2] = args[2];
297         return oraclize_query(timestamp, datasource, dynargs);
298     }
299     function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
300         string[] memory dynargs = new string[](3);
301         dynargs[0] = args[0];
302         dynargs[1] = args[1];
303         dynargs[2] = args[2];
304         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
305     }
306     function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
307         string[] memory dynargs = new string[](3);
308         dynargs[0] = args[0];
309         dynargs[1] = args[1];
310         dynargs[2] = args[2];
311         return oraclize_query(datasource, dynargs, gaslimit);
312     }
313 
314     function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
315         string[] memory dynargs = new string[](4);
316         dynargs[0] = args[0];
317         dynargs[1] = args[1];
318         dynargs[2] = args[2];
319         dynargs[3] = args[3];
320         return oraclize_query(datasource, dynargs);
321     }
322     function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {
323         string[] memory dynargs = new string[](4);
324         dynargs[0] = args[0];
325         dynargs[1] = args[1];
326         dynargs[2] = args[2];
327         dynargs[3] = args[3];
328         return oraclize_query(timestamp, datasource, dynargs);
329     }
330     function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
331         string[] memory dynargs = new string[](4);
332         dynargs[0] = args[0];
333         dynargs[1] = args[1];
334         dynargs[2] = args[2];
335         dynargs[3] = args[3];
336         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
337     }
338     function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
339         string[] memory dynargs = new string[](4);
340         dynargs[0] = args[0];
341         dynargs[1] = args[1];
342         dynargs[2] = args[2];
343         dynargs[3] = args[3];
344         return oraclize_query(datasource, dynargs, gaslimit);
345     }
346     function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
347         string[] memory dynargs = new string[](5);
348         dynargs[0] = args[0];
349         dynargs[1] = args[1];
350         dynargs[2] = args[2];
351         dynargs[3] = args[3];
352         dynargs[4] = args[4];
353         return oraclize_query(datasource, dynargs);
354     }
355     function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {
356         string[] memory dynargs = new string[](5);
357         dynargs[0] = args[0];
358         dynargs[1] = args[1];
359         dynargs[2] = args[2];
360         dynargs[3] = args[3];
361         dynargs[4] = args[4];
362         return oraclize_query(timestamp, datasource, dynargs);
363     }
364     function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
365         string[] memory dynargs = new string[](5);
366         dynargs[0] = args[0];
367         dynargs[1] = args[1];
368         dynargs[2] = args[2];
369         dynargs[3] = args[3];
370         dynargs[4] = args[4];
371         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
372     }
373     function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
374         string[] memory dynargs = new string[](5);
375         dynargs[0] = args[0];
376         dynargs[1] = args[1];
377         dynargs[2] = args[2];
378         dynargs[3] = args[3];
379         dynargs[4] = args[4];
380         return oraclize_query(datasource, dynargs, gaslimit);
381     }
382     function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
383         uint price = oraclize.getPrice(datasource);
384         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
385         bytes memory args = ba2cbor(argN);
386         return oraclize.queryN.value(price)(0, datasource, args);
387     }
388     function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){
389         uint price = oraclize.getPrice(datasource);
390         if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price
391         bytes memory args = ba2cbor(argN);
392         return oraclize.queryN.value(price)(timestamp, datasource, args);
393     }
394     function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
395         uint price = oraclize.getPrice(datasource, gaslimit);
396         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
397         bytes memory args = ba2cbor(argN);
398         return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);
399     }
400     function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){
401         uint price = oraclize.getPrice(datasource, gaslimit);
402         if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price
403         bytes memory args = ba2cbor(argN);
404         return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);
405     }
406     function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
407         bytes[] memory dynargs = new bytes[](1);
408         dynargs[0] = args[0];
409         return oraclize_query(datasource, dynargs);
410     }
411     function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {
412         bytes[] memory dynargs = new bytes[](1);
413         dynargs[0] = args[0];
414         return oraclize_query(timestamp, datasource, dynargs);
415     }
416     function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
417         bytes[] memory dynargs = new bytes[](1);
418         dynargs[0] = args[0];
419         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
420     }
421     function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
422         bytes[] memory dynargs = new bytes[](1);
423         dynargs[0] = args[0];
424         return oraclize_query(datasource, dynargs, gaslimit);
425     }
426 
427     function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
428         bytes[] memory dynargs = new bytes[](2);
429         dynargs[0] = args[0];
430         dynargs[1] = args[1];
431         return oraclize_query(datasource, dynargs);
432     }
433     function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {
434         bytes[] memory dynargs = new bytes[](2);
435         dynargs[0] = args[0];
436         dynargs[1] = args[1];
437         return oraclize_query(timestamp, datasource, dynargs);
438     }
439     function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
440         bytes[] memory dynargs = new bytes[](2);
441         dynargs[0] = args[0];
442         dynargs[1] = args[1];
443         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
444     }
445     function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
446         bytes[] memory dynargs = new bytes[](2);
447         dynargs[0] = args[0];
448         dynargs[1] = args[1];
449         return oraclize_query(datasource, dynargs, gaslimit);
450     }
451     function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
452         bytes[] memory dynargs = new bytes[](3);
453         dynargs[0] = args[0];
454         dynargs[1] = args[1];
455         dynargs[2] = args[2];
456         return oraclize_query(datasource, dynargs);
457     }
458     function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {
459         bytes[] memory dynargs = new bytes[](3);
460         dynargs[0] = args[0];
461         dynargs[1] = args[1];
462         dynargs[2] = args[2];
463         return oraclize_query(timestamp, datasource, dynargs);
464     }
465     function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
466         bytes[] memory dynargs = new bytes[](3);
467         dynargs[0] = args[0];
468         dynargs[1] = args[1];
469         dynargs[2] = args[2];
470         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
471     }
472     function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
473         bytes[] memory dynargs = new bytes[](3);
474         dynargs[0] = args[0];
475         dynargs[1] = args[1];
476         dynargs[2] = args[2];
477         return oraclize_query(datasource, dynargs, gaslimit);
478     }
479 
480     function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
481         bytes[] memory dynargs = new bytes[](4);
482         dynargs[0] = args[0];
483         dynargs[1] = args[1];
484         dynargs[2] = args[2];
485         dynargs[3] = args[3];
486         return oraclize_query(datasource, dynargs);
487     }
488     function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {
489         bytes[] memory dynargs = new bytes[](4);
490         dynargs[0] = args[0];
491         dynargs[1] = args[1];
492         dynargs[2] = args[2];
493         dynargs[3] = args[3];
494         return oraclize_query(timestamp, datasource, dynargs);
495     }
496     function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
497         bytes[] memory dynargs = new bytes[](4);
498         dynargs[0] = args[0];
499         dynargs[1] = args[1];
500         dynargs[2] = args[2];
501         dynargs[3] = args[3];
502         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
503     }
504     function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
505         bytes[] memory dynargs = new bytes[](4);
506         dynargs[0] = args[0];
507         dynargs[1] = args[1];
508         dynargs[2] = args[2];
509         dynargs[3] = args[3];
510         return oraclize_query(datasource, dynargs, gaslimit);
511     }
512     function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
513         bytes[] memory dynargs = new bytes[](5);
514         dynargs[0] = args[0];
515         dynargs[1] = args[1];
516         dynargs[2] = args[2];
517         dynargs[3] = args[3];
518         dynargs[4] = args[4];
519         return oraclize_query(datasource, dynargs);
520     }
521     function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {
522         bytes[] memory dynargs = new bytes[](5);
523         dynargs[0] = args[0];
524         dynargs[1] = args[1];
525         dynargs[2] = args[2];
526         dynargs[3] = args[3];
527         dynargs[4] = args[4];
528         return oraclize_query(timestamp, datasource, dynargs);
529     }
530     function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
531         bytes[] memory dynargs = new bytes[](5);
532         dynargs[0] = args[0];
533         dynargs[1] = args[1];
534         dynargs[2] = args[2];
535         dynargs[3] = args[3];
536         dynargs[4] = args[4];
537         return oraclize_query(timestamp, datasource, dynargs, gaslimit);
538     }
539     function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {
540         bytes[] memory dynargs = new bytes[](5);
541         dynargs[0] = args[0];
542         dynargs[1] = args[1];
543         dynargs[2] = args[2];
544         dynargs[3] = args[3];
545         dynargs[4] = args[4];
546         return oraclize_query(datasource, dynargs, gaslimit);
547     }
548 
549     function oraclize_cbAddress() oraclizeAPI internal returns (address){
550         return oraclize.cbAddress();
551     }
552     function oraclize_setProof(byte proofP) oraclizeAPI internal {
553         return oraclize.setProofType(proofP);
554     }
555     function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {
556         return oraclize.setCustomGasPrice(gasPrice);
557     }
558 
559     function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){
560         return oraclize.randomDS_getSessionPubKeyHash();
561     }
562 
563     function getCodeSize(address _addr) constant internal returns(uint _size) {
564         assembly {
565             _size := extcodesize(_addr)
566         }
567     }
568 
569     function parseAddr(string _a) internal pure returns (address){
570         bytes memory tmp = bytes(_a);
571         uint160 iaddr = 0;
572         uint160 b1;
573         uint160 b2;
574         for (uint i=2; i<2+2*20; i+=2){
575             iaddr *= 256;
576             b1 = uint160(tmp[i]);
577             b2 = uint160(tmp[i+1]);
578             if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
579             else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
580             else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
581             if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
582             else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
583             else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
584             iaddr += (b1*16+b2);
585         }
586         return address(iaddr);
587     }
588 
589     function strCompare(string _a, string _b) internal pure returns (int) {
590         bytes memory a = bytes(_a);
591         bytes memory b = bytes(_b);
592         uint minLength = a.length;
593         if (b.length < minLength) minLength = b.length;
594         for (uint i = 0; i < minLength; i ++)
595             if (a[i] < b[i])
596                 return -1;
597             else if (a[i] > b[i])
598                 return 1;
599         if (a.length < b.length)
600             return -1;
601         else if (a.length > b.length)
602             return 1;
603         else
604             return 0;
605     }
606 
607     function indexOf(string _haystack, string _needle) internal pure returns (int) {
608         bytes memory h = bytes(_haystack);
609         bytes memory n = bytes(_needle);
610         if(h.length < 1 || n.length < 1 || (n.length > h.length))
611             return -1;
612         else if(h.length > (2**128 -1))
613             return -1;
614         else
615         {
616             uint subindex = 0;
617             for (uint i = 0; i < h.length; i ++)
618             {
619                 if (h[i] == n[0])
620                 {
621                     subindex = 1;
622                     while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])
623                     {
624                         subindex++;
625                     }
626                     if(subindex == n.length)
627                         return int(i);
628                 }
629             }
630             return -1;
631         }
632     }
633 
634     function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {
635         bytes memory _ba = bytes(_a);
636         bytes memory _bb = bytes(_b);
637         bytes memory _bc = bytes(_c);
638         bytes memory _bd = bytes(_d);
639         bytes memory _be = bytes(_e);
640         string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
641         bytes memory babcde = bytes(abcde);
642         uint k = 0;
643         for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
644         for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
645         for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
646         for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
647         for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
648         return string(babcde);
649     }
650 
651     function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {
652         return strConcat(_a, _b, _c, _d, "");
653     }
654 
655     function strConcat(string _a, string _b, string _c) internal pure returns (string) {
656         return strConcat(_a, _b, _c, "", "");
657     }
658 
659     function strConcat(string _a, string _b) internal pure returns (string) {
660         return strConcat(_a, _b, "", "", "");
661     }
662 
663     // parseInt
664     function parseInt(string _a) internal pure returns (uint) {
665         return parseInt(_a, 0);
666     }
667 
668     // parseInt(parseFloat*10^_b)
669     function parseInt(string _a, uint _b) internal pure returns (uint) {
670         bytes memory bresult = bytes(_a);
671         uint mint = 0;
672         bool decimals = false;
673         for (uint i=0; i<bresult.length; i++){
674             if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
675                 if (decimals){
676                    if (_b == 0) break;
677                     else _b--;
678                 }
679                 mint *= 10;
680                 mint += uint(bresult[i]) - 48;
681             } else if (bresult[i] == 46) decimals = true;
682         }
683         if (_b > 0) mint *= 10**_b;
684         return mint;
685     }
686 
687     function uint2str(uint i) internal pure returns (string){
688         if (i == 0) return "0";
689         uint j = i;
690         uint len;
691         while (j != 0){
692             len++;
693             j /= 10;
694         }
695         bytes memory bstr = new bytes(len);
696         uint k = len - 1;
697         while (i != 0){
698             bstr[k--] = byte(48 + i % 10);
699             i /= 10;
700         }
701         return string(bstr);
702     }
703 
704     function stra2cbor(string[] arr) internal pure returns (bytes) {
705             uint arrlen = arr.length;
706 
707             // get correct cbor output length
708             uint outputlen = 0;
709             bytes[] memory elemArray = new bytes[](arrlen);
710             for (uint i = 0; i < arrlen; i++) {
711                 elemArray[i] = (bytes(arr[i]));
712                 outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
713             }
714             uint ctr = 0;
715             uint cborlen = arrlen + 0x80;
716             outputlen += byte(cborlen).length;
717             bytes memory res = new bytes(outputlen);
718 
719             while (byte(cborlen).length > ctr) {
720                 res[ctr] = byte(cborlen)[ctr];
721                 ctr++;
722             }
723             for (i = 0; i < arrlen; i++) {
724                 res[ctr] = 0x5F;
725                 ctr++;
726                 for (uint x = 0; x < elemArray[i].length; x++) {
727                     // if there's a bug with larger strings, this may be the culprit
728                     if (x % 23 == 0) {
729                         uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
730                         elemcborlen += 0x40;
731                         uint lctr = ctr;
732                         while (byte(elemcborlen).length > ctr - lctr) {
733                             res[ctr] = byte(elemcborlen)[ctr - lctr];
734                             ctr++;
735                         }
736                     }
737                     res[ctr] = elemArray[i][x];
738                     ctr++;
739                 }
740                 res[ctr] = 0xFF;
741                 ctr++;
742             }
743             return res;
744         }
745 
746     function ba2cbor(bytes[] arr) internal pure returns (bytes) {
747             uint arrlen = arr.length;
748 
749             // get correct cbor output length
750             uint outputlen = 0;
751             bytes[] memory elemArray = new bytes[](arrlen);
752             for (uint i = 0; i < arrlen; i++) {
753                 elemArray[i] = (bytes(arr[i]));
754                 outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types
755             }
756             uint ctr = 0;
757             uint cborlen = arrlen + 0x80;
758             outputlen += byte(cborlen).length;
759             bytes memory res = new bytes(outputlen);
760 
761             while (byte(cborlen).length > ctr) {
762                 res[ctr] = byte(cborlen)[ctr];
763                 ctr++;
764             }
765             for (i = 0; i < arrlen; i++) {
766                 res[ctr] = 0x5F;
767                 ctr++;
768                 for (uint x = 0; x < elemArray[i].length; x++) {
769                     // if there's a bug with larger strings, this may be the culprit
770                     if (x % 23 == 0) {
771                         uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;
772                         elemcborlen += 0x40;
773                         uint lctr = ctr;
774                         while (byte(elemcborlen).length > ctr - lctr) {
775                             res[ctr] = byte(elemcborlen)[ctr - lctr];
776                             ctr++;
777                         }
778                     }
779                     res[ctr] = elemArray[i][x];
780                     ctr++;
781                 }
782                 res[ctr] = 0xFF;
783                 ctr++;
784             }
785             return res;
786         }
787 
788 
789     string oraclize_network_name;
790     function oraclize_setNetworkName(string _network_name) internal {
791         oraclize_network_name = _network_name;
792     }
793 
794     function oraclize_getNetworkName() internal view returns (string) {
795         return oraclize_network_name;
796     }
797 
798     function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){
799         require((_nbytes > 0) && (_nbytes <= 32));
800         bytes memory nbytes = new bytes(1);
801         nbytes[0] = byte(_nbytes);
802         bytes memory unonce = new bytes(32);
803         bytes memory sessionKeyHash = new bytes(32);
804         bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();
805         assembly {
806             mstore(unonce, 0x20)
807             mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))
808             mstore(sessionKeyHash, 0x20)
809             mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)
810         }
811         bytes[3] memory args = [unonce, nbytes, sessionKeyHash];
812         bytes32 queryId = oraclize_query(_delay, "random", args, _customGasLimit);
813         oraclize_randomDS_setCommitment(queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));
814         return queryId;
815     }
816 
817     function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {
818         oraclize_randomDS_args[queryId] = commitment;
819     }
820 
821     mapping(bytes32=>bytes32) oraclize_randomDS_args;
822     mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;
823 
824     function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){
825         bool sigok;
826         address signer;
827 
828         bytes32 sigr;
829         bytes32 sigs;
830 
831         bytes memory sigr_ = new bytes(32);
832         uint offset = 4+(uint(dersig[3]) - 0x20);
833         sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);
834         bytes memory sigs_ = new bytes(32);
835         offset += 32 + 2;
836         sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);
837 
838         assembly {
839             sigr := mload(add(sigr_, 32))
840             sigs := mload(add(sigs_, 32))
841         }
842 
843 
844         (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);
845         if (address(keccak256(pubkey)) == signer) return true;
846         else {
847             (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);
848             return (address(keccak256(pubkey)) == signer);
849         }
850     }
851 
852     function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {
853         bool sigok;
854 
855         // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)
856         bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);
857         copyBytes(proof, sig2offset, sig2.length, sig2, 0);
858 
859         bytes memory appkey1_pubkey = new bytes(64);
860         copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);
861 
862         bytes memory tosign2 = new bytes(1+65+32);
863         tosign2[0] = byte(1); //role
864         copyBytes(proof, sig2offset-65, 65, tosign2, 1);
865         bytes memory CODEHASH = hex"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c";
866         copyBytes(CODEHASH, 0, 32, tosign2, 1+65);
867         sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);
868 
869         if (sigok == false) return false;
870 
871 
872         // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)
873         bytes memory LEDGERKEY = hex"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4";
874 
875         bytes memory tosign3 = new bytes(1+65);
876         tosign3[0] = 0xFE;
877         copyBytes(proof, 3, 65, tosign3, 1);
878 
879         bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);
880         copyBytes(proof, 3+65, sig3.length, sig3, 0);
881 
882         sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);
883 
884         return sigok;
885     }
886 
887     modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {
888         // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
889         require((_proof[0] == "L") && (_proof[1] == "P") && (_proof[2] == 1));
890 
891         bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
892         require(proofVerified);
893 
894         _;
895     }
896 
897     function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){
898         // Step 1: the prefix has to match 'LP\x01' (Ledger Proof version 1)
899         if ((_proof[0] != "L")||(_proof[1] != "P")||(_proof[2] != 1)) return 1;
900 
901         bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());
902         if (proofVerified == false) return 2;
903 
904         return 0;
905     }
906 
907     function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){
908         bool match_ = true;
909         
910 
911         for (uint256 i=0; i< n_random_bytes; i++) {
912             if (content[i] != prefix[i]) match_ = false;
913         }
914 
915         return match_;
916     }
917 
918     function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){
919 
920         // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)
921         uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;
922         bytes memory keyhash = new bytes(32);
923         copyBytes(proof, ledgerProofLength, 32, keyhash, 0);
924         if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;
925 
926         bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);
927         copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);
928 
929         // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)
930         if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;
931 
932         // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.
933         // This is to verify that the computed args match with the ones specified in the query.
934         bytes memory commitmentSlice1 = new bytes(8+1+32);
935         copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);
936 
937         bytes memory sessionPubkey = new bytes(64);
938         uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;
939         copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);
940 
941         bytes32 sessionPubkeyHash = sha256(sessionPubkey);
942         if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match
943             delete oraclize_randomDS_args[queryId];
944         } else return false;
945 
946 
947         // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)
948         bytes memory tosign1 = new bytes(32+8+1+32);
949         copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);
950         if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;
951 
952         // verify if sessionPubkeyHash was verified already, if not.. let's do it!
953         if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){
954             oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);
955         }
956 
957         return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];
958     }
959 
960     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license
961     function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {
962         uint minLength = length + toOffset;
963 
964         // Buffer too small
965         require(to.length >= minLength); // Should be a better way?
966 
967         // NOTE: the offset 32 is added to skip the `size` field of both bytes variables
968         uint i = 32 + fromOffset;
969         uint j = 32 + toOffset;
970 
971         while (i < (32 + fromOffset + length)) {
972             assembly {
973                 let tmp := mload(add(from, i))
974                 mstore(add(to, j), tmp)
975             }
976             i += 32;
977             j += 32;
978         }
979 
980         return to;
981     }
982 
983     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license
984     // Duplicate Solidity's ecrecover, but catching the CALL return value
985     function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {
986         // We do our own memory management here. Solidity uses memory offset
987         // 0x40 to store the current end of memory. We write past it (as
988         // writes are memory extensions), but don't update the offset so
989         // Solidity will reuse it. The memory used here is only needed for
990         // this context.
991 
992         // FIXME: inline assembly can't access return values
993         bool ret;
994         address addr;
995 
996         assembly {
997             let size := mload(0x40)
998             mstore(size, hash)
999             mstore(add(size, 32), v)
1000             mstore(add(size, 64), r)
1001             mstore(add(size, 96), s)
1002 
1003             // NOTE: we can reuse the request memory because we deal with
1004             //       the return code
1005             ret := call(3000, 1, 0, size, 128, size, 32)
1006             addr := mload(size)
1007         }
1008 
1009         return (ret, addr);
1010     }
1011 
1012     // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license
1013     function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {
1014         bytes32 r;
1015         bytes32 s;
1016         uint8 v;
1017 
1018         if (sig.length != 65)
1019           return (false, 0);
1020 
1021         // The signature format is a compact form of:
1022         //   {bytes32 r}{bytes32 s}{uint8 v}
1023         // Compact means, uint8 is not padded to 32 bytes.
1024         assembly {
1025             r := mload(add(sig, 32))
1026             s := mload(add(sig, 64))
1027 
1028             // Here we are loading the last 32 bytes. We exploit the fact that
1029             // 'mload' will pad with zeroes if we overread.
1030             // There is no 'mload8' to do this, but that would be nicer.
1031             v := byte(0, mload(add(sig, 96)))
1032 
1033             // Alternative solution:
1034             // 'byte' is not working due to the Solidity parser, so lets
1035             // use the second best option, 'and'
1036             // v := and(mload(add(sig, 65)), 255)
1037         }
1038 
1039         // albeit non-transactional signatures are not specified by the YP, one would expect it
1040         // to match the YP range of [27, 28]
1041         //
1042         // geth uses [0, 1] and some clients have followed. This might change, see:
1043         //  https://github.com/ethereum/go-ethereum/issues/2053
1044         if (v < 27)
1045           v += 27;
1046 
1047         if (v != 27 && v != 28)
1048             return (false, 0);
1049 
1050         return safer_ecrecover(hash, v, r, s);
1051     }
1052 
1053 }
1054 // </ORACLIZE_API>
1055 
1056 
1057 //Contract deployed as EthereumSweepstakes, rinkeby max 4000 at .000001
1058 //Contract  
1059 
1060 contract CoinInterface {
1061     function balanceOf(address _owner) public constant returns (uint256 balance);
1062     function transfer(address _to, uint256 _value) public returns (bool success);
1063 
1064     event Transfer(address indexed _from, address indexed _to, uint256 _value);
1065 }
1066 
1067 // Fixed supply token ERC standard compliant 
1068 contract SweepsToken is CoinInterface {
1069     string public constant symbol = "SWEEP";
1070     string public constant name = "Ethereum Sweepstakes SWEEP Token";
1071     uint256 _totalSupply = 4000000;
1072     
1073     address public owner;
1074 
1075     // Can have multiple tokens per address
1076     mapping(address => uint256) tokBalance;
1077 
1078     function SweepsToken() public {
1079         owner = msg.sender;
1080         tokBalance[owner] = _totalSupply;
1081     }
1082  
1083     function balanceOf(address _owner) public constant returns (uint256 balance) {
1084         return tokBalance[_owner];
1085     }
1086 
1087     function transfer(address _to, uint256 _amount) returns (bool success) {
1088         require(msg.sender == owner);
1089         if (tokBalance[msg.sender] >= _amount && _amount > 0 && tokBalance[_to] + _amount > tokBalance[_to]) {
1090             tokBalance[msg.sender] -= _amount;
1091             tokBalance[_to] += _amount;
1092             Transfer(msg.sender, _to, _amount);
1093             return true;
1094         } else {
1095             return false;
1096         }
1097     }
1098 }
1099 
1100 // 
1101 contract EthereumSweepstakes is usingOraclize {
1102     string public constant name = "Ethereum Sweepstakes";
1103     uint constant max_tickets = 4000000;
1104 
1105     address public owner;
1106     uint public sweepsCreationTime;
1107     uint256 withdrawamount;
1108 
1109 //Contract contest states
1110 
1111     enum SweepsStates {
1112         OPEN,
1113         CLOSED,
1114         DRAWING_WINNER,
1115         DRAWING_SECONDARY_WINNERS,
1116         DRAWING_TERTIARY_A_WINNERS,
1117         DRAWING_TERTIARY_B_WINNERS,
1118         DRAWING_TERTIARY_C_WINNERS,
1119         DRAWING_TERTIARY_D_WINNERS,
1120         WINNERS_PAID_SWEEPS_COMPLETE
1121     }
1122     
1123     struct JackPots {
1124         uint primaryJackpot;
1125         uint secondJackPot;
1126         uint tertiaryAJackPot;
1127         uint tertiaryBJackPot;
1128         uint tertiaryCJackPot;
1129         uint tertiaryDJackPot;
1130         // uint numPrimaryWinners; // Always 1 winner
1131         uint numSecondaryWinners;
1132         uint numTertiaryAWinners;
1133         uint numTertiaryBWinners;
1134         uint numTertiaryCWinners;
1135         uint numTertiaryDWinners;
1136     }
1137     
1138     JackPots public jackpots;
1139     SweepsStates public sweepsState;
1140     SweepsToken sweepsToken;    
1141     address[] public drawPool;  
1142     uint numTokensSold;         
1143     uint numTertiaryAWinnersPaidOut;
1144     uint numTertiaryBWinnersPaidOut;
1145     uint numTertiaryCWinnersPaidOut;
1146     uint numTertiaryDWinnersPaidOut;
1147     uint randomNumber;
1148 
1149     modifier atState(SweepsStates _state) {
1150         require(sweepsState == _state);
1151         _;
1152     }
1153 
1154     modifier StateTransitions() {
1155         if ((now >= sweepsCreationTime + 375 days) && sweepsState == SweepsStates.OPEN) { sweepsState = SweepsStates.CLOSED; }
1156         if (sweepsState == SweepsStates.CLOSED) { sweepsState = SweepsStates.DRAWING_WINNER; }
1157         _;
1158     }
1159 
1160     modifier onlyBy(address _account)
1161     {
1162         require(msg.sender == _account);
1163         _;
1164     }
1165 
1166     // ------- Events -------
1167     event tickets_bought(string _msg, uint _numTickets);
1168     event winner_announced(address _winner, uint _winnings);
1169 
1170     function EthereumSweepstakes () public {
1171         owner = msg.sender;
1172         numTokensSold = 0;
1173         sweepsState = SweepsStates.OPEN;
1174         sweepsToken = new SweepsToken();
1175         sweepsCreationTime = now;
1176     }
1177 
1178     function  management() public payable
1179         onlyBy(owner)
1180     {
1181         require(withdrawamount > 0);
1182         owner.transfer(withdrawamount);    // Limited withdraw amount for marketing, expenses, fees, etc.. 
1183         withdrawamount = 0;
1184     }
1185 
1186     function min(uint a, uint b) private pure returns (uint) {
1187         return a < b ? a : b;
1188     }
1189     
1190     function calculateJackpots() private {
1191         // jackpots in wei
1192         jackpots.primaryJackpot     = ((numTokensSold * 375 * 10**18)/1000) ;   // 37.5% of tokens sold
1193         jackpots.secondJackPot      = ((numTokensSold * 375 * 10**18)/100000);    // 10 winners of 15, 000 tokens or .375% of tokens sold
1194         jackpots.tertiaryAJackPot   = ((numTokensSold * 375 * 10**18)/1000000);   // 100 winners of 1,500 tokens or .0375% of tokens sold
1195 	    jackpots.tertiaryBJackPot   = ((numTokensSold * 375 * 10**18)/10000000);   // 1,000 winners of 150 tokens or .00375% of tokens sold
1196 	    jackpots.tertiaryCJackPot   = ((numTokensSold * 375 * 10**18)/100000000);   // 10,000 winners of 15 tokens or .000375% of tokens sold
1197 	    jackpots.tertiaryDJackPot   = ((numTokensSold * 375 * 10**18)/1000000000);   // 100,000 winners of 1.5 tokens or .0000375% of tokens sold
1198 
1199         // Pre-Calculate number of winners in each category based on number of tickets sold
1200         //jackpots.numPrimaryWinners = 1;
1201         jackpots.numSecondaryWinners = min(10, numTokensSold > 1 ? (numTokensSold-1) : 0);
1202         jackpots.numTertiaryAWinners = min(100, numTokensSold > 11 ? (numTokensSold-11) : 0);
1203         jackpots.numTertiaryBWinners = min(1000, numTokensSold > 111 ? (numTokensSold-111) : 0);
1204         jackpots.numTertiaryCWinners = min(10000, numTokensSold > 1111 ? (numTokensSold-1111) : 0);
1205         jackpots.numTertiaryDWinners = min(100000, numTokensSold > 11111 ? (numTokensSold-11111) : 0);
1206     }
1207     
1208     function buyTokens() public payable
1209         StateTransitions
1210         atState(SweepsStates.OPEN)
1211         returns(bool success) 
1212     {
1213         require(numTokensSold < max_tickets);
1214         uint tokensBought = 0;
1215 
1216         // Only taking payment in multiple of 1 ether, as 1 ether = 1 token
1217         uint etherReceived = msg.value/(10**18);
1218 
1219         // Check that we have enough tokens left
1220         uint tokensRemaining = sweepsToken.balanceOf(this);
1221         assert(tokensRemaining > 0);
1222 	    require(etherReceived <= 10);
1223         if (tokensRemaining >= etherReceived) {
1224             tokensBought = etherReceived;
1225             tokensRemaining -= etherReceived;
1226         } else {
1227             tokensBought = tokensRemaining;
1228             tokensRemaining = 0;
1229         }
1230 
1231         for (uint i = 0; i < tokensBought; i++) {
1232             drawPool.push(msg.sender);
1233             numTokensSold++;
1234         }
1235 
1236         tickets_bought("Payment received; Sweeps tokens sent", tokensBought);
1237 
1238         // No more tokens remaining Close sweeps
1239         if (tokensRemaining <= 0) {
1240             sweepsState = SweepsStates.CLOSED;
1241         }
1242 
1243         withdrawamount += ((tokensBought*10**18)*40)/100;  
1244 
1245         if (sweepsToken.transfer(msg.sender, tokensBought) == false) {
1246             revert();
1247         }
1248         
1249         return true;
1250     }
1251     
1252     function updateRandomNumber(uint numBytes, uint callBackGas) private
1253         onlyBy(owner)
1254     {
1255         uint N = numBytes;
1256         uint delay = 0;
1257         oraclize_newRandomDSQuery(delay, N, callBackGas);
1258     }
1259 
1260     function __callback(bytes32 _queryId, string _result, bytes _proof)
1261     { 
1262         if (msg.sender != oraclize_cbAddress()) {
1263             revert();
1264         }
1265         
1266         if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
1267             randomNumber = uint(block.blockhash(block.number-1));
1268         } else {
1269             randomNumber = uint(keccak256(_result));
1270         }
1271 
1272         // Primary Winner 
1273         if (sweepsState == SweepsStates.DRAWING_WINNER) {
1274             require(numTokensSold >= 1);
1275             sweepsState = SweepsStates.DRAWING_SECONDARY_WINNERS;
1276 
1277             uint rand = randomNumber % numTokensSold;
1278             var endIndex = numTokensSold - 1;
1279             address primaryWinner = drawPool[rand];
1280             drawPool[rand] = drawPool[endIndex];
1281             delete drawPool[endIndex];
1282             --numTokensSold;
1283 
1284             winner_announced(primaryWinner, jackpots.primaryJackpot);
1285 
1286             primaryWinner.transfer(jackpots.primaryJackpot);
1287         }
1288     }
1289 
1290    function closeOutSweeps() public payable
1291         StateTransitions
1292         onlyBy(owner)
1293         atState(SweepsStates.DRAWING_WINNER)
1294         returns(bool result) 
1295     {
1296         calculateJackpots();
1297         oraclize_setProof(proofType_Ledger);
1298         updateRandomNumber(32, 1000000);
1299         return true;
1300     }
1301 
1302     function drawWinners(uint numWinners, uint jackpot, uint shift) payable 
1303         onlyBy(owner)    
1304     {
1305         require(numWinners > 0);
1306 
1307         uint rand = randomNumber ^ uint(block.blockhash(block.number-1));
1308 
1309         uint winnerIndex;
1310         address[] memory winnerAddresses = new address[](numWinners);
1311         uint bitMask = uint(0x3FFFFF);
1312         uint endIndex = numTokensSold - 1;
1313         for (uint j = 0; j < numWinners; j++) {
1314             winnerIndex = uint(rand & bitMask) % numTokensSold;
1315             rand >>= shift;
1316 
1317             if (j > 255) {
1318                 rand ^= (rand << 104);
1319                 rand ^= (rand >> 136);
1320                 rand ^= (rand << 40);
1321                 rand = (rand ^ uint(block.blockhash(block.number-1)));
1322             }
1323             
1324             winnerAddresses[j] = drawPool[winnerIndex];
1325             drawPool[winnerIndex] = drawPool[endIndex];
1326             delete drawPool[endIndex];
1327             --endIndex;
1328             --numTokensSold;
1329         }
1330 
1331         for (j = 0; j < numWinners; j++) {
1332             winner_announced(winnerAddresses[j], jackpot);
1333             winnerAddresses[j].transfer(jackpot);
1334         }
1335     }
1336 
1337     // 10 winners of 15,000 tokens or .375% of tokens sold
1338     function drawSecondaryWinners() public payable
1339         onlyBy(owner)
1340         atState(SweepsStates.DRAWING_SECONDARY_WINNERS)
1341     {
1342         require(numTokensSold > 1);
1343         sweepsState = SweepsStates.DRAWING_TERTIARY_A_WINNERS;
1344 
1345         drawWinners(jackpots.numSecondaryWinners, jackpots.secondJackPot, 22);
1346     }
1347 
1348     // 100 winners of 1,500 tokens or .0375% of tokens sold
1349     function drawTertiaryAWinners(uint numToProcess) public payable
1350         onlyBy(owner)
1351         atState(SweepsStates.DRAWING_TERTIARY_A_WINNERS)
1352     {
1353         require(numTokensSold > 1);
1354         require(numToProcess > 0);
1355 
1356         uint numWinnersToProcess = min(numToProcess, jackpots.numTertiaryAWinners - numTertiaryAWinnersPaidOut);
1357         if (numWinnersToProcess < numToProcess) {
1358             sweepsState = SweepsStates.DRAWING_TERTIARY_B_WINNERS;
1359         }
1360                 
1361         numTertiaryAWinnersPaidOut += numWinnersToProcess;
1362         drawWinners(jackpots.numTertiaryAWinners, jackpots.tertiaryAJackPot, 1);
1363     }
1364 
1365     // 1,000 winners of 150 tokens or .00375% of tokens sold
1366     function drawTertiaryBWinners(uint numToProcess) public payable
1367         onlyBy(owner)
1368         atState(SweepsStates.DRAWING_TERTIARY_B_WINNERS)
1369     {
1370         require(numTokensSold > 1);
1371         require(numToProcess > 0);
1372 
1373         uint numWinnersToProcess = min(numToProcess, jackpots.numTertiaryBWinners - numTertiaryBWinnersPaidOut);
1374         if (numWinnersToProcess < numToProcess) {
1375             sweepsState = SweepsStates.DRAWING_TERTIARY_C_WINNERS;
1376         }
1377                 
1378         numTertiaryBWinnersPaidOut += numWinnersToProcess;
1379         drawWinners(numWinnersToProcess, jackpots.tertiaryBJackPot, 1);
1380     }
1381 
1382     // 10,000 winners of 15 tokens or .000375% of tokens sold
1383     function drawTertiaryCWinners(uint numToProcess) public payable
1384         onlyBy(owner)
1385         atState(SweepsStates.DRAWING_TERTIARY_C_WINNERS)
1386     {
1387         require(numTokensSold > 1);
1388         require(numToProcess > 0);
1389 
1390         uint numWinnersToProcess = min(numToProcess, jackpots.numTertiaryCWinners - numTertiaryCWinnersPaidOut);
1391         if (numWinnersToProcess < numToProcess) {
1392             sweepsState = SweepsStates.DRAWING_TERTIARY_D_WINNERS;
1393         }
1394 
1395         numTertiaryCWinnersPaidOut += numWinnersToProcess;
1396         drawWinners(numWinnersToProcess, jackpots.tertiaryCJackPot, 1);
1397     }
1398 
1399     // 100,000 winners of 1.5 tokens or .0000375% of tokens sold
1400     function drawTertiaryDWinners(uint numToProcess) public payable
1401         onlyBy(owner)
1402         atState(SweepsStates.DRAWING_TERTIARY_D_WINNERS)
1403     {
1404         require(numTokensSold > 1);
1405         require(numToProcess > 0);
1406 
1407         uint numWinnersToProcess = min(numToProcess, jackpots.numTertiaryDWinners - numTertiaryDWinnersPaidOut);
1408         if (numWinnersToProcess < numToProcess) {
1409             sweepsState = SweepsStates.WINNERS_PAID_SWEEPS_COMPLETE;
1410         }
1411         numTertiaryDWinnersPaidOut += numWinnersToProcess;
1412         drawWinners(numWinnersToProcess, jackpots.tertiaryDJackPot, 1);
1413     }
1414     
1415     //function to add ether to contract
1416     function Fund_Contract () public payable {}
1417 
1418     function () public payable {
1419         buyTokens();
1420     }
1421     
1422     function cleanUp() public payable
1423         onlyBy(owner)
1424     {
1425         require(sweepsState > SweepsStates.DRAWING_WINNER);
1426        
1427         // Transfer Eth to owner and terminate contract
1428         //*only apllicable after Smart Contract has drawn Jackpot winner
1429         selfdestruct(owner);
1430     }
1431 }