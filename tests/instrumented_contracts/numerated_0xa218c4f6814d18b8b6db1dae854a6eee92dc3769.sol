1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/PunksVoxels.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.12;\r\n\r\n/**\r\n* @notice PunksVoxels ERC721 wrapper contract and ApeVoxels ERC721 contract\r\n* @author DeMemeTree and MarbuR7\r\n*/\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\nlibrary Strings {\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) external view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: invalid token ID\");\r\n        return owner;\r\n    }\r\n\r\n    function name() external view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) external view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) external virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not token owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        _requireMinted(tokenId);\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, data);\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        // THE BALANCES GET UPDATED OUTSIDE OF THIS FUNCTION IN A MANNER OF ALL AT ONCE\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _requireMinted(uint256 tokenId) internal view virtual {\r\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    /// @solidity memory-safe-assembly\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n}\r\n\r\ncontract ApeVoxels is ERC721, ReentrancyGuard, Ownable {\r\n    address private whoCanMint;\r\n    string private baseURIForOGApeVoxels = \"ipfs://\";\r\n    string private baseExt = \".json\";\r\n    string private baseURIForCollectionData = \"ipfs://\";\r\n    uint private totalMinted = 0;\r\n\r\n    constructor(address owner_, address whoCanMint_) ERC721(\"ApeVoxels\", \"ApeVoxels\") {\r\n        transferOwnership(owner_);\r\n        whoCanMint = whoCanMint_;\r\n    }\r\n\r\n    receive() external payable {\r\n        (bool sent, ) = payable(owner()).call{value: msg.value}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n\r\n    function mint(address user, uint id) external {\r\n        require(msg.sender == whoCanMint, \"Sorry you cant mint\");\r\n        _mint(user, id);\r\n    }\r\n\r\n    function emergencyMint(uint id) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        require(id >= 0, \"Id must be in the range 0-9999\");\r\n        require(id <= 9999, \"Id must be in the range 0-9999\");\r\n        _mint(msg.sender, id);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(baseURIForOGApeVoxels, Strings.toString(tokenId), baseExt));\r\n    }\r\n\r\n    function updateOwner(address owner_) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        require(owner_ != address(0));\r\n        transferOwnership(owner_);\r\n    }\r\n\r\n    function withdraw() external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        uint256 _balance = address(this).balance;\r\n        require(payable(msg.sender).send(_balance));\r\n    }\r\n\r\n    function setExtension(string calldata _baseExt) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseExt = _baseExt;\r\n    }\r\n\r\n    function setURIOG(string calldata _baseURI) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseURIForOGApeVoxels = _baseURI;\r\n    }\r\n\r\n    function setURIForCollection(string calldata _baseURICollection) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseURIForCollectionData = _baseURICollection;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return string(abi.encodePacked(baseURIForCollectionData));\r\n    }\r\n\r\n    function exists(uint256 tokenId) external view virtual returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n\r\n    function updateSupply(uint count, address whoToMintTo) external {\r\n        require(msg.sender == whoCanMint, \"Sorry you cant mint\");\r\n        unchecked {\r\n            _balances[whoToMintTo] += count;\r\n            totalMinted += count;\r\n        }\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalMinted;\r\n    }\r\n}\r\n\r\ncontract PunksVoxels is ERC721, ReentrancyGuard, IERC721Receiver, IERC1155Receiver, Ownable {\r\n    string private baseURIForOGPunksVoxels = \"ipfs://\";\r\n    string private baseExt = \".json\";\r\n    string private baseURIForCollectionData = \"ipfs://\";\r\n    IERC1155 internal punkVoxels;\r\n    ApeVoxels punkApes;\r\n    uint private totalMinted = 0;\r\n\r\n    constructor(address punkVoxels_) ERC721(\"PunksVoxels\", \"PunksVoxels\") {\r\n        punkVoxels = IERC1155(punkVoxels_);\r\n        punkApes = new ApeVoxels(msg.sender, address(this));\r\n    }\r\n\r\n    receive() external payable {\r\n        (bool sent, ) = payable(owner()).call{value: msg.value}(\"\");\r\n        require(sent, \"Failed to send Ether\");\r\n    }\r\n\r\n    function wrapMany(uint[] calldata tokenIds) nonReentrant external {\r\n        require(\r\n            punkVoxels.isApprovedForAll(msg.sender, address(this)),\r\n            \"You need approval\"\r\n        );\r\n        require(tokenIds.length > 0, \"Must have something\");\r\n\r\n        uint count = tokenIds.length;\r\n        uint[] memory qty = new uint[](count);\r\n        for(uint i = 0; i < count;) {\r\n            require(_exists(tokenIds[i]) == false, \"Token already minted\");\r\n            require(isValidPunk(tokenIds[i]), \"Not a valid PunkVoxels\");\r\n            qty[i] = 1;\r\n            unchecked { i++; }\r\n        }\r\n\r\n        punkVoxels.safeBatchTransferFrom(msg.sender, address(this), tokenIds, qty, \"\");\r\n\r\n        uint countToUpdatePunks = 0;\r\n        uint countToUpdateApes = 0;\r\n        for(uint i = 0; i < count;) {\r\n            // Mint the PunkVoxel\r\n            _mint(msg.sender, tokenIds[i]);\r\n            countToUpdatePunks = countToUpdatePunks + 1;\r\n\r\n            // Mint the ApeVoxel\r\n            uint newId = toPunkId(tokenIds[i]);\r\n            if(punkApes.exists(newId) == false) {\r\n                punkApes.mint(msg.sender, newId);\r\n                countToUpdateApes = countToUpdateApes + 1;\r\n            }\r\n\r\n            unchecked { i++; }\r\n        }\r\n\r\n        if (countToUpdatePunks > 0) {\r\n            _balances[msg.sender] += countToUpdatePunks;\r\n            totalMinted += countToUpdatePunks;\r\n        }\r\n        if (countToUpdateApes > 0) {\r\n            punkApes.updateSupply(countToUpdateApes, msg.sender);\r\n        }\r\n    }\r\n\r\n    function unwrapMany(uint[] calldata tokenIds) nonReentrant external {\r\n        require(tokenIds.length > 0, \"Must have something\");\r\n\r\n        uint count = tokenIds.length;\r\n        uint[] memory qty = new uint[](count);\r\n        uint countToUpdatePunks = 0;\r\n        for(uint i = 0; i < count;) {\r\n            qty[i] = 1;\r\n            require(msg.sender == ownerOf(tokenIds[i]), \"Bruh.. you dont own that\");\r\n            _burn(tokenIds[i]);\r\n            countToUpdatePunks = countToUpdatePunks + 1;\r\n            unchecked { i++; }\r\n        }\r\n\r\n        punkVoxels.safeBatchTransferFrom(address(this), msg.sender, tokenIds, qty, \"\");\r\n\r\n        if (countToUpdatePunks > 0) {\r\n            totalMinted -= countToUpdatePunks;\r\n        }\r\n    }\r\n\r\n\tfunction isValidPunk(uint256 openseaId) public pure returns(bool) {\r\n\t\tif (openseaId >> 96 != 0x0000000000000000000000002f77f1bd06f98d2e7e537ab86bcba23559b5c03f)\r\n\t\t\treturn false;\r\n\t\tif (openseaId & 0x000000000000000000000000000000000000000000000000000000ffffffffff != 1)\r\n\t\t\treturn false;\r\n\t\tuint256 id = (openseaId & 0x0000000000000000000000000000000000000000ffffffffffffff0000000000) >> 40;\r\n\t\tif (id > 9999 || id == 0 || id == 1 || id == 41 || id == 51 || id == 68 || id == 100 || id == 101 || id == 102 ||\r\n            id == 107 || id == 114 || id == 3014 || id == 3195 || id == 4157)\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n    function toPunkId(uint256 openseaId) public pure returns (uint256) {\r\n        uint256 id = (openseaId &\r\n            0x0000000000000000000000000000000000000000ffffffffffffff0000000000) >> 40;\r\n        if (id < 41) return id - 2;\r\n        else if (id > 41 && id < 51) return id - 3;\r\n        else if (id > 51 && id < 68) return id - 4;\r\n        else if (id > 68 && id < 106) return id - 5;\r\n        else if (id == 106) return id + 3944;\r\n        else if (id == 108) return id + 4896;\r\n        else if (id > 1103 && id < 1471) return id - 1003;\r\n        else if (id ==  1471) return id + 2863;\r\n        else if (id > 1471 && id < 1768) return id - 1004;\r\n        else if (id > 1767 && id < 2003) return id - 1003;\r\n        else if (id > 108 && id < 114) return id + 891;\r\n        else if (id > 114 && id < 135) return id + 890;\r\n        else if (id > 134 && id < 231) return id + 891;\r\n        else if (id > 230 && id < 249) return id + 892;\r\n        else if (id > 248 && id < 264) return id + 893;\r\n        else if (id > 263 && id < 342) return id + 894;\r\n        else if (id > 341 && id < 1008) return id + 895;\r\n        else if (id > 1007 && id < 1104) return id + 896;\r\n        else if (id > 2002 && id < 3286) return id - 3;\r\n        else if (id > 3285 && id < 4052) return id - 2;\r\n        else if (id > 4051 && id < 4335) return id - 1;\r\n        else if (id > 4334 && id < 5004) return id;\r\n        else if (id > 5003 && id < 5452) return id + 1;\r\n        else if (id > 5451 && id < 9998) return id + 2;\r\n        else if (id == 9998) return id - 5842;\r\n        else if (id == 9999) return id - 6988;\r\n        return id;\r\n    }\r\n\r\n    function updateOwner(address owner_) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        require(owner_ != address(0));\r\n        transferOwnership(owner_);\r\n    }\r\n\r\n    function withdraw() external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        uint256 _balance = address(this).balance;\r\n        require(payable(msg.sender).send(_balance));\r\n    }\r\n\r\n    function setExtension(string calldata _baseExt) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseExt = _baseExt;\r\n    }\r\n\r\n    function onERC721Received(address, address, uint256, bytes calldata) pure external returns(bytes4) {\r\n        return PunksVoxels.onERC721Received.selector;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) pure external returns (bytes4) {\r\n        return PunksVoxels.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) pure external returns (bytes4) {\r\n        return PunksVoxels.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return string(abi.encodePacked(baseURIForOGPunksVoxels, Strings.toString(toPunkId(tokenId)), baseExt));\r\n    }\r\n\r\n    function setURIOG(string calldata _baseURI) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseURIForOGPunksVoxels = _baseURI;\r\n    }\r\n\r\n    function setURIForCollection(string calldata _baseURICollection) external {\r\n        require(msg.sender == owner(), \"You are not the owner\");\r\n        baseURIForCollectionData = _baseURICollection;\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return string(abi.encodePacked(baseURIForCollectionData));\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalMinted;\r\n    }\r\n\r\n    function apesContractAddress() external view returns (address) {\r\n        return address(punkApes);\r\n    }\r\n}\r\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": true,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}