1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19  
20 pragma solidity ^0.4.23;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   function totalSupply() public view returns (uint256);
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42 
43   /**
44   * @dev Multiplies two numbers, throws on overflow.
45   */
46   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
47     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
48     // benefit is lost if 'b' is also tested.
49     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
50     if (a == 0) {
51       return 0;
52     }
53 
54     c = a * b;
55     assert(c / a == b);
56     return c;
57   }
58 
59   /**
60   * @dev Integer division of two numbers, truncating the quotient.
61   */
62   function div(uint256 a, uint256 b) internal pure returns (uint256) {
63     // assert(b > 0); // Solidity automatically throws when dividing by 0
64     // uint256 c = a / b;
65     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
66     return a / b;
67   }
68 
69   /**
70   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
71   */
72   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
73     assert(b <= a);
74     return a - b;
75   }
76 
77   /**
78   * @dev Adds two numbers, throws on overflow.
79   */
80   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
81     c = a + b;
82     assert(c >= a);
83     return c;
84   }
85 }
86 
87 
88 
89 /**
90  * @title Basic token
91  * @dev Basic version of StandardToken, with no allowances.
92  */
93 contract BasicToken is ERC20Basic {
94   using SafeMath for uint256;
95 
96   mapping(address => uint256) balances;
97 
98   uint256 totalSupply_;
99 
100   /**
101   * @dev total number of tokens in existence
102   */
103   function totalSupply() public view returns (uint256) {
104     return totalSupply_;
105   }
106 
107   /**
108   * @dev transfer token for a specified address
109   * @param _to The address to transfer to.
110   * @param _value The amount to be transferred.
111   */
112   function transfer(address _to, uint256 _value) public returns (bool) {
113     require(_to != address(0));
114     require(_value <= balances[msg.sender]);
115 
116     balances[msg.sender] = balances[msg.sender].sub(_value);
117     balances[_to] = balances[_to].add(_value);
118     emit Transfer(msg.sender, _to, _value);
119     return true;
120   }
121 
122   /**
123   * @dev Gets the balance of the specified address.
124   * @param _owner The address to query the the balance of.
125   * @return An uint256 representing the amount owned by the passed address.
126   */
127   function balanceOf(address _owner) public view returns (uint256) {
128     return balances[_owner];
129   }
130 
131 }
132 
133 
134 /**
135  * @title ERC20 interface
136  * @dev see https://github.com/ethereum/EIPs/issues/20
137  */
138 contract ERC20 is ERC20Basic {
139   function allowance(address owner, address spender)
140     public view returns (uint256);
141 
142   function transferFrom(address from, address to, uint256 value)
143     public returns (bool);
144 
145   function approve(address spender, uint256 value) public returns (bool);
146   event Approval(
147     address indexed owner,
148     address indexed spender,
149     uint256 value
150   );
151 }
152 
153 
154 /**
155  * @title Standard ERC20 token
156  *
157  * @dev Implementation of the basic standard token.
158  * @dev https://github.com/ethereum/EIPs/issues/20
159  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
160  */
161 contract StandardToken is ERC20, BasicToken {
162 
163   mapping (address => mapping (address => uint256)) internal allowed;
164 
165 
166   /**
167    * @dev Transfer tokens from one address to another
168    * @param _from address The address which you want to send tokens from
169    * @param _to address The address which you want to transfer to
170    * @param _value uint256 the amount of tokens to be transferred
171    */
172   function transferFrom(
173     address _from,
174     address _to,
175     uint256 _value
176   )
177     public
178     returns (bool)
179   {
180     require(_to != address(0));
181     require(_value <= balances[_from]);
182     require(_value <= allowed[_from][msg.sender]);
183 
184     balances[_from] = balances[_from].sub(_value);
185     balances[_to] = balances[_to].add(_value);
186     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
187     emit Transfer(_from, _to, _value);
188     return true;
189   }
190 
191   /**
192    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
193    *
194    * Beware that changing an allowance with this method brings the risk that someone may use both the old
195    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
196    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
197    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
198    * @param _spender The address which will spend the funds.
199    * @param _value The amount of tokens to be spent.
200    */
201   function approve(address _spender, uint256 _value) public returns (bool) {
202     allowed[msg.sender][_spender] = _value;
203     emit Approval(msg.sender, _spender, _value);
204     return true;
205   }
206 
207   /**
208    * @dev Function to check the amount of tokens that an owner allowed to a spender.
209    * @param _owner address The address which owns the funds.
210    * @param _spender address The address which will spend the funds.
211    * @return A uint256 specifying the amount of tokens still available for the spender.
212    */
213   function allowance(
214     address _owner,
215     address _spender
216    )
217     public
218     view
219     returns (uint256)
220   {
221     return allowed[_owner][_spender];
222   }
223 
224   /**
225    * @dev Increase the amount of tokens that an owner allowed to a spender.
226    *
227    * approve should be called when allowed[_spender] == 0. To increment
228    * allowed value is better to use this function to avoid 2 calls (and wait until
229    * the first transaction is mined)
230    * From MonolithDAO Token.sol
231    * @param _spender The address which will spend the funds.
232    * @param _addedValue The amount of tokens to increase the allowance by.
233    */
234   function increaseApproval(
235     address _spender,
236     uint _addedValue
237   )
238     public
239     returns (bool)
240   {
241     allowed[msg.sender][_spender] = (
242       allowed[msg.sender][_spender].add(_addedValue));
243     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
244     return true;
245   }
246 
247   /**
248    * @dev Decrease the amount of tokens that an owner allowed to a spender.
249    *
250    * approve should be called when allowed[_spender] == 0. To decrement
251    * allowed value is better to use this function to avoid 2 calls (and wait until
252    * the first transaction is mined)
253    * From MonolithDAO Token.sol
254    * @param _spender The address which will spend the funds.
255    * @param _subtractedValue The amount of tokens to decrease the allowance by.
256    */
257   function decreaseApproval(
258     address _spender,
259     uint _subtractedValue
260   )
261     public
262     returns (bool)
263   {
264     uint oldValue = allowed[msg.sender][_spender];
265     if (_subtractedValue > oldValue) {
266       allowed[msg.sender][_spender] = 0;
267     } else {
268       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
269     }
270     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
271     return true;
272   }
273 
274 }
275 
276 
277 
278 /**
279  * @title Ownable
280  * @dev The Ownable contract has an owner address, and provides basic authorization control
281  * functions, this simplifies the implementation of "user permissions".
282  */
283 contract Ownable {
284   address public owner;
285 
286 
287   event OwnershipRenounced(address indexed previousOwner);
288   event OwnershipTransferred(
289     address indexed previousOwner,
290     address indexed newOwner
291   );
292 
293 
294   /**
295    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
296    * account.
297    */
298   constructor() public {
299     owner = msg.sender;
300   }
301 
302   /**
303    * @dev Throws if called by any account other than the owner.
304    */
305   modifier onlyOwner() {
306     require(msg.sender == owner);
307     _;
308   }
309 
310   /**
311    * @dev Allows the current owner to relinquish control of the contract.
312    */
313   function renounceOwnership() public onlyOwner {
314     emit OwnershipRenounced(owner);
315     owner = address(0);
316   }
317 
318   /**
319    * @dev Allows the current owner to transfer control of the contract to a newOwner.
320    * @param _newOwner The address to transfer ownership to.
321    */
322   function transferOwnership(address _newOwner) public onlyOwner {
323     _transferOwnership(_newOwner);
324   }
325 
326   /**
327    * @dev Transfers control of the contract to a newOwner.
328    * @param _newOwner The address to transfer ownership to.
329    */
330   function _transferOwnership(address _newOwner) internal {
331     require(_newOwner != address(0));
332     emit OwnershipTransferred(owner, _newOwner);
333     owner = _newOwner;
334   }
335 }
336 
337 
338 /**
339  * @title Mintable token
340  * @dev Simple ERC20 Token example, with mintable token creation
341  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
342  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
343  */
344 contract MintableToken is StandardToken, Ownable {
345   event Mint(address indexed to, uint256 amount);
346   event MintFinished();
347 
348   bool public mintingFinished = false;
349 
350 
351   modifier canMint() {
352     require(!mintingFinished);
353     _;
354   }
355 
356   modifier hasMintPermission() {
357     require(msg.sender == owner);
358     _;
359   }
360 
361   /**
362    * @dev Function to mint tokens
363    * @param _to The address that will receive the minted tokens.
364    * @param _amount The amount of tokens to mint.
365    * @return A boolean that indicates if the operation was successful.
366    */
367   function mint(
368     address _to,
369     uint256 _amount
370   )
371     hasMintPermission
372     canMint
373     public
374     returns (bool)
375   {
376     totalSupply_ = totalSupply_.add(_amount);
377     balances[_to] = balances[_to].add(_amount);
378     emit Mint(_to, _amount);
379     emit Transfer(address(0), _to, _amount);
380     return true;
381   }
382 
383   /**
384    * @dev Function to stop minting new tokens.
385    * @return True if the operation was successful.
386    */
387   function finishMinting() onlyOwner canMint public returns (bool) {
388     mintingFinished = true;
389     emit MintFinished();
390     return true;
391   }
392 }
393 
394 
395 contract FreezableToken is StandardToken {
396     // freezing chains
397     mapping (bytes32 => uint64) internal chains;
398     // freezing amounts for each chain
399     mapping (bytes32 => uint) internal freezings;
400     // total freezing balance per address
401     mapping (address => uint) internal freezingBalance;
402 
403     event Freezed(address indexed to, uint64 release, uint amount);
404     event Released(address indexed owner, uint amount);
405 
406     /**
407      * @dev Gets the balance of the specified address include freezing tokens.
408      * @param _owner The address to query the the balance of.
409      * @return An uint256 representing the amount owned by the passed address.
410      */
411     function balanceOf(address _owner) public view returns (uint256 balance) {
412         return super.balanceOf(_owner) + freezingBalance[_owner];
413     }
414 
415     /**
416      * @dev Gets the balance of the specified address without freezing tokens.
417      * @param _owner The address to query the the balance of.
418      * @return An uint256 representing the amount owned by the passed address.
419      */
420     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
421         return super.balanceOf(_owner);
422     }
423 
424     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
425         return freezingBalance[_owner];
426     }
427 
428     /**
429      * @dev gets freezing count
430      * @param _addr Address of freeze tokens owner.
431      */
432     function freezingCount(address _addr) public view returns (uint count) {
433         uint64 release = chains[toKey(_addr, 0)];
434         while (release != 0) {
435             count++;
436             release = chains[toKey(_addr, release)];
437         }
438     }
439 
440     /**
441      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
442      * @param _addr Address of freeze tokens owner.
443      * @param _index Freezing portion index. It ordered by release date descending.
444      */
445     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
446         for (uint i = 0; i < _index + 1; i++) {
447             _release = chains[toKey(_addr, _release)];
448             if (_release == 0) {
449                 return;
450             }
451         }
452         _balance = freezings[toKey(_addr, _release)];
453     }
454 
455     /**
456      * @dev freeze your tokens to the specified address.
457      *      Be careful, gas usage is not deterministic,
458      *      and depends on how many freezes _to address already has.
459      * @param _to Address to which token will be freeze.
460      * @param _amount Amount of token to freeze.
461      * @param _until Release date, must be in future.
462      */
463     function freezeTo(address _to, uint _amount, uint64 _until) public {
464         require(_to != address(0));
465         require(_amount <= balances[msg.sender]);
466 
467         balances[msg.sender] = balances[msg.sender].sub(_amount);
468 
469         bytes32 currentKey = toKey(_to, _until);
470         freezings[currentKey] = freezings[currentKey].add(_amount);
471         freezingBalance[_to] = freezingBalance[_to].add(_amount);
472 
473         freeze(_to, _until);
474         emit Transfer(msg.sender, _to, _amount);
475         emit Freezed(_to, _until, _amount);
476     }
477 
478     /**
479      * @dev release first available freezing tokens.
480      */
481     function releaseOnce() public {
482         bytes32 headKey = toKey(msg.sender, 0);
483         uint64 head = chains[headKey];
484         require(head != 0);
485         require(uint64(block.timestamp) > head);
486         bytes32 currentKey = toKey(msg.sender, head);
487 
488         uint64 next = chains[currentKey];
489 
490         uint amount = freezings[currentKey];
491         delete freezings[currentKey];
492 
493         balances[msg.sender] = balances[msg.sender].add(amount);
494         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
495 
496         if (next == 0) {
497             delete chains[headKey];
498         } else {
499             chains[headKey] = next;
500             delete chains[currentKey];
501         }
502         emit Released(msg.sender, amount);
503     }
504 
505     /**
506      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
507      * @return how many tokens was released
508      */
509     function releaseAll() public returns (uint tokens) {
510         uint release;
511         uint balance;
512         (release, balance) = getFreezing(msg.sender, 0);
513         while (release != 0 && block.timestamp > release) {
514             releaseOnce();
515             tokens += balance;
516             (release, balance) = getFreezing(msg.sender, 0);
517         }
518     }
519 
520     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
521         // WISH masc to increase entropy
522         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
523         assembly {
524             result := or(result, mul(_addr, 0x10000000000000000))
525             result := or(result, _release)
526         }
527     }
528 
529     function freeze(address _to, uint64 _until) internal {
530         require(_until > block.timestamp);
531         bytes32 key = toKey(_to, _until);
532         bytes32 parentKey = toKey(_to, uint64(0));
533         uint64 next = chains[parentKey];
534 
535         if (next == 0) {
536             chains[parentKey] = _until;
537             return;
538         }
539 
540         bytes32 nextKey = toKey(_to, next);
541         uint parent;
542 
543         while (next != 0 && _until > next) {
544             parent = next;
545             parentKey = nextKey;
546 
547             next = chains[nextKey];
548             nextKey = toKey(_to, next);
549         }
550 
551         if (_until == next) {
552             return;
553         }
554 
555         if (next != 0) {
556             chains[key] = next;
557         }
558 
559         chains[parentKey] = _until;
560     }
561 }
562 
563 
564 /**
565  * @title Burnable Token
566  * @dev Token that can be irreversibly burned (destroyed).
567  */
568 contract BurnableToken is BasicToken {
569 
570   event Burn(address indexed burner, uint256 value);
571 
572   /**
573    * @dev Burns a specific amount of tokens.
574    * @param _value The amount of token to be burned.
575    */
576   function burn(uint256 _value) public {
577     _burn(msg.sender, _value);
578   }
579 
580   function _burn(address _who, uint256 _value) internal {
581     require(_value <= balances[_who]);
582     // no need to require value <= totalSupply, since that would imply the
583     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
584 
585     balances[_who] = balances[_who].sub(_value);
586     totalSupply_ = totalSupply_.sub(_value);
587     emit Burn(_who, _value);
588     emit Transfer(_who, address(0), _value);
589   }
590 }
591 
592 
593 
594 /**
595  * @title Pausable
596  * @dev Base contract which allows children to implement an emergency stop mechanism.
597  */
598 contract Pausable is Ownable {
599   event Pause();
600   event Unpause();
601 
602   bool public paused = false;
603 
604 
605   /**
606    * @dev Modifier to make a function callable only when the contract is not paused.
607    */
608   modifier whenNotPaused() {
609     require(!paused);
610     _;
611   }
612 
613   /**
614    * @dev Modifier to make a function callable only when the contract is paused.
615    */
616   modifier whenPaused() {
617     require(paused);
618     _;
619   }
620 
621   /**
622    * @dev called by the owner to pause, triggers stopped state
623    */
624   function pause() onlyOwner whenNotPaused public {
625     paused = true;
626     emit Pause();
627   }
628 
629   /**
630    * @dev called by the owner to unpause, returns to normal state
631    */
632   function unpause() onlyOwner whenPaused public {
633     paused = false;
634     emit Unpause();
635   }
636 }
637 
638 
639 contract FreezableMintableToken is FreezableToken, MintableToken {
640     /**
641      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
642      *      Be careful, gas usage is not deterministic,
643      *      and depends on how many freezes _to address already has.
644      * @param _to Address to which token will be freeze.
645      * @param _amount Amount of token to mint and freeze.
646      * @param _until Release date, must be in future.
647      * @return A boolean that indicates if the operation was successful.
648      */
649     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
650         totalSupply_ = totalSupply_.add(_amount);
651 
652         bytes32 currentKey = toKey(_to, _until);
653         freezings[currentKey] = freezings[currentKey].add(_amount);
654         freezingBalance[_to] = freezingBalance[_to].add(_amount);
655 
656         freeze(_to, _until);
657         emit Mint(_to, _amount);
658         emit Freezed(_to, _until, _amount);
659         emit Transfer(msg.sender, _to, _amount);
660         return true;
661     }
662 }
663 
664 
665 
666 contract Consts {
667     uint public constant TOKEN_DECIMALS = 18;
668     uint8 public constant TOKEN_DECIMALS_UINT8 = 18;
669     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
670 
671     string public constant TOKEN_NAME = "NutriLife";
672     string public constant TOKEN_SYMBOL = "NLC";
673     bool public constant PAUSED = false;
674     address public constant TARGET_USER = 0x7A72911D42387d01D7396542fE8b4cF2e84F9B35;
675     
676     uint public constant START_TIME = 1550239740;
677     
678     bool public constant CONTINUE_MINTING = true;
679 }
680 
681 
682 
683 
684 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
685     
686 {
687     
688 
689     function name() public pure returns (string _name) {
690         return TOKEN_NAME;
691     }
692 
693     function symbol() public pure returns (string _symbol) {
694         return TOKEN_SYMBOL;
695     }
696 
697     function decimals() public pure returns (uint8 _decimals) {
698         return TOKEN_DECIMALS_UINT8;
699     }
700 
701     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
702         require(!paused);
703         return super.transferFrom(_from, _to, _value);
704     }
705 
706     function transfer(address _to, uint256 _value) public returns (bool _success) {
707         require(!paused);
708         return super.transfer(_to, _value);
709     }
710 
711     
712 }