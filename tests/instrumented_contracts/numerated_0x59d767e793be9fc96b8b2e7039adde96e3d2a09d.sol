1 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
2 
3 pragma solidity ^0.5.0;
4 
5 /**
6  * @title Elliptic curve signature operations
7  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
8  * TODO Remove this library once solidity supports passing a signature to ecrecover.
9  * See https://github.com/ethereum/solidity/issues/864
10  */
11 
12 library ECDSA {
13     /**
14      * @dev Recover signer address from a message by using their signature
15      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
16      * @param signature bytes signature, the signature is generated using web3.eth.sign()
17      */
18     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
19         bytes32 r;
20         bytes32 s;
21         uint8 v;
22 
23         // Check the signature length
24         if (signature.length != 65) {
25             return (address(0));
26         }
27 
28         // Divide the signature in r, s and v variables
29         // ecrecover takes the signature parameters, and the only way to get them
30         // currently is to use assembly.
31         // solhint-disable-next-line no-inline-assembly
32         assembly {
33             r := mload(add(signature, 0x20))
34             s := mload(add(signature, 0x40))
35             v := byte(0, mload(add(signature, 0x60)))
36         }
37 
38         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
39         if (v < 27) {
40             v += 27;
41         }
42 
43         // If the version is correct return the signer address
44         if (v != 27 && v != 28) {
45             return (address(0));
46         } else {
47             return ecrecover(hash, v, r, s);
48         }
49     }
50 
51     /**
52      * toEthSignedMessageHash
53      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
54      * and hash the result
55      */
56     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
57         // 32 is the length in bytes of hash,
58         // enforced by the type signature above
59         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
60     }
61 }
62 
63 // File: contracts/votingMachines/IntVoteInterface.sol
64 
65 pragma solidity ^0.5.4;
66 
67 interface IntVoteInterface {
68     //When implementing this interface please do not only override function and modifier,
69     //but also to keep the modifiers on the overridden functions.
70     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
71     modifier votable(bytes32 _proposalId) {revert(); _;}
72 
73     event NewProposal(
74         bytes32 indexed _proposalId,
75         address indexed _organization,
76         uint256 _numOfChoices,
77         address _proposer,
78         bytes32 _paramsHash
79     );
80 
81     event ExecuteProposal(bytes32 indexed _proposalId,
82         address indexed _organization,
83         uint256 _decision,
84         uint256 _totalReputation
85     );
86 
87     event VoteProposal(
88         bytes32 indexed _proposalId,
89         address indexed _organization,
90         address indexed _voter,
91         uint256 _vote,
92         uint256 _reputation
93     );
94 
95     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
96     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
97 
98     /**
99      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
100      * generated by calculating keccak256 of a incremented counter.
101      * @param _numOfChoices number of voting choices
102      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
103      * @param _proposer address
104      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
105      * @return proposal's id.
106      */
107     function propose(
108         uint256 _numOfChoices,
109         bytes32 _proposalParameters,
110         address _proposer,
111         address _organization
112         ) external returns(bytes32);
113 
114     function vote(
115         bytes32 _proposalId,
116         uint256 _vote,
117         uint256 _rep,
118         address _voter
119     )
120     external
121     returns(bool);
122 
123     function cancelVote(bytes32 _proposalId) external;
124 
125     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
126 
127     function isVotable(bytes32 _proposalId) external view returns(bool);
128 
129     /**
130      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
131      * @param _proposalId the ID of the proposal
132      * @param _choice the index in the
133      * @return voted reputation for the given choice
134      */
135     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
136 
137     /**
138      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
139      * @return bool true or false
140      */
141     function isAbstainAllow() external pure returns(bool);
142 
143     /**
144      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
145      * @return min - minimum number of choices
146                max - maximum number of choices
147      */
148     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
149 }
150 
151 // File: contracts/libs/RealMath.sol
152 
153 pragma solidity ^0.5.4;
154 
155 /**
156  * RealMath: fixed-point math library, based on fractional and integer parts.
157  * Using uint256 as real216x40, which isn't in Solidity yet.
158  * Internally uses the wider uint256 for some math.
159  *
160  * Note that for addition, subtraction, and mod (%), you should just use the
161  * built-in Solidity operators. Functions for these operations are not provided.
162  *
163  */
164 
165 
166 library RealMath {
167 
168     /**
169      * How many total bits are there?
170      */
171     uint256 constant private REAL_BITS = 256;
172 
173     /**
174      * How many fractional bits are there?
175      */
176     uint256 constant private REAL_FBITS = 40;
177 
178     /**
179      * What's the first non-fractional bit
180      */
181     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
182 
183     /**
184      * Raise a real number to any positive integer power
185      */
186     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
187 
188         uint256 tempRealBase = realBase;
189         uint256 tempExponent = exponent;
190 
191         // Start with the 0th power
192         uint256 realResult = REAL_ONE;
193         while (tempExponent != 0) {
194             // While there are still bits set
195             if ((tempExponent & 0x1) == 0x1) {
196                 // If the low bit is set, multiply in the (many-times-squared) base
197                 realResult = mul(realResult, tempRealBase);
198             }
199                 // Shift off the low bit
200             tempExponent = tempExponent >> 1;
201             if (tempExponent != 0) {
202                 // Do the squaring
203                 tempRealBase = mul(tempRealBase, tempRealBase);
204             }
205         }
206 
207         // Return the final result.
208         return realResult;
209     }
210 
211     /**
212      * Create a real from a rational fraction.
213      */
214     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
215         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
216     }
217 
218     /**
219      * Multiply one real by another. Truncates overflows.
220      */
221     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
222         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
223         // So we just have to clip off the extra REAL_FBITS fractional bits.
224         uint256 res = realA * realB;
225         require(res/realA == realB, "RealMath mul overflow");
226         return (res >> REAL_FBITS);
227     }
228 
229     /**
230      * Divide one real by another real. Truncates overflows.
231      */
232     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
233         // We use the reverse of the multiplication trick: convert numerator from
234         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
235         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
236     }
237 
238 }
239 
240 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
241 
242 pragma solidity ^0.5.0;
243 
244 /**
245  * @title ERC20 interface
246  * @dev see https://github.com/ethereum/EIPs/issues/20
247  */
248 interface IERC20 {
249     function transfer(address to, uint256 value) external returns (bool);
250 
251     function approve(address spender, uint256 value) external returns (bool);
252 
253     function transferFrom(address from, address to, uint256 value) external returns (bool);
254 
255     function totalSupply() external view returns (uint256);
256 
257     function balanceOf(address who) external view returns (uint256);
258 
259     function allowance(address owner, address spender) external view returns (uint256);
260 
261     event Transfer(address indexed from, address indexed to, uint256 value);
262 
263     event Approval(address indexed owner, address indexed spender, uint256 value);
264 }
265 
266 // File: contracts/votingMachines/VotingMachineCallbacksInterface.sol
267 
268 pragma solidity ^0.5.4;
269 
270 
271 interface VotingMachineCallbacksInterface {
272     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
273     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
274 
275     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
276     external
277     returns(bool);
278 
279     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
280     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
281     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
282 }
283 
284 // File: contracts/votingMachines/ProposalExecuteInterface.sol
285 
286 pragma solidity ^0.5.4;
287 
288 interface ProposalExecuteInterface {
289     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
290 }
291 
292 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
293 
294 pragma solidity ^0.5.0;
295 
296 /**
297  * @title SafeMath
298  * @dev Unsigned math operations with safety checks that revert on error
299  */
300 library SafeMath {
301     /**
302     * @dev Multiplies two unsigned integers, reverts on overflow.
303     */
304     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
305         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
306         // benefit is lost if 'b' is also tested.
307         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
308         if (a == 0) {
309             return 0;
310         }
311 
312         uint256 c = a * b;
313         require(c / a == b);
314 
315         return c;
316     }
317 
318     /**
319     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
320     */
321     function div(uint256 a, uint256 b) internal pure returns (uint256) {
322         // Solidity only automatically asserts when dividing by 0
323         require(b > 0);
324         uint256 c = a / b;
325         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
326 
327         return c;
328     }
329 
330     /**
331     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
332     */
333     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
334         require(b <= a);
335         uint256 c = a - b;
336 
337         return c;
338     }
339 
340     /**
341     * @dev Adds two unsigned integers, reverts on overflow.
342     */
343     function add(uint256 a, uint256 b) internal pure returns (uint256) {
344         uint256 c = a + b;
345         require(c >= a);
346 
347         return c;
348     }
349 
350     /**
351     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
352     * reverts when dividing by zero.
353     */
354     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
355         require(b != 0);
356         return a % b;
357     }
358 }
359 
360 // File: openzeppelin-solidity/contracts/math/Math.sol
361 
362 pragma solidity ^0.5.0;
363 
364 /**
365  * @title Math
366  * @dev Assorted math operations
367  */
368 library Math {
369     /**
370     * @dev Returns the largest of two numbers.
371     */
372     function max(uint256 a, uint256 b) internal pure returns (uint256) {
373         return a >= b ? a : b;
374     }
375 
376     /**
377     * @dev Returns the smallest of two numbers.
378     */
379     function min(uint256 a, uint256 b) internal pure returns (uint256) {
380         return a < b ? a : b;
381     }
382 
383     /**
384     * @dev Calculates the average of two numbers. Since these are integers,
385     * averages of an even and odd number cannot be represented, and will be
386     * rounded down.
387     */
388     function average(uint256 a, uint256 b) internal pure returns (uint256) {
389         // (a + b) / 2 can overflow, so we distribute
390         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
391     }
392 }
393 
394 // File: openzeppelin-solidity/contracts/utils/Address.sol
395 
396 pragma solidity ^0.5.0;
397 
398 /**
399  * Utility library of inline functions on addresses
400  */
401 library Address {
402     /**
403      * Returns whether the target address is a contract
404      * @dev This function will return false if invoked during the constructor of a contract,
405      * as the code is not actually created until after the constructor finishes.
406      * @param account address of the account to check
407      * @return whether the target address is a contract
408      */
409     function isContract(address account) internal view returns (bool) {
410         uint256 size;
411         // XXX Currently there is no better way to check if there is a contract in an address
412         // than to check the size of the code at that address.
413         // See https://ethereum.stackexchange.com/a/14016/36603
414         // for more details about how this works.
415         // TODO Check this again before the Serenity release, because all addresses will be
416         // contracts then.
417         // solhint-disable-next-line no-inline-assembly
418         assembly { size := extcodesize(account) }
419         return size > 0;
420     }
421 }
422 
423 // File: contracts/votingMachines/GenesisProtocolLogic.sol
424 
425 pragma solidity ^0.5.4;
426 
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 /**
438  * @title GenesisProtocol implementation -an organization's voting machine scheme.
439  */
440 contract GenesisProtocolLogic is IntVoteInterface {
441     using SafeMath for uint256;
442     using Math for uint256;
443     using RealMath for uint216;
444     using RealMath for uint256;
445     using Address for address;
446 
447     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
448     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
449 
450     //Organization's parameters
451     struct Parameters {
452         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
453         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
454         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
455         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
456                                           //to be in an preparation state (stable) before boosted.
457         uint256 thresholdConst; //constant  for threshold calculation .
458                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
459         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
460                                    //in the threshold calculation to prevent overflow
461         uint256 quietEndingPeriod; //quite ending period
462         uint256 proposingRepReward;//proposer reputation reward.
463         uint256 votersReputationLossRatio;//Unsuccessful pre booster
464                                           //voters lose votersReputationLossRatio% of their reputation.
465         uint256 minimumDaoBounty;
466         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
467                                //(daoBountyConst * averageBoostDownstakes)/100 .
468         uint256 activationTime;//the point in time after which proposals can be created.
469         //if this address is set so only this address is allowed to vote of behalf of someone else.
470         address voteOnBehalf;
471     }
472 
473     struct Voter {
474         uint256 vote; // YES(1) ,NO(2)
475         uint256 reputation; // amount of voter's reputation
476         bool preBoosted;
477     }
478 
479     struct Staker {
480         uint256 vote; // YES(1) ,NO(2)
481         uint256 amount; // amount of staker's stake
482         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
483     }
484 
485     struct Proposal {
486         bytes32 organizationId; // the organization unique identifier the proposal is target to.
487         address callbacks;    // should fulfill voting callbacks interface.
488         ProposalState state;
489         uint256 winningVote; //the winning vote.
490         address proposer;
491         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
492         uint256 currentBoostedVotePeriodLimit;
493         bytes32 paramsHash;
494         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
495         uint256 daoBounty;
496         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
497         uint256 confidenceThreshold;
498         //The percentage from upper stakes which the caller for the expiration was given.
499         uint256 expirationCallBountyPercentage;
500         uint[3] times; //times[0] - submittedTime
501                        //times[1] - boostedPhaseTime
502                        //times[2] -preBoostedPhaseTime;
503         bool daoRedeemItsWinnings;
504         //      vote      reputation
505         mapping(uint256   =>  uint256    ) votes;
506         //      vote      reputation
507         mapping(uint256   =>  uint256    ) preBoostedVotes;
508         //      address     voter
509         mapping(address =>  Voter    ) voters;
510         //      vote        stakes
511         mapping(uint256   =>  uint256    ) stakes;
512         //      address  staker
513         mapping(address  => Staker   ) stakers;
514     }
515 
516     event Stake(bytes32 indexed _proposalId,
517         address indexed _organization,
518         address indexed _staker,
519         uint256 _vote,
520         uint256 _amount
521     );
522 
523     event Redeem(bytes32 indexed _proposalId,
524         address indexed _organization,
525         address indexed _beneficiary,
526         uint256 _amount
527     );
528 
529     event RedeemDaoBounty(bytes32 indexed _proposalId,
530         address indexed _organization,
531         address indexed _beneficiary,
532         uint256 _amount
533     );
534 
535     event RedeemReputation(bytes32 indexed _proposalId,
536         address indexed _organization,
537         address indexed _beneficiary,
538         uint256 _amount
539     );
540 
541     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
542     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
543     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
544     event ConfidenceLevelChange(bytes32 indexed _proposalId, uint256 _confidenceThreshold);
545 
546     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
547     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
548     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
549            //organizationId => organization
550     mapping(bytes32        => address     ) public organizations;
551           //organizationId => averageBoostDownstakes
552     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
553     uint256 constant public NUM_OF_CHOICES = 2;
554     uint256 constant public NO = 2;
555     uint256 constant public YES = 1;
556     uint256 public proposalsCnt; // Total number of proposals
557     IERC20 public stakingToken;
558     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
559     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
560 
561     /**
562      * @dev Constructor
563      */
564     constructor(IERC20 _stakingToken) public {
565       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
566       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
567       //If such contract address does not exist in the network (e.g ganache)
568       //the contract will use the _stakingToken param as the
569       //staking token address.
570         if (address(GEN_TOKEN_ADDRESS).isContract()) {
571             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
572         } else {
573             stakingToken = _stakingToken;
574         }
575     }
576 
577   /**
578    * @dev Check that the proposal is votable
579    * a proposal is votable if it is in one of the following states:
580    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
581    */
582     modifier votable(bytes32 _proposalId) {
583         require(_isVotable(_proposalId));
584         _;
585     }
586 
587     /**
588      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
589      * generated by calculating keccak256 of a incremented counter.
590      * @param _paramsHash parameters hash
591      * @param _proposer address
592      * @param _organization address
593      */
594     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
595         external
596         returns(bytes32)
597     {
598       // solhint-disable-next-line not-rely-on-time
599         require(now > parameters[_paramsHash].activationTime, "not active yet");
600         //Check parameters existence.
601         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
602         // Generate a unique ID:
603         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
604         proposalsCnt = proposalsCnt.add(1);
605          // Open proposal:
606         Proposal memory proposal;
607         proposal.callbacks = msg.sender;
608         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
609 
610         proposal.state = ProposalState.Queued;
611         // solhint-disable-next-line not-rely-on-time
612         proposal.times[0] = now;//submitted time
613         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
614         proposal.proposer = _proposer;
615         proposal.winningVote = NO;
616         proposal.paramsHash = _paramsHash;
617         if (organizations[proposal.organizationId] == address(0)) {
618             if (_organization == address(0)) {
619                 organizations[proposal.organizationId] = msg.sender;
620             } else {
621                 organizations[proposal.organizationId] = _organization;
622             }
623         }
624         //calc dao bounty
625         uint256 daoBounty =
626         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
627         if (daoBounty < parameters[_paramsHash].minimumDaoBounty) {
628             proposal.daoBountyRemain = parameters[_paramsHash].minimumDaoBounty;
629         } else {
630             proposal.daoBountyRemain = daoBounty;
631         }
632         proposal.totalStakes = proposal.daoBountyRemain;
633         proposals[proposalId] = proposal;
634         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
635 
636         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
637         return proposalId;
638     }
639 
640     /**
641       * @dev executeBoosted try to execute a boosted or QuietEndingPeriod proposal if it is expired
642       * @param _proposalId the id of the proposal
643       * @return uint256 expirationCallBounty the bounty amount for the expiration call
644      */
645     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
646         Proposal storage proposal = proposals[_proposalId];
647         require(proposal.state == ProposalState.Boosted || proposal.state == ProposalState.QuietEndingPeriod,
648         "proposal state in not Boosted nor QuietEndingPeriod");
649         require(_execute(_proposalId), "proposal need to expire");
650         uint256 expirationCallBountyPercentage =
651         // solhint-disable-next-line not-rely-on-time
652         (uint(1).add(now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1])).div(15)));
653         if (expirationCallBountyPercentage > 100) {
654             expirationCallBountyPercentage = 100;
655         }
656         proposal.expirationCallBountyPercentage = expirationCallBountyPercentage;
657         expirationCallBounty = expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100);
658         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
659         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
660     }
661 
662     /**
663      * @dev hash the parameters, save them if necessary, and return the hash value
664      * @param _params a parameters array
665      *    _params[0] - _queuedVoteRequiredPercentage,
666      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
667      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
668      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
669      *                  state (stable) before boosted.
670      *    _params[4] -_thresholdConst
671      *    _params[5] -_quietEndingPeriod
672      *    _params[6] -_proposingRepReward
673      *    _params[7] -_votersReputationLossRatio
674      *    _params[8] -_minimumDaoBounty
675      *    _params[9] -_daoBountyConst
676      *    _params[10] -_activationTime
677      * @param _voteOnBehalf - authorized to vote on behalf of others.
678     */
679     function setParameters(
680         uint[11] calldata _params, //use array here due to stack too deep issue.
681         address _voteOnBehalf
682     )
683     external
684     returns(bytes32)
685     {
686         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
687         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
688         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
689         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
690         require(_params[8] > 0, "minimumDaoBounty should be > 0");
691         require(_params[9] > 0, "daoBountyConst should be > 0");
692 
693         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
694         //set a limit for power for a given alpha to prevent overflow
695         uint256 limitExponent = 172;//for alpha less or equal 2
696         uint256 j = 2;
697         for (uint256 i = 2000; i < 16000; i = i*2) {
698             if ((_params[4] > i) && (_params[4] <= i*2)) {
699                 limitExponent = limitExponent/j;
700                 break;
701             }
702             j++;
703         }
704 
705         parameters[paramsHash] = Parameters({
706             queuedVoteRequiredPercentage: _params[0],
707             queuedVotePeriodLimit: _params[1],
708             boostedVotePeriodLimit: _params[2],
709             preBoostedVotePeriodLimit: _params[3],
710             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
711             limitExponentValue:limitExponent,
712             quietEndingPeriod: _params[5],
713             proposingRepReward: _params[6],
714             votersReputationLossRatio:_params[7],
715             minimumDaoBounty:_params[8],
716             daoBountyConst:_params[9],
717             activationTime:_params[10],
718             voteOnBehalf:_voteOnBehalf
719         });
720         return paramsHash;
721     }
722 
723     /**
724      * @dev redeem a reward for a successful stake, vote or proposing.
725      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
726      * users to redeem on behalf of someone else.
727      * @param _proposalId the ID of the proposal
728      * @param _beneficiary - the beneficiary address
729      * @return rewards -
730      *           [0] stakerTokenReward
731      *           [1] voterReputationReward
732      *           [2] proposerReputationReward
733      */
734      // solhint-disable-next-line function-max-lines,code-complexity
735     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
736         Proposal storage proposal = proposals[_proposalId];
737         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
738         "Proposal should be Executed or ExpiredInQueue");
739         Parameters memory params = parameters[proposal.paramsHash];
740         uint256 lostReputation;
741         if (proposal.winningVote == YES) {
742             lostReputation = proposal.preBoostedVotes[NO];
743         } else {
744             lostReputation = proposal.preBoostedVotes[YES];
745         }
746         lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
747         //as staker
748         Staker storage staker = proposal.stakers[_beneficiary];
749         uint256 totalStakes = proposal.stakes[NO].add(proposal.stakes[YES]);
750         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
751 
752         if (staker.amount > 0) {
753             uint256 totalStakesLeftAfterCallBounty =
754             totalStakes.sub(proposal.expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100));
755             if (proposal.state == ProposalState.ExpiredInQueue) {
756                 //Stakes of a proposal that expires in Queue are sent back to stakers
757                 rewards[0] = staker.amount;
758             } else if (staker.vote == proposal.winningVote) {
759                 if (staker.vote == YES) {
760                     if (proposal.daoBounty < totalStakesLeftAfterCallBounty) {
761                         uint256 _totalStakes = totalStakesLeftAfterCallBounty.sub(proposal.daoBounty);
762                         rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
763                     }
764                 } else {
765                     rewards[0] = (staker.amount.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes;
766                 }
767             }
768             staker.amount = 0;
769         }
770             //dao redeem its winnings
771         if (proposal.daoRedeemItsWinnings == false &&
772             _beneficiary == organizations[proposal.organizationId] &&
773             proposal.state != ProposalState.ExpiredInQueue &&
774             proposal.winningVote == NO) {
775             rewards[0] =
776             rewards[0].add((proposal.daoBounty.mul(totalStakes))/totalWinningStakes).sub(proposal.daoBounty);
777             proposal.daoRedeemItsWinnings = true;
778         }
779 
780         //as voter
781         Voter storage voter = proposal.voters[_beneficiary];
782         if ((voter.reputation != 0) && (voter.preBoosted)) {
783             if (proposal.state == ProposalState.ExpiredInQueue) {
784               //give back reputation for the voter
785                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
786             } else if (proposal.winningVote == voter.vote) {
787                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
788                 .add((voter.reputation.mul(lostReputation))/proposal.preBoostedVotes[proposal.winningVote]);
789             }
790             voter.reputation = 0;
791         }
792         //as proposer
793         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
794             rewards[2] = params.proposingRepReward;
795             proposal.proposer = address(0);
796         }
797         if (rewards[0] != 0) {
798             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
799             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
800             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
801         }
802         if (rewards[1].add(rewards[2]) != 0) {
803             VotingMachineCallbacksInterface(proposal.callbacks)
804             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
805             emit RedeemReputation(
806             _proposalId,
807             organizations[proposal.organizationId],
808             _beneficiary,
809             rewards[1].add(rewards[2])
810             );
811         }
812     }
813 
814     /**
815      * @dev redeemDaoBounty a reward for a successful stake.
816      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
817      * users to redeem on behalf of someone else.
818      * @param _proposalId the ID of the proposal
819      * @param _beneficiary - the beneficiary address
820      * @return redeemedAmount - redeem token amount
821      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
822      */
823     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
824     public
825     returns(uint256 redeemedAmount, uint256 potentialAmount) {
826         Proposal storage proposal = proposals[_proposalId];
827         require(proposal.state == ProposalState.Executed);
828         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
829         Staker storage staker = proposal.stakers[_beneficiary];
830         if (
831             (staker.amount4Bounty > 0)&&
832             (staker.vote == proposal.winningVote)&&
833             (proposal.winningVote == YES)&&
834             (totalWinningStakes != 0)) {
835             //as staker
836                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
837             }
838         if ((potentialAmount != 0)&&
839             (VotingMachineCallbacksInterface(proposal.callbacks)
840             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
841             staker.amount4Bounty = 0;
842             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
843             require(
844             VotingMachineCallbacksInterface(proposal.callbacks)
845             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
846             redeemedAmount = potentialAmount;
847             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
848         }
849     }
850 
851     /**
852      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
853      * @param _proposalId the ID of the proposal
854      * @return bool true or false.
855      */
856     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
857         Proposal memory proposal = proposals[_proposalId];
858         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
859     }
860 
861     /**
862      * @dev threshold return the organization's score threshold which required by
863      * a proposal to shift to boosted state.
864      * This threshold is dynamically set and it depend on the number of boosted proposal.
865      * @param _organizationId the organization identifier
866      * @param _paramsHash the organization parameters hash
867      * @return uint256 organization's score threshold as real number.
868      */
869     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
870         uint256 power = orgBoostedProposalsCnt[_organizationId];
871         Parameters storage params = parameters[_paramsHash];
872 
873         if (power > params.limitExponentValue) {
874             power = params.limitExponentValue;
875         }
876 
877         return params.thresholdConst.pow(power);
878     }
879 
880   /**
881    * @dev hashParameters returns a hash of the given parameters
882    */
883     function getParametersHash(
884         uint[11] memory _params,//use array here due to stack too deep issue.
885         address _voteOnBehalf
886     )
887         public
888         pure
889         returns(bytes32)
890         {
891         //double call to keccak256 to avoid deep stack issue when call with too many params.
892         return keccak256(
893             abi.encodePacked(
894             keccak256(
895             abi.encodePacked(
896                 _params[0],
897                 _params[1],
898                 _params[2],
899                 _params[3],
900                 _params[4],
901                 _params[5],
902                 _params[6],
903                 _params[7],
904                 _params[8],
905                 _params[9],
906                 _params[10])
907             ),
908             _voteOnBehalf
909         ));
910     }
911 
912     /**
913       * @dev execute check if the proposal has been decided, and if so, execute the proposal
914       * @param _proposalId the id of the proposal
915       * @return bool true - the proposal has been executed
916       *              false - otherwise.
917      */
918      // solhint-disable-next-line function-max-lines,code-complexity
919     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
920         Proposal storage proposal = proposals[_proposalId];
921         Parameters memory params = parameters[proposal.paramsHash];
922         Proposal memory tmpProposal = proposal;
923         uint256 totalReputation =
924         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
925         //first divide by 100 to prevent overflow
926         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
927         ExecutionState executionState = ExecutionState.None;
928         uint256 averageDownstakesOfBoosted;
929         uint256 confidenceThreshold;
930 
931         if (proposal.votes[proposal.winningVote] > executionBar) {
932          // someone crossed the absolute vote execution bar.
933             if (proposal.state == ProposalState.Queued) {
934                 executionState = ExecutionState.QueueBarCrossed;
935             } else if (proposal.state == ProposalState.PreBoosted) {
936                 executionState = ExecutionState.PreBoostedBarCrossed;
937             } else {
938                 executionState = ExecutionState.BoostedBarCrossed;
939             }
940             proposal.state = ProposalState.Executed;
941         } else {
942             if (proposal.state == ProposalState.Queued) {
943                 // solhint-disable-next-line not-rely-on-time
944                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
945                     proposal.state = ProposalState.ExpiredInQueue;
946                     proposal.winningVote = NO;
947                     executionState = ExecutionState.QueueTimeOut;
948                 } else {
949                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
950                     if (_score(_proposalId) > confidenceThreshold) {
951                         //change proposal mode to PreBoosted mode.
952                         proposal.state = ProposalState.PreBoosted;
953                         // solhint-disable-next-line not-rely-on-time
954                         proposal.times[2] = now;
955                         proposal.confidenceThreshold = confidenceThreshold;
956                     }
957                 }
958             }
959 
960             if (proposal.state == ProposalState.PreBoosted) {
961                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
962               // solhint-disable-next-line not-rely-on-time
963                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
964                     if ((_score(_proposalId) > confidenceThreshold) &&
965                         (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)) {
966                        //change proposal mode to Boosted mode.
967                         proposal.state = ProposalState.Boosted;
968                        // solhint-disable-next-line not-rely-on-time
969                         proposal.times[1] = now;
970                         orgBoostedProposalsCnt[proposal.organizationId]++;
971                        //add a value to average -> average = average + ((value - average) / nbValues)
972                         averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
973                         // solium-disable-next-line indentation
974                         averagesDownstakesOfBoosted[proposal.organizationId] =
975                             uint256(int256(averageDownstakesOfBoosted) +
976                             ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
977                             int256(orgBoostedProposalsCnt[proposal.organizationId])));
978                     }
979                 } else { //check the Confidence level is stable
980                     uint256 proposalScore = _score(_proposalId);
981                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
982                         proposal.state = ProposalState.Queued;
983                     } else if (proposal.confidenceThreshold > proposalScore) {
984                         proposal.confidenceThreshold = confidenceThreshold;
985                         emit ConfidenceLevelChange(_proposalId, confidenceThreshold);
986                     }
987                 }
988             }
989         }
990 
991         if ((proposal.state == ProposalState.Boosted) ||
992             (proposal.state == ProposalState.QuietEndingPeriod)) {
993             // solhint-disable-next-line not-rely-on-time
994             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
995                 proposal.state = ProposalState.Executed;
996                 executionState = ExecutionState.BoostedTimeOut;
997             }
998         }
999 
1000         if (executionState != ExecutionState.None) {
1001             if ((executionState == ExecutionState.BoostedTimeOut) ||
1002                 (executionState == ExecutionState.BoostedBarCrossed)) {
1003                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
1004                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1005                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
1006                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1007                 if (boostedProposals == 0) {
1008                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1009                 } else {
1010                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1011                     averagesDownstakesOfBoosted[proposal.organizationId] =
1012                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1013                 }
1014             }
1015             emit ExecuteProposal(
1016             _proposalId,
1017             organizations[proposal.organizationId],
1018             proposal.winningVote,
1019             totalReputation
1020             );
1021             emit GPExecuteProposal(_proposalId, executionState);
1022             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1023             proposal.daoBounty = proposal.daoBountyRemain;
1024         }
1025         if (tmpProposal.state != proposal.state) {
1026             emit StateChange(_proposalId, proposal.state);
1027         }
1028         return (executionState != ExecutionState.None);
1029     }
1030 
1031     /**
1032      * @dev staking function
1033      * @param _proposalId id of the proposal
1034      * @param _vote  NO(2) or YES(1).
1035      * @param _amount the betting amount
1036      * @return bool true - the proposal has been executed
1037      *              false - otherwise.
1038      */
1039     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1040         // 0 is not a valid vote.
1041         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1042         require(_amount > 0, "staking amount should be >0");
1043 
1044         if (_execute(_proposalId)) {
1045             return true;
1046         }
1047         Proposal storage proposal = proposals[_proposalId];
1048 
1049         if ((proposal.state != ProposalState.PreBoosted) &&
1050             (proposal.state != ProposalState.Queued)) {
1051             return false;
1052         }
1053 
1054         // enable to increase stake only on the previous stake vote
1055         Staker storage staker = proposal.stakers[_staker];
1056         if ((staker.amount > 0) && (staker.vote != _vote)) {
1057             return false;
1058         }
1059 
1060         uint256 amount = _amount;
1061         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1062         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1063         staker.amount = staker.amount.add(amount);
1064         //This is to prevent average downstakes calculation overflow
1065         //Note that any how GEN cap is 100000000 ether.
1066         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1067         require(proposal.totalStakes <= 0x100000000000000000000000000000000, "total stakes is too high");
1068 
1069         if (_vote == YES) {
1070             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1071         }
1072         staker.vote = _vote;
1073 
1074         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1075         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1076         return _execute(_proposalId);
1077     }
1078 
1079     /**
1080      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1081      * @param _proposalId id of the proposal
1082      * @param _voter used in case the vote is cast for someone else
1083      * @param _vote a value between 0 to and the proposal's number of choices.
1084      * @param _rep how many reputation the voter would like to stake for this vote.
1085      *         if  _rep==0 so the voter full reputation will be use.
1086      * @return true in case of proposal execution otherwise false
1087      * throws if proposal is not open or if it has been executed
1088      * NB: executes the proposal if a decision has been reached
1089      */
1090      // solhint-disable-next-line function-max-lines,code-complexity
1091     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1092         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1093         if (_execute(_proposalId)) {
1094             return true;
1095         }
1096 
1097         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1098         Proposal storage proposal = proposals[_proposalId];
1099 
1100         // Check voter has enough reputation:
1101         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
1102         require(reputation > 0, "_voter must have reputation");
1103         require(reputation >= _rep, "reputation >= _rep");
1104         uint256 rep = _rep;
1105         if (rep == 0) {
1106             rep = reputation;
1107         }
1108         // If this voter has already voted, return false.
1109         if (proposal.voters[_voter].reputation != 0) {
1110             return false;
1111         }
1112         // The voting itself:
1113         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
1114         //check if the current winningVote changed or there is a tie.
1115         //for the case there is a tie the current winningVote set to NO.
1116         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
1117             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
1118             proposal.winningVote == YES)) {
1119             if (proposal.state == ProposalState.Boosted &&
1120             // solhint-disable-next-line not-rely-on-time
1121                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
1122                 proposal.state == ProposalState.QuietEndingPeriod) {
1123                 //quietEndingPeriod
1124                 if (proposal.state != ProposalState.QuietEndingPeriod) {
1125                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
1126                     proposal.state = ProposalState.QuietEndingPeriod;
1127                 }
1128                 // solhint-disable-next-line not-rely-on-time
1129                 proposal.times[1] = now;
1130             }
1131             proposal.winningVote = _vote;
1132         }
1133         proposal.voters[_voter] = Voter({
1134             reputation: rep,
1135             vote: _vote,
1136             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
1137         });
1138         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
1139             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
1140             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
1141             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
1142         }
1143         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
1144         return _execute(_proposalId);
1145     }
1146 
1147     /**
1148      * @dev _score return the proposal score (Confidence level)
1149      * For dual choice proposal S = (S+)/(S-)
1150      * @param _proposalId the ID of the proposal
1151      * @return uint256 proposal score as real number.
1152      */
1153     function _score(bytes32 _proposalId) internal view returns(uint256) {
1154         Proposal storage proposal = proposals[_proposalId];
1155         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
1156         return uint216(proposal.stakes[YES]).fraction(uint216(proposal.stakes[NO]));
1157     }
1158 
1159     /**
1160       * @dev _isVotable check if the proposal is votable
1161       * @param _proposalId the ID of the proposal
1162       * @return bool true or false
1163     */
1164     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
1165         ProposalState pState = proposals[_proposalId].state;
1166         return ((pState == ProposalState.PreBoosted)||
1167                 (pState == ProposalState.Boosted)||
1168                 (pState == ProposalState.QuietEndingPeriod)||
1169                 (pState == ProposalState.Queued)
1170         );
1171     }
1172 }
1173 
1174 // File: votingMachines/GenesisProtocol.sol
1175 
1176 pragma solidity ^0.5.4;
1177 
1178 
1179 
1180 
1181 /**
1182  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1183  */
1184 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
1185     using ECDSA for bytes32;
1186 
1187     // Digest describing the data the user signs according EIP 712.
1188     // Needs to match what is passed to Metamask.
1189     bytes32 public constant DELEGATION_HASH_EIP712 =
1190     keccak256(abi.encodePacked(
1191     "address GenesisProtocolAddress",
1192     "bytes32 ProposalId",
1193     "uint256 Vote",
1194     "uint256 AmountToStake",
1195     "uint256 Nonce"
1196     ));
1197 
1198     mapping(address=>uint256) public stakesNonce; //stakes Nonce
1199 
1200     /**
1201      * @dev Constructor
1202      */
1203     constructor(IERC20 _stakingToken)
1204     public
1205     // solhint-disable-next-line no-empty-blocks
1206     GenesisProtocolLogic(_stakingToken) {
1207     }
1208 
1209     /**
1210      * @dev staking function
1211      * @param _proposalId id of the proposal
1212      * @param _vote  NO(2) or YES(1).
1213      * @param _amount the betting amount
1214      * @return bool true - the proposal has been executed
1215      *              false - otherwise.
1216      */
1217     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
1218         return _stake(_proposalId, _vote, _amount, msg.sender);
1219     }
1220 
1221     /**
1222      * @dev stakeWithSignature function
1223      * @param _proposalId id of the proposal
1224      * @param _vote  NO(2) or YES(1).
1225      * @param _amount the betting amount
1226      * @param _nonce nonce value ,it is part of the signature to ensure that
1227               a signature can be received only once.
1228      * @param _signatureType signature type
1229               1 - for web3.eth.sign
1230               2 - for eth_signTypedData according to EIP #712.
1231      * @param _signature  - signed data by the staker
1232      * @return bool true - the proposal has been executed
1233      *              false - otherwise.
1234      */
1235     function stakeWithSignature(
1236         bytes32 _proposalId,
1237         uint256 _vote,
1238         uint256 _amount,
1239         uint256 _nonce,
1240         uint256 _signatureType,
1241         bytes calldata _signature
1242         )
1243         external
1244         returns(bool)
1245         {
1246         // Recreate the digest the user signed
1247         bytes32 delegationDigest;
1248         if (_signatureType == 2) {
1249             delegationDigest = keccak256(
1250                 abi.encodePacked(
1251                     DELEGATION_HASH_EIP712, keccak256(
1252                         abi.encodePacked(
1253                         address(this),
1254                         _proposalId,
1255                         _vote,
1256                         _amount,
1257                         _nonce)
1258                     )
1259                 )
1260             );
1261         } else {
1262             delegationDigest = keccak256(
1263                         abi.encodePacked(
1264                         address(this),
1265                         _proposalId,
1266                         _vote,
1267                         _amount,
1268                         _nonce)
1269                     ).toEthSignedMessageHash();
1270         }
1271         address staker = delegationDigest.recover(_signature);
1272         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
1273         require(staker != address(0), "staker address cannot be 0");
1274         require(stakesNonce[staker] == _nonce);
1275         stakesNonce[staker] = stakesNonce[staker].add(1);
1276         return _stake(_proposalId, _vote, _amount, staker);
1277     }
1278 
1279     /**
1280      * @dev voting function
1281      * @param _proposalId id of the proposal
1282      * @param _vote NO(2) or YES(1).
1283      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
1284      * @param _voter voter address
1285      * @return bool true - the proposal has been executed
1286      *              false - otherwise.
1287      */
1288     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
1289     external
1290     votable(_proposalId)
1291     returns(bool) {
1292         Proposal storage proposal = proposals[_proposalId];
1293         Parameters memory params = parameters[proposal.paramsHash];
1294         address voter;
1295         if (params.voteOnBehalf != address(0)) {
1296             require(msg.sender == params.voteOnBehalf);
1297             voter = _voter;
1298         } else {
1299             voter = msg.sender;
1300         }
1301         return internalVote(_proposalId, voter, _vote, _amount);
1302     }
1303 
1304   /**
1305    * @dev Cancel the vote of the msg.sender.
1306    * cancel vote is not allow in genesisProtocol so this function doing nothing.
1307    * This function is here in order to comply to the IntVoteInterface .
1308    */
1309     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
1310        //this is not allowed
1311         return;
1312     }
1313 
1314     /**
1315       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1316       * @param _proposalId the id of the proposal
1317       * @return bool true - the proposal has been executed
1318       *              false - otherwise.
1319      */
1320     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
1321         return _execute(_proposalId);
1322     }
1323 
1324   /**
1325     * @dev getNumberOfChoices returns the number of choices possible in this proposal
1326     * @return uint256 that contains number of choices
1327     */
1328     function getNumberOfChoices(bytes32) external view returns(uint256) {
1329         return NUM_OF_CHOICES;
1330     }
1331 
1332     /**
1333       * @dev getProposalTimes returns proposals times variables.
1334       * @param _proposalId id of the proposal
1335       * @return proposals times array
1336       */
1337     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
1338         return proposals[_proposalId].times;
1339     }
1340 
1341     /**
1342      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
1343      * @param _proposalId the ID of the proposal
1344      * @param _voter the address of the voter
1345      * @return uint256 vote - the voters vote
1346      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
1347      */
1348     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
1349         Voter memory voter = proposals[_proposalId].voters[_voter];
1350         return (voter.vote, voter.reputation);
1351     }
1352 
1353     /**
1354     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
1355     * @param _proposalId the ID of the proposal
1356     * @param _choice the index in the
1357     * @return voted reputation for the given choice
1358     */
1359     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
1360         return proposals[_proposalId].votes[_choice];
1361     }
1362 
1363     /**
1364     * @dev isVotable check if the proposal is votable
1365     * @param _proposalId the ID of the proposal
1366     * @return bool true or false
1367     */
1368     function isVotable(bytes32 _proposalId) external view returns(bool) {
1369         return _isVotable(_proposalId);
1370     }
1371 
1372     /**
1373     * @dev proposalStatus return the total votes and stakes for a given proposal
1374     * @param _proposalId the ID of the proposal
1375     * @return uint256 preBoostedVotes YES
1376     * @return uint256 preBoostedVotes NO
1377     * @return uint256 total stakes YES
1378     * @return uint256 total stakes NO
1379     */
1380     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
1381         return (
1382                 proposals[_proposalId].preBoostedVotes[YES],
1383                 proposals[_proposalId].preBoostedVotes[NO],
1384                 proposals[_proposalId].stakes[YES],
1385                 proposals[_proposalId].stakes[NO]
1386         );
1387     }
1388 
1389   /**
1390     * @dev getProposalOrganization return the organizationId for a given proposal
1391     * @param _proposalId the ID of the proposal
1392     * @return bytes32 organization identifier
1393     */
1394     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
1395         return (proposals[_proposalId].organizationId);
1396     }
1397 
1398     /**
1399       * @dev getStaker return the vote and stake amount for a given proposal and staker
1400       * @param _proposalId the ID of the proposal
1401       * @param _staker staker address
1402       * @return uint256 vote
1403       * @return uint256 amount
1404     */
1405     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
1406         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
1407     }
1408 
1409     /**
1410       * @dev voteStake return the amount stakes for a given proposal and vote
1411       * @param _proposalId the ID of the proposal
1412       * @param _vote vote number
1413       * @return uint256 stake amount
1414     */
1415     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
1416         return proposals[_proposalId].stakes[_vote];
1417     }
1418 
1419   /**
1420     * @dev voteStake return the winningVote for a given proposal
1421     * @param _proposalId the ID of the proposal
1422     * @return uint256 winningVote
1423     */
1424     function winningVote(bytes32 _proposalId) external view returns(uint256) {
1425         return proposals[_proposalId].winningVote;
1426     }
1427 
1428     /**
1429       * @dev voteStake return the state for a given proposal
1430       * @param _proposalId the ID of the proposal
1431       * @return ProposalState proposal state
1432     */
1433     function state(bytes32 _proposalId) external view returns(ProposalState) {
1434         return proposals[_proposalId].state;
1435     }
1436 
1437    /**
1438     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
1439     * @return bool true or false
1440     */
1441     function isAbstainAllow() external pure returns(bool) {
1442         return false;
1443     }
1444 
1445     /**
1446      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
1447      * @return min - minimum number of choices
1448                max - maximum number of choices
1449      */
1450     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
1451         return (YES, NO);
1452     }
1453 
1454     /**
1455      * @dev score return the proposal score
1456      * @param _proposalId the ID of the proposal
1457      * @return uint256 proposal score.
1458      */
1459     function score(bytes32 _proposalId) public view returns(uint256) {
1460         return  _score(_proposalId);
1461     }
1462 }