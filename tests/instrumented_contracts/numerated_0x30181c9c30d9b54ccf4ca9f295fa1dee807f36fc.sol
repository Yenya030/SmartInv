1 /*
2 
3     ,----..      
4    /   /   \            *********************************
5   /   .     :           *Qwoyn Digital Investments, LLC *
6  .   /   ;.  \          *Cornerstone version 0.1        *
7 .   ;   /  ` ;          *Daniel Pittman, CEO            *
8 ;   |  ; \ ; |          *December 2017                  *
9 |   :  | ; | '          *********************************
10 .   |  ' ' ' :   
11 '   ;  \; /  |   
12  \   \  ',  . \  
13   ;   :      ; | 
14    \   \ .'`--" 
15 
16 
17 Tokenized Company Equity Right Transfer Agreement
18 
19 
20 
21 Subject to an existing Right of Ownership Token Transfer Agreement or otherwise proclaimed possession of ownership of the underlying 
22 
23 asset ("the Company Equity"), referenced hereafter as "P003_25793", Qwoyn Digital Investments, LLC, (hereafter the “Token Issuer”) 
24 
25 (the “Purchaser” or the “lien holder”) hereby agrees to tokenize his ownership of  the Company Equity Right granted under the 
26 
27 Agreement P003_25793, (the “Tokenized Right to Company Equity Revenue”). 
28 
29 Uploading this Agreement on the blockchain will be hashed and referred in code of a Smart Contract generated by the Token Issuer. 
30 
31 1. SALE OF THE TOKENIZED RIGHT. 
32 
33 1.1. The Token Issuer hereby agrees to issue 1000000 Token(s) at the price of as .1 ether 2017-12-06 on the blockchain of the Token 
34 
35 Issuer’s choice (Ethereum). 
36 
37 1.2  The Token Issuer hereby reserves the right to issue more tokens dependent on market demand.
38 
39 2. TOKEN BUYER’S PAYMENT AS CONDITION PRECEDENT. 
40 
41 2.1. Token Buyer’s (defined in Section 14) payment for the Token(s) issued by Token Issuer under Section 1 is a condition precedent to 
42 
43 the formation of this Agreement. There will no binding Agreement until the payment from the Token Buyer is appeared in the Token 
44 
45 Issuer’s ethereum-wallet account. 
46 
47 2.2. Likewise, there will be no binding agreement with any subsequent token buyer unless the payment for the Token created hereunder 
48 
49 made to the Token Holder at the moment of selling the Token. 
50 
51 3. SMART CONTRACT. For the purpose of recording the ownership of the Company Equity Right created under the Agreement P003_25793, 
52 
53 Token Issuer generates a Smart Contract. This Smart Contract facilitates the direct transfer of the Company Equity Right created to an 
54 
55 individual or an entity that makes the payment for the Token representing the ownership of the Company Equity Right created under the 
56 
57 Agreement K003-2017 (the “Token Holder”). 
58 
59 4. TOKEN HOLDER’S RIGHT. 
60 
61 4.1. Subject to the Agreement P003_25793, all Token Holder(s) will be granted the right to set a new price for the purchased token 
62 
63 hereunder, provided that he/she cannot interfere or enforce in the Company Equity Owner’s decision regarding the Company Equity 
64 
65 subject to the Agreement P003_25793. 
66 
67 4.2. Subject to the Agreement P003_25793, Token Holder(s)’s Company Equity Right does not create any type of a lien on the Company 
68 
69 Equity subject to the Agreement P003_25793. Token Holder’s Company Equity Right will be limited to the Right to claim the amount of 
70 
71 the Company Equity Income promised by the Company Equity Owner to Token Issuer under the Agreement P003_25793. 
72 
73 5. RIGHT OWNER’S WARRANTIES AND DUTIES. Token Issuer and subsequent Token Holder hereby represent and warrant that, to the best of 
74 
75 his/her knowledge, he/she is the sole lawful owner of the tokenized Company Equity Right created under the Agreement P003_25793 and 
76 
77 free and clear of any liens and encumbrances except the ones disclosed to Token Issuer from the Company Equity Owner under the 
78 
79 Agreement P003_25793. Token Issuer and each subsequent Token Holder(s) have full right, power and authority to sell and transfer 
80 
81 his/her Right created under the Agreement P003_25793. Token Issuer and each subsequent Token Holder also warrant that he/she does not 
82 
83 currently know of and has no reason to know of any third party claim to any right, title, or use of the Right created under the 
84 
85 Agreement P003_25793 except the ones disclosed to Token Issuer from the Company Equity Owner under the Agreement P003_25793. Token 
86 
87 Issuer and each subsequent Token Holder did not and will not execute any agreement in conflict with this Agreement. Once a token 
88 
89 purchaser makes the full payment pursuant to Section 1, Token Issuer will take any actions that may be necessary or desirable to 
90 
91 protect and perfect the Purchaser’s Company Equity Right created under the Agreement P003_25793. 
92 
93 6. ASSUMPTION OF RISK. 
94 
95 Each Token Holder bears the risk of loss when purchasing a Token representing the ownership of the Company Equity Right created under 
96 
97 the Agreement P003_25793. Token Issuer will not be responsible for and will not be liable for any loss arising from: (a) failure or 
98 
99 malfunction of hardware, software, server, and internet connections; (b) malicious software introduction; (c) the third party may 
100 
101 obtain unauthorized access to information stored within buyer’s account, including, but not limited to Buyer’s storage address and 
102 
103 private key; (d) forgotten passwords; and (e) incorrectly constructed transactions or mistyped account address. 
104 
105 7. DISCLAIMER.
106 
107 This Tokenized Company Equity Right subject to the Agreement P003_25793 is not a consumer good and sold on an “as is” and 
108 
109 “as-available” basis. Token Holder(s) bears the entire risk, Token Issuer sells the tokenized Company Equity Right to Token Holder(s) 
110 
111 without any warranty of fitness for a particular purpose, and Token Holder(s) acknowledges that no warrant of fitness could be offered
112 
113 because of the many future technical and legal uncertainties regarding the Tokenized Company Equity Right. 
114 
115 8. TAX.
116 
117 Token Issuer is not responsible for any taxes or any other costs related to purchasing the Tokenized Company Equity Right created 
118 
119 under the Agreement P003_25793. 
120 
121 9. NO DAMAGES.
122 
123 Token Issuer will never be liable to Token Holder(s) for consequential and any kind of damages, including but not limited to lost 
124 
125 profits. 
126 
127 10. MARKET RISK.
128 
129 All Token Holder(s) understands that this Tokenized Company Equity Right is a new and relatively untested exchange medium. Token 
130 
131 Holder(s) therefore understands that Token Issuer cannot predict how the value of the Tokenized Right will change, the consumer 
132 
133 demand for the Tokenized Right, technical difficulties in or modification to the peer-to-peer blockchain network, change of 
134 
135 regulations, and all other obstacles that a peer-to-peer blockchain network might face. All Token Holder(s) affirmatively represents 
136 
137 that he/she is a sophisticated blockchain users and therefore knowingly assumes all known and unknown risk of loss. All Token Holder(s)
138 
139 has not recourse whatsoever against Token Issuer for damages or liability suffered by Token Holder(s) due to the market condition or 
140 
141 whatsoever causes. 
142 
143 11. RISK OF FINANCIAL REGULATION.
144 
145 All Token Holder(s) understands that the Tokenized Company Equity Right is a relatively new technology and no one can predict how the 
146 
147 government for each country may apply and enforce the existing laws or regulate the Tokenized Right or other peer-to-peer blockchain 
148 
149 based exchange technologies in the future. All Token Holder(s) understands that there is a high level of uncertainty, and all Token 
150 
151 Holder(s) assumes that all financial regulatory risk inherent in operating and transferring the Tokenized Right. 
152 
153 All Token Holder(s) has no recourse whatsoever against Token Issuer for damages, civil and criminal, suffered by each Token Holder(s) 
154 
155 due to regulatory enforcement. Token Issuer does not and cannot warrant that the exercise or transfer of the Tokenized Company Equity 
156 
157 Right is legal in all specific jurisdiction of each country. Token Issuer has not duty to advise or warn to each Token Holder(s) and 
158 
159 each Token Holder(s) will not advise or warn Token Issuer about any particular legal or regulatory requirement(s). Each Token Holder(s)
160 
161 is solely obligated to understand the laws and regulations of its local jurisdiction before exercising, selling, or purchasing the 
162 
163 Tokenized Right, and Token Holder(s) is solely responsible for any of its actions that may be unlawful. 
164 
165 12. DEFINITIONS. 
166 
167 “Tokenized Right to Company Equity Revenue” means a digitized portion or unit of the syndicated ownership of the Company Equity Right 
168 
169 created under the Agreement P003_25793. “Token Holder(s)” means a buyer(s) of the tokenized Right representing an ownership of the 
170 
171 Company Equity Right through the Smart Contract created by the Token Issuer hereunder. “Smart Contract” means terms and conditions 
172 
173 for a legally effective Instrument written in programming language or asset protocol into the blockchain of Token Issuer’s choice. 
174 
175 “Token Buyer” means that a party (an individual, legal entity, or authorized person representing an organization) that intends to buy 
176 
177 the Tokenized Company Equity Right initially issued by Token Issuer hereunder. 
178 
179 13. DISPUTE RESOLTUION.
180 
181 Informal Resolution. If either Token Issuer or Token Holder has any concerns regarding a breach under this Agreement, the complaining 
182 
183 party must first notify the other and allow the other party at least 30 days to remedy the claimed breach. Binding Arbitration. Any 
184 
185 dispute arising out of or relating to this Agreement, or the breach thereof, shall finally settled under the Rules of Arbitration of 
186 
187 the International Chamber of Commerce by one or three arbitrator, and judgement upon the award rendered the arbitrators may be 
188 
189 entered in a court in United States jurisdiction. The arbitration will be conducted in the English language, in accordance with the 
190 
191 international Arbitration Rules of the United States Commercial Arbitration Board. 
192 
193 14. MISCELLANEOUS.
194 
195 14.1. No Conditions to Effectiveness; Entire Agreement. There are no conditions to the effectiveness of this Agreement. This Agreement 
196 
197 contains the entire agreement and understanding of the Parties hereto, and supersedes any prior agreements or understandings between 
198 
199 or among the Parties hereto, which respect to the subject matter hereof. 
200 
201 14.2. Governing Law. This Agreement, and the right of the Parties hereto, shall be governed by, construed and enforced in accordance 
202 
203 with the laws of United States regardless of the conflict of laws principle. Any action in respect of, or concerning, this Agreement 
204 
205 shall be litigated solely in United States and both Parties consent to jurisdiction of the person and venue solely in United States . 
206 
207 14.3. Amendment and Waivers. This Agreement may be amended only by an instrument in writing signed by the Parties hereto. No waivers 
208 
209 of or exceptions to any term, condition or provision of this Agreement, in any one or more instances, shall be deemed to be, or 
210 
211 construed as, a further or continuing waiver of any such term, condition or provision. 
212 
213 14.4. Severability. If any provision of this Agreement is held to be invalid or unenforceable, the validity and enforceability of the 
214 
215 remaining provisions of this Agreement shall not be affected thereby. 
216 
217 14.5. Each party, in entering into this Agreement, acts as an independent party and nothing herein shall be construed to create a 
218 
219 partnership or joint venture between the Parties or to constitute agency of an sort. Neither party shall have the authority to bind the other. 
220 
221 14.6. Force Majeure. A party is not liable for failure to perform the party’s obligations if such failure is as a result of Acts of 
222 
223 God including: fire, flood, earthquake, storm, hurricane or other natural disaster), war, invasion, act of foreign enemies, 
224 
225 hostilities (regardless of whether war is declared), civil war, rebellion, revolution, insurrection, military or usurped power or 
226 
227 confiscation, terrorist activities, nationalization, government sanction, or government prohibition or regulation preventing the 
228 
229 trade of blockchain-backed token(s). 
230 
231 IN WITNESS WHEREOF, the Token Issuer, Qwoyn Digital Investments, LLC hereto have executed this Agreement as of the date first written 
232 
233 above. 
234 
235 Token Issuer/Token Holder
236 
237 Daniel Pittman, CEO
238 _____________________________ 
239 Qwoyn Digital Investments, LLC 
240 2017-12-06                                                                                                                          */
241 
242 
243 /********************
244  * SMART CONTRACT   *
245  * CODE BEGINS HERE *
246  *******************/ 
247 
248 /*ERC20*/         
249 pragma solidity ^0.4.18;
250  
251 //TOKEN SECURITY//
252  
253  /**
254  * @title Math
255  * @dev Assorted math operations
256  */
257 
258 library Math {
259   function max64(uint64 a, uint64 b) internal pure returns (uint64) {
260     return a >= b ? a : b;
261   }
262 
263   function min64(uint64 a, uint64 b) internal pure returns (uint64) {
264     return a < b ? a : b;
265   }
266 
267   function max256(uint256 a, uint256 b) internal pure returns (uint256) {
268     return a >= b ? a : b;
269   }
270 
271   function min256(uint256 a, uint256 b) internal pure returns (uint256) {
272     return a < b ? a : b;
273   }
274 }
275  
276  /**
277  * @title SafeMath
278  * @dev Math operations with safety checks that throw on error
279  */
280 library SafeMath {
281   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
282     if (a == 0) {
283       return 0;
284     }
285     uint256 c = a * b;
286     assert(c / a == b);
287     return c;
288   }
289 
290   function div(uint256 a, uint256 b) internal pure returns (uint256) {
291     // assert(b > 0); // Solidity automatically throws when dividing by 0
292     uint256 c = a / b;
293     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
294     return c;
295   }
296 
297   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
298     assert(b <= a);
299     return a - b;
300   }
301 
302   function add(uint256 a, uint256 b) internal pure returns (uint256) {
303     uint256 c = a + b;
304     assert(c >= a);
305     return c;
306   }
307 }
308  
309  /*
310  * @title MerkleProof
311  * @dev Merkle proof verification
312  * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol
313  */
314 library MerkleProof {
315   /*
316    * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves
317    * and each pair of pre-images is sorted.
318    * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree
319    * @param _root Merkle root
320    * @param _leaf Leaf of Merkle tree
321    */
322   function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {
323     // Check if proof length is a multiple of 32
324     if (_proof.length % 32 != 0) return false;
325 
326     bytes32 proofElement;
327     bytes32 computedHash = _leaf;
328 
329     for (uint256 i = 32; i <= _proof.length; i += 32) {
330       assembly {
331         // Load the current element of the proof
332         proofElement := mload(add(_proof, i))
333       }
334 
335       if (computedHash < proofElement) {
336         // Hash(current computed hash + current element of the proof)
337         computedHash = keccak256(computedHash, proofElement);
338       } else {
339         // Hash(current element of the proof + current computed hash)
340         computedHash = keccak256(proofElement, computedHash);
341       }
342     }
343 
344     // Check if the computed hash (root) is equal to the provided root
345     return computedHash == _root;
346   }
347 }
348 
349  /**
350  * @title Helps contracts guard agains rentrancy attacks.
351  * @author Remco Bloemen <remco@2p.com>
352  * @notice If you mark a function `nonReentrant`, you should also
353  * mark it `external`.
354  */
355 contract ReentrancyGuard {
356 
357   /**
358    * @dev We use a single lock for the whole contract.
359    */
360   bool private rentrancy_lock = false;
361 
362   /**
363    * @dev Prevents a contract from calling itself, directly or indirectly.
364    * @notice If you mark a function `nonReentrant`, you should also
365    * mark it `external`. Calling one nonReentrant function from
366    * another is not supported. Instead, you can implement a
367    * `private` function doing the actual work, and a `external`
368    * wrapper marked as `nonReentrant`.
369    */
370   modifier nonReentrant() {
371     require(!rentrancy_lock);
372     rentrancy_lock = true;
373     _;
374     rentrancy_lock = false;
375   }
376 
377 }
378 
379 //Cornerstone TOKEN//
380 
381 /*Contract to Declare Owner*/
382 contract owned {
383     address public owner;
384 
385     function owned() public {
386         owner = msg.sender;
387     }
388 
389     modifier onlyOwner {
390         require(msg.sender == owner);
391         _;
392     }
393 
394     function transferOwnership(address newOwner) onlyOwner public {
395         owner = newOwner;
396     }
397 }
398 
399 /* Interfaces */
400 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
401 
402 //Cornerstone Contract//
403 
404 /* Cornerstone Token Contract */
405 contract Cornerstone is owned{
406     // Public variables of the token
407     string public name;
408     string public symbol;
409     uint8 public decimals;
410     // 18 decimals is the strongly suggested default, avoid changing it
411     uint256 public totalSupply;
412 
413     // This creates an array with all balances
414     mapping (address => uint256) public balanceOf;
415     mapping (address => mapping (address => uint256)) public allowance;
416     
417     // This creates an arroy for accounts to freeze
418     mapping (address => bool) public frozenAccount;
419 
420     // This generates a public event on the blockchain that will notify clients
421     event Transfer(address indexed from, address indexed to, uint256 value);
422 
423     // This notifies clients about the amount burnt
424     event Burn(address indexed from, uint256 value);
425     
426     // This notifies clients of frozen account
427     event FrozenFunds(address target, bool frozen);
428 
429     /**
430      * Constrctor function
431      *
432      * Initializes contract with initial supply tokens to the creator of the contract
433      */
434     function Cornerstone(
435         uint256 initialSupply,
436         string tokenName,
437         string tokenSymbol
438     ) public {
439         totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount  // Update total supply with the decimal amount
440         balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
441         name = tokenName;                                   // Set the name for display purposes
442         symbol = tokenSymbol;                               // Set the symbol for display purposes
443     }
444     
445     function freezeAccount(address target, bool freeze) onlyOwner public{
446         frozenAccount[target] = freeze;
447         FrozenFunds(target, freeze);
448     }
449     
450     /**
451      * Internal transfer, only can be called by this contract
452      */
453     function _transfer(address _from, address _to, uint _value) internal {
454         // Prevent transfer to 0x0 address. Use burn() instead
455         require(_to != 0x0);
456         // Check if the sender has enough
457         require(balanceOf[_from] >= _value);
458         // Check for overflows
459         require(balanceOf[_to] + _value > balanceOf[_to]);
460         // Save this for an assertion in the future
461         // Check if sender is frozen
462         require(!frozenAccount[_from]);        
463         // Check if recipient is frozen
464         require(!frozenAccount[_to]);                      
465         uint previousBalances = balanceOf[_from] + balanceOf[_to];
466         // Subtract from the sender
467         balanceOf[_from] -= _value;
468         // Add the same to the recipient
469         balanceOf[_to] += _value;
470         Transfer(_from, _to, _value);
471         // Asserts are used to use static analysis to find bugs in your code. They should never fail
472         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
473     }
474 
475     /**
476      * Transfer tokens
477      *
478      * Send `_value` tokens to `_to` from your account
479      *
480      * @param _to The address of the recipient
481      * @param _value the amount to send
482      */
483     function transfer(address _to, uint256 _value) public {
484         _transfer(msg.sender, _to, _value);
485     }
486 
487     /**
488      * Transfer tokens from other address
489      *
490      * Send `_value` tokens to `_to` in behalf of `_from`
491      *
492      * @param _from The address of the sender
493      * @param _to The address of the recipient
494      * @param _value the amount to send
495      */
496     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
497         require(_value <= allowance[_from][msg.sender]);     // Check allowance
498         allowance[_from][msg.sender] -= _value;
499         _transfer(_from, _to, _value);
500         return true;
501     }
502 
503     /**
504      * Set allowance for other address
505      *
506      * Allows `_spender` to spend no more than `_value` tokens in your behalf
507      *
508      * @param _spender The address authorized to spend
509      * @param _value the max amount they can spend
510      */
511     function approve(address _spender, uint256 _value) public
512         returns (bool success) {
513         allowance[msg.sender][_spender] = _value;
514         return true;
515     }
516 
517     /**
518      * Set allowance for other address and notify
519      *
520      * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it
521      *
522      * @param _spender The address authorized to spend
523      * @param _value the max amount they can spend
524      * @param _extraData some extra information to send to the approved contract
525      */
526     function approveAndCall(address _spender, uint256 _value, bytes _extraData)
527         public
528         returns (bool success) {
529         tokenRecipient spender = tokenRecipient(_spender);
530         if (approve(_spender, _value)) {
531             spender.receiveApproval(msg.sender, _value, this, _extraData);
532             return true;
533         }
534     }
535 
536     /**
537      * Destroy tokens
538      *
539      * Remove `_value` tokens from the system irreversibly
540      *
541      * @param _value the amount of money to burn
542      */
543     function burn(uint256 _value) public returns (bool success) {
544         require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough
545         balanceOf[msg.sender] -= _value;            // Subtract from the sender
546         totalSupply -= _value;                      // Updates totalSupply
547         Burn(msg.sender, _value);
548         return true;
549     }
550 
551     /**
552      * Destroy tokens from other account
553      *
554      * Remove `_value` tokens from the system irreversibly on behalf of `_from`.
555      *
556      * @param _from the address of the sender
557      * @param _value the amount of money to burn
558      */
559     function burnFrom(address _from, uint256 _value) public returns (bool success) {
560         require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough
561         require(_value <= allowance[_from][msg.sender]);    // Check allowance
562         balanceOf[_from] -= _value;                         // Subtract from the targeted balance
563         allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance
564         totalSupply -= _value;                              // Update totalSupply
565         Burn(_from, _value);
566         return true;
567     }
568 }
569 
570 /* ADVANCED TOKEN  */
571 
572 contract MyAdvancedToken is owned, Cornerstone {
573 
574     uint256 public sellPrice;
575     uint256 public buyPrice;
576 
577     mapping (address => bool) public frozenAccount;
578 
579     /* This generates a public event on the blockchain that will notify clients */
580     event FrozenFunds(address target, bool frozen);
581 
582     /* Initializes contract with initial supply tokens to the creator of the contract */
583     function MyAdvancedToken(
584         uint256 initialSupply,
585         string tokenName,
586         string tokenSymbol
587     ) Cornerstone(initialSupply, tokenName, tokenSymbol) public {}
588 
589     /* Internal transfer, only can be called by this contract */
590     function _transfer(address _from, address _to, uint _value) internal {
591         require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead
592         require (balanceOf[_from] >= _value);               // Check if the sender has enough
593         require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows
594         require(!frozenAccount[_from]);                     // Check if sender is frozen
595         require(!frozenAccount[_to]);                       // Check if recipient is frozen
596         balanceOf[_from] -= _value;                         // Subtract from the sender
597         balanceOf[_to] += _value;                           // Add the same to the recipient
598         Transfer(_from, _to, _value);
599     }
600 
601     /// @notice Create `mintedAmount` tokens and send it to `target`
602     /// @param target Address to receive the tokens
603     /// @param mintedAmount the amount of tokens it will receive
604     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
605         balanceOf[target] += mintedAmount;
606         totalSupply += mintedAmount;
607         Transfer(0, this, mintedAmount);
608         Transfer(this, target, mintedAmount);
609     }
610 
611     /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens
612     /// @param target Address to be frozen
613     /// @param freeze either to freeze it or not
614     function freezeAccount(address target, bool freeze) onlyOwner public {
615         frozenAccount[target] = freeze;
616         FrozenFunds(target, freeze);
617     }
618 
619     /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth
620     /// @param newSellPrice Price the users can sell to the contract
621     /// @param newBuyPrice Price users can buy from the contract
622     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
623         sellPrice = newSellPrice;
624         buyPrice = newBuyPrice;
625     }
626 
627     /// @notice Buy tokens from contract by sending ether
628     function buy() payable public {
629         uint amount = msg.value / buyPrice;               // calculates the amount
630         _transfer(this, msg.sender, amount);              // makes the transfers
631     }
632 
633     /// @notice Sell `amount` tokens to contract
634     /// @param amount amount of tokens to be sold
635     function sell(uint256 amount) public {
636         require(this.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy
637         _transfer(msg.sender, this, amount);              // makes the transfers
638         msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks
639     }
640 }