1 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
2 // 口口口口口口口口口口口口口　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
3 // 口口口口口口口口口口口口　　　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
4 // 口口口口口口口口口口口　　　　口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
5 // 口口口口口口口口口口　　　　口口口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
6 // 口口口口口口口口口口　　　口口口口口口口　　　口口　　　　　　　口口口　　　　　　口口　　　　　　　　　口口口口口口口口口
7 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　口口　　　　　　口　　　　　　　　　　口口口口口口口口口
8 // 口口口口口口口口口　　　　口口口口口口口口口口　　　　口口口　　　口口　　　　口口口　　　口口　　　　　口口口口口口口口口
9 // 口口口口口口口口口　　　　口口口口口口口口口口口口口口口口口　　　口口　　　口口口　　　　口口口　　　　口口口口口口口口口
10 // 口口口口口口口口口　　　　口口口口口口口口口口口口　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
11 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
12 // 口口口口口口口口口口　　　口口口口口口口　　　　　　　口口口　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
13 // 口口口口口口口口口口　　　　口口口口口　　　　　　　口口口口　　　　口　　　口口口　　　　口口口　　　　口口口口口口口口口
14 // 口口口口口口口口口口口　　　　口口口　　　　口　　　　口口　　　　　口　　　口口口　　　　口口　　　　　口口口口口口口口口
15 // 口口口口口口口口口口口口　　　　　　　　　　口口　　　　　　　　　　口　　　口口口口　　　　　　　　　　口口口口口口口口口
16 // 口口口口口口口口口口口口口　　　　　　　口口口口口　　　　　　　　　口　　　口口口口口　　　　　　　　　口口口口口口口口口
17 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
18 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
19 // 口口口　　　　口口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
20 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
21 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
22 // 口口口　　　　　口口口口　　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
23 // 口口口　　　　　　口口口　　　　　　口口口　　　　　　　口口口　　　口口　　　　口口口　　　　　　口口口　　　　　　口口口
24 // 口口口　　　　　　口口口　　　　　　口口　　　　　　　　　口口　　　口　　　　口口　　　　　　　　　口口　　　　　　口口口
25 // 口口口　　　　　　口口　　　　　　　口　　　　口口口　　　口口　　　　　　　口口口　　　口口口　　　　口　　　　口口口口口
26 // 口口口　　　　　　　口　　　　　　　口口口口口口口口　　　口口　　　　　　口口口　　　　口口口口　　　口　　　口口口口口口
27 // 口口口　　　口　　　口　　　　　　　口口口　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
28 // 口口口　　　口　　　口　　　　　　　口口　　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
29 // 口口口　　　口　　　　　　口　　　　口　　　　口口口　　　　口　　　　　　　口口　　　口口口口口口口口口　　　口口口口口口
30 // 口口口　　　口口　　　　　口　　　　口　　　口口口口　　　　口　　　口　　　　口　　　　口口口口口口口口　　　口口口口口口
31 // 口口口　　　口口　　　　　口　　　　口　　　　口口　　　　　口　　　口口　　　口口　　　　口口　　　　口　　　口口口口口口
32 // 口口口　　　口口　　　　口口　　　　口口　　　　　　　　　　口　　　口口　　　　口　　　　　　　　　口口　　　口口口口口口
33 // 口口口　　　口口口　　　口口　　　　口口口　　　　　　　　　口　　　口口口　　　　口口　　　　　　口口口　　　口口口口口口
34 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
35 
36 
37 pragma solidity ^0.4.24;
38 
39 /**
40  * @title SafeMath
41  * @dev Math operations with safety checks that throw on error
42  */
43 library SafeMath {
44 
45     /**
46     * @dev Adds two numbers, throws on overflow.
47     */
48     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
49         c = a + b;
50         assert(c >= a);
51         return c;
52     }
53 
54     /**
55     * @dev Multiplies two numbers, throws on overflow.
56     */
57     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
58         if (a == 0) {
59             return 0;
60         }
61         c = a * b;
62         assert(c / a == b);
63         return c;
64     }
65 
66     /**
67     * @dev Integer division of two numbers, truncating the quotient.
68     */
69     function div(uint256 a, uint256 b) internal pure returns (uint256) {
70         return a / b;
71     }
72 
73     /**
74     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
75     */
76     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
77         assert(b <= a);
78         return a - b;
79     }
80 }
81 
82 /**
83  * @title Ownable
84  * @dev The Ownable contract has an owner address, and provides basic authorization control
85  * functions, this simplifies the implementation of "user permissions".
86  */
87 contract Ownable {
88     address public owner;
89     address public newOwner;
90 
91     event OwnershipTransferred(address indexed _from, address indexed _to);
92 
93     constructor() public {
94         owner = msg.sender;
95     }
96 
97     modifier onlyOwner {
98         require(msg.sender == owner);
99         _;
100     }
101 
102     function transferOwnership(address _newOwner) public onlyOwner {
103         newOwner = _newOwner;
104     }
105 
106     function acceptOwnership() public {
107         require(msg.sender == newOwner);
108         emit OwnershipTransferred(owner, newOwner);
109         owner = newOwner;
110         newOwner = address(0);
111     }
112 }
113 
114 /**
115  * @title Pausable
116  * @dev Base contract which allows children to implement an emergency stop mechanism.
117  */
118 contract Pausable is Ownable {
119     event Pause();
120     event Unpause();
121 
122     bool public paused = false;
123 
124     /**
125      * @dev modifier to allow actions only when the contract IS paused
126      */
127     modifier whenNotPaused() {
128         require(!paused);
129         _;
130     }
131 
132     /**
133      * @dev modifier to allow actions only when the contract IS NOT paused
134      */
135     modifier whenPaused {
136         require(paused);
137         _;
138     }
139 
140     /**
141      * @dev called by the owner to pause, triggers stopped state
142      */
143     function pause() onlyOwner whenNotPaused public returns (bool) {
144         paused = true;
145         emit Pause();
146         return true;
147     }
148 
149     /**
150      * @dev called by the owner to unpause, returns to normal state
151      */
152     function unpause() onlyOwner whenPaused public returns (bool) {
153         paused = false;
154         emit Unpause();
155         return true;
156     }
157 }
158 
159 // ----------------------------------------------------------------------------
160 // ERC Token Standard #20 Interface
161 // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
162 // ----------------------------------------------------------------------------
163 contract ERC20Interface {
164     function totalSupply() public constant returns (uint);
165     function balanceOf(address tokenOwner) public constant returns (uint);
166     function allowance(address tokenOwner, address spender) public constant returns (uint);
167     function transfer(address to, uint tokens) public returns (bool);
168     function approve(address spender, uint tokens) public returns (bool);
169     function transferFrom(address from, address to, uint tokens) public returns (bool);
170 
171     function name() public constant returns (string);
172     function symbol() public constant returns (string);
173     function decimals() public constant returns (uint8);
174 
175     event Transfer(address indexed from, address indexed to, uint tokens);
176     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
177 }
178 
179 /**
180 * ERC223 token by Dexaran
181 * New ERC223 contract interface
182 * https://github.com/Dexaran/ERC223-token-standard
183 */
184 contract ERC223 is ERC20Interface {
185     function transfer(address to, uint value, bytes data) public returns (bool);
186 
187     event Transfer(address indexed from, address indexed to, uint tokens);
188     event Transfer(address indexed from, address indexed to, uint value, bytes data);
189 }
190 
191 /**
192 * @title Contract that will work with ERC223 tokens.
193 */
194 contract ERC223ReceivingContract {
195     /**
196      * @dev Standard ERC223 function that will handle incoming token transfers.
197      * @param _from  Token sender address.
198      * @param _value Amount of tokens.
199      * @param _data  Transaction metadata.
200      */
201     function tokenFallback(address _from, uint _value, bytes _data) public;
202     function doTransfer(address _to, uint256 _index) public returns (uint256 price, address owner);
203 }
204 
205 contract CardMakerCake is ERC223, Pausable {
206 
207     using SafeMath for uint256;
208 
209     mapping(address => uint) balances;
210     mapping(address => mapping(address => uint)) internal allowed;
211 
212     string public name;
213     string public symbol;
214     uint8 public decimals;
215     uint256 public totalSupply;
216 
217     // EIP1046/1047
218     string private tokenURI_ = "";
219 
220     event Burn(address indexed burner, uint256 value);
221 
222     constructor() public {
223         tokenURI_ = "cardmaker.io";
224         name = "CardMaker Alchemists Knowledge Energy (CardMaker Token)";
225         symbol = "CAKE";
226         decimals = 18;
227         totalSupply = 10000 * 10000 * 50 * 10 ** uint(decimals);
228         balances[msg.sender] = totalSupply;
229     }
230 
231     function tokenURI() external view returns (string) {
232         return tokenURI_;
233     }
234 
235     // Function to access name of token .
236     function name() public constant returns (string) {
237         return name;
238     }
239     // Function to access symbol of token .
240     function symbol() public constant returns (string) {
241         return symbol;
242     }
243     // Function to access decimals of token .
244     function decimals() public constant returns (uint8) {
245         return decimals;
246     }
247     // Function to access total supply of tokens .
248     function totalSupply() public constant returns (uint256) {
249         return totalSupply;
250     }
251 
252     // Function that is called when a user or another contract wants to transfer funds .
253     function transfer(address _to, uint _value, bytes _data) public whenNotPaused returns (bool) {
254         if(isContract(_to)) {
255             return transferToContract(_to, _value, _data);
256         } else {
257             return transferToAddress(_to, _value, _data);
258         }
259     }
260 
261     // Standard function transfer similar to ERC20 transfer with no _data .
262     // Added due to backwards compatibility reasons .
263     function transfer(address _to, uint _value) public whenNotPaused returns (bool) {
264         bytes memory empty;
265         if(isContract(_to)) {
266             return transferToContract(_to, _value, empty);
267         } else {
268             return transferToAddress(_to, _value, empty);
269         }
270     }
271 
272     //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
273     function isContract(address _addr) private view returns (bool) {
274         uint length;
275         assembly {
276         //retrieve the size of the code on target address, this needs assembly
277             length := extcodesize(_addr)
278         }
279         return (length>0);
280     }
281 
282     //function that is called when transaction target is an address
283     function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {
284         if (balanceOf(msg.sender) < _value) revert();
285         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
286         balances[_to] = balanceOf(_to).add(_value);
287         emit Transfer(msg.sender, _to, _value);
288         emit Transfer(msg.sender, _to, _value, _data);
289         return true;
290     }
291 
292     //function that is called when transaction target is a contract
293     function transferToContract(address _to, uint _value, bytes _data) private returns (bool) {
294 
295         ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
296         uint256 price;
297         address owner;
298         (price, owner) = receiver.doTransfer(msg.sender, bytesToUint(_data));
299 
300         if (balanceOf(msg.sender) < price) revert();
301         balances[msg.sender] = balanceOf(msg.sender).sub(price);
302         balances[owner] = balanceOf(owner).add(price);
303         receiver.tokenFallback(msg.sender, price, _data);
304         emit Transfer(msg.sender, _to, _value);
305         emit Transfer(msg.sender, _to, _value, _data);
306         return true;
307     }
308 
309     function balanceOf(address _owner) public constant returns (uint) {
310         return balances[_owner];
311     }
312 
313     function allowance(address _tokenOwner, address _spender) public constant returns (uint) {
314         return allowed[_tokenOwner][_spender];
315     }
316 
317     function burn(uint256 _value) public returns (bool) {
318         require (_value > 0);
319         // Check if the sender has enough
320         require (balanceOf(msg.sender) >= _value);
321         // Subtract from the sender
322         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
323         // Updates totalSupply
324         totalSupply = totalSupply.sub(_value);
325         emit Burn(msg.sender, _value);
326         return true;
327     }
328 
329     function bytesToUint(bytes b) private pure returns (uint result) {
330         uint i;
331         result = 0;
332         for (i = 0; i < b.length; i++) {
333             uint c = uint(b[i]);
334             if (c >= 48 && c <= 57) {
335                 result = result * 10 + (c - 48);
336             }
337         }
338     }
339 
340     function approve(address _spender, uint _tokens) public whenNotPaused returns (bool) {
341         allowed[msg.sender][_spender] = _tokens;
342         emit Approval(msg.sender, _spender, _tokens);
343         return true;
344     }
345 
346     function transferFrom(address _from, address _to, uint _tokens) public whenNotPaused returns (bool) {
347         require(_to != address(0));
348         require(_tokens <= balances[_from]);
349         require(_tokens <= allowed[_from][msg.sender]);
350 
351         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);
352         balances[_from] = balances[_from].sub(_tokens);
353         balances[_to] = balances[_to].add(_tokens);
354         emit Transfer(_from, _to, _tokens);
355         return true;
356     }
357 
358     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {
359         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));
360         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
361         return true;
362     }
363 
364     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool){
365         uint256 oldValue = allowed[msg.sender][_spender];
366         if (_subtractedValue > oldValue) {
367             allowed[msg.sender][_spender] = 0;
368         } else {
369             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
370         }
371         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
372         return true;
373     }
374 
375     // ------------------------------------------------------------------------
376     // Don't accept ETH
377     // ------------------------------------------------------------------------
378     function () public payable {
379         revert();
380     }
381 
382     // ------------------------------------------------------------------------
383     // Owner can transfer out any accidentally sent ERC20 tokens
384     // ------------------------------------------------------------------------
385     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool) {
386         return ERC20Interface(tokenAddress).transfer(owner, tokens);
387     }
388 }