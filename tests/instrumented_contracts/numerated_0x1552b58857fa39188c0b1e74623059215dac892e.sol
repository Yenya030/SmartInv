1 {{
2   "language": "Solidity",
3   "sources": {
4     "other/artifacts/GtrNftTopupV2.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) { return msg.sender; }\r\n    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n    bool private _paused;\r\n    constructor() { _paused = false; }\r\n    function paused() public view virtual returns (bool) { return _paused; }\r\n    modifier whenNotPaused() { require(!paused(), \"Pausable: paused\"); _; }\r\n    modifier whenPaused() { require(paused(), \"Pausable: not paused\"); _; }\r\n    function _pause() internal virtual whenNotPaused { _paused = true; emit Paused(_msgSender()); }\r\n    function _unpause() internal virtual whenPaused { _paused = false; emit Unpaused(_msgSender()); }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() { _transferOwnership(_msgSender()); }\r\n    function owner() public view virtual returns (address) { return _owner; }\r\n    modifier onlyOwner() { require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); _; }\r\n    function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); _transferOwnership(newOwner); }\r\n    function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ncontract GtrNftTopupV2 is Ownable, Pausable {\r\n\r\n    mapping(IERC20 => bool) public _validTokenContracts;\r\n    mapping(IERC721 => bool) public _validNftContracts;\r\n    address public _depositAddress;\r\n    uint256 public _depositTaxPercent;\r\n    uint256 public _depositTaxPercentDivisor;\r\n\r\n    event DepositRequested(address sender, address nftContract, uint256 nftId, address tokenContract, uint8 tokenDecimals, uint256 depositAmount, uint taxAmount);\r\n    event WithdrawalRequested(address sender, address nftContract, uint256 nftId, uint256 amount);\r\n    event CompoundUpdateRequested(address sender, address nftContract, uint256 nftId, uint8 percent);\r\n    \r\n    constructor() {\r\n        //validate stablecoins for deposit\r\n        _validTokenContracts[IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = true; //usdt mainnet\r\n        _validTokenContracts[IERC20(0x4Fabb145d64652a948d72533023f6E7A623C7C53)] = true; //busd mainnet\r\n        _validTokenContracts[IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = true; //usdc mainnet\r\n\r\n        //validate existing GTR NFT contracts\r\n        _validNftContracts[IERC721(0x472B932cc83678f75A409326b71c7FCB16081Dd3)] = true; //diamond\r\n        _validNftContracts[IERC721(0xdAeC66BD252768DB641E8F51255260762708ACf4)] = true; //gold\r\n        _validNftContracts[IERC721(0x837204F046fF7F2a6E50cC4aec6aDc85D20a2A72)] = true; //silver\r\n\r\n        //set deposit settings\r\n        _depositAddress = 0x628789179aA833f3D8Aa319b3a3604991a682c2f;\r\n        _depositTaxPercent = 5;\r\n        _depositTaxPercentDivisor = 100;\r\n    }\r\n\r\n    function deposit(IERC721 nftContract, uint256 nftId, IERC20 tokenContract, uint256 amount) external whenNotPaused {\r\n        //validate tx\r\n        require(_validNftContracts[nftContract] == true, \"NFT_INVALID\");\r\n        require(nftId <= nftContract.totalSupply(), \"NFT_INVALID\");\r\n        require(nftContract.ownerOf(nftId) != address(0), \"NFT_INVALID\");\r\n        require(_validTokenContracts[tokenContract] == true, \"ASSET_INVALID\");\r\n        require(amount > 0, \"AMOUNT_INVALID\");\r\n\r\n        //transfer funds\r\n        require(tokenContract.balanceOf(msg.sender) >= amount, \"BALANCE_INSUFFICIENT\");\r\n        require(tokenContract.allowance(msg.sender, address(this)) >= amount, \"ALLOWANCE_INSUFFICIENT\");\r\n        (bool success, bytes memory data) = address(tokenContract).call(abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, _depositAddress, amount)); \r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERC20_TRANSFER_FAILED\");\r\n\r\n        //emit event\r\n        uint256 taxAmount = (_depositTaxPercent > 0 && _depositTaxPercentDivisor > 0) ? (amount * _depositTaxPercent / _depositTaxPercentDivisor) : 0;\r\n        uint256 depositAmount = amount - taxAmount;\r\n        emit DepositRequested(msg.sender, address(nftContract), nftId, address(tokenContract), tokenContract.decimals(), depositAmount, taxAmount);\r\n    }\r\n\r\n    function withdraw(IERC721 nftContract, uint256 nftId, uint256 amount) external whenNotPaused {\r\n        require(_validNftContracts[nftContract] == true, \"NFT_INVALID\");\r\n        require(nftId <= nftContract.totalSupply(), \"NFT_INVALID\");\r\n        require(nftContract.ownerOf(nftId) == msg.sender, \"NOT_ALLOWED\");\r\n\r\n        //emit event\r\n        emit WithdrawalRequested(msg.sender, address(nftContract), nftId, amount);\r\n    }\r\n\r\n    function updateCompoundPercent(IERC721 nftContract, uint256 nftId, uint8 percent) external whenNotPaused {\r\n        require(_validNftContracts[nftContract] == true, \"NFT_INVALID\");\r\n        require(nftId <= nftContract.totalSupply(), \"NFT_INVALID\");\r\n        require(nftContract.ownerOf(nftId) == msg.sender, \"NOT_ALLOWED\");\r\n\r\n        //emit event\r\n        emit CompoundUpdateRequested(msg.sender, address(nftContract), nftId, percent);\r\n    }\r\n\r\n    //admin functions\r\n    function setValidTokenContractStatus(IERC20 contractAddress, bool status) external onlyOwner {\r\n        _validTokenContracts[contractAddress] = status;\r\n    }\r\n\r\n    function setValidNftContractStatus(IERC721 contractAddress, bool status) external onlyOwner {\r\n        _validNftContracts[contractAddress] = status;\r\n    }\r\n\r\n    function setDepositWalletAddress(address to) external onlyOwner {\r\n        _depositAddress = to;\r\n    }\r\n\r\n    function setDepositTaxPercent(uint256 amount, uint256 divisor) external onlyOwner {\r\n        _depositTaxPercent = amount;\r\n        _depositTaxPercentDivisor = divisor;\r\n    }\r\n\r\n    //pausable implementation\r\n    function pause() external onlyOwner { _pause(); }\r\n    function unpause() external onlyOwner { _unpause(); }\r\n\r\n    //default withdrawal functions\r\n    function withdrawToken(IERC20 token, uint256 amount, address to) external onlyOwner {\r\n        if (address(token) == address(0)) {\r\n            (bool success, ) = to.call{value: (amount == 0 ? address(this).balance : amount)}(new bytes(0)); \r\n            require(success, \"NATIVE_TRANSFER_FAILED\");\r\n        } else {\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, (amount == 0 ? token.balanceOf(address(this)) : amount))); \r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"ERC20_TRANSFER_FAILED\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": false,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}