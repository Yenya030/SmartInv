1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/LlamaPayBot.sol": {
5       "content": "//SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\ninterface LlamaPay {\n    function withdraw(\n        address from,\n        address to,\n        uint216 amountPerSec\n    ) external;\n\n    function withdrawable(\n        address from,\n        address to,\n        uint216 amountPerSec\n    )\n        external\n        view\n        returns (\n            uint256 withdrawableAmount,\n            uint256 lastUpdate,\n            uint256 owed\n        );\n}\n\ninterface LlamaPayFactory {\n    function getLlamaPayContractByToken(address _token)\n        external\n        view\n        returns (address predictedAddress, bool isDeployed);\n}\n\ncontract LlamaPayBot {\n    using SafeTransferLib for ERC20;\n\n    address public immutable factory;\n    address public bot;\n    address public llama;\n    address public newLlama = address(0);\n    uint256 public fee = 50000; // Covers bot gas cost for calling function\n\n    event WithdrawScheduled(\n        address owner,\n        address token,\n        address from,\n        address to,\n        uint216 amountPerSec,\n        uint40 starts,\n        uint40 frequency,\n        bytes32 id\n    );\n\n    event WithdrawCancelled(\n        address owner,\n        address token,\n        address from,\n        address to,\n        uint216 amountPerSec,\n        uint40 starts,\n        uint40 frequency,\n        bytes32 id\n    );\n\n    event WithdrawExecuted(\n        address owner,\n        address token,\n        address from,\n        address to,\n        uint216 amountPerSec,\n        uint40 starts,\n        uint40 frequency,\n        bytes32 id\n    );\n\n    mapping(address => uint256) public balances;\n    mapping(bytes32 => address) public owners;\n    mapping(address => address) public redirects;\n\n    constructor(\n        address _factory,\n        address _bot,\n        address _llama\n    ) {\n        factory = _factory;\n        bot = _bot;\n        llama = _llama;\n    }\n\n    function deposit() external payable {\n        require(msg.sender != bot, \"bot cannot deposit\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function refund() external {\n        uint256 toSend = balances[msg.sender];\n        balances[msg.sender] = 0;\n        (bool sent, ) = msg.sender.call{value: toSend}(\"\");\n        require(sent, \"failed to send ether\");\n    }\n\n    function scheduleWithdraw(\n        address _token,\n        address _from,\n        address _to,\n        uint216 _amountPerSec,\n        uint40 _starts,\n        uint40 _frequency\n    ) external returns (bytes32 id) {\n        id = calcWithdrawId(\n            _token,\n            _from,\n            _to,\n            _amountPerSec,\n            _starts,\n            _frequency\n        );\n        require(owners[id] == address(0), \"already exists\");\n        owners[id] = msg.sender;\n        emit WithdrawScheduled(\n            msg.sender,\n            _token,\n            _from,\n            _to,\n            _amountPerSec,\n            _starts,\n            _frequency,\n            id\n        );\n    }\n\n    function cancelWithdraw(\n        address _token,\n        address _from,\n        address _to,\n        uint216 _amountPerSec,\n        uint40 _starts,\n        uint40 _frequency\n    ) external returns (bytes32 id) {\n        id = calcWithdrawId(\n            _token,\n            _from,\n            _to,\n            _amountPerSec,\n            _starts,\n            _frequency\n        );\n        require(msg.sender == owners[id], \"not owner\");\n        owners[id] = address(0);\n        emit WithdrawCancelled(\n            msg.sender,\n            _token,\n            _from,\n            _to,\n            _amountPerSec,\n            _starts,\n            _frequency,\n            id\n        );\n    }\n\n    function setRedirect(address _to) external {\n        redirects[msg.sender] = _to;\n    }\n\n    function cancelRedirect() external {\n        redirects[msg.sender] = address(0);\n    }\n\n    function executeWithdraw(\n        address _owner,\n        address _token,\n        address _from,\n        address _to,\n        uint216 _amountPerSec,\n        uint40 _starts,\n        uint40 _frequency,\n        bytes32 _id,\n        bool _execute,\n        bool _emitEvent\n    ) external {\n        require(msg.sender == bot, \"not bot\");\n        if (_execute) {\n            (address llamapay, bool isDeployed) = LlamaPayFactory(factory)\n                .getLlamaPayContractByToken(_token);\n            require(isDeployed, \"invalid llamapay contract\");\n            if (redirects[_to] != address(0)) {\n                (uint256 withdrawableAmount, , ) = LlamaPay(llamapay)\n                    .withdrawable(_from, _to, _amountPerSec);\n                LlamaPay(llamapay).withdraw(_from, _to, _amountPerSec);\n                ERC20(_token).safeTransferFrom(\n                    _to,\n                    redirects[_to],\n                    withdrawableAmount\n                );\n            } else {\n                LlamaPay(llamapay).withdraw(_from, _to, _amountPerSec);\n            }\n        }\n        if (_emitEvent) {\n            emit WithdrawExecuted(\n                _owner,\n                _token,\n                _from,\n                _to,\n                _amountPerSec,\n                _starts,\n                _frequency,\n                _id\n            );\n        }\n    }\n\n    function execute(bytes[] calldata _calls, address _from) external {\n        require(msg.sender == bot, \"not bot\");\n        uint256 i;\n        uint256 len = _calls.length;\n        uint256 startGas = gasleft();\n        for (i = 0; i < len; ++i) {\n            address(this).delegatecall(_calls[i]);\n        }\n        uint256 gasUsed = ((startGas - gasleft()) + 21000) + fee;\n        uint256 totalSpent = gasUsed * tx.gasprice;\n        balances[_from] -= totalSpent;\n        (bool sent, ) = bot.call{value: totalSpent}(\"\");\n        require(sent, \"failed to send ether to bot\");\n    }\n\n    function batchExecute(bytes[] calldata _calls) external {\n        require(msg.sender == bot, \"not bot\");\n        uint256 i;\n        uint256 len = _calls.length;\n        for (i = 0; i < len; ++i) {\n            address(this).delegatecall(_calls[i]);\n        }\n    }\n\n    function changeBot(address _newBot) external {\n        require(msg.sender == llama, \"not llama\");\n        bot = _newBot;\n    }\n\n    function changeLlama(address _newLlama) external {\n        require(msg.sender == llama, \"not llama\");\n        newLlama = _newLlama;\n    }\n\n    function confirmNewLlama() external {\n        require(msg.sender == newLlama, \"not new llama\");\n        llama = newLlama;\n    }\n\n    function changeFee(uint256 _newFee) external {\n        require(msg.sender == llama, \"not llama\");\n        fee = _newFee;\n    }\n\n    function calcWithdrawId(\n        address _token,\n        address _from,\n        address _to,\n        uint216 _amountPerSec,\n        uint40 _starts,\n        uint40 _frequency\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _token,\n                    _from,\n                    _to,\n                    _amountPerSec,\n                    _starts,\n                    _frequency\n                )\n            );\n    }\n}\n"
6     },
7     "lib/solmate/src/tokens/ERC20.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
9     },
10     "lib/solmate/src/utils/SafeTransferLib.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
12     }
13   },
14   "settings": {
15     "remappings": [
16       "ds-test/=lib/solmate/lib/ds-test/src/",
17       "forge-std/=lib/forge-std/src/",
18       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
19       "solmate/=lib/solmate/src/"
20     ],
21     "optimizer": {
22       "enabled": true,
23       "runs": 200
24     },
25     "metadata": {
26       "bytecodeHash": "ipfs"
27     },
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     },
40     "evmVersion": "london",
41     "libraries": {}
42   }
43 }}