1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/KillaLabs.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"./StaticNFT.sol\";\n\n/* ------------\n    Interfaces\n   ------------ */\n\ninterface IRewarder {\n    function reward(\n        address recipient,\n        uint256[] calldata bears,\n        uint256[] calldata rewardIds,\n        bytes calldata signature\n    ) external;\n\n    function reward(\n        address recipient,\n        uint256[] calldata bears,\n        uint256[] calldata rewardIds\n    ) external;\n}\n\ninterface IKillaBits is IERC721 {\n    function tokenUpgrade(uint256 token) external view returns (uint64);\n}\n\n/* ---------\n    Structs\n   --------- */\n\nstruct Stake {\n    uint32 ts;\n    address owner;\n    uint16 bit;\n}\n\n/* ------\n    Main\n   ------ */\n\ncontract KillaLabs is Ownable, StaticNFT {\n    using Strings for uint16;\n    using Strings for uint256;\n\n    /* --------\n        Errors\n       -------- */\n    error NotYourToken();\n    error NotCompleted();\n    error CanNoLongerEscape();\n    error ArrayLengthMismatch();\n    error StakingNotEnabled();\n    error BearAlreadyClaimedReward();\n    error BitAlreadyClaimedReward();\n\n    /* --------\n        Events\n       -------- */\n    event EnteredLab(uint256[] bears, uint256[] bits);\n    event ExitedLab(uint256[] bears);\n    event EscapedLab(uint256[] bears);\n\n    /* --------\n        Config\n       -------- */\n    uint256 public immutable stakeTime;\n    IERC721 public immutable killaBearsContract;\n    IKillaBits public immutable killaBitsContract;\n    IRewarder public rewardsContract;\n    bool public stakingEnabled;\n    mapping(address => bool) public stakingEnabledFor;\n\n    /* --------\n        Stakes\n       -------- */\n    mapping(uint256 => Stake) public stakes;\n    mapping(address => uint256) public balances;\n    mapping(uint256 => bool) public bearsClaimed;\n    mapping(uint256 => bool) public bitsClaimed;\n\n    constructor(\n        address killaBearsAddress,\n        address killaBitsAddress,\n        uint256 _stakeTime\n    ) StaticNFT(\"KillaLabs\", \"KillaLabs\") {\n        stakeTime = _stakeTime;\n        killaBearsContract = IERC721(killaBearsAddress);\n        killaBitsContract = IKillaBits(killaBitsAddress);\n    }\n\n    /* ---------\n        Staking\n       --------- */\n\n    /// @notice Stake pairs of KILLABEARS and KILLABITS\n    function enter(uint256[] calldata bears, uint256[] calldata bits) external {\n        if (!stakingEnabled && !stakingEnabledFor[msg.sender])\n            revert StakingNotEnabled();\n\n        uint256 index = bears.length;\n        if (index != bits.length) revert ArrayLengthMismatch();\n\n        uint256 ts = block.timestamp;\n\n        balances[msg.sender] += index;\n\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            uint256 bit = bits[index];\n\n            if (bearsClaimed[bear]) revert BearAlreadyClaimedReward();\n            if (bitsClaimed[bit]) revert BitAlreadyClaimedReward();\n\n            killaBearsContract.transferFrom(msg.sender, address(this), bear);\n            killaBitsContract.transferFrom(msg.sender, address(this), bit);\n\n            stakes[bear] = Stake(uint32(ts), msg.sender, uint16(bit));\n\n            emit Transfer(address(0), msg.sender, bear);\n        }\n\n        emit EnteredLab(bears, bits);\n    }\n\n    /// @notice Unstake and claim rewards\n    function exit(\n        uint256[] calldata bears,\n        uint256[] calldata rewards,\n        bytes calldata signature\n    ) external {\n        uint256 index = bears.length;\n        balances[msg.sender] -= index;\n\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            Stake storage stake = stakes[bear];\n            address owner = stake.owner;\n            uint256 bit = stake.bit;\n\n            if (owner != msg.sender) revert NotYourToken();\n            if (block.timestamp - stake.ts < stakeTime) revert NotCompleted();\n\n            bearsClaimed[bear] = true;\n            bitsClaimed[bit] = true;\n            killaBearsContract.transferFrom(address(this), owner, bear);\n            killaBitsContract.transferFrom(address(this), owner, bit);\n\n            delete stakes[bear];\n            emit Transfer(msg.sender, address(0), bear);\n        }\n\n        rewardsContract.reward(msg.sender, bears, rewards, signature);\n\n        emit ExitedLab(bears);\n    }\n\n    /// @notice Failsafe unstake without claiming after the staking period, but still mark as claimed\n    function escapeAndMarkAsClaimed(uint256[] calldata bears) external {\n        uint256 index = bears.length;\n        balances[msg.sender] -= index;\n\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            Stake storage stake = stakes[bear];\n            address owner = stake.owner;\n            uint256 bit = stake.bit;\n\n            if (owner != msg.sender) revert NotYourToken();\n            if (block.timestamp - stake.ts < stakeTime) revert NotCompleted();\n\n            bearsClaimed[bear] = true;\n            bitsClaimed[bit] = true;\n            killaBearsContract.transferFrom(address(this), owner, bear);\n            killaBitsContract.transferFrom(address(this), owner, bit);\n\n            delete stakes[bear];\n            emit Transfer(msg.sender, address(0), bear);\n        }\n\n        emit ExitedLab(bears);\n    }\n\n    /// @notice Unstake prematurely\n    function escape(uint256[] calldata bears) external {\n        uint256 index = bears.length;\n        balances[msg.sender] -= index;\n\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            Stake storage stake = stakes[bear];\n            address owner = stake.owner;\n            uint256 bit = stake.bit;\n\n            if (owner != msg.sender) revert NotYourToken();\n            if (block.timestamp - stake.ts >= stakeTime)\n                revert CanNoLongerEscape();\n\n            killaBearsContract.transferFrom(address(this), owner, bear);\n            killaBitsContract.transferFrom(address(this), owner, bit);\n\n            delete stakes[bear];\n\n            emit Transfer(msg.sender, address(0), bear);\n        }\n        emit EscapedLab(bears);\n    }\n\n    /* -------\n        Token\n       ------- */\n\n    /// @dev used by StaticNFT base contract\n    function getBalance(address _addr)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        return balances[_addr];\n    }\n\n    /// @dev used by StaticNFT base contract\n    function getOwner(uint256 tokenId)\n        internal\n        view\n        override\n        returns (address)\n    {\n        return stakes[tokenId].owner;\n    }\n\n    /* -------\n        Admin\n       ------- */\n\n    /// @notice Unstake and claim rewards for holder\n    function adminExit(\n        address holder,\n        uint256[] calldata bears,\n        uint256[] calldata rewards\n    ) external onlyOwner {\n        uint256 index = bears.length;\n        balances[holder] -= index;\n\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            Stake storage stake = stakes[bear];\n            address owner = stake.owner;\n            uint256 bit = stake.bit;\n\n            if (owner != holder) revert NotYourToken();\n            if (block.timestamp - stake.ts < stakeTime) revert NotCompleted();\n\n            bearsClaimed[bear] = true;\n            bitsClaimed[bit] = true;\n            killaBearsContract.transferFrom(address(this), owner, bear);\n            killaBitsContract.transferFrom(address(this), owner, bit);\n\n            delete stakes[bear];\n            emit Transfer(holder, address(0), bear);\n        }\n\n        rewardsContract.reward(holder, bears, rewards);\n\n        emit ExitedLab(bears);\n    }\n\n    /// @notice Unstake prematurely for holder\n    function adminEscape(uint256[] calldata bears) external onlyOwner {\n        uint256 index = bears.length;\n        while (index > 0) {\n            index--;\n\n            uint256 bear = bears[index];\n            Stake storage stake = stakes[bear];\n            address owner = stake.owner;\n            uint256 bit = stake.bit;\n\n            if (block.timestamp - stake.ts >= stakeTime)\n                revert CanNoLongerEscape();\n\n            killaBearsContract.transferFrom(address(this), owner, bear);\n            killaBitsContract.transferFrom(address(this), owner, bit);\n\n            delete stakes[bear];\n\n            balances[owner]--;\n\n            emit Transfer(owner, address(0), bear);\n        }\n        emit EscapedLab(bears);\n    }\n\n    /// @notice Set the rewarder contract\n    function setRewarder(address addr) external onlyOwner {\n        rewardsContract = IRewarder(addr);\n    }\n\n    /// @notice Enable/disable staking\n    function toggleStaking(bool enabled) external onlyOwner {\n        stakingEnabled = enabled;\n    }\n\n    /// @notice Enable/disable staking for a given wallet\n    function toggleStakingFor(address who, bool enabled) external onlyOwner {\n        stakingEnabledFor[who] = enabled;\n    }\n\n    /// @notice Set the base URI\n    function setBaseURI(string calldata uri) external onlyOwner {\n        baseURI = uri;\n    }\n\n    /* -------\n        Other\n       ------- */\n\n    /// @dev URI is different based on which bear and bit are staked, how long they've been staked, and the equipped gear\n    function tokenURI(uint256 tokenId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        if (getOwner(tokenId) == address(0)) {\n            if (bearsClaimed[tokenId]) {\n                return\n                    string(\n                        abi.encodePacked(\n                            baseURI,\n                            \"claimed/\",\n                            tokenId.toString()\n                        )\n                    );\n            } else {\n                return\n                    string(\n                        abi.encodePacked(\n                            baseURI,\n                            \"escaped/\",\n                            tokenId.toString()\n                        )\n                    );\n            }\n        }\n\n        Stake storage stake = stakes[tokenId];\n\n        uint256 day = (block.timestamp - stake.ts) / 86400 + 1;\n        uint256 upgrade = IKillaBits(killaBitsContract).tokenUpgrade(stake.bit);\n\n        return\n            bytes(baseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        baseURI,\n                        tokenId.toString(),\n                        \"/\",\n                        stake.bit.toString(),\n                        \"/\",\n                        day.toString(),\n                        \"/\",\n                        upgrade.toString()\n                    )\n                )\n                : \"\";\n    }\n}\n"
6     },
7     "contracts/StaticNFT.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nabstract contract StaticNFT is IERC721 {\n    using Strings for uint256;\n\n    string public name;\n    string public symbol;\n    string public baseURI;\n\n    error TransferNotAllowed();\n    error InvalidOwner();\n    error NonExistentToken();\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function getBalance(address) internal view virtual returns (uint256);\n\n    function getOwner(uint256) internal view virtual returns (address);\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        if (owner == address(0)) revert InvalidOwner();\n        return getBalance(owner);\n    }\n\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        address owner = getOwner(tokenId);\n        if (owner == address(0)) revert NonExistentToken();\n        return owner;\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure override {\n        revert TransferNotAllowed();\n    }\n\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) external pure override {\n        revert TransferNotAllowed();\n    }\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external pure override {\n        revert TransferNotAllowed();\n    }\n\n    function approve(address, uint256) external pure override {\n        revert TransferNotAllowed();\n    }\n\n    function setApprovalForAll(address, bool) external pure override {\n        revert TransferNotAllowed();\n    }\n\n    function getApproved(uint256) external pure override returns (address) {\n        return address(0);\n    }\n\n    function isApprovedForAll(address, address)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return false;\n    }\n\n    function tokenURI(uint256 tokenId)\n        external\n        view\n        virtual\n        returns (string memory)\n    {\n        if (getOwner(tokenId) == address(0)) revert NonExistentToken();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata;\n    }\n}\n"
9     },
10     "@openzeppelin/contracts/access/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
15     },
16     "@openzeppelin/contracts/utils/Strings.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
21     },
22     "@openzeppelin/contracts/utils/Context.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
24     }
25   },
26   "settings": {
27     "optimizer": {
28       "enabled": true,
29       "runs": 200
30     },
31     "outputSelection": {
32       "*": {
33         "*": [
34           "evm.bytecode",
35           "evm.deployedBytecode",
36           "devdoc",
37           "userdoc",
38           "metadata",
39           "abi"
40         ]
41       }
42     },
43     "libraries": {}
44   }
45 }}