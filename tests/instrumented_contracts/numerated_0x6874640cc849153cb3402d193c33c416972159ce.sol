1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/Wormhole.sol": {
5       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport './Migratable.sol';\r\n\r\ncontract Wormhole is Migratable {\r\n\r\n    event Freeze (\r\n        address indexed account,\r\n        uint256 amount,\r\n        uint256 fromChainId,\r\n        address fromWormhole,\r\n        uint256 toChainId,\r\n        address toWormhole,\r\n        uint256 nonce,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event Claim (\r\n        address indexed account,\r\n        uint256 amount,\r\n        uint256 fromChainId,\r\n        address fromWormhole,\r\n        uint256 toChainId,\r\n        address toWormhole,\r\n        uint256 nonce,\r\n        uint256 timestamp\r\n    );\r\n\r\n    string public constant name = 'Wormhole';\r\n\r\n    address public tokenAddress;\r\n\r\n    bool public allowMintBurn;\r\n\r\n    uint256 public nonce;\r\n\r\n    uint256 public chainId;\r\n\r\n    mapping (bytes32 => bool) public usedHash;\r\n\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\r\n\r\n    bytes32 public constant CLAIM_TYPEHASH = keccak256(\r\n        'Claim(address account,uint256 amount,uint256 fromChainId,address fromWormhole,uint256 toChainId,address toWormhole,uint256 nonce)'\r\n    );\r\n\r\n    constructor (address tokenAddress_, bool allowMintBurn_) {\r\n        controller = msg.sender;\r\n        tokenAddress = tokenAddress_;\r\n        allowMintBurn = allowMintBurn_;\r\n        uint256 _chainId;\r\n        assembly {\r\n            _chainId := chainid()\r\n        }\r\n        chainId = _chainId;\r\n    }\r\n\r\n    function approveMigration() public override _controller_ _valid_ {\r\n        require(migrationTimestamp != 0 && block.timestamp >= migrationTimestamp, 'Wormhole.approveMigration: migrationTimestamp not met yet');\r\n        if (allowMintBurn) {\r\n            IERC20(tokenAddress).setController(migrationDestination);\r\n        } else {\r\n            IERC20(tokenAddress).approve(migrationDestination, type(uint256).max);\r\n        }\r\n        isMigrated = true;\r\n\r\n        emit ApproveMigration(migrationTimestamp, address(this), migrationDestination);\r\n    }\r\n\r\n    function executeMigration(address source) public override _controller_ _valid_ {\r\n        uint256 _migrationTimestamp = IWormhole(source).migrationTimestamp();\r\n        address _migrationDestination = IWormhole(source).migrationDestination();\r\n        require(_migrationTimestamp != 0 && block.timestamp >= _migrationTimestamp, 'Wormhole.executeMigration: migrationTimestamp not met yet');\r\n        require(_migrationDestination == address(this), 'Wormhole.executeMigration: not destination address');\r\n\r\n        if (!IWormhole(source).allowMintBurn()) {\r\n            IERC20(tokenAddress).transferFrom(source, address(this), IERC20(tokenAddress).balanceOf(source));\r\n        }\r\n\r\n        emit ExecuteMigration(_migrationTimestamp, source, address(this));\r\n    }\r\n\r\n    function freeze(uint256 amount, uint256 toChainId, address toWormhole) public _valid_ {\r\n        require(amount > 0, 'Wormhole.freeze: 0 amount');\r\n        require(toChainId != chainId, 'Wormhole.freeze: to the same chain');\r\n        if (allowMintBurn) {\r\n            IERC20(tokenAddress).burn(msg.sender, amount);\r\n        } else {\r\n            IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\r\n        }\r\n        emit Freeze(msg.sender, amount, chainId, address(this), toChainId, toWormhole, nonce++, block.timestamp);\r\n    }\r\n\r\n    function claim(uint256 amount, uint256 fromChainId, address fromWormhole, uint256 fromNonce, uint8 v, bytes32 r, bytes32 s) public _valid_ {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), chainId, address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(CLAIM_TYPEHASH, msg.sender, amount, fromChainId, fromWormhole, chainId, address(this), fromNonce));\r\n        require(!usedHash[structHash], 'Wormhole.claim: replay');\r\n        usedHash[structHash] = true;\r\n\r\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory == controller, 'Wormhole.claim: unauthorized');\r\n\r\n        if (allowMintBurn) {\r\n            IERC20(tokenAddress).mint(msg.sender, amount);\r\n        } else {\r\n            IERC20(tokenAddress).transfer(msg.sender, amount);\r\n        }\r\n\r\n        emit Claim(msg.sender, amount, fromChainId, fromWormhole, chainId, address(this), fromNonce, block.timestamp);\r\n    }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n    function setController(address newController) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address account, uint256 amount) external returns (bool);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function mint(address account, uint256 amount) external;\r\n    function burn(address account, uint256 amount) external;\r\n}\r\n\r\ninterface IWormhole {\r\n    function migrationTimestamp() external view returns (uint256);\r\n    function migrationDestination() external view returns (address);\r\n    function allowMintBurn() external view returns (bool);\r\n}\r\n"
6     },
7     "contracts/Migratable.sol": {
8       "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nabstract contract Migratable {\r\n\r\n    event PrepareMigration(uint256 migrationTimestamp, address source, address destination);\r\n\r\n    event ApproveMigration(uint256 migrationTimestamp, address source, address destination);\r\n\r\n    event ExecuteMigration(uint256 migrationTimestamp, address source, address destination);\r\n\r\n    address public controller;\r\n\r\n    uint256 public migrationTimestamp;\r\n\r\n    address public migrationDestination;\r\n\r\n    bool public isMigrated;\r\n\r\n    modifier _controller_() {\r\n        require(msg.sender == controller, 'Migratable._controller_: can only called by controller');\r\n        _;\r\n    }\r\n\r\n    modifier _valid_() {\r\n        require(!isMigrated, 'Migratable._valid_: cannot proceed, this contract has been migrated');\r\n        _;\r\n    }\r\n\r\n    function setController(address newController) public _controller_ _valid_ {\r\n        require(newController != address(0), 'Migratable.setController: to 0 address');\r\n        controller = newController;\r\n    }\r\n\r\n    function prepareMigration(address destination, uint256 graceDays) public _controller_ _valid_ {\r\n        require(destination != address(0), 'Migratable.prepareMigration: to 0 address');\r\n        require(graceDays >= 3 && graceDays <= 365, 'Migratable.prepareMigration: graceDays must be 3-365 days');\r\n\r\n        migrationTimestamp = block.timestamp + graceDays * 1 days;\r\n        migrationDestination = destination;\r\n\r\n        emit PrepareMigration(migrationTimestamp, address(this), migrationDestination);\r\n    }\r\n\r\n    function approveMigration() public virtual;\r\n\r\n    function executeMigration(address source) public virtual;\r\n\r\n}\r\n"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": true,
14       "runs": 200
15     },
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "abi"
22         ]
23       }
24     },
25     "libraries": {}
26   }
27 }}