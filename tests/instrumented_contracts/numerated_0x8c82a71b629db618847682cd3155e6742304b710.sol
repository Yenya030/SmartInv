1 {{
2   "language": "Solidity",
3   "sources": {
4     "./contracts/FeeCollector.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IFeeCollector } from \"./interfaces/IFeeCollector.sol\";\nimport { LibAddress } from \"./lib/LibAddress.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract FeeCollector is IFeeCollector {\n    using LibAddress for address payable;\n\n    address payable public guildFeeCollector;\n    uint96 public guildSharex100;\n\n    address payable public poapFeeCollector;\n    uint96 public poapSharex100;\n\n    Vault[] internal vaults;\n\n    /// @param guildFeeCollector_ The address that will receive Guild's share from the funds.\n    /// @param guildSharex100_ The percentage of Guild's share multiplied by 100 (e.g 500 for a 5% cut).\n    /// @param poapFeeCollector_ The address that will receive POAP's share from the funds.\n    /// @param poapSharex100_ The percentage of POAP's share multiplied by 100 (e.g 500 for a 5% cut).\n    constructor(\n        address payable guildFeeCollector_,\n        uint96 guildSharex100_,\n        address payable poapFeeCollector_,\n        uint96 poapSharex100_\n    ) {\n        guildFeeCollector = guildFeeCollector_;\n        guildSharex100 = guildSharex100_;\n        poapFeeCollector = poapFeeCollector_;\n        poapSharex100 = poapSharex100_;\n    }\n\n    function registerVault(\n        uint256 eventId,\n        address owner,\n        address token,\n        uint128 fee\n    ) external {\n        Vault storage vault = vaults.push();\n        vault.eventId = eventId;\n        vault.owner = owner;\n        vault.token = token;\n        vault.fee = fee;\n\n        emit VaultRegistered(vaults.length - 1, eventId, owner, token, fee);\n    }\n\n    function payFee(uint256 vaultId) external payable {\n        if (vaultId >= vaults.length) revert VaultDoesNotExist(vaultId);\n\n        Vault storage vault = vaults[vaultId];\n        uint256 requiredAmount = vault.fee;\n        vault.collected += uint128(requiredAmount);\n        vault.paid[msg.sender] = true;\n\n        // If the tokenAddress is zero, the payment should be in Ether, otherwise in ERC20.\n        address tokenAddress = vault.token;\n        if (tokenAddress == address(0)) {\n            if (msg.value != requiredAmount) revert IncorrectFee(vaultId, msg.value, requiredAmount);\n        } else {\n            if (msg.value != 0) revert IncorrectFee(vaultId, msg.value, 0);\n            if (!IERC20(vault.token).transferFrom(msg.sender, address(this), requiredAmount))\n                revert TransferFailed(msg.sender, address(this));\n        }\n\n        emit FeeReceived(vaultId, msg.sender, requiredAmount);\n    }\n\n    function withdraw(uint256 vaultId) external {\n        if (vaultId >= vaults.length) revert VaultDoesNotExist(vaultId);\n\n        Vault storage vault = vaults[vaultId];\n        uint256 collected = vault.collected;\n        vault.collected = 0;\n\n        // Calculate fees to receive. Guild's and Poap's part is truncated - the remainder goes to the owner (max 2 wei).\n        uint256 guildAmount = (collected * guildSharex100) / 10000;\n        uint256 poapAmount = (collected * poapSharex100) / 10000;\n        uint256 ownerAmount = collected - poapAmount - guildAmount;\n\n        // If the tokenAddress is zero, the collected fees are in Ether, otherwise in ERC20.\n        address tokenAddress = vault.token;\n        if (tokenAddress == address(0)) _withdrawEther(guildAmount, poapAmount, ownerAmount, vault.owner);\n        else _withdrawToken(guildAmount, poapAmount, ownerAmount, vault.owner, tokenAddress);\n\n        emit Withdrawn(vaultId, guildAmount, poapAmount, ownerAmount);\n    }\n\n    function setGuildFeeCollector(address payable newFeeCollector) external {\n        if (msg.sender != guildFeeCollector) revert AccessDenied(msg.sender, guildFeeCollector);\n        guildFeeCollector = newFeeCollector;\n        emit GuildFeeCollectorChanged(newFeeCollector);\n    }\n\n    function setGuildSharex100(uint96 newShare) external {\n        if (msg.sender != guildFeeCollector) revert AccessDenied(msg.sender, guildFeeCollector);\n        guildSharex100 = newShare;\n        emit GuildSharex100Changed(newShare);\n    }\n\n    function setPoapFeeCollector(address payable newFeeCollector) external {\n        if (msg.sender != poapFeeCollector) revert AccessDenied(msg.sender, poapFeeCollector);\n        poapFeeCollector = newFeeCollector;\n        emit PoapFeeCollectorChanged(newFeeCollector);\n    }\n\n    function setPoapSharex100(uint96 newShare) external {\n        if (msg.sender != poapFeeCollector) revert AccessDenied(msg.sender, poapFeeCollector);\n        poapSharex100 = newShare;\n        emit PoapSharex100Changed(newShare);\n    }\n\n    function getVault(uint256 vaultId)\n        external\n        view\n        returns (\n            uint256 eventId,\n            address owner,\n            address token,\n            uint128 fee,\n            uint128 collected\n        )\n    {\n        if (vaultId >= vaults.length) revert VaultDoesNotExist(vaultId);\n        Vault storage vault = vaults[vaultId];\n        return (vault.eventId, vault.owner, vault.token, vault.fee, vault.collected);\n    }\n\n    function hasPaid(uint256 vaultId, address account) external view returns (bool paid) {\n        if (vaultId >= vaults.length) revert VaultDoesNotExist(vaultId);\n        return vaults[vaultId].paid[account];\n    }\n\n    function _withdrawEther(\n        uint256 guildAmount,\n        uint256 poapAmount,\n        uint256 ownerAmount,\n        address eventOwner\n    ) internal {\n        guildFeeCollector.sendEther(guildAmount);\n        poapFeeCollector.sendEther(poapAmount);\n        payable(eventOwner).sendEther(ownerAmount);\n    }\n\n    function _withdrawToken(\n        uint256 guildAmount,\n        uint256 poapAmount,\n        uint256 ownerAmount,\n        address eventOwner,\n        address tokenAddress\n    ) internal {\n        IERC20 token = IERC20(tokenAddress);\n        if (!token.transfer(guildFeeCollector, guildAmount)) revert TransferFailed(address(this), guildFeeCollector);\n        if (!token.transfer(poapFeeCollector, poapAmount)) revert TransferFailed(address(this), poapFeeCollector);\n        if (!token.transfer(eventOwner, ownerAmount)) revert TransferFailed(address(this), eventOwner);\n    }\n}\n"
6     },
7     "./contracts/interfaces/IFeeCollector.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IFeeCollector {\n    struct Vault {\n        uint256 eventId;\n        address owner;\n        address token;\n        uint128 fee;\n        uint128 collected;\n        mapping(address => bool) paid;\n    }\n\n    /// @notice Registers a POAP drop and it's fee.\n    /// @param eventId The id of the POAP drop.\n    /// @param owner The address that receives the fees from the drop.\n    /// @param token The zero address for Ether, otherwise an ERC20 token.\n    /// @param fee The amount of fee to pay in wei.\n    function registerVault(\n        uint256 eventId,\n        address owner,\n        address token,\n        uint128 fee\n    ) external;\n\n    /// @notice Registers the paid fee, both in Ether or ERC20.\n    /// @param vaultId The id of the vault to pay to.\n    function payFee(uint256 vaultId) external payable;\n\n    /// @notice Sets the address that receives Guild's share from the funds.\n    /// @dev Callable only by the current Guild fee collector.\n    /// @param newFeeCollector The new address of guildFeeCollector.\n    function setGuildFeeCollector(address payable newFeeCollector) external;\n\n    /// @notice Sets Guild's share from the funds.\n    /// @dev Callable only by the Guild fee collector.\n    /// @param newShare The percentual value multiplied by 100.\n    function setGuildSharex100(uint96 newShare) external;\n\n    /// @notice Sets the address that receives POAP's share from the funds.\n    /// @dev Callable only by the current POAP fee collector.\n    /// @param newFeeCollector The new address of poapFeeCollector.\n    function setPoapFeeCollector(address payable newFeeCollector) external;\n\n    /// @notice Sets POAP's share from the funds.\n    /// @dev Callable only by the POAP fee collector.\n    /// @param newShare The percentual value multiplied by 100.\n    function setPoapSharex100(uint96 newShare) external;\n\n    /// @notice Distributes the funds from a vault to the fee collectors and the owner.\n    /// @param vaultId The id of the vault whose funds should be distributed.\n    function withdraw(uint256 vaultId) external;\n\n    /// @notice Returns a vault's details.\n    /// @param vaultId The id of the queried vault.\n    /// @return eventId The id of the POAP drop.\n    /// @return owner The owner of the vault who recieves the funds.\n    /// @return token The address of the token to receive funds in (the zero address in case of Ether).\n    /// @return fee The amount of required funds in wei.\n    /// @return collected The amount of already collected funds.\n    function getVault(uint256 vaultId)\n        external\n        view\n        returns (\n            uint256 eventId,\n            address owner,\n            address token,\n            uint128 fee,\n            uint128 collected\n        );\n\n    /// @notice Returns if an account has paid the fee to a vault.\n    /// @param vaultId The id of the queried vault.\n    /// @param account The address of the queried account.\n    function hasPaid(uint256 vaultId, address account) external view returns (bool paid);\n\n    /// @notice Returns the address that receives Guild's share from the funds.\n    function guildFeeCollector() external view returns (address payable);\n\n    /// @notice Returns the percentage of Guild's share multiplied by 100.\n    function guildSharex100() external view returns (uint96);\n\n    /// @notice Returns the address that receives POAP's share from the funds.\n    function poapFeeCollector() external view returns (address payable);\n\n    /// @notice Returns the percentage of POAP's share multiplied by 100.\n    function poapSharex100() external view returns (uint96);\n\n    /// @notice Event emitted when a call to {payFee} succeeds.\n    /// @param vaultId The id of the vault that received the payment.\n    /// @param account The address of the account that paid.\n    /// @param amount The amount of fee received in wei.\n    event FeeReceived(uint256 indexed vaultId, address indexed account, uint256 amount);\n\n    /// @notice Event emitted when the Guild fee collector address is changed.\n    /// @param newFeeCollector The address to change guildFeeCollector to.\n    event GuildFeeCollectorChanged(address newFeeCollector);\n\n    /// @notice Event emitted when the share of the Guild fee collector changes.\n    /// @param newShare The new value of guildSharex100.\n    event GuildSharex100Changed(uint96 newShare);\n\n    /// @notice Event emitted when the POAP fee collector address is changed.\n    /// @param newFeeCollector The address to change poapFeeCollector to.\n    event PoapFeeCollectorChanged(address newFeeCollector);\n\n    /// @notice Event emitted when the share of the POAP fee collector changes.\n    /// @param newShare The new value of poapSharex100.\n    event PoapSharex100Changed(uint96 newShare);\n\n    /// @notice Event emitted when a new vault is registered.\n    /// @param eventId The id of the POAP drop.\n    /// @param owner The address that receives the fees from the drop.\n    /// @param token The zero address for Ether, otherwise an ERC20 token.\n    /// @param fee The amount of fee to pay in wei.\n    event VaultRegistered(\n        uint256 vaultId,\n        uint256 indexed eventId,\n        address indexed owner,\n        address indexed token,\n        uint256 fee\n    );\n\n    /// @notice Event emitted when funds are withdrawn by a vault owner.\n    /// @param vaultId The id of the vault.\n    /// @param guildAmount The amount received by the Guild fee collector in wei.\n    /// @param poapAmount The amount received by the POAP fee collector in wei.\n    /// @param ownerAmount The amount received by the vault's owner in wei.\n    event Withdrawn(uint256 indexed vaultId, uint256 guildAmount, uint256 poapAmount, uint256 ownerAmount);\n\n    /// @notice Error thrown when an incorrect amount of fee is attempted to be paid.\n    /// @dev requiredAmount might be 0 in cases when an ERC20 payment was expected but Ether was received, too.\n    /// @param vaultId The id of the vault.\n    /// @param paid The amount of funds received.\n    /// @param requiredAmount The amount of fees required by the vault.\n    error IncorrectFee(uint256 vaultId, uint256 paid, uint256 requiredAmount);\n\n    /// @notice Error thrown when a function is attempted to be called by the wrong address.\n    /// @param sender The address that sent the transaction.\n    /// @param owner The address that is allowed to call the function.\n    error AccessDenied(address sender, address owner);\n\n    /// @notice Error thrown when an ERC20 transfer failed.\n    /// @param from The sender of the token.\n    /// @param to The recipient of the token.\n    error TransferFailed(address from, address to);\n\n    /// @notice Error thrown when a vault does not exist.\n    /// @param vaultId The id of the requested vault.\n    error VaultDoesNotExist(uint256 vaultId);\n}\n"
9     },
10     "./contracts/lib/LibAddress.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for functions related to addresses.\nlibrary LibAddress {\n    /// @notice Error thrown when sending ether fails.\n    /// @param recipient The address that could not receive the ether.\n    error FailedToSendEther(address recipient);\n\n    /// @notice Send ether to an address, forwarding all available gas and reverting on errors.\n    /// @param recipient The recipient of the ether.\n    /// @param amount The amount of ether to send in wei.\n    function sendEther(address payable recipient, uint256 amount) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        if (!success) revert FailedToSendEther(recipient);\n    }\n}\n"
12     },
13     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
15     }
16   },
17   "settings": {
18     "metadata": {
19       "useLiteralContent": true
20     },
21     "optimizer": {
22       "enabled": true,
23       "runs": 200
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "abi"
31         ]
32       }
33     }
34   }
35 }}