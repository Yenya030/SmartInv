1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/WLMarketplace.sol": {
5       "content": "\n\n// SPDX-License-Identifier: MIT License\n\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n\ninterface iSabi {\n    function balanceOf(address address_) external view returns (uint); \n    function transferFrom(address from_, address to_, uint amount) external returns (bool);\n    function burnFrom(address account, uint amount) external;\n}\n\ncontract WLMarketplace is ReentrancyGuard {\n\n    address public owner;\n    address[] public players;\n    \n    uint256 public ticketPrice = 500000000000000000000; // 500ETH\n    uint public maxTicketsPerTx = 20;\n    mapping (address => uint256) public userEntries;\n\n    \n    /* NEW mapping */\n    struct SaleItem {\n        uint16 totalSlots;\n        uint16 boughtSlots;\n        bool isActive;\n        uint256 itemPrice;\n        address[] buyers;\n    }\n    mapping (uint => SaleItem) public idToSaleItem;\n    // mapping (address => uint) public lastBuyTime;\n    //\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    address public sabiAddress;\n    iSabi public Sabi;\n    function setSabi(address _address) external onlyOwner {\n        sabiAddress = _address;\n        Sabi = iSabi(_address);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    /*  ======================\n        |---Entry Function---|\n        ======================\n    */\n\n    function buyWL(uint _id) public nonReentrant {\n        // used to have payable word in function sig\n        require(idToSaleItem[_id].isActive == true, \"sale ended\");\n\n        require(Sabi.balanceOf(msg.sender) >= idToSaleItem[_id].itemPrice, \"insufficent $SABI\");\n        // require(lastBuyTime[msg.sender] + 1 hours < block.timestamp, \"last buy time is less than 72 hours\");\n        require(idToSaleItem[_id].boughtSlots < idToSaleItem[_id].totalSlots, \"slots filled for saleItem\");\n        for (uint i=0; i<idToSaleItem[_id].buyers.length; i++) {\n            require(idToSaleItem[_id].buyers[i] != msg.sender, \"already bought from item\");           \n        }\n        // lastBuyTime[msg.sender] = block.timestamp;\n        idToSaleItem[_id].boughtSlots++;\n        idToSaleItem[_id].buyers.push(msg.sender);\n        Sabi.burnFrom(msg.sender, idToSaleItem[_id].itemPrice);\n    }\n\n    function enterDraw(uint256 _numOfTickets) public nonReentrant {\n        // require(idToSaleItem[_id].isActive == true, \"sale ended\");\n        \n\n        uint256 totalTicketCost = ticketPrice * _numOfTickets;\n        require(Sabi.balanceOf(msg.sender) >= ticketPrice * _numOfTickets, \"insufficent $SABI\");\n        // require(drawLive == true, \"cannot enter at this time\");\n        require(_numOfTickets <= maxTicketsPerTx, \"too many per TX\");\n\n        uint256 ownerTicketsPurchased = userEntries[msg.sender];\n        require(ownerTicketsPurchased + _numOfTickets <= maxTicketsPerTx, \"only allowed 20 tickets\");\n        Sabi.burnFrom(msg.sender, totalTicketCost);\n\n        // player ticket purchasing loop\n        for (uint256 i = 1; i <= _numOfTickets; i++) {\n            players.push(msg.sender);\n            userEntries[msg.sender]++;\n        }\n        \n    }\n\n    /*  ======================\n        |---View Functions---|\n        ======================\n    */\n\n    //HELPERS\n    // function getLastBuyTimePlus72Hours(address _buyer) public view returns (uint) {\n    //     return lastBuyTime[_buyer] + 1 hours;\n    // }\n\n    function buyersOfSaleItem(uint16 _id) public view returns (address[] memory) {\n        return idToSaleItem[_id].buyers;\n    }\n\n    function buyersOfDraw() public view returns (address[] memory) {\n        return players;\n    }\n\n\n    /*  ============================\n        |---Owner Only Functions---|\n        ============================\n    */\n\n    \n\n    function createSaleItem(uint256 _newTicketPrice, uint16 _newId, uint16 _totalSlots) public onlyOwner {\n        // ticketPrice = _newTicketPrice;\n\n        idToSaleItem[_newId].totalSlots = _totalSlots;\n        idToSaleItem[_newId].boughtSlots = 0;\n        idToSaleItem[_newId].isActive = true;\n        idToSaleItem[_newId].itemPrice = _newTicketPrice * ticketPrice;\n        // idToSaleItem[_newId].buyers = address[]\n\n    }\n\n    function disableSaleItem(uint16 _newId) public onlyOwner {\n\n        idToSaleItem[_newId].isActive = false;\n\n    }\n\n\n\n    function setTicketPrice(uint256 _newTicketPrice) public onlyOwner {\n        ticketPrice = _newTicketPrice;\n    }\n\n    function transferOwnership(address _address) public onlyOwner {\n        owner = _address;\n    }\n\n    function withdraw() public payable onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n}"
6     },
7     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": true,
14       "runs": 2000,
15       "details": {
16         "yul": true,
17         "yulDetails": {
18           "stackAllocation": true,
19           "optimizerSteps": "dhfoDgvulfnTUtnIf"
20         }
21       }
22     },
23     "outputSelection": {
24       "*": {
25         "*": [
26           "evm.bytecode",
27           "evm.deployedBytecode",
28           "devdoc",
29           "userdoc",
30           "metadata",
31           "abi"
32         ]
33       }
34     },
35     "libraries": {}
36   }
37 }}