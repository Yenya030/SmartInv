1 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
2 // 口口口口口口口口口口口口口　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
3 // 口口口口口口口口口口口口　　　　　　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
4 // 口口口口口口口口口口口　　　　口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
5 // 口口口口口口口口口口　　　　口口口口口　　　　口口口口口口口口口口口口口口口口口口口口口口口口口　　　　口口口口口口口口口
6 // 口口口口口口口口口口　　　口口口口口口口　　　口口　　　　　　　口口口　　　　　　口口　　　　　　　　　口口口口口口口口口
7 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　口口　　　　　　口　　　　　　　　　　口口口口口口口口口
8 // 口口口口口口口口口　　　　口口口口口口口口口口　　　　口口口　　　口口　　　　口口口　　　口口　　　　　口口口口口口口口口
9 // 口口口口口口口口口　　　　口口口口口口口口口口口口口口口口口　　　口口　　　口口口　　　　口口口　　　　口口口口口口口口口
10 // 口口口口口口口口口　　　　口口口口口口口口口口口口　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
11 // 口口口口口口口口口　　　　口口口口口口口口口口口　　　　　　　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
12 // 口口口口口口口口口口　　　口口口口口口口　　　　　　　口口口　　　　口　　　口口口　　　口口口口　　　　口口口口口口口口口
13 // 口口口口口口口口口口　　　　口口口口口　　　　　　　口口口口　　　　口　　　口口口　　　　口口口　　　　口口口口口口口口口
14 // 口口口口口口口口口口口　　　　口口口　　　　口　　　　口口　　　　　口　　　口口口　　　　口口　　　　　口口口口口口口口口
15 // 口口口口口口口口口口口口　　　　　　　　　　口口　　　　　　　　　　口　　　口口口口　　　　　　　　　　口口口口口口口口口
16 // 口口口口口口口口口口口口口　　　　　　　口口口口口　　　　　　　　　口　　　口口口口口　　　　　　　　　口口口口口口口口口
17 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
18 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
19 // 口口口　　　　口口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
20 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
21 // 口口口　　　　　口口口口口　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
22 // 口口口　　　　　口口口口　　　　　　口口口口口口口口口口口口口　　　口口口口口口口口口口口口口口口口口口口口口口口口口口口
23 // 口口口　　　　　　口口口　　　　　　口口口　　　　　　　口口口　　　口口　　　　口口口　　　　　　口口口　　　　　　口口口
24 // 口口口　　　　　　口口口　　　　　　口口　　　　　　　　　口口　　　口　　　　口口　　　　　　　　　口口　　　　　　口口口
25 // 口口口　　　　　　口口　　　　　　　口　　　　口口口　　　口口　　　　　　　口口口　　　口口口　　　　口　　　　口口口口口
26 // 口口口　　　　　　　口　　　　　　　口口口口口口口口　　　口口　　　　　　口口口　　　　口口口口　　　口　　　口口口口口口
27 // 口口口　　　口　　　口　　　　　　　口口口　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
28 // 口口口　　　口　　　口　　　　　　　口口　　　　　　　　　　口　　　　　　口口口　　　　　　　　　　　口　　　口口口口口口
29 // 口口口　　　口　　　　　　口　　　　口　　　　口口口　　　　口　　　　　　　口口　　　口口口口口口口口口　　　口口口口口口
30 // 口口口　　　口口　　　　　口　　　　口　　　口口口口　　　　口　　　口　　　　口　　　　口口口口口口口口　　　口口口口口口
31 // 口口口　　　口口　　　　　口　　　　口　　　　口口　　　　　口　　　口口　　　口口　　　　口口　　　　口　　　口口口口口口
32 // 口口口　　　口口　　　　口口　　　　口口　　　　　　　　　　口　　　口口　　　　口　　　　　　　　　口口　　　口口口口口口
33 // 口口口　　　口口口　　　口口　　　　口口口　　　　　　　　　口　　　口口口　　　　口口　　　　　　口口口　　　口口口口口口
34 // 口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口口
35 
36 pragma solidity ^0.4.24;
37 
38 /**
39  * @title SafeMath
40  * @dev Math operations with safety checks that throw on error
41  */
42 library SafeMath {
43     /**
44     * @dev Multiplies two numbers, throws on overflow.
45     */
46     function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
47         if (a == 0) {
48             return 0;
49         }
50         c = a * b;
51         assert(c / a == b);
52         return c;
53     }
54 
55     /**
56     * @dev Integer division of two numbers, truncating the quotient.
57     */
58     function div(uint256 a, uint256 b) internal pure returns (uint256) {
59         return a / b;
60     }
61 
62     /**
63     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
64     */
65     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
66         assert(b <= a);
67         return a - b;
68     }
69 
70     /**
71     * @dev Adds two numbers, throws on overflow.
72     */
73     function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
74         c = a + b;
75         assert(c >= a);
76         return c;
77     }
78 }
79 
80 /**
81  * @title Ownable
82  * @dev The Ownable contract has an owner address, and provides basic authorization control
83  * functions, this simplifies the implementation of "user permissions".
84  */
85 contract Ownable {
86     address public owner;
87     address public newOwner;
88 
89     event OwnershipTransferred(address indexed _from, address indexed _to);
90 
91     constructor() public {
92         owner = msg.sender;
93     }
94 
95     modifier onlyOwner {
96         require(msg.sender == owner);
97         _;
98     }
99 
100     function transferOwnership(address _newOwner) public onlyOwner {
101         newOwner = _newOwner;
102     }
103 
104     function acceptOwnership() public {
105         require(msg.sender == newOwner);
106         emit OwnershipTransferred(owner, newOwner);
107         owner = newOwner;
108         newOwner = address(0);
109     }
110 }
111 
112 /**
113  * @title Pausable
114  * @dev Base contract which allows children to implement an emergency stop mechanism.
115  */
116 contract Pausable is Ownable {
117     event Pause();
118     event Unpause();
119 
120     bool public paused = false;
121 
122     /**
123      * @dev modifier to allow actions only when the contract IS paused
124      */
125     modifier whenNotPaused() {
126         require(!paused);
127         _;
128     }
129 
130     /**
131      * @dev modifier to allow actions only when the contract IS NOT paused
132      */
133     modifier whenPaused {
134         require(paused);
135         _;
136     }
137 
138     /**
139      * @dev called by the owner to pause, triggers stopped state
140      */
141     function pause() onlyOwner whenNotPaused public returns (bool) {
142         paused = true;
143         emit Pause();
144         return true;
145     }
146 
147     /**
148      * @dev called by the owner to unpause, returns to normal state
149      */
150     function unpause() onlyOwner whenPaused public returns (bool) {
151         paused = false;
152         emit Unpause();
153         return true;
154     }
155 }
156 
157 // ----------------------------------------------------------------------------
158 // ERC Token Standard #20 Interface
159 // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md
160 // ----------------------------------------------------------------------------
161 contract ERC20Interface {
162     function totalSupply() public constant returns (uint);
163     function balanceOf(address tokenOwner) public constant returns (uint);
164     function allowance(address tokenOwner, address spender) public constant returns (uint);
165     function transfer(address to, uint tokens) public returns (bool);
166     function approve(address spender, uint tokens) public returns (bool);
167     function transferFrom(address from, address to, uint tokens) public returns (bool);
168 
169     function name() public constant returns (string);
170     function symbol() public constant returns (string);
171     function decimals() public constant returns (uint8);
172 
173     event Transfer(address indexed from, address indexed to, uint tokens);
174     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
175 }
176 
177 /**
178 * ERC223 token by Dexaran
179 * New ERC223 contract interface
180 * https://github.com/Dexaran/ERC223-token-standard
181 */
182 contract ERC223 is ERC20Interface {
183     function transfer(address to, uint value, bytes data) public returns (bool);
184 
185     event Transfer(address indexed from, address indexed to, uint tokens);
186     event Transfer(address indexed from, address indexed to, uint value, bytes data);
187 }
188 
189 /**
190 * @title Contract that will work with ERC223 tokens.
191 */
192 contract ERC223ReceivingContract {
193     /**
194      * @dev Standard ERC223 function that will handle incoming token transfers.
195      * @param _from  Token sender address.
196      * @param _value Amount of tokens.
197      * @param _data  Transaction metadata.
198      */
199     function tokenFallback(address _from, uint _value, bytes _data) public;
200     function doTransfer(address _to, uint256 _index) public returns (uint256 price, address owner);
201 }
202 
203 contract CardMakerCake is ERC223, Pausable {
204 
205     using SafeMath for uint256;
206 
207     mapping(address => uint) balances;
208     mapping(address => mapping(address => uint)) internal allowed;
209 
210     string public name;
211     string public symbol;
212     uint8 public decimals;
213     uint256 public totalSupply;
214 
215     // EIP1046/1047
216     string private tokenURI_ = "";
217 
218     event Burn(address indexed burner, uint256 value);
219 
220     constructor() public {
221         tokenURI_ = "cardmaker.io";
222         name = "Card Alchemists' Knowledge Energy (CardMaker Token)";
223         symbol = "CAKE";
224         decimals = 18;
225         totalSupply = 10000 * 10000 * 100 * 10 ** uint(decimals);
226         balances[msg.sender] = totalSupply;
227     }
228 
229     function tokenURI() external view returns (string) {
230         return tokenURI_;
231     }
232 
233     // Function to access name of token .
234     function name() public constant returns (string) {
235         return name;
236     }
237     // Function to access symbol of token .
238     function symbol() public constant returns (string) {
239         return symbol;
240     }
241     // Function to access decimals of token .
242     function decimals() public constant returns (uint8) {
243         return decimals;
244     }
245     // Function to access total supply of tokens .
246     function totalSupply() public constant returns (uint256) {
247         return totalSupply;
248     }
249 
250     // Function that is called when a user or another contract wants to transfer funds .
251     function transfer(address _to, uint _value, bytes _data) public whenNotPaused returns (bool) {
252         if(isContract(_to)) {
253             return transferToContract(_to, _value, _data);
254         } else {
255             return transferToAddress(_to, _value, _data);
256         }
257     }
258 
259     // Standard function transfer similar to ERC20 transfer with no _data .
260     // Added due to backwards compatibility reasons .
261     function transfer(address _to, uint _value) public whenNotPaused returns (bool) {
262         bytes memory empty;
263         if(isContract(_to)) {
264             return transferToContract(_to, _value, empty);
265         } else {
266             return transferToAddress(_to, _value, empty);
267         }
268     }
269 
270     //assemble the given address bytecode. If bytecode exists then the _addr is a contract.
271     function isContract(address _addr) private view returns (bool) {
272         uint length;
273         assembly {
274         //retrieve the size of the code on target address, this needs assembly
275             length := extcodesize(_addr)
276         }
277         return (length>0);
278     }
279 
280     //function that is called when transaction target is an address
281     function transferToAddress(address _to, uint _value, bytes _data) private returns (bool) {
282         if (balanceOf(msg.sender) < _value) revert();
283         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
284         balances[_to] = balanceOf(_to).add(_value);
285         emit Transfer(msg.sender, _to, _value);
286         emit Transfer(msg.sender, _to, _value, _data);
287         return true;
288     }
289 
290     //function that is called when transaction target is a contract
291     function transferToContract(address _to, uint _value, bytes _data) private returns (bool) {
292 
293         ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
294         uint256 price;
295         address owner;
296         (price, owner) = receiver.doTransfer(msg.sender, bytesToUint(_data));
297 
298         if (balanceOf(msg.sender) < price) revert();
299         balances[msg.sender] = balanceOf(msg.sender).sub(price);
300         balances[owner] = balanceOf(owner).add(price);
301         receiver.tokenFallback(msg.sender, price, _data);
302         emit Transfer(msg.sender, _to, _value);
303         emit Transfer(msg.sender, _to, _value, _data);
304         return true;
305     }
306 
307     function balanceOf(address _owner) public constant returns (uint) {
308         return balances[_owner];
309     }
310 
311     function allowance(address _tokenOwner, address _spender) public constant returns (uint) {
312         return allowed[_tokenOwner][_spender];
313     }
314 
315     function burn(uint256 _value) public returns (bool) {
316         require (_value > 0);
317         // Check if the sender has enough
318         require (balanceOf(msg.sender) >= _value);
319         // Subtract from the sender
320         balances[msg.sender] = balanceOf(msg.sender).sub(_value);
321         // Updates totalSupply
322         totalSupply = totalSupply.sub(_value);
323         emit Burn(msg.sender, _value);
324         return true;
325     }
326 
327     function bytesToUint(bytes b) private pure returns (uint result) {
328         uint i;
329         result = 0;
330         for (i = 0; i < b.length; i++) {
331             uint c = uint(b[i]);
332             if (c >= 48 && c <= 57) {
333                 result = result * 10 + (c - 48);
334             }
335         }
336     }
337 
338     function approve(address _spender, uint _tokens) public whenNotPaused returns (bool) {
339         allowed[msg.sender][_spender] = _tokens;
340         emit Approval(msg.sender, _spender, _tokens);
341         return true;
342     }
343 
344     function transferFrom(address _from, address _to, uint _tokens) public whenNotPaused returns (bool) {
345         require(_to != address(0));
346         require(_tokens <= balances[_from]);
347         require(_tokens <= allowed[_from][msg.sender]);
348 
349         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_tokens);
350         balances[_from] = balances[_from].sub(_tokens);
351         balances[_to] = balances[_to].add(_tokens);
352         emit Transfer(_from, _to, _tokens);
353         return true;
354     }
355 
356     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {
357         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));
358         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
359         return true;
360     }
361 
362     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool){
363         uint256 oldValue = allowed[msg.sender][_spender];
364         if (_subtractedValue > oldValue) {
365             allowed[msg.sender][_spender] = 0;
366         } else {
367             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
368         }
369         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
370         return true;
371     }
372 
373     // ------------------------------------------------------------------------
374     // Don't accept ETH
375     // ------------------------------------------------------------------------
376     function () public payable {
377         revert();
378     }
379 
380     // ------------------------------------------------------------------------
381     // Owner can transfer out any accidentally sent ERC20 tokens
382     // ------------------------------------------------------------------------
383     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool) {
384         return ERC20Interface(tokenAddress).transfer(owner, tokens);
385     }
386 }