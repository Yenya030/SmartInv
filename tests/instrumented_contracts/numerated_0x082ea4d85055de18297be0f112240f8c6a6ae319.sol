1 pragma solidity ^0.5.2;
2 
3 // File: @daostack/infra/contracts/votingMachines/IntVoteInterface.sol
4 
5 interface IntVoteInterface {
6     //When implementing this interface please do not only override function and modifier,
7     //but also to keep the modifiers on the overridden functions.
8     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
9     modifier votable(bytes32 _proposalId) {revert(); _;}
10 
11     event NewProposal(
12         bytes32 indexed _proposalId,
13         address indexed _organization,
14         uint256 _numOfChoices,
15         address _proposer,
16         bytes32 _paramsHash
17     );
18 
19     event ExecuteProposal(bytes32 indexed _proposalId,
20         address indexed _organization,
21         uint256 _decision,
22         uint256 _totalReputation
23     );
24 
25     event VoteProposal(
26         bytes32 indexed _proposalId,
27         address indexed _organization,
28         address indexed _voter,
29         uint256 _vote,
30         uint256 _reputation
31     );
32 
33     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
34     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
35 
36     /**
37      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
38      * generated by calculating keccak256 of a incremented counter.
39      * @param _numOfChoices number of voting choices
40      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
41      * @param _proposer address
42      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
43      * @return proposal's id.
44      */
45     function propose(
46         uint256 _numOfChoices,
47         bytes32 _proposalParameters,
48         address _proposer,
49         address _organization
50         ) external returns(bytes32);
51 
52     function vote(
53         bytes32 _proposalId,
54         uint256 _vote,
55         uint256 _rep,
56         address _voter
57     )
58     external
59     returns(bool);
60 
61     function cancelVote(bytes32 _proposalId) external;
62 
63     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
64 
65     function isVotable(bytes32 _proposalId) external view returns(bool);
66 
67     /**
68      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
69      * @param _proposalId the ID of the proposal
70      * @param _choice the index in the
71      * @return voted reputation for the given choice
72      */
73     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
74 
75     /**
76      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
77      * @return bool true or false
78      */
79     function isAbstainAllow() external pure returns(bool);
80 
81     /**
82      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
83      * @return min - minimum number of choices
84                max - maximum number of choices
85      */
86     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
87 }
88 
89 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
90 
91 /**
92  * @title ERC20 interface
93  * @dev see https://github.com/ethereum/EIPs/issues/20
94  */
95 interface IERC20 {
96     function transfer(address to, uint256 value) external returns (bool);
97 
98     function approve(address spender, uint256 value) external returns (bool);
99 
100     function transferFrom(address from, address to, uint256 value) external returns (bool);
101 
102     function totalSupply() external view returns (uint256);
103 
104     function balanceOf(address who) external view returns (uint256);
105 
106     function allowance(address owner, address spender) external view returns (uint256);
107 
108     event Transfer(address indexed from, address indexed to, uint256 value);
109 
110     event Approval(address indexed owner, address indexed spender, uint256 value);
111 }
112 
113 // File: @daostack/infra/contracts/votingMachines/VotingMachineCallbacksInterface.sol
114 
115 interface VotingMachineCallbacksInterface {
116     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
117     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
118 
119     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
120     external
121     returns(bool);
122 
123     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
124     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
125     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
126 }
127 
128 // File: openzeppelin-solidity/contracts/ownership/Ownable.sol
129 
130 /**
131  * @title Ownable
132  * @dev The Ownable contract has an owner address, and provides basic authorization control
133  * functions, this simplifies the implementation of "user permissions".
134  */
135 contract Ownable {
136     address private _owner;
137 
138     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
139 
140     /**
141      * @dev The Ownable constructor sets the original `owner` of the contract to the sender
142      * account.
143      */
144     constructor () internal {
145         _owner = msg.sender;
146         emit OwnershipTransferred(address(0), _owner);
147     }
148 
149     /**
150      * @return the address of the owner.
151      */
152     function owner() public view returns (address) {
153         return _owner;
154     }
155 
156     /**
157      * @dev Throws if called by any account other than the owner.
158      */
159     modifier onlyOwner() {
160         require(isOwner());
161         _;
162     }
163 
164     /**
165      * @return true if `msg.sender` is the owner of the contract.
166      */
167     function isOwner() public view returns (bool) {
168         return msg.sender == _owner;
169     }
170 
171     /**
172      * @dev Allows the current owner to relinquish control of the contract.
173      * @notice Renouncing to ownership will leave the contract without an owner.
174      * It will not be possible to call the functions with the `onlyOwner`
175      * modifier anymore.
176      */
177     function renounceOwnership() public onlyOwner {
178         emit OwnershipTransferred(_owner, address(0));
179         _owner = address(0);
180     }
181 
182     /**
183      * @dev Allows the current owner to transfer control of the contract to a newOwner.
184      * @param newOwner The address to transfer ownership to.
185      */
186     function transferOwnership(address newOwner) public onlyOwner {
187         _transferOwnership(newOwner);
188     }
189 
190     /**
191      * @dev Transfers control of the contract to a newOwner.
192      * @param newOwner The address to transfer ownership to.
193      */
194     function _transferOwnership(address newOwner) internal {
195         require(newOwner != address(0));
196         emit OwnershipTransferred(_owner, newOwner);
197         _owner = newOwner;
198     }
199 }
200 
201 // File: @daostack/infra/contracts/Reputation.sol
202 
203 /**
204  * @title Reputation system
205  * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .
206  * A reputation is use to assign influence measure to a DAO'S peers.
207  * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.
208  * The Reputation contract maintain a map of address to reputation value.
209  * It provides an onlyOwner functions to mint and burn reputation _to (or _from) a specific address.
210  */
211 
212 contract Reputation is Ownable {
213 
214     uint8 public decimals = 18;             //Number of decimals of the smallest unit
215     // Event indicating minting of reputation to an address.
216     event Mint(address indexed _to, uint256 _amount);
217     // Event indicating burning of reputation for an address.
218     event Burn(address indexed _from, uint256 _amount);
219 
220       /// @dev `Checkpoint` is the structure that attaches a block number to a
221       ///  given value, the block number attached is the one that last changed the
222       ///  value
223     struct Checkpoint {
224 
225     // `fromBlock` is the block number that the value was generated from
226         uint128 fromBlock;
227 
228           // `value` is the amount of reputation at a specific block number
229         uint128 value;
230     }
231 
232       // `balances` is the map that tracks the balance of each address, in this
233       //  contract when the balance changes the block number that the change
234       //  occurred is also included in the map
235     mapping (address => Checkpoint[]) balances;
236 
237       // Tracks the history of the `totalSupply` of the reputation
238     Checkpoint[] totalSupplyHistory;
239 
240     /// @notice Constructor to create a Reputation
241     constructor(
242     ) public
243     {
244     }
245 
246     /// @dev This function makes it easy to get the total number of reputation
247     /// @return The total number of reputation
248     function totalSupply() public view returns (uint256) {
249         return totalSupplyAt(block.number);
250     }
251 
252   ////////////////
253   // Query balance and totalSupply in History
254   ////////////////
255     /**
256     * @dev return the reputation amount of a given owner
257     * @param _owner an address of the owner which we want to get his reputation
258     */
259     function balanceOf(address _owner) public view returns (uint256 balance) {
260         return balanceOfAt(_owner, block.number);
261     }
262 
263       /// @dev Queries the balance of `_owner` at a specific `_blockNumber`
264       /// @param _owner The address from which the balance will be retrieved
265       /// @param _blockNumber The block number when the balance is queried
266       /// @return The balance at `_blockNumber`
267     function balanceOfAt(address _owner, uint256 _blockNumber)
268     public view returns (uint256)
269     {
270         if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {
271             return 0;
272           // This will return the expected balance during normal situations
273         } else {
274             return getValueAt(balances[_owner], _blockNumber);
275         }
276     }
277 
278       /// @notice Total amount of reputation at a specific `_blockNumber`.
279       /// @param _blockNumber The block number when the totalSupply is queried
280       /// @return The total amount of reputation at `_blockNumber`
281     function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {
282         if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {
283             return 0;
284           // This will return the expected totalSupply during normal situations
285         } else {
286             return getValueAt(totalSupplyHistory, _blockNumber);
287         }
288     }
289 
290       /// @notice Generates `_amount` reputation that are assigned to `_owner`
291       /// @param _user The address that will be assigned the new reputation
292       /// @param _amount The quantity of reputation generated
293       /// @return True if the reputation are generated correctly
294     function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {
295         uint256 curTotalSupply = totalSupply();
296         require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow
297         uint256 previousBalanceTo = balanceOf(_user);
298         require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow
299         updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);
300         updateValueAtNow(balances[_user], previousBalanceTo + _amount);
301         emit Mint(_user, _amount);
302         return true;
303     }
304 
305       /// @notice Burns `_amount` reputation from `_owner`
306       /// @param _user The address that will lose the reputation
307       /// @param _amount The quantity of reputation to burn
308       /// @return True if the reputation are burned correctly
309     function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {
310         uint256 curTotalSupply = totalSupply();
311         uint256 amountBurned = _amount;
312         uint256 previousBalanceFrom = balanceOf(_user);
313         if (previousBalanceFrom < amountBurned) {
314             amountBurned = previousBalanceFrom;
315         }
316         updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);
317         updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);
318         emit Burn(_user, amountBurned);
319         return true;
320     }
321 
322   ////////////////
323   // Internal helper functions to query and set a value in a snapshot array
324   ////////////////
325 
326       /// @dev `getValueAt` retrieves the number of reputation at a given block number
327       /// @param checkpoints The history of values being queried
328       /// @param _block The block number to retrieve the value at
329       /// @return The number of reputation being queried
330     function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {
331         if (checkpoints.length == 0) {
332             return 0;
333         }
334 
335           // Shortcut for the actual value
336         if (_block >= checkpoints[checkpoints.length-1].fromBlock) {
337             return checkpoints[checkpoints.length-1].value;
338         }
339         if (_block < checkpoints[0].fromBlock) {
340             return 0;
341         }
342 
343           // Binary search of the value in the array
344         uint256 min = 0;
345         uint256 max = checkpoints.length-1;
346         while (max > min) {
347             uint256 mid = (max + min + 1) / 2;
348             if (checkpoints[mid].fromBlock<=_block) {
349                 min = mid;
350             } else {
351                 max = mid-1;
352             }
353         }
354         return checkpoints[min].value;
355     }
356 
357       /// @dev `updateValueAtNow` used to update the `balances` map and the
358       ///  `totalSupplyHistory`
359       /// @param checkpoints The history of data being updated
360       /// @param _value The new number of reputation
361     function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {
362         require(uint128(_value) == _value); //check value is in the 128 bits bounderies
363         if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {
364             Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];
365             newCheckPoint.fromBlock = uint128(block.number);
366             newCheckPoint.value = uint128(_value);
367         } else {
368             Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];
369             oldCheckPoint.value = uint128(_value);
370         }
371     }
372 }
373 
374 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
375 
376 
377 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol
378 
379 /**
380  * @title SafeMath
381  * @dev Unsigned math operations with safety checks that revert on error
382  */
383 library SafeMath {
384     /**
385     * @dev Multiplies two unsigned integers, reverts on overflow.
386     */
387     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
388         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
389         // benefit is lost if 'b' is also tested.
390         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
391         if (a == 0) {
392             return 0;
393         }
394 
395         uint256 c = a * b;
396         require(c / a == b);
397 
398         return c;
399     }
400 
401     /**
402     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
403     */
404     function div(uint256 a, uint256 b) internal pure returns (uint256) {
405         // Solidity only automatically asserts when dividing by 0
406         require(b > 0);
407         uint256 c = a / b;
408         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
409 
410         return c;
411     }
412 
413     /**
414     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
415     */
416     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
417         require(b <= a);
418         uint256 c = a - b;
419 
420         return c;
421     }
422 
423     /**
424     * @dev Adds two unsigned integers, reverts on overflow.
425     */
426     function add(uint256 a, uint256 b) internal pure returns (uint256) {
427         uint256 c = a + b;
428         require(c >= a);
429 
430         return c;
431     }
432 
433     /**
434     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
435     * reverts when dividing by zero.
436     */
437     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
438         require(b != 0);
439         return a % b;
440     }
441 }
442 
443 // File: /Users/oren/daostack/daostack2/daostack/node_modules/openzeppelin-solidity/contracts/token/ERC20/ERC20.sol
444 
445 /**
446  * @title Standard ERC20 token
447  *
448  * @dev Implementation of the basic standard token.
449  * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md
450  * Originally based on code by FirstBlood:
451  * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
452  *
453  * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for
454  * all accounts just by listening to said events. Note that this isn't required by the specification, and other
455  * compliant implementations may not do it.
456  */
457 contract ERC20 is IERC20 {
458     using SafeMath for uint256;
459 
460     mapping (address => uint256) private _balances;
461 
462     mapping (address => mapping (address => uint256)) private _allowed;
463 
464     uint256 private _totalSupply;
465 
466     /**
467     * @dev Total number of tokens in existence
468     */
469     function totalSupply() public view returns (uint256) {
470         return _totalSupply;
471     }
472 
473     /**
474     * @dev Gets the balance of the specified address.
475     * @param owner The address to query the balance of.
476     * @return An uint256 representing the amount owned by the passed address.
477     */
478     function balanceOf(address owner) public view returns (uint256) {
479         return _balances[owner];
480     }
481 
482     /**
483      * @dev Function to check the amount of tokens that an owner allowed to a spender.
484      * @param owner address The address which owns the funds.
485      * @param spender address The address which will spend the funds.
486      * @return A uint256 specifying the amount of tokens still available for the spender.
487      */
488     function allowance(address owner, address spender) public view returns (uint256) {
489         return _allowed[owner][spender];
490     }
491 
492     /**
493     * @dev Transfer token for a specified address
494     * @param to The address to transfer to.
495     * @param value The amount to be transferred.
496     */
497     function transfer(address to, uint256 value) public returns (bool) {
498         _transfer(msg.sender, to, value);
499         return true;
500     }
501 
502     /**
503      * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
504      * Beware that changing an allowance with this method brings the risk that someone may use both the old
505      * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
506      * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
507      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
508      * @param spender The address which will spend the funds.
509      * @param value The amount of tokens to be spent.
510      */
511     function approve(address spender, uint256 value) public returns (bool) {
512         require(spender != address(0));
513 
514         _allowed[msg.sender][spender] = value;
515         emit Approval(msg.sender, spender, value);
516         return true;
517     }
518 
519     /**
520      * @dev Transfer tokens from one address to another.
521      * Note that while this function emits an Approval event, this is not required as per the specification,
522      * and other compliant implementations may not emit the event.
523      * @param from address The address which you want to send tokens from
524      * @param to address The address which you want to transfer to
525      * @param value uint256 the amount of tokens to be transferred
526      */
527     function transferFrom(address from, address to, uint256 value) public returns (bool) {
528         _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
529         _transfer(from, to, value);
530         emit Approval(from, msg.sender, _allowed[from][msg.sender]);
531         return true;
532     }
533 
534     /**
535      * @dev Increase the amount of tokens that an owner allowed to a spender.
536      * approve should be called when allowed_[_spender] == 0. To increment
537      * allowed value is better to use this function to avoid 2 calls (and wait until
538      * the first transaction is mined)
539      * From MonolithDAO Token.sol
540      * Emits an Approval event.
541      * @param spender The address which will spend the funds.
542      * @param addedValue The amount of tokens to increase the allowance by.
543      */
544     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
545         require(spender != address(0));
546 
547         _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
548         emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
549         return true;
550     }
551 
552     /**
553      * @dev Decrease the amount of tokens that an owner allowed to a spender.
554      * approve should be called when allowed_[_spender] == 0. To decrement
555      * allowed value is better to use this function to avoid 2 calls (and wait until
556      * the first transaction is mined)
557      * From MonolithDAO Token.sol
558      * Emits an Approval event.
559      * @param spender The address which will spend the funds.
560      * @param subtractedValue The amount of tokens to decrease the allowance by.
561      */
562     function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
563         require(spender != address(0));
564 
565         _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);
566         emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
567         return true;
568     }
569 
570     /**
571     * @dev Transfer token for a specified addresses
572     * @param from The address to transfer from.
573     * @param to The address to transfer to.
574     * @param value The amount to be transferred.
575     */
576     function _transfer(address from, address to, uint256 value) internal {
577         require(to != address(0));
578 
579         _balances[from] = _balances[from].sub(value);
580         _balances[to] = _balances[to].add(value);
581         emit Transfer(from, to, value);
582     }
583 
584     /**
585      * @dev Internal function that mints an amount of the token and assigns it to
586      * an account. This encapsulates the modification of balances such that the
587      * proper events are emitted.
588      * @param account The account that will receive the created tokens.
589      * @param value The amount that will be created.
590      */
591     function _mint(address account, uint256 value) internal {
592         require(account != address(0));
593 
594         _totalSupply = _totalSupply.add(value);
595         _balances[account] = _balances[account].add(value);
596         emit Transfer(address(0), account, value);
597     }
598 
599     /**
600      * @dev Internal function that burns an amount of the token of a given
601      * account.
602      * @param account The account whose tokens will be burnt.
603      * @param value The amount that will be burnt.
604      */
605     function _burn(address account, uint256 value) internal {
606         require(account != address(0));
607 
608         _totalSupply = _totalSupply.sub(value);
609         _balances[account] = _balances[account].sub(value);
610         emit Transfer(account, address(0), value);
611     }
612 
613     /**
614      * @dev Internal function that burns an amount of the token of a given
615      * account, deducting from the sender's allowance for said account. Uses the
616      * internal burn function.
617      * Emits an Approval event (reflecting the reduced allowance).
618      * @param account The account whose tokens will be burnt.
619      * @param value The amount that will be burnt.
620      */
621     function _burnFrom(address account, uint256 value) internal {
622         _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);
623         _burn(account, value);
624         emit Approval(account, msg.sender, _allowed[account][msg.sender]);
625     }
626 }
627 
628 // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol
629 
630 /**
631  * @title Burnable Token
632  * @dev Token that can be irreversibly burned (destroyed).
633  */
634 contract ERC20Burnable is ERC20 {
635     /**
636      * @dev Burns a specific amount of tokens.
637      * @param value The amount of token to be burned.
638      */
639     function burn(uint256 value) public {
640         _burn(msg.sender, value);
641     }
642 
643     /**
644      * @dev Burns a specific amount of tokens from the target address and decrements allowance
645      * @param from address The address which you want to send tokens from
646      * @param value uint256 The amount of token to be burned
647      */
648     function burnFrom(address from, uint256 value) public {
649         _burnFrom(from, value);
650     }
651 }
652 
653 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/DAOToken.sol
654 
655 /**
656  * @title DAOToken, base on zeppelin contract.
657  * @dev ERC20 compatible token. It is a mintable, burnable token.
658  */
659 
660 contract DAOToken is ERC20, ERC20Burnable, Ownable {
661 
662     string public name;
663     string public symbol;
664     // solhint-disable-next-line const-name-snakecase
665     uint8 public constant decimals = 18;
666     uint256 public cap;
667 
668     /**
669     * @dev Constructor
670     * @param _name - token name
671     * @param _symbol - token symbol
672     * @param _cap - token cap - 0 value means no cap
673     */
674     constructor(string memory _name, string memory _symbol, uint256 _cap)
675     public {
676         name = _name;
677         symbol = _symbol;
678         cap = _cap;
679     }
680 
681     /**
682      * @dev Function to mint tokens
683      * @param _to The address that will receive the minted tokens.
684      * @param _amount The amount of tokens to mint.
685      */
686     function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {
687         if (cap > 0)
688             require(totalSupply().add(_amount) <= cap);
689         _mint(_to, _amount);
690         return true;
691     }
692 }
693 
694 // File: openzeppelin-solidity/contracts/utils/Address.sol
695 
696 /**
697  * Utility library of inline functions on addresses
698  */
699 library Address {
700     /**
701      * Returns whether the target address is a contract
702      * @dev This function will return false if invoked during the constructor of a contract,
703      * as the code is not actually created until after the constructor finishes.
704      * @param account address of the account to check
705      * @return whether the target address is a contract
706      */
707     function isContract(address account) internal view returns (bool) {
708         uint256 size;
709         // XXX Currently there is no better way to check if there is a contract in an address
710         // than to check the size of the code at that address.
711         // See https://ethereum.stackexchange.com/a/14016/36603
712         // for more details about how this works.
713         // TODO Check this again before the Serenity release, because all addresses will be
714         // contracts then.
715         // solhint-disable-next-line no-inline-assembly
716         assembly { size := extcodesize(account) }
717         return size > 0;
718     }
719 }
720 
721 // File: /Users/oren/daostack/daostack2/daostack/contracts/libs/SafeERC20.sol
722 
723 /*
724 
725 SafeERC20 by daostack.
726 The code is based on a fix by SECBIT Team.
727 
728 USE WITH CAUTION & NO WARRANTY
729 
730 REFERENCE & RELATED READING
731 - https://github.com/ethereum/solidity/issues/4116
732 - https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c
733 - https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
734 - https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61
735 
736 */
737 pragma solidity ^0.5.2;
738 
739 
740 
741 library SafeERC20 {
742     using Address for address;
743 
744     bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));
745     bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));
746     bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes("approve(address,uint256)")));
747 
748     function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {
749 
750         // Must be a contract addr first!
751         require(_erc20Addr.isContract());
752 
753         (bool success, bytes memory returnValue) =
754         // solhint-disable-next-line avoid-low-level-calls
755         _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));
756         // call return false when something wrong
757         require(success);
758         //check return value
759         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
760     }
761 
762     function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {
763 
764         // Must be a contract addr first!
765         require(_erc20Addr.isContract());
766 
767         (bool success, bytes memory returnValue) =
768         // solhint-disable-next-line avoid-low-level-calls
769         _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));
770         // call return false when something wrong
771         require(success);
772         //check return value
773         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
774     }
775 
776     function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {
777 
778         // Must be a contract addr first!
779         require(_erc20Addr.isContract());
780 
781         // safeApprove should only be called when setting an initial allowance,
782         // or when resetting it to zero.
783         require((_value == 0) || (IERC20(_erc20Addr).allowance(msg.sender, _spender) == 0));
784 
785         (bool success, bytes memory returnValue) =
786         // solhint-disable-next-line avoid-low-level-calls
787         _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));
788         // call return false when something wrong
789         require(success);
790         //check return value
791         require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));
792     }
793 }
794 
795 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/Avatar.sol
796 
797 /**
798  * @title An Avatar holds tokens, reputation and ether for a controller
799  */
800 contract Avatar is Ownable {
801     using SafeERC20 for address;
802 
803     string public orgName;
804     DAOToken public nativeToken;
805     Reputation public nativeReputation;
806 
807     event GenericCall(address indexed _contract, bytes _params, bool _success);
808     event SendEther(uint256 _amountInWei, address indexed _to);
809     event ExternalTokenTransfer(address indexed _externalToken, address indexed _to, uint256 _value);
810     event ExternalTokenTransferFrom(address indexed _externalToken, address _from, address _to, uint256 _value);
811     event ExternalTokenApproval(address indexed _externalToken, address _spender, uint256 _value);
812     event ReceiveEther(address indexed _sender, uint256 _value);
813 
814     /**
815     * @dev the constructor takes organization name, native token and reputation system
816     and creates an avatar for a controller
817     */
818     constructor(string memory _orgName, DAOToken _nativeToken, Reputation _nativeReputation) public {
819         orgName = _orgName;
820         nativeToken = _nativeToken;
821         nativeReputation = _nativeReputation;
822     }
823 
824     /**
825     * @dev enables an avatar to receive ethers
826     */
827     function() external payable {
828         emit ReceiveEther(msg.sender, msg.value);
829     }
830 
831     /**
832     * @dev perform a generic call to an arbitrary contract
833     * @param _contract  the contract's address to call
834     * @param _data ABI-encoded contract call to call `_contract` address.
835     * @return bool    success or fail
836     *         bytes - the return bytes of the called contract's function.
837     */
838     function genericCall(address _contract, bytes memory _data)
839     public
840     onlyOwner
841     returns(bool success, bytes memory returnValue) {
842       // solhint-disable-next-line avoid-low-level-calls
843         (success, returnValue) = _contract.call(_data);
844         emit GenericCall(_contract, _data, success);
845     }
846 
847     /**
848     * @dev send ethers from the avatar's wallet
849     * @param _amountInWei amount to send in Wei units
850     * @param _to send the ethers to this address
851     * @return bool which represents success
852     */
853     function sendEther(uint256 _amountInWei, address payable _to) public onlyOwner returns(bool) {
854         _to.transfer(_amountInWei);
855         emit SendEther(_amountInWei, _to);
856         return true;
857     }
858 
859     /**
860     * @dev external token transfer
861     * @param _externalToken the token contract
862     * @param _to the destination address
863     * @param _value the amount of tokens to transfer
864     * @return bool which represents success
865     */
866     function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value)
867     public onlyOwner returns(bool)
868     {
869         address(_externalToken).safeTransfer(_to, _value);
870         emit ExternalTokenTransfer(address(_externalToken), _to, _value);
871         return true;
872     }
873 
874     /**
875     * @dev external token transfer from a specific account
876     * @param _externalToken the token contract
877     * @param _from the account to spend token from
878     * @param _to the destination address
879     * @param _value the amount of tokens to transfer
880     * @return bool which represents success
881     */
882     function externalTokenTransferFrom(
883         IERC20 _externalToken,
884         address _from,
885         address _to,
886         uint256 _value
887     )
888     public onlyOwner returns(bool)
889     {
890         address(_externalToken).safeTransferFrom(_from, _to, _value);
891         emit ExternalTokenTransferFrom(address(_externalToken), _from, _to, _value);
892         return true;
893     }
894 
895     /**
896     * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens
897     *      on behalf of msg.sender.
898     * @param _externalToken the address of the Token Contract
899     * @param _spender address
900     * @param _value the amount of ether (in Wei) which the approval is referring to.
901     * @return bool which represents a success
902     */
903     function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value)
904     public onlyOwner returns(bool)
905     {
906         address(_externalToken).safeApprove(_spender, _value);
907         emit ExternalTokenApproval(address(_externalToken), _spender, _value);
908         return true;
909     }
910 
911 }
912 
913 // File: /Users/oren/daostack/daostack2/daostack/contracts/universalSchemes/UniversalSchemeInterface.sol
914 
915 contract UniversalSchemeInterface {
916 
917     function updateParameters(bytes32 _hashedParameters) public;
918 
919     function getParametersFromController(Avatar _avatar) internal view returns(bytes32);
920 }
921 
922 // File: /Users/oren/daostack/daostack2/daostack/contracts/globalConstraints/GlobalConstraintInterface.sol
923 
924 contract GlobalConstraintInterface {
925 
926     enum CallPhase { Pre, Post, PreAndPost }
927 
928     function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
929     function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);
930     /**
931      * @dev when return if this globalConstraints is pre, post or both.
932      * @return CallPhase enum indication  Pre, Post or PreAndPost.
933      */
934     function when() public returns(CallPhase);
935 }
936 
937 // File: /Users/oren/daostack/daostack2/daostack/contracts/controller/ControllerInterface.sol
938 
939 /**
940  * @title Controller contract
941  * @dev A controller controls the organizations tokens ,reputation and avatar.
942  * It is subject to a set of schemes and constraints that determine its behavior.
943  * Each scheme has it own parameters and operation permissions.
944  */
945 interface ControllerInterface {
946 
947     /**
948      * @dev Mint `_amount` of reputation that are assigned to `_to` .
949      * @param  _amount amount of reputation to mint
950      * @param _to beneficiary address
951      * @return bool which represents a success
952     */
953     function mintReputation(uint256 _amount, address _to, address _avatar)
954     external
955     returns(bool);
956 
957     /**
958      * @dev Burns `_amount` of reputation from `_from`
959      * @param _amount amount of reputation to burn
960      * @param _from The address that will lose the reputation
961      * @return bool which represents a success
962      */
963     function burnReputation(uint256 _amount, address _from, address _avatar)
964     external
965     returns(bool);
966 
967     /**
968      * @dev mint tokens .
969      * @param  _amount amount of token to mint
970      * @param _beneficiary beneficiary address
971      * @param _avatar address
972      * @return bool which represents a success
973      */
974     function mintTokens(uint256 _amount, address _beneficiary, address _avatar)
975     external
976     returns(bool);
977 
978   /**
979    * @dev register or update a scheme
980    * @param _scheme the address of the scheme
981    * @param _paramsHash a hashed configuration of the usage of the scheme
982    * @param _permissions the permissions the new scheme will have
983    * @param _avatar address
984    * @return bool which represents a success
985    */
986     function registerScheme(address _scheme, bytes32 _paramsHash, bytes4 _permissions, address _avatar)
987     external
988     returns(bool);
989 
990     /**
991      * @dev unregister a scheme
992      * @param _avatar address
993      * @param _scheme the address of the scheme
994      * @return bool which represents a success
995      */
996     function unregisterScheme(address _scheme, address _avatar)
997     external
998     returns(bool);
999 
1000     /**
1001      * @dev unregister the caller's scheme
1002      * @param _avatar address
1003      * @return bool which represents a success
1004      */
1005     function unregisterSelf(address _avatar) external returns(bool);
1006 
1007     /**
1008      * @dev add or update Global Constraint
1009      * @param _globalConstraint the address of the global constraint to be added.
1010      * @param _params the constraint parameters hash.
1011      * @param _avatar the avatar of the organization
1012      * @return bool which represents a success
1013      */
1014     function addGlobalConstraint(address _globalConstraint, bytes32 _params, address _avatar)
1015     external returns(bool);
1016 
1017     /**
1018      * @dev remove Global Constraint
1019      * @param _globalConstraint the address of the global constraint to be remove.
1020      * @param _avatar the organization avatar.
1021      * @return bool which represents a success
1022      */
1023     function removeGlobalConstraint (address _globalConstraint, address _avatar)
1024     external  returns(bool);
1025 
1026   /**
1027     * @dev upgrade the Controller
1028     *      The function will trigger an event 'UpgradeController'.
1029     * @param  _newController the address of the new controller.
1030     * @param _avatar address
1031     * @return bool which represents a success
1032     */
1033     function upgradeController(address _newController, Avatar _avatar)
1034     external returns(bool);
1035 
1036     /**
1037     * @dev perform a generic call to an arbitrary contract
1038     * @param _contract  the contract's address to call
1039     * @param _data ABI-encoded contract call to call `_contract` address.
1040     * @param _avatar the controller's avatar address
1041     * @return bool -success
1042     *         bytes  - the return value of the called _contract's function.
1043     */
1044     function genericCall(address _contract, bytes calldata _data, Avatar _avatar)
1045     external
1046     returns(bool, bytes memory);
1047 
1048   /**
1049    * @dev send some ether
1050    * @param _amountInWei the amount of ether (in Wei) to send
1051    * @param _to address of the beneficiary
1052    * @param _avatar address
1053    * @return bool which represents a success
1054    */
1055     function sendEther(uint256 _amountInWei, address payable _to, Avatar _avatar)
1056     external returns(bool);
1057 
1058     /**
1059     * @dev send some amount of arbitrary ERC20 Tokens
1060     * @param _externalToken the address of the Token Contract
1061     * @param _to address of the beneficiary
1062     * @param _value the amount of ether (in Wei) to send
1063     * @param _avatar address
1064     * @return bool which represents a success
1065     */
1066     function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value, Avatar _avatar)
1067     external
1068     returns(bool);
1069 
1070     /**
1071     * @dev transfer token "from" address "to" address
1072     *      One must to approve the amount of tokens which can be spend from the
1073     *      "from" account.This can be done using externalTokenApprove.
1074     * @param _externalToken the address of the Token Contract
1075     * @param _from address of the account to send from
1076     * @param _to address of the beneficiary
1077     * @param _value the amount of ether (in Wei) to send
1078     * @param _avatar address
1079     * @return bool which represents a success
1080     */
1081     function externalTokenTransferFrom(
1082     IERC20 _externalToken,
1083     address _from,
1084     address _to,
1085     uint256 _value,
1086     Avatar _avatar)
1087     external
1088     returns(bool);
1089 
1090     /**
1091     * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens
1092     *      on behalf of msg.sender.
1093     * @param _externalToken the address of the Token Contract
1094     * @param _spender address
1095     * @param _value the amount of ether (in Wei) which the approval is referring to.
1096     * @return bool which represents a success
1097     */
1098     function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value, Avatar _avatar)
1099     external
1100     returns(bool);
1101 
1102     /**
1103      * @dev getNativeReputation
1104      * @param _avatar the organization avatar.
1105      * @return organization native reputation
1106      */
1107     function getNativeReputation(address _avatar)
1108     external
1109     view
1110     returns(address);
1111 
1112     function isSchemeRegistered( address _scheme, address _avatar) external view returns(bool);
1113 
1114     function getSchemeParameters(address _scheme, address _avatar) external view returns(bytes32);
1115 
1116     function getGlobalConstraintParameters(address _globalConstraint, address _avatar) external view returns(bytes32);
1117 
1118     function getSchemePermissions(address _scheme, address _avatar) external view returns(bytes4);
1119 
1120     /**
1121      * @dev globalConstraintsCount return the global constraint pre and post count
1122      * @return uint256 globalConstraintsPre count.
1123      * @return uint256 globalConstraintsPost count.
1124      */
1125     function globalConstraintsCount(address _avatar) external view returns(uint, uint);
1126 
1127     function isGlobalConstraintRegistered(address _globalConstraint, address _avatar) external view returns(bool);
1128 }
1129 
1130 // File: /Users/oren/daostack/daostack2/daostack/contracts/universalSchemes/UniversalScheme.sol
1131 
1132 contract UniversalScheme is Ownable, UniversalSchemeInterface {
1133     bytes32 public hashedParameters; // For other parameters.
1134 
1135     function updateParameters(
1136         bytes32 _hashedParameters
1137     )
1138         public
1139         onlyOwner
1140     {
1141         hashedParameters = _hashedParameters;
1142     }
1143 
1144     /**
1145     *  @dev get the parameters for the current scheme from the controller
1146     */
1147     function getParametersFromController(Avatar _avatar) internal view returns(bytes32) {
1148         require(ControllerInterface(_avatar.owner()).isSchemeRegistered(address(this), address(_avatar)),
1149         "scheme is not registered");
1150         return ControllerInterface(_avatar.owner()).getSchemeParameters(address(this), address(_avatar));
1151     }
1152 }
1153 
1154 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
1155 
1156 /**
1157  * @title Elliptic curve signature operations
1158  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
1159  * TODO Remove this library once solidity supports passing a signature to ecrecover.
1160  * See https://github.com/ethereum/solidity/issues/864
1161  */
1162 
1163 library ECDSA {
1164     /**
1165      * @dev Recover signer address from a message by using their signature
1166      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
1167      * @param signature bytes signature, the signature is generated using web3.eth.sign()
1168      */
1169     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
1170         bytes32 r;
1171         bytes32 s;
1172         uint8 v;
1173 
1174         // Check the signature length
1175         if (signature.length != 65) {
1176             return (address(0));
1177         }
1178 
1179         // Divide the signature in r, s and v variables
1180         // ecrecover takes the signature parameters, and the only way to get them
1181         // currently is to use assembly.
1182         // solhint-disable-next-line no-inline-assembly
1183         assembly {
1184             r := mload(add(signature, 0x20))
1185             s := mload(add(signature, 0x40))
1186             v := byte(0, mload(add(signature, 0x60)))
1187         }
1188 
1189         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
1190         if (v < 27) {
1191             v += 27;
1192         }
1193 
1194         // If the version is correct return the signer address
1195         if (v != 27 && v != 28) {
1196             return (address(0));
1197         } else {
1198             return ecrecover(hash, v, r, s);
1199         }
1200     }
1201 
1202     /**
1203      * toEthSignedMessageHash
1204      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
1205      * and hash the result
1206      */
1207     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
1208         // 32 is the length in bytes of hash,
1209         // enforced by the type signature above
1210         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
1211     }
1212 }
1213 
1214 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/IntVoteInterface.sol
1215 
1216 
1217 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/libs/RealMath.sol
1218 
1219 /**
1220  * RealMath: fixed-point math library, based on fractional and integer parts.
1221  * Using uint256 as real216x40, which isn't in Solidity yet.
1222  * 40 fractional bits gets us down to 1E-12 precision, while still letting us
1223  * go up to galaxy scale counting in meters.
1224  * Internally uses the wider uint256 for some math.
1225  *
1226  * Note that for addition, subtraction, and mod (%), you should just use the
1227  * built-in Solidity operators. Functions for these operations are not provided.
1228  *
1229  */
1230 
1231 
1232 library RealMath {
1233 
1234     /**
1235      * How many total bits are there?
1236      */
1237     uint256 constant private REAL_BITS = 256;
1238 
1239     /**
1240      * How many fractional bits are there?
1241      */
1242     uint256 constant private REAL_FBITS = 40;
1243 
1244     /**
1245      * What's the first non-fractional bit
1246      */
1247     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
1248 
1249     /**
1250      * Raise a real number to any positive integer power
1251      */
1252     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
1253 
1254         uint256 tempRealBase = realBase;
1255         uint256 tempExponent = exponent;
1256 
1257         // Start with the 0th power
1258         uint256 realResult = REAL_ONE;
1259         while (tempExponent != 0) {
1260             // While there are still bits set
1261             if ((tempExponent & 0x1) == 0x1) {
1262                 // If the low bit is set, multiply in the (many-times-squared) base
1263                 realResult = mul(realResult, tempRealBase);
1264             }
1265             // Shift off the low bit
1266             tempExponent = tempExponent >> 1;
1267             // Do the squaring
1268             tempRealBase = mul(tempRealBase, tempRealBase);
1269         }
1270 
1271         // Return the final result.
1272         return uint216(realResult / REAL_ONE);
1273     }
1274 
1275     /**
1276      * Create a real from a rational fraction.
1277      */
1278     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
1279         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
1280     }
1281 
1282     /**
1283      * Multiply one real by another. Truncates overflows.
1284      */
1285     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
1286         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
1287         // So we just have to clip off the extra REAL_FBITS fractional bits.
1288         return uint256((uint256(realA) * uint256(realB)) >> REAL_FBITS);
1289     }
1290 
1291     /**
1292      * Divide one real by another real. Truncates overflows.
1293      */
1294     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
1295         // We use the reverse of the multiplication trick: convert numerator from
1296         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
1297         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
1298     }
1299 
1300 }
1301 
1302 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/VotingMachineCallbacksInterface.sol
1303 
1304 
1305 
1306 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/ProposalExecuteInterface.sol
1307 
1308 interface ProposalExecuteInterface {
1309     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
1310 }
1311 
1312 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
1313 
1314 
1315 // File: openzeppelin-solidity/contracts/math/Math.sol
1316 
1317 /**
1318  * @title Math
1319  * @dev Assorted math operations
1320  */
1321 library Math {
1322     /**
1323     * @dev Returns the largest of two numbers.
1324     */
1325     function max(uint256 a, uint256 b) internal pure returns (uint256) {
1326         return a >= b ? a : b;
1327     }
1328 
1329     /**
1330     * @dev Returns the smallest of two numbers.
1331     */
1332     function min(uint256 a, uint256 b) internal pure returns (uint256) {
1333         return a < b ? a : b;
1334     }
1335 
1336     /**
1337     * @dev Calculates the average of two numbers. Since these are integers,
1338     * averages of an even and odd number cannot be represented, and will be
1339     * rounded down.
1340     */
1341     function average(uint256 a, uint256 b) internal pure returns (uint256) {
1342         // (a + b) / 2 can overflow, so we distribute
1343         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
1344     }
1345 }
1346 
1347 // File: /Users/oren/daostack/daostack2/daostack/node_modules/@daostack/infra/contracts/votingMachines/GenesisProtocolLogic.sol
1348 
1349 /**
1350  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1351  */
1352 contract GenesisProtocolLogic is IntVoteInterface {
1353     using SafeMath for uint;
1354     using Math for uint;
1355     using RealMath for uint216;
1356     using RealMath for uint256;
1357     using Address for address;
1358 
1359     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
1360     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
1361 
1362     //Organization's parameters
1363     struct Parameters {
1364         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
1365         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
1366         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
1367         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
1368                                           //to be in an preparation state (stable) before boosted.
1369         uint256 thresholdConst; //constant  for threshold calculation .
1370                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
1371         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
1372                                    //in the threshold calculation to prevent overflow
1373         uint256 quietEndingPeriod; //quite ending period
1374         uint256 proposingRepReward;//proposer reputation reward.
1375         uint256 votersReputationLossRatio;//Unsuccessful pre booster
1376                                           //voters lose votersReputationLossRatio% of their reputation.
1377         uint256 minimumDaoBounty;
1378         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
1379                                //(daoBountyConst * averageBoostDownstakes)/100 .
1380         uint256 activationTime;//the point in time after which proposals can be created.
1381         //if this address is set so only this address is allowed to vote of behalf of someone else.
1382         address voteOnBehalf;
1383     }
1384 
1385     struct Voter {
1386         uint256 vote; // YES(1) ,NO(2)
1387         uint256 reputation; // amount of voter's reputation
1388         bool preBoosted;
1389     }
1390 
1391     struct Staker {
1392         uint256 vote; // YES(1) ,NO(2)
1393         uint256 amount; // amount of staker's stake
1394         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
1395     }
1396 
1397     struct Proposal {
1398         bytes32 organizationId; // the organization unique identifier the proposal is target to.
1399         address callbacks;    // should fulfill voting callbacks interface.
1400         ProposalState state;
1401         uint256 winningVote; //the winning vote.
1402         address proposer;
1403         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
1404         uint256 currentBoostedVotePeriodLimit;
1405         bytes32 paramsHash;
1406         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
1407         uint256 daoBounty;
1408         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
1409         uint256 confidenceThreshold;
1410         //The percentage from upper stakes which the caller for the expiration was given.
1411         uint256 expirationCallBountyPercentage;
1412         uint[3] times; //times[0] - submittedTime
1413                        //times[1] - boostedPhaseTime
1414                        //times[2] -preBoostedPhaseTime;
1415         //      vote      reputation
1416         mapping(uint256   =>  uint256    ) votes;
1417         //      vote      reputation
1418         mapping(uint256   =>  uint256    ) preBoostedVotes;
1419         //      address     voter
1420         mapping(address =>  Voter    ) voters;
1421         //      vote        stakes
1422         mapping(uint256   =>  uint256    ) stakes;
1423         //      address  staker
1424         mapping(address  => Staker   ) stakers;
1425     }
1426 
1427     event Stake(bytes32 indexed _proposalId,
1428         address indexed _organization,
1429         address indexed _staker,
1430         uint256 _vote,
1431         uint256 _amount
1432     );
1433 
1434     event Redeem(bytes32 indexed _proposalId,
1435         address indexed _organization,
1436         address indexed _beneficiary,
1437         uint256 _amount
1438     );
1439 
1440     event RedeemDaoBounty(bytes32 indexed _proposalId,
1441         address indexed _organization,
1442         address indexed _beneficiary,
1443         uint256 _amount
1444     );
1445 
1446     event RedeemReputation(bytes32 indexed _proposalId,
1447         address indexed _organization,
1448         address indexed _beneficiary,
1449         uint256 _amount
1450     );
1451 
1452     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
1453     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
1454     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
1455 
1456     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
1457     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
1458     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
1459            //organizationId => organization
1460     mapping(bytes32        => address     ) public organizations;
1461           //organizationId => averageBoostDownstakes
1462     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
1463     uint256 constant public NUM_OF_CHOICES = 2;
1464     uint256 constant public NO = 2;
1465     uint256 constant public YES = 1;
1466     uint256 public proposalsCnt; // Total number of proposals
1467     IERC20 public stakingToken;
1468     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
1469     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
1470 
1471     /**
1472      * @dev Constructor
1473      */
1474     constructor(IERC20 _stakingToken) public {
1475       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
1476       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
1477       //If such contract address does not exist in the network (e.g ganache)
1478       //the contract will use the _stakingToken param as the
1479       //staking token address.
1480         if (address(GEN_TOKEN_ADDRESS).isContract()) {
1481             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
1482         } else {
1483             stakingToken = _stakingToken;
1484         }
1485     }
1486 
1487   /**
1488    * @dev Check that the proposal is votable
1489    * a proposal is votable if it is in one of the following states:
1490    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
1491    */
1492     modifier votable(bytes32 _proposalId) {
1493         require(_isVotable(_proposalId));
1494         _;
1495     }
1496 
1497     /**
1498      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
1499      * generated by calculating keccak256 of a incremented counter.
1500      * @param _paramsHash parameters hash
1501      * @param _proposer address
1502      * @param _organization address
1503      */
1504     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
1505         external
1506         returns(bytes32)
1507     {
1508       // solhint-disable-next-line not-rely-on-time
1509         require(now > parameters[_paramsHash].activationTime, "not active yet");
1510         //Check parameters existence.
1511         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
1512         // Generate a unique ID:
1513         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
1514         proposalsCnt = proposalsCnt.add(1);
1515          // Open proposal:
1516         Proposal memory proposal;
1517         proposal.callbacks = msg.sender;
1518         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
1519 
1520         proposal.state = ProposalState.Queued;
1521         // solhint-disable-next-line not-rely-on-time
1522         proposal.times[0] = now;//submitted time
1523         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
1524         proposal.proposer = _proposer;
1525         proposal.winningVote = NO;
1526         proposal.paramsHash = _paramsHash;
1527         if (organizations[proposal.organizationId] == address(0)) {
1528             if (_organization == address(0)) {
1529                 organizations[proposal.organizationId] = msg.sender;
1530             } else {
1531                 organizations[proposal.organizationId] = _organization;
1532             }
1533         }
1534         //calc dao bounty
1535         uint256 daoBounty =
1536         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
1537         if (daoBounty < parameters[_paramsHash].minimumDaoBounty) {
1538             proposal.daoBountyRemain = parameters[_paramsHash].minimumDaoBounty;
1539         } else {
1540             proposal.daoBountyRemain = daoBounty;
1541         }
1542         proposal.totalStakes = proposal.daoBountyRemain;
1543         proposals[proposalId] = proposal;
1544         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
1545         Staker storage staker = proposals[proposalId].stakers[organizations[proposal.organizationId]];
1546         staker.vote = NO;
1547         staker.amount = proposal.daoBountyRemain;
1548 
1549         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
1550         return proposalId;
1551     }
1552 
1553     /**
1554       * @dev executeBoosted try to execute a boosted proposal if it is expired
1555       * @param _proposalId the id of the proposal
1556       * @return uint256 expirationCallBounty the bounty amount for the expiration call
1557      */
1558     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
1559         Proposal storage proposal = proposals[_proposalId];
1560         require(proposal.state == ProposalState.Boosted);
1561         require(_execute(_proposalId), "proposal need to expire");
1562         uint256 expirationCallBountyPercentage =
1563         // solhint-disable-next-line not-rely-on-time
1564         (uint(1).add(now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1])).div(15)));
1565         if (expirationCallBountyPercentage > 100) {
1566             expirationCallBountyPercentage = 100;
1567         }
1568         proposal.expirationCallBountyPercentage = expirationCallBountyPercentage;
1569         expirationCallBounty = expirationCallBountyPercentage.mul(proposal.stakes[YES]).div(100);
1570         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
1571         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
1572     }
1573 
1574     /**
1575      * @dev hash the parameters, save them if necessary, and return the hash value
1576      * @param _params a parameters array
1577      *    _params[0] - _queuedVoteRequiredPercentage,
1578      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
1579      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
1580      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
1581      *                  state (stable) before boosted.
1582      *    _params[4] -_thresholdConst
1583      *    _params[5] -_quietEndingPeriod
1584      *    _params[6] -_proposingRepReward
1585      *    _params[7] -_votersReputationLossRatio
1586      *    _params[8] -_minimumDaoBounty
1587      *    _params[9] -_daoBountyConst
1588      *    _params[10] -_activationTime
1589      * @param _voteOnBehalf - authorized to vote on behalf of others.
1590     */
1591     function setParameters(
1592         uint[11] calldata _params, //use array here due to stack too deep issue.
1593         address _voteOnBehalf
1594     )
1595     external
1596     returns(bytes32)
1597     {
1598         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
1599         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
1600         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
1601         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
1602         require(_params[8] > 0, "minimumDaoBounty should be > 0");
1603         require(_params[9] > 0, "daoBountyConst should be > 0");
1604 
1605         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
1606         //set a limit for power for a given alpha to prevent overflow
1607         uint256 limitExponent = 172;//for alpha less or equal 2
1608         uint256 j = 2;
1609         for (uint256 i = 2000; i < 16000; i = i*2) {
1610             if ((_params[4] > i) && (_params[4] <= i*2)) {
1611                 limitExponent = limitExponent/j;
1612                 break;
1613             }
1614             j++;
1615         }
1616 
1617         parameters[paramsHash] = Parameters({
1618             queuedVoteRequiredPercentage: _params[0],
1619             queuedVotePeriodLimit: _params[1],
1620             boostedVotePeriodLimit: _params[2],
1621             preBoostedVotePeriodLimit: _params[3],
1622             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
1623             limitExponentValue:limitExponent,
1624             quietEndingPeriod: _params[5],
1625             proposingRepReward: _params[6],
1626             votersReputationLossRatio:_params[7],
1627             minimumDaoBounty:_params[8],
1628             daoBountyConst:_params[9],
1629             activationTime:_params[10],
1630             voteOnBehalf:_voteOnBehalf
1631         });
1632         return paramsHash;
1633     }
1634 
1635     /**
1636      * @dev redeem a reward for a successful stake, vote or proposing.
1637      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
1638      * users to redeem on behalf of someone else.
1639      * @param _proposalId the ID of the proposal
1640      * @param _beneficiary - the beneficiary address
1641      * @return rewards -
1642      *           [0] stakerTokenReward
1643      *           [1] voterReputationReward
1644      *           [2] proposerReputationReward
1645      */
1646      // solhint-disable-next-line function-max-lines,code-complexity
1647     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
1648         Proposal storage proposal = proposals[_proposalId];
1649         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
1650         "Proposal should be Executed or ExpiredInQueue");
1651         Parameters memory params = parameters[proposal.paramsHash];
1652         uint256 lostReputation;
1653         if (proposal.winningVote == YES) {
1654             lostReputation = proposal.preBoostedVotes[NO];
1655         } else {
1656             lostReputation = proposal.preBoostedVotes[YES];
1657         }
1658         lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
1659         //as staker
1660         Staker storage staker = proposal.stakers[_beneficiary];
1661         if (staker.amount > 0) {
1662             if (proposal.state == ProposalState.ExpiredInQueue) {
1663                 //Stakes of a proposal that expires in Queue are sent back to stakers
1664                 rewards[0] = staker.amount;
1665             } else if (staker.vote == proposal.winningVote) {
1666                 uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
1667                 uint256 totalStakes = proposal.stakes[YES].add(proposal.stakes[NO]);
1668                 if (staker.vote == YES) {
1669                     uint256 _totalStakes =
1670                     ((totalStakes.mul(100 - proposal.expirationCallBountyPercentage))/100) - proposal.daoBounty;
1671                     rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
1672                 } else {
1673                     rewards[0] = (staker.amount.mul(totalStakes))/totalWinningStakes;
1674                     if (organizations[proposal.organizationId] == _beneficiary) {
1675                           //dao redeem it reward
1676                         rewards[0] = rewards[0].sub(proposal.daoBounty);
1677                     }
1678                 }
1679             }
1680             staker.amount = 0;
1681         }
1682         //as voter
1683         Voter storage voter = proposal.voters[_beneficiary];
1684         if ((voter.reputation != 0) && (voter.preBoosted)) {
1685             if (proposal.state == ProposalState.ExpiredInQueue) {
1686               //give back reputation for the voter
1687                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
1688             } else if (proposal.winningVote == voter.vote) {
1689                 uint256 preBoostedVotes = proposal.preBoostedVotes[YES].add(proposal.preBoostedVotes[NO]);
1690                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
1691                 .add((voter.reputation.mul(lostReputation))/preBoostedVotes);
1692             }
1693             voter.reputation = 0;
1694         }
1695         //as proposer
1696         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
1697             rewards[2] = params.proposingRepReward;
1698             proposal.proposer = address(0);
1699         }
1700         if (rewards[0] != 0) {
1701             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
1702             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
1703             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
1704         }
1705         if (rewards[1].add(rewards[2]) != 0) {
1706             VotingMachineCallbacksInterface(proposal.callbacks)
1707             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
1708             emit RedeemReputation(
1709             _proposalId,
1710             organizations[proposal.organizationId],
1711             _beneficiary,
1712             rewards[1].add(rewards[2])
1713             );
1714         }
1715     }
1716 
1717     /**
1718      * @dev redeemDaoBounty a reward for a successful stake.
1719      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
1720      * users to redeem on behalf of someone else.
1721      * @param _proposalId the ID of the proposal
1722      * @param _beneficiary - the beneficiary address
1723      * @return redeemedAmount - redeem token amount
1724      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
1725      */
1726     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
1727     public
1728     returns(uint256 redeemedAmount, uint256 potentialAmount) {
1729         Proposal storage proposal = proposals[_proposalId];
1730         require(proposal.state == ProposalState.Executed);
1731         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
1732         Staker storage staker = proposal.stakers[_beneficiary];
1733         if (
1734             (staker.amount4Bounty > 0)&&
1735             (staker.vote == proposal.winningVote)&&
1736             (proposal.winningVote == YES)&&
1737             (totalWinningStakes != 0)) {
1738             //as staker
1739                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
1740             }
1741         if ((potentialAmount != 0)&&
1742             (VotingMachineCallbacksInterface(proposal.callbacks)
1743             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
1744             staker.amount4Bounty = 0;
1745             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
1746             require(
1747             VotingMachineCallbacksInterface(proposal.callbacks)
1748             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
1749             redeemedAmount = potentialAmount;
1750             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
1751         }
1752     }
1753 
1754     /**
1755      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
1756      * @param _proposalId the ID of the proposal
1757      * @return bool true or false.
1758      */
1759     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
1760         Proposal memory proposal = proposals[_proposalId];
1761         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
1762     }
1763 
1764     /**
1765      * @dev threshold return the organization's score threshold which required by
1766      * a proposal to shift to boosted state.
1767      * This threshold is dynamically set and it depend on the number of boosted proposal.
1768      * @param _organizationId the organization identifier
1769      * @param _paramsHash the organization parameters hash
1770      * @return uint256 organization's score threshold.
1771      */
1772     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
1773         uint256 power = orgBoostedProposalsCnt[_organizationId];
1774         Parameters storage params = parameters[_paramsHash];
1775 
1776         if (power > params.limitExponentValue) {
1777             power = params.limitExponentValue;
1778         }
1779 
1780         return params.thresholdConst.pow(power);
1781     }
1782 
1783   /**
1784    * @dev hashParameters returns a hash of the given parameters
1785    */
1786     function getParametersHash(
1787         uint[11] memory _params,//use array here due to stack too deep issue.
1788         address _voteOnBehalf
1789     )
1790         public
1791         pure
1792         returns(bytes32)
1793         {
1794         //double call to keccak256 to avoid deep stack issue when call with too many params.
1795         return keccak256(
1796             abi.encodePacked(
1797             keccak256(
1798             abi.encodePacked(
1799                 _params[0],
1800                 _params[1],
1801                 _params[2],
1802                 _params[3],
1803                 _params[4],
1804                 _params[5],
1805                 _params[6],
1806                 _params[7],
1807                 _params[8],
1808                 _params[9],
1809                 _params[10])
1810             ),
1811             _voteOnBehalf
1812         ));
1813     }
1814 
1815     /**
1816       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1817       * @param _proposalId the id of the proposal
1818       * @return bool true - the proposal has been executed
1819       *              false - otherwise.
1820      */
1821      // solhint-disable-next-line function-max-lines,code-complexity
1822     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
1823         Proposal storage proposal = proposals[_proposalId];
1824         Parameters memory params = parameters[proposal.paramsHash];
1825         Proposal memory tmpProposal = proposal;
1826         uint256 totalReputation =
1827         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
1828         //first divide by 100 to prevent overflow
1829         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
1830         ExecutionState executionState = ExecutionState.None;
1831         uint256 averageDownstakesOfBoosted;
1832         uint256 confidenceThreshold;
1833 
1834         if (proposal.votes[proposal.winningVote] > executionBar) {
1835          // someone crossed the absolute vote execution bar.
1836             if (proposal.state == ProposalState.Queued) {
1837                 executionState = ExecutionState.QueueBarCrossed;
1838             } else if (proposal.state == ProposalState.PreBoosted) {
1839                 executionState = ExecutionState.PreBoostedBarCrossed;
1840             } else {
1841                 executionState = ExecutionState.BoostedBarCrossed;
1842             }
1843             proposal.state = ProposalState.Executed;
1844         } else {
1845             if (proposal.state == ProposalState.Queued) {
1846                 // solhint-disable-next-line not-rely-on-time
1847                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
1848                     proposal.state = ProposalState.ExpiredInQueue;
1849                     proposal.winningVote = NO;
1850                     executionState = ExecutionState.QueueTimeOut;
1851                 } else {
1852                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1853                     if (_score(_proposalId) > confidenceThreshold) {
1854                         //change proposal mode to PreBoosted mode.
1855                         proposal.state = ProposalState.PreBoosted;
1856                         // solhint-disable-next-line not-rely-on-time
1857                         proposal.times[2] = now;
1858                         proposal.confidenceThreshold = confidenceThreshold;
1859                     }
1860                 }
1861             }
1862 
1863             if (proposal.state == ProposalState.PreBoosted) {
1864                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
1865               // solhint-disable-next-line not-rely-on-time
1866                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
1867                     if ((_score(_proposalId) > confidenceThreshold) &&
1868                         (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)) {
1869                        //change proposal mode to Boosted mode.
1870                         proposal.state = ProposalState.Boosted;
1871                        // solhint-disable-next-line not-rely-on-time
1872                         proposal.times[1] = now;
1873                         orgBoostedProposalsCnt[proposal.organizationId]++;
1874                        //add a value to average -> average = average + ((value - average) / nbValues)
1875                         averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1876                         // solium-disable-next-line indentation
1877                         averagesDownstakesOfBoosted[proposal.organizationId] =
1878                             uint256(int256(averageDownstakesOfBoosted) +
1879                             ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
1880                             int256(orgBoostedProposalsCnt[proposal.organizationId])));
1881                     }
1882                 } else { //check the Confidence level is stable
1883                     uint256 proposalScore = _score(_proposalId);
1884                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
1885                         proposal.state = ProposalState.Queued;
1886                     } else if (proposal.confidenceThreshold > proposalScore) {
1887                         proposal.confidenceThreshold = confidenceThreshold;
1888                     }
1889                 }
1890             }
1891         }
1892 
1893         if ((proposal.state == ProposalState.Boosted) ||
1894             (proposal.state == ProposalState.QuietEndingPeriod)) {
1895             // solhint-disable-next-line not-rely-on-time
1896             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
1897                 proposal.state = ProposalState.Executed;
1898                 executionState = ExecutionState.BoostedTimeOut;
1899             }
1900         }
1901 
1902         if (executionState != ExecutionState.None) {
1903             if ((executionState == ExecutionState.BoostedTimeOut) ||
1904                 (executionState == ExecutionState.BoostedBarCrossed)) {
1905                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
1906                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1907                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
1908                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1909                 if (boostedProposals == 0) {
1910                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1911                 } else {
1912                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1913                     averagesDownstakesOfBoosted[proposal.organizationId] =
1914                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1915                 }
1916             }
1917             emit ExecuteProposal(
1918             _proposalId,
1919             organizations[proposal.organizationId],
1920             proposal.winningVote,
1921             totalReputation
1922             );
1923             emit GPExecuteProposal(_proposalId, executionState);
1924             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1925             proposal.daoBounty = proposal.daoBountyRemain;
1926         }
1927         if (tmpProposal.state != proposal.state) {
1928             emit StateChange(_proposalId, proposal.state);
1929         }
1930         return (executionState != ExecutionState.None);
1931     }
1932 
1933     /**
1934      * @dev staking function
1935      * @param _proposalId id of the proposal
1936      * @param _vote  NO(2) or YES(1).
1937      * @param _amount the betting amount
1938      * @return bool true - the proposal has been executed
1939      *              false - otherwise.
1940      */
1941     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1942         // 0 is not a valid vote.
1943         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1944         require(_amount > 0, "staking amount should be >0");
1945 
1946         if (_execute(_proposalId)) {
1947             return true;
1948         }
1949         Proposal storage proposal = proposals[_proposalId];
1950 
1951         if ((proposal.state != ProposalState.PreBoosted) &&
1952             (proposal.state != ProposalState.Queued)) {
1953             return false;
1954         }
1955 
1956         // enable to increase stake only on the previous stake vote
1957         Staker storage staker = proposal.stakers[_staker];
1958         if ((staker.amount > 0) && (staker.vote != _vote)) {
1959             return false;
1960         }
1961 
1962         uint256 amount = _amount;
1963         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1964         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1965         staker.amount = staker.amount.add(amount);
1966         //This is to prevent average downstakes calculation overflow
1967         //Note that any how GEN cap is 100000000 ether.
1968         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1969         require(proposal.totalStakes <= 0x100000000000000000000000000000000, "total stakes is too high");
1970 
1971         if (_vote == YES) {
1972             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1973         }
1974         staker.vote = _vote;
1975 
1976         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1977         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1978         return _execute(_proposalId);
1979     }
1980 
1981     /**
1982      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1983      * @param _proposalId id of the proposal
1984      * @param _voter used in case the vote is cast for someone else
1985      * @param _vote a value between 0 to and the proposal's number of choices.
1986      * @param _rep how many reputation the voter would like to stake for this vote.
1987      *         if  _rep==0 so the voter full reputation will be use.
1988      * @return true in case of proposal execution otherwise false
1989      * throws if proposal is not open or if it has been executed
1990      * NB: executes the proposal if a decision has been reached
1991      */
1992      // solhint-disable-next-line function-max-lines,code-complexity
1993     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1994         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1995         if (_execute(_proposalId)) {
1996             return true;
1997         }
1998 
1999         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
2000         Proposal storage proposal = proposals[_proposalId];
2001 
2002         // Check voter has enough reputation:
2003         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
2004         require(reputation > 0, "_voter must have reputation");
2005         require(reputation >= _rep, "reputation >= _rep");
2006         uint256 rep = _rep;
2007         if (rep == 0) {
2008             rep = reputation;
2009         }
2010         // If this voter has already voted, return false.
2011         if (proposal.voters[_voter].reputation != 0) {
2012             return false;
2013         }
2014         // The voting itself:
2015         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
2016         //check if the current winningVote changed or there is a tie.
2017         //for the case there is a tie the current winningVote set to NO.
2018         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
2019             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
2020             proposal.winningVote == YES)) {
2021             if (proposal.state == ProposalState.Boosted &&
2022             // solhint-disable-next-line not-rely-on-time
2023                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
2024                 proposal.state == ProposalState.QuietEndingPeriod) {
2025                 //quietEndingPeriod
2026                 if (proposal.state != ProposalState.QuietEndingPeriod) {
2027                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
2028                     proposal.state = ProposalState.QuietEndingPeriod;
2029                 }
2030                 // solhint-disable-next-line not-rely-on-time
2031                 proposal.times[1] = now;
2032             }
2033             proposal.winningVote = _vote;
2034         }
2035         proposal.voters[_voter] = Voter({
2036             reputation: rep,
2037             vote: _vote,
2038             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
2039         });
2040         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
2041             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
2042             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
2043             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
2044         }
2045         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
2046         return _execute(_proposalId);
2047     }
2048 
2049     /**
2050      * @dev _score return the proposal score (Confidence level)
2051      * For dual choice proposal S = (S+)/(S-)
2052      * @param _proposalId the ID of the proposal
2053      * @return uint256 proposal score.
2054      */
2055     function _score(bytes32 _proposalId) internal view returns(uint256) {
2056         Proposal storage proposal = proposals[_proposalId];
2057         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
2058         return proposal.stakes[YES]/proposal.stakes[NO];
2059     }
2060 
2061     /**
2062       * @dev _isVotable check if the proposal is votable
2063       * @param _proposalId the ID of the proposal
2064       * @return bool true or false
2065     */
2066     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
2067         ProposalState pState = proposals[_proposalId].state;
2068         return ((pState == ProposalState.PreBoosted)||
2069                 (pState == ProposalState.Boosted)||
2070                 (pState == ProposalState.QuietEndingPeriod)||
2071                 (pState == ProposalState.Queued)
2072         );
2073     }
2074 }
2075 
2076 // File: @daostack/infra/contracts/votingMachines/GenesisProtocol.sol
2077 
2078 /**
2079  * @title GenesisProtocol implementation -an organization's voting machine scheme.
2080  */
2081 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
2082     using ECDSA for bytes32;
2083 
2084     // Digest describing the data the user signs according EIP 712.
2085     // Needs to match what is passed to Metamask.
2086     bytes32 public constant DELEGATION_HASH_EIP712 =
2087     keccak256(abi.encodePacked(
2088     "address GenesisProtocolAddress",
2089     "bytes32 ProposalId",
2090     "uint256 Vote",
2091     "uint256 AmountToStake",
2092     "uint256 Nonce"
2093     ));
2094 
2095     mapping(address=>uint256) public stakesNonce; //stakes Nonce
2096 
2097     /**
2098      * @dev Constructor
2099      */
2100     constructor(IERC20 _stakingToken)
2101     public
2102     // solhint-disable-next-line no-empty-blocks
2103     GenesisProtocolLogic(_stakingToken) {
2104     }
2105 
2106     /**
2107      * @dev staking function
2108      * @param _proposalId id of the proposal
2109      * @param _vote  NO(2) or YES(1).
2110      * @param _amount the betting amount
2111      * @return bool true - the proposal has been executed
2112      *              false - otherwise.
2113      */
2114     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
2115         return _stake(_proposalId, _vote, _amount, msg.sender);
2116     }
2117 
2118     /**
2119      * @dev stakeWithSignature function
2120      * @param _proposalId id of the proposal
2121      * @param _vote  NO(2) or YES(1).
2122      * @param _amount the betting amount
2123      * @param _nonce nonce value ,it is part of the signature to ensure that
2124               a signature can be received only once.
2125      * @param _signatureType signature type
2126               1 - for web3.eth.sign
2127               2 - for eth_signTypedData according to EIP #712.
2128      * @param _signature  - signed data by the staker
2129      * @return bool true - the proposal has been executed
2130      *              false - otherwise.
2131      */
2132     function stakeWithSignature(
2133         bytes32 _proposalId,
2134         uint256 _vote,
2135         uint256 _amount,
2136         uint256 _nonce,
2137         uint256 _signatureType,
2138         bytes calldata _signature
2139         )
2140         external
2141         returns(bool)
2142         {
2143         // Recreate the digest the user signed
2144         bytes32 delegationDigest;
2145         if (_signatureType == 2) {
2146             delegationDigest = keccak256(
2147                 abi.encodePacked(
2148                     DELEGATION_HASH_EIP712, keccak256(
2149                         abi.encodePacked(
2150                         address(this),
2151                         _proposalId,
2152                         _vote,
2153                         _amount,
2154                         _nonce)
2155                     )
2156                 )
2157             );
2158         } else {
2159             delegationDigest = keccak256(
2160                         abi.encodePacked(
2161                         address(this),
2162                         _proposalId,
2163                         _vote,
2164                         _amount,
2165                         _nonce)
2166                     ).toEthSignedMessageHash();
2167         }
2168         address staker = delegationDigest.recover(_signature);
2169         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
2170         require(staker != address(0), "staker address cannot be 0");
2171         require(stakesNonce[staker] == _nonce);
2172         stakesNonce[staker] = stakesNonce[staker].add(1);
2173         return _stake(_proposalId, _vote, _amount, staker);
2174     }
2175 
2176     /**
2177      * @dev voting function
2178      * @param _proposalId id of the proposal
2179      * @param _vote NO(2) or YES(1).
2180      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
2181      * @param _voter voter address
2182      * @return bool true - the proposal has been executed
2183      *              false - otherwise.
2184      */
2185     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
2186     external
2187     votable(_proposalId)
2188     returns(bool) {
2189         Proposal storage proposal = proposals[_proposalId];
2190         Parameters memory params = parameters[proposal.paramsHash];
2191         address voter;
2192         if (params.voteOnBehalf != address(0)) {
2193             require(msg.sender == params.voteOnBehalf);
2194             voter = _voter;
2195         } else {
2196             voter = msg.sender;
2197         }
2198         return internalVote(_proposalId, voter, _vote, _amount);
2199     }
2200 
2201   /**
2202    * @dev Cancel the vote of the msg.sender.
2203    * cancel vote is not allow in genesisProtocol so this function doing nothing.
2204    * This function is here in order to comply to the IntVoteInterface .
2205    */
2206     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
2207        //this is not allowed
2208         return;
2209     }
2210 
2211     /**
2212       * @dev execute check if the proposal has been decided, and if so, execute the proposal
2213       * @param _proposalId the id of the proposal
2214       * @return bool true - the proposal has been executed
2215       *              false - otherwise.
2216      */
2217     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
2218         return _execute(_proposalId);
2219     }
2220 
2221   /**
2222     * @dev getNumberOfChoices returns the number of choices possible in this proposal
2223     * @return uint256 that contains number of choices
2224     */
2225     function getNumberOfChoices(bytes32) external view returns(uint256) {
2226         return NUM_OF_CHOICES;
2227     }
2228 
2229     /**
2230       * @dev getProposalTimes returns proposals times variables.
2231       * @param _proposalId id of the proposal
2232       * @return proposals times array
2233       */
2234     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
2235         return proposals[_proposalId].times;
2236     }
2237 
2238     /**
2239      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
2240      * @param _proposalId the ID of the proposal
2241      * @param _voter the address of the voter
2242      * @return uint256 vote - the voters vote
2243      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
2244      */
2245     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
2246         Voter memory voter = proposals[_proposalId].voters[_voter];
2247         return (voter.vote, voter.reputation);
2248     }
2249 
2250     /**
2251     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
2252     * @param _proposalId the ID of the proposal
2253     * @param _choice the index in the
2254     * @return voted reputation for the given choice
2255     */
2256     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
2257         return proposals[_proposalId].votes[_choice];
2258     }
2259 
2260     /**
2261     * @dev isVotable check if the proposal is votable
2262     * @param _proposalId the ID of the proposal
2263     * @return bool true or false
2264     */
2265     function isVotable(bytes32 _proposalId) external view returns(bool) {
2266         return _isVotable(_proposalId);
2267     }
2268 
2269     /**
2270     * @dev proposalStatus return the total votes and stakes for a given proposal
2271     * @param _proposalId the ID of the proposal
2272     * @return uint256 preBoostedVotes YES
2273     * @return uint256 preBoostedVotes NO
2274     * @return uint256 total stakes YES
2275     * @return uint256 total stakes NO
2276     */
2277     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
2278         return (
2279                 proposals[_proposalId].preBoostedVotes[YES],
2280                 proposals[_proposalId].preBoostedVotes[NO],
2281                 proposals[_proposalId].stakes[YES],
2282                 proposals[_proposalId].stakes[NO]
2283         );
2284     }
2285 
2286   /**
2287     * @dev getProposalOrganization return the organizationId for a given proposal
2288     * @param _proposalId the ID of the proposal
2289     * @return bytes32 organization identifier
2290     */
2291     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
2292         return (proposals[_proposalId].organizationId);
2293     }
2294 
2295     /**
2296       * @dev getStaker return the vote and stake amount for a given proposal and staker
2297       * @param _proposalId the ID of the proposal
2298       * @param _staker staker address
2299       * @return uint256 vote
2300       * @return uint256 amount
2301     */
2302     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
2303         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
2304     }
2305 
2306     /**
2307       * @dev voteStake return the amount stakes for a given proposal and vote
2308       * @param _proposalId the ID of the proposal
2309       * @param _vote vote number
2310       * @return uint256 stake amount
2311     */
2312     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
2313         return proposals[_proposalId].stakes[_vote];
2314     }
2315 
2316   /**
2317     * @dev voteStake return the winningVote for a given proposal
2318     * @param _proposalId the ID of the proposal
2319     * @return uint256 winningVote
2320     */
2321     function winningVote(bytes32 _proposalId) external view returns(uint256) {
2322         return proposals[_proposalId].winningVote;
2323     }
2324 
2325     /**
2326       * @dev voteStake return the state for a given proposal
2327       * @param _proposalId the ID of the proposal
2328       * @return ProposalState proposal state
2329     */
2330     function state(bytes32 _proposalId) external view returns(ProposalState) {
2331         return proposals[_proposalId].state;
2332     }
2333 
2334    /**
2335     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
2336     * @return bool true or false
2337     */
2338     function isAbstainAllow() external pure returns(bool) {
2339         return false;
2340     }
2341 
2342     /**
2343      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
2344      * @return min - minimum number of choices
2345                max - maximum number of choices
2346      */
2347     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
2348         return (YES, NO);
2349     }
2350 
2351     /**
2352      * @dev score return the proposal score
2353      * @param _proposalId the ID of the proposal
2354      * @return uint256 proposal score.
2355      */
2356     function score(bytes32 _proposalId) public view returns(uint256) {
2357         return  _score(_proposalId);
2358     }
2359 }
2360 
2361 // File: /Users/oren/daostack/daostack2/daostack/contracts/votingMachines/VotingMachineCallbacks.sol
2362 
2363 contract VotingMachineCallbacks is VotingMachineCallbacksInterface {
2364 
2365     struct ProposalInfo {
2366         uint256 blockNumber; // the proposal's block number
2367         Avatar avatar; // the proposal's avatar
2368         address votingMachine;
2369     }
2370 
2371     modifier onlyVotingMachine(bytes32 _proposalId) {
2372         require(msg.sender == proposalsInfo[_proposalId].votingMachine, "only VotingMachine");
2373         _;
2374     }
2375 
2376             //proposalId ->     ProposalInfo
2377     mapping(bytes32      =>     ProposalInfo    ) public proposalsInfo;
2378 
2379     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId)
2380     external
2381     onlyVotingMachine(_proposalId)
2382     returns(bool)
2383     {
2384         Avatar avatar = proposalsInfo[_proposalId].avatar;
2385         if (avatar == Avatar(0)) {
2386             return false;
2387         }
2388         return ControllerInterface(avatar.owner()).mintReputation(_amount, _beneficiary, address(avatar));
2389     }
2390 
2391     function burnReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId)
2392     external
2393     onlyVotingMachine(_proposalId)
2394     returns(bool)
2395     {
2396         Avatar avatar = proposalsInfo[_proposalId].avatar;
2397         if (avatar == Avatar(0)) {
2398             return false;
2399         }
2400         return ControllerInterface(avatar.owner()).burnReputation(_amount, _beneficiary, address(avatar));
2401     }
2402 
2403     function stakingTokenTransfer(
2404         IERC20 _stakingToken,
2405         address _beneficiary,
2406         uint256 _amount,
2407         bytes32 _proposalId)
2408     external
2409     onlyVotingMachine(_proposalId)
2410     returns(bool)
2411     {
2412         Avatar avatar = proposalsInfo[_proposalId].avatar;
2413         if (avatar == Avatar(0)) {
2414             return false;
2415         }
2416         return ControllerInterface(avatar.owner()).externalTokenTransfer(_stakingToken, _beneficiary, _amount, avatar);
2417     }
2418 
2419     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256) {
2420         Avatar avatar = proposalsInfo[_proposalId].avatar;
2421         if (proposalsInfo[_proposalId].avatar == Avatar(0)) {
2422             return 0;
2423         }
2424         return _stakingToken.balanceOf(address(avatar));
2425     }
2426 
2427     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256) {
2428         ProposalInfo memory proposal = proposalsInfo[_proposalId];
2429         if (proposal.avatar == Avatar(0)) {
2430             return 0;
2431         }
2432         return proposal.avatar.nativeReputation().totalSupplyAt(proposal.blockNumber);
2433     }
2434 
2435     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256) {
2436         ProposalInfo memory proposal = proposalsInfo[_proposalId];
2437         if (proposal.avatar == Avatar(0)) {
2438             return 0;
2439         }
2440         return proposal.avatar.nativeReputation().balanceOfAt(_owner, proposal.blockNumber);
2441     }
2442 }
2443 
2444 // File: contracts/universalSchemes/ContributionReward.sol
2445 
2446 /**
2447  * @title A scheme for proposing and rewarding contributions to an organization
2448  * @dev An agent can ask an organization to recognize a contribution and reward
2449  * him with token, reputation, ether or any combination.
2450  */
2451 
2452 contract ContributionReward is UniversalScheme, VotingMachineCallbacks, ProposalExecuteInterface {
2453     using SafeMath for uint;
2454 
2455     event NewContributionProposal(
2456         address indexed _avatar,
2457         bytes32 indexed _proposalId,
2458         address indexed _intVoteInterface,
2459         string _descriptionHash,
2460         int256 _reputationChange,
2461         uint[5]  _rewards,
2462         IERC20 _externalToken,
2463         address _beneficiary
2464     );
2465 
2466     event ProposalExecuted(address indexed _avatar, bytes32 indexed _proposalId, int256 _param);
2467 
2468     event RedeemReputation(
2469         address indexed _avatar,
2470         bytes32 indexed _proposalId,
2471         address indexed _beneficiary,
2472         int256 _amount);
2473 
2474     event RedeemEther(address indexed _avatar,
2475         bytes32 indexed _proposalId,
2476         address indexed _beneficiary,
2477         uint256 _amount);
2478 
2479     event RedeemNativeToken(address indexed _avatar,
2480         bytes32 indexed _proposalId,
2481         address indexed _beneficiary,
2482         uint256 _amount);
2483 
2484     event RedeemExternalToken(address indexed _avatar,
2485         bytes32 indexed _proposalId,
2486         address indexed _beneficiary,
2487         uint256 _amount);
2488 
2489     // A struct holding the data for a contribution proposal
2490     struct ContributionProposal {
2491         uint256 nativeTokenReward; // Reward asked in the native token of the organization.
2492         int256 reputationChange; // Organization reputation reward requested.
2493         uint256 ethReward;
2494         IERC20 externalToken;
2495         uint256 externalTokenReward;
2496         address payable beneficiary;
2497         uint256 periodLength;
2498         uint256 numberOfPeriods;
2499         uint256 executionTime;
2500         uint[4] redeemedPeriods;
2501     }
2502 
2503     // A mapping from the organization (Avatar) address to the saved data of the organization:
2504     mapping(address=>mapping(bytes32=>ContributionProposal)) public organizationsProposals;
2505 
2506     // A mapping from hashes to parameters (use to store a particular configuration on the controller)
2507     // A contribution fee can be in the organization token or the scheme token or a combination
2508     struct Parameters {
2509       // a fee (in the organization's token) that is to be paid for submitting a contribution
2510         uint256 orgNativeTokenFee;
2511         bytes32 voteApproveParams;
2512         IntVoteInterface intVote;
2513     }
2514 
2515     // A mapping from hashes to parameters (use to store a particular configuration on the controller)
2516     mapping(bytes32=>Parameters) public parameters;
2517 
2518     /**
2519     * @dev execution of proposals, can only be called by the voting machine in which the vote is held.
2520     * @param _proposalId the ID of the voting in the voting machine
2521     * @param _param a parameter of the voting result, 1 yes and 2 is no.
2522     */
2523     function executeProposal(bytes32 _proposalId, int256 _param) external onlyVotingMachine(_proposalId) returns(bool) {
2524         ProposalInfo memory proposal = proposalsInfo[_proposalId];
2525         require(organizationsProposals[address(proposal.avatar)][_proposalId].executionTime == 0);
2526         require(organizationsProposals[address(proposal.avatar)][_proposalId].beneficiary != address(0));
2527         // Check if vote was successful:
2528         if (_param == 1) {
2529           // solhint-disable-next-line not-rely-on-time
2530             organizationsProposals[address(proposal.avatar)][_proposalId].executionTime = now;
2531         }
2532         emit ProposalExecuted(address(proposal.avatar), _proposalId, _param);
2533         return true;
2534     }
2535 
2536     /**
2537     * @dev hash the parameters, save them if necessary, and return the hash value
2538     */
2539     function setParameters(
2540         uint256 _orgNativeTokenFee,
2541         bytes32 _voteApproveParams,
2542         IntVoteInterface _intVote
2543     ) public returns(bytes32)
2544     {
2545         bytes32 paramsHash = getParametersHash(
2546             _orgNativeTokenFee,
2547             _voteApproveParams,
2548             _intVote
2549         );
2550         parameters[paramsHash].orgNativeTokenFee = _orgNativeTokenFee;
2551         parameters[paramsHash].voteApproveParams = _voteApproveParams;
2552         parameters[paramsHash].intVote = _intVote;
2553         return paramsHash;
2554     }
2555 
2556     /**
2557     * @dev return a hash of the given parameters
2558     * @param _orgNativeTokenFee the fee for submitting a contribution in organizations native token
2559     * @param _voteApproveParams parameters for the voting machine used to approve a contribution
2560     * @param _intVote the voting machine used to approve a contribution
2561     * @return a hash of the parameters
2562     */
2563     // TODO: These fees are messy. Better to have a _fee and _feeToken pair,
2564     //just as in some other contract (which one?) with some sane default
2565     function getParametersHash(
2566         uint256 _orgNativeTokenFee,
2567         bytes32 _voteApproveParams,
2568         IntVoteInterface _intVote
2569     ) public pure returns(bytes32)
2570     {
2571         return (keccak256(abi.encodePacked(_voteApproveParams, _orgNativeTokenFee, _intVote)));
2572     }
2573 
2574     /**
2575     * @dev Submit a proposal for a reward for a contribution:
2576     * @param _avatar Avatar of the organization that the contribution was made for
2577     * @param _descriptionHash A hash of the proposal's description
2578     * @param _reputationChange - Amount of reputation change requested .Can be negative.
2579     * @param _rewards rewards array:
2580     *         rewards[0] - Amount of tokens requested per period
2581     *         rewards[1] - Amount of ETH requested per period
2582     *         rewards[2] - Amount of external tokens requested per period
2583     *         rewards[3] - Period length - if set to zero it allows immediate redeeming after execution.
2584     *         rewards[4] - Number of periods
2585     * @param _externalToken Address of external token, if reward is requested there
2586     * @param _beneficiary Who gets the rewards
2587     */
2588     function proposeContributionReward(
2589         Avatar _avatar,
2590         string memory _descriptionHash,
2591         int256 _reputationChange,
2592         uint[5] memory _rewards,
2593         IERC20 _externalToken,
2594         address payable _beneficiary
2595     )
2596     public
2597     returns(bytes32)
2598     {
2599         validateProposalParams(_reputationChange, _rewards);
2600         Parameters memory controllerParams = parameters[getParametersFromController(_avatar)];
2601         // Pay fees for submitting the contribution:
2602         if (controllerParams.orgNativeTokenFee > 0) {
2603             _avatar.nativeToken().transferFrom(msg.sender, address(_avatar), controllerParams.orgNativeTokenFee);
2604         }
2605 
2606         bytes32 contributionId = controllerParams.intVote.propose(
2607         2,
2608         controllerParams.voteApproveParams,
2609         msg.sender,
2610         address(_avatar)
2611         );
2612 
2613         address payable beneficiary = _beneficiary;
2614         if (beneficiary == address(0)) {
2615             beneficiary = msg.sender;
2616         }
2617 
2618         ContributionProposal memory proposal = ContributionProposal({
2619             nativeTokenReward: _rewards[0],
2620             reputationChange: _reputationChange,
2621             ethReward: _rewards[1],
2622             externalToken: _externalToken,
2623             externalTokenReward: _rewards[2],
2624             beneficiary: beneficiary,
2625             periodLength: _rewards[3],
2626             numberOfPeriods: _rewards[4],
2627             executionTime: 0,
2628             redeemedPeriods:[uint(0), uint(0), uint(0), uint(0)]
2629         });
2630         organizationsProposals[address(_avatar)][contributionId] = proposal;
2631 
2632         emit NewContributionProposal(
2633             address(_avatar),
2634             contributionId,
2635             address(controllerParams.intVote),
2636             _descriptionHash,
2637             _reputationChange,
2638             _rewards,
2639             _externalToken,
2640             beneficiary
2641         );
2642 
2643         proposalsInfo[contributionId] = ProposalInfo({
2644             blockNumber:block.number,
2645             avatar:_avatar,
2646             votingMachine:address(controllerParams.intVote)
2647         });
2648         return contributionId;
2649     }
2650 
2651     /**
2652     * @dev RedeemReputation reward for proposal
2653     * @param _proposalId the ID of the voting in the voting machine
2654     * @param _avatar address of the controller
2655     * @return reputation the redeemed reputation.
2656     */
2657     function redeemReputation(bytes32 _proposalId, Avatar _avatar) public returns(int256 reputation) {
2658 
2659         ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
2660         ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
2661         require(proposal.executionTime != 0);
2662         uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 0);
2663 
2664         //set proposal reward to zero to prevent reentrancy attack.
2665         proposal.reputationChange = 0;
2666         reputation = int(periodsToPay) * _proposal.reputationChange;
2667         if (reputation > 0) {
2668             require(
2669             ControllerInterface(
2670             _avatar.owner()).mintReputation(uint(reputation), _proposal.beneficiary, address(_avatar)));
2671         } else if (reputation < 0) {
2672             require(
2673             ControllerInterface(
2674             _avatar.owner()).burnReputation(uint(reputation*(-1)), _proposal.beneficiary, address(_avatar)));
2675         }
2676         if (reputation != 0) {
2677             proposal.redeemedPeriods[0] = proposal.redeemedPeriods[0].add(periodsToPay);
2678             emit RedeemReputation(address(_avatar), _proposalId, _proposal.beneficiary, reputation);
2679         }
2680         //restore proposal reward.
2681         proposal.reputationChange = _proposal.reputationChange;
2682     }
2683 
2684     /**
2685     * @dev RedeemNativeToken reward for proposal
2686     * @param _proposalId the ID of the voting in the voting machine
2687     * @param _avatar address of the controller
2688     * @return amount the redeemed nativeToken.
2689     */
2690     function redeemNativeToken(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
2691 
2692         ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
2693         ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
2694         require(proposal.executionTime != 0);
2695         uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 1);
2696         //set proposal rewards to zero to prevent reentrancy attack.
2697         proposal.nativeTokenReward = 0;
2698 
2699         amount = periodsToPay.mul(_proposal.nativeTokenReward);
2700         if (amount > 0) {
2701             require(ControllerInterface(_avatar.owner()).mintTokens(amount, _proposal.beneficiary, address(_avatar)));
2702             proposal.redeemedPeriods[1] = proposal.redeemedPeriods[1].add(periodsToPay);
2703             emit RedeemNativeToken(address(_avatar), _proposalId, _proposal.beneficiary, amount);
2704         }
2705 
2706         //restore proposal reward.
2707         proposal.nativeTokenReward = _proposal.nativeTokenReward;
2708     }
2709 
2710     /**
2711     * @dev RedeemEther reward for proposal
2712     * @param _proposalId the ID of the voting in the voting machine
2713     * @param _avatar address of the controller
2714     * @return amount ether redeemed amount
2715     */
2716     function redeemEther(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
2717 
2718         ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
2719         ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
2720         require(proposal.executionTime != 0);
2721         uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 2);
2722         //set proposal rewards to zero to prevent reentrancy attack.
2723         proposal.ethReward = 0;
2724         amount = periodsToPay.mul(_proposal.ethReward);
2725 
2726         if (amount > 0) {
2727             require(ControllerInterface(_avatar.owner()).sendEther(amount, _proposal.beneficiary, _avatar));
2728             proposal.redeemedPeriods[2] = proposal.redeemedPeriods[2].add(periodsToPay);
2729             emit RedeemEther(address(_avatar), _proposalId, _proposal.beneficiary, amount);
2730         }
2731 
2732         //restore proposal reward.
2733         proposal.ethReward = _proposal.ethReward;
2734     }
2735 
2736     /**
2737     * @dev RedeemNativeToken reward for proposal
2738     * @param _proposalId the ID of the voting in the voting machine
2739     * @param _avatar address of the controller
2740     * @return amount the external token redeemed amount
2741     */
2742     function redeemExternalToken(bytes32 _proposalId, Avatar _avatar) public returns(uint256 amount) {
2743 
2744         ContributionProposal memory _proposal = organizationsProposals[address(_avatar)][_proposalId];
2745         ContributionProposal storage proposal = organizationsProposals[address(_avatar)][_proposalId];
2746         require(proposal.executionTime != 0);
2747         uint256 periodsToPay = getPeriodsToPay(_proposalId, address(_avatar), 3);
2748         //set proposal rewards to zero to prevent reentrancy attack.
2749         proposal.externalTokenReward = 0;
2750 
2751         if (proposal.externalToken != IERC20(0) && _proposal.externalTokenReward > 0) {
2752             amount = periodsToPay.mul(_proposal.externalTokenReward);
2753             if (amount > 0) {
2754                 require(
2755                 ControllerInterface(
2756                 _avatar.owner())
2757                 .externalTokenTransfer(_proposal.externalToken, _proposal.beneficiary, amount, _avatar));
2758                 proposal.redeemedPeriods[3] = proposal.redeemedPeriods[3].add(periodsToPay);
2759                 emit RedeemExternalToken(address(_avatar), _proposalId, _proposal.beneficiary, amount);
2760             }
2761         }
2762         //restore proposal reward.
2763         proposal.externalTokenReward = _proposal.externalTokenReward;
2764     }
2765 
2766     /**
2767     * @dev redeem rewards for proposal
2768     * @param _proposalId the ID of the voting in the voting machine
2769     * @param _avatar address of the controller
2770     * @param _whatToRedeem whatToRedeem array:
2771     *         whatToRedeem[0] - reputation
2772     *         whatToRedeem[1] - nativeTokenReward
2773     *         whatToRedeem[2] - Ether
2774     *         whatToRedeem[3] - ExternalToken
2775     * @return  result boolean array for each redeem type.
2776     */
2777     function redeem(bytes32 _proposalId, Avatar _avatar, bool[4] memory _whatToRedeem)
2778     public
2779     returns(int256 reputationReward, uint256 nativeTokenReward, uint256 etherReward, uint256 externalTokenReward)
2780     {
2781 
2782         if (_whatToRedeem[0]) {
2783             reputationReward = redeemReputation(_proposalId, _avatar);
2784         }
2785 
2786         if (_whatToRedeem[1]) {
2787             nativeTokenReward = redeemNativeToken(_proposalId, _avatar);
2788         }
2789 
2790         if (_whatToRedeem[2]) {
2791             etherReward = redeemEther(_proposalId, _avatar);
2792         }
2793 
2794         if (_whatToRedeem[3]) {
2795             externalTokenReward = redeemExternalToken(_proposalId, _avatar);
2796         }
2797     }
2798 
2799     /**
2800     * @dev getPeriodsToPay return the periods left to be paid for reputation,nativeToken,ether or externalToken.
2801     * The function ignore the reward amount to be paid (which can be zero).
2802     * @param _proposalId the ID of the voting in the voting machine
2803     * @param _avatar address of the controller
2804     * @param _redeemType - the type of the reward  :
2805     *         0 - reputation
2806     *         1 - nativeTokenReward
2807     *         2 - Ether
2808     *         3 - ExternalToken
2809     * @return  periods left to be paid.
2810     */
2811     function getPeriodsToPay(bytes32 _proposalId, address _avatar, uint256 _redeemType) public view returns (uint256) {
2812         require(_redeemType <= 3, "should be in the redeemedPeriods range");
2813         ContributionProposal memory _proposal = organizationsProposals[_avatar][_proposalId];
2814         if (_proposal.executionTime == 0)
2815             return 0;
2816         uint256 periodsFromExecution;
2817         if (_proposal.periodLength > 0) {
2818           // solhint-disable-next-line not-rely-on-time
2819             periodsFromExecution = (now.sub(_proposal.executionTime))/(_proposal.periodLength);
2820         }
2821         uint256 periodsToPay;
2822         if ((_proposal.periodLength == 0) || (periodsFromExecution >= _proposal.numberOfPeriods)) {
2823             periodsToPay = _proposal.numberOfPeriods.sub(_proposal.redeemedPeriods[_redeemType]);
2824         } else {
2825             periodsToPay = periodsFromExecution.sub(_proposal.redeemedPeriods[_redeemType]);
2826         }
2827         return periodsToPay;
2828     }
2829 
2830     /**
2831     * @dev getRedeemedPeriods return the already redeemed periods for reputation, nativeToken, ether or externalToken.
2832     * @param _proposalId the ID of the voting in the voting machine
2833     * @param _avatar address of the controller
2834     * @param _redeemType - the type of the reward  :
2835     *         0 - reputation
2836     *         1 - nativeTokenReward
2837     *         2 - Ether
2838     *         3 - ExternalToken
2839     * @return redeemed period.
2840     */
2841     function getRedeemedPeriods(bytes32 _proposalId, address _avatar, uint256 _redeemType)
2842     public
2843     view
2844     returns (uint256) {
2845         return organizationsProposals[_avatar][_proposalId].redeemedPeriods[_redeemType];
2846     }
2847 
2848     function getProposalEthReward(bytes32 _proposalId, address _avatar) public view returns (uint256) {
2849         return organizationsProposals[_avatar][_proposalId].ethReward;
2850     }
2851 
2852     function getProposalExternalTokenReward(bytes32 _proposalId, address _avatar) public view returns (uint256) {
2853         return organizationsProposals[_avatar][_proposalId].externalTokenReward;
2854     }
2855 
2856     function getProposalExternalToken(bytes32 _proposalId, address _avatar) public view returns (address) {
2857         return address(organizationsProposals[_avatar][_proposalId].externalToken);
2858     }
2859 
2860     function getProposalExecutionTime(bytes32 _proposalId, address _avatar) public view returns (uint256) {
2861         return organizationsProposals[_avatar][_proposalId].executionTime;
2862     }
2863 
2864     /**
2865     * @dev validateProposalParams validate proposal's rewards parameters.
2866     * The function check for potential overflow upon proposal's redeem.
2867     * The function reverts if the params are not valid.
2868     * @param _reputationChange - Amount of reputation change requested .Can be negative.
2869     * @param _rewards rewards array:
2870     *         rewards[0] - Amount of tokens requested per period
2871     *         rewards[1] - Amount of ETH requested per period
2872     *         rewards[2] - Amount of external tokens requested per period
2873     *         rewards[3] - Period length - if set to zero it allows immediate redeeming after execution.
2874     *         rewards[4] - Number of periods
2875     */
2876     function validateProposalParams(int256 _reputationChange, uint[5] memory _rewards) private pure {
2877         require(((_rewards[3] > 0) || (_rewards[4] == 1)), "periodLength equal 0 require numberOfPeriods to be 1");
2878         if (_rewards[4] > 0) {
2879             // This is the only case of overflow not detected by the check below
2880             require(!(int(_rewards[4]) == -1 && _reputationChange == (-2**255)),
2881             "numberOfPeriods * _reputationChange will overflow");
2882            //check that numberOfPeriods * _reputationChange will not overflow
2883             require((int(_rewards[4]) * _reputationChange) / int(_rewards[4]) == _reputationChange,
2884             "numberOfPeriods * reputationChange will overflow");
2885             //check that numberOfPeriods * tokenReward will not overflow
2886             require((_rewards[4] * _rewards[0]) / _rewards[4] == _rewards[0],
2887             "numberOfPeriods * tokenReward will overflow");
2888             //check that numberOfPeriods * ethReward will not overflow
2889             require((_rewards[4] * _rewards[1]) / _rewards[4] == _rewards[1],
2890             "numberOfPeriods * ethReward will overflow");
2891             //check that numberOfPeriods * texternalTokenReward will not overflow
2892             require((_rewards[4] * _rewards[2]) / _rewards[4] == _rewards[2],
2893             "numberOfPeriods * texternalTokenReward will overflow");
2894         }
2895     }
2896 
2897 }