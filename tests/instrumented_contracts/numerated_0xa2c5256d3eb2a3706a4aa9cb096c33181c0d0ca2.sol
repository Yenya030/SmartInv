1 // Generated by TokenGen and the Fabric Token platform.
2 // https://tokengen.io
3 // https://fabrictoken.io
4 pragma solidity ^0.4.21;
5 
6 // File: contracts/library/SafeMath.sol
7 
8 /**
9  * @title Safe Math
10  *
11  * @dev Library for safe mathematical operations.
12  */
13 library SafeMath {
14     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
15         uint256 c = a * b;
16         assert(a == 0 || c / a == b);
17 
18         return c;
19     }
20 
21     function div(uint256 a, uint256 b) internal pure returns (uint256) {
22         uint256 c = a / b;
23 
24         return c;
25     }
26 
27     function minus(uint256 a, uint256 b) internal pure returns (uint256) {
28         assert(b <= a);
29 
30         return a - b;
31     }
32 
33     function plus(uint256 a, uint256 b) internal pure returns (uint256) {
34         uint256 c = a + b;
35         assert(c >= a);
36 
37         return c;
38     }
39 }
40 
41 // File: contracts/token/ERC20Token.sol
42 
43 /**
44  * @dev The standard ERC20 Token contract base.
45  */
46 contract ERC20Token {
47     uint256 public totalSupply;  /* shorthand for public function and a property */
48     
49     function balanceOf(address _owner) public view returns (uint256 balance);
50     function transfer(address _to, uint256 _value) public returns (bool success);
51     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
52     function approve(address _spender, uint256 _value) public returns (bool success);
53     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
54 
55     event Transfer(address indexed _from, address indexed _to, uint256 _value);
56     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
57 }
58 
59 // File: contracts/trait/HasOwner.sol
60 
61 /**
62  * @title HasOwner
63  *
64  * @dev Allows for exclusive access to certain functionality.
65  */
66 contract HasOwner {
67     // The current owner.
68     address public owner;
69 
70     // Conditionally the new owner.
71     address public newOwner;
72 
73     /**
74      * @dev The constructor.
75      *
76      * @param _owner The address of the owner.
77      */
78     constructor(address _owner) public {
79         owner = _owner;
80     }
81 
82     /** 
83      * @dev Access control modifier that allows only the current owner to call the function.
84      */
85     modifier onlyOwner {
86         require(msg.sender == owner);
87         _;
88     }
89 
90     /**
91      * @dev The event is fired when the current owner is changed.
92      *
93      * @param _oldOwner The address of the previous owner.
94      * @param _newOwner The address of the new owner.
95      */
96     event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner);
97 
98     /**
99      * @dev Transfering the ownership is a two-step process, as we prepare
100      * for the transfer by setting `newOwner` and requiring `newOwner` to accept
101      * the transfer. This prevents accidental lock-out if something goes wrong
102      * when passing the `newOwner` address.
103      *
104      * @param _newOwner The address of the proposed new owner.
105      */
106     function transferOwnership(address _newOwner) public onlyOwner {
107         newOwner = _newOwner;
108     }
109  
110     /**
111      * @dev The `newOwner` finishes the ownership transfer process by accepting the
112      * ownership.
113      */
114     function acceptOwnership() public {
115         require(msg.sender == newOwner);
116 
117         emit OwnershipTransfer(owner, newOwner);
118 
119         owner = newOwner;
120     }
121 }
122 
123 // File: contracts/fundraiser/AbstractFundraiser.sol
124 
125 contract AbstractFundraiser {
126     /// The ERC20 token contract.
127     ERC20Token public token;
128 
129     /**
130      * @dev The event fires every time a new buyer enters the fundraiser.
131      *
132      * @param _address The address of the buyer.
133      * @param _ethers The number of ethers funded.
134      * @param _tokens The number of tokens purchased.
135      */
136     event FundsReceived(address indexed _address, uint _ethers, uint _tokens);
137 
138 
139     /**
140      * @dev The initialization method for the token
141      *
142      * @param _token The address of the token of the fundraiser
143      */
144     function initializeFundraiserToken(address _token) internal
145     {
146         token = ERC20Token(_token);
147     }
148 
149     /**
150      * @dev The default function which is executed when someone sends funds to this contract address.
151      */
152     function() public payable {
153         receiveFunds(msg.sender, msg.value);
154     }
155 
156     /**
157      * @dev this overridable function returns the current conversion rate for the fundraiser
158      */
159     function getConversionRate() public view returns (uint256);
160 
161     /**
162      * @dev checks whether the fundraiser passed `endTime`.
163      *
164      * @return whether the fundraiser has ended.
165      */
166     function hasEnded() public view returns (bool);
167 
168     /**
169      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
170      *
171      * @param _address The address of the receiver of tokens.
172      * @param _amount The amount of received funds in ether.
173      */
174     function receiveFunds(address _address, uint256 _amount) internal;
175     
176     /**
177      * @dev It throws an exception if the transaction does not meet the preconditions.
178      */
179     function validateTransaction() internal view;
180     
181     /**
182      * @dev this overridable function makes and handles tokens to buyers
183      */
184     function handleTokens(address _address, uint256 _tokens) internal;
185 
186     /**
187      * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary
188      */
189     function handleFunds(address _address, uint256 _ethers) internal;
190 
191 }
192 
193 // File: contracts/fundraiser/BasicFundraiser.sol
194 
195 /**
196  * @title Basic Fundraiser
197  *
198  * @dev An abstract contract that is a base for fundraisers. 
199  * It implements a generic procedure for handling received funds:
200  * 1. Validates the transaciton preconditions
201  * 2. Calculates the amount of tokens based on the conversion rate.
202  * 3. Delegate the handling of the tokens (mint, transfer or conjure)
203  * 4. Delegate the handling of the funds
204  * 5. Emit event for received funds
205  */
206 contract BasicFundraiser is HasOwner, AbstractFundraiser {
207     using SafeMath for uint256;
208 
209     // The number of decimals for the token.
210     uint8 constant DECIMALS = 18;  // Enforced
211 
212     // Decimal factor for multiplication purposes.
213     uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS);
214 
215     /// The start time of the fundraiser - Unix timestamp.
216     uint256 public startTime;
217 
218     /// The end time of the fundraiser - Unix timestamp.
219     uint256 public endTime;
220 
221     /// The address where funds collected will be sent.
222     address public beneficiary;
223 
224     /// The conversion rate with decimals difference adjustment,
225     /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division
226     uint256 public conversionRate;
227 
228     /// The total amount of ether raised.
229     uint256 public totalRaised;
230 
231     /**
232      * @dev The event fires when the number of token conversion rate has changed.
233      *
234      * @param _conversionRate The new number of tokens per 1 ether.
235      */
236     event ConversionRateChanged(uint _conversionRate);
237 
238     /**
239      * @dev The basic fundraiser initialization method.
240      *
241      * @param _startTime The start time of the fundraiser - Unix timestamp.
242      * @param _endTime The end time of the fundraiser - Unix timestamp.
243      * @param _conversionRate The number of tokens create for 1 ETH funded.
244      * @param _beneficiary The address which will receive the funds gathered by the fundraiser.
245      */
246     function initializeBasicFundraiser(
247         uint256 _startTime,
248         uint256 _endTime,
249         uint256 _conversionRate,
250         address _beneficiary
251     )
252         internal
253     {
254         require(_endTime >= _startTime);
255         require(_conversionRate > 0);
256         require(_beneficiary != address(0));
257 
258         startTime = _startTime;
259         endTime = _endTime;
260         conversionRate = _conversionRate;
261         beneficiary = _beneficiary;
262     }
263 
264     /**
265      * @dev Sets the new conversion rate
266      *
267      * @param _conversionRate New conversion rate
268      */
269     function setConversionRate(uint256 _conversionRate) public onlyOwner {
270         require(_conversionRate > 0);
271 
272         conversionRate = _conversionRate;
273 
274         emit ConversionRateChanged(_conversionRate);
275     }
276 
277     /**
278      * @dev Sets The beneficiary of the fundraiser.
279      *
280      * @param _beneficiary The address of the beneficiary.
281      */
282     function setBeneficiary(address _beneficiary) public onlyOwner {
283         require(_beneficiary != address(0));
284 
285         beneficiary = _beneficiary;
286     }
287 
288     /**
289      * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`.
290      *
291      * @param _address The address of the receiver of tokens.
292      * @param _amount The amount of received funds in ether.
293      */
294     function receiveFunds(address _address, uint256 _amount) internal {
295         validateTransaction();
296 
297         uint256 tokens = calculateTokens(_amount);
298         require(tokens > 0);
299 
300         totalRaised = totalRaised.plus(_amount);
301         handleTokens(_address, tokens);
302         handleFunds(_address, _amount);
303 
304         emit FundsReceived(_address, msg.value, tokens);
305     }
306 
307     /**
308      * @dev this overridable function returns the current conversion rate for the fundraiser
309      */
310     function getConversionRate() public view returns (uint256) {
311         return conversionRate;
312     }
313 
314     /**
315      * @dev this overridable function that calculates the tokens based on the ether amount
316      */
317     function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) {
318         tokens = _amount.mul(getConversionRate());
319     }
320 
321     /**
322      * @dev It throws an exception if the transaction does not meet the preconditions.
323      */
324     function validateTransaction() internal view {
325         require(msg.value != 0);
326         require(now >= startTime && now < endTime);
327     }
328 
329     /**
330      * @dev checks whether the fundraiser passed `endtime`.
331      *
332      * @return whether the fundraiser is passed its deadline or not.
333      */
334     function hasEnded() public view returns (bool) {
335         return now >= endTime;
336     }
337 }
338 
339 // File: contracts/fundraiser/CappedFundraiser.sol
340 
341 /**
342  * @title Capped Fundraiser
343  *
344  * @dev Allows you to set a hard cap on your fundraiser.
345  */
346 contract CappedFundraiser is BasicFundraiser {
347     /// The maximum amount of ether allowed for the fundraiser.
348     uint256 public hardCap;
349 
350     /**
351      * @dev The initialization method.
352      *
353      * @param _hardCap The maximum amount of ether allowed to be raised.
354      */
355     function initializeCappedFundraiser(uint256 _hardCap) internal {
356         require(_hardCap > 0);
357 
358         hardCap = _hardCap;
359     }
360 
361     /**
362      * @dev Adds additional check if the hard cap has been reached.
363      *
364      * @return Whether the token purchase will be allowed.
365      */
366     function validateTransaction() internal view {
367         super.validateTransaction();
368         require(totalRaised < hardCap);
369     }
370 
371     /**
372      * @dev Overrides the method from the default `Fundraiser` contract
373      * to additionally check if the `hardCap` is reached.
374      *
375      * @return Whether or not the fundraiser has ended.
376      */
377     function hasEnded() public view returns (bool) {
378         return (super.hasEnded() || totalRaised >= hardCap);
379     }
380 }
381 
382 // File: contracts/fundraiser/ForwardFundsFundraiser.sol
383 
384 /**
385  * @title Forward Funds to Beneficiary Fundraiser
386  *
387  * @dev This contract forwards the funds received to the beneficiary.
388  */
389 contract ForwardFundsFundraiser is BasicFundraiser {
390     /**
391      * @dev Forward funds directly to beneficiary
392      */
393     function handleFunds(address, uint256 _ethers) internal {
394         // Forward the funds directly to the beneficiary
395         beneficiary.transfer(_ethers);
396     }
397 }
398 
399 // File: contracts/fundraiser/GasPriceLimitFundraiser.sol
400 
401 /**
402  * @title GasPriceLimitFundraiser
403  *
404  * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser
405  */
406 contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser {
407     uint256 public gasPriceLimit;
408 
409     event GasPriceLimitChanged(uint256 gasPriceLimit);
410 
411     /**
412      * @dev This function puts the initial gas limit
413      */
414     function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal {
415         gasPriceLimit = _gasPriceLimit;
416     }
417 
418     /**
419      * @dev This function allows the owner to change the gas limit any time during the fundraiser
420      */
421     function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public {
422         gasPriceLimit = _gasPriceLimit;
423 
424         emit GasPriceLimitChanged(_gasPriceLimit);
425     }
426 
427     /**
428      * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement
429      */
430     function validateTransaction() internal view {
431         require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit);
432 
433         return super.validateTransaction();
434     }
435 }
436 
437 // File: contracts/fundraiser/IndividualCapsFundraiser.sol
438 
439 /**
440  * @title Fundraiser with individual caps
441  *
442  * @dev Allows you to set a hard cap on your fundraiser.
443  */
444 contract IndividualCapsFundraiser is BasicFundraiser {
445     uint256 public individualMinCap;
446     uint256 public individualMaxCap;
447     uint256 public individualMaxCapTokens;
448 
449 
450     event IndividualMinCapChanged(uint256 _individualMinCap);
451     event IndividualMaxCapTokensChanged(uint256 _individualMaxCapTokens);
452 
453     /**
454      * @dev The initialization method.
455      *
456      * @param _individualMinCap The minimum amount of ether contribution per address.
457      * @param _individualMaxCap The maximum amount of ether contribution per address.
458      */
459     function initializeIndividualCapsFundraiser(uint256 _individualMinCap, uint256 _individualMaxCap) internal {
460         individualMinCap = _individualMinCap;
461         individualMaxCap = _individualMaxCap;
462         individualMaxCapTokens = _individualMaxCap * conversionRate;
463     }
464 
465     function setConversionRate(uint256 _conversionRate) public onlyOwner {
466         super.setConversionRate(_conversionRate);
467 
468         if (individualMaxCap == 0) {
469             return;
470         }
471         
472         individualMaxCapTokens = individualMaxCap * _conversionRate;
473 
474         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
475     }
476 
477     function setIndividualMinCap(uint256 _individualMinCap) public onlyOwner {
478         individualMinCap = _individualMinCap;
479 
480         emit IndividualMinCapChanged(individualMinCap);
481     }
482 
483     function setIndividualMaxCap(uint256 _individualMaxCap) public onlyOwner {
484         individualMaxCap = _individualMaxCap;
485         individualMaxCapTokens = _individualMaxCap * conversionRate;
486 
487         emit IndividualMaxCapTokensChanged(individualMaxCapTokens);
488     }
489 
490     /**
491      * @dev Extends the transaction validation to check if the value this higher than the minumum cap.
492      */
493     function validateTransaction() internal view {
494         super.validateTransaction();
495         require(msg.value >= individualMinCap);
496     }
497 
498     /**
499      * @dev We validate the new amount doesn't surpass maximum contribution cap
500      */
501     function handleTokens(address _address, uint256 _tokens) internal {
502         require(individualMaxCapTokens == 0 || token.balanceOf(_address).plus(_tokens) <= individualMaxCapTokens);
503 
504         super.handleTokens(_address, _tokens);
505     }
506 }
507 
508 // File: contracts/token/StandardToken.sol
509 
510 /**
511  * @title Standard Token
512  *
513  * @dev The standard abstract implementation of the ERC20 interface.
514  */
515 contract StandardToken is ERC20Token {
516     using SafeMath for uint256;
517 
518     string public name;
519     string public symbol;
520     uint8 public decimals;
521     
522     mapping (address => uint256) balances;
523     mapping (address => mapping (address => uint256)) internal allowed;
524     
525     /**
526      * @dev The constructor assigns the token name, symbols and decimals.
527      */
528     constructor(string _name, string _symbol, uint8 _decimals) internal {
529         name = _name;
530         symbol = _symbol;
531         decimals = _decimals;
532     }
533 
534     /**
535      * @dev Get the balance of an address.
536      *
537      * @param _address The address which's balance will be checked.
538      *
539      * @return The current balance of the address.
540      */
541     function balanceOf(address _address) public view returns (uint256 balance) {
542         return balances[_address];
543     }
544 
545     /**
546      * @dev Checks the amount of tokens that an owner allowed to a spender.
547      *
548      * @param _owner The address which owns the funds allowed for spending by a third-party.
549      * @param _spender The third-party address that is allowed to spend the tokens.
550      *
551      * @return The number of tokens available to `_spender` to be spent.
552      */
553     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
554         return allowed[_owner][_spender];
555     }
556 
557     /**
558      * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf.
559      * E.g. You place a buy or sell order on an exchange and in that example, the 
560      * `_spender` address is the address of the contract the exchange created to add your token to their 
561      * website and you are `msg.sender`.
562      *
563      * @param _spender The address which will spend the funds.
564      * @param _value The amount of tokens to be spent.
565      *
566      * @return Whether the approval process was successful or not.
567      */
568     function approve(address _spender, uint256 _value) public returns (bool) {
569         allowed[msg.sender][_spender] = _value;
570 
571         emit Approval(msg.sender, _spender, _value);
572 
573         return true;
574     }
575 
576     /**
577      * @dev Transfers `_value` number of tokens to the `_to` address.
578      *
579      * @param _to The address of the recipient.
580      * @param _value The number of tokens to be transferred.
581      */
582     function transfer(address _to, uint256 _value) public returns (bool) {
583         executeTransfer(msg.sender, _to, _value);
584 
585         return true;
586     }
587 
588     /**
589      * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address.
590      *
591      * @param _from The address which approved you to spend tokens on their behalf.
592      * @param _to The address where you want to send tokens.
593      * @param _value The number of tokens to be sent.
594      *
595      * @return Whether the transfer was successful or not.
596      */
597     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
598         require(_value <= allowed[_from][msg.sender]);
599         
600         allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value);
601         executeTransfer(_from, _to, _value);
602 
603         return true;
604     }
605 
606     /**
607      * @dev Internal function that this reused by the transfer functions
608      */
609     function executeTransfer(address _from, address _to, uint256 _value) internal {
610         require(_to != address(0));
611         require(_value != 0 && _value <= balances[_from]);
612         
613         balances[_from] = balances[_from].minus(_value);
614         balances[_to] = balances[_to].plus(_value);
615 
616         emit Transfer(_from, _to, _value);
617     }
618 }
619 
620 // File: contracts/token/MintableToken.sol
621 
622 /**
623  * @title Mintable Token
624  *
625  * @dev Allows the creation of new tokens.
626  */
627 contract MintableToken is StandardToken {
628     /// @dev The only address allowed to mint coins
629     address public minter;
630 
631     /// @dev Indicates whether the token is still mintable.
632     bool public mintingDisabled = false;
633 
634     /**
635      * @dev Event fired when minting is no longer allowed.
636      */
637     event MintingDisabled();
638 
639     /**
640      * @dev Allows a function to be executed only if minting is still allowed.
641      */
642     modifier canMint() {
643         require(!mintingDisabled);
644         _;
645     }
646 
647     /**
648      * @dev Allows a function to be called only by the minter
649      */
650     modifier onlyMinter() {
651         require(msg.sender == minter);
652         _;
653     }
654 
655     /**
656      * @dev The constructor assigns the minter which is allowed to mind and disable minting
657      */
658     constructor(address _minter) internal {
659         minter = _minter;
660     }
661 
662     /**
663     * @dev Creates new `_value` number of tokens and sends them to the `_to` address.
664     *
665     * @param _to The address which will receive the freshly minted tokens.
666     * @param _value The number of tokens that will be created.
667     */
668     function mint(address _to, uint256 _value) onlyMinter canMint public {
669         totalSupply = totalSupply.plus(_value);
670         balances[_to] = balances[_to].plus(_value);
671 
672         emit Transfer(0x0, _to, _value);
673     }
674 
675     /**
676     * @dev Disable the minting of new tokens. Cannot be reversed.
677     *
678     * @return Whether or not the process was successful.
679     */
680     function disableMinting() onlyMinter canMint public {
681         mintingDisabled = true;
682        
683         emit MintingDisabled();
684     }
685 }
686 
687 // File: contracts/token/StandardMintableToken.sol
688 
689 contract StandardMintableToken is MintableToken {
690     constructor(address _minter, string _name, string _symbol, uint8 _decimals)
691         StandardToken(_name, _symbol, _decimals)
692         MintableToken(_minter)
693         public
694     {
695     }
696 }
697 
698 // File: contracts/fundraiser/MintableTokenFundraiser.sol
699 
700 /**
701  * @title Fundraiser With Mintable Token
702  */
703 contract MintableTokenFundraiser is BasicFundraiser {
704     /**
705      * @dev The initialization method that creates a new mintable token.
706      *
707      * @param _name Token name
708      * @param _symbol Token symbol
709      * @param _decimals Token decimals
710      */
711     function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal {
712         token = new StandardMintableToken(
713             address(this), // The fundraiser is the token minter
714             _name,
715             _symbol,
716             _decimals
717         );
718     }
719 
720     /**
721      * @dev Mint the specific amount tokens
722      */
723     function handleTokens(address _address, uint256 _tokens) internal {
724         MintableToken(token).mint(_address, _tokens);
725     }
726 }
727 
728 // File: contracts/token/BurnableToken.sol
729 
730 /**
731  * @title Burnable Token
732  *
733  * @dev Allows tokens to be destroyed.
734  */
735 contract BurnableToken is StandardToken {
736     /**
737      * @dev Event fired when tokens are burned.
738      *
739      * @param _from The address from which tokens will be removed.
740      * @param _value The number of tokens to be destroyed.
741      */
742     event Burn(address indexed _from, uint256 _value);
743 
744     /**
745      * @dev Burnes `_value` number of tokens.
746      *
747      * @param _value The number of tokens that will be burned.
748      */
749     function burn(uint256 _value) public {
750         require(_value != 0);
751 
752         address burner = msg.sender;
753         require(_value <= balances[burner]);
754 
755         balances[burner] = balances[burner].minus(_value);
756         totalSupply = totalSupply.minus(_value);
757 
758         emit Burn(burner, _value);
759         emit Transfer(burner, address(0), _value);
760     }
761 }
762 
763 // File: contracts/Fundraiser.sol
764 
765 /**
766  * @title FAVOURToken
767  */
768  
769 contract FAVOURToken is MintableToken, BurnableToken {
770   constructor(address _minter)
771     StandardToken(
772       "FAVOUR",   // Token name
773       "FVR", // Token symbol
774       18  // Token decimals
775     )
776     
777     MintableToken(_minter)
778     public
779   {
780   }
781 }
782 
783 
784 
785 /**
786  * @title FAVOURTokenFundraiser
787  */
788 
789 contract FAVOURTokenFundraiser is MintableTokenFundraiser, IndividualCapsFundraiser, CappedFundraiser, ForwardFundsFundraiser, GasPriceLimitFundraiser {
790   
791 
792   constructor()
793     HasOwner(msg.sender)
794     public
795   {
796     token = new FAVOURToken(
797       
798       address(this)  // The fundraiser is the minter
799     );
800 
801     
802 
803     initializeBasicFundraiser(
804       1529854200, // Start date = 24 Jun 2018 15:30 UTC
805       1534334400,  // End date = 15 Aug 2018 12:00 UTC
806       25000, // Conversion rate = 25000 FVR per 1 ether
807       0x88FE3A52C66CD0158643A1C1B7572b42932133A4     // Beneficiary
808     );
809 
810     initializeIndividualCapsFundraiser(
811       (0.001 ether), // Minimum contribution
812       (50 ether)  // Maximum individual cap
813     );
814 
815     initializeGasPriceLimitFundraiser(
816         50000000000 // Gas price limit in wei
817     );
818 
819     
820 
821     initializeCappedFundraiser(
822       (204 ether) // Hard cap
823     );
824 
825     
826     
827     
828   }
829   
830 }