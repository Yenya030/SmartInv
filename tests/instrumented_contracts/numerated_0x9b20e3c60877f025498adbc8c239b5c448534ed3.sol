1 /*
2     SPARK
3 
4 
5        ,,H`           `.`````.`.'``':`;;;r)k]g$$M'&&@WWu0@m"RR@&&NDRNN@HHHHUHHHHUHHHHHUHHHHHHHHHUUHHUUUU
6       '"`".          ,:,`````.,.`'';';;j]q&@@&D`["`'``````"*\"RMH&&$@@@@@pH]]@@@@@@@@@@@@@@@@@HHHHHHHHHH
7           `,        ,r''```'':```';;;r]]$M]%M` ' ~~~****Hr~~~"`"g*#@&&$@]@HH]@@@@@@@@H@@@@@@@@@@HHHHHHHH
8            `~~~~~~~]r''````':`''::~*rH]@HH*,", r   r    [,;;]%=,R, "R&&NUR@@HHHHHHHHH@@@@@@@@@@HHHHHHHHH
9            ''```'"`'"'````':``''/:,;m]]U,,[;"` :` ',   .::';'[:]]H@,.]R&&@@@H@@@@@@@HH%@@@@H@HHH@HHHHHHH
10          ,r``       `','`':``''*';;;r]]KHk`:`'`:``.:`  ';,;,;:'(H]H%m`j&$&@@@@@@@@@@HHH]HHHHHHHHmHHHHHHH
11     **UHHr'`    ``````,`"'"```:`:;;jr]]@H'[,.`.,"'`;.'.,H,H';[,]:g]]%@,'R&B@@R@@@@HHHH@H]%%%%%[k]HHHHHHH
12        `''`     `|```/!`|```'':`,;j)m[]H],]```  ````'`]:,r`'`',:]%]]H]W']R$$&N@@@@HHH@U]HHHhUUjr]]HHHHHH
13                  '',['':|``''':'::)j]]pHj@~`'.,,;ppppq@g@@p@@pp;;;*][]&Hw]8&$&@]@%H@@r]HHHhr;:'jmm]HHHHH
14            ,`'  "]%%H::'|``'''':'H]]]]@HU::,:;\HH@@@@&$&$&8&@@@HHprjr]@H]@.&B&@@H[p[k]HHHhmr'::;]H][[][]
15           .``    `:;,.::|```''',[)h]]%@]H:]m;)k]]K@@&&$$$$$&@@@@H%@m]@@[']mH3&$@m@HHHm]]Hh[r`::;r"*]%%"'
16          :``'`    `;;';,``````)Ukk)]H]@BHp[;:;;j]]]KHR@@@@@@HHHHHp@@@&@[:']K:j&$@@@H[[pjUh(r:':',,:`'"
17         '`|`'`    'jjhr:::':'jjrj;jmU]R@@&mH;;;;;jj]]]]%%HHHHHHHH]B$@&@[''`jK%@$&@@@HHHrm;;,,.,']h,,`
18     ,  ..,r`'     ''jH,':|````:;,j)#Q%]]$$@::,,;;)]]H]]@@@@@@@UUUUg&$MMB@['.jN&&&$@HNH;][rr':''``'`;,`
19     ;,.,]mmp,    ,,xU:'''''|``'';:j],[`,&$$N""^*H]]HHH]HHH%%MM"""j&$&mr]q;'' "B@$$[HU]mrr;``'.` ` .];``
20     HH,]]@HH`   `jj['''''''||``']'jmK,,]&M%RM"     ''"jr`'    ``""jR&[;pH]''`''$@%@@:"[r;':;m;'```]@Hp:,
21     HHj]K@Hh'    `';`  `''''|``/",';]Bw]$H,,  .,,,   jg@'  ,,,q~,p@H@[%m[]:,`..`]H&H[n':'''''' '  ]@Hhr`
22     *''j]%hH'    ``;``   `''''' '!`;rj8o8[@]p,.,",j%h]&&@@H||,,p@@@m@]@H@];``'j'j]@[[r,``'''     j]@Hh`:
23     `  ']][r`    `';`.  '''''': ``::;j;]]m*m"M@Hj8@HU]R@@%&&UjwMUK"][;|@%[('`]]~']][k;",:;``     ]%&Hr``
24        ``j[`      `:'  `'''''||' `'!'jr]]BN::j]"H][r,@$$Nr]"*]H[r,g&@j$@Hj@',]@``]@[r',`':,       ]@H`
25         ``;:      `"  ````'''''||. '''':']$H:;;rh@@/'""^"jp@@UH[jo&%N]B&]@{%@@[.;]%[~::'`'`       j["
26         `:.'      ':   `````.'''' '`'`j;]%&&m'`jj]K@.,`,u&&@Hhk;']BH&@B&]HM'j%'.,jK:,`"`''``      ':`
27          ``       ```   ```'`.,` '|``:.]]]@R@@'''*]%M"*MTMHMj:'jMj&@&H&@]H::,[`::]H::; `':,        '`
28                       `         '''''':]]H)]$0N:';;;mn@mmHHH'::,@r]&B[&[[::jr'j;]@'':'!   ,
29             ,p,         ```````  '''`';]j\pM['"H,'``,',,,',,,x"'M**R@@@]Hj:'['`j@[`"wr`;`"''`
30             `"'           ``````  ``;m"*r',',,,,,]p;j]]%%(;(;,,`,w,',~""`'w,`;j@%::'``:`:.`
31                              ```,NfW"`,wm,gwM*""""""""""""""""""MH;"\$j*,"\"~]HA\,,, ``''`` `,,
32                              ```]h''^&*]@M`                        %'"MM`  "]Ma[''\,,  .''``,]n,
33          `                `.,`,am'` '`]8" ,wgM"   ```,AAAA&^  ""*Hm ]pM",~j"^MW;'`''`'. ''*`'''`].
34                       ' .,w@@%hM"".`  $$   "``    ``,$$$$P`   ,,     &'    `']%RR&gw;'` ;:...    '`
35                 ,wH"%]@D"%@@@@H@@'    $$    r`,.`'`j&$$$^ ;`  ~~."  j$H, ,,,g&&$&8&@@@B&&&&W,``,'
36               ,$@H(*H@H]HHh"*^%Ur,r ' [$ ` j%'` .',$$$P  ]H`r  .'*  j$M,.[/%@@R@@%%@%M]@RR@@@&W``
37              &M^,.`]H%jn***,,,,'''    $$       `.,g$$$$$$"] ,,,     j&'`"'`"[""jjh,;p@[:;"'M%%R&,
38          ,` 8U` :`''",:`:,',Hmrrh   ' $$      ,,`]   A$F ][']r;;,,,.j&H]@@``]@@@@[pjH"::'*.`'*""8.`
39         :' a[:'```,;';o*Up,;]k][   /,'$$ ;jj]%Hmj%HH&P`,]H[ ]@HMM%j[j&HHj@N``]&@@Q%@,.'"```   ``]@`
40           ]H''.`  `:',,r";]UUHH'  ]H`/'$b,"hp,,: ]]8',p@@@H ],;pp@@NF"$@@"&N''j$&&@@@w[*,,`;'; '`]b
41           @r'      '``,mrj]]]@M  ]M,@]p"B&[N;"R@~R",g@@@@%[ R@@@&&&U`""&&@/BW'`]&@@@@HHHHw'.':``']8~
42          ]H:`        :```::j]*  /`]UUU@@,"R$WB@w""@@@@HHHH[ ]@@@&$&@wp@$$$&W"K`,]@@@HU*"'"``` '''j]m
43          ]:`             `:''  '.]]H@@@@@@p.,"*P4&&RRRRRRRR&RRRRRRRRW,A&$$$&&@',`j@HUr`     `  '`"jK`
44          *`               ``       "MMM********^*                     ^*P**" ``   ***`             *
45       
46 */
47 
48 // SPDX-License-Identifier: MIT
49 
50 pragma solidity 0.8.18;
51 
52 abstract contract Context {
53     function _msgSender() internal view virtual returns (address) {
54         return msg.sender;
55     }
56 
57     function _msgData() internal view virtual returns (bytes calldata) {
58         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
59         return msg.data;
60     }
61 }
62 
63 interface IERC20 {
64     /**
65      * @dev Returns the amount of tokens in existence.
66      */
67     function totalSupply() external view returns (uint256);
68 
69     /**
70      * @dev Returns the amount of tokens owned by `account`.
71      */
72     function balanceOf(address account) external view returns (uint256);
73 
74     /**
75      * @dev Moves `amount` tokens from the caller's account to `recipient`.
76      *
77      * Returns a boolean value indicating whether the operation succeeded.
78      *
79      * Emits a {Transfer} event.
80      */
81     function transfer(address recipient, uint256 amount)
82         external
83         returns (bool);
84 
85     /**
86      * @dev Returns the remaining number of tokens that `spender` will be
87      * allowed to spend on behalf of `owner` through {transferFrom}. This is
88      * zero by default.
89      *
90      * This value changes when {approve} or {transferFrom} are called.
91      */
92     function allowance(address owner, address spender)
93         external
94         view
95         returns (uint256);
96 
97     /**
98      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
99      *
100      * Returns a boolean value indicating whether the operation succeeded.
101      *
102      * IMPORTANT: Beware that changing an allowance with this method brings the risk
103      * that someone may use both the old and the new allowance by unfortunate
104      * transaction ordering. One possible solution to mitigate this race
105      * condition is to first reduce the spender's allowance to 0 and set the
106      * desired value afterwards:
107      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
108      *
109      * Emits an {Approval} event.
110      */
111     function approve(address spender, uint256 amount) external returns (bool);
112 
113     /**
114      * @dev Moves `amount` tokens from `sender` to `recipient` using the
115      * allowance mechanism. `amount` is then deducted from the caller's
116      * allowance.
117      *
118      * Returns a boolean value indicating whether the operation succeeded.
119      *
120      * Emits a {Transfer} event.
121      */
122     function transferFrom(
123         address sender,
124         address recipient,
125         uint256 amount
126     ) external returns (bool);
127 
128     /**
129      * @dev Emitted when `value` tokens are moved from one account (`from`) to
130      * another (`to`).
131      *
132      * Note that `value` may be zero.
133      */
134     event Transfer(address indexed from, address indexed to, uint256 value);
135 
136     /**
137      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
138      * a call to {approve}. `value` is the new allowance.
139      */
140     event Approval(
141         address indexed owner,
142         address indexed spender,
143         uint256 value
144     );
145 }
146 
147 interface IERC20Metadata is IERC20 {
148     /**
149      * @dev Returns the name of the token.
150      */
151     function name() external view returns (string memory);
152 
153     /**
154      * @dev Returns the symbol of the token.
155      */
156     function symbol() external view returns (string memory);
157 
158     /**
159      * @dev Returns the decimals places of the token.
160      */
161     function decimals() external view returns (uint8);
162 }
163 
164 contract ERC20 is Context, IERC20, IERC20Metadata {
165     mapping(address => uint256) internal _balances;
166 
167     mapping(address => mapping(address => uint256)) private _allowances;
168 
169     uint256 internal _totalSupply;
170 
171     string private _name;
172     string private _symbol;
173 
174     constructor(string memory name_, string memory symbol_) {
175         _name = name_;
176         _symbol = symbol_;
177     }
178 
179     function name() public view virtual override returns (string memory) {
180         return _name;
181     }
182 
183     function symbol() public view virtual override returns (string memory) {
184         return _symbol;
185     }
186 
187     function decimals() public view virtual override returns (uint8) {
188         return 18;
189     }
190 
191     function totalSupply() public view virtual override returns (uint256) {
192         return _totalSupply;
193     }
194 
195     function balanceOf(address account)
196         public
197         view
198         virtual
199         override
200         returns (uint256)
201     {
202         return _balances[account];
203     }
204 
205     function transfer(address recipient, uint256 amount)
206         public
207         virtual
208         override
209         returns (bool)
210     {
211         _transfer(_msgSender(), recipient, amount);
212         return true;
213     }
214 
215     function allowance(address owner, address spender)
216         public
217         view
218         virtual
219         override
220         returns (uint256)
221     {
222         return _allowances[owner][spender];
223     }
224 
225     function approve(address spender, uint256 amount)
226         public
227         virtual
228         override
229         returns (bool)
230     {
231         _approve(_msgSender(), spender, amount);
232         return true;
233     }
234 
235     function transferFrom(
236         address sender,
237         address recipient,
238         uint256 amount
239     ) public virtual override returns (bool) {
240         _transfer(sender, recipient, amount);
241 
242         uint256 currentAllowance = _allowances[sender][_msgSender()];
243         if(currentAllowance != type(uint256).max) { 
244             require(
245                 currentAllowance >= amount,
246                 "ERC20: transfer amount exceeds allowance"
247             );
248             unchecked {
249                 _approve(sender, _msgSender(), currentAllowance - amount);
250             }
251         }
252         return true;
253     }
254 
255     function increaseAllowance(address spender, uint256 addedValue)
256         public
257         virtual
258         returns (bool)
259     {
260         _approve(
261             _msgSender(),
262             spender,
263             _allowances[_msgSender()][spender] + addedValue
264         );
265         return true;
266     }
267 
268     function decreaseAllowance(address spender, uint256 subtractedValue)
269         public
270         virtual
271         returns (bool)
272     {
273         uint256 currentAllowance = _allowances[_msgSender()][spender];
274         require(
275             currentAllowance >= subtractedValue,
276             "ERC20: decreased allowance below zero"
277         );
278         unchecked {
279             _approve(_msgSender(), spender, currentAllowance - subtractedValue);
280         }
281 
282         return true;
283     }
284 
285     function _transfer(
286         address sender,
287         address recipient,
288         uint256 amount
289     ) internal virtual {
290         require(sender != address(0), "ERC20: transfer from the zero address");
291         require(recipient != address(0), "ERC20: transfer to the zero address");
292 
293         uint256 senderBalance = _balances[sender];
294         require(
295             senderBalance >= amount,
296             "ERC20: transfer amount exceeds balance"
297         );
298         unchecked {
299             _balances[sender] = senderBalance - amount;
300         }
301         _balances[recipient] += amount;
302 
303         emit Transfer(sender, recipient, amount);
304     }
305 
306     function _approve(
307         address owner,
308         address spender,
309         uint256 amount
310     ) internal virtual {
311         require(owner != address(0), "ERC20: approve from the zero address");
312         require(spender != address(0), "ERC20: approve to the zero address");
313 
314         _allowances[owner][spender] = amount;
315         emit Approval(owner, spender, amount);
316     }
317 }
318 
319 contract Ownable is Context {
320     address private _owner;
321 
322     event OwnershipTransferred(
323         address indexed previousOwner,
324         address indexed newOwner
325     );
326 
327     constructor() {
328         address msgSender = _msgSender();
329         _owner = msgSender;
330         emit OwnershipTransferred(address(0), msgSender);
331     }
332 
333     function owner() public view returns (address) {
334         return _owner;
335     }
336 
337     modifier onlyOwner() {
338         require(_owner == _msgSender(), "Ownable: caller is not the owner");
339         _;
340     }
341 
342     function renounceOwnership() public virtual onlyOwner {
343         emit OwnershipTransferred(_owner, address(0));
344         _owner = address(0);
345     }
346 
347     function transferOwnership(address newOwner) public virtual onlyOwner {
348         require(
349             newOwner != address(0),
350             "Ownable: new owner is the zero address"
351         );
352         emit OwnershipTransferred(_owner, newOwner);
353         _owner = newOwner;
354     }
355 }
356 
357 interface IDexRouter {
358     function factory() external pure returns (address);
359 
360     function WETH() external pure returns (address);
361 
362     function swapExactTokensForETHSupportingFeeOnTransferTokens(
363         uint256 amountIn,
364         uint256 amountOutMin,
365         address[] calldata path,
366         address to,
367         uint256 deadline
368     ) external;
369 
370     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
371         uint256 amountIn,
372         uint256 amountOutMin,
373         address[] calldata path,
374         address to,
375         uint256 deadline
376     ) external;
377 
378     function addLiquidity(
379         address tokenA,
380         address tokenB,
381         uint amountADesired,
382         uint amountBDesired,
383         uint amountAMin,
384         uint amountBMin,
385         address to,
386         uint deadline
387     ) external returns (uint amountA, uint amountB, uint liquidity);
388 
389     function addLiquidityETH(
390         address token,
391         uint256 amountTokenDesired,
392         uint256 amountTokenMin,
393         uint256 amountETHMin,
394         address to,
395         uint256 deadline
396     )
397         external
398         payable
399         returns (
400             uint256 amountToken,
401             uint256 amountETH,
402             uint256 liquidity
403         );
404     
405     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
406         external
407         payable
408         returns (uint[] memory amounts);
409 
410     function swapExactETHForTokensSupportingFeeOnTransferTokens(
411         uint amountOutMin,
412         address[] calldata path,
413         address to,
414         uint deadline
415     ) external payable;
416 }
417 
418 interface IDexFactory {
419     function createPair(address tokenA, address tokenB)
420         external
421         returns (address pair);
422 }
423 
424 interface IAntiSnipe {
425   function setTokenOwner(address owner, address pair) external;
426 
427   function onPreTransferCheck(
428     address sender,
429     address from,
430     address to,
431     uint256 amount
432   ) external returns (bool checked);
433 }
434 
435 contract Spark is ERC20, Ownable {
436     IDexRouter public immutable dexRouter;
437     mapping(address => bool) public pairs;
438     address public lpPair;
439     address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
440 
441     uint8 constant _decimals = 9;
442     uint256 constant _decimalFactor = 10 ** _decimals;
443 
444     bool private swapping;
445 
446     uint256 public swapTokensAtAmount;
447     bool public swapEnabled = true;
448 
449     address public taxAddress;
450     bool public buyTaxEnabled;
451     bool public sellTaxEnabled;
452     uint256 deadBlocks;
453     uint256 public walletLimit = 100;
454 
455     uint256 public tradingActiveTime;
456     uint256 public launchBlock;
457 
458     IAntiSnipe antibot;
459     bool public protectionEnabled = false;
460     bool public protectionDisabled = false;
461 
462     mapping(address => bool) public _isExcludedFromFees;
463 
464     event ExcludeFromFees(address indexed account, bool isExcluded);
465     event ProtectionToggle(bool isEnabled);
466     event ProtectionDisabled();
467 
468     constructor() ERC20("Spark", "SPK") payable {
469         taxAddress = 0x29B292C45AE248D7DAd9Ed9804992c2A6Cb4405e;
470 
471         address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
472         dexRouter = IDexRouter(routerAddress);
473 
474         _approve(msg.sender, routerAddress, type(uint256).max);
475         _approve(address(this), routerAddress, type(uint256).max);
476 
477         lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), USDC);
478         pairs[lpPair] = true;
479         IERC20(lpPair).approve(address(dexRouter), type(uint256).max);
480         IERC20(USDC).approve(address(dexRouter), type(uint256).max);
481 
482         uint256 totalSupply = 1_000_000_000 * _decimalFactor;
483 
484         excludeFromFees(msg.sender, true);
485         excludeFromFees(taxAddress, true);
486         excludeFromFees(address(this), true);
487         excludeFromFees(address(0xdead), true);
488 
489         _totalSupply = totalSupply;
490         uint256 lpTokens = totalSupply * 90 / 100;
491         _balances[address(this)] = lpTokens;
492         emit Transfer(address(0), address(this), lpTokens);
493         _balances[taxAddress] = totalSupply - lpTokens;
494         emit Transfer(address(0), taxAddress, totalSupply - lpTokens);
495 
496         swapTokensAtAmount = (lpTokens * 5) / 10000; // 0.05 %
497 
498         transferOwnership(msg.sender);
499     }
500 
501     receive() external payable {}
502 
503     function decimals() public pure override returns (uint8) {
504         return _decimals;
505     }
506 
507     function getSellFees() public view returns (uint256) {
508         if(!sellTaxEnabled) return 0;
509         return 4;
510     }
511 
512     function getBuyFees() public view returns (uint256) {
513         if(!buyTaxEnabled) return 0;
514         if(tradingActiveTime + 5 minutes < block.timestamp) return 5;
515         if(launchBlock + deadBlocks > block.number){ return 90; }
516         if(tradingActiveTime + 4 minutes < block.timestamp) return 10;
517         if(tradingActiveTime + 3 minutes < block.timestamp) return 15;
518         if(tradingActiveTime + 2 minutes < block.timestamp) return 20;
519         return 25;
520     }
521 
522     function excludeFromFees(address account, bool excluded) public onlyOwner {
523         _isExcludedFromFees[account] = excluded;
524         emit ExcludeFromFees(account, excluded);
525     }
526 
527     function circulatingSupply() public view returns (uint256) {
528         return totalSupply() - balanceOf(address(0xdead));
529     }
530 
531     function checkWalletLimit(address recipient, uint256 amount) internal view {
532         require(balanceOf(recipient) + amount <= circulatingSupply() * walletLimit / 100, "Transfer amount exceeds the bag size.");
533     }
534 
535     function _transfer(
536         address from,
537         address to,
538         uint256 amount
539     ) internal override {
540         require(from != address(0), "ERC20: transfer from the zero address");
541         require(to != address(0), "ERC20: transfer to the zero address");
542         require(amount > 0, "Amount must be greater than 0");
543 
544         if (tradingActiveTime > 0 && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {
545             if (!pairs[to] && to != address(0xdead) && to != address(dexRouter)) {
546                 checkWalletLimit(to, amount);
547             }
548 
549             uint256 fees = 0;
550             uint256 _sf = getSellFees();
551             uint256 _bf = getBuyFees();
552 
553             if (swapEnabled && !swapping && pairs[to]) {
554                 swapping = true;
555                 swapBack(amount);
556                 swapping = false;
557             }
558 
559             if (pairs[to] &&_sf > 0) {
560                 fees = (amount * _sf) / 100;
561             }
562             else if (_bf > 0 && pairs[from]) {
563                 fees = (amount * _bf) / 100;
564             }
565 
566             if (fees > 0) {
567                 super._transfer(from, address(this), fees);
568             }
569 
570             amount -= fees;
571             if(protectionEnabled)
572                 antibot.onPreTransferCheck(msg.sender, from, to, amount);
573         }
574 
575         super._transfer(from, to, amount);
576     }
577 
578     function swapTokensForUSDC(uint256 tokenAmount) private {
579         // generate the uniswap pair path of token -> USDC
580         address[] memory path = new address[](2);
581         path[0] = address(this);
582         path[1] = USDC;
583 
584         dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
585             tokenAmount,
586             0, // accept any amount of USDC
587             path,
588             taxAddress,
589             block.timestamp
590         );
591     }
592 
593     function swapBack(uint256 amount) private {
594         uint256 amountToSwap = balanceOf(address(this));
595         if (amountToSwap < swapTokensAtAmount) return;
596         if (amountToSwap > swapTokensAtAmount * 10) amountToSwap = swapTokensAtAmount * 10;
597         if (amountToSwap > amount) amountToSwap = 90 * amount / 100;
598 	    if (amountToSwap == 0) return;
599 
600         swapTokensForUSDC(amountToSwap);
601     }
602 
603     // withdraw ETH if stuck or someone sends to the address
604     function withdrawStuckETH() external {
605         bool success;
606         (success, ) = address(taxAddress).call{value: address(this).balance}("");
607     }
608 
609     function withdrawStuckUSDC() external {
610         IERC20(USDC).transfer(taxAddress, IERC20(USDC).balanceOf(address(this)));
611     }
612 
613     function launch(uint256 _deadBlocks, address _antibot, uint256 minUSDC) external payable onlyOwner {
614         require(tradingActiveTime == 0);
615 
616         address[] memory path = new address[](2);
617         path[0] = dexRouter.WETH();
618         path[1] = USDC;
619 
620         if(address(this).balance > 0)
621             dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: address(this).balance}(minUSDC, path, address(this), block.timestamp);
622 
623         dexRouter.addLiquidity(address(this), USDC, balanceOf(address(this)), IERC20(USDC).balanceOf(address(this)),0,0,msg.sender,block.timestamp);
624 
625         deadBlocks = _deadBlocks;
626         launchBlock = block.number;
627         buyTaxEnabled = true;
628         sellTaxEnabled = true;
629         walletLimit = 2;
630         tradingActiveTime = block.timestamp;
631         if(protectionEnabled) {
632             antibot = IAntiSnipe(_antibot);
633             antibot.setTokenOwner(address(this), lpPair);
634         }
635     }
636 
637     function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {
638         require(newAmount >= (circulatingSupply() * 1) / 100000, "Swap amount cannot be lower than 0.001% total supply.");
639         require(newAmount <= (circulatingSupply() * 1) / 1000, "Swap amount cannot be higher than 0.1% total supply.");
640         swapTokensAtAmount = newAmount;
641     }
642 
643     function setPair(address pair, bool value) external onlyOwner
644     {
645         require(pair != lpPair,"The main pair cannot be removed from pairs");
646 
647         pairs[pair] = value;
648     }
649 
650     function disableSwap() external onlyOwner {
651         swapEnabled = false;
652     }
653 
654     function enableSwap() external onlyOwner {
655         swapEnabled = true;
656     }
657 
658     function disableBuyTax() external onlyOwner {
659         buyTaxEnabled = false;
660     }
661 
662     function enableBuyTax() external onlyOwner {
663         buyTaxEnabled = true;
664     }
665 
666     function disableSellTax() external onlyOwner {
667         sellTaxEnabled = false;
668     }
669 
670     function enableSellTax() external onlyOwner {
671         sellTaxEnabled = true;
672     }
673 
674     function setProtectionEnabled(bool _protect) external onlyOwner {
675         if (_protect)
676             require(!protectionDisabled, "Protection disabled");
677         protectionEnabled = _protect;
678         emit ProtectionToggle(_protect);
679     }
680     
681     function disableProtection() external onlyOwner {
682         protectionDisabled = true;
683         emit ProtectionDisabled();
684     }
685 
686     function setWalletLimits(uint256 _limit) external onlyOwner {
687         require(_limit >= 1, "Wallet limit must be 1% or greater");
688         walletLimit = _limit;
689     }
690 }