1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 
20 pragma solidity ^0.4.20;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   uint256 public totalSupply;
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
43     if (a == 0) {
44       return 0;
45     }
46     uint256 c = a * b;
47     assert(c / a == b);
48     return c;
49   }
50 
51   function div(uint256 a, uint256 b) internal pure returns (uint256) {
52     // assert(b > 0); // Solidity automatically throws when dividing by 0
53     uint256 c = a / b;
54     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
55     return c;
56   }
57 
58   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
59     assert(b <= a);
60     return a - b;
61   }
62 
63   function add(uint256 a, uint256 b) internal pure returns (uint256) {
64     uint256 c = a + b;
65     assert(c >= a);
66     return c;
67   }
68 }
69 
70 
71 
72 /**
73  * @title Basic token
74  * @dev Basic version of StandardToken, with no allowances.
75  */
76 contract BasicToken is ERC20Basic {
77   using SafeMath for uint256;
78 
79   mapping(address => uint256) balances;
80 
81   /**
82   * @dev transfer token for a specified address
83   * @param _to The address to transfer to.
84   * @param _value The amount to be transferred.
85   */
86   function transfer(address _to, uint256 _value) public returns (bool) {
87     require(_to != address(0));
88     require(_value <= balances[msg.sender]);
89 
90     // SafeMath.sub will throw if there is not enough balance.
91     balances[msg.sender] = balances[msg.sender].sub(_value);
92     balances[_to] = balances[_to].add(_value);
93     Transfer(msg.sender, _to, _value);
94     return true;
95   }
96 
97   /**
98   * @dev Gets the balance of the specified address.
99   * @param _owner The address to query the the balance of.
100   * @return An uint256 representing the amount owned by the passed address.
101   */
102   function balanceOf(address _owner) public view returns (uint256 balance) {
103     return balances[_owner];
104   }
105 
106 }
107 
108 
109 
110 /**
111  * @title ERC20 interface
112  * @dev see https://github.com/ethereum/EIPs/issues/20
113  */
114 contract ERC20 is ERC20Basic {
115   function allowance(address owner, address spender) public view returns (uint256);
116   function transferFrom(address from, address to, uint256 value) public returns (bool);
117   function approve(address spender, uint256 value) public returns (bool);
118   event Approval(address indexed owner, address indexed spender, uint256 value);
119 }
120 
121 
122 
123 /**
124  * @title Standard ERC20 token
125  *
126  * @dev Implementation of the basic standard token.
127  * @dev https://github.com/ethereum/EIPs/issues/20
128  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
129  */
130 contract StandardToken is ERC20, BasicToken {
131 
132   mapping (address => mapping (address => uint256)) internal allowed;
133 
134 
135   /**
136    * @dev Transfer tokens from one address to another
137    * @param _from address The address which you want to send tokens from
138    * @param _to address The address which you want to transfer to
139    * @param _value uint256 the amount of tokens to be transferred
140    */
141   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
142     require(_to != address(0));
143     require(_value <= balances[_from]);
144     require(_value <= allowed[_from][msg.sender]);
145 
146     balances[_from] = balances[_from].sub(_value);
147     balances[_to] = balances[_to].add(_value);
148     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
149     Transfer(_from, _to, _value);
150     return true;
151   }
152 
153   /**
154    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
155    *
156    * Beware that changing an allowance with this method brings the risk that someone may use both the old
157    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
158    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
159    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
160    * @param _spender The address which will spend the funds.
161    * @param _value The amount of tokens to be spent.
162    */
163   function approve(address _spender, uint256 _value) public returns (bool) {
164     allowed[msg.sender][_spender] = _value;
165     Approval(msg.sender, _spender, _value);
166     return true;
167   }
168 
169   /**
170    * @dev Function to check the amount of tokens that an owner allowed to a spender.
171    * @param _owner address The address which owns the funds.
172    * @param _spender address The address which will spend the funds.
173    * @return A uint256 specifying the amount of tokens still available for the spender.
174    */
175   function allowance(address _owner, address _spender) public view returns (uint256) {
176     return allowed[_owner][_spender];
177   }
178 
179   /**
180    * approve should be called when allowed[_spender] == 0. To increment
181    * allowed value is better to use this function to avoid 2 calls (and wait until
182    * the first transaction is mined)
183    * From MonolithDAO Token.sol
184    */
185   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
186     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
187     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
188     return true;
189   }
190 
191   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
192     uint oldValue = allowed[msg.sender][_spender];
193     if (_subtractedValue > oldValue) {
194       allowed[msg.sender][_spender] = 0;
195     } else {
196       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
197     }
198     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
199     return true;
200   }
201 
202 }
203 
204 
205 
206 /**
207  * @title Ownable
208  * @dev The Ownable contract has an owner address, and provides basic authorization control
209  * functions, this simplifies the implementation of "user permissions".
210  */
211 contract Ownable {
212   address public owner;
213 
214 
215   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
216 
217 
218   /**
219    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
220    * account.
221    */
222   function Ownable() public {
223     owner = msg.sender;
224   }
225 
226 
227   /**
228    * @dev Throws if called by any account other than the owner.
229    */
230   modifier onlyOwner() {
231     require(msg.sender == owner);
232     _;
233   }
234 
235 
236   /**
237    * @dev Allows the current owner to transfer control of the contract to a newOwner.
238    * @param newOwner The address to transfer ownership to.
239    */
240   function transferOwnership(address newOwner) public onlyOwner {
241     require(newOwner != address(0));
242     OwnershipTransferred(owner, newOwner);
243     owner = newOwner;
244   }
245 
246 }
247 
248 
249 
250 /**
251  * @title Mintable token
252  * @dev Simple ERC20 Token example, with mintable token creation
253  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
254  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
255  */
256 
257 contract MintableToken is StandardToken, Ownable {
258   event Mint(address indexed to, uint256 amount);
259   event MintFinished();
260 
261   bool public mintingFinished = false;
262 
263 
264   modifier canMint() {
265     require(!mintingFinished);
266     _;
267   }
268 
269   /**
270    * @dev Function to mint tokens
271    * @param _to The address that will receive the minted tokens.
272    * @param _amount The amount of tokens to mint.
273    * @return A boolean that indicates if the operation was successful.
274    */
275   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
276     totalSupply = totalSupply.add(_amount);
277     balances[_to] = balances[_to].add(_amount);
278     Mint(_to, _amount);
279     Transfer(address(0), _to, _amount);
280     return true;
281   }
282 
283   /**
284    * @dev Function to stop minting new tokens.
285    * @return True if the operation was successful.
286    */
287   function finishMinting() onlyOwner canMint public returns (bool) {
288     mintingFinished = true;
289     MintFinished();
290     return true;
291   }
292 }
293 
294 
295 
296 contract FreezableToken is StandardToken {
297     // freezing chains
298     mapping (bytes32 => uint64) internal chains;
299     // freezing amounts for each chain
300     mapping (bytes32 => uint) internal freezings;
301     // total freezing balance per address
302     mapping (address => uint) internal freezingBalance;
303 
304     event Freezed(address indexed to, uint64 release, uint amount);
305     event Released(address indexed owner, uint amount);
306 
307 
308     /**
309      * @dev Gets the balance of the specified address include freezing tokens.
310      * @param _owner The address to query the the balance of.
311      * @return An uint256 representing the amount owned by the passed address.
312      */
313     function balanceOf(address _owner) public view returns (uint256 balance) {
314         return super.balanceOf(_owner) + freezingBalance[_owner];
315     }
316 
317     /**
318      * @dev Gets the balance of the specified address without freezing tokens.
319      * @param _owner The address to query the the balance of.
320      * @return An uint256 representing the amount owned by the passed address.
321      */
322     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
323         return super.balanceOf(_owner);
324     }
325 
326     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
327         return freezingBalance[_owner];
328     }
329 
330     /**
331      * @dev gets freezing count
332      * @param _addr Address of freeze tokens owner.
333      */
334     function freezingCount(address _addr) public view returns (uint count) {
335         uint64 release = chains[toKey(_addr, 0)];
336         while (release != 0) {
337             count ++;
338             release = chains[toKey(_addr, release)];
339         }
340     }
341 
342     /**
343      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
344      * @param _addr Address of freeze tokens owner.
345      * @param _index Freezing portion index. It ordered by release date descending.
346      */
347     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
348         for (uint i = 0; i < _index + 1; i ++) {
349             _release = chains[toKey(_addr, _release)];
350             if (_release == 0) {
351                 return;
352             }
353         }
354         _balance = freezings[toKey(_addr, _release)];
355     }
356 
357     /**
358      * @dev freeze your tokens to the specified address.
359      *      Be careful, gas usage is not deterministic,
360      *      and depends on how many freezes _to address already has.
361      * @param _to Address to which token will be freeze.
362      * @param _amount Amount of token to freeze.
363      * @param _until Release date, must be in future.
364      */
365     function freezeTo(address _to, uint _amount, uint64 _until) public {
366         require(_to != address(0));
367         require(_amount <= balances[msg.sender]);
368 
369         balances[msg.sender] = balances[msg.sender].sub(_amount);
370 
371         bytes32 currentKey = toKey(_to, _until);
372         freezings[currentKey] = freezings[currentKey].add(_amount);
373         freezingBalance[_to] = freezingBalance[_to].add(_amount);
374 
375         freeze(_to, _until);
376         Transfer(msg.sender, _to, _amount);
377         Freezed(_to, _until, _amount);
378     }
379 
380     /**
381      * @dev release first available freezing tokens.
382      */
383     function releaseOnce() public {
384         bytes32 headKey = toKey(msg.sender, 0);
385         uint64 head = chains[headKey];
386         require(head != 0);
387         require(uint64(block.timestamp) > head);
388         bytes32 currentKey = toKey(msg.sender, head);
389 
390         uint64 next = chains[currentKey];
391 
392         uint amount = freezings[currentKey];
393         delete freezings[currentKey];
394 
395         balances[msg.sender] = balances[msg.sender].add(amount);
396         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
397 
398         if (next == 0) {
399             delete chains[headKey];
400         }
401         else {
402             chains[headKey] = next;
403             delete chains[currentKey];
404         }
405         Released(msg.sender, amount);
406     }
407 
408     /**
409      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
410      * @return how many tokens was released
411      */
412     function releaseAll() public returns (uint tokens) {
413         uint release;
414         uint balance;
415         (release, balance) = getFreezing(msg.sender, 0);
416         while (release != 0 && block.timestamp > release) {
417             releaseOnce();
418             tokens += balance;
419             (release, balance) = getFreezing(msg.sender, 0);
420         }
421     }
422 
423     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
424         // WISH masc to increase entropy
425         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
426         assembly {
427             result := or(result, mul(_addr, 0x10000000000000000))
428             result := or(result, _release)
429         }
430     }
431 
432     function freeze(address _to, uint64 _until) internal {
433         require(_until > block.timestamp);
434         bytes32 key = toKey(_to, _until);
435         bytes32 parentKey = toKey(_to, uint64(0));
436         uint64 next = chains[parentKey];
437 
438         if (next == 0) {
439             chains[parentKey] = _until;
440             return;
441         }
442 
443         bytes32 nextKey = toKey(_to, next);
444         uint parent;
445 
446         while (next != 0 && _until > next) {
447             parent = next;
448             parentKey = nextKey;
449 
450             next = chains[nextKey];
451             nextKey = toKey(_to, next);
452         }
453 
454         if (_until == next) {
455             return;
456         }
457 
458         if (next != 0) {
459             chains[key] = next;
460         }
461 
462         chains[parentKey] = _until;
463     }
464 }
465 
466 /**
467 * @title Contract that will work with ERC223 tokens.
468 */
469 
470 contract ERC223Receiver {
471     /**
472      * @dev Standard ERC223 function that will handle incoming token transfers.
473      *
474      * @param _from  Token sender address.
475      * @param _value Amount of tokens.
476      * @param _data  Transaction metadata.
477      */
478     function tokenFallback(address _from, uint _value, bytes _data) public;
479 }
480 
481 contract ERC223Basic is ERC20Basic {
482     function transfer(address to, uint value, bytes data) public returns (bool);
483     event Transfer(address indexed from, address indexed to, uint value, bytes data);
484 }
485 
486 
487 contract SuccessfulERC223Receiver is ERC223Receiver {
488     event Invoked(address from, uint value, bytes data);
489 
490     function tokenFallback(address _from, uint _value, bytes _data) public {
491         Invoked(_from, _value, _data);
492     }
493 }
494 
495 contract FailingERC223Receiver is ERC223Receiver {
496     function tokenFallback(address, uint, bytes) public {
497         revert();
498     }
499 }
500 
501 contract ERC223ReceiverWithoutTokenFallback {
502 }
503 
504 /**
505  * @title Burnable Token
506  * @dev Token that can be irreversibly burned (destroyed).
507  */
508 contract BurnableToken is StandardToken {
509 
510     event Burn(address indexed burner, uint256 value);
511 
512     /**
513      * @dev Burns a specific amount of tokens.
514      * @param _value The amount of token to be burned.
515      */
516     function burn(uint256 _value) public {
517         require(_value > 0);
518         require(_value <= balances[msg.sender]);
519         // no need to require value <= totalSupply, since that would imply the
520         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
521 
522         address burner = msg.sender;
523         balances[burner] = balances[burner].sub(_value);
524         totalSupply = totalSupply.sub(_value);
525         Burn(burner, _value);
526     }
527 }
528 
529 
530 
531 /**
532  * @title Pausable
533  * @dev Base contract which allows children to implement an emergency stop mechanism.
534  */
535 contract Pausable is Ownable {
536   event Pause();
537   event Unpause();
538 
539   bool public paused = false;
540 
541 
542   /**
543    * @dev Modifier to make a function callable only when the contract is not paused.
544    */
545   modifier whenNotPaused() {
546     require(!paused);
547     _;
548   }
549 
550   /**
551    * @dev Modifier to make a function callable only when the contract is paused.
552    */
553   modifier whenPaused() {
554     require(paused);
555     _;
556   }
557 
558   /**
559    * @dev called by the owner to pause, triggers stopped state
560    */
561   function pause() onlyOwner whenNotPaused public {
562     paused = true;
563     Pause();
564   }
565 
566   /**
567    * @dev called by the owner to unpause, returns to normal state
568    */
569   function unpause() onlyOwner whenPaused public {
570     paused = false;
571     Unpause();
572   }
573 }
574 
575 
576 
577 contract FreezableMintableToken is FreezableToken, MintableToken {
578     /**
579      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
580      *      Be careful, gas usage is not deterministic,
581      *      and depends on how many freezes _to address already has.
582      * @param _to Address to which token will be freeze.
583      * @param _amount Amount of token to mint and freeze.
584      * @param _until Release date, must be in future.
585      * @return A boolean that indicates if the operation was successful.
586      */
587     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
588         totalSupply = totalSupply.add(_amount);
589 
590         bytes32 currentKey = toKey(_to, _until);
591         freezings[currentKey] = freezings[currentKey].add(_amount);
592         freezingBalance[_to] = freezingBalance[_to].add(_amount);
593 
594         freeze(_to, _until);
595         Mint(_to, _amount);
596         Freezed(_to, _until, _amount);
597         Transfer(msg.sender, _to, _amount);
598         return true;
599     }
600 }
601 
602 contract Consts {
603     uint constant TOKEN_DECIMALS = 18;
604     uint8 constant TOKEN_DECIMALS_UINT8 = 18;
605     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
606 
607     string constant TOKEN_NAME = "token22";
608     string constant TOKEN_SYMBOL = "token22";
609     bool constant PAUSED = true;
610     address constant TARGET_USER = 0x008024069546651883a2b948AE67b345D7c42B19;
611     
612     uint constant START_TIME = 1524839861;
613     
614     bool constant CONTINUE_MINTING = false;
615 }
616 
617 
618 
619 
620 /**
621  * @title Reference implementation of the ERC223 standard token.
622  */
623 contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {
624     using SafeMath for uint;
625 
626     /**
627      * @dev Transfer the specified amount of tokens to the specified address.
628      *      Invokes the `tokenFallback` function if the recipient is a contract.
629      *      The token transfer fails if the recipient is a contract
630      *      but does not implement the `tokenFallback` function
631      *      or the fallback function to receive funds.
632      *
633      * @param _to    Receiver address.
634      * @param _value Amount of tokens that will be transferred.
635      * @param _data  Transaction metadata.
636      */
637     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
638         // Standard function transfer similar to ERC20 transfer with no _data .
639         // Added due to backwards compatibility reasons .
640         uint codeLength;
641 
642         assembly {
643             // Retrieve the size of the code on target address, this needs assembly.
644             codeLength := extcodesize(_to)
645         }
646 
647         balances[msg.sender] = balances[msg.sender].sub(_value);
648         balances[_to] = balances[_to].add(_value);
649         if(codeLength > 0) {
650             ERC223Receiver receiver = ERC223Receiver(_to);
651             receiver.tokenFallback(msg.sender, _value, _data);
652         }
653         Transfer(msg.sender, _to, _value, _data);
654         return true;
655     }
656 
657     /**
658      * @dev Transfer the specified amount of tokens to the specified address.
659      *      This function works the same with the previous one
660      *      but doesn't contain `_data` param.
661      *      Added due to backwards compatibility reasons.
662      *
663      * @param _to    Receiver address.
664      * @param _value Amount of tokens that will be transferred.
665      */
666     function transfer(address _to, uint256 _value) public returns (bool) {
667         bytes memory empty;
668         return transfer(_to, _value, empty);
669     }
670 }
671 
672 
673 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
674     
675 {
676     
677 
678     function name() pure public returns (string _name) {
679         return TOKEN_NAME;
680     }
681 
682     function symbol() pure public returns (string _symbol) {
683         return TOKEN_SYMBOL;
684     }
685 
686     function decimals() pure public returns (uint8 _decimals) {
687         return TOKEN_DECIMALS_UINT8;
688     }
689 
690     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
691         require(!paused);
692         return super.transferFrom(_from, _to, _value);
693     }
694 
695     function transfer(address _to, uint256 _value) public returns (bool _success) {
696         require(!paused);
697         return super.transfer(_to, _value);
698     }
699 }