1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/FlyzERC20.sol": {
5       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport './types/Ownable.sol';\nimport './types/ERC20.sol';\nimport './libraries/SafeMath.sol';\n\ncontract VaultOwned is Ownable {\n    address internal _vault;\n\n    function setVault(address vault_) external onlyOwner returns (bool) {\n        _vault = vault_;\n\n        return true;\n    }\n\n    function vault() public view returns (address) {\n        return _vault;\n    }\n\n    modifier onlyVault() {\n        require(_vault == msg.sender, 'VaultOwned: caller is not the Vault');\n        _;\n    }\n}\n\ncontract FlyzERC20 is ERC20Permit, VaultOwned {\n    using SafeMath for uint256;\n\n    constructor() ERC20('FLYZ', 'FLZ', 9) {}\n\n    function mint(address account_, uint256 amount_) external onlyVault {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account_, uint256 amount_) public virtual {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) public virtual {\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(\n            amount_,\n            'ERC20: burn amount exceeds allowance'\n        );\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}\n"
6     },
7     "contracts/types/Ownable.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n\n    function renounceManagement() external;\n\n    function pushManagement(address newOwner_) external;\n\n    function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event OwnershipPulled(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipPushed(address(0), _owner);\n    }\n\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyOwner {\n        emit OwnershipPushed(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function pushManagement(address newOwner_)\n        public\n        virtual\n        override\n        onlyOwner\n    {\n        require(\n            newOwner_ != address(0),\n            'Ownable: new owner is the zero address'\n        );\n        emit OwnershipPushed(_owner, newOwner_);\n        _newOwner = newOwner_;\n    }\n\n    function pullManagement() public virtual override {\n        require(msg.sender == _newOwner, 'Ownable: must be new owner to pull');\n        emit OwnershipPulled(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n"
9     },
10     "contracts/types/ERC20.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport '../interfaces/IERC20.sol';\nimport '../libraries/SafeMath.sol';\nimport '../libraries/Counters.sol';\nimport '../libraries/Address.sol';\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n        keccak256('ERC20Token');\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(\n                amount,\n                'ERC20: transfer amount exceeds allowance'\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                'ERC20: decreased allowance below zero'\n            )\n        );\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), 'ERC20: transfer from the zero address');\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account_, uint256 ammount_) internal virtual {\n        require(account_ != address(0), 'ERC20: mint to the zero address');\n        _beforeTokenTransfer(address(this), account_, ammount_);\n        _totalSupply = _totalSupply.add(ammount_);\n        _balances[account_] = _balances[account_].add(ammount_);\n        emit Transfer(address(this), account_, ammount_);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            'ERC20: burn amount exceeds balance'\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal virtual {}\n}\n\ninterface IERC2612Permit {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    constructor() {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes('1')), // Version\n                chainID,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, 'Permit: expired deadline');\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                _nonces[owner].current(),\n                deadline\n            )\n        );\n\n        bytes32 _hash = keccak256(\n            abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n        );\n\n        address signer = ecrecover(_hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            'ZeroSwapPermit: Invalid signature'\n        );\n\n        _nonces[owner].increment();\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n}\n"
12     },
13     "contracts/libraries/SafeMath.sol": {
14       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = add(div(a, 2), 1);\n            while (b < c) {\n                c = b;\n                b = div(add(div(a, b), b), 2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n"
15     },
16     "contracts/interfaces/IERC20.sol": {
17       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n\ninterface IERC20Mintable {\n    function mint(uint256 amount_) external;\n\n    function mint(address account_, uint256 ammount_) external;\n}\n"
18     },
19     "contracts/libraries/Counters.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport './SafeMath.sol';\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
21     },
22     "contracts/libraries/Address.sol": {
23       "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            'Address: insufficient balance'\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}('');\n        require(\n            success,\n            'Address: unable to send value, recipient may have reverted'\n        );\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, 'Address: low-level call failed');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'Address: low-level call with value failed'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'Address: insufficient balance for call'\n        );\n        require(isContract(target), 'Address: call to non-contract');\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), 'Address: call to non-contract');\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                'Address: low-level static call failed'\n            );\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), 'Address: static call to non-contract');\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                'Address: low-level delegate call failed'\n            );\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), 'Address: delegate call to non-contract');\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = '0123456789abcdef';\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = '0';\n        _addr[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) {\n            _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n            _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n    }\n}\n"
24     }
25   },
26   "settings": {
27     "optimizer": {
28       "enabled": false,
29       "runs": 200
30     },
31     "outputSelection": {
32       "*": {
33         "*": [
34           "evm.bytecode",
35           "evm.deployedBytecode",
36           "devdoc",
37           "userdoc",
38           "metadata",
39           "abi"
40         ]
41       }
42     },
43     "libraries": {}
44   }
45 }}