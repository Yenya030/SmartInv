1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/LICENSE.sol": {
5       "content": "// Copyright (c) 2022-2023 Fellowship\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice (including the next paragraph) shall be included in all copies\n// or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
6     },
7     "contracts/DutchAuctionRefundMinter.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022-2023 Fellowship\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./LimitedPaymentDistributor.sol\";\nimport \"./Mintable.sol\";\nimport \"./TimedSale.sol\";\n\ncontract DutchAuctionRefundMinter is LimitedPaymentDistributor, TimedSale {\n    uint256 public immutable walletLimit;\n    uint256 public immutable mintLimit;\n    string private limitRevertMessage;\n\n    /// @notice ERC-721 contract whose tokens are minted by this auction\n    /// @dev Must implement Mintable and number tokens sequentially from zero\n    Mintable public tokenContract;\n\n    /// @notice Starting price for the Dutch auction (in wei)\n    uint256 public startPrice;\n\n    /// @notice Resting price where price descent ends (in wei)\n    uint256 public restPrice;\n\n    /// @notice Lowest price at which a token was minted (in wei)\n    uint256 public lowestPrice;\n\n    /// @notice Amount that the price drops (in wei) every slot (every 12 seconds)\n    uint256 public priceDropPerSlot;\n\n    /// @notice Number of reserveTokens that have been minted\n    uint256 public reserveCount = 0;\n\n    /// @notice Number of tokens that have been minted per address\n    mapping(address => uint256) public mintCount;\n    /// @notice Total amount paid to mint per address\n    mapping(address => uint256) public mintPayment;\n\n    uint256 private previousPayment = 0;\n\n    /// @notice An event emitted upon token purchases\n    event Purchase(address purchaser, uint256 tokenId, uint256 price);\n\n    /// @notice An event emitted when reserve tokens are minted\n    event Reservation(address recipient, uint256 quantity, uint256 totalReserved);\n\n    /// @notice An event emitted when a refund is sent to a minter\n    event Refund(address recipient, uint256 amount);\n\n    /// @notice An error returned when the auction has reached its `mintLimit`\n    error SoldOut();\n\n    constructor(\n        Mintable tokenContract_,\n        uint256 startTime_,\n        uint256 startPrice_,\n        uint256 restPrice_,\n        uint256 priceDrop,\n        uint256 walletLimit_,\n        uint256 mintLimit_\n    ) TimedSale(startTime_) {\n        // CHECKS inputs\n        require(address(tokenContract_) != address(0), \"Token contract must not be the zero address\");\n\n        require(startPrice_ > 1e15, \"Start price too low: check that prices are in wei\");\n        require(restPrice_ > 1e15, \"Rest price too low: check that prices are in wei\");\n        require(startPrice_ >= restPrice_, \"Start price must not be lower than rest price\");\n\n        require(walletLimit_ < mintLimit_, \"Mint limit should be greater than wallet limit\");\n\n        uint256 priceDifference;\n        unchecked {\n            priceDifference = startPrice_ - restPrice_;\n        }\n        require(priceDrop * 25 <= priceDifference, \"Auction must last at least 5 minutes\");\n        require(priceDrop * (5 * 60 * 24) >= priceDifference, \"Auction must not last longer than 24 hours\");\n\n        // EFFECTS\n        tokenContract = tokenContract_;\n        lowestPrice = startPrice = startPrice_;\n        restPrice = restPrice_;\n        priceDropPerSlot = priceDrop;\n\n        mintLimit = mintLimit_;\n        walletLimit = walletLimit_ != 0 ? walletLimit_ : mintLimit_;\n        limitRevertMessage = string.concat(\"Limited to \", Strings.toString(walletLimit), \" purchases per wallet\");\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Mint a token on the `tokenContract` contract. Must include at least `currentPrice`.\n    function mint() public payable virtual started whenNotPaused {\n        // CHECKS state and inputs\n        uint totalCount = tokenContract.totalSupply();\n        if (totalCount >= mintLimit) revert SoldOut();\n        uint256 price = msg.value;\n        require(price >= currentPrice(), \"Insufficient payment\");\n        require(mintCount[msg.sender] < walletLimit, limitRevertMessage);\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: mintCount cannot exceed walletLimit\n            mintCount[msg.sender]++;\n            // Unchecked arithmetic: can't exceed this.balance; not expected to exceed walletLimit * startPrice\n            mintPayment[msg.sender] += price;\n        }\n\n        if (price < lowestPrice) {\n            lowestPrice = price;\n        }\n\n        emit Purchase(msg.sender, totalCount, price);\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        tokenContract.mint(msg.sender);\n    }\n\n    /// @notice Mint multiple tokens on the `tokenContract` contract. Must pay at least `currentPrice` * `quantity`.\n    /// @param quantity The number of tokens to mint: must not be greater than `walletLimit`\n    function mintMultiple(uint256 quantity) public payable virtual started whenNotPaused {\n        // CHECKS state and inputs\n        uint firstId = tokenContract.totalSupply();\n        if (firstId >= mintLimit) revert SoldOut();\n        uint256 alreadyMinted = mintCount[msg.sender];\n        require(quantity > 0, \"Must mint at least one token\");\n        require(quantity <= walletLimit && alreadyMinted < walletLimit, limitRevertMessage);\n\n        uint256 payment = msg.value;\n        uint256 price = payment / quantity;\n        require(price >= currentPrice(), \"Insufficient payment\");\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: firstId + quantity is less than mintLimit + walletLimit\n            if (firstId + quantity > mintLimit) {\n                // Reduce quantity to the remaining supply\n                // Unchecked arithmetic: already checked that firstId is less than mintLimit\n                quantity = mintLimit - firstId;\n            }\n            // Unchecked arithmetic: alreadyMinted + quantity is less than 2 * walletLimit\n            if (alreadyMinted + quantity > walletLimit) {\n                // Reduce quantity to the remaining wallet allowance\n                // Unchecked arithmetic: already checked that firstId is less than mintLimit\n                quantity = walletLimit - alreadyMinted;\n            }\n\n            // Unchecked arithmetic: mintCount cannot exceed walletLimit\n            mintCount[msg.sender] = alreadyMinted + quantity;\n            // Unchecked arithmetic: can't exceed total existing wei; not expected to exceed walletLimit * startPrice\n            mintPayment[msg.sender] += payment;\n        }\n\n        if (price < lowestPrice) {\n            lowestPrice = price;\n        }\n\n        unchecked {\n            for (uint256 i = 0; i < quantity; i++) {\n                emit Purchase(msg.sender, firstId + i, price);\n            }\n        }\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        tokenContract.mintBatch(msg.sender, quantity);\n    }\n\n    /// @notice Mint multiple tokens for the contract owner. Must pay at least `currentPrice` * `quantity`.\n    /// @param quantity The number of tokens to mint\n    function mintMultipleAbsentee(uint256 quantity) public payable virtual started whenNotPaused onlyOwner {\n        // CHECKS state and inputs\n        uint firstId = tokenContract.totalSupply();\n        if (firstId >= mintLimit) revert SoldOut();\n        require(quantity > 0, \"Must mint at least one token\");\n\n        uint256 payment = msg.value;\n        uint256 price = payment / quantity;\n        require(price >= currentPrice(), \"Insufficient payment\");\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: firstId + quantity is less than mintLimit + walletLimit\n            if (firstId + quantity > mintLimit) {\n                // Reduce quantity to the remaining supply\n                // Unchecked arithmetic: already checked that firstId is less than mintLimit\n                quantity = mintLimit - firstId;\n            }\n\n            // Unchecked arithmetic: mintCount cannot exceed mintLimit\n            mintCount[msg.sender] += quantity;\n            // Unchecked arithmetic: can't exceed total existing wei; not expected to exceed walletLimit * startPrice\n            mintPayment[msg.sender] += payment;\n        }\n\n        if (price < lowestPrice) {\n            lowestPrice = price;\n        }\n\n        unchecked {\n            for (uint256 i = 0; i < quantity; i++) {\n                emit Purchase(msg.sender, firstId + i, price);\n            }\n        }\n\n        // INTERACTIONS: call mint on known contract (tokenContract.mint contains no external interactions)\n        tokenContract.mintBatch(msg.sender, quantity);\n    }\n\n    /// @notice Send any available refund to the message sender\n    function refund() external returns (uint256) {\n        // CHECK available refund\n        uint256 refundAmount = refundAvailable(msg.sender);\n        require(refundAmount > 0, \"No refund available\");\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: refundAmount will always be less than mintPayment\n            mintPayment[msg.sender] -= refundAmount;\n        }\n\n        emit Refund(msg.sender, refundAmount);\n\n        // INTERACTIONS\n        (bool refunded, ) = msg.sender.call{value: refundAmount}(\"\");\n        require(refunded, \"Refund transfer was reverted\");\n\n        return refundAmount;\n    }\n\n    // OWNER AND ADMIN FUNCTIONS\n\n    /// @notice Mint reserve tokens to the designated `recipient`\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function reserve(address recipient, uint256 quantity) external unstarted onlyOwner {\n        // CHECKS contract state\n        uint totalCount = tokenContract.totalSupply();\n        if (totalCount + quantity > mintLimit) revert SoldOut();\n\n        // EFFECTS\n        unchecked {\n            // Unchecked arithmetic: neither value can exceed mintLimit\n            reserveCount += quantity;\n        }\n\n        emit Reservation(recipient, quantity, reserveCount);\n\n        // INTERACTIONS\n        tokenContract.mintBatch(recipient, quantity);\n    }\n\n    /// @notice withdraw auction proceeds\n    /// @dev Can only be called by the contract `owner` or a payee. Reverts if the final price is unknown or all\n    ///  proceeds have already been withdrawn.\n    function withdraw() external onlyPayee {\n        // CHECKS contract state\n        uint totalCount = tokenContract.totalSupply();\n        bool soldOut = totalCount >= mintLimit;\n        uint256 finalPrice = lowestPrice;\n        if (!soldOut) {\n            // Only allow a withdraw before the auction is sold out if the price has finished falling\n            require(currentPrice() == restPrice, \"Price is still falling\");\n            finalPrice = restPrice;\n        }\n\n        uint256 totalPayment = (totalCount - reserveCount) * finalPrice;\n        require(totalPayment > previousPayment, \"All funds have been withdrawn\");\n\n        // EFFECTS\n        uint256 outstandingPayment = totalPayment - previousPayment;\n        uint256 balance = address(this).balance;\n        if (outstandingPayment > balance) {\n            // Escape hatch to prevent stuck funds, but this shouldn't happen\n            require(balance > 0, \"All funds have been withdrawn\");\n            outstandingPayment = balance;\n        }\n\n        previousPayment += outstandingPayment;\n        withdraw(outstandingPayment);\n    }\n\n    /// @notice Update the tokenContract contract address\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setMintable(Mintable tokenContract_) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(address(tokenContract_) != address(0), \"Token contract must not be the zero address\");\n        // EFFECTS\n        tokenContract = tokenContract_;\n    }\n\n    /// @notice Update the auction price range and rate of decrease\n    /// @dev Since the values are validated against each other, they are all set together. Can only be called by the\n    ///  contract `owner`. Reverts if the auction has already started.\n    function setPriceRange(uint256 startPrice_, uint256 restPrice_, uint256 priceDrop) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(startPrice_ > 1e15, \"Start price too low: check that prices are in wei\");\n        require(restPrice_ > 1e15, \"Rest price too low: check that prices are in wei\");\n        require(startPrice_ >= restPrice_, \"Start price must not be lower than rest price\");\n\n        uint256 priceDifference;\n        unchecked {\n            priceDifference = startPrice_ - restPrice_;\n        }\n        require(priceDrop * 25 <= priceDifference, \"Auction must last at least 5 minutes\");\n        require(priceDrop * (5 * 60 * 24) >= priceDifference, \"Auction must not last longer than 24 hours\");\n\n        // EFFECTS\n        startPrice = startPrice_;\n        restPrice = restPrice_;\n        priceDropPerSlot = priceDrop;\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @notice Query the current price\n    function currentPrice() public view returns (uint256) {\n        uint256 time = timeElapsed();\n        unchecked {\n            uint256 drop = priceDropPerSlot * (time / 12);\n            if (startPrice < restPrice + drop) return restPrice;\n            return startPrice - drop;\n        }\n    }\n\n    /// @notice Query the refund available for the specified `minter`\n    function refundAvailable(address minter) public view returns (uint256) {\n        uint256 minted = mintCount[minter];\n        if (minted == 0) return 0;\n\n        uint totalCount = tokenContract.totalSupply();\n        bool soldOut = totalCount >= mintLimit;\n        uint256 refundPrice = soldOut ? lowestPrice : currentPrice();\n\n        uint256 payment = mintPayment[minter];\n        uint256 newPayment;\n        uint256 refundAmount;\n        unchecked {\n            // Unchecked arithmetic: newPayment cannot exceed walletLimit * startPrice\n            newPayment = minted * refundPrice;\n            // Unchecked arithmetic: value only used if newPayment < payment\n            refundAmount = payment - newPayment;\n        }\n\n        return (newPayment < payment) ? refundAmount : 0;\n    }\n}\n"
9     },
10     "contracts/LimitedPaymentDistributor.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Limited Payment Distributor\n/// @notice Distributes limited amounts of Ethereum or tokens to payees according to their shares\n/// @dev While `owner` already has full control, this contract uses `ReentrancyGuard` to prevent any footgun shenanigans\n///  that could result from calling `setShares` during `withdraw`\ncontract LimitedPaymentDistributor is Ownable, ReentrancyGuard {\n    uint256 private shareCount;\n    address[] private payees;\n    mapping(address => PayeeInfo) private payeeInfo;\n\n    struct PayeeInfo {\n        uint128 index;\n        uint128 shares;\n    }\n\n    error PaymentsNotConfigured();\n    error OnlyPayee();\n    error FailedPaying(address payee, bytes data);\n\n    /// @dev Check that caller is owner or payee\n    modifier onlyPayee() {\n        if (shareCount == 0) revert PaymentsNotConfigured();\n        if (msg.sender != owner()) {\n            // Get the stored index for the sender\n            uint256 index = payeeInfo[msg.sender].index;\n            // Check that they are actually at that index\n            if (payees[index] != msg.sender) revert OnlyPayee();\n        }\n\n        _;\n    }\n\n    modifier paymentsConfigured() {\n        if (shareCount == 0) revert PaymentsNotConfigured();\n        _;\n    }\n\n    receive() external payable {}\n\n    // OWNER FUNCTIONS\n\n    /// @notice Sets `payees_` who receive funds from this contract in accordance with shares in the `shares` array\n    /// @dev `payees_` and `shares` must have the same length and non-zero values\n    function setShares(address[] calldata payees_, uint128[] calldata shares) external onlyOwner nonReentrant {\n        // CHECKS inputs\n        require(payees_.length > 0, \"Must set at least one payee\");\n        require(payees_.length < type(uint128).max, \"Too many payees\");\n        require(payees_.length == shares.length, \"Payees and shares must have the same length\");\n\n        // CHECKS + EFFECTS: check each payee before setting values\n        shareCount = 0;\n        payees = payees_;\n        unchecked {\n            // Unchecked arithmetic: already checked that the number of payees is less than uint128 max\n            for (uint128 i = 0; i < payees_.length; i++) {\n                address payee = payees_[i];\n                uint128 payeeShares = shares[i];\n                require(payee != address(0), \"Payees must not be the zero address\");\n                require(payeeShares > 0, \"Payees shares must not be zero\");\n\n                // Unchecked arithmetic: since number of payees is less than uint128 max and share values are uint128,\n                // `shareCount` cannot exceed uint256 max.\n                shareCount += payeeShares;\n                PayeeInfo storage info = payeeInfo[payee];\n                info.index = i;\n                info.shares = payeeShares;\n            }\n        }\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice Distributes the specified `amount` from the contract balance to the `payees`\n    function withdraw(uint256 amount) internal {\n        uint256 shareSplit = amount / shareCount;\n\n        // INTERACTIONS\n        bool success;\n        bytes memory data;\n        for (uint256 i = 0; i < payees.length; i++) {\n            address payee = payees[i];\n            unchecked {\n                (success, data) = payee.call{value: shareSplit * payeeInfo[payee].shares}(\"\");\n            }\n            if (!success) revert FailedPaying(payee, data);\n        }\n    }\n\n    /// @notice Distributes a specified `amount` of tokens held by this contract to the `payees`\n    function withdrawToken(IERC20 token, uint256 amount) internal {\n        uint256 shareSplit = amount / shareCount;\n\n        // INTERACTIONS\n        bool success;\n        bytes memory data;\n        for (uint256 i = 0; i < payees.length; i++) {\n            address payee = payees[i];\n\n            unchecked {\n                // Based on token/ERC20/utils/SafeERC20.sol and utils/Address.sol from OpenZeppelin Contracts v4.7.0\n                (success, data) = address(token).call(\n                    abi.encodeWithSelector(token.transfer.selector, payee, shareSplit * payeeInfo[payee].shares)\n                );\n            }\n            if (!success) {\n                if (data.length > 0) revert FailedPaying(payee, data);\n                revert FailedPaying(payee, \"Transfer reverted\");\n            } else if (data.length > 0 && !abi.decode(data, (bool))) {\n                revert FailedPaying(payee, \"Transfer failed\");\n            }\n        }\n    }\n}\n"
12     },
13     "contracts/Mintable.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2023 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nabstract contract Mintable is IERC721 {\n    function mint(address to) external virtual;\n\n    function mintBatch(address to, uint256 amount) external virtual;\n\n    function totalSupply() external view virtual returns (uint256);\n}\n"
15     },
16     "contracts/Pausable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 Fellowship\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Pausable is Ownable {\n    /// @notice Whether or not this contract is paused\n    /// @dev The exact meaning of \"paused\" will vary by contract, but in general paused contracts should prevent most\n    ///  interactions from non-owners\n    bool public isPaused = false;\n\n    event Paused();\n    event Unpaused();\n\n    error ContractIsPaused();\n    error ContractNotPaused();\n\n    modifier whenPaused() {\n        if (!isPaused) revert ContractNotPaused();\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (isPaused) revert ContractIsPaused();\n        _;\n    }\n\n    // OWNER FUNCTIONS\n\n    /// @notice Pause this contract\n    /// @dev Can only be called by the contract `owner`\n    function pause() public virtual whenNotPaused onlyOwner {\n        // EFFECTS (checks already handled by modifiers)\n        isPaused = true;\n        emit Paused();\n    }\n\n    /// @notice Resume this contract\n    /// @dev Can only be called by the contract `owner`\n    function unpause() public virtual whenPaused onlyOwner {\n        // EFFECTS (checks already handled by modifiers)\n        isPaused = false;\n        emit Unpaused();\n    }\n\n    // VIEW FUNCTIONS\n\n    /// @notice Query if this contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @return `true` if `interfaceID` is implemented and is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x7f5828d0 || // ERC-173 Contract Ownership Standard\n            interfaceId == 0x01ffc9a7; // ERC-165 Standard Interface Detection\n    }\n}\n"
18     },
19     "contracts/TimedSale.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2022 - 2023 Fellowship\n\npragma solidity ^0.8.7;\nimport \"./Pausable.sol\";\n\ncontract TimedSale is Pausable {\n    /// @notice Timestamp when this auction starts allowing minting\n    uint256 public startTime;\n\n    uint256 private pauseStart;\n    uint256 internal pastPauseDelay;\n\n    /// @notice An error returned when the auction has already started\n    error AlreadyStarted();\n    /// @notice An error returned when the auction has not yet started\n    error NotYetStarted();\n\n    constructor(uint startTime_) {\n        // CHECKS inputs\n        require(startTime_ >= block.timestamp, \"Start time cannot be in the past\");\n\n        // EFFECTS\n        startTime = startTime_;\n    }\n\n    modifier started() {\n        if (!isStarted()) revert NotYetStarted();\n        _;\n    }\n    modifier unstarted() {\n        if (isStarted()) revert AlreadyStarted();\n        _;\n    }\n\n    // OWNER FUNCTIONS\n\n    /// @notice Pause this contract\n    /// @dev Can only be called by the contract `owner`\n    function pause() public override {\n        // CHECKS + EFFECTS: `Pausable` handles checking permissions and setting pause state\n        super.pause();\n        // More EFFECTS\n        pauseStart = block.timestamp;\n    }\n\n    /// @notice Resume this contract\n    /// @dev Can only be called by the contract `owner`. Pricing tiers will pick up where they left off.\n    function unpause() public override {\n        // CHECKS + EFFECTS: `Pausable` handles checking permissions and setting pause state\n        super.unpause();\n        // More EFFECTS\n        if (block.timestamp <= startTime) {\n            return;\n        }\n        // Find the amount time the auction should have been live, but was paused\n        unchecked {\n            // Unchecked arithmetic: computed value will be < block.timestamp and >= 0\n            if (pauseStart < startTime) {\n                pastPauseDelay = block.timestamp - startTime;\n            } else {\n                pastPauseDelay += (block.timestamp - pauseStart);\n            }\n        }\n    }\n\n    /// @notice Update the auction start time\n    /// @dev Can only be called by the contract `owner`. Reverts if the auction has already started.\n    function setStartTime(uint256 startTime_) external unstarted onlyOwner {\n        // CHECKS inputs\n        require(startTime_ >= block.timestamp, \"New start time cannot be in the past\");\n        // EFFECTS\n        startTime = startTime_;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function isStarted() internal view virtual returns (bool) {\n        return (isPaused ? pauseStart : block.timestamp) >= startTime;\n    }\n\n    function timeElapsed() internal view returns (uint256) {\n        if (!isStarted()) return 0;\n        unchecked {\n            // pastPauseDelay cannot be greater than the time passed since startTime\n            if (!isPaused) {\n                return block.timestamp - startTime - pastPauseDelay;\n            }\n\n            // pastPauseDelay cannot be greater than the time between startTime and pauseStart\n            return pauseStart - startTime - pastPauseDelay;\n        }\n    }\n}\n"
21     },
22     "contracts/OPENZEPPELIN_LICENSE.sol": {
23       "content": "// OpenZeppelin Contracts\n//\n// Copyright (c) 2016-2023 zOS Global Limited and contributors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
24     },
25     "@openzeppelin/contracts/utils/Context.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
30     },
31     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
33     },
34     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
36     },
37     "@openzeppelin/contracts/utils/math/Math.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
39     },
40     "@openzeppelin/contracts/access/Ownable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
42     },
43     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
44       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
45     },
46     "@openzeppelin/contracts/utils/Strings.sol": {
47       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
48     }
49   },
50   "settings": {
51     "optimizer": {
52       "enabled": true,
53       "runs": 200
54     },
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "abi"
61         ]
62       }
63     }
64   }
65 }}