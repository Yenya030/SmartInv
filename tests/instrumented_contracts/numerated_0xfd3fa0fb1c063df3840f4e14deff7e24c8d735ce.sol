1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/BullFarm.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IBullFund.sol\";\n\ncontract BullFarm {\n    // Structs\n    struct User {\n        address account;\n        address upline;\n        uint deposit;\n        uint withdraw;\n        uint x3Factor;\n        uint x3FactorCount;\n        uint lastDepositUpdate;\n        uint deferredProfit;\n        uint openLines;\n        uint[6] missedPartnersRewardByLine;\n        uint[6] partnersRewardByLine;\n        uint[6] partnersCountByLine;\n    }\n\n    // Constants\n    uint public constant MIN_DEPOSIT_VALUE = 0.1 ether;\n    uint public constant MIN_REINVEST_VALUE = 0.01 ether;\n    uint public constant MIN_WITHDRAWAL_VALUE = 0.01 ether;\n    uint public constant INITIAL_MAX_DEPOSIT = 1 ether;\n    uint public constant MAX_DEPOSIT_DAILY_STEP = 0.2 ether;\n    uint public constant MAX_DEPOSIT = 20 ether;\n    uint public constant STAGE_PERIOD = 3 days;\n    uint public constant MAX_LINES = 6;\n    uint public constant DEVS_FEE = 300; // 3%\n    uint public constant HONEY_BANK_FEE = 400; // 4%\n    uint public constant INSURANCE_FEE = 300; // 3%\n    uint public constant TOTAL_FEES = DEVS_FEE + HONEY_BANK_FEE + INSURANCE_FEE; // 10%\n    uint[4] public PROFIT_BY_STAGES = [500,400,300,200]; // [5%, 4%, 3%, 2%]\n    uint[6] public OPEN_LINE_MIN_DEPOSIT = [0.1 ether, 0.5 ether, 1 ether, 1.5 ether, 2 ether, 2.5 ether];\n    uint[][] public PARTNER_PROGRAMS; // [12%, 10%, 8%] -> [10%, 8%, 7%, 5%] -> [9%, 7%, 6%, 5%, 3%] -> [8%, 7%, 6%, 4%, 3%, 2%]\n    uint public PERCENTS_DIVISOR = 10000;\n\n    // State\n    mapping(address => User) users;\n    mapping(address => bool) waitingMigration;\n    address public admin;\n    address public lineManager;\n    uint public launchTimestamp;\n    uint[] public stageTimestamps;\n    mapping(address => bool) unlimited;\n    uint public totalUsers;\n\n    // Addresses for fee distribution\n    address public devAddress;\n    address public honeyFundAddress;\n    IBullFarmFund public insuranceFund;\n\n    // Events\n    event Deposit(address account, uint value);\n    event Reinvest(address account, uint value);\n    event Withdraw(address account, uint value);\n    event WithdrawTokens(address account, uint value);\n    event Registration(address account, address upline);\n    event PartnerReward(address account, address upline, uint reward);\n    event FailedPartnerReward(address account, address upline, uint reward);\n    event MissedPartnerReward(address account, address upline, uint reward);\n    event X3FactorApply(address account, uint deposit);\n    event Launch();\n\n    // Modifiers\n    modifier onlyRegistered() {\n        require(users[msg.sender].account != address(0), \"User is not registered\");\n        _;\n    }\n\n    constructor(address _devAddress, address _honeyFundAddress, IBullFarmFund _insuranceFund) {\n        devAddress = _devAddress;\n        honeyFundAddress = _honeyFundAddress;\n        insuranceFund = _insuranceFund;\n        admin = msg.sender;\n        users[admin].account = admin;\n        users[admin].upline = admin;\n        users[admin].openLines = MAX_LINES;\n        unlimited[admin] = true;\n        totalUsers++;\n        PARTNER_PROGRAMS.push([1200, 1000, 800]); //12%, 10%, 8%\n        PARTNER_PROGRAMS.push([1000, 800, 700, 500]); //10%, 8%, 7%, 5%\n        PARTNER_PROGRAMS.push([900, 700, 600, 500, 300]); //9%, 7%, 6%, 5%, 3%\n        PARTNER_PROGRAMS.push([800, 700, 600, 400, 300, 200]); //8%, 7%, 6%, 4%, 3%, 2%\n    }\n\n    receive() external payable { /* Do nothing */ }\n\n    // State changing functions\n    function registerAndDeposit(address upline) payable external {\n        register(upline);\n        depositTo(msg.sender);\n    }\n\n    function register(address upline) public {\n        if(users[upline].account == address(0)) {\n            upline = admin;\n        }\n\n        require(users[msg.sender].account == address(0), \"User is already registered\");\n        require(users[upline].account != address(0), \"Upline is not registered\");\n\n        users[msg.sender].account = msg.sender;\n        users[msg.sender].upline = upline;\n        totalUsers++;\n\n        address curUpline = upline;\n        for(uint line; line < MAX_LINES; line++) {\n            users[curUpline].partnersCountByLine[line]++;\n            if (curUpline != users[curUpline].upline) {\n                curUpline = users[curUpline].upline;\n            } else {\n                break;\n            }\n        }\n\n        emit Registration(msg.sender, upline);\n    }\n\n    function deposit() payable external onlyRegistered {\n        depositTo(msg.sender);\n    }\n\n    function depositTo(address account) payable public {\n        require(launchTimestamp > 0, \"BullFarm: not launched\");\n        require(users[account].account != address(0), \"User is not registered\");\n        require(msg.value >= MIN_DEPOSIT_VALUE, \"Deposit value is too small\");\n        require(users[account].deposit + msg.value <= getCurrentMaxDeposit(), \"Deposit limit exceeded\");\n        require(!waitingMigration[account], \"Migration required before deposit\");\n\n        users[account].deferredProfit += calcProfitForPeriod(users[account].deposit, users[account].lastDepositUpdate, block.timestamp);\n        users[account].lastDepositUpdate = block.timestamp;\n        users[account].deposit += msg.value;\n        users[account].x3Factor += msg.value * 3;\n        users[account].openLines = recalcOpenLines(account);\n\n        distributeFees(msg.value);\n        sendPartnerRewards(account, msg.value);\n\n        emit Deposit(account, msg.value);\n    }\n\n    function reinvest() external onlyRegistered {\n        require(launchTimestamp > 0, \"BullFarm: not launched\");\n        require(users[msg.sender].deposit > 0, \"Nothing to reinvest\");\n\n        uint availableProfit = calcAvailableProfit(msg.sender);\n        require(availableProfit >= MIN_REINVEST_VALUE, \"Reinvest value is too small\");\n        require(users[msg.sender].deposit + availableProfit <= getCurrentMaxDeposit(), \"Reinvest value is too big\");\n\n        users[msg.sender].deferredProfit = 0;\n        users[msg.sender].lastDepositUpdate = block.timestamp;\n        users[msg.sender].deposit += availableProfit;\n        users[msg.sender].x3Factor += availableProfit * 3;\n        users[msg.sender].openLines = recalcOpenLines(msg.sender);\n\n        uint feeAndPartnersReward = availableProfit * (getCurrentTotalPartnersRewardPercents() + TOTAL_FEES) / PERCENTS_DIVISOR;\n        if (address(this).balance >= feeAndPartnersReward) {\n            distributeFees(availableProfit);\n            sendPartnerRewards(msg.sender, availableProfit);\n        }\n\n        emit Reinvest(msg.sender, availableProfit);\n    }\n\n    function withdraw() external onlyRegistered {\n        require(users[msg.sender].lastDepositUpdate > 0, \"No deposits\");\n\n        uint profit = calcAvailableProfit(msg.sender);\n        require(profit > MIN_WITHDRAWAL_VALUE, \"No profit available\");\n\n        users[msg.sender].deferredProfit = 0;\n        users[msg.sender].lastDepositUpdate = block.timestamp;\n\n        if (profit * (PERCENTS_DIVISOR + TOTAL_FEES) / PERCENTS_DIVISOR <= address(this).balance) {\n            users[msg.sender].withdraw += profit;\n            users[msg.sender].x3Factor -= min(profit, users[msg.sender].x3Factor);\n            distributeFees(profit);\n            payable(msg.sender).transfer(profit);\n            emit Withdraw(msg.sender, profit);\n        } else if(users[msg.sender].withdraw < users[msg.sender].deposit) {\n            users[msg.sender].withdraw += profit;\n            users[msg.sender].x3Factor -= min(profit, users[msg.sender].x3Factor);\n            insuranceFund.sendTokens(msg.sender, profit);\n            emit WithdrawTokens(msg.sender, profit);\n        } else {\n            revert(\"Withdrawal failed\");\n        }\n\n        if (users[msg.sender].x3Factor == 0) {\n            applyX3Factor(msg.sender);\n        }\n    }\n\n    function launch() external {\n        require(msg.sender == admin, \"Only admin\");\n        require(launchTimestamp == 0, \"Launch can be used only once\");\n        launchTimestamp = block.timestamp;\n        stageTimestamps = [\n            block.timestamp,\n            block.timestamp + STAGE_PERIOD,\n            block.timestamp + 2 * STAGE_PERIOD,\n            block.timestamp + 3 * STAGE_PERIOD\n        ];\n\n        emit Launch();\n    }\n\n    function setUnlimited(address account) external {\n        require(msg.sender == admin, \"Only admin\");\n        require(launchTimestamp == 0, \"Can be used only before launch\");\n        require(users[account].account == account, \"User is not registered\");\n\n        unlimited[account] = true;\n        users[account].openLines = MAX_LINES;\n    }\n\n    function migrate(address account) external payable {\n        require(msg.sender == lineManager, \"Only lineManager\");\n        require(launchTimestamp > 0, \"BullFarm: not launched\");\n        require(users[account].account != address(0), \"User is not registered\");\n        require(waitingMigration[account], \"Account not waiting for migration\");\n\n        waitingMigration[account] = false;\n        if (users[account].x3Factor > 0) {\n            users[account].lastDepositUpdate = block.timestamp;\n            users[account].deposit = msg.value;\n        }\n\n        distributeFees(msg.value);\n        sendPartnerRewards(account, msg.value);\n\n        emit Deposit(account, msg.value);\n    }\n\n    function setOpenLines(address account, uint lines) external {\n        require(msg.sender == lineManager, \"Only lineManager\");\n        require(launchTimestamp == 0, \"Can be used only before launch\");\n        require(users[account].account == account, \"User is not registered\");\n        require(lines > 0 && lines <= MAX_LINES, \"Invalid lines count\");\n\n        users[account].openLines = lines;\n        users[account].x3Factor = OPEN_LINE_MIN_DEPOSIT[lines - 1] * 3;\n        waitingMigration[account] = true;\n    }\n\n    function setLineManager(address _lineManager) external {\n        require(msg.sender == admin, \"Only admin\");\n        lineManager = _lineManager;\n    }\n\n    // Private functions\n    function distributeFees(uint depositValue) private {\n        uint devFeeValue = depositValue * DEVS_FEE / PERCENTS_DIVISOR;\n        (bool devFeeSent,) = payable(devAddress).call{value : devFeeValue}(\"\");\n        require(devFeeSent, \"Failed to send dev fee\");\n\n        uint honeyFundFeeValue = depositValue * HONEY_BANK_FEE / PERCENTS_DIVISOR;\n        (bool honeyFundFeeSent,) = payable(honeyFundAddress).call{value : honeyFundFeeValue}(\"\");\n        require(honeyFundFeeSent, \"Failed to send Honey Fund fee\");\n\n        uint insuranceFeeValue = depositValue * INSURANCE_FEE / PERCENTS_DIVISOR;\n        bool insuranceFeeSent = payable(address(insuranceFund)).send(insuranceFeeValue);\n        require(insuranceFeeSent, \"Failed to send Insurance Fund fee\");\n    }\n\n    function sendPartnerRewards(address account, uint depositValue) private {\n        uint[] memory partnersProgram = getCurrentPartnersProgram();\n        address upline = users[account].upline;\n        for(uint line; line < partnersProgram.length; line++) {\n            uint reward = depositValue * partnersProgram[line] / PERCENTS_DIVISOR;\n            if (users[upline].openLines > line) {\n                bool sent = payable(upline).send(reward);\n                if (sent) {\n                    users[upline].partnersRewardByLine[line] += reward;\n                    users[upline].x3Factor -= min(reward, users[upline].x3Factor);\n                    if(users[upline].x3Factor == 0) {\n                        applyX3Factor(upline);\n                    }\n                    emit PartnerReward(account, upline, reward);\n                } else {\n                    // Only if receiver is smart contract with broken handler\n                    payable(admin).transfer(reward);\n                    emit FailedPartnerReward(account, upline, reward);\n                }\n            } else {\n                users[upline].missedPartnersRewardByLine[line] += reward;\n                emit MissedPartnerReward(account, upline, reward);\n            }\n\n            upline = users[upline].upline;\n        }\n    }\n\n    function applyX3Factor(address account) private {\n        if (unlimited[account]) {\n            return;\n        }\n\n        users[account].x3FactorCount++;\n        users[account].withdraw = 0;\n        users[account].x3Factor = 0;\n        users[account].lastDepositUpdate = 0;\n        users[account].deferredProfit = 0;\n        users[account].openLines = 0;\n\n        emit X3FactorApply(account, users[account].deposit);\n        users[account].deposit = 0;\n    }\n\n    // View functions\n    function recalcOpenLines(address account) public view returns(uint) {\n        for(uint i = users[account].openLines; i < MAX_LINES; i++) {\n            if (users[account].deposit < OPEN_LINE_MIN_DEPOSIT[i]) {\n                return i;\n            }\n        }\n\n        return MAX_LINES;\n    }\n\n    function getCurrentPartnersProgram() public view returns(uint[] memory) {\n        return PARTNER_PROGRAMS[getCurrentStageIndex()];\n    }\n\n    function getCurrentProfitPercents() public view returns(uint) {\n        return PROFIT_BY_STAGES[getCurrentStageIndex()];\n    }\n\n    function calcAvailableProfit(address account) public view returns(uint) {\n        uint profit = users[account].deferredProfit + calcProfitForPeriod(users[account].deposit, users[account].lastDepositUpdate, block.timestamp);\n        if (unlimited[account]) {\n            return profit;\n        }\n\n        return profit > users[account].x3Factor ? users[account].x3Factor : profit;\n    }\n\n    function calcProfitForPeriod(uint depositValue, uint from, uint to) public view returns(uint) {\n        if (launchTimestamp == 0 || to <= from || to < stageTimestamps[0]) {\n            return 0;\n        }\n\n        uint result;\n\n        // Profit for stage 1\n        if (from < stageTimestamps[1]) {\n            result += calcProfitForStage(depositValue, 0, min(to, stageTimestamps[1]) - max(from, stageTimestamps[0]));\n        }\n\n        // Profit for stage 2\n        if (from < stageTimestamps[2] && to > stageTimestamps[1]) {\n            result += calcProfitForStage(depositValue, 1, min(to, stageTimestamps[2]) - max(from, stageTimestamps[1]));\n        }\n\n        // Profit for stage 3\n        if (from < stageTimestamps[3] && to > stageTimestamps[2]) {\n            result += calcProfitForStage(depositValue, 2, min(to, stageTimestamps[3]) - max(from, stageTimestamps[2]));\n        }\n\n        // Profit for stage 4\n        if (to >= stageTimestamps[3]) {\n            result += calcProfitForStage(depositValue, 3, to - max(from, stageTimestamps[3]));\n        }\n\n        return result;\n    }\n\n    function getCurrentMaxDeposit() public view returns(uint) {\n        uint curMaxDep = INITIAL_MAX_DEPOSIT + MAX_DEPOSIT_DAILY_STEP * ((block.timestamp - launchTimestamp) / 1 days);\n        return curMaxDep > MAX_DEPOSIT ? MAX_DEPOSIT : curMaxDep;\n    }\n\n    function getCurrentStageIndex() public view returns(uint) {\n        uint timeSpent = (block.timestamp - launchTimestamp);\n        if (timeSpent < STAGE_PERIOD) {\n            return 0;\n        } else if (timeSpent < STAGE_PERIOD * 2) {\n            return 1;\n        } else if (timeSpent < STAGE_PERIOD * 3) {\n            return 2;\n        } else {\n            return 3;\n        }\n    }\n\n    function getProfitByStages() external view returns(uint[4] memory) {\n        return PROFIT_BY_STAGES;\n    }\n\n    function getOpenLinesMinDeposit() external view returns(uint[6] memory) {\n        return OPEN_LINE_MIN_DEPOSIT;\n    }\n\n    function getUser(address account) external view returns(User memory) {\n        return users[account];\n    }\n\n    function calcProfitForStage(uint depositValue, uint stageIndex, uint duration) private view returns(uint) {\n        return depositValue * PROFIT_BY_STAGES[stageIndex] * duration * 10000 / 1 days / 10000 / PERCENTS_DIVISOR;\n    }\n\n    function getStageTimestamps() external view returns(uint[] memory) {\n        return stageTimestamps;\n    }\n\n    function getCurrentTotalPartnersRewardPercents() public view returns(uint) {\n        uint result;\n        uint[] memory rewardPercents = getCurrentPartnersProgram();\n        for(uint i; i < rewardPercents.length; i++) {\n            result += rewardPercents[i];\n        }\n\n        return result;\n    }\n\n    function min(uint value1, uint value2) private pure returns(uint) {\n        return value1 < value2 ? value1 : value2;\n    }\n\n    function max(uint value1, uint value2) private pure returns(uint) {\n        return value1 > value2 ? value1 : value2;\n    }\n}"
6     },
7     "contracts/interfaces/IBullFund.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\ninterface IBullFarmFund {\n    function sendTokens(address to, uint ethAmount) external;\n}"
9     }
10   },
11   "settings": {
12     "optimizer": {
13       "enabled": false,
14       "runs": 200
15     },
16     "outputSelection": {
17       "*": {
18         "*": [
19           "evm.bytecode",
20           "evm.deployedBytecode",
21           "devdoc",
22           "userdoc",
23           "metadata",
24           "abi"
25         ]
26       }
27     },
28     "libraries": {}
29   }
30 }}