1 pragma solidity ^0.4.18;
2 contract Token {
3     function transfer(address _to, uint _value) public returns (bool success);
4     function transferFrom(address _from, address _to, uint _value) public returns (bool success);
5     function approve(address _spender, uint _value) public returns (bool success);
6 }
7 contract LocalEthereumEscrows {
8     // The address of the arbitrator
9     // In the first version, this is always localethereum staff.
10     address public arbitrator;
11     address public owner;
12     address public relayer;
13     uint32 public requestCancellationMinimumTime;
14     uint256 public feesAvailableForWithdraw;
15 
16     uint8 constant ACTION_SELLER_CANNOT_CANCEL = 0x01; // Called when marking as paid or calling a dispute as the buyer
17     uint8 constant ACTION_BUYER_CANCEL = 0x02;
18     uint8 constant ACTION_SELLER_CANCEL = 0x03;
19     uint8 constant ACTION_SELLER_REQUEST_CANCEL = 0x04;
20     uint8 constant ACTION_RELEASE = 0x05;
21     uint8 constant ACTION_DISPUTE = 0x06;
22 
23     event Created(bytes32 _tradeHash);
24     event SellerCancelDisabled(bytes32 _tradeHash);
25     event SellerRequestedCancel(bytes32 _tradeHash);
26     event CancelledBySeller(bytes32 _tradeHash);
27     event CancelledByBuyer(bytes32 _tradeHash);
28     event Released(bytes32 _tradeHash);
29     event DisputeResolved(bytes32 _tradeHash);
30 
31     struct Escrow {
32         // Set so we know the trade has already been created
33         bool exists;
34         // The timestamp in which the seller can cancel the trade if the buyer has not yet marked as paid. Set to 0 on marked paid or dispute
35         // 1 = unlimited cancel time
36         uint32 sellerCanCancelAfter;
37         // The total cost of gas spent by relaying parties. This amount will be
38         // refunded/paid to localethereum.com once the escrow is finished.
39         uint128 totalGasFeesSpentByRelayer;
40     }
41     // Mapping of active trades. Key is a hash of the trade data
42     mapping (bytes32 => Escrow) public escrows;
43 
44     modifier onlyOwner() {
45         require(msg.sender == owner);
46         _;
47     }
48 
49     modifier onlyArbitrator() {
50         require(msg.sender == arbitrator);
51         _;
52     }
53 
54     function getRelayedSender(
55       bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com
56       uint8 _actionByte, // The desired action of the user, matching an ACTION_* constant
57       uint128 _maximumGasPrice, // The maximum gas price the user is willing to pay
58       uint8 _v, // Signature value
59       bytes32 _r, // Signature value
60       bytes32 _s // Signature value
61     ) view private returns (address) {
62         bytes32 _hash = keccak256(_tradeID, _actionByte, _maximumGasPrice);
63         if(tx.gasprice > _maximumGasPrice) return;
64         return ecrecover(_hash, _v, _r, _s);
65     }
66 
67     function LocalEthereumEscrows() public {
68         /**
69          * Initialize the contract.
70          */
71         owner = msg.sender;
72         arbitrator = msg.sender;
73         relayer = msg.sender;
74         requestCancellationMinimumTime = 2 hours; // TODO
75     }
76 
77     function getEscrowAndHash(
78       /**
79        * Hashes the values and returns the matching escrow object and trade hash.
80        * Returns an empty escrow struct and 0 _tradeHash if not found
81        */
82       bytes16 _tradeID,
83       address _seller,
84       address _buyer,
85       uint256 _value,
86       uint16 _fee
87     ) view private returns (Escrow, bytes32) {
88         bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);
89         return (escrows[_tradeHash], _tradeHash);
90     }
91 
92     function createEscrow(
93       /**
94        * Create a new escrow and add it to `escrows`.
95        * _tradeHash is created by hashing _tradeID, _seller, _buyer, _value and _fee variables. These variables must be supplied on future contract calls.
96        * v, r and s is the signature data supplied from the api. The sig is keccak256(_tradeHash, _paymentWindowInSeconds, _expiry).
97        */
98       bytes16 _tradeID, // The unique ID of the trade, generated by localethereum.com
99       address _seller, // The selling party of the trade
100       address _buyer, // The buying party of the trade
101       uint256 _value, // The ether amount being held in escrow
102       uint16 _fee, // The localethereum.com fee in 1/10000ths
103       uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the buyer has to mark as paid
104       uint32 _expiry, // Provided by localethereum.com. This transaction must be created before this time.
105       uint8 _v, // Signature value
106       bytes32 _r, // Signature value
107       bytes32 _s // Signature value
108     ) payable external {
109         bytes32 _tradeHash = keccak256(_tradeID, _seller, _buyer, _value, _fee);
110         require(!escrows[_tradeHash].exists); // Require that trade does not already exist
111         require(ecrecover(keccak256(_tradeHash, _paymentWindowInSeconds, _expiry), _v, _r, _s) == relayer); // Signature must have come from the relayer
112         require(block.timestamp < _expiry);
113         require(msg.value == _value && msg.value > 0); // Check sent eth against signed _value and make sure is not 0
114         uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32(block.timestamp) + _paymentWindowInSeconds;
115         escrows[_tradeHash] = Escrow(true, _sellerCanCancelAfter, 0);
116         Created(_tradeHash);
117     }
118 
119     uint16 constant GAS_doRelease = 36100;
120     function doRelease(
121       /**
122        * Called by the seller to releases the funds for a successful trade.
123        * Deletes the trade from the `escrows` mapping.
124        */
125       bytes16 _tradeID,
126       address _seller,
127       address _buyer,
128       uint256 _value,
129       uint16 _fee,
130       uint128 _additionalGas
131     ) private returns (bool) {
132         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
133         if (!_escrow.exists) return false;
134         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doRelease + _additionalGas) * uint128(tx.gasprice) : 0);
135         delete escrows[_tradeHash];
136         Released(_tradeHash);
137         transferMinusFees(_buyer, _value, _gasFees, _fee);
138         return true;
139     }
140 
141     uint16 constant GAS_doDisableSellerCancel = 12100;
142     function doDisableSellerCancel(
143       /**
144        * Stops the seller from cancelling the trade.
145        * Can only be called the buyer.
146        * Used to mark the trade as paid, or if the buyer has a dispute.
147        */
148       bytes16 _tradeID,
149       address _seller,
150       address _buyer,
151       uint256 _value,
152       uint16 _fee,
153       uint128 _additionalGas
154     ) private returns (bool) {
155         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
156         if (!_escrow.exists) return false;
157         if(_escrow.sellerCanCancelAfter == 0) return false;
158         escrows[_tradeHash].sellerCanCancelAfter = 0;
159         SellerCancelDisabled(_tradeHash);
160         if (msg.sender == relayer) {
161           increaseGasSpent(_tradeHash, GAS_doDisableSellerCancel + _additionalGas);
162         }
163         return true;
164     }
165 
166     uint16 constant GAS_doBuyerCancel = 36100;
167     function doBuyerCancel(
168       /**
169        * Cancels the trade and returns the ether to the seller.
170        * Can only be called the buyer.
171        */
172       bytes16 _tradeID,
173       address _seller,
174       address _buyer,
175       uint256 _value,
176       uint16 _fee,
177       uint128 _additionalGas
178     ) private returns (bool) {
179         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
180         if (!_escrow.exists) return false;
181         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doBuyerCancel + _additionalGas) * uint128(tx.gasprice) : 0);
182         delete escrows[_tradeHash];
183         CancelledByBuyer(_tradeHash);
184         transferMinusFees(_seller, _value, _gasFees, 0);
185         return true;
186     }
187 
188     uint16 constant GAS_doSellerCancel = 36100;
189     function doSellerCancel(
190       /**
191        * Cancels the trade and returns the ether to the seller.
192        * Can only be called the seller.
193        * Can only be called if the payment window was missed by the buyer
194        */
195       bytes16 _tradeID,
196       address _seller,
197       address _buyer,
198       uint256 _value,
199       uint16 _fee,
200       uint128 _additionalGas
201     ) private returns (bool) {
202         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
203         if (!_escrow.exists) return false;
204         if(_escrow.sellerCanCancelAfter <= 1 || _escrow.sellerCanCancelAfter > block.timestamp) return false;
205         uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer + (msg.sender == relayer ? (GAS_doSellerCancel + _additionalGas) * uint128(tx.gasprice) : 0);
206         delete escrows[_tradeHash];
207         CancelledBySeller(_tradeHash);
208         transferMinusFees(_seller, _value, _gasFees, 0);
209         return true;
210     }
211 
212     uint16 constant GAS_doSellerRequestCancel = 12100;
213     function doSellerRequestCancel(
214       /**
215        * Called by the seller if the buyer is unresponsive
216        * Can only be called on unlimited payment window trades (sellerCanCancelAfter == 1)
217        * Sets the payment window to `requestCancellationMinimumTime` from now, in which it can be cancelled.
218        */
219       bytes16 _tradeID,
220       address _seller,
221       address _buyer,
222       uint256 _value,
223       uint16 _fee,
224       uint128 _additionalGas
225     ) private returns (bool) {
226         // Called on unlimited payment window trades wheret the buyer is not responding
227         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
228         if (!_escrow.exists) return false;
229         if(_escrow.sellerCanCancelAfter != 1) return false;
230         escrows[_tradeHash].sellerCanCancelAfter = uint32(block.timestamp) + requestCancellationMinimumTime;
231         SellerRequestedCancel(_tradeHash);
232         if (msg.sender == relayer) {
233           increaseGasSpent(_tradeHash, GAS_doSellerRequestCancel + _additionalGas);
234         }
235         return true;
236     }
237 
238     uint16 constant GAS_doResolveDispute = 36100;
239     function resolveDispute(
240       /**
241        * Called by the arbitrator to resolve a dispute
242        * Requires the signed ACTION_DISPUTE actionByte from either the buyer or the seller
243        */
244       bytes16 _tradeID,
245       address _seller,
246       address _buyer,
247       uint256 _value,
248       uint16 _fee,
249       uint8 _v,
250       bytes32 _r,
251       bytes32 _s,
252       uint8 _buyerPercent
253     ) external onlyArbitrator {
254         address _signature = ecrecover(keccak256(_tradeID, ACTION_DISPUTE), _v, _r, _s);
255         require(_signature == _buyer || _signature == _seller);
256 
257         var (_escrow, _tradeHash) = getEscrowAndHash(_tradeID, _seller, _buyer, _value, _fee);
258         require(_escrow.exists);
259         require(_buyerPercent <= 100);
260 
261         uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer + GAS_doResolveDispute;
262         require(_value - _totalFees <= _value); // Prevent underflow
263         feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw
264 
265         delete escrows[_tradeHash];
266         DisputeResolved(_tradeHash);
267         _buyer.transfer((_value - _totalFees) * _buyerPercent / 100);
268         _seller.transfer((_value - _totalFees) * (100 - _buyerPercent) / 100);
269     }
270 
271     function release(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool){
272       require(msg.sender == _seller);
273       return doRelease(_tradeID, _seller, _buyer, _value, _fee, 0);
274     }
275     function disableSellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {
276       require(msg.sender == _buyer);
277       return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
278     }
279     function buyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {
280       require(msg.sender == _buyer);
281       return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
282     }
283     function sellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {
284       require(msg.sender == _seller);
285       return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
286     }
287     function sellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee) external returns (bool) {
288       require(msg.sender == _seller);
289       return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, 0);
290     }
291 
292     function relaySellerCannotCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {
293       return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANNOT_CANCEL, 0);
294     }
295     function relayBuyerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {
296       return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_BUYER_CANCEL, 0);
297     }
298     function relayRelease(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {
299       return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_RELEASE, 0);
300     }
301     function relaySellerCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {
302       return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_CANCEL, 0);
303     }
304     function relaySellerRequestCancel(bytes16 _tradeID, address _seller, address _buyer, uint256 _value, uint16 _fee, uint128 _maximumGasPrice, uint8 _v, bytes32 _r, bytes32 _s) external returns (bool) {
305       return relay(_tradeID, _seller, _buyer, _value, _fee, _maximumGasPrice, _v, _r, _s, ACTION_SELLER_REQUEST_CANCEL, 0);
306     }
307 
308     function relay(
309       bytes16 _tradeID,
310       address _seller,
311       address _buyer,
312       uint256 _value,
313       uint16 _fee,
314       uint128 _maximumGasPrice,
315       uint8 _v,
316       bytes32 _r,
317       bytes32 _s,
318       uint8 _actionByte,
319       uint128 _additionalGas
320     ) private returns (bool) {
321       address _relayedSender = getRelayedSender(_tradeID, _actionByte, _maximumGasPrice, _v, _r, _s);
322       if (_relayedSender == _buyer) {
323         if (_actionByte == ACTION_SELLER_CANNOT_CANCEL) {
324           return doDisableSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
325         } else if (_actionByte == ACTION_BUYER_CANCEL) {
326           return doBuyerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
327         }
328       } else if (_relayedSender == _seller) {
329         if (_actionByte == ACTION_RELEASE) {
330           return doRelease(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
331         } else if (_actionByte == ACTION_SELLER_CANCEL) {
332           return doSellerCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
333         } else if (_actionByte == ACTION_SELLER_REQUEST_CANCEL){
334           return doSellerRequestCancel(_tradeID, _seller, _buyer, _value, _fee, _additionalGas);
335         }
336       } else {
337         return false;
338       }
339     }
340 
341     uint16 constant GAS_batchRelayBaseCost = 28500;
342     function batchRelay(
343       /**
344        * Call multiple relay methods at once to save on gas.
345        */
346         bytes16[] _tradeID,
347         address[] _seller,
348         address[] _buyer,
349         uint256[] _value,
350         uint16[] _fee,
351         uint128[] _maximumGasPrice,
352         uint8[] _v,
353         bytes32[] _r,
354         bytes32[] _s,
355         uint8[] _actionByte
356     ) public returns (bool[]) {
357         bool[] memory _results = new bool[](_tradeID.length);
358         uint128 _additionalGas = uint128(msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0);
359         for (uint8 i=0; i<_tradeID.length; i++) {
360             _results[i] = relay(_tradeID[i], _seller[i], _buyer[i], _value[i], _fee[i], _maximumGasPrice[i], _v[i], _r[i], _s[i], _actionByte[i], _additionalGas);
361         }
362         return _results;
363     }
364 
365     function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {
366         /** Increase `totalGasFeesSpentByRelayer` to be charged later on completion of the trade.
367          */
368         escrows[_tradeHash].totalGasFeesSpentByRelayer += _gas * uint128(tx.gasprice);
369     }
370 
371     function transferMinusFees(address _to, uint256 _value, uint128 _totalGasFeesSpentByRelayer, uint16 _fee) private {
372         uint256 _totalFees = (_value * _fee / 10000) + _totalGasFeesSpentByRelayer;
373         if(_value - _totalFees > _value) return; // Prevent underflow
374         feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw
375         _to.transfer(_value - _totalFees);
376     }
377 
378     function withdrawFees(address _to, uint256 _amount) onlyOwner external {
379       /**
380        * Withdraw fees collected by the contract. Only the owner can call this.
381        */
382         require(_amount <= feesAvailableForWithdraw); // Also prevents underflow
383         feesAvailableForWithdraw -= _amount;
384         _to.transfer(_amount);
385     }
386 
387     function setArbitrator(address _newArbitrator) onlyOwner external {
388         /**
389          * Set the arbitrator to a new address. Only the owner can call this.
390          * @param address _newArbitrator
391          */
392         arbitrator = _newArbitrator;
393     }
394 
395     function setOwner(address _newOwner) onlyOwner external {
396         /**
397          * Change the owner to a new address. Only the owner can call this.
398          * @param address _newOwner
399          */
400         owner = _newOwner;
401     }
402 
403     function setRelayer(address _newRelayer) onlyOwner external {
404         /**
405          * Change the relayer to a new address. Only the owner can call this.
406          * @param address _newRelayer
407          */
408         relayer = _newRelayer;
409     }
410 
411     function setRequestCancellationMinimumTime(uint32 _newRequestCancellationMinimumTime) onlyOwner external {
412         /**
413          * Change the requestCancellationMinimumTime. Only the owner can call this.
414          * @param uint32 _newRequestCancellationMinimumTime
415          */
416         requestCancellationMinimumTime = _newRequestCancellationMinimumTime;
417     }
418 
419     function transferToken(Token _tokenContract, address _transferTo, uint256 _value) onlyOwner external {
420         /**
421          * If ERC20 tokens are sent to this contract, they will be trapped forever.
422          * This function is way for us to withdraw them so we can get them back to their rightful owner
423          */
424          _tokenContract.transfer(_transferTo, _value);
425     }
426     function transferTokenFrom(Token _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external {
427         /**
428          * If ERC20 tokens are sent to this contract, they will be trapped forever.
429          * This function is way for us to withdraw them so we can get them back to their rightful owner
430          */
431          _tokenContract.transferFrom(_transferTo, _transferFrom, _value);
432     }
433     function approveToken(Token _tokenContract, address _spender, uint256 _value) onlyOwner external {
434         /**
435          * If ERC20 tokens are sent to this contract, they will be trapped forever.
436          * This function is way for us to withdraw them so we can get them back to their rightful owner
437          */
438          _tokenContract.approve(_spender, _value);
439     }
440 }