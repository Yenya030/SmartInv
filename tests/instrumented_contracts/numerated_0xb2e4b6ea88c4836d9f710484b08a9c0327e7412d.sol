1 /**
2 程煜团伙通过五个山寨Fus基金类Dapp诈骗超过1500eth,各界同仁联合起来，铲除诈骗团伙，保护大众安全，还区块链健康环境
3 
4 ---
5 
6 2018年到2019年对于区块链是不堪回首的一年，多数虚拟资产缩水超过95%。就在这种不易且不堪的大环境中，还有许多山寨传销的诈骗团伙，骗取广大区块链社区用户的大量虚拟资产。人是应该有底线的，不应该把人往死路上推。做恶是应该受到惩罚的！！！
7 我们号召广大受害者成立春之盟维权社区联盟，搜集诈骗团伙的违法证据，并用合理的方式提交给公安机关和法院。如果大家置之不理，那就是纵容，那就是助纣为虐，程煜一伙必将祸害更多的无辜群众
8 春之盟社区QQ群：14363934 电报群t.me/chunzhimeng 微信 231799955
9 春之盟社区采用举报奖励机制，当作恶者伏法之后，提供有用信息者，奖励10eth,提供重大关键线索者，奖励100eth。
10 以下是春之盟基金会资产截图：
11 
12 ![Image text](https://www.btc36.com/fus/1.jpg)
13 
14 ![Image text](https://www.btc36.com/fus/2.jpg)
15 
16 下面公布陈煜骗子团伙详细资料信息
17 
18 银行卡 李燕 6222024402039562529
19 
20 微信号 
21 
22       chengyuchengyugood
23 
24       chengchenggogogogo
25 
26       Love198708100
27 
28 WXID 
29 
30      wxid_lwk01vm5shp22
31 
32      wxid_0brbon0vdh7i12
33 
34       wxid_ndlgwxj5gn5q22
35 
36       wxid_onqp99i98zgz22
37 
38 微信名 
39 
40       yer
41 
42       Yetta
43 
44       拉拉
45 
46       阿亮
47             
48 
49 微信转账 
50 
51         1000050201201810251500357518278
52 
53         1000050201201810291400720419169
54 
55         1000050201201810300200672611120
56 
57 城市 河北 秦皇岛 
58 
59 本名 程煜
60 
61 曾用名 阿亮 
62 
63 出生日期 1987年8月10日
64 
65 手机：85268518708
66 
67 自毁合约地址 [0x22DD339F871f6480073d706093Fa2630B9f6f8b5](https://etherscan.io/address/0x22DD339F871f6480073d706093Fa2630B9f6f8b5)（FIT健康基金）270eth
68                    [0x73A56eF997Bc7D7E0d2A606586b41AcfEc8120D8](https://etherscan.io/address/0x73A56eF997Bc7D7E0d2A606586b41AcfEc8120D8)（FIT宝贝）12eth
69                    [0xF8C791A0897BcF636d22b0F4bF703EC73Fd5D69b](https://etherscan.io/address/0xF8C791A0897BcF636d22b0F4bF703EC73Fd5D69b)（FUS人民基金）854eth
70                    [0x05F32908A4A010e2Bca02d2675641f22e0c86aD2](https://etherscan.io/address/0x05f32908a4a010e2bca02d2675641f22e0c86ad2)(AWT金字塔) 101eth
71                    [0x328C56A62768913b845c7864d46941c46b93d475](https://etherscan.io/address/0x328C56A62768913b845c7864d46941c46b93d475)（FUS生态）205eth
72                    
73 FUS代币地址 [0xa14839c9837657EFcDE754EbEAF5cbECDd801B2A](https://etherscan.io/address/0xa14839c9837657EFcDE754EbEAF5cbECDd801B2A)
74 
75 FUND代币地址 [0x608f7dF36409888D17Ad1fCf258e59880840742E](https://etherscan.io/address/0x608f7dF36409888D17Ad1fCf258e59880840742E)
76 
77 FIT代币地址 [0xC98449EF8a017cfD29AED8b21B9B26492978a898](https://etherscan.io/address/0xC98449EF8a017cfD29AED8b21B9B26492978a898)
78 
79 充值交易所地址 [0x7EF35bb398E0416b81b019fEa395219B65c52164](https://etherscan.io/address/0x7ef35bb398e0416b81b019fea395219b65c52164)(（火币）
80 （[0x123b6fAFA57C3e522094C2f82cc18dEbF1AEFc75](https://etherscan.io/address/0x123b6fAFA57C3e522094C2f82cc18dEbF1AEFc75) 充值地址）
81                       [0xf775a9a0Ad44807bc15936dF0Ee68902aF1A0EEE](https://etherscan.io/address/0xf775a9a0Ad44807bc15936dF0Ee68902aF1A0EEE) （火币）
82 （[0x6C08fB8AAd24B472301CE868AC1F86657D14f3b3](https://etherscan.io/address/0x6C08fB8AAd24B472301CE868AC1F86657D14f3b3) 充值地址）
83                       [0xEec606A66edB6f497662Ea31b5eb1610da87AB5f](https://etherscan.io/address/0xeec606a66edb6f497662ea31b5eb1610da87ab5f)（火币）
84 （[0xe694A922Bf1F832A6E1363a1F276F9eC6cfef989](https://etherscan.io/address/0xe694A922Bf1F832A6E1363a1F276F9eC6cfef989)（充值地址）
85 
86 下方是程煜诈骗团伙图片与视频
87 
88 ![Image text](https://www.btc36.com/fus/3.jpeg)
89 
90 ![Image text](https://www.btc36.com/fus/4.jpeg)
91 
92 ![Image text](https://www.btc36.com/fus/5.jpeg)
93 
94 ![Image text](https://www.btc36.com/fus/6.jpeg)
95 
96 ![Image text](https://www.btc36.com/fus/7.jpeg)
97 
98 ![Image text](https://www.btc36.com/fus/8.jpeg)
99 
100 ![Image text](https://www.btc36.com/fus/9.jpeg)
101 
102 ![Image text](https://www.btc36.com/fus/10.jpeg)
103 
104 ![Image text](https://www.btc36.com/fus/11.jpeg)
105 
106 ![Image text](https://www.btc36.com/fus/12.jpeg)
107 
108 ![Image text](https://www.btc36.com/fus/13.jpeg)
109 
110 ![Image text](https://www.btc36.com/fus/14.jpeg)
111 
112 ![Image text](https://www.btc36.com/fus/15.jpeg)
113 
114 ![Image text](https://www.btc36.com/fus/16.png)
115 
116 ![Image text](https://www.btc36.com/fus/17.png)
117 
118 ![Image text](https://www.btc36.com/fus/18.png)
119 
120 
121 本人将实名举报和报案给全国多家主观机构，不会牵扯任何其他的信息提供者。
122 
123 本人电话13438082089（短信），QQ与微信：231799955
124 
125 或扫描下方二维码
126 
127 ![Image text](https://www.btc36.com/wechat.jpeg)
128 
129  */
130 
131 pragma solidity ^0.4.18;
132 
133 /**
134  * @title ERC20Basic
135  * @dev Simpler version of ERC20 interface
136  * @dev see https://github.com/ethereum/EIPs/issues/179
137  */
138 contract ERC20Basic {
139   uint256 public totalSupply;
140   function balanceOf(address who) public view returns (uint256);
141   function transfer(address to, uint256 value) public returns (bool);
142   event Transfer(address indexed from, address indexed to, uint256 value);
143 }
144 
145 /**
146  * @title ERC20 interface
147  * @dev see https://github.com/ethereum/EIPs/issues/20
148  */
149 contract ERC20 is ERC20Basic {
150   function allowance(address owner, address spender) public view returns (uint256);
151   function transferFrom(address from, address to, uint256 value) public returns (bool);
152   function approve(address spender, uint256 value) public returns (bool);
153   event Approval(address indexed owner, address indexed spender, uint256 value);
154 }
155 
156 
157 /**
158  * @title SafeMath
159  * @dev Math operations with safety checks that throw on error
160  */
161 library SafeMath {
162   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
163     if (a == 0) {
164       return 0;
165     }
166     uint256 c = a * b;
167     assert(c / a == b);
168     return c;
169   }
170 
171   function div(uint256 a, uint256 b) internal pure returns (uint256) {
172     // assert(b > 0); // Solidity automatically throws when dividing by 0
173     uint256 c = a / b;
174     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
175     return c;
176   }
177 
178   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
179     assert(b <= a);
180     return a - b;
181   }
182 
183   function add(uint256 a, uint256 b) internal pure returns (uint256) {
184     uint256 c = a + b;
185     assert(c >= a);
186     return c;
187   }
188 }
189 
190 
191 /**
192  * @title Basic token
193  * @dev Basic version of StandardToken, with no allowances.
194  */
195 contract BasicToken is ERC20Basic {
196   using SafeMath for uint256;
197 
198   mapping(address => uint256) balances;
199 
200   /**
201   * @dev transfer token for a specified address
202   * @param _to The address to transfer to.
203   * @param _value The amount to be transferred.
204   */
205   function transfer(address _to, uint256 _value) public returns (bool) {
206     require(_to != address(0));
207     require(_value <= balances[msg.sender]);
208 
209     // SafeMath.sub will throw if there is not enough balance.
210     balances[msg.sender] = balances[msg.sender].sub(_value);
211     balances[_to] = balances[_to].add(_value);
212     Transfer(msg.sender, _to, _value);
213     return true;
214   }
215 
216   /**
217   * @dev Gets the balance of the specified address.
218   * @param _owner The address to query the the balance of.
219   * @return An uint256 representing the amount owned by the passed address.
220   */
221   function balanceOf(address _owner) public view returns (uint256 balance) {
222     return balances[_owner];
223   }
224 
225 }
226 
227 /**
228  * @title Standard ERC20 token
229  *
230  * @dev Implementation of the basic standard token.
231  * @dev https://github.com/ethereum/EIPs/issues/20
232  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
233  */
234 contract StandardToken is ERC20, BasicToken {
235 
236   mapping (address => mapping (address => uint256)) internal allowed;
237 
238 
239   /**
240    * @dev Transfer tokens from one address to another
241    * @param _from address The address which you want to send tokens from
242    * @param _to address The address which you want to transfer to
243    * @param _value uint256 the amount of tokens to be transferred
244    */
245   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
246     require(_to != address(0));
247     require(_value <= balances[_from]);
248     require(_value <= allowed[_from][msg.sender]);
249 
250     balances[_from] = balances[_from].sub(_value);
251     balances[_to] = balances[_to].add(_value);
252     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
253     Transfer(_from, _to, _value);
254     return true;
255   }
256 
257   /**
258    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
259    *
260    * Beware that changing an allowance with this method brings the risk that someone may use both the old
261    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
262    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
263    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
264    * @param _spender The address which will spend the funds.
265    * @param _value The amount of tokens to be spent.
266    */
267   function approve(address _spender, uint256 _value) public returns (bool) {
268     allowed[msg.sender][_spender] = _value;
269     Approval(msg.sender, _spender, _value);
270     return true;
271   }
272 
273   /**
274    * @dev Function to check the amount of tokens that an owner allowed to a spender.
275    * @param _owner address The address which owns the funds.
276    * @param _spender address The address which will spend the funds.
277    * @return A uint256 specifying the amount of tokens still available for the spender.
278    */
279   function allowance(address _owner, address _spender) public view returns (uint256) {
280     return allowed[_owner][_spender];
281   }
282 
283   /**
284    * approve should be called when allowed[_spender] == 0. To increment
285    * allowed value is better to use this function to avoid 2 calls (and wait until
286    * the first transaction is mined)
287    * From MonolithDAO Token.sol
288    */
289   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
290     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
291     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
292     return true;
293   }
294 
295   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
296     uint oldValue = allowed[msg.sender][_spender];
297     if (_subtractedValue > oldValue) {
298       allowed[msg.sender][_spender] = 0;
299     } else {
300       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
301     }
302     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
303     return true;
304   }
305 
306 }
307 
308 /**
309  * @title Ownable
310  * @dev The Ownable contract has an owner address, and provides basic authorization control
311  * functions, this simplifies the implementation of "user permissions".
312  */
313 contract Ownable {
314   address public owner;
315 
316 
317   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
318 
319 
320   /**
321    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
322    * account.
323    */
324   function Ownable() public {
325     owner = msg.sender;
326   }
327 
328 
329   /**
330    * @dev Throws if called by any account other than the owner.
331    */
332   modifier onlyOwner() {
333     require(msg.sender == owner);
334     _;
335   }
336 
337 
338   /**
339    * @dev Allows the current owner to transfer control of the contract to a newOwner.
340    * @param newOwner The address to transfer ownership to.
341    */
342   function transferOwnership(address newOwner) public onlyOwner {
343     require(newOwner != address(0));
344     OwnershipTransferred(owner, newOwner);
345     owner = newOwner;
346   }
347 
348 }
349 
350 /**
351  * @title Pausable
352  * @dev Base contract which allows children to implement an emergency stop mechanism.
353  */
354 contract Pausable is Ownable {
355   event PausePublic(bool newState);
356   event PauseOwnerAdmin(bool newState);
357 
358   bool public pausedPublic = false;
359   bool public pausedOwnerAdmin = false;
360 
361   address public admin;
362 
363   /**
364    * @dev Modifier to make a function callable based on pause states.
365    */
366   modifier whenNotPaused() {
367     if(pausedPublic) {
368       if(!pausedOwnerAdmin) {
369         require(msg.sender == admin || msg.sender == owner);
370       } else {
371         revert();
372       }
373     }
374     _;
375   }
376 
377   /**
378    * @dev called by the owner to set new pause flags
379    * pausedPublic can't be false while pausedOwnerAdmin is true
380    */
381   function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public {
382     require(!(newPausedPublic == false && newPausedOwnerAdmin == true));
383 
384     pausedPublic = newPausedPublic;
385     pausedOwnerAdmin = newPausedOwnerAdmin;
386 
387     PausePublic(newPausedPublic);
388     PauseOwnerAdmin(newPausedOwnerAdmin);
389   }
390 }
391 
392 contract PausableToken is StandardToken, Pausable {
393 
394   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
395     return super.transfer(_to, _value);
396   }
397 
398   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
399     return super.transferFrom(_from, _to, _value);
400   }
401 
402   function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
403     return super.approve(_spender, _value);
404   }
405 
406   function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
407     return super.increaseApproval(_spender, _addedValue);
408   }
409 
410   function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
411     return super.decreaseApproval(_spender, _subtractedValue);
412   }
413 }
414 
415 
416 contract FUSToken is PausableToken {
417     string  public  constant name = "QQ微信231799955";
418     string  public  constant symbol = "通缉FUS骗子陈煜维权QQ微信231799955";
419     uint8   public  constant decimals = 18;
420 
421     modifier validDestination( address to )
422     {
423         require(to != address(0x0));
424         require(to != address(this));
425         _;
426     }
427 
428     function FUSToken( address _admin, uint _totalTokenAmount ) 
429     {
430         // assign the admin account
431         admin = _admin;
432 
433         // assign the total tokens to FUS
434         totalSupply = _totalTokenAmount;
435         balances[msg.sender] = _totalTokenAmount;
436         Transfer(address(0x0), msg.sender, _totalTokenAmount);
437     }
438 
439     function transfer(address _to, uint _value) validDestination(_to) returns (bool) 
440     {
441         return super.transfer(_to, _value);
442     }
443 
444     function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) 
445     {
446         return super.transferFrom(_from, _to, _value);
447     }
448 
449     event Burn(address indexed _burner, uint _value);
450 
451     function burn(uint _value) returns (bool)
452     {
453         balances[msg.sender] = balances[msg.sender].sub(_value);
454         totalSupply = totalSupply.sub(_value);
455         Burn(msg.sender, _value);
456         Transfer(msg.sender, address(0x0), _value);
457         return true;
458     }
459 
460     // save some gas by making only one contract call
461     function burnFrom(address _from, uint256 _value) returns (bool) 
462     {
463         assert( transferFrom( _from, msg.sender, _value ) );
464         return burn(_value);
465     }
466 
467     function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner {
468         // owner can drain tokens that are sent here by mistake
469         token.transfer( owner, amount );
470     }
471 
472     event AdminTransferred(address indexed previousAdmin, address indexed newAdmin);
473 
474     function changeAdmin(address newAdmin) onlyOwner {
475         // owner can re-assign the admin
476         AdminTransferred(admin, newAdmin);
477         admin = newAdmin;
478     }
479 }