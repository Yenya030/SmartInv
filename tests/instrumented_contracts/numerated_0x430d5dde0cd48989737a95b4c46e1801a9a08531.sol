1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/ERC721StakingContract/AceStaking.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// Creator: andreitoma8\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC1820Implementer.sol\";\n\ncontract AceStaking is\n    Ownable,\n    ReentrancyGuard,\n    IERC721Receiver,\n    IERC777Sender,\n    IERC777Recipient,\n    ERC1820Implementer\n{\n    // Interfaces for ERC777 and ERC721\n    IERC777 public immutable rewardsToken;\n    mapping(address => IERC721) public nftContracts;\n    address[] public nftContractAddresses;\n\n    // Reward Settings\n    mapping(address => uint256) public rewardsForContract;\n    mapping(address => mapping(uint256 => uint256))\n        public additionalRewardsForToken;\n\n    uint256 public rewardPeriodInSeconds;\n    uint256 public totalTokensStakedCount;\n    address internal REWARD_UPDATER;\n\n    // Definition of Staker\n    struct Staker {\n        uint256 unclaimedRewards;\n        uint256 lifetimeRewards;\n        uint256 lastRewardedAt;\n        uint256 lastClaimedAt;\n    }\n\n    // This is how we expect Tokens to be sent\n    struct TokenData {\n        address contractAddress;\n        uint256 tokenIdentifier;\n    }\n\n    // How we keep track of a Staked token\n    struct StakedToken {\n        address contractAddress;\n        uint256 tokenIdentifier;\n        uint256 lastRewardedAt;\n        uint256 stakedAt;\n    }\n\n    event UnstakedNFT(StakedToken stakedToken, address indexed staker);\n    event StakedNFT(StakedToken stakedToken, address indexed staker);\n    event RewardClaimed(address indexed staker, uint256 indexed amount);\n\n    address[] public currentStakers;\n    mapping(address => Staker) public stakers;\n    mapping(address => StakedToken[]) public stakedTokensForAddress;\n    mapping(address => mapping(uint256 => address)) public stakedTokenOwner;\n    mapping(uint256 => mapping(address => uint256))\n        internal sharesForWalletInRound;\n    mapping(uint256 => address[]) internal walletsToRewardInRound;\n    uint256 internal currentRoundId;\n\n    uint256 public slashingPeriod = 24;\n\n    // ERC777 Definitions\n    event TokensToSendCalled(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData,\n        address token,\n        uint256 fromBalance,\n        uint256 toBalance\n    );\n\n    event TokensReceivedCalled(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData,\n        address token,\n        uint256 fromBalance,\n        uint256 toBalance\n    );\n\n    bool private _shouldRevertSend;\n    bool private _shouldRevertReceive;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY =\n        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =\n        keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    /**\n     * @dev Setsup the new Contract.\n     *\n     * @param _rewardsToken A ERC777 Token. Can't be changed!\n     * @param _rewardPeriodInSeconds Every x Seconds the Reward gets emitted. Can't be changed! Needs to be at least 60 Seconds but at least a day is recommneded.\n     */\n    constructor(IERC777 _rewardsToken, uint256 _rewardPeriodInSeconds) {\n        require(\n            _rewardPeriodInSeconds > 60,\n            \"AceStaking: Rewards need to be paid at least once per minute\"\n        );\n        rewardsToken = _rewardsToken;\n        rewardPeriodInSeconds = _rewardPeriodInSeconds;\n        REWARD_UPDATER = msg.sender;\n        _ERC1820_REGISTRY.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n        _ERC1820_REGISTRY.setInterfaceImplementer(\n            address(this),\n            _TOKENS_SENDER_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Call this function to add a new NFT Contract to be accepted for staking.\n     * Each contract can have differen rewards.\n     *\n     * Requirements: onlyOwner can add new Contracts; Contract needs to be ERC721 compliant.\n     * @param _nftContract A ERC721 Contract that can be used for staking.\n     * @param _reward ERC777 Token Value that is rewarded for each token every rewardPeriodInSeconds.\n     */\n    function addNFTContract(IERC721 _nftContract, uint256 _reward)\n        public\n        onlyOwner\n    {\n        nftContracts[address(_nftContract)] = _nftContract;\n        nftContractAddresses.push(address(_nftContract));\n        rewardsForContract[address(_nftContract)] = _reward;\n    }\n\n    /**\n     * @dev Call this function to remove a NFT contract from beeing accepted for staking.\n     * All tokens remain in the contract but wont receive any further rewards. They can be withdrawn by\n     * the token owner.\n     * Warning: Additional Rewards might stay in place, so call setAdditionalRewardsForTokens first and set their reward to 0.\n     *\n     * Requirements: onlyOwner can remove Contracts; Contract needs to be ERC721 compliant and already added through addNFTContract.\n     * @param _nftContract A ERC721 Contract that should be removed from staking.\n     */\n    function removeNFTContract(address _nftContract) public onlyOwner {\n        require(\n            nftContracts[_nftContract] == IERC721(_nftContract),\n            \"AceStaking: Unkown Contract\"\n        );\n\n        nftContracts[address(_nftContract)] = IERC721(address(0));\n        rewardsForContract[address(_nftContract)] = 0;\n        for (uint256 i; i < nftContractAddresses.length; i = unsafe_inc(i)) {\n            if (nftContractAddresses[i] == _nftContract) {\n                nftContractAddresses[i] = nftContractAddresses[\n                    nftContractAddresses.length - 1\n                ];\n                nftContractAddresses.pop();\n            }\n        }\n    }\n\n    /**\n     * @dev This function allows the contract owner to set an additional bonus that is\n     * added for each token. The reward is added on top to the default reward for the contract.\n     *\n     * Requirements: onlyOwner or rewardUpdate (external contract) can remove Contracts; Contract needs to be ERC721 compliant\n     * and already added through addNFTContract.\n     * @param _nftContract A ERC721 Contract that is accepted by the contract.\n     * @param _tokenIdentifiers Array of Identifiers that should receive the additional reward\n     * @param _additionalReward ERC777 Token Value that is rewarded for each token every rewardPeriodInSeconds additionally to the default reward.\n     */\n    function setAdditionalRewardsForTokens(\n        IERC721 _nftContract,\n        uint256[] memory _tokenIdentifiers,\n        uint256 _additionalReward\n    ) external onlyRewardUpdater {\n        require(\n            nftContracts[address(_nftContract)] == IERC721(_nftContract),\n            \"AceStaking: Unkown Contract\"\n        );\n\n        uint256 tokenCounter = _tokenIdentifiers.length;\n        for (uint256 i; i < tokenCounter; i = unsafe_inc(i)) {\n            additionalRewardsForToken[address(_nftContract)][\n                _tokenIdentifiers[i]\n            ] = _additionalReward;\n        }\n    }\n\n    /**\n     * @dev You need to claim your rewards at least once within this period.\n     * If not you won't get any new rewards until you claim again.\n     *\n     * Requirements: onlyOwner can change that value\n     *\n     * @param _slashingPeriod Amount of Periods after that rewards get slashed\n     */\n    function setSlashingPeriod(uint256 _slashingPeriod) external onlyOwner {\n        slashingPeriod = _slashingPeriod;\n    }\n\n    /**\n     * @dev We reward a Bonus depending on different traits in some periods.\n     * The choosen traits and to be rewareded tokens are calculated off-chain.\n     * Tokens need to be staked when the reward is paid and already staked in the Snapshot of Tokens that is sent.\n     * If you want to learn more about how our trait based bonus works take a look at our website.\n     *\n     * @param _tokens Array of TokenData(contractAddress, tokenId)\n     * @param _totalBonus Amount of Tokens that should be distributed among sent tokens\n     */\n    function rewardBonus(TokenData[] calldata _tokens, uint256 _totalBonus)\n        external\n        onlyRewardUpdater\n    {\n        uint256 stakedTokensLength = _tokens.length;\n        require(stakedTokensLength > 0, \"AceStaking: No Tokens\");\n        require(\n            _totalBonus > 0,\n            \"AceStaking: No Bonus to be distributed\"\n        );\n\n        uint256 totalShares;\n        currentRoundId += 1;\n        for (uint256 i; i < stakedTokensLength; i = unsafe_inc(i)) {\n            address _staker = stakedTokenOwner[_tokens[i].contractAddress][\n                _tokens[i].tokenIdentifier\n            ];\n            if (_staker != address(0)) {\n                sharesForWalletInRound[currentRoundId][_staker] += 100;\n                walletsToRewardInRound[currentRoundId].push(_staker);\n                totalShares += 1;\n            }\n        }\n\n        require(totalShares > 0, \"AceStaking: No shares to distribute\");\n\n        uint256 walletsToRewardLength = walletsToRewardInRound[currentRoundId]\n            .length;\n        for (uint256 i; i < walletsToRewardLength; i = unsafe_inc(i)) {\n            address walletToCheck = walletsToRewardInRound[currentRoundId][i];\n            if (sharesForWalletInRound[currentRoundId][walletToCheck] > 0) {\n                uint256 rewardsForWallet = (sharesForWalletInRound[\n                    currentRoundId\n                ][walletToCheck] / totalShares) * (_totalBonus / 100);\n\n                stakers[walletToCheck].unclaimedRewards += rewardsForWallet;\n                stakers[walletToCheck].lifetimeRewards += rewardsForWallet;\n\n                sharesForWalletInRound[currentRoundId][walletToCheck] = 0;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to estimate rewards for specific token on a contract in one period.\n     * Token ID could be out of range we don't care since this is just for\n     * simulating unstaked token rewards for UI.\n     *\n     * Requirements: nftContractAddress needs to be registereed on the staking contract.\n     * @param nftContractAddress A ERC721 Contract of the token\n     * @param tokenIdentifier Token Identifier that you want an estimation for\n     */\n    function estimateRewardsForToken(\n        address nftContractAddress,\n        uint256 tokenIdentifier\n    ) public view returns (uint256) {\n        require(\n            nftContracts[nftContractAddress] == IERC721(nftContractAddress),\n            \"AceStaking: Unkown Contract\"\n        );\n        return rewardsForToken(nftContractAddress, tokenIdentifier);\n    }\n\n    /**\n     * @dev Returns multiple stats for the address. Returns those values:\n     * - totalTokensStaked: Count of Tokens for this Wallet on the Staking Contract\n     * - unclaimedRewards: Rewards that can be claimed but are unclaimed by the user\n     * - unaccountedRewards: Rewards that are not ready to be claimed\n     * because the current period did not finish yet. If tokens were staked on different\n     * start times this number might never be 0.\n     * - lifetimeRewards: Just counting up what a user earned over life\n     *\n     * @param _stakerAddress Wallet Address that has staked tokens on the contract\n     */\n    function stakerStats(address _stakerAddress)\n        public\n        view\n        returns (\n            uint256 totalTokensStaked,\n            uint256 unclaimedRewards,\n            uint256 unaccountedRewards,\n            uint256 lifetimeRewards\n        )\n    {\n        Staker memory staker = stakers[_stakerAddress];\n        uint256 claimableRewards = calculateUnaccountedRewards(\n            _stakerAddress,\n            false\n        );\n        return (\n            stakedTokensForAddress[_stakerAddress].length,\n            staker.unclaimedRewards + claimableRewards,\n            calculateUnaccountedRewards(_stakerAddress, true),\n            staker.lifetimeRewards + claimableRewards\n        );\n    }\n\n    /**\n     * @dev Function to unstake all tokens for the msg.sender.\n     * Also rewards msg.sender for all of his staked tokens his staked tokens and ejects all tokens after this.\n     * If you have many tokens staked (50+) we recommend unstaking them in badges to not hit the gas limit of a block.\n     */\n    function unstakeAllTokens() external nonReentrant {\n        StakedToken[] memory stakedTokens = stakedTokensForAddress[msg.sender];\n        uint256 stakedTokensLength = stakedTokens.length;\n        require(stakedTokensLength > 0, \"AceStaking: No Tokens found\");\n        rewardStaker(msg.sender);\n        for (uint256 i; i < stakedTokensLength; i = unsafe_inc(i)) {\n            ejectToken(\n                stakedTokens[i].contractAddress,\n                stakedTokens[i].tokenIdentifier\n            );\n        }\n    }\n\n    /**\n     * @dev Unstake a Set of Tokens for msg.sender.\n     * Also rewards msg.sender for all of his staked tokens his staked tokens and ejects all sent tokens after this.\n     *\n     * @param _tokens Array of TokenData(contractAddress, tokenId)\n     */\n    function unstake(TokenData[] calldata _tokens) external nonReentrant {\n        uint256 stakedTokensLength = _tokens.length;\n        require(stakedTokensLength > 0, \"AceStaking: No Tokens found\");\n        rewardStaker(msg.sender);\n        for (uint256 i; i < stakedTokensLength; i = unsafe_inc(i)) {\n            ejectToken(_tokens[i].contractAddress, _tokens[i].tokenIdentifier);\n        }\n    }\n\n    /**\n     * @dev Emergency Unstake Function: Unstake without any reward calculation.\n     * !!! NOT RECOMMENDED, YOU MIGHT LOSE UNACCOUNTED REWARDS !!!\n     * When to use? This function consumes less gas then the normal unstake since we do not reward all tokens before unstaking.\n     * In case you hit the block limit for gas (very unlikely) we have a way to withdrawal your tokens somehow.\n     * @param _tokens Array of TokenData(contractAddress, tokenId)\n     */\n    function emergencyUnstake(TokenData[] calldata _tokens)\n        external\n        nonReentrant\n    {\n        uint256 stakedTokensLength = _tokens.length;\n        require(stakedTokensLength > 0, \"AceStaking: No Tokens in calldata\");\n        for (uint256 i; i < stakedTokensLength; i = unsafe_inc(i)) {\n            ejectToken(_tokens[i].contractAddress, _tokens[i].tokenIdentifier);\n        }\n    }\n\n    /**\n     * @dev This function transfers tokens to the contract with transferFrom.\n     * thusfor we need to call addToken manually but we save a little on gas.\n     *\n     * Requirements: All token contracts need to be added to this contract and be approved by the user.\n     *\n     * @param _tokens Array of TokenData(contractAddress, tokenId)\n     */\n    function stake(TokenData[] calldata _tokens) external {\n        beforeTokensAdded(msg.sender);\n        uint256 tokensLength = _tokens.length;\n        for (uint256 i; i < tokensLength; i = unsafe_inc(i)) {\n            IERC721(_tokens[i].contractAddress).transferFrom(\n                msg.sender,\n                address(this),\n                _tokens[i].tokenIdentifier\n            );\n            addToken(\n                _tokens[i].contractAddress,\n                _tokens[i].tokenIdentifier,\n                msg.sender\n            );\n        }\n    }\n\n    /**\n     * @dev Call this function to get your ERC777 Token rewards transfered to your wallet.\n     * This is an expensive call since we calculate your current earnings and send them in one\n     * Transaction to your wallet.\n     *\n     */\n    function claimRewards() external nonReentrant {\n        rewardStaker(msg.sender);\n        require(\n            stakers[msg.sender].unclaimedRewards > 0,\n            \"AceStaking: Nothing to claim\"\n        );\n        IERC777(rewardsToken).send(\n            msg.sender,\n            stakers[msg.sender].unclaimedRewards,\n            \"\"\n        );\n        emit RewardClaimed(msg.sender, stakers[msg.sender].unclaimedRewards);\n        stakers[msg.sender].unclaimedRewards = 0;\n        stakers[msg.sender].lastClaimedAt = block.timestamp;\n    }\n\n    /**\n     * @dev This function determains how many periods should be calculated for rewarding.\n     *\n     * @param _lastRewardedAt timestamp when the token was rewarded last\n     * @param _lastClaimedAt timestamp when ist was last claimed\n     *\n     */\n    function rewardPeriods(uint256 _lastRewardedAt, uint256 _lastClaimedAt)\n        internal\n        view\n        returns (uint256 _rewardPeriodCounter)\n    {\n        uint256 referenceTimestamp = block.timestamp;\n        if (\n            referenceTimestamp >\n            (_lastClaimedAt + slashingPeriod * rewardPeriodInSeconds)\n        ) {\n            referenceTimestamp =\n                _lastClaimedAt +\n                slashingPeriod *\n                rewardPeriodInSeconds;\n        }\n        return (referenceTimestamp - _lastRewardedAt) / rewardPeriodInSeconds;\n    }\n\n    /**\n     * @dev Calculates Rewards for a User and accounts them to his entry.\n     *\n     * @param _stakerAddress staker that should be rewarded\n     *\n     */\n    function rewardUnaccountedRewards(address _stakerAddress)\n        internal\n        returns (uint256 _rewards)\n    {\n        StakedToken[] memory stakedTokens = stakedTokensForAddress[\n            _stakerAddress\n        ];\n        uint256 totalRewards;\n        uint256 stakedTokensCount = stakedTokens.length;\n        for (uint256 i; i < stakedTokensCount; i = unsafe_inc(i)) {\n            uint256 periodsToReward = rewardPeriods(\n                stakedTokens[i].lastRewardedAt,\n                stakers[_stakerAddress].lastClaimedAt\n            );\n\n            if (periodsToReward > 0) {\n                totalRewards +=\n                    periodsToReward *\n                    rewardsForToken(\n                        stakedTokens[i].contractAddress,\n                        stakedTokens[i].tokenIdentifier\n                    );\n                if (periodsToReward == slashingPeriod) {\n                    stakedTokensForAddress[_stakerAddress][i].lastRewardedAt =\n                        stakedTokensForAddress[_stakerAddress][i].stakedAt +\n                        (\n                            uint256(\n                                (block.timestamp -\n                                    stakedTokensForAddress[_stakerAddress][i]\n                                        .stakedAt) / rewardPeriodInSeconds\n                            )\n                        ) *\n                        rewardPeriodInSeconds;\n                } else {\n                    stakedTokensForAddress[_stakerAddress][i].lastRewardedAt =\n                        stakedTokensForAddress[_stakerAddress][i].stakedAt +\n                        periodsToReward *\n                        rewardPeriodInSeconds;\n                }\n            }\n        }\n        return totalRewards;\n    }\n\n    /**\n     * @dev Calculates Rewards for a User but does not account them.\n     *\n     * @param _stakerAddress staker that should be rewarded\n     * @param _simulateUnaccounted include unaccounted rewards that can't be claimed yet\n     *\n     */\n    function calculateUnaccountedRewards(\n        address _stakerAddress,\n        bool _simulateUnaccounted\n    ) internal view returns (uint256 _rewards) {\n        StakedToken[] memory stakedTokens = stakedTokensForAddress[\n            _stakerAddress\n        ];\n        uint256 totalRewards;\n        uint256 stakedTokensCount = stakedTokens.length;\n        for (uint256 i; i < stakedTokensCount; i = unsafe_inc(i)) {\n            uint256 periodsToReward = rewardPeriods(\n                stakedTokens[i].lastRewardedAt,\n                stakers[_stakerAddress].lastClaimedAt\n            );\n\n            uint256 tokenReward = rewardsForToken(\n                stakedTokens[i].contractAddress,\n                stakedTokens[i].tokenIdentifier\n            );\n            if (_simulateUnaccounted) {\n                totalRewards +=\n                    ((((block.timestamp - stakedTokens[i].lastRewardedAt) *\n                        100) / rewardPeriodInSeconds) * tokenReward) /\n                    100 -\n                    periodsToReward *\n                    tokenReward;\n            } else {\n                totalRewards += tokenReward * periodsToReward;\n            }\n        }\n        return totalRewards;\n    }\n\n    /**\n     * @dev Summarize rewards for a specific token on a contract.\n     * Sums up default rewards for contract and bonus for token identifier.\n     *\n     * @param nftContractAddress Contract to check\n     * @param tokenIdentifier Token Identifier to check\n     *\n     */\n    function rewardsForToken(\n        address nftContractAddress,\n        uint256 tokenIdentifier\n    ) internal view returns (uint256) {\n        return\n            rewardsForContract[nftContractAddress] +\n            additionalRewardsForToken[nftContractAddress][tokenIdentifier];\n    }\n\n    /**\n     * @dev Function that moves all unaccounted rewards to unclaimed.\n     * This call is required to keep our internal balance sheets up to date.\n     * Depending on Token Amount this is very expensive to call since we loop through all tokens!\n     *\n     * @param _address Wallet Address that should be rewarded\n     *\n     */\n    function rewardStaker(address _address) internal {\n        uint256 unaccountedRewards = rewardUnaccountedRewards(_address);\n        stakers[_address].lastRewardedAt = block.timestamp;\n        stakers[_address].unclaimedRewards += unaccountedRewards;\n        stakers[_address].lifetimeRewards += unaccountedRewards;\n    }\n\n    /**\n     * @dev Internal function to send a token back to a user. Also\n     * removes / updates all contract internal trackings.\n     *\n     * Requirements: msg.sender needs to be the wallet that sent the token to the contract.\n     *\n     * @param nftContractAddress Contract for the token to be ejected\n     * @param tokenIdentifier Token Identifier for the token to be ejected\n     *\n     */\n    function ejectToken(address nftContractAddress, uint256 tokenIdentifier)\n        internal\n    {\n        require(\n            stakedTokenOwner[nftContractAddress][tokenIdentifier] == msg.sender,\n            \"AceStaking: Not your token...\"\n        );\n\n        IERC721(nftContractAddress).transferFrom(\n            address(this),\n            msg.sender,\n            tokenIdentifier\n        );\n\n        for (\n            uint256 i;\n            i < stakedTokensForAddress[msg.sender].length;\n            i = unsafe_inc(i)\n        ) {\n            if (\n                stakedTokensForAddress[msg.sender][i].tokenIdentifier ==\n                tokenIdentifier &&\n                stakedTokensForAddress[msg.sender][i].contractAddress ==\n                nftContractAddress\n            ) {\n                emit UnstakedNFT(\n                    stakedTokensForAddress[msg.sender][i],\n                    msg.sender\n                );\n                stakedTokensForAddress[msg.sender][i] = stakedTokensForAddress[\n                    msg.sender\n                ][stakedTokensForAddress[msg.sender].length - 1];\n                stakedTokensForAddress[msg.sender].pop();\n            }\n        }\n\n        if (stakedTokensForAddress[msg.sender].length == 0) {\n            for (uint256 i; i < currentStakers.length; i = unsafe_inc(i)) {\n                if (currentStakers[i] == msg.sender) {\n                    currentStakers[i] = currentStakers[\n                        currentStakers.length - 1\n                    ];\n                    currentStakers.pop();\n                }\n            }\n        }\n\n        stakedTokenOwner[msg.sender][tokenIdentifier] = address(0);\n        totalTokensStakedCount -= 1;\n    }\n\n    /**\n     * @dev Helper that should be called before any token is added. Needs to be called\n     * only once per batch. It basically setup the staker object.\n     *\n     * @param _staker Wallet Address for Staker\n     */\n    function beforeTokensAdded(address _staker) internal {\n        if (stakedTokensForAddress[_staker].length == 0) {\n            if (stakers[_staker].lastRewardedAt > 0) {\n                // This wallet already staked before and was at least rewarded once.\n                stakers[_staker].lastRewardedAt = block.timestamp;\n                stakers[_staker].lastClaimedAt = block.timestamp;\n            } else {\n                // This wallet is new to us\n                stakers[_staker] = Staker(\n                    stakers[_staker].unclaimedRewards,\n                    stakers[_staker].lifetimeRewards,\n                    block.timestamp,\n                    block.timestamp\n                );\n            }\n            currentStakers.push(_staker);\n        }\n    }\n\n    /**\n     * @dev Function to add a token and regiter it in all mappings that we need to\n     * return and reward a token.\n     *\n     * @param nftContractAddress Contract of the token\n     * @param tokenIdentifier The Identifier of a token\n     * @param tokenOwnerAddress The address of the current owner\n     */\n    function addToken(\n        address nftContractAddress,\n        uint256 tokenIdentifier,\n        address tokenOwnerAddress\n    ) internal {\n        require(\n            nftContracts[nftContractAddress] == IERC721(nftContractAddress),\n            \"AceStaking: Unkown Contract\"\n        );\n\n        StakedToken memory newToken = StakedToken(\n            nftContractAddress,\n            tokenIdentifier,\n            block.timestamp,\n            block.timestamp\n        );\n        stakedTokenOwner[nftContractAddress][\n            tokenIdentifier\n        ] = tokenOwnerAddress;\n\n        stakedTokensForAddress[tokenOwnerAddress].push(newToken);\n        totalTokensStakedCount += 1;\n        emit StakedNFT(newToken, tokenOwnerAddress);\n    }\n\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\n        unchecked {\n            return x + 1;\n        }\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}. Also registers token in our TokenRegistry.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address, // operator not required\n        address tokenOwnerAddress,\n        uint256 tokenIdentifier,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        beforeTokensAdded(tokenOwnerAddress);\n        addToken(msg.sender, tokenIdentifier, tokenOwnerAddress);\n        return this.onERC721Received.selector;\n    }\n\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external override {\n        if (_shouldRevertSend) {\n            revert();\n        }\n\n        IERC777 token = IERC777(_msgSender());\n\n        uint256 fromBalance = token.balanceOf(from);\n        // when called due to burn, to will be the zero address, which will have a balance of 0\n        uint256 toBalance = token.balanceOf(to);\n\n        emit TokensToSendCalled(\n            operator,\n            from,\n            to,\n            amount,\n            userData,\n            operatorData,\n            address(token),\n            fromBalance,\n            toBalance\n        );\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external override {\n        if (_shouldRevertReceive) {\n            revert();\n        }\n\n        IERC777 token = IERC777(_msgSender());\n\n        uint256 fromBalance = token.balanceOf(from);\n        // when called due to burn, to will be the zero address, which will have a balance of 0\n        uint256 toBalance = token.balanceOf(to);\n\n        emit TokensReceivedCalled(\n            operator,\n            from,\n            to,\n            amount,\n            userData,\n            operatorData,\n            address(token),\n            fromBalance,\n            toBalance\n        );\n    }\n\n\n    /**\n     * @dev This address is allowed to change the rewards for a specific token.\n     * Since opening a chest door results in a different reward, this is implemented in the chest door opener contract later.\n     *\n     * @param _REWARD_UPDATER Address that is allowed to modify rewards\n     */\n    function setRewardUpdater(address _REWARD_UPDATER) external onlyOwner {\n        REWARD_UPDATER = _REWARD_UPDATER;\n    }\n\n    modifier onlyRewardUpdater() {\n        require(\n            msg.sender == REWARD_UPDATER || msg.sender == owner(),\n            \"AceStaking: Only REWARD_UPDATE or OWNER.\"\n        );\n        _;\n    }\n}\n\n/** created with bowline.app **/"
6     },
7     "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
9     },
10     "@openzeppelin/contracts/utils/introspection/IERC1820Implementer.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for an ERC1820 implementer, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820#interface-implementation-erc1820implementerinterface[EIP].\n * Used by contracts that will be registered as implementers in the\n * {IERC1820Registry}.\n */\ninterface IERC1820Implementer {\n    /**\n     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract\n     * implements `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\n}\n"
12     },
13     "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
15     },
16     "@openzeppelin/contracts/utils/introspection/ERC1820Implementer.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC1820Implementer.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1820Implementer.sol\";\n\n/**\n * @dev Implementation of the {IERC1820Implementer} interface.\n *\n * Contracts may inherit from this and call {_registerInterfaceForAddress} to\n * declare their willingness to be implementers.\n * {IERC1820Registry-setInterfaceImplementer} should then be called for the\n * registration to be complete.\n */\ncontract ERC1820Implementer is IERC1820Implementer {\n    bytes32 private constant _ERC1820_ACCEPT_MAGIC = keccak256(\"ERC1820_ACCEPT_MAGIC\");\n\n    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account)\n        public\n        view\n        virtual\n        override\n        returns (bytes32)\n    {\n        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n    }\n\n    /**\n     * @dev Declares the contract as willing to be an implementer of\n     * `interfaceHash` for `account`.\n     *\n     * See {IERC1820Registry-setInterfaceImplementer} and\n     * {IERC1820Registry-interfaceHash}.\n     */\n    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual {\n        _supportedInterfaces[interfaceHash][account] = true;\n    }\n}\n"
18     },
19     "@openzeppelin/contracts/utils/Context.sol": {
20       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
21     },
22     "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC777/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
24     },
25     "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
27     },
28     "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
30     },
31     "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
32       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
33     },
34     "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
36     },
37     "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
38       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
39     },
40     "@openzeppelin/contracts/access/Ownable.sol": {
41       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
42     }
43   },
44   "settings": {
45     "remappings": [],
46     "optimizer": {
47       "enabled": false,
48       "runs": 200
49     },
50     "evmVersion": "london",
51     "libraries": {},
52     "outputSelection": {
53       "*": {
54         "*": [
55           "evm.bytecode",
56           "evm.deployedBytecode",
57           "devdoc",
58           "userdoc",
59           "metadata",
60           "abi"
61         ]
62       }
63     }
64   }
65 }}