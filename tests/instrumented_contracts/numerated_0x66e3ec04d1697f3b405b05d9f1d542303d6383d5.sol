1 // File: @chainlink/contracts/src/v0.8/VRFRequestIDBase.sol
2 
3 
4 pragma solidity ^0.8.0;
5 
6 contract VRFRequestIDBase {
7   /**
8    * @notice returns the seed which is actually input to the VRF coordinator
9    *
10    * @dev To prevent repetition of VRF output due to repetition of the
11    * @dev user-supplied seed, that seed is combined in a hash with the
12    * @dev user-specific nonce, and the address of the consuming contract. The
13    * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
14    * @dev the final seed, but the nonce does protect against repetition in
15    * @dev requests which are included in a single block.
16    *
17    * @param _userSeed VRF seed input provided by user
18    * @param _requester Address of the requesting contract
19    * @param _nonce User-specific nonce at the time of the request
20    */
21   function makeVRFInputSeed(
22     bytes32 _keyHash,
23     uint256 _userSeed,
24     address _requester,
25     uint256 _nonce
26   ) internal pure returns (uint256) {
27     return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
28   }
29 
30   /**
31    * @notice Returns the id for this request
32    * @param _keyHash The serviceAgreement ID to be used for this request
33    * @param _vRFInputSeed The seed to be passed directly to the VRF
34    * @return The id for this request
35    *
36    * @dev Note that _vRFInputSeed is not the seed passed by the consuming
37    * @dev contract, but the one generated by makeVRFInputSeed
38    */
39   function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
40     return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
41   }
42 }
43 
44 // File: @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol
45 
46 
47 pragma solidity ^0.8.0;
48 
49 interface LinkTokenInterface {
50   function allowance(address owner, address spender) external view returns (uint256 remaining);
51 
52   function approve(address spender, uint256 value) external returns (bool success);
53 
54   function balanceOf(address owner) external view returns (uint256 balance);
55 
56   function decimals() external view returns (uint8 decimalPlaces);
57 
58   function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);
59 
60   function increaseApproval(address spender, uint256 subtractedValue) external;
61 
62   function name() external view returns (string memory tokenName);
63 
64   function symbol() external view returns (string memory tokenSymbol);
65 
66   function totalSupply() external view returns (uint256 totalTokensIssued);
67 
68   function transfer(address to, uint256 value) external returns (bool success);
69 
70   function transferAndCall(
71     address to,
72     uint256 value,
73     bytes calldata data
74   ) external returns (bool success);
75 
76   function transferFrom(
77     address from,
78     address to,
79     uint256 value
80   ) external returns (bool success);
81 }
82 
83 // File: @chainlink/contracts/src/v0.8/VRFConsumerBase.sol
84 
85 
86 pragma solidity ^0.8.0;
87 
88 
89 
90 /** ****************************************************************************
91  * @notice Interface for contracts using VRF randomness
92  * *****************************************************************************
93  * @dev PURPOSE
94  *
95  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness
96  * @dev to Vera the verifier in such a way that Vera can be sure he's not
97  * @dev making his output up to suit himself. Reggie provides Vera a public key
98  * @dev to which he knows the secret key. Each time Vera provides a seed to
99  * @dev Reggie, he gives back a value which is computed completely
100  * @dev deterministically from the seed and the secret key.
101  *
102  * @dev Reggie provides a proof by which Vera can verify that the output was
103  * @dev correctly computed once Reggie tells it to her, but without that proof,
104  * @dev the output is indistinguishable to her from a uniform random sample
105  * @dev from the output space.
106  *
107  * @dev The purpose of this contract is to make it easy for unrelated contracts
108  * @dev to talk to Vera the verifier about the work Reggie is doing, to provide
109  * @dev simple access to a verifiable source of randomness.
110  * *****************************************************************************
111  * @dev USAGE
112  *
113  * @dev Calling contracts must inherit from VRFConsumerBase, and can
114  * @dev initialize VRFConsumerBase's attributes in their constructor as
115  * @dev shown:
116  *
117  * @dev   contract VRFConsumer {
118  * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)
119  * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {
120  * @dev         <initialization with other arguments goes here>
121  * @dev       }
122  * @dev   }
123  *
124  * @dev The oracle will have given you an ID for the VRF keypair they have
125  * @dev committed to (let's call it keyHash), and have told you the minimum LINK
126  * @dev price for VRF service. Make sure your contract has sufficient LINK, and
127  * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you
128  * @dev want to generate randomness from.
129  *
130  * @dev Once the VRFCoordinator has received and validated the oracle's response
131  * @dev to your request, it will call your contract's fulfillRandomness method.
132  *
133  * @dev The randomness argument to fulfillRandomness is the actual random value
134  * @dev generated from your seed.
135  *
136  * @dev The requestId argument is generated from the keyHash and the seed by
137  * @dev makeRequestId(keyHash, seed). If your contract could have concurrent
138  * @dev requests open, you can use the requestId to track which seed is
139  * @dev associated with which randomness. See VRFRequestIDBase.sol for more
140  * @dev details. (See "SECURITY CONSIDERATIONS" for principles to keep in mind,
141  * @dev if your contract could have multiple requests in flight simultaneously.)
142  *
143  * @dev Colliding `requestId`s are cryptographically impossible as long as seeds
144  * @dev differ. (Which is critical to making unpredictable randomness! See the
145  * @dev next section.)
146  *
147  * *****************************************************************************
148  * @dev SECURITY CONSIDERATIONS
149  *
150  * @dev A method with the ability to call your fulfillRandomness method directly
151  * @dev could spoof a VRF response with any random value, so it's critical that
152  * @dev it cannot be directly called by anything other than this base contract
153  * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).
154  *
155  * @dev For your users to trust that your contract's random behavior is free
156  * @dev from malicious interference, it's best if you can write it so that all
157  * @dev behaviors implied by a VRF response are executed *during* your
158  * @dev fulfillRandomness method. If your contract must store the response (or
159  * @dev anything derived from it) and use it later, you must ensure that any
160  * @dev user-significant behavior which depends on that stored value cannot be
161  * @dev manipulated by a subsequent VRF request.
162  *
163  * @dev Similarly, both miners and the VRF oracle itself have some influence
164  * @dev over the order in which VRF responses appear on the blockchain, so if
165  * @dev your contract could have multiple VRF requests in flight simultaneously,
166  * @dev you must ensure that the order in which the VRF responses arrive cannot
167  * @dev be used to manipulate your contract's user-significant behavior.
168  *
169  * @dev Since the ultimate input to the VRF is mixed with the block hash of the
170  * @dev block in which the request is made, user-provided seeds have no impact
171  * @dev on its economic security properties. They are only included for API
172  * @dev compatability with previous versions of this contract.
173  *
174  * @dev Since the block hash of the block which contains the requestRandomness
175  * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful
176  * @dev miner could, in principle, fork the blockchain to evict the block
177  * @dev containing the request, forcing the request to be included in a
178  * @dev different block with a different hash, and therefore a different input
179  * @dev to the VRF. However, such an attack would incur a substantial economic
180  * @dev cost. This cost scales with the number of blocks the VRF oracle waits
181  * @dev until it calls responds to a request.
182  */
183 abstract contract VRFConsumerBase is VRFRequestIDBase {
184   /**
185    * @notice fulfillRandomness handles the VRF response. Your contract must
186    * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
187    * @notice principles to keep in mind when implementing your fulfillRandomness
188    * @notice method.
189    *
190    * @dev VRFConsumerBase expects its subcontracts to have a method with this
191    * @dev signature, and will call it once it has verified the proof
192    * @dev associated with the randomness. (It is triggered via a call to
193    * @dev rawFulfillRandomness, below.)
194    *
195    * @param requestId The Id initially returned by requestRandomness
196    * @param randomness the VRF output
197    */
198   function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;
199 
200   /**
201    * @dev In order to keep backwards compatibility we have kept the user
202    * seed field around. We remove the use of it because given that the blockhash
203    * enters later, it overrides whatever randomness the used seed provides.
204    * Given that it adds no security, and can easily lead to misunderstandings,
205    * we have removed it from usage and can now provide a simpler API.
206    */
207   uint256 private constant USER_SEED_PLACEHOLDER = 0;
208 
209   /**
210    * @notice requestRandomness initiates a request for VRF output given _seed
211    *
212    * @dev The fulfillRandomness method receives the output, once it's provided
213    * @dev by the Oracle, and verified by the vrfCoordinator.
214    *
215    * @dev The _keyHash must already be registered with the VRFCoordinator, and
216    * @dev the _fee must exceed the fee specified during registration of the
217    * @dev _keyHash.
218    *
219    * @dev The _seed parameter is vestigial, and is kept only for API
220    * @dev compatibility with older versions. It can't *hurt* to mix in some of
221    * @dev your own randomness, here, but it's not necessary because the VRF
222    * @dev oracle will mix the hash of the block containing your request into the
223    * @dev VRF seed it ultimately uses.
224    *
225    * @param _keyHash ID of public key against which randomness is generated
226    * @param _fee The amount of LINK to send with the request
227    *
228    * @return requestId unique ID for this request
229    *
230    * @dev The returned requestId can be used to distinguish responses to
231    * @dev concurrent requests. It is passed as the first argument to
232    * @dev fulfillRandomness.
233    */
234   function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {
235     LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));
236     // This is the seed passed to VRFCoordinator. The oracle will mix this with
237     // the hash of the block containing this request to obtain the seed/input
238     // which is finally passed to the VRF cryptographic machinery.
239     uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);
240     // nonces[_keyHash] must stay in sync with
241     // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above
242     // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).
243     // This provides protection against the user repeating their input seed,
244     // which would result in a predictable/duplicate output, if multiple such
245     // requests appeared in the same block.
246     nonces[_keyHash] = nonces[_keyHash] + 1;
247     return makeRequestId(_keyHash, vRFSeed);
248   }
249 
250   LinkTokenInterface internal immutable LINK;
251   address private immutable vrfCoordinator;
252 
253   // Nonces for each VRF key from which randomness has been requested.
254   //
255   // Must stay in sync with VRFCoordinator[_keyHash][this]
256   mapping(bytes32 => uint256) /* keyHash */ /* nonce */
257     private nonces;
258 
259   /**
260    * @param _vrfCoordinator address of VRFCoordinator contract
261    * @param _link address of LINK token contract
262    *
263    * @dev https://docs.chain.link/docs/link-token-contracts
264    */
265   constructor(address _vrfCoordinator, address _link) {
266     vrfCoordinator = _vrfCoordinator;
267     LINK = LinkTokenInterface(_link);
268   }
269 
270   // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
271   // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
272   // the origin of the call
273   function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {
274     require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");
275     fulfillRandomness(requestId, randomness);
276   }
277 }
278 
279 // File: base64-sol/base64.sol
280 
281 
282 
283 pragma solidity >=0.6.0;
284 
285 /// @title Base64
286 /// @author Brecht Devos - <brecht@loopring.org>
287 /// @notice Provides functions for encoding/decoding base64
288 library Base64 {
289     string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
290     bytes  internal constant TABLE_DECODE = hex"0000000000000000000000000000000000000000000000000000000000000000"
291                                             hex"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000"
292                                             hex"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000"
293                                             hex"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000";
294 
295     function encode(bytes memory data) internal pure returns (string memory) {
296         if (data.length == 0) return '';
297 
298         // load the table into memory
299         string memory table = TABLE_ENCODE;
300 
301         // multiply by 4/3 rounded up
302         uint256 encodedLen = 4 * ((data.length + 2) / 3);
303 
304         // add some extra buffer at the end required for the writing
305         string memory result = new string(encodedLen + 32);
306 
307         assembly {
308             // set the actual output length
309             mstore(result, encodedLen)
310 
311             // prepare the lookup table
312             let tablePtr := add(table, 1)
313 
314             // input ptr
315             let dataPtr := data
316             let endPtr := add(dataPtr, mload(data))
317 
318             // result ptr, jump over length
319             let resultPtr := add(result, 32)
320 
321             // run over the input, 3 bytes at a time
322             for {} lt(dataPtr, endPtr) {}
323             {
324                 // read 3 bytes
325                 dataPtr := add(dataPtr, 3)
326                 let input := mload(dataPtr)
327 
328                 // write 4 characters
329                 mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
330                 resultPtr := add(resultPtr, 1)
331                 mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
332                 resultPtr := add(resultPtr, 1)
333                 mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))
334                 resultPtr := add(resultPtr, 1)
335                 mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))
336                 resultPtr := add(resultPtr, 1)
337             }
338 
339             // padding with '='
340             switch mod(mload(data), 3)
341             case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
342             case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
343         }
344 
345         return result;
346     }
347 
348     function decode(string memory _data) internal pure returns (bytes memory) {
349         bytes memory data = bytes(_data);
350 
351         if (data.length == 0) return new bytes(0);
352         require(data.length % 4 == 0, "invalid base64 decoder input");
353 
354         // load the table into memory
355         bytes memory table = TABLE_DECODE;
356 
357         // every 4 characters represent 3 bytes
358         uint256 decodedLen = (data.length / 4) * 3;
359 
360         // add some extra buffer at the end required for the writing
361         bytes memory result = new bytes(decodedLen + 32);
362 
363         assembly {
364             // padding with '='
365             let lastBytes := mload(add(data, mload(data)))
366             if eq(and(lastBytes, 0xFF), 0x3d) {
367                 decodedLen := sub(decodedLen, 1)
368                 if eq(and(lastBytes, 0xFFFF), 0x3d3d) {
369                     decodedLen := sub(decodedLen, 1)
370                 }
371             }
372 
373             // set the actual output length
374             mstore(result, decodedLen)
375 
376             // prepare the lookup table
377             let tablePtr := add(table, 1)
378 
379             // input ptr
380             let dataPtr := data
381             let endPtr := add(dataPtr, mload(data))
382 
383             // result ptr, jump over length
384             let resultPtr := add(result, 32)
385 
386             // run over the input, 4 characters at a time
387             for {} lt(dataPtr, endPtr) {}
388             {
389                // read 4 characters
390                dataPtr := add(dataPtr, 4)
391                let input := mload(dataPtr)
392 
393                // write 3 bytes
394                let output := add(
395                    add(
396                        shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),
397                        shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),
398                    add(
399                        shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),
400                                and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)
401                     )
402                 )
403                 mstore(resultPtr, shl(232, output))
404                 resultPtr := add(resultPtr, 3)
405             }
406         }
407 
408         return result;
409     }
410 }
411 
412 // File: @openzeppelin/contracts/utils/Strings.sol
413 
414 
415 // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)
416 
417 pragma solidity ^0.8.0;
418 
419 /**
420  * @dev String operations.
421  */
422 library Strings {
423     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
424 
425     /**
426      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
427      */
428     function toString(uint256 value) internal pure returns (string memory) {
429         // Inspired by OraclizeAPI's implementation - MIT licence
430         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
431 
432         if (value == 0) {
433             return "0";
434         }
435         uint256 temp = value;
436         uint256 digits;
437         while (temp != 0) {
438             digits++;
439             temp /= 10;
440         }
441         bytes memory buffer = new bytes(digits);
442         while (value != 0) {
443             digits -= 1;
444             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
445             value /= 10;
446         }
447         return string(buffer);
448     }
449 
450     /**
451      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
452      */
453     function toHexString(uint256 value) internal pure returns (string memory) {
454         if (value == 0) {
455             return "0x00";
456         }
457         uint256 temp = value;
458         uint256 length = 0;
459         while (temp != 0) {
460             length++;
461             temp >>= 8;
462         }
463         return toHexString(value, length);
464     }
465 
466     /**
467      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
468      */
469     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
470         bytes memory buffer = new bytes(2 * length + 2);
471         buffer[0] = "0";
472         buffer[1] = "x";
473         for (uint256 i = 2 * length + 1; i > 1; --i) {
474             buffer[i] = _HEX_SYMBOLS[value & 0xf];
475             value >>= 4;
476         }
477         require(value == 0, "Strings: hex length insufficient");
478         return string(buffer);
479     }
480 }
481 
482 // File: @openzeppelin/contracts/utils/Address.sol
483 
484 
485 // OpenZeppelin Contracts v4.4.1 (utils/Address.sol)
486 
487 pragma solidity ^0.8.0;
488 
489 /**
490  * @dev Collection of functions related to the address type
491  */
492 library Address {
493     /**
494      * @dev Returns true if `account` is a contract.
495      *
496      * [IMPORTANT]
497      * ====
498      * It is unsafe to assume that an address for which this function returns
499      * false is an externally-owned account (EOA) and not a contract.
500      *
501      * Among others, `isContract` will return false for the following
502      * types of addresses:
503      *
504      *  - an externally-owned account
505      *  - a contract in construction
506      *  - an address where a contract will be created
507      *  - an address where a contract lived, but was destroyed
508      * ====
509      */
510     function isContract(address account) internal view returns (bool) {
511         // This method relies on extcodesize, which returns 0 for contracts in
512         // construction, since the code is only stored at the end of the
513         // constructor execution.
514 
515         uint256 size;
516         assembly {
517             size := extcodesize(account)
518         }
519         return size > 0;
520     }
521 
522     /**
523      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
524      * `recipient`, forwarding all available gas and reverting on errors.
525      *
526      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
527      * of certain opcodes, possibly making contracts go over the 2300 gas limit
528      * imposed by `transfer`, making them unable to receive funds via
529      * `transfer`. {sendValue} removes this limitation.
530      *
531      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
532      *
533      * IMPORTANT: because control is transferred to `recipient`, care must be
534      * taken to not create reentrancy vulnerabilities. Consider using
535      * {ReentrancyGuard} or the
536      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
537      */
538     function sendValue(address payable recipient, uint256 amount) internal {
539         require(address(this).balance >= amount, "Address: insufficient balance");
540 
541         (bool success, ) = recipient.call{value: amount}("");
542         require(success, "Address: unable to send value, recipient may have reverted");
543     }
544 
545     /**
546      * @dev Performs a Solidity function call using a low level `call`. A
547      * plain `call` is an unsafe replacement for a function call: use this
548      * function instead.
549      *
550      * If `target` reverts with a revert reason, it is bubbled up by this
551      * function (like regular Solidity function calls).
552      *
553      * Returns the raw returned data. To convert to the expected return value,
554      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
555      *
556      * Requirements:
557      *
558      * - `target` must be a contract.
559      * - calling `target` with `data` must not revert.
560      *
561      * _Available since v3.1._
562      */
563     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
564         return functionCall(target, data, "Address: low-level call failed");
565     }
566 
567     /**
568      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
569      * `errorMessage` as a fallback revert reason when `target` reverts.
570      *
571      * _Available since v3.1._
572      */
573     function functionCall(
574         address target,
575         bytes memory data,
576         string memory errorMessage
577     ) internal returns (bytes memory) {
578         return functionCallWithValue(target, data, 0, errorMessage);
579     }
580 
581     /**
582      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
583      * but also transferring `value` wei to `target`.
584      *
585      * Requirements:
586      *
587      * - the calling contract must have an ETH balance of at least `value`.
588      * - the called Solidity function must be `payable`.
589      *
590      * _Available since v3.1._
591      */
592     function functionCallWithValue(
593         address target,
594         bytes memory data,
595         uint256 value
596     ) internal returns (bytes memory) {
597         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
598     }
599 
600     /**
601      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
602      * with `errorMessage` as a fallback revert reason when `target` reverts.
603      *
604      * _Available since v3.1._
605      */
606     function functionCallWithValue(
607         address target,
608         bytes memory data,
609         uint256 value,
610         string memory errorMessage
611     ) internal returns (bytes memory) {
612         require(address(this).balance >= value, "Address: insufficient balance for call");
613         require(isContract(target), "Address: call to non-contract");
614 
615         (bool success, bytes memory returndata) = target.call{value: value}(data);
616         return verifyCallResult(success, returndata, errorMessage);
617     }
618 
619     /**
620      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
621      * but performing a static call.
622      *
623      * _Available since v3.3._
624      */
625     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
626         return functionStaticCall(target, data, "Address: low-level static call failed");
627     }
628 
629     /**
630      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
631      * but performing a static call.
632      *
633      * _Available since v3.3._
634      */
635     function functionStaticCall(
636         address target,
637         bytes memory data,
638         string memory errorMessage
639     ) internal view returns (bytes memory) {
640         require(isContract(target), "Address: static call to non-contract");
641 
642         (bool success, bytes memory returndata) = target.staticcall(data);
643         return verifyCallResult(success, returndata, errorMessage);
644     }
645 
646     /**
647      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
648      * but performing a delegate call.
649      *
650      * _Available since v3.4._
651      */
652     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
653         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
654     }
655 
656     /**
657      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
658      * but performing a delegate call.
659      *
660      * _Available since v3.4._
661      */
662     function functionDelegateCall(
663         address target,
664         bytes memory data,
665         string memory errorMessage
666     ) internal returns (bytes memory) {
667         require(isContract(target), "Address: delegate call to non-contract");
668 
669         (bool success, bytes memory returndata) = target.delegatecall(data);
670         return verifyCallResult(success, returndata, errorMessage);
671     }
672 
673     /**
674      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
675      * revert reason using the provided one.
676      *
677      * _Available since v4.3._
678      */
679     function verifyCallResult(
680         bool success,
681         bytes memory returndata,
682         string memory errorMessage
683     ) internal pure returns (bytes memory) {
684         if (success) {
685             return returndata;
686         } else {
687             // Look for revert reason and bubble it up if present
688             if (returndata.length > 0) {
689                 // The easiest way to bubble the revert reason is using memory via assembly
690 
691                 assembly {
692                     let returndata_size := mload(returndata)
693                     revert(add(32, returndata), returndata_size)
694                 }
695             } else {
696                 revert(errorMessage);
697             }
698         }
699     }
700 }
701 
702 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
703 
704 
705 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)
706 
707 pragma solidity ^0.8.0;
708 
709 /**
710  * @title ERC721 token receiver interface
711  * @dev Interface for any contract that wants to support safeTransfers
712  * from ERC721 asset contracts.
713  */
714 interface IERC721Receiver {
715     /**
716      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
717      * by `operator` from `from`, this function is called.
718      *
719      * It must return its Solidity selector to confirm the token transfer.
720      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
721      *
722      * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
723      */
724     function onERC721Received(
725         address operator,
726         address from,
727         uint256 tokenId,
728         bytes calldata data
729     ) external returns (bytes4);
730 }
731 
732 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
733 
734 
735 // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
736 
737 pragma solidity ^0.8.0;
738 
739 /**
740  * @dev Interface of the ERC165 standard, as defined in the
741  * https://eips.ethereum.org/EIPS/eip-165[EIP].
742  *
743  * Implementers can declare support of contract interfaces, which can then be
744  * queried by others ({ERC165Checker}).
745  *
746  * For an implementation, see {ERC165}.
747  */
748 interface IERC165 {
749     /**
750      * @dev Returns true if this contract implements the interface defined by
751      * `interfaceId`. See the corresponding
752      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
753      * to learn more about how these ids are created.
754      *
755      * This function call must use less than 30 000 gas.
756      */
757     function supportsInterface(bytes4 interfaceId) external view returns (bool);
758 }
759 
760 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
761 
762 
763 // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
764 
765 pragma solidity ^0.8.0;
766 
767 
768 /**
769  * @dev Implementation of the {IERC165} interface.
770  *
771  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
772  * for the additional interface id that will be supported. For example:
773  *
774  * ```solidity
775  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
776  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
777  * }
778  * ```
779  *
780  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
781  */
782 abstract contract ERC165 is IERC165 {
783     /**
784      * @dev See {IERC165-supportsInterface}.
785      */
786     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
787         return interfaceId == type(IERC165).interfaceId;
788     }
789 }
790 
791 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
792 
793 
794 // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)
795 
796 pragma solidity ^0.8.0;
797 
798 
799 /**
800  * @dev Required interface of an ERC721 compliant contract.
801  */
802 interface IERC721 is IERC165 {
803     /**
804      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
805      */
806     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
807 
808     /**
809      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
810      */
811     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
812 
813     /**
814      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
815      */
816     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
817 
818     /**
819      * @dev Returns the number of tokens in ``owner``'s account.
820      */
821     function balanceOf(address owner) external view returns (uint256 balance);
822 
823     /**
824      * @dev Returns the owner of the `tokenId` token.
825      *
826      * Requirements:
827      *
828      * - `tokenId` must exist.
829      */
830     function ownerOf(uint256 tokenId) external view returns (address owner);
831 
832     /**
833      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
834      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
835      *
836      * Requirements:
837      *
838      * - `from` cannot be the zero address.
839      * - `to` cannot be the zero address.
840      * - `tokenId` token must exist and be owned by `from`.
841      * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
842      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
843      *
844      * Emits a {Transfer} event.
845      */
846     function safeTransferFrom(
847         address from,
848         address to,
849         uint256 tokenId
850     ) external;
851 
852     /**
853      * @dev Transfers `tokenId` token from `from` to `to`.
854      *
855      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
856      *
857      * Requirements:
858      *
859      * - `from` cannot be the zero address.
860      * - `to` cannot be the zero address.
861      * - `tokenId` token must be owned by `from`.
862      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
863      *
864      * Emits a {Transfer} event.
865      */
866     function transferFrom(
867         address from,
868         address to,
869         uint256 tokenId
870     ) external;
871 
872     /**
873      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
874      * The approval is cleared when the token is transferred.
875      *
876      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
877      *
878      * Requirements:
879      *
880      * - The caller must own the token or be an approved operator.
881      * - `tokenId` must exist.
882      *
883      * Emits an {Approval} event.
884      */
885     function approve(address to, uint256 tokenId) external;
886 
887     /**
888      * @dev Returns the account approved for `tokenId` token.
889      *
890      * Requirements:
891      *
892      * - `tokenId` must exist.
893      */
894     function getApproved(uint256 tokenId) external view returns (address operator);
895 
896     /**
897      * @dev Approve or remove `operator` as an operator for the caller.
898      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
899      *
900      * Requirements:
901      *
902      * - The `operator` cannot be the caller.
903      *
904      * Emits an {ApprovalForAll} event.
905      */
906     function setApprovalForAll(address operator, bool _approved) external;
907 
908     /**
909      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
910      *
911      * See {setApprovalForAll}
912      */
913     function isApprovedForAll(address owner, address operator) external view returns (bool);
914 
915     /**
916      * @dev Safely transfers `tokenId` token from `from` to `to`.
917      *
918      * Requirements:
919      *
920      * - `from` cannot be the zero address.
921      * - `to` cannot be the zero address.
922      * - `tokenId` token must exist and be owned by `from`.
923      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
924      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
925      *
926      * Emits a {Transfer} event.
927      */
928     function safeTransferFrom(
929         address from,
930         address to,
931         uint256 tokenId,
932         bytes calldata data
933     ) external;
934 }
935 
936 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
937 
938 
939 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
940 
941 pragma solidity ^0.8.0;
942 
943 
944 /**
945  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
946  * @dev See https://eips.ethereum.org/EIPS/eip-721
947  */
948 interface IERC721Metadata is IERC721 {
949     /**
950      * @dev Returns the token collection name.
951      */
952     function name() external view returns (string memory);
953 
954     /**
955      * @dev Returns the token collection symbol.
956      */
957     function symbol() external view returns (string memory);
958 
959     /**
960      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
961      */
962     function tokenURI(uint256 tokenId) external view returns (string memory);
963 }
964 
965 // File: @openzeppelin/contracts/utils/Context.sol
966 
967 
968 // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
969 
970 pragma solidity ^0.8.0;
971 
972 /**
973  * @dev Provides information about the current execution context, including the
974  * sender of the transaction and its data. While these are generally available
975  * via msg.sender and msg.data, they should not be accessed in such a direct
976  * manner, since when dealing with meta-transactions the account sending and
977  * paying for execution may not be the actual sender (as far as an application
978  * is concerned).
979  *
980  * This contract is only required for intermediate, library-like contracts.
981  */
982 abstract contract Context {
983     function _msgSender() internal view virtual returns (address) {
984         return msg.sender;
985     }
986 
987     function _msgData() internal view virtual returns (bytes calldata) {
988         return msg.data;
989     }
990 }
991 
992 // File: @openzeppelin/contracts/token/ERC721/ERC721.sol
993 
994 
995 // OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)
996 
997 pragma solidity ^0.8.0;
998 
999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 /**
1007  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
1008  * the Metadata extension, but not including the Enumerable extension, which is available separately as
1009  * {ERC721Enumerable}.
1010  */
1011 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
1012     using Address for address;
1013     using Strings for uint256;
1014 
1015     // Token name
1016     string private _name;
1017 
1018     // Token symbol
1019     string private _symbol;
1020 
1021     // Mapping from token ID to owner address
1022     mapping(uint256 => address) private _owners;
1023 
1024     // Mapping owner address to token count
1025     mapping(address => uint256) private _balances;
1026 
1027     // Mapping from token ID to approved address
1028     mapping(uint256 => address) private _tokenApprovals;
1029 
1030     // Mapping from owner to operator approvals
1031     mapping(address => mapping(address => bool)) private _operatorApprovals;
1032 
1033     /**
1034      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
1035      */
1036     constructor(string memory name_, string memory symbol_) {
1037         _name = name_;
1038         _symbol = symbol_;
1039     }
1040 
1041     /**
1042      * @dev See {IERC165-supportsInterface}.
1043      */
1044     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
1045         return
1046             interfaceId == type(IERC721).interfaceId ||
1047             interfaceId == type(IERC721Metadata).interfaceId ||
1048             super.supportsInterface(interfaceId);
1049     }
1050 
1051     /**
1052      * @dev See {IERC721-balanceOf}.
1053      */
1054     function balanceOf(address owner) public view virtual override returns (uint256) {
1055         require(owner != address(0), "ERC721: balance query for the zero address");
1056         return _balances[owner];
1057     }
1058 
1059     /**
1060      * @dev See {IERC721-ownerOf}.
1061      */
1062     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
1063         address owner = _owners[tokenId];
1064         require(owner != address(0), "ERC721: owner query for nonexistent token");
1065         return owner;
1066     }
1067 
1068     /**
1069      * @dev See {IERC721Metadata-name}.
1070      */
1071     function name() public view virtual override returns (string memory) {
1072         return _name;
1073     }
1074 
1075     /**
1076      * @dev See {IERC721Metadata-symbol}.
1077      */
1078     function symbol() public view virtual override returns (string memory) {
1079         return _symbol;
1080     }
1081 
1082     /**
1083      * @dev See {IERC721Metadata-tokenURI}.
1084      */
1085     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1086         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1087 
1088         string memory baseURI = _baseURI();
1089         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1090     }
1091 
1092     /**
1093      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1094      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
1095      * by default, can be overriden in child contracts.
1096      */
1097     function _baseURI() internal view virtual returns (string memory) {
1098         return "";
1099     }
1100 
1101     /**
1102      * @dev See {IERC721-approve}.
1103      */
1104     function approve(address to, uint256 tokenId) public virtual override {
1105         address owner = ERC721.ownerOf(tokenId);
1106         require(to != owner, "ERC721: approval to current owner");
1107 
1108         require(
1109             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1110             "ERC721: approve caller is not owner nor approved for all"
1111         );
1112 
1113         _approve(to, tokenId);
1114     }
1115 
1116     /**
1117      * @dev See {IERC721-getApproved}.
1118      */
1119     function getApproved(uint256 tokenId) public view virtual override returns (address) {
1120         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1121 
1122         return _tokenApprovals[tokenId];
1123     }
1124 
1125     /**
1126      * @dev See {IERC721-setApprovalForAll}.
1127      */
1128     function setApprovalForAll(address operator, bool approved) public virtual override {
1129         _setApprovalForAll(_msgSender(), operator, approved);
1130     }
1131 
1132     /**
1133      * @dev See {IERC721-isApprovedForAll}.
1134      */
1135     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
1136         return _operatorApprovals[owner][operator];
1137     }
1138 
1139     /**
1140      * @dev See {IERC721-transferFrom}.
1141      */
1142     function transferFrom(
1143         address from,
1144         address to,
1145         uint256 tokenId
1146     ) public virtual override {
1147         //solhint-disable-next-line max-line-length
1148         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1149 
1150         _transfer(from, to, tokenId);
1151     }
1152 
1153     /**
1154      * @dev See {IERC721-safeTransferFrom}.
1155      */
1156     function safeTransferFrom(
1157         address from,
1158         address to,
1159         uint256 tokenId
1160     ) public virtual override {
1161         safeTransferFrom(from, to, tokenId, "");
1162     }
1163 
1164     /**
1165      * @dev See {IERC721-safeTransferFrom}.
1166      */
1167     function safeTransferFrom(
1168         address from,
1169         address to,
1170         uint256 tokenId,
1171         bytes memory _data
1172     ) public virtual override {
1173         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1174         _safeTransfer(from, to, tokenId, _data);
1175     }
1176 
1177     /**
1178      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
1179      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1180      *
1181      * `_data` is additional data, it has no specified format and it is sent in call to `to`.
1182      *
1183      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1184      * implement alternative mechanisms to perform token transfer, such as signature-based.
1185      *
1186      * Requirements:
1187      *
1188      * - `from` cannot be the zero address.
1189      * - `to` cannot be the zero address.
1190      * - `tokenId` token must exist and be owned by `from`.
1191      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1192      *
1193      * Emits a {Transfer} event.
1194      */
1195     function _safeTransfer(
1196         address from,
1197         address to,
1198         uint256 tokenId,
1199         bytes memory _data
1200     ) internal virtual {
1201         _transfer(from, to, tokenId);
1202         require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1203     }
1204 
1205     /**
1206      * @dev Returns whether `tokenId` exists.
1207      *
1208      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1209      *
1210      * Tokens start existing when they are minted (`_mint`),
1211      * and stop existing when they are burned (`_burn`).
1212      */
1213     function _exists(uint256 tokenId) internal view virtual returns (bool) {
1214         return _owners[tokenId] != address(0);
1215     }
1216 
1217     /**
1218      * @dev Returns whether `spender` is allowed to manage `tokenId`.
1219      *
1220      * Requirements:
1221      *
1222      * - `tokenId` must exist.
1223      */
1224     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
1225         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1226         address owner = ERC721.ownerOf(tokenId);
1227         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1228     }
1229 
1230     /**
1231      * @dev Safely mints `tokenId` and transfers it to `to`.
1232      *
1233      * Requirements:
1234      *
1235      * - `tokenId` must not exist.
1236      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1237      *
1238      * Emits a {Transfer} event.
1239      */
1240     function _safeMint(address to, uint256 tokenId) internal virtual {
1241         _safeMint(to, tokenId, "");
1242     }
1243 
1244     /**
1245      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
1246      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1247      */
1248     function _safeMint(
1249         address to,
1250         uint256 tokenId,
1251         bytes memory _data
1252     ) internal virtual {
1253         _mint(to, tokenId);
1254         require(
1255             _checkOnERC721Received(address(0), to, tokenId, _data),
1256             "ERC721: transfer to non ERC721Receiver implementer"
1257         );
1258     }
1259 
1260     /**
1261      * @dev Mints `tokenId` and transfers it to `to`.
1262      *
1263      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1264      *
1265      * Requirements:
1266      *
1267      * - `tokenId` must not exist.
1268      * - `to` cannot be the zero address.
1269      *
1270      * Emits a {Transfer} event.
1271      */
1272     function _mint(address to, uint256 tokenId) internal virtual {
1273         require(to != address(0), "ERC721: mint to the zero address");
1274         require(!_exists(tokenId), "ERC721: token already minted");
1275 
1276         _beforeTokenTransfer(address(0), to, tokenId);
1277 
1278         _balances[to] += 1;
1279         _owners[tokenId] = to;
1280 
1281         emit Transfer(address(0), to, tokenId);
1282     }
1283 
1284     /**
1285      * @dev Destroys `tokenId`.
1286      * The approval is cleared when the token is burned.
1287      *
1288      * Requirements:
1289      *
1290      * - `tokenId` must exist.
1291      *
1292      * Emits a {Transfer} event.
1293      */
1294     function _burn(uint256 tokenId) internal virtual {
1295         address owner = ERC721.ownerOf(tokenId);
1296 
1297         _beforeTokenTransfer(owner, address(0), tokenId);
1298 
1299         // Clear approvals
1300         _approve(address(0), tokenId);
1301 
1302         _balances[owner] -= 1;
1303         delete _owners[tokenId];
1304 
1305         emit Transfer(owner, address(0), tokenId);
1306     }
1307 
1308     /**
1309      * @dev Transfers `tokenId` from `from` to `to`.
1310      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1311      *
1312      * Requirements:
1313      *
1314      * - `to` cannot be the zero address.
1315      * - `tokenId` token must be owned by `from`.
1316      *
1317      * Emits a {Transfer} event.
1318      */
1319     function _transfer(
1320         address from,
1321         address to,
1322         uint256 tokenId
1323     ) internal virtual {
1324         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1325         require(to != address(0), "ERC721: transfer to the zero address");
1326 
1327         _beforeTokenTransfer(from, to, tokenId);
1328 
1329         // Clear approvals from the previous owner
1330         _approve(address(0), tokenId);
1331 
1332         _balances[from] -= 1;
1333         _balances[to] += 1;
1334         _owners[tokenId] = to;
1335 
1336         emit Transfer(from, to, tokenId);
1337     }
1338 
1339     /**
1340      * @dev Approve `to` to operate on `tokenId`
1341      *
1342      * Emits a {Approval} event.
1343      */
1344     function _approve(address to, uint256 tokenId) internal virtual {
1345         _tokenApprovals[tokenId] = to;
1346         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1347     }
1348 
1349     /**
1350      * @dev Approve `operator` to operate on all of `owner` tokens
1351      *
1352      * Emits a {ApprovalForAll} event.
1353      */
1354     function _setApprovalForAll(
1355         address owner,
1356         address operator,
1357         bool approved
1358     ) internal virtual {
1359         require(owner != operator, "ERC721: approve to caller");
1360         _operatorApprovals[owner][operator] = approved;
1361         emit ApprovalForAll(owner, operator, approved);
1362     }
1363 
1364     /**
1365      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1366      * The call is not executed if the target address is not a contract.
1367      *
1368      * @param from address representing the previous owner of the given token ID
1369      * @param to target address that will receive the tokens
1370      * @param tokenId uint256 ID of the token to be transferred
1371      * @param _data bytes optional data to send along with the call
1372      * @return bool whether the call correctly returned the expected magic value
1373      */
1374     function _checkOnERC721Received(
1375         address from,
1376         address to,
1377         uint256 tokenId,
1378         bytes memory _data
1379     ) private returns (bool) {
1380         if (to.isContract()) {
1381             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
1382                 return retval == IERC721Receiver.onERC721Received.selector;
1383             } catch (bytes memory reason) {
1384                 if (reason.length == 0) {
1385                     revert("ERC721: transfer to non ERC721Receiver implementer");
1386                 } else {
1387                     assembly {
1388                         revert(add(32, reason), mload(reason))
1389                     }
1390                 }
1391             }
1392         } else {
1393             return true;
1394         }
1395     }
1396 
1397     /**
1398      * @dev Hook that is called before any token transfer. This includes minting
1399      * and burning.
1400      *
1401      * Calling conditions:
1402      *
1403      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
1404      * transferred to `to`.
1405      * - When `from` is zero, `tokenId` will be minted for `to`.
1406      * - When `to` is zero, ``from``'s `tokenId` will be burned.
1407      * - `from` and `to` are never both zero.
1408      *
1409      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1410      */
1411     function _beforeTokenTransfer(
1412         address from,
1413         address to,
1414         uint256 tokenId
1415     ) internal virtual {}
1416 }
1417 
1418 // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol
1419 
1420 
1421 // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)
1422 
1423 pragma solidity ^0.8.0;
1424 
1425 
1426 /**
1427  * @dev ERC721 token with storage based token URI management.
1428  */
1429 abstract contract ERC721URIStorage is ERC721 {
1430     using Strings for uint256;
1431 
1432     // Optional mapping for token URIs
1433     mapping(uint256 => string) private _tokenURIs;
1434 
1435     /**
1436      * @dev See {IERC721Metadata-tokenURI}.
1437      */
1438     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
1439         require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token");
1440 
1441         string memory _tokenURI = _tokenURIs[tokenId];
1442         string memory base = _baseURI();
1443 
1444         // If there is no base URI, return the token URI.
1445         if (bytes(base).length == 0) {
1446             return _tokenURI;
1447         }
1448         // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
1449         if (bytes(_tokenURI).length > 0) {
1450             return string(abi.encodePacked(base, _tokenURI));
1451         }
1452 
1453         return super.tokenURI(tokenId);
1454     }
1455 
1456     /**
1457      * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
1458      *
1459      * Requirements:
1460      *
1461      * - `tokenId` must exist.
1462      */
1463     function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
1464         require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
1465         _tokenURIs[tokenId] = _tokenURI;
1466     }
1467 
1468     /**
1469      * @dev Destroys `tokenId`.
1470      * The approval is cleared when the token is burned.
1471      *
1472      * Requirements:
1473      *
1474      * - `tokenId` must exist.
1475      *
1476      * Emits a {Transfer} event.
1477      */
1478     function _burn(uint256 tokenId) internal virtual override {
1479         super._burn(tokenId);
1480 
1481         if (bytes(_tokenURIs[tokenId]).length != 0) {
1482             delete _tokenURIs[tokenId];
1483         }
1484     }
1485 }
1486 
1487 // File: @openzeppelin/contracts/access/Ownable.sol
1488 
1489 
1490 // OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)
1491 
1492 pragma solidity ^0.8.0;
1493 
1494 
1495 /**
1496  * @dev Contract module which provides a basic access control mechanism, where
1497  * there is an account (an owner) that can be granted exclusive access to
1498  * specific functions.
1499  *
1500  * By default, the owner account will be the one that deploys the contract. This
1501  * can later be changed with {transferOwnership}.
1502  *
1503  * This module is used through inheritance. It will make available the modifier
1504  * `onlyOwner`, which can be applied to your functions to restrict their use to
1505  * the owner.
1506  */
1507 abstract contract Ownable is Context {
1508     address private _owner;
1509 
1510     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
1511 
1512     /**
1513      * @dev Initializes the contract setting the deployer as the initial owner.
1514      */
1515     constructor() {
1516         _transferOwnership(_msgSender());
1517     }
1518 
1519     /**
1520      * @dev Returns the address of the current owner.
1521      */
1522     function owner() public view virtual returns (address) {
1523         return _owner;
1524     }
1525 
1526     /**
1527      * @dev Throws if called by any account other than the owner.
1528      */
1529     modifier onlyOwner() {
1530         require(owner() == _msgSender(), "Ownable: caller is not the owner");
1531         _;
1532     }
1533 
1534     /**
1535      * @dev Leaves the contract without owner. It will not be possible to call
1536      * `onlyOwner` functions anymore. Can only be called by the current owner.
1537      *
1538      * NOTE: Renouncing ownership will leave the contract without an owner,
1539      * thereby removing any functionality that is only available to the owner.
1540      */
1541     function renounceOwnership() public virtual onlyOwner {
1542         _transferOwnership(address(0));
1543     }
1544 
1545     /**
1546      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1547      * Can only be called by the current owner.
1548      */
1549     function transferOwnership(address newOwner) public virtual onlyOwner {
1550         require(newOwner != address(0), "Ownable: new owner is the zero address");
1551         _transferOwnership(newOwner);
1552     }
1553 
1554     /**
1555      * @dev Transfers ownership of the contract to a new account (`newOwner`).
1556      * Internal function without access restriction.
1557      */
1558     function _transferOwnership(address newOwner) internal virtual {
1559         address oldOwner = _owner;
1560         _owner = newOwner;
1561         emit OwnershipTransferred(oldOwner, newOwner);
1562     }
1563 }
1564 
1565 // File: contracts/4_MechArcade.sol
1566 
1567 
1568 //  __   __  _______  _______  __   __  _______  ______    _______  _______  ______   _______
1569 // |  |_|  ||       ||       ||  | |  ||   _   ||    _ |  |       ||   _   ||      | |       |
1570 // |       ||    ___||       ||  |_|  ||  |_|  ||   | ||  |       ||  |_|  ||  _    ||    ___|
1571 // |       ||   |___ |       ||       ||       ||   |_||_ |       ||       || | |   ||   |___
1572 // |       ||    ___||      _||       ||       ||    __  ||      _||       || |_|   ||    ___|
1573 // | ||_|| ||   |___ |     |_ |   _   ||   _   ||   |  | ||     |_ |   _   ||       ||   |___
1574 // |_|   |_||_______||_______||__| |__||__| |__||___|  |_||_______||__| |__||______| |_______|
1575 //                                                                          
1576 // MechArcade: The Lost Metal Alliance
1577 //
1578 // Official Links:
1579 // mecharcade.eth
1580 // www.mecharcade.com
1581 // twitter.com/mecharcade
1582 // discord.gg/mecharcade
1583 //
1584 // Planned Drop Dates:
1585 // Jan 18, 2022 - 6pm PST / 9pm EST Whitelist Mint Begins
1586 // Jan 19, 2022 - 6pm PST / 9pm EST Waitlist Mint Begins
1587 // Jan 20, 2022 - 6pm PST / 9pm EST Public Mint Begins
1588 //
1589 // The MechArcade team wants to thank you for checking out our project and joining us in building
1590 // the metaverse. We are builders and have a special place in our hearts for devs. So if you're
1591 // reading this before our mint, we'd like to invite you to join our whitelist by going to 
1592 // premint.xyz/solidity - WAGMI
1593 
1594 pragma solidity 0.8.7;
1595 
1596 
1597 
1598 
1599 
1600 contract MechNFT is ERC721URIStorage, VRFConsumerBase, Ownable {
1601         
1602     // Enum representing mint status
1603     enum MintPhase {
1604         Closed,
1605         Whitelist,
1606         Open
1607     }
1608 
1609     MintPhase public liveStatus;
1610 
1611     event requestProtoMech(uint256 indexed tokenId);
1612     event receivedChainlinkVRF(bytes32 indexed requestId, uint256 randomNumber);
1613     event executedReveal(uint256 mechsRevealed);
1614     
1615     string public baseURI;
1616 
1617     address public constant whitelistSigner = 0x21aE3B48BA6876D9298E37F0A56c8d51339C6e74;
1618     address public constant proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1; // Approving Opensea Registry for lower secondary gas
1619    
1620     uint256 public tokenCounter;
1621     uint256 public revealedMechs;
1622     uint256 public maxMint;
1623     uint256 internal fee;
1624     uint256 public rngSeed;
1625 
1626     uint256 public constant price = 0.08 ether; 
1627     uint256 public constant maxSupply = 10001; // Adding one to max supply to avoid LTE operator
1628 
1629     bytes32 internal keyHash;
1630 
1631     bool public mutableMetadata;
1632     
1633     mapping(address => uint256) addressToNumberOfTokensMinted;
1634 
1635     constructor()
1636         VRFConsumerBase(0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, 0x514910771AF9Ca656af840dff83E8264EcF986CA)
1637         ERC721("MechNFT", "MECH")
1638     {
1639         //update for launch
1640         liveStatus = MintPhase.Closed;
1641         tokenCounter = 0;
1642         mutableMetadata = true;
1643         revealedMechs = 0;
1644         keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445; // ChainLink keyHash
1645         baseURI = "https://gateway.pinata.cloud/ipfs/QmaorAspp4UDE2eB6hxUeT4P2N7rmqR6KU1t4XtcDuagJD/Mech_";
1646         fee =   2* 10 ** 18; //      Ethereum Mainnet Price
1647         maxMint = 3; // Contract adds one to maxMint to avoid using LTE operator for lower gas
1648 
1649     }
1650 
1651     //Withdraw funds to owner.
1652     function withdraw() public payable onlyOwner {
1653         payable(owner()).transfer(address(this).balance);
1654     }
1655 
1656     //Allows owner to permanently freeze metadata URI - ownerAddress can send freezeMetadata(TRUE) to freeze the data.
1657     function freezeMetadata(bool _freeze) public onlyOwner {
1658         mutableMetadata = mutableMetadata && !_freeze;
1659     }
1660 
1661     //int to string function.
1662     function uint2str(uint256 _i)
1663         internal
1664         pure
1665         returns (string memory _uintAsString)
1666     {
1667         if (_i == 0) {
1668             return "0";
1669         }
1670         uint256 j = _i;
1671         uint256 len;
1672         while (j != 0) {
1673             len++;
1674             j /= 10;
1675         }
1676         bytes memory bstr = new bytes(len);
1677         uint256 k = len;
1678         while (_i != 0) {
1679             k = k - 1;
1680             uint8 temp = (48 + uint8(_i - (_i / 10) * 10));
1681             bytes1 b1 = bytes1(temp);
1682             bstr[k] = b1;
1683             _i /= 10;
1684         }
1685         return string(bstr);
1686     }
1687 
1688     function tokenURI(uint256 tokenId)
1689         public
1690         view
1691         virtual
1692         override
1693         returns (string memory)
1694     {
1695         require(
1696             _exists(tokenId),
1697             "ERC721Metadata: URI query for nonexistent token"
1698         );
1699 
1700         if (tokenId < revealedMechs) {
1701             string memory _token = string(abi.encodePacked(uint2str(tokenId+1)));
1702             return string(abi.encodePacked(baseURI, _token, ".json"));
1703         }
1704         return string(abi.encodePacked(baseURI, "0.json"));
1705     }
1706 
1707     //OwnerMinting Function. The team is reserving 100 Mechs from the 10,000 collection for promotional purposes and internal rewards.
1708     function ownerMint(uint256 tokenQuant) public payable virtual onlyOwner {
1709         
1710         require(
1711             tokenCounter + tokenQuant < maxSupply,
1712             "Would exceed max supply!"
1713         );
1714 
1715         for (uint256 i; i < tokenQuant; i++) {
1716             _mint(msg.sender, tokenCounter);
1717             tokenCounter = tokenCounter + 1;
1718         }
1719 
1720     }
1721 
1722     //Function is named to generate a Method ID of 0x00007f6c to save gas
1723     function whitelistMint_rhh(uint256 tokenQuant, bytes memory _whitelistToken)
1724         public
1725         payable
1726         virtual
1727     {
1728         
1729         require(
1730             (liveStatus == MintPhase.Whitelist) &&
1731                 (whitelistSigner == recoverSigner_94g(_whitelistToken)),
1732             "Either Whitelist Phase is not live or your Whitelist Code is invalid!"
1733         );
1734 
1735         require(
1736             tokenCounter + tokenQuant < maxSupply,
1737             "Would exceed max supply"
1738         );
1739 
1740         require(
1741             msg.value == price * tokenQuant,
1742             "Wrong amount of ETH sent - please check price!"
1743         );
1744 
1745         require(
1746             addressToNumberOfTokensMinted[msg.sender] + tokenQuant < maxMint,
1747             "Minting this many tokens takes you over your maximum amount!"
1748         );
1749 
1750         // Increasing minted count in dictionary
1751         addressToNumberOfTokensMinted[msg.sender] += tokenQuant;
1752 
1753         for (uint256 i; i < tokenQuant; i++) {
1754             _mint(msg.sender, tokenCounter);
1755             tokenCounter = tokenCounter + 1;
1756         }
1757     }
1758 
1759     // Separating mint phases to reduce operations
1760     function publicMint_1VS(uint256 tokenQuant) public payable virtual {
1761         require(
1762             liveStatus == MintPhase.Open,
1763             "Mint Phase is not open to the public yet!"
1764         );
1765 
1766         require(
1767             tokenCounter + tokenQuant < maxSupply,
1768             "Would exceed max supply"
1769         );
1770 
1771         require(
1772             msg.value == price * tokenQuant,
1773             "Wrong amount of ETH sent - please check price!"
1774         );
1775 
1776         require(
1777             addressToNumberOfTokensMinted[msg.sender] + tokenQuant < maxMint,
1778             "Minting this many tokens takes you over your maximum amount!"
1779         );
1780 
1781         // Increasing minted count in dictionary
1782         addressToNumberOfTokensMinted[msg.sender] += tokenQuant;
1783 
1784         for (uint256 i; i < tokenQuant; i++) {
1785             _mint(msg.sender, tokenCounter);
1786             tokenCounter = tokenCounter + 1;
1787         }
1788     }
1789 
1790     //Request from Mecharcade to get a verified Chainlink random number to assign mechs to tokenIDs. Please check
1791     //the website FAQ for more details on how the reveal will happen and how we are using Chainlink's VRF for a 
1792     //provably fair distribution of the Mechs.
1793     function chainLinkGetSeed() public onlyOwner {
1794         require(
1795             LINK.balanceOf(address(this)) >= fee,
1796             "Not enough LINK - fill contract with faucet"
1797         );
1798 
1799         requestRandomness(keyHash, fee);
1800     }
1801 
1802     //Called by Chainlink with requested random number.
1803     function fulfillRandomness(bytes32 requestId, uint256 randomNumber)
1804         internal
1805         override
1806     {
1807         rngSeed = randomNumber;
1808         emit receivedChainlinkVRF(requestId, randomNumber);
1809     }
1810 
1811     //Set the MintingPhase which controls contract behavior.
1812     function setMintPhase(MintPhase phase, uint256 maxAmount) public onlyOwner {
1813         liveStatus = phase;
1814         maxMint = maxAmount;
1815     }
1816 
1817     //Set the base path on Pinata.
1818     function reveal(string memory base) public onlyOwner {
1819         require(
1820             mutableMetadata, // Check to make sure the collection hasn't been frozen before allowing the metadata to change
1821             "Metadata is frozen on the blockchain forever"
1822         );
1823         baseURI = base;
1824         emit executedReveal(tokenCounter - revealedMechs);
1825         revealedMechs = tokenCounter;
1826     }
1827 
1828     //Allows owner to manually set rngSeed from external source
1829     function setRNGSeed(uint256 _rngSeed) public onlyOwner {
1830         rngSeed = _rngSeed;
1831     }
1832 
1833     //Extract the signer address for the whitelist verification.
1834     function recoverSigner_94g(bytes memory _signature)
1835         internal
1836         view
1837         returns (address)
1838     {
1839         (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);
1840         bytes32 senderhash = keccak256(abi.encodePacked(msg.sender));
1841         bytes32 finalhash = keccak256(
1842             abi.encodePacked("\x19Ethereum Signed Message:\n32", senderhash)
1843         );
1844 
1845         return ecrecover(finalhash, v, r, s);
1846     }
1847 
1848     //Extract the components of the whitelist signature.
1849     function splitSignature(bytes memory sig)
1850         public
1851         pure
1852         returns (
1853             bytes32 r,
1854             bytes32 s,
1855             uint8 v
1856         )
1857     {
1858         require(sig.length == 65, "invalid signature length");
1859         assembly {
1860             r := mload(add(sig, 32))
1861             s := mload(add(sig, 64))
1862             v := byte(0, mload(add(sig, 96)))
1863         }
1864     }
1865 
1866     // Approving OpenSea Proxy to reduce gas costs for secondary sales 
1867     function isApprovedForAll(address _owner, address operator) public view override returns (bool) {
1868         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);
1869         if (address(proxyRegistry.proxies(_owner)) == operator) return true;
1870         return super.isApprovedForAll(_owner, operator);
1871     }
1872 }
1873 
1874 contract OwnableDelegateProxy { }
1875 contract OpenSeaProxyRegistry {
1876     mapping(address => OwnableDelegateProxy) public proxies;
1877 }