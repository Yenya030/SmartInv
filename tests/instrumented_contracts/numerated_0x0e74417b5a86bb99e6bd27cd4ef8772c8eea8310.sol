1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "contracts/EON.sol": {
43       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IEON.sol\";\r\n\r\ncontract EON is IEON, ERC20 {\r\n    // Tracks the last block that a caller has written to state.\r\n    // Disallow some access to functions if they occur while a change is being written.\r\n    mapping(address => uint256) private lastWrite;\r\n\r\n    // address => allowedToCallFunctions\r\n    mapping(address => bool) private admins;\r\n    //ower\r\n    address public auth;\r\n    // hardcoded max eon supply 5b\r\n    uint256 public constant MAX_EON = 5000000000 ether;\r\n\r\n    // amount minted\r\n    uint256 public minted;\r\n\r\n    constructor() ERC20(\"EON\", \"EON\", 18) {\r\n        auth = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == auth);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * enables an address to mint / burn\r\n     * @param addr the address to enable\r\n     */\r\n    function addAdmin(address addr) external onlyOwner {\r\n        admins[addr] = true;\r\n    }\r\n\r\n    /**\r\n     * disables an address from minting / burning\r\n     * @param addr the address to disbale\r\n     */\r\n    function removeAdmin(address addr) external onlyOwner {\r\n        admins[addr] = false;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        auth = newOwner;\r\n    }\r\n\r\n    /**\r\n     * mints $EON to a recipient\r\n     * @param to the recipient of the $EON\r\n     * @param amount the amount of $EON to mint\r\n     */\r\n    function mint(address to, uint256 amount) external override {\r\n        require(admins[msg.sender], \"Only admins can mint\");\r\n        minted += amount;\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /**\r\n     * burns $EON from a holder\r\n     * @param from the holder of the $EON\r\n     * @param amount the amount of $EON to burn\r\n     */\r\n    function burn(address from, uint256 amount) external override {\r\n        require(admins[msg.sender], \"Only admins\");\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override(ERC20, IEON) returns (bool) {\r\n        // caught yah\r\n        require(\r\n            admins[msg.sender] || lastWrite[sender] < block.number,\r\n            \"hmmmm what are you doing?\"\r\n        );\r\n        // If the entity invoking this transfer is an admin (i.e. the gameContract)\r\n        // allow the transfer without approval. This saves gas and a transaction.\r\n        // The sender address will still need to actually have the amount being attempted to send.\r\n        if (admins[msg.sender]) {\r\n            // NOTE: This will omit any events from being written. This saves additional gas,\r\n            // and the event emission is not a requirement by the EIP\r\n            // (read this function summary / ERC20 summary for more details)\r\n            emit Transfer(sender, recipient, amount);\r\n            return true;\r\n        }\r\n\r\n        // If it's not an admin entity (Shattered EON contract, pytheas, refinery. etc)\r\n        // The entity will need to be given permission to transfer these funds\r\n        // For instance, someone can't just make a contract and siphon $EON from every account\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n}\r\n"
44     },
45     "contracts/ERC20.sol": {
46       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
47     },
48     "contracts/interfaces/IEON.sol": {
49       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
50     }
51   }
52 }}