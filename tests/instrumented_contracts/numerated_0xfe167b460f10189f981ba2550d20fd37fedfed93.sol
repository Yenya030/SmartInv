1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 
20 pragma solidity ^0.4.21;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   uint256 public totalSupply;
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
43     if (a == 0) {
44       return 0;
45     }
46     uint256 c = a * b;
47     assert(c / a == b);
48     return c;
49   }
50 
51   function div(uint256 a, uint256 b) internal pure returns (uint256) {
52     // assert(b > 0); // Solidity automatically throws when dividing by 0
53     uint256 c = a / b;
54     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
55     return c;
56   }
57 
58   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
59     assert(b <= a);
60     return a - b;
61   }
62 
63   function add(uint256 a, uint256 b) internal pure returns (uint256) {
64     uint256 c = a + b;
65     assert(c >= a);
66     return c;
67   }
68 }
69 
70 
71 
72 /**
73  * @title Basic token
74  * @dev Basic version of StandardToken, with no allowances.
75  */
76 contract BasicToken is ERC20Basic {
77   using SafeMath for uint256;
78 
79   mapping(address => uint256) balances;
80 
81   /**
82   * @dev transfer token for a specified address
83   * @param _to The address to transfer to.
84   * @param _value The amount to be transferred.
85   */
86   function transfer(address _to, uint256 _value) public returns (bool) {
87     require(_to != address(0));
88     require(_value <= balances[msg.sender]);
89 
90     // SafeMath.sub will throw if there is not enough balance.
91     balances[msg.sender] = balances[msg.sender].sub(_value);
92     balances[_to] = balances[_to].add(_value);
93     Transfer(msg.sender, _to, _value);
94     return true;
95   }
96 
97   /**
98   * @dev Gets the balance of the specified address.
99   * @param _owner The address to query the the balance of.
100   * @return An uint256 representing the amount owned by the passed address.
101   */
102   function balanceOf(address _owner) public view returns (uint256 balance) {
103     return balances[_owner];
104   }
105 
106 }
107 
108 
109 
110 /**
111  * @title ERC20 interface
112  * @dev see https://github.com/ethereum/EIPs/issues/20
113  */
114 contract ERC20 is ERC20Basic {
115   function allowance(address owner, address spender) public view returns (uint256);
116   function transferFrom(address from, address to, uint256 value) public returns (bool);
117   function approve(address spender, uint256 value) public returns (bool);
118   event Approval(address indexed owner, address indexed spender, uint256 value);
119 }
120 
121 
122 
123 /**
124  * @title Standard ERC20 token
125  *
126  * @dev Implementation of the basic standard token.
127  * @dev https://github.com/ethereum/EIPs/issues/20
128  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
129  */
130 contract StandardToken is ERC20, BasicToken {
131 
132   mapping (address => mapping (address => uint256)) internal allowed;
133 
134 
135   /**
136    * @dev Transfer tokens from one address to another
137    * @param _from address The address which you want to send tokens from
138    * @param _to address The address which you want to transfer to
139    * @param _value uint256 the amount of tokens to be transferred
140    */
141   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
142     require(_to != address(0));
143     require(_value <= balances[_from]);
144     require(_value <= allowed[_from][msg.sender]);
145 
146     balances[_from] = balances[_from].sub(_value);
147     balances[_to] = balances[_to].add(_value);
148     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
149     Transfer(_from, _to, _value);
150     return true;
151   }
152 
153   /**
154    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
155    *
156    * Beware that changing an allowance with this method brings the risk that someone may use both the old
157    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
158    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
159    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
160    * @param _spender The address which will spend the funds.
161    * @param _value The amount of tokens to be spent.
162    */
163   function approve(address _spender, uint256 _value) public returns (bool) {
164     allowed[msg.sender][_spender] = _value;
165     Approval(msg.sender, _spender, _value);
166     return true;
167   }
168 
169   /**
170    * @dev Function to check the amount of tokens that an owner allowed to a spender.
171    * @param _owner address The address which owns the funds.
172    * @param _spender address The address which will spend the funds.
173    * @return A uint256 specifying the amount of tokens still available for the spender.
174    */
175   function allowance(address _owner, address _spender) public view returns (uint256) {
176     return allowed[_owner][_spender];
177   }
178 
179   /**
180    * approve should be called when allowed[_spender] == 0. To increment
181    * allowed value is better to use this function to avoid 2 calls (and wait until
182    * the first transaction is mined)
183    * From MonolithDAO Token.sol
184    */
185   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
186     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
187     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
188     return true;
189   }
190 
191   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
192     uint oldValue = allowed[msg.sender][_spender];
193     if (_subtractedValue > oldValue) {
194       allowed[msg.sender][_spender] = 0;
195     } else {
196       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
197     }
198     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
199     return true;
200   }
201 
202 }
203 
204 
205 
206 /**
207  * @title Ownable
208  * @dev The Ownable contract has an owner address, and provides basic authorization control
209  * functions, this simplifies the implementation of "user permissions".
210  */
211 contract Ownable {
212   address public owner;
213 
214 
215   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
216 
217 
218   /**
219    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
220    * account.
221    */
222   function Ownable() public {
223     owner = msg.sender;
224   }
225 
226 
227   /**
228    * @dev Throws if called by any account other than the owner.
229    */
230   modifier onlyOwner() {
231     require(msg.sender == owner);
232     _;
233   }
234 
235 
236   /**
237    * @dev Allows the current owner to transfer control of the contract to a newOwner.
238    * @param newOwner The address to transfer ownership to.
239    */
240   function transferOwnership(address newOwner) public onlyOwner {
241     require(newOwner != address(0));
242     OwnershipTransferred(owner, newOwner);
243     owner = newOwner;
244   }
245 
246 }
247 
248 
249 
250 /**
251  * @title Mintable token
252  * @dev Simple ERC20 Token example, with mintable token creation
253  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
254  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
255  */
256 
257 contract MintableToken is StandardToken, Ownable {
258   event Mint(address indexed to, uint256 amount);
259   event MintFinished();
260 
261   bool public mintingFinished = false;
262 
263 
264   modifier canMint() {
265     require(!mintingFinished);
266     _;
267   }
268 
269   /**
270    * @dev Function to mint tokens
271    * @param _to The address that will receive the minted tokens.
272    * @param _amount The amount of tokens to mint.
273    * @return A boolean that indicates if the operation was successful.
274    */
275   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
276     totalSupply = totalSupply.add(_amount);
277     balances[_to] = balances[_to].add(_amount);
278     Mint(_to, _amount);
279     Transfer(address(0), _to, _amount);
280     return true;
281   }
282 
283   /**
284    * @dev Function to stop minting new tokens.
285    * @return True if the operation was successful.
286    */
287   function finishMinting() onlyOwner canMint public returns (bool) {
288     mintingFinished = true;
289     MintFinished();
290     return true;
291   }
292 }
293 
294 
295 /**
296  * @title Crowdsale
297  * @dev Crowdsale is a base contract for managing a token crowdsale.
298  * Crowdsales have a start and end timestamps, where investors can make
299  * token purchases and the crowdsale will assign them tokens based
300  * on a token per ETH rate. Funds collected are forwarded to a wallet
301  * as they arrive.
302  */
303 contract Crowdsale {
304   using SafeMath for uint256;
305 
306   // The token being sold
307   MintableToken public token;
308 
309   // start and end timestamps where investments are allowed (both inclusive)
310   uint256 public startTime;
311   uint256 public endTime;
312 
313   // address where funds are collected
314   address public wallet;
315 
316   // how many token units a buyer gets per wei
317   uint256 public rate;
318 
319   // amount of raised money in wei
320   uint256 public weiRaised;
321 
322   /**
323    * event for token purchase logging
324    * @param purchaser who paid for the tokens
325    * @param beneficiary who got the tokens
326    * @param value weis paid for purchase
327    * @param amount amount of tokens purchased
328    */
329   event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
330 
331 
332   function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
333     require(_startTime >= now);
334     require(_endTime >= _startTime);
335     require(_rate > 0);
336     require(_wallet != address(0));
337 
338     token = createTokenContract();
339     startTime = _startTime;
340     endTime = _endTime;
341     rate = _rate;
342     wallet = _wallet;
343   }
344 
345   // creates the token to be sold.
346   // override this method to have crowdsale of a specific mintable token.
347   function createTokenContract() internal returns (MintableToken) {
348     return new MintableToken();
349   }
350 
351 
352   // fallback function can be used to buy tokens
353   function () external payable {
354     buyTokens(msg.sender);
355   }
356 
357   // low level token purchase function
358   function buyTokens(address beneficiary) public payable {
359     require(beneficiary != address(0));
360     require(validPurchase());
361 
362     uint256 weiAmount = msg.value;
363 
364     // calculate token amount to be created
365     uint256 tokens = weiAmount.mul(rate);
366 
367     // update state
368     weiRaised = weiRaised.add(weiAmount);
369 
370     token.mint(beneficiary, tokens);
371     TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
372 
373     forwardFunds();
374   }
375 
376   // send ether to the fund collection wallet
377   // override to create custom fund forwarding mechanisms
378   function forwardFunds() internal {
379     wallet.transfer(msg.value);
380   }
381 
382   // @return true if the transaction can buy tokens
383   function validPurchase() internal view returns (bool) {
384     bool withinPeriod = now >= startTime && now <= endTime;
385     bool nonZeroPurchase = msg.value != 0;
386     return withinPeriod && nonZeroPurchase;
387   }
388 
389   // @return true if crowdsale event has ended
390   function hasEnded() public view returns (bool) {
391     return now > endTime;
392   }
393 
394 
395 }
396 
397 
398 
399 contract FreezableToken is StandardToken {
400     // freezing chains
401     mapping (bytes32 => uint64) internal chains;
402     // freezing amounts for each chain
403     mapping (bytes32 => uint) internal freezings;
404     // total freezing balance per address
405     mapping (address => uint) internal freezingBalance;
406 
407     event Freezed(address indexed to, uint64 release, uint amount);
408     event Released(address indexed owner, uint amount);
409 
410 
411     /**
412      * @dev Gets the balance of the specified address include freezing tokens.
413      * @param _owner The address to query the the balance of.
414      * @return An uint256 representing the amount owned by the passed address.
415      */
416     function balanceOf(address _owner) public view returns (uint256 balance) {
417         return super.balanceOf(_owner) + freezingBalance[_owner];
418     }
419 
420     /**
421      * @dev Gets the balance of the specified address without freezing tokens.
422      * @param _owner The address to query the the balance of.
423      * @return An uint256 representing the amount owned by the passed address.
424      */
425     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
426         return super.balanceOf(_owner);
427     }
428 
429     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
430         return freezingBalance[_owner];
431     }
432 
433     /**
434      * @dev gets freezing count
435      * @param _addr Address of freeze tokens owner.
436      */
437     function freezingCount(address _addr) public view returns (uint count) {
438         uint64 release = chains[toKey(_addr, 0)];
439         while (release != 0) {
440             count ++;
441             release = chains[toKey(_addr, release)];
442         }
443     }
444 
445     /**
446      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
447      * @param _addr Address of freeze tokens owner.
448      * @param _index Freezing portion index. It ordered by release date descending.
449      */
450     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
451         for (uint i = 0; i < _index + 1; i ++) {
452             _release = chains[toKey(_addr, _release)];
453             if (_release == 0) {
454                 return;
455             }
456         }
457         _balance = freezings[toKey(_addr, _release)];
458     }
459 
460     /**
461      * @dev freeze your tokens to the specified address.
462      *      Be careful, gas usage is not deterministic,
463      *      and depends on how many freezes _to address already has.
464      * @param _to Address to which token will be freeze.
465      * @param _amount Amount of token to freeze.
466      * @param _until Release date, must be in future.
467      */
468     function freezeTo(address _to, uint _amount, uint64 _until) public {
469         require(_to != address(0));
470         require(_amount <= balances[msg.sender]);
471 
472         balances[msg.sender] = balances[msg.sender].sub(_amount);
473 
474         bytes32 currentKey = toKey(_to, _until);
475         freezings[currentKey] = freezings[currentKey].add(_amount);
476         freezingBalance[_to] = freezingBalance[_to].add(_amount);
477 
478         freeze(_to, _until);
479         emit Transfer(msg.sender, _to, _amount);
480         emit Freezed(_to, _until, _amount);
481     }
482 
483     /**
484      * @dev release first available freezing tokens.
485      */
486     function releaseOnce() public {
487         bytes32 headKey = toKey(msg.sender, 0);
488         uint64 head = chains[headKey];
489         require(head != 0);
490         require(uint64(block.timestamp) > head);
491         bytes32 currentKey = toKey(msg.sender, head);
492 
493         uint64 next = chains[currentKey];
494 
495         uint amount = freezings[currentKey];
496         delete freezings[currentKey];
497 
498         balances[msg.sender] = balances[msg.sender].add(amount);
499         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
500 
501         if (next == 0) {
502             delete chains[headKey];
503         }
504         else {
505             chains[headKey] = next;
506             delete chains[currentKey];
507         }
508         emit Released(msg.sender, amount);
509     }
510 
511     /**
512      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
513      * @return how many tokens was released
514      */
515     function releaseAll() public returns (uint tokens) {
516         uint release;
517         uint balance;
518         (release, balance) = getFreezing(msg.sender, 0);
519         while (release != 0 && block.timestamp > release) {
520             releaseOnce();
521             tokens += balance;
522             (release, balance) = getFreezing(msg.sender, 0);
523         }
524     }
525 
526     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
527         // WISH masc to increase entropy
528         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
529         assembly {
530             result := or(result, mul(_addr, 0x10000000000000000))
531             result := or(result, _release)
532         }
533     }
534 
535     function freeze(address _to, uint64 _until) internal {
536         require(_until > block.timestamp);
537         bytes32 key = toKey(_to, _until);
538         bytes32 parentKey = toKey(_to, uint64(0));
539         uint64 next = chains[parentKey];
540 
541         if (next == 0) {
542             chains[parentKey] = _until;
543             return;
544         }
545 
546         bytes32 nextKey = toKey(_to, next);
547         uint parent;
548 
549         while (next != 0 && _until > next) {
550             parent = next;
551             parentKey = nextKey;
552 
553             next = chains[nextKey];
554             nextKey = toKey(_to, next);
555         }
556 
557         if (_until == next) {
558             return;
559         }
560 
561         if (next != 0) {
562             chains[key] = next;
563         }
564 
565         chains[parentKey] = _until;
566     }
567 }
568 
569 
570 /**
571  * @title Burnable Token
572  * @dev Token that can be irreversibly burned (destroyed).
573  */
574 contract BurnableToken is StandardToken {
575 
576     event Burn(address indexed burner, uint256 value);
577 
578     /**
579      * @dev Burns a specific amount of tokens.
580      * @param _value The amount of token to be burned.
581      */
582     function burn(uint256 _value) public {
583         require(_value > 0);
584         require(_value <= balances[msg.sender]);
585         // no need to require value <= totalSupply, since that would imply the
586         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
587 
588         address burner = msg.sender;
589         balances[burner] = balances[burner].sub(_value);
590         totalSupply = totalSupply.sub(_value);
591         Burn(burner, _value);
592     }
593 }
594 
595 
596 
597 /**
598  * @title Pausable
599  * @dev Base contract which allows children to implement an emergency stop mechanism.
600  */
601 contract Pausable is Ownable {
602   event Pause();
603   event Unpause();
604 
605   bool public paused = false;
606 
607 
608   /**
609    * @dev Modifier to make a function callable only when the contract is not paused.
610    */
611   modifier whenNotPaused() {
612     require(!paused);
613     _;
614   }
615 
616   /**
617    * @dev Modifier to make a function callable only when the contract is paused.
618    */
619   modifier whenPaused() {
620     require(paused);
621     _;
622   }
623 
624   /**
625    * @dev called by the owner to pause, triggers stopped state
626    */
627   function pause() onlyOwner whenNotPaused public {
628     paused = true;
629     Pause();
630   }
631 
632   /**
633    * @dev called by the owner to unpause, returns to normal state
634    */
635   function unpause() onlyOwner whenPaused public {
636     paused = false;
637     Unpause();
638   }
639 }
640 
641 
642 
643 contract FreezableMintableToken is FreezableToken, MintableToken {
644     /**
645      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
646      *      Be careful, gas usage is not deterministic,
647      *      and depends on how many freezes _to address already has.
648      * @param _to Address to which token will be freeze.
649      * @param _amount Amount of token to mint and freeze.
650      * @param _until Release date, must be in future.
651      * @return A boolean that indicates if the operation was successful.
652      */
653     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
654         totalSupply = totalSupply.add(_amount);
655 
656         bytes32 currentKey = toKey(_to, _until);
657         freezings[currentKey] = freezings[currentKey].add(_amount);
658         freezingBalance[_to] = freezingBalance[_to].add(_amount);
659 
660         freeze(_to, _until);
661         emit Mint(_to, _amount);
662         emit Freezed(_to, _until, _amount);
663         emit Transfer(msg.sender, _to, _amount);
664         return true;
665     }
666 }
667 
668 contract Consts {
669     uint constant TOKEN_DECIMALS = 18;
670     uint8 constant TOKEN_DECIMALS_UINT8 = 18;
671     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
672 
673     string constant TOKEN_NAME = "MAKEAFOLIO";
674     string constant TOKEN_SYMBOL = "MAF";
675     bool constant PAUSED = true;
676     address constant TARGET_USER = 0x8De57367b1Bb53afc74f5efAbAebC3A971FA69A9;
677     
678     uint constant START_TIME = 1530417600;
679     
680     bool constant CONTINUE_MINTING = false;
681 }
682 
683 
684 
685 
686 /**
687  * @title FinalizableCrowdsale
688  * @dev Extension of Crowdsale where an owner can do extra work
689  * after finishing.
690  */
691 contract FinalizableCrowdsale is Crowdsale, Ownable {
692   using SafeMath for uint256;
693 
694   bool public isFinalized = false;
695 
696   event Finalized();
697 
698   /**
699    * @dev Must be called after crowdsale ends, to do some extra finalization
700    * work. Calls the contract's finalization function.
701    */
702   function finalize() onlyOwner public {
703     require(!isFinalized);
704     require(hasEnded());
705 
706     finalization();
707     Finalized();
708 
709     isFinalized = true;
710   }
711 
712   /**
713    * @dev Can be overridden to add finalization logic. The overriding function
714    * should call super.finalization() to ensure the chain of finalization is
715    * executed entirely.
716    */
717   function finalization() internal {
718   }
719 }
720 
721 
722 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
723     
724 {
725     
726 
727     function name() pure public returns (string _name) {
728         return TOKEN_NAME;
729     }
730 
731     function symbol() pure public returns (string _symbol) {
732         return TOKEN_SYMBOL;
733     }
734 
735     function decimals() pure public returns (uint8 _decimals) {
736         return TOKEN_DECIMALS_UINT8;
737     }
738 
739     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
740         require(!paused);
741         return super.transferFrom(_from, _to, _value);
742     }
743 
744     function transfer(address _to, uint256 _value) public returns (bool _success) {
745         require(!paused);
746         return super.transfer(_to, _value);
747     }
748 }
749 
750 
751 
752 
753 /**
754  * @title CappedCrowdsale
755  * @dev Extension of Crowdsale with a max amount of funds raised
756  */
757 contract CappedCrowdsale is Crowdsale {
758   using SafeMath for uint256;
759 
760   uint256 public cap;
761 
762   function CappedCrowdsale(uint256 _cap) public {
763     require(_cap > 0);
764     cap = _cap;
765   }
766 
767   // overriding Crowdsale#validPurchase to add extra cap logic
768   // @return true if investors can buy at the moment
769   function validPurchase() internal view returns (bool) {
770     bool withinCap = weiRaised.add(msg.value) <= cap;
771     return super.validPurchase() && withinCap;
772   }
773 
774   // overriding Crowdsale#hasEnded to add cap logic
775   // @return true if crowdsale event has ended
776   function hasEnded() public view returns (bool) {
777     bool capReached = weiRaised >= cap;
778     return super.hasEnded() || capReached;
779   }
780 
781 }
782 
783 
784 contract MainCrowdsale is Consts, FinalizableCrowdsale {
785     function hasStarted() public constant returns (bool) {
786         return now >= startTime;
787     }
788 
789     function finalization() internal {
790         super.finalization();
791 
792         if (PAUSED) {
793             MainToken(token).unpause();
794         }
795 
796         if (!CONTINUE_MINTING) {
797             token.finishMinting();
798         }
799 
800         token.transferOwnership(TARGET_USER);
801     }
802 
803     function buyTokens(address beneficiary) public payable {
804         require(beneficiary != address(0));
805         require(validPurchase());
806 
807         uint256 weiAmount = msg.value;
808 
809         // calculate token amount to be created
810         uint256 tokens = weiAmount.mul(rate).div(1 ether);
811 
812         // update state
813         weiRaised = weiRaised.add(weiAmount);
814 
815         token.mint(beneficiary, tokens);
816         emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
817 
818         forwardFunds();
819     }
820 }
821 
822 
823 contract BonusableCrowdsale is Consts, Crowdsale {
824 
825     function buyTokens(address beneficiary) public payable {
826         require(beneficiary != address(0));
827         require(validPurchase());
828 
829         uint256 weiAmount = msg.value;
830 
831         // calculate token amount to be created
832         uint256 bonusRate = getBonusRate(weiAmount);
833         uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);
834 
835         // update state
836         weiRaised = weiRaised.add(weiAmount);
837 
838         token.mint(beneficiary, tokens);
839         emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
840 
841         forwardFunds();
842     }
843 
844     function getBonusRate(uint256 weiAmount) internal view returns (uint256) {
845         uint256 bonusRate = rate;
846 
847         
848         // apply bonus for time & weiRaised
849         uint[5] memory weiRaisedStartsBoundaries = [uint(0),uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000)];
850         uint[5] memory weiRaisedEndsBoundaries = [uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000),uint(33333333333333333333333)];
851         uint64[5] memory timeStartsBoundaries = [uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600)];
852         uint64[5] memory timeEndsBoundaries = [uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395)];
853         uint[5] memory weiRaisedAndTimeRates = [uint(300),uint(200),uint(150),uint(100),uint(50)];
854 
855         for (uint i = 0; i < 5; i++) {
856             bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);
857             bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);
858             if (weiRaisedInBound && timeInBound) {
859                 bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;
860             }
861         }
862         
863 
864         
865 
866         return bonusRate;
867     }
868 }
869 
870 
871 
872 contract WhitelistedCrowdsale is Crowdsale, Ownable {
873     mapping (address => bool) private whitelist;
874 
875     event WhitelistedAddressAdded(address indexed _address);
876     event WhitelistedAddressRemoved(address indexed _address);
877 
878     /**
879      * @dev throws if buyer is not whitelisted.
880      * @param _buyer address
881      */
882     modifier onlyIfWhitelisted(address _buyer) {
883         require(whitelist[_buyer]);
884         _;
885     }
886 
887     /**
888      * @dev getter to determine if address is in whitelist
889      */
890     function isWhitelisted(address _address) public view returns (bool) {
891         return whitelist[_address];
892     }
893 
894     /**
895      * @dev override purchase validation to add extra value logic.
896      * @return true if sender is whitelisted
897      */
898     function validPurchase() internal view onlyIfWhitelisted(msg.sender) returns (bool) {
899         return super.validPurchase();
900     }
901 
902     /**
903      * @dev add single address to whitelist
904      */
905     function addAddressToWhitelist(address _address) external onlyOwner {
906         whitelist[_address] = true;
907         emit WhitelistedAddressAdded(_address);
908     }
909 
910     /**
911      * @dev add addresses to whitelist
912      */
913     function addAddressesToWhitelist(address[] _addresses) external onlyOwner {
914         for (uint i = 0; i < _addresses.length; i++) {
915             whitelist[_addresses[i]] = true;
916             emit WhitelistedAddressAdded(_addresses[i]);
917         }
918     }
919 
920     /**
921      * @dev remove single address from whitelist
922      */
923     function removeAddressFromWhitelist(address _address) external onlyOwner {
924         delete whitelist[_address];
925         emit WhitelistedAddressRemoved(_address);
926     }
927 
928     /**
929      * @dev remove addresses from whitelist
930      */
931     function removeAddressesFromWhitelist(address[] _addresses) external onlyOwner {
932         for (uint i = 0; i < _addresses.length; i++) {
933             delete whitelist[_addresses[i]];
934             emit WhitelistedAddressRemoved(_addresses[i]);
935         }
936     }
937 }
938 
939 
940 contract TemplateCrowdsale is Consts, MainCrowdsale
941     
942     , BonusableCrowdsale
943     
944     
945     , CappedCrowdsale
946     
947     
948     , WhitelistedCrowdsale
949     
950 {
951     event Initialized();
952     event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);
953     bool public initialized = false;
954 
955     function TemplateCrowdsale(MintableToken _token) public
956         Crowdsale(START_TIME > now ? START_TIME : now, 1543640400, 1200 * TOKEN_DECIMAL_MULTIPLIER, 0x8BcC12F71e4C0C5f73C0dF9afbB3ed1de66DdD79)
957         CappedCrowdsale(50000000000000000000000)
958         
959     {
960         token = _token;
961     }
962 
963     function init() public onlyOwner {
964         require(!initialized);
965         initialized = true;
966 
967         if (PAUSED) {
968             MainToken(token).pause();
969         }
970 
971         
972         address[3] memory addresses = [address(0xbbc01d55a41a9eadd12027fe8088ed84768c3f0d),address(0x6cfd2db944e2b28a61a4f3f2cfb1973f0758cc3b),address(0x221be49cd399b8aaf0ade2485d6535e10518700d)];
973         uint[3] memory amounts = [uint(12500000000000000000000000),uint(7500000000000000000000000),uint(20000000000000000000000000)];
974         uint64[3] memory freezes = [uint64(0),uint64(0),uint64(1561953604)];
975 
976         for (uint i = 0; i < addresses.length; i++) {
977             if (freezes[i] == 0) {
978                 MainToken(token).mint(addresses[i], amounts[i]);
979             } else {
980                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
981             }
982         }
983         
984 
985         transferOwnership(TARGET_USER);
986 
987         emit Initialized();
988     }
989 
990     /**
991      * @dev override token creation to set token address in constructor.
992      */
993     function createTokenContract() internal returns (MintableToken) {
994         return MintableToken(0);
995     }
996 
997     
998 
999     
1000     /**
1001      * @dev override purchase validation to add extra value logic.
1002      * @return true if sended more than minimal value
1003      */
1004     function validPurchase() internal view returns (bool) {
1005         
1006         bool minValue = msg.value >= 100000000000000000;
1007         
1008         
1009         bool maxValue = msg.value <= 1000000000000000000000;
1010         
1011 
1012         return
1013         
1014             minValue &&
1015         
1016         
1017             maxValue &&
1018         
1019             super.validPurchase();
1020     }
1021     
1022 
1023     
1024     /**
1025      * @dev override hasEnded to add minimal value logic
1026      * @return true if remained to achieve less than minimal
1027      */
1028     function hasEnded() public view returns (bool) {
1029         bool remainValue = cap.sub(weiRaised) < 100000000000000000;
1030         return super.hasEnded() || remainValue;
1031     }
1032     
1033 
1034     
1035 
1036     
1037     function setEndTime(uint _endTime) public onlyOwner {
1038         // only if CS was not ended
1039         require(now < endTime);
1040         // only if new end time in future
1041         require(now < _endTime);
1042         require(_endTime > startTime);
1043         emit TimesChanged(startTime, _endTime, startTime, endTime);
1044         endTime = _endTime;
1045     }
1046     
1047 
1048     
1049 
1050 }