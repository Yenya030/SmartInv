1 {{
2   "language": "Solidity",
3   "sources": {
4     "MeGods.sol": {
5       "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\nabstract contract Context {\r\nfunction _msgSender() internal view virtual returns (address) {\r\nreturn msg.sender;\r\n}\r\n\r\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\nthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\nreturn msg.data;\r\n}\r\n}\r\n\r\ninterface IERC20 {\r\nfunction totalSupply() external view returns (uint256);\r\n\r\nfunction balanceOf(address account) external view returns (uint256);\r\n\r\nfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\nfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\nfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\nfunction transferFrom(\r\naddress sender,\r\naddress recipient,\r\nuint256 amount\r\n) external returns (bool);\r\n\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n/**\r\n* @dev Returns the name of the token.\r\n*/\r\nfunction name() external view returns (string memory);\r\n\r\n/**\r\n* @dev Returns the symbol of the token.\r\n*/\r\nfunction symbol() external view returns (string memory);\r\n\r\n/**\r\n* @dev Returns the decimals places of the token.\r\n*/\r\nfunction decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\nmapping(address => uint256) internal _balances;\r\n\r\nmapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\nuint256 private _totalSupply;\r\n\r\nstring private _name;\r\nstring private _symbol;\r\n\r\n/**\r\n* @dev Sets the values for {name} and {symbol}.\r\n*\r\n* The defaut value of {decimals} is 18. To select a different value for\r\n* {decimals} you should overload it.\r\n*\r\n* All two of these values are immutable: they can only be set once during\r\n* construction.\r\n*/\r\nconstructor(string memory name_, string memory symbol_) {\r\n_name = name_;\r\n_symbol = symbol_;\r\n}\r\n\r\n/**\r\n* @dev Returns the name of the token.\r\n*/\r\nfunction name() public view virtual override returns (string memory) {\r\nreturn _name;\r\n}\r\n\r\n/**\r\n* @dev Returns the symbol of the token, usually a shorter version of the\r\n* name.\r\n*/\r\nfunction symbol() public view virtual override returns (string memory) {\r\nreturn _symbol;\r\n}\r\n\r\n/**\r\n* @dev Returns the number of decimals used to get its user representation.\r\n* For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n* be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n*\r\n* Tokens usually opt for a value of 18, imitating the relationship between\r\n* Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n* overridden;\r\n*\r\n* NOTE: This information is only used for _display_ purposes: it in\r\n* no way affects any of the arithmetic of the contract, including\r\n* {IERC20-balanceOf} and {IERC20-transfer}.\r\n*/\r\nfunction decimals() public view virtual override returns (uint8) {\r\nreturn 18;\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-totalSupply}.\r\n*/\r\nfunction totalSupply() public view virtual override returns (uint256) {\r\nreturn _totalSupply;\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-balanceOf}.\r\n*/\r\nfunction balanceOf(address account) public view virtual override returns (uint256) {\r\nreturn _balances[account];\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-transfer}.\r\n*\r\n* Requirements:\r\n*\r\n* - `recipient` cannot be the zero address.\r\n* - the caller must have a balance of at least `amount`.\r\n*/\r\nfunction transfer(address recipient, uint256 amount)\r\npublic\r\nvirtual\r\noverride\r\nreturns (bool)\r\n{\r\n_transfer(_msgSender(), recipient, amount);\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-allowance}.\r\n*/\r\nfunction allowance(address owner, address spender)\r\npublic\r\nview\r\nvirtual\r\noverride\r\nreturns (uint256)\r\n{\r\nreturn _allowances[owner][spender];\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-approve}.\r\n*\r\n* Requirements:\r\n*\r\n* - `spender` cannot be the zero address.\r\n*/\r\nfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n_approve(_msgSender(), spender, amount);\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev See {IERC20-transferFrom}.\r\n*\r\n* Emits an {Approval} event indicating the updated allowance. This is not\r\n* required by the EIP. See the note at the beginning of {ERC20}.\r\n*\r\n* Requirements:\r\n*\r\n* - `sender` and `recipient` cannot be the zero address.\r\n* - `sender` must have a balance of at least `amount`.\r\n* - the caller must have allowance for ``sender``'s tokens of at least\r\n* `amount`.\r\n*/\r\nfunction transferFrom(\r\naddress sender,\r\naddress recipient,\r\nuint256 amount\r\n) public virtual override returns (bool) {\r\n_transfer(sender, recipient, amount);\r\n\r\nuint256 currentAllowance = _allowances[sender][_msgSender()];\r\nrequire(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n_approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Atomically increases the allowance granted to `spender` by the caller.\r\n*\r\n* This is an alternative to {approve} that can be used as a mitigation for\r\n* problems described in {IERC20-approve}.\r\n*\r\n* Emits an {Approval} event indicating the updated allowance.\r\n*\r\n* Requirements:\r\n*\r\n* - `spender` cannot be the zero address.\r\n*/\r\nfunction increaseAllowance(address spender, uint256 addedValue)\r\npublic\r\nvirtual\r\nreturns (bool)\r\n{\r\n_approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n*\r\n* This is an alternative to {approve} that can be used as a mitigation for\r\n* problems described in {IERC20-approve}.\r\n*\r\n* Emits an {Approval} event indicating the updated allowance.\r\n*\r\n* Requirements:\r\n*\r\n* - `spender` cannot be the zero address.\r\n* - `spender` must have allowance for the caller of at least\r\n* `subtractedValue`.\r\n*/\r\nfunction decreaseAllowance(address spender, uint256 subtractedValue)\r\npublic\r\nvirtual\r\nreturns (bool)\r\n{\r\nuint256 currentAllowance = _allowances[_msgSender()][spender];\r\nrequire(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n_approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\nreturn true;\r\n}\r\n\r\n/**\r\n* @dev Moves tokens `amount` from `sender` to `recipient`.\r\n*\r\n* This is internal function is equivalent to {transfer}, and can be used to\r\n* e.g. implement automatic token fees, slashing mechanisms, etc.\r\n*\r\n* Emits a {Transfer} event.\r\n*\r\n* Requirements:\r\n*\r\n* - `sender` cannot be the zero address.\r\n* - `recipient` cannot be the zero address.\r\n* - `sender` must have a balance of at least `amount`.\r\n*/\r\nfunction _transfer(\r\naddress sender,\r\naddress recipient,\r\nuint256 amount\r\n) internal virtual {\r\nrequire(sender != address(0), \"ERC20: transfer from the zero address\");\r\nrequire(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n_beforeTokenTransfer(sender, recipient, amount);\r\n\r\nuint256 senderBalance = _balances[sender];\r\nrequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n_balances[sender] = senderBalance - amount;\r\n_balances[recipient] += amount;\r\n\r\nemit Transfer(sender, recipient, amount);\r\n}\r\n\r\n/** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n* the total supply.\r\n*\r\n* Emits a {Transfer} event with `from` set to the zero address.\r\n*\r\n* Requirements:\r\n*\r\n* - `to` cannot be the zero address.\r\n*/\r\nfunction _tokengeneration(address account, uint256 amount) internal virtual {\r\nrequire(account != address(0), \"ERC20: generation to the zero address\");\r\n\r\n_beforeTokenTransfer(address(0), account, amount);\r\n\r\n_totalSupply = amount;\r\n_balances[account] = amount;\r\nemit Transfer(address(0), account, amount);\r\n}\r\n\r\n/**\r\n* @dev Destroys `amount` tokens from `account`, reducing the\r\n* total supply.\r\n*\r\n* Emits a {Transfer} event with `to` set to the zero address.\r\n*\r\n* Requirements:\r\n*\r\n* - `account` cannot be the zero address.\r\n* - `account` must have at least `amount` tokens.\r\n*/\r\nfunction _burn(address account, uint256 amount) internal virtual {\r\nrequire(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n_beforeTokenTransfer(account, address(0), amount);\r\n\r\nuint256 accountBalance = _balances[account];\r\nrequire(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n_balances[account] = accountBalance - amount;\r\n_totalSupply -= amount;\r\n\r\nemit Transfer(account, address(0), amount);\r\n}\r\n\r\n/**\r\n* @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n*\r\n* This internal function is equivalent to `approve`, and can be used to\r\n* e.g. set automatic allowances for certain subsystems, etc.\r\n*\r\n* Emits an {Approval} event.\r\n*\r\n* Requirements:\r\n*\r\n* - `owner` cannot be the zero address.\r\n* - `spender` cannot be the zero address.\r\n*/\r\nfunction _approve(\r\naddress owner,\r\naddress spender,\r\nuint256 amount\r\n) internal virtual {\r\nrequire(owner != address(0), \"ERC20: approve from the zero address\");\r\nrequire(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n_allowances[owner][spender] = amount;\r\nemit Approval(owner, spender, amount);\r\n}\r\n\r\n/**\r\n* @dev Hook that is called before any transfer of tokens. This includes\r\n* generation and burning.\r\n*\r\n* Calling conditions:\r\n*\r\n* - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n* will be to transferred to `to`.\r\n* - when `from` is zero, `amount` tokens will be generated for `to`.\r\n* - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n* - `from` and `to` are never both zero.\r\n*\r\n* To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n*/\r\nfunction _beforeTokenTransfer(\r\naddress from,\r\naddress to,\r\nuint256 amount\r\n) internal virtual {}\r\n}\r\n\r\nlibrary Address {\r\nfunction sendValue(address payable recipient, uint256 amount) internal {\r\nrequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n(bool success, ) = recipient.call{ value: amount }(\"\");\r\nrequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n}\r\n}\r\n\r\nabstract contract Ownable is Context {\r\naddress private _owner;\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\nconstructor() {\r\n_setOwner(_msgSender());\r\n}\r\n\r\nfunction owner() public view virtual returns (address) {\r\nreturn _owner;\r\n}\r\n\r\nmodifier onlyOwner() {\r\nrequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n_;\r\n}\r\n\r\nfunction renounceOwnership() public virtual onlyOwner {\r\n_setOwner(address(0));\r\n}\r\n\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n_setOwner(newOwner);\r\n}\r\n\r\nfunction _setOwner(address newOwner) private {\r\naddress oldOwner = _owner;\r\n_owner = newOwner;\r\nemit OwnershipTransferred(oldOwner, newOwner);\r\n}\r\n}\r\n\r\ninterface IFactory {\r\nfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IRouter {\r\nfunction factory() external pure returns (address);\r\n\r\nfunction WETH() external pure returns (address);\r\n\r\nfunction addLiquidityETH(\r\naddress token,\r\nuint256 amountTokenDesired,\r\nuint256 amountTokenMin,\r\nuint256 amountETHMin,\r\naddress to,\r\nuint256 deadline\r\n)\r\nexternal\r\npayable\r\nreturns (\r\nuint256 amountToken,\r\nuint256 amountETH,\r\nuint256 liquidity\r\n);\r\n\r\nfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\nuint256 amountIn,\r\nuint256 amountOutMin,\r\naddress[] calldata path,\r\naddress to,\r\nuint256 deadline\r\n) external;\r\n}\r\n\r\ncontract MeGods is ERC20, Ownable {\r\nusing Address for address payable;\r\n\r\nIRouter public router;\r\naddress public pair;\r\n\r\nbool private _liquidityMutex = false;\r\nbool public providingLiquidity = false;\r\nbool public tradingEnabled = false;\r\n\r\nuint256 public tokenLiquidityThreshold = 500e6 * 10**18; //500,000,000,000\r\n\r\nuint256 public genesis_block;\r\nuint256 private deadline = 0;\r\nuint256 private launchtax = 0; //0\r\n\r\naddress public marketingWallet = 0x4686DdaC37978464b7814610106C03Fa10f91aC9;\r\naddress private devWallet = 0x6F4757F99AC1ebF02214f6890ba291Dd475aB585;\r\naddress public constant deadWallet = 0x000000000000000000000000000000000000dEaD;\r\n\r\n// Main Taxes - 0x4686DdaC37978464b7814610106C03Fa10f91aC9 - 1.75% buy / 2.75% sell\r\n// Secondary tax - 0x6F4757F99AC1ebF02214f6890ba291Dd475aB585 - 0.25% Buy / 0.25% sell\r\n\r\nstruct Taxes {\r\nuint256 marketing;\r\nuint256 nativeTax;\r\nuint256 dev;\r\nuint256 liquidity;\r\nuint256 denominator;\r\n}\r\n\r\nTaxes private buytaxes = Taxes(175, 0, 25, 0, 100); //same happening here 100 denominator an buy tax is 1%\r\nTaxes private sellTaxes = Taxes(175, 0, 25, 0, 100); //100 is denominator and total tax is 1%. on buy and sell\r\n\r\nuint256 public TotalBuyFee = (buytaxes.marketing + buytaxes.nativeTax + buytaxes.dev + buytaxes.liquidity)/buytaxes.denominator;\r\nuint256 public TotalSellFee = (sellTaxes.marketing + sellTaxes.nativeTax + sellTaxes.dev + sellTaxes.liquidity)/sellTaxes.denominator;\r\n\r\nmapping(address => bool) public exemptFee;\r\n\r\nmodifier mutexLock() {\r\nif (!_liquidityMutex) {\r\n_liquidityMutex = true;\r\n_;\r\n_liquidityMutex = false;\r\n}\r\n}\r\n\r\nconstructor() ERC20(\"MeGods\", \"MeGods\") {\r\n_tokengeneration(msg.sender, 500e9 * 10**decimals());\r\n\r\nIRouter _router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Testnet router 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D UNISWAP V2 ||| // testnet router v 2\r\n\r\n// UNISWAP MAINNNET 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n\r\naddress _pair = IFactory(_router.factory()).createPair(address(this), _router.WETH());\r\n\r\nrouter = _router;\r\npair = _pair;\r\nexemptFee[address(this)] = true;\r\nexemptFee[msg.sender] = true;\r\nexemptFee[marketingWallet] = true;\r\nexemptFee[devWallet] = true;\r\nexemptFee[deadWallet] = true;\r\n\r\n}\r\n\r\nfunction approve(address spender, uint256 amount) public override returns (bool) {\r\n_approve(_msgSender(), spender, amount);\r\nreturn true;\r\n}\r\n\r\nfunction transferFrom(\r\naddress sender,\r\naddress recipient,\r\nuint256 amount\r\n) public override returns (bool) {\r\n_transfer(sender, recipient, amount);\r\n\r\nuint256 currentAllowance = _allowances[sender][_msgSender()];\r\nrequire(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n_approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\nreturn true;\r\n}\r\n\r\nfunction increaseAllowance(address spender, uint256 addedValue)\r\npublic\r\noverride\r\nreturns (bool)\r\n{\r\n_approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\nreturn true;\r\n}\r\n\r\nfunction decreaseAllowance(address spender, uint256 subtractedValue)\r\npublic\r\noverride\r\nreturns (bool)\r\n{\r\nuint256 currentAllowance = _allowances[_msgSender()][spender];\r\nrequire(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n_approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\nreturn true;\r\n}\r\n\r\nfunction transfer(address recipient, uint256 amount) public override returns (bool) {\r\n_transfer(msg.sender, recipient, amount);\r\nreturn true;\r\n}\r\n\r\nfunction _transfer(\r\naddress sender,\r\naddress recipient,\r\nuint256 amount\r\n) internal override {\r\nrequire(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\nif (!exemptFee[sender] && !exemptFee[recipient]) {\r\nrequire(tradingEnabled, \"Trading not enabled\");\r\n}\r\n\r\nuint256 feeswap;\r\nuint256 feesum;\r\nuint256 fee;\r\nuint256 _taxDenominator = sellTaxes.denominator;\r\nTaxes memory currentTaxes;\r\n\r\nbool useLaunchFee = !exemptFee[sender] &&\r\n!exemptFee[recipient] &&\r\nblock.number < genesis_block + deadline;\r\n\r\n//set fee to zero if fees in contract are handled or exempted\r\nif (_liquidityMutex || exemptFee[sender] || exemptFee[recipient])\r\nfee = 0;\r\n\r\n//calculate fee\r\nelse if (recipient == pair && !useLaunchFee) {\r\nfeeswap = sellTaxes.marketing + sellTaxes.dev + sellTaxes.liquidity;\r\nfeesum = feeswap + sellTaxes.nativeTax;\r\ncurrentTaxes = sellTaxes;\r\n_taxDenominator = sellTaxes.denominator;\r\n} else if (!useLaunchFee) {\r\nfeeswap = buytaxes.marketing + buytaxes.dev + buytaxes.liquidity;\r\nfeesum = feeswap + buytaxes.nativeTax;\r\ncurrentTaxes = buytaxes;\r\n_taxDenominator = buytaxes.denominator;\r\n} else if (useLaunchFee) {\r\nfeeswap = launchtax;\r\nfeesum = launchtax;\r\n}\r\n\r\nfee = ((amount * feesum) / 100)/_taxDenominator;\r\n\r\n//send fees if threshold has been reached\r\n//don't do this on buys, breaks swap\r\nif (providingLiquidity && sender != pair) handle_fees(feeswap, currentTaxes);\r\n\r\n//rest to recipient\r\nsuper._transfer(sender, recipient, amount - fee);\r\nif (fee > 0) {\r\n//send the fee to the contract\r\nif (feeswap > 0) {\r\nuint256 feeAmount = ((amount * feeswap) / 100)/_taxDenominator;\r\nsuper._transfer(sender, address(this), feeAmount);\r\n}\r\n\r\nif (currentTaxes.nativeTax > 0) {\r\nuint256 nativeTaxAmount = ((currentTaxes.nativeTax * amount) / 100)/_taxDenominator;\r\n_balances[marketingWallet] += nativeTaxAmount;\r\nemit Transfer(sender, marketingWallet, nativeTaxAmount);\r\n}\r\n\r\n}\r\n}\r\n\r\nfunction handle_fees(uint256 feeswap, Taxes memory swapTaxes) private mutexLock {\r\n\r\nif(feeswap == 0){\r\nreturn;\r\n}\r\n\r\nuint256 contractBalance = balanceOf(address(this));\r\nif (contractBalance >= tokenLiquidityThreshold) {\r\nif (tokenLiquidityThreshold > 1) {\r\ncontractBalance = tokenLiquidityThreshold;\r\n}\r\n\r\n// Split the contract balance into halves\r\nuint256 denominator = feeswap * 2;\r\nuint256 tokensToAddLiquidityWith = (contractBalance * swapTaxes.liquidity) /\r\ndenominator;\r\nuint256 toSwap = contractBalance - tokensToAddLiquidityWith;\r\n\r\nuint256 initialBalance = address(this).balance;\r\n\r\nswapTokensForETH(toSwap);\r\n\r\nuint256 deltaBalance = address(this).balance - initialBalance;\r\nuint256 unitBalance = deltaBalance / ((denominator - swapTaxes.liquidity)/swapTaxes.denominator);\r\nuint256 bnbToAddLiquidityWith = (unitBalance * swapTaxes.liquidity)/swapTaxes.denominator;\r\n\r\nif (bnbToAddLiquidityWith > 0) {\r\naddLiquidity(tokensToAddLiquidityWith, bnbToAddLiquidityWith);\r\n}\r\n\r\nuint256 marketingAmt = (unitBalance * 2 * swapTaxes.marketing)/swapTaxes.denominator;\r\nif (marketingAmt > 0) {\r\npayable(marketingWallet).sendValue(marketingAmt);\r\n}\r\nuint256 devAmt = (unitBalance * 2 * swapTaxes.dev)/swapTaxes.denominator;\r\nif (devAmt > 0) {\r\npayable(devWallet).sendValue(devAmt);\r\n}\r\n\r\n}\r\n}\r\n\r\nfunction swapTokensForETH(uint256 tokenAmount) private {\r\naddress[] memory path = new address[](2);\r\npath[0] = address(this);\r\npath[1] = router.WETH();\r\n\r\n_approve(address(this), address(router), tokenAmount);\r\n\r\nrouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\ntokenAmount,\r\n0,\r\npath,\r\naddress(this),\r\nblock.timestamp\r\n);\r\n}\r\n\r\nfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n_approve(address(this), address(router), tokenAmount);\r\n\r\nrouter.addLiquidityETH{ value: ethAmount }(\r\naddress(this),\r\ntokenAmount,\r\n0, // slippage is unavoidable\r\n0, // slippage is unavoidable\r\ndeadWallet,\r\nblock.timestamp\r\n);\r\n}\r\n\r\nfunction updateLiquidityProvide(bool state) external onlyOwner{\r\nprovidingLiquidity = state;\r\n}\r\n\r\nfunction updateLiquidityTreshhold(uint256 new_amount) external onlyOwner {\r\ntokenLiquidityThreshold = new_amount * 10**decimals();\r\n}\r\n\r\nfunction enableTrading() external onlyOwner {\r\nrequire(!tradingEnabled, \"Trading is already enabled\");\r\ntradingEnabled = true;\r\nprovidingLiquidity = true;\r\ngenesis_block = block.number;\r\n}\r\n\r\nfunction updatedeadline(uint256 _deadline) external onlyOwner {\r\nrequire (_deadline < 3,\"Deadline should be less than 3\");\r\ndeadline = _deadline;\r\n}\r\n\r\nfunction updateMarketingWallet(address _newWallet) external onlyOwner {\r\nmarketingWallet = _newWallet;\r\n}\r\n\r\nfunction updateDevWallet(address _newWallet) external onlyOwner {\r\ndevWallet = _newWallet;\r\n}\r\n\r\nfunction updateExemptFee(address _address, bool state) external onlyOwner {\r\nexemptFee[_address] = state;\r\n}\r\n\r\nfunction bulkExemptFee(address[] memory accounts, bool state) external onlyOwner {\r\nfor (uint256 i = 0; i < accounts.length; i++) {\r\nexemptFee[accounts[i]] = state;\r\n}\r\n}\r\n\r\nfunction rescueETH() external {\r\nuint256 contractETHBalance = address(this).balance;\r\npayable(owner()).transfer(contractETHBalance);\r\n}\r\n\r\nfunction rescueBRC20(address tokenAdd, uint256 amount) external {\r\nrequire(tokenAdd != address(this), \"Owner can't claim contract's balance of its own tokens\");\r\nIERC20(tokenAdd).transfer(owner(), amount);\r\n}\r\n\r\n// fallbacks\r\nreceive() external payable {}\r\n}\r\n\r\n\r\n\r\n"
6     }
7   },
8   "settings": {
9     "optimizer": {
10       "enabled": false,
11       "runs": 200
12     },
13     "outputSelection": {
14       "*": {
15         "*": [
16           "evm.bytecode",
17           "evm.deployedBytecode",
18           "devdoc",
19           "userdoc",
20           "metadata",
21           "abi"
22         ]
23       }
24     }
25   }
26 }}