1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/AutoSniper.sol": {
5       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./helpers/SniperStructs.sol\";\nimport \"./helpers/IWETH.sol\";\nimport \"./helpers/IPunk.sol\";\nimport \"./helpers/SniperErrors.sol\";\nimport \"solmate/src/auth/Owned.sol\";\nimport \"openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/**\n * @title AutoSniper 3.0 for @oSnipeNFT\n * @author 0xQuit\n */\n\n/*\n\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*+=--::::::--=+*#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*=:.       ......        :=*%@@@@@@@@@%@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#=.    .-+*%@@@@@@@@@@@@%#+=:    -@@@@@@=:::=#@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@%+.   :=#@@@@@@@@@@@@@@@@@@@@@@@@#+#@@@@@%**+-:::-%@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@#-   :+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%******+-::=@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@%:   =%@@@@@@@@@@@@@@@@%%%%@@@@@@@@@@@@@@%*++++++***+=+@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@=   -@@@@@@@@@@@@#+-:.         :-+%@@@@@%*+++++++++*#@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@#.  :%@@@@@@@@@%+:      ..:::::.  .*@@@%*+++++++++++#@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@*   =@@@@@@@@@#:    .=*%@@@@@@@@@@%@@@%+----======+#@@@@@%@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@+   *@@@@@@@@#:   .+%@@@@@@@@@@@@@@@@@@=-------==+#@@@@@%- -@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@#   #@@@@@@@@=   .*@@@@@@@@@#=.    .-+#+=--------*@@@@@@@%   +@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@.  =@@@@@@@@-   =@@@@@@@@@@:  -+**+-   .--=----+%@@@@@@@@@#   %@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@+  .@@@@@@@@-   +@@@@@@@@@@-  #@@@@%+-:.  :=*@#%@@@*%@@@@@@@=  -@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@.  #@@@@@@@+   =@@@@@@@@@@@:  @@@%=-----.  #@@@@@*. -@@@@@@@@   %@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@#   @@@@@@@@.  .@@@@@@@@@@@@%  :#=:::::--*+=@@@@@@-   %@@@@@@@-  +@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@+  :@@@@@@@%   =@@@@@@@@@@@@@%-:--::::-*@@@@@@@@@@*   *@@@@@@@+  :@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@=  -@@@@@@@#   +@@@@@@@@@@@@@#-:---:-*@@@@@@@@@@@@#   +@@@@@@@+  :@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@+  -@@@@@@@%   =@@@@@@*#@@@#-::---=. -@@@@@@@@@@@@*   +@@@@@@@+  :@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@#  .@@@@@@@@   .@@@@@+  #*-:::--*@@#  -@@@@@@@@@@@-   %@@@@@@@-  =@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@   #@@@@@@@+  =@@@@@%  .--:--+@@@@@=  %@@@@@@@@@#   :@@@@@@@@   %@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@=  :@@@@@@@@=%@@@@@@*:   :-*@@@@@@%. .@@@@@@@@@%    %@@@@@@@=  :@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@   +@@@@@@@@@@@@#+---:.  .=*###*-  :%@@@@@@@@#   .%@@@@@@@#   #@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@*   %@@@@@@@@@#=------*%+-      .-#@@@@@@@@%=   .%@@@@@@@@.  =@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@= .*@@@@@@@@+------=%@@@@@@%%%@@@@@@@@@@#-    +@@@@@@@@@:  :@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@#@@@@@@@@*===---=#@@@@@@@@@@@@@@@@@%*-     +@@@@@@@@@#   -@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@*=====+#%@@@@@%= .:--==--:.     .-*@@@@@@@@@@+   +@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@+--==+#@@@@@@@@=:.           :=*%@@@@@@@@@@@*.  .#@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@*===+-*@@@@@@@@@@@@@@%%#####%@@@@@@@@@@@@@@@*.   +@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@#+==#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#=   .+@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@+==+%@@@@@@@@@%*%@@@@@@@@@@@@@@@@@@@@@@@@@*-    -*@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@#=%@@@@@@@@@+    -=*%@@@@@@@@@@@@@@%*+-.    :+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%+-.      ..:::::::.      .-+#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*+=-:........:-=+*#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n*/\n\ncontract AutoSniper is Owned {\n    event Deposit(\n        address sniper,\n        uint256 amount\n    );\n\n    event Withdrawal(\n        address sniper,\n        uint256 amount\n    );\n\n    string public constant name = \"oSnipe: AutoSniper V3\";\n\n    address private constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private fulfillerAddress = 0x7D79Bd0E4B3dC90665A3ed30Aa6C6c06c89D224E;\n    address public nextContractVersionAddress;\n    bool public migrationEnabled;\n    mapping(address => bool) public allowedMarketplaces;\n    mapping(address => uint256) public sniperBalances;\n    mapping(address => SniperGuardrails) public sniperGuardrails;\n\n    constructor() Owned(0x507c8252c764489Dc1150135CA7e41b01e10ee74) {}\n\n    /**\n    * @dev fulfillOrder conducts its own checks to ensure that the passed order is a valid sniper\n    * before forwarding the snipe on to the appropriate marketplace. Snipers can block orders by setting\n    * up guardrails that prevent orders from being fulfilled outside of allowlisted marketplaces or\n    * nft contracts, or with tips that exceed a maximum tip amount. WETH is used to subsidize\n    * the order in case the Sniper's deposited balance is too low. WETH must be approved in order for this to\n    * work. Calculation is done off-chain and passed in via wethAmount. If for some reason there is an overpay,\n    * the marketplace will refund the difference, which is added to the Sniper's balance.\n    * @param wethSubsidy the amount of WETH that needs to be converted.\n    * @param claims an array of claims that the sniped NFT is eligible for. Claims are claimed and\n    * transferred to the sniper along with the sniped NFT.\n    */\n    function fulfillOrder(SniperOrder calldata order, Claim[] calldata claims, uint256 wethSubsidy) external onlyFulfiller {\n        _checkGuardrails(order.tokenAddress, order.marketplace, order.autosniperTip, order.to);\n        uint256 totalValue = order.value + order.autosniperTip + order.validatorTip;\n        if (wethSubsidy > 0) _swapWeth(wethSubsidy, order.to);\n        if (sniperBalances[order.to] < totalValue) revert InsufficientBalance();\n\n        uint256 balanceBefore = address(this).balance;\n\n        (bool autosniperPaid, ) = payable(fulfillerAddress).call{value: order.autosniperTip}(\"\");\n        if (!autosniperPaid) revert FailedToPayAutosniper();\n        (bool orderFilled,) = order.marketplace.call{value: order.value}(order.data);\n        if (!orderFilled) revert OrderFailed();\n        (bool validatorPaid, ) = block.coinbase.call{value: order.validatorTip}(\"\");\n        if (!validatorPaid) revert FailedToPayValidator();\n\n        uint256 balanceAfter = address(this).balance;\n        uint256 spent = balanceBefore - balanceAfter;\n\n        unchecked { sniperBalances[order.to] -= spent; }\n\n        _claimAndTransferClaimableAssets(claims, order.to);\n        _transferNftToSniper(order.tokenType, order.tokenAddress, order.tokenId, address(this), order.to);\n    }\n\n    /**\n    * @dev fulfillNonCompliantMarketplaceOrder is a variant on fulfillOrder, used for markets that\n    * don't allow purchases through contracts. The fulfiller EOA will fulfill the order, and then use\n    * this function to get it to the sniper.\n    * @param wethSubsidy the amount of WETH that needs to be converted.\n    * @param claims an array of claims that the sniped NFT is eligible for. Claims are claimed and\n    * transferred to the sniper along with the sniped NFT.\n    */\n    function fulfillNonCompliantMarketplaceOrder(SniperOrder calldata order, Claim[] calldata claims, uint256 wethSubsidy) external onlyFulfiller {\n        _checkGuardrails(order.tokenAddress, order.marketplace, order.autosniperTip, order.to);\n        uint256 totalValue = order.value + order.autosniperTip + order.validatorTip;\n        if (wethSubsidy > 0) _swapWeth(wethSubsidy, order.to);\n        if (sniperBalances[order.to] < totalValue) revert InsufficientBalance();\n\n        uint256 balanceBefore = address(this).balance;\n\n        (bool autosniperPaid, ) = payable(fulfillerAddress).call{value: order.autosniperTip + order.value}(\"\");\n        if (!autosniperPaid) revert FailedToPayAutosniper();\n        (bool validatorPaid, ) = block.coinbase.call{value: order.validatorTip}(\"\");\n        if (!validatorPaid) revert FailedToPayValidator();\n\n        uint256 balanceAfter = address(this).balance;\n        uint256 spent = balanceBefore - balanceAfter;\n\n        unchecked { sniperBalances[order.to] -= spent; }\n\n        _claimAndTransferClaimableAssets(claims, order.to);\n        _transferNftToSniper(order.tokenType, order.tokenAddress, order.tokenId, fulfillerAddress, order.to);\n    }\n\n    /**\n    * @dev solSnatch is a pure arbitrage function for fulfilling an order, and accepting a WETH offer in the same transaction.\n    * Contract balance can be used, but user balances cannot be affected - the call will revert if the post-call contract\n    * balance is lower than the pre-call balance.\n    * @param contractAddresses a list of contract addresses that will be called\n    * @param calls a matching array to contractAddresses, each index being a call to make to a given contract\n    * @param validatorTip the amount to send to block.coinbase. Reverts if this is 0.\n    */\n    function solSnatch(address[] calldata contractAddresses, bytes[] calldata calls, uint256[] calldata values, address sniper, uint256 validatorTip, uint256 fulfillerTip) external onlyFulfiller {\n        if (contractAddresses.length != calls.length) revert ArrayLengthMismatch();\n        if (calls.length != values.length) revert ArrayLengthMismatch();\n        uint256 balanceBefore = address(this).balance;\n\n        for (uint256 i = 0; i < contractAddresses.length;) {\n            (bool success, ) = contractAddresses[i].call{value: values[i]}(calls[i]);\n            if (!success) revert OrderFailed();\n\n            unchecked { ++i; }\n        }\n\n        (bool validatorPaid, ) = block.coinbase.call{value: validatorTip}(\"\");\n        if (!validatorPaid) revert FailedToPayValidator();\n        (bool fulfillerPaid, ) = fulfillerAddress.call{value: fulfillerTip}(\"\");\n        if (!fulfillerPaid) revert FailedToPayAutosniper();\n\n        uint256 balanceAfter = address(this).balance;\n\n        if (balanceAfter <= balanceBefore) revert NoMoneyMoProblems();\n        unchecked { sniperBalances[sniper] += balanceAfter - balanceBefore; }\n\n        emit Deposit(sniper, balanceAfter - balanceBefore);\n    }\n\n    /**\n    * @dev In cases where we execute a snipe without using this contract, use this function as a solution to\n    * bypass priority fee by tipping the coinbase directly.\n    */\n    function sendDirectTipToCoinbase() external payable onlyFulfiller {\n        (bool validatorPaid, ) = block.coinbase.call{value: msg.value}(\"\");\n        if (!validatorPaid) revert FailedToPayValidator();\n    }\n\n    /**\n    * @dev deposit Ether into the contract. \n    * @param sniper is the address who's balance is affected.\n    */\n    function deposit(address sniper) public payable {\n        if (tx.origin == fulfillerAddress) revert FulfillerCannotHaveBalance();\n        unchecked { sniperBalances[sniper] += msg.value; }\n\n        emit Deposit(sniper, msg.value);\n    }\n\n    /**\n    * @dev deposit Ether into your own contract balance.\n    */\n    function depositSelf() external payable {\n        deposit(msg.sender);\n    }\n\n    /**\n    * @dev withdraw Ether from your contract balance\n    * @param amount the amount of Ether to be withdrawn \n    */\n    function withdraw(uint256 amount) external {\n        if (tx.origin == fulfillerAddress) revert FulfillerCannotHaveBalance();\n        if (sniperBalances[msg.sender] < amount) revert InsufficientBalance();\n        unchecked { sniperBalances[msg.sender] -= amount; }\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        if (!success) revert FailedToWithdraw();\n\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    /**\n    * @dev set up a marketplace allowlist.\n    * @param guardEnabled if false then marketplace allowlist will not be checked for this user\n    * @param marketplaceAllowed boolean indicating whether the marketplace is allowed or not\n    */\n    function setUserAllowedMarketplaces(bool guardEnabled, bool marketplaceAllowed, address[] calldata marketplaces) external {\n        sniperGuardrails[msg.sender].marketplaceGuardEnabled = guardEnabled;\n        for (uint256 i = 0; i < marketplaces.length;) {\n            sniperGuardrails[msg.sender].allowedMarketplaces[marketplaces[i]] = marketplaceAllowed;\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n    * @dev Set up a maximum tip guardrail (in wei). If set to 0, guardrail will be disabled.\n    */\n    function setUserMaxTip(uint72 maxTipInWei) external {\n        sniperGuardrails[msg.sender].maxTip = maxTipInWei;\n    }\n\n    /**\n    * @dev set up NFT contract allowlist\n    * @param guardEnabled if false then NFT contract allowlist will not be checked for this user\n    * @param nftAllowed boolean indicating whether the NFT contract is allowed or not\n    */\n    function setUserAllowedNfts(bool guardEnabled, bool nftAllowed, address[] calldata nfts) external {\n        sniperGuardrails[msg.sender].nftContractGuardEnabled = guardEnabled;\n        for (uint256 i = 0; i < nfts.length;) {\n            sniperGuardrails[msg.sender].allowedNftContracts[nfts[i]] = nftAllowed;\n            unchecked { ++i; }\n        }\n    }\n\n    function setUserIsPaused(bool isPaused) external {\n        sniperGuardrails[msg.sender].isPaused = isPaused;\n    }\n\n    /**\n    * @dev Owner function to set up global marketplace allowlist.\n    */\n    function configureMarkets(address[] calldata marketplaces, bool status) external onlyOwner {\n        for (uint256 i = 0; i < marketplaces.length;) {\n            allowedMarketplaces[marketplaces[i]] = status;\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n    * @dev Owner function to change fulfiller address if needed.\n    */\n    function setFulfillerAddress(address _fulfiller) external onlyOwner {\n        fulfillerAddress = _fulfiller;\n    }\n\n    /**\n    * Enables migration and sets a destination address (the new contract)\n    * @param _destination the new AutoSniper version to allow migration to.\n    */\n    function setMigrationAddress(address _destination) external onlyOwner {\n        migrationEnabled = true;\n        nextContractVersionAddress = _destination;\n    }\n\n    // getters to simplify web3js calls\n    function marketplaceApprovedBySniper(address sniper, address marketplace) external view returns (bool) {\n        return sniperGuardrails[sniper].allowedMarketplaces[marketplace];\n    }\n\n    function nftContractApprovedBySniper(address sniper, address nftContract) external view returns (bool) {\n        return sniperGuardrails[sniper].allowedNftContracts[nftContract];\n    }\n\n    /**\n    * @dev in the event of a future contract upgrade, this function allows snipers to\n    * easily move their ether balance to the new contract. This can only be called by\n    * the sniper to move their personal balance - the contract owner or anybody else\n    * does not have the power to migrate balances for users.\n    */\n    function migrateBalance() external {\n        if (!migrationEnabled) revert MigrationNotEnabled();\n        uint256 balanceToMigrate = sniperBalances[msg.sender];\n        sniperBalances[msg.sender] = 0;\n\n        (bool success, ) = nextContractVersionAddress.call{value: balanceToMigrate}(abi.encodeWithSelector(this.deposit.selector, msg.sender));\n        if (!success) revert FailedToWithdraw();\n    }\n\n    // internal helpers\n    function _swapWeth(uint256 wethAmount, address sniper) private {\n        IWETH weth = IWETH(WETH_ADDRESS);\n        weth.transferFrom(sniper, address(this), wethAmount);\n        weth.withdraw(wethAmount);\n\n        unchecked { sniperBalances[sniper] += wethAmount; }\n    }\n\n    function _transferNftToSniper(ItemType tokenType, address tokenAddress, uint256 tokenId, address source, address sniper) private {\n        if (tokenType == ItemType.ERC721) {\n            IERC721(tokenAddress).transferFrom(source, sniper, tokenId);\n        } else if (tokenType == ItemType.ERC1155) {\n            IERC1155(tokenAddress).safeTransferFrom(source, sniper, tokenId, 1, \"\");\n        } else if (tokenType == ItemType.CRYPTOPUNKS) {\n            IPunk(tokenAddress).transferPunk(sniper, tokenId);\n        } else if (tokenType == ItemType.ERC20) {\n            IERC20 token = IERC20(tokenAddress);\n            token.transfer(sniper, token.balanceOf(source));\n        }\n    }\n\n    function _claimAndTransferClaimableAssets(Claim[] calldata claims, address sniper) private {\n        for (uint256 i = 0; i < claims.length; i++) {\n            Claim memory claim = claims[i];\n\n            (bool claimSuccess, ) = claim.tokenAddress.call(claim.claimData);\n            if (!claimSuccess) revert ClaimFailed();\n\n            _transferNftToSniper(claim.tokenType, claim.tokenAddress, claim.tokenId, address(this), sniper);\n        }\n    }\n\n    function _checkGuardrails(address tokenAddress, address marketplace, uint256 tip, address sniper) private view {\n        SniperGuardrails storage guardrails = sniperGuardrails[sniper];\n\n        if (guardrails.isPaused) revert SniperIsPaused();\n        if (!allowedMarketplaces[marketplace]) revert MarketplaceNotAllowed();\n        if (guardrails.maxTip > 0 && tip > guardrails.maxTip) revert MaxTipExceeded();\n        if (guardrails.marketplaceGuardEnabled && !guardrails.allowedMarketplaces[marketplace]) revert MarketplaceNotAllowed();\n        if (guardrails.nftContractGuardEnabled && !guardrails.allowedNftContracts[tokenAddress]) revert TokenContractNotAllowed();\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    // Used by ERC721BasicToken.sol\n    function onERC721Received(\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return 0xf0b9e5ba;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        external\n        virtual\n        view\n        returns (bool)\n    {\n        return interfaceId == this.supportsInterface.selector;\n    }\n\n    receive() external payable {}\n\n    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC20(address asset, address recipient) onlyOwner external {\n        IERC20 token = IERC20(asset);\n        token.transfer(recipient, token.balanceOf(address(this)));\n    }\n\n    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC721(address asset, uint256[] calldata ids, address recipient) onlyOwner external {\n        for (uint256 i = 0; i < ids.length; i++) {\n            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\n        }\n    }\n\n    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC1155(address asset, uint256[] calldata ids, uint256[] calldata amounts, address recipient) onlyOwner external {\n        for (uint256 i = 0; i < ids.length; i++) {\n            IERC1155(asset).safeTransferFrom(address(this), recipient, ids[i], amounts[i], \"\");\n        }\n    }\n\n    modifier onlyFulfiller() {\n        if (msg.sender != fulfillerAddress) revert CallerNotFulfiller();\n        _;\n    }\n}\n"
6     },
7     "src/helpers/SniperStructs.sol": {
8       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.18;\n\nimport \"./SniperEnums.sol\";\n\nstruct SniperOrder {\n    ItemType tokenType;\n    uint72 value;\n    uint72 autosniperTip;\n    uint72 validatorTip;\n    address to;\n    address marketplace;\n    address tokenAddress;\n    uint256 tokenId;\n    bytes data;\n}\n\nstruct Claim {\n    ItemType tokenType;\n    address tokenAddress;\n    uint256 tokenId;\n    bytes claimData;\n}\n\nstruct SniperGuardrails {\n    bool marketplaceGuardEnabled;\n    bool nftContractGuardEnabled;\n    bool isPaused;\n    uint72 maxTip;\n    mapping(address => bool) allowedMarketplaces;\n    mapping(address => bool) allowedNftContracts;\n}"
9     },
10     "src/helpers/IWETH.sol": {
11       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.18;\n\ninterface IWETH {\n  function transferFrom(address src, address dst, uint wad) external;\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n  function balanceOf(address user) external view returns (uint256);\n  function approve(address guy, uint wad) external returns (bool);\n}"
12     },
13     "src/helpers/IPunk.sol": {
14       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.18;\n\ninterface IPunk {\n  function transferPunk(address to, uint punkIndex) external;\n}"
15     },
16     "src/helpers/SniperErrors.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nerror InsufficientBalance();\nerror FailedToWithdraw();\nerror FailedToPayAutosniper();\nerror FailedToPayValidator();\nerror MaxTipExceeded();\nerror MarketplaceNotAllowed();\nerror TokenContractNotAllowed();\nerror OrderFailed();\nerror CallerNotFulfiller();\nerror ClaimFailed();\nerror MigrationNotEnabled();\nerror ArrayLengthMismatch();\nerror NoMoneyMoProblems();\nerror SniperIsPaused();\nerror FulfillerCannotHaveBalance();"
18     },
19     "lib/solmate/src/auth/Owned.sol": {
20       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
21     },
22     "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
23       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
24     },
25     "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
27     },
28     "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
29       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
30     },
31     "src/helpers/SniperEnums.sol": {
32       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.18;\n\n// from Seaport\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA,\n\n    // 6: CryptoPunks\n    CRYPTOPUNKS\n}"
33     },
34     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
35       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
36     }
37   },
38   "settings": {
39     "remappings": [
40       "ERC721A/=lib/ERC721A/",
41       "ds-test/=lib/forge-std/lib/ds-test/src/",
42       "forge-std/=lib/forge-std/src/",
43       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
44       "openzeppelin/=lib/openzeppelin-contracts/",
45       "solmate/=lib/solmate/"
46     ],
47     "optimizer": {
48       "enabled": true,
49       "runs": 200
50     },
51     "metadata": {
52       "bytecodeHash": "ipfs",
53       "appendCBOR": true
54     },
55     "outputSelection": {
56       "*": {
57         "*": [
58           "evm.bytecode",
59           "evm.deployedBytecode",
60           "devdoc",
61           "userdoc",
62           "metadata",
63           "abi"
64         ]
65       }
66     },
67     "evmVersion": "paris",
68     "libraries": {}
69   }
70 }}