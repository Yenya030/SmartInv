1 pragma solidity ^0.4.18;
2 
3 
4 contract Trigonometry {
5 
6     // Table index into the trigonometric table
7     uint constant INDEX_WIDTH = 4;
8     // Interpolation between successive entries in the tables
9     uint constant INTERP_WIDTH = 8;
10     uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;
11     uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
12     uint16 constant ANGLES_IN_CYCLE = 16384;
13     uint16 constant QUADRANT_HIGH_MASK = 8192;
14     uint16 constant QUADRANT_LOW_MASK = 4096;
15     uint constant SINE_TABLE_SIZE = 16;
16 
17     // constant sine lookup table generated by gen_tables.py
18     // We have no other choice but this since constant arrays don't yet exist
19     uint8 constant entry_bytes = 2;
20     bytes constant sin_table = "\x00\x00\x0c\x8c\x18\xf9\x25\x28\x30\xfb\x3c\x56\x47\x1c\x51\x33\x5a\x82\x62\xf1\x6a\x6d\x70\xe2\x76\x41\x7a\x7c\x7d\x89\x7f\x61\x7f\xff";
21 
22     /**
23      * Convenience function to apply a mask on an integer to extract a certain
24      * number of bits. Using exponents since solidity still does not support
25      * shifting.
26      *
27      * @param _value The integer whose bits we want to get
28      * @param _width The width of the bits (in bits) we want to extract
29      * @param _offset The offset of the bits (in bits) we want to extract
30      * @return An integer containing _width bits of _value starting at the
31      *         _offset bit
32      */
33     function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {
34         return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);
35     }
36 
37     function sin_table_lookup(uint index) pure internal returns (uint16) {
38         bytes memory table = sin_table;
39         uint offset = (index + 1) * entry_bytes;
40         uint16 trigint_value;
41         assembly {
42             trigint_value := mload(add(table, offset))
43         }
44 
45         return trigint_value;
46     }
47 
48     /**
49      * Return the sine of an integer approximated angle as a signed 16-bit
50      * integer.
51      *
52      * @param _angle A 14-bit angle. This divides the circle into 16384
53      *               angle units, instead of the standard 360 degrees.
54      * @return The sine result as a number in the range -32767 to 32767.
55      */
56     function sin(uint16 _angle) public pure returns (int) {
57         uint interp = bits(_angle, INTERP_WIDTH, INTERP_OFFSET);
58         uint index = bits(_angle, INDEX_WIDTH, INDEX_OFFSET);
59 
60         bool is_odd_quadrant = (_angle & QUADRANT_LOW_MASK) == 0;
61         bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;
62 
63         if (!is_odd_quadrant) {
64             index = SINE_TABLE_SIZE - 1 - index;
65         }
66 
67         uint x1 = sin_table_lookup(index);
68         uint x2 = sin_table_lookup(index + 1);
69         uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);
70 
71         int sine;
72         if (is_odd_quadrant) {
73             sine = int(x1) + int(approximation);
74         } else {
75             sine = int(x2) - int(approximation);
76         }
77 
78         if (is_negative_quadrant) {
79             sine *= -1;
80         }
81 
82         return sine;
83     }
84 
85     /**
86      * Return the cos of an integer approximated angle.
87      * It functions just like the sin() method but uses the trigonometric
88      * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
89      */
90     function cos(uint16 _angle) public pure returns (int) {
91         if (_angle > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {
92             _angle = QUADRANT_LOW_MASK - ANGLES_IN_CYCLE - _angle;
93         } else {
94             _angle += QUADRANT_LOW_MASK;
95         }
96         return sin(_angle);
97     }
98 
99 }
100 
101 library SafeMath {
102 
103   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
104     if (a == 0) {
105       return 0;
106     }
107     uint256 c = a * b;
108     assert(c / a == b);
109     return c;
110   }
111 
112   function div(uint256 a, uint256 b) internal pure returns (uint256) {
113     // assert(b > 0); // Solidity automatically throws when dividing by 0
114     uint256 c = a / b;
115     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
116     return c;
117   }
118 
119   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
120     assert(b <= a);
121     return a - b;
122   }
123 
124   function add(uint256 a, uint256 b) internal pure returns (uint256) {
125     uint256 c = a + b;
126     assert(c >= a);
127     return c;
128   }
129 
130 }
131 
132 contract Ownable {
133 
134   address public owner;
135 
136   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
137 
138   function Ownable() public {
139     owner = msg.sender;
140   }
141 
142   modifier onlyOwner() {
143     require(msg.sender == owner);
144     _;
145   }
146 
147   function transferOwnership(address newOwner) public onlyOwner {
148     require(newOwner != address(0));
149     OwnershipTransferred(owner, newOwner);
150     owner = newOwner;
151   }
152 
153 }
154 
155 
156 contract VirusGame is Ownable, Trigonometry {
157 
158     using SafeMath for uint256;
159 
160     /**
161     * Structs
162     */
163 
164     struct Virus {
165         bytes32 name;
166         bytes32 parent;
167         uint256 potential;
168         uint256 infected;
169         uint256 infectedPayed;
170         uint256 infectedTriggle;
171         uint256 lastWithdraw;
172         uint256 lastInfected;
173         uint256 generation;
174         address owner;
175     }
176 
177     /**
178     * State
179     */
180 
181     uint256 nonce;
182 
183     mapping (address => bytes32[]) public virusOwner;
184 
185     mapping (bytes32 => Virus) public virus;
186 
187     bytes32[] public virusHashes;
188 
189     uint256 public totalPopulation;
190 
191     uint256 public totalInfected;
192 
193     bytes32 public genesisVirus;
194 
195     uint256 public totalBalance;
196 
197     uint256 public totalPayed;
198 
199     /**
200     * Modifier
201     */
202 
203     modifier useNonce() {
204         _;
205         nonce = nonce.add(1);
206     }
207 
208     modifier healthyPeople() {
209         require(totalPopulation > totalInfected);
210         _;
211     }
212 
213     /**
214     * Functions
215     */
216 
217     event LogMutation(
218         bytes32 parentHash,
219         bytes32 virusHash
220     );
221 
222     function mutate(bytes32 _virus, bytes32 _name) payable healthyPeople useNonce public {
223         // ensure parent virus exists
224         require(virus[_virus].owner != address(0));
225 
226         uint costs = virus[_virus].generation.mul(0.001 ether).add(0.01 ether);
227         require(msg.value >= costs);
228 
229         bytes32 newHash = keccak256(_virus, _name, nonce, msg.sender, now);
230 
231         // new potential from virus hash to uint -> sinus or cosinus
232         int mutationFactor = sin(uint16(newHash));
233         uint uintFactor;
234         uint newPotential;
235 
236         if (mutationFactor >= 0) {
237             uintFactor = uint(mutationFactor);
238             newPotential = virus[_virus].potential.mul(
239                 uintFactor.mul(20).div(32767).add(100)
240             ).div(100);
241         } else {
242             uintFactor = uint(-mutationFactor);
243             newPotential = virus[_virus].potential.mul(
244                 uintFactor.mul(20).div(32767).add(80)
245             ).div(100);
246         }
247 
248         virus[newHash].name = _name;
249         virus[newHash].parent = _virus;
250         virus[newHash].generation = virus[_virus].generation.add(1);
251         virus[newHash].potential = newPotential;
252         virus[newHash].lastInfected = now;
253         virus[newHash].lastWithdraw = now;
254         virus[newHash].owner = msg.sender;
255 
256         virusHashes.push(newHash);
257         virusOwner[msg.sender].push(newHash);
258 
259         totalBalance = totalBalance.add(
260             costs.mul(9).div(10)
261         );
262 
263         LogMutation(
264             _virus,
265             newHash
266         );
267     }
268 
269     event LogInfection(
270         uint infected,
271         bytes32 virusHash
272     );
273 
274     event LogEndOfWorld();
275 
276     function infect(bytes32 _virus) healthyPeople public {
277         require(virus[_virus].owner == msg.sender);
278 
279         // infectedTriggle + potential * delay = infected
280         uint delay = now.sub(virus[_virus].lastInfected);
281 
282         uint infected = virus[_virus].infectedTriggle.add(
283             virus[_virus].potential.mul(delay).div(1 days)
284         );
285         
286         // infectedTriggle from parent must be set to x% of infected
287         virus[virus[_virus].parent].infectedTriggle = virus[virus[_virus].parent].infectedTriggle.add(
288             infected.div(10)
289         );
290 
291         totalInfected = totalInfected.add(infected);
292         virus[_virus].infected = virus[_virus].infected.add(infected);
293 
294         virus[_virus].lastInfected = now;
295         virus[_virus].infectedTriggle = 0;
296 
297         LogInfection(
298             infected,
299             _virus
300         );
301 
302         if (totalPopulation < totalInfected) {
303             totalInfected = totalPopulation;
304             LogEndOfWorld();
305         }
306     }
307 
308     function withdraw(bytes32 _virus) public {
309         require(virus[_virus].owner == msg.sender);
310 
311         // only withdraw once a day
312         require(now > (virus[_virus].lastWithdraw + 1 days));
313 
314         // calculate ether
315         uint toBePayed = virus[_virus].infected.sub(virus[_virus].infectedPayed);
316         uint amount = totalBalance.div(totalInfected.sub(totalPayed)).mul(toBePayed);
317 
318         require(amount <= totalBalance);
319 
320         // subtract from total balance
321         totalBalance = totalBalance.sub(amount);
322         totalPayed = totalPayed.add(toBePayed);
323 
324         // send ether
325         msg.sender.transfer(amount);
326 
327         virus[_virus].infectedPayed = virus[_virus].infected;
328         virus[_virus].lastWithdraw = now;
329     }
330 
331     function withdrawExcess(address _withdraw) onlyOwner public {
332         _withdraw.transfer(this.balance.sub(totalBalance));
333     }
334 
335     /**
336     * Getters
337     */
338 
339     function getVirusLength() public view returns(uint) {
340         return virusHashes.length;
341     }
342 
343     function getOwnerVirusLength(address _owner) public view returns(uint) {
344         return virusOwner[_owner].length;
345     }
346 
347     /**
348     * Constructor
349     */
350 
351     function VirusGame() public {
352         totalPopulation = 7000000000;
353 
354         genesisVirus = keccak256("Genesis");
355 
356         virus[genesisVirus].name = "Genesis";
357         virus[genesisVirus].potential = 100;
358         virus[genesisVirus].owner = msg.sender;
359         virus[genesisVirus].lastInfected = now;
360 
361         virusOwner[msg.sender].push(genesisVirus);
362         virusHashes.push(genesisVirus);
363     }
364 
365 }