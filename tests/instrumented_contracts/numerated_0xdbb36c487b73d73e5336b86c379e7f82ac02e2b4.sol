1 /**
2  *Submitted for verification at Etherscan.io on 2021-06-15
3 */
4 
5 //Khloe Koin ($KHLOE)
6 //@Khloe envisioned
7 //Powerful Bot Protect yes
8 
9 //Deflationary yes
10 //1% of total supply will be airdropped to ZachInu holders
11 //Telegram: https://t.me/khloekoinofficial
12 
13 //CG, CMC listing: Ongoing
14 //Fair Launch
15 
16 /*
17                          ▗▖▄▄▖▖▖                            
18                   ▄▄▚▙▚▌█▙▜▞▄▌▙▀▞▌▖                         
19                ▗▐▜▄▙▌▛▙█▙▛▛█▟▟▐▐▜▞▞▜▄                       
20               ▗▚▜▐▐▗▜▛█▟▚█▛▛▟██▟▐▞▛▄▝▀▄                     
21              ▝▞▞▌▌▙▜▛▛▙▜▜▐▐▐▐▖▛▛▙▚▌▌▛▚▐▐▖▖                  
22             ▐▐▐▚▚▘▞▙▜▜▐▚▚▚▝▞▖▌▌▛▙▚▚▙▚▚▚▚▚▙▚                 
23            ▗▚▚▚▜▐▝▌▙▚▙▚▚▘▗▘▞▗▝▝▞▞▀▙▙█▟▚▙▚▞▙▚                
24            ▌▌▚▀▞▖▚▚▙▜▐▐ ▌▘▞▗▗▘▌▟▟▜▚▚▙██▟▜▛▛█▖               
25       ▖▘ ▝▐▝▞▖▌▞▐▐▐▐▞▚▚▚▞▞▄▗▘▐▟▜▞█▜█▞█▟▛▙▛█▙▜               
26         ▗▞▌▛▟▐▝▚▚▜▚▙▜▜▀▜▜▛▙▚▝▖▙▜█▜▛▌▌▛▙███▟▞▛▄▗  ▘  ▗ ▘  ▗  
27        ▗▙▜▟▜▐▐▚▜▜▚█▟▜▟█▙▛▜▞▜▚▞▞▖▞▝▞▗▘▙▜█▙█▙▙▜▄▗▚▚           
28        ▙▛▙▙▜▞▙▜▚█▜▙▚▛▛▛▙▜▀▐▝▞▄▚▚▐▝▗▘▚▚▛▙▚▙▜▚▙▞▖▘▌▙          
29      ▘▗▜▜▟▞▙█▟█▜█▜▟▚▚▘▚▝▖▞▗▐▐▞▖▜▖▘▚▐▐▚█▛▛▞▜▐▐▟▐▚▘▖▖         
30       ▞▟█▟██▞▛▟█▜█▟▜▚▜▗▚▗▝▖▘▌█▟▚▀▚▚▚▀▙▚█▜▞▚▚▜▝▙▚▌▖▘         
31         ▙▛▟▞▞▟█▟█▙▛█▜▚▌▌▌▚▖▌▞▞▝▞▐▐▗▚▜▐▜██▟▗▚▚▛▞▟▝           
32      ▗ ▖▙▜▖▙▚▜▟█▟▙█▛▛█▟▚▜▐▗▚▚▞▙▜▙▛▙▚▚▜▚▙▙█▞▟▜▞▞▞▚▚          
33      ▖▞▞▞▌▛▌█▜▙▙▙▛▙▀▛▙▙▜▚▛▞▞▟▜▜▝▞▟▞▞▞▛█▙▛▟▟▞▙▜▐▞▛▄▘▞  ▖ ▘   
34    ▗▛▞▐▐▐▐▝▞▞▙▙▙█▟▛███▟▜▚▜▞▙▚▜▚▛▀▞▐▐▜▟▙▛▛▙█▞▞▞▞▟▜▞▖▞▖▘      
35    ▙▛▞▙▜▜▚▜▐▐▞▟▙▙▛█▜▜▜██▛▙▜▞▞▌▌▖▚▗▚▚█▚▚▙▜▜▐▐▞▞▐▟▙▄▄▐▖▖      
36    ▟▌▛▞▛▟▜▟▜▞▟▚▙▚▛▛███▙▜▜██▜▛█▟▜▙█▟▛▛▛▜▚▌▞▚▖▌▞▚▚▌▚▐▚▘       
37     ▚▜▐▜▚█▜▜▜▐▗▝▌▛▛▙▛▙█▜▞▄▚▛█▜▜▛▙█▞▌▛▄▜▐▐▜▚▚▚▀▙▜▞▌▚▘▘       
38      ▜▞▞▜▟▚▞▜▟▐▚▚▀▀▌▛▌█▜▞▞▞▞▞▞▌▌▙▐▝▞▞▙▚▌▌▌▌▌▛▐▗▌▌▖          
39     ▘▝▞▛▟▐▚▚▚▚▛▌▜▀▛▜▙▙▜▜▟▐▐▐▐▐▐▐▐▐▞▜▗▜▙▌▌▌▌▞▄▐▝             
40     ▖▝▚▛▙▜▚▌▞▛▞▟▜▟▟▄▚▜▜▛▟▐▙▜▐▐▞▜▐▝▌▌▌▌▛▙▙▚▚▛▞▄▙████████▙▄▖  
41       ▝▞ ▞▌▚▜▀▌▚▙▚▙▜▛▛█▟▌▌▞▞▞▟▐▐▐▐▐▚▘▌▀▌█▟█▟▜▟█▟▙█▜██▜▟█▜█▙ 
42        ▐ ▀▗▞▖▛▞▐▐▜▞▙▛█▐▞▟▞▖▚▐▐▚▚▚▝▟▚▚▝▜▞▄▚▚██▛█▜█▜█▙███▜█▙█▖
43         ▝▝ ▄▟▛▞▙▛▙▛█▛█▚▙▚▌▞▞▖▚▛▖▚▝▄▜▐▐▚▐▚▀▜▜▟███▜█▛█▜█▟█▛█▜█
44       ▖ ▄▄▟█▟██▛▛▙█▙███▐▌▛▞▖▌▌▙▀▞▞▖▛▖▚▐▚▀▛▞▟█▛▙██▛███▜█▜████
45    ▗▄▄▟████▜█▜▛███▜█▜█▞▌▚▚▀▗▘▞▞▛▖▚▐▞▌▌▟▄▜▗▚▚████▜██▙██▜█▙█▟█
46   ▗█████▙█▜██████▟███▛█▞▞▌▙▘▌▚▜▐▚▘▚▐▄▚▚▟▞▞▞▙▜█▟██▜▟█▙███▜▛██
47   ▞█▜█▜▟█▜██▙█▛█▙█▛▙███▛▙▜▞▜▐▐▝▛▙▜▐▐▐▞▙▚▚▜▐▞▙█▜▟███▙█▛█▟████
48   █████████▙█▛███████▜▛█▞▟▐▜▐▌▌▛▟▙▘▌▌▙▚▜▚▙▙▜▟▟██▙█▙█▛███▜▙██
49  ▟█▜▟█▟█▟█▙████▙█▟█▛████▛▟▀▛▟▐▚▚▚▚▜▝▐▞▛▞▌▙▞▙▚▜▜▙█▛█▛██▙███▙█
50 ▗████▛█▛█▙██▙█▛███▜██▜█▟█▙▛█▐▟▚▙▚▜▞▌▚▚▜▞▟▚▜▞▛▙▜██████▛█▜█▟██
51 ▟█▟█▙██████▙████▙███▟██▛█▙▛▟▜▞▜▞▙▚▚▀▞▙▜▜▞▛▌▙▚▞▜█▟▙█▟▛███▛█▟█
52 █▛█▙███▜█▟▛██▟█▟██▜▟██▙███▟▞▌▛▌▙▛▙▜▚▜▟▜▐▞▙▀▞▞▐▐▛█▛████▜▟████
53 █████▜▟█████▜█▜█▜▟███▙██▛██▞▞▞▞▙▜▞▛▟▚▙▛▟▞▞▞▞▞▞▐████▙████▛▙██
54 █▜▙█▟████▟█▜████████▜█▛▙██▙█▞▞▞▞▞▟▟▀▙▞▜▚▜▞▞▞▖▞▖█▙█▙██▙█▛████
55 ████████▜█▜██▙█▛██▜▟██████▜█▙▚▐▝▞▞▞▛▙▀▙▜▞▞▞▞▝▖▟██▛██▙████▛▙█
56 ██▜▛█▛█▟████▙████▜███▙██▜▟██▜▄▘▞▐▐▐▜▟▛▞▙▜▞▞▞▞▗▐█▙██▙██▛▙████
57 ███████████▜█▛▙█████▜█▛███████▖▞▖▚▚▚▚▙▛▞▙▜▐▝▖▘█████▜█▛███▛██
58 █▙██▙███▜▙▌ ▝███▟█▜▟██████▜▟█▛█▗▝▞▞▛▟▗▀▜▞▛▙▚▚▜█▙█▙██████▙███
59 ██▛▙███▟██   ▝██▜█████▟█▟███████▐▐▐▞▞▞▞▛▌▌▌▛▟▟█▜████▙██▜█▜██
60 █▙████▜██▛    ▝▜█▛██▜▟███▛█▛▙██▜▙▌▙▚▚▝▞▞▞▖▚▐▐████▙█▙█████▛▜█
61 █████████       ███████▙█████████▙▘ ▘▘▘▝ ▘▘▘██▟█▙████▙█▙█▌▝█
62 */
63 
64 
65 
66 // SPDX-License-Identifier: Unlicensed
67 pragma solidity ^0.8.4;
68 
69 abstract contract Context {
70     function _msgSender() internal view virtual returns (address) {
71         return msg.sender;
72     }
73 }
74 
75 interface IERC20 {
76     function totalSupply() external view returns (uint256);
77 
78     function balanceOf(address account) external view returns (uint256);
79 
80     function transfer(address recipient, uint256 amount)
81         external
82         returns (bool);
83 
84     function allowance(address owner, address spender)
85         external
86         view
87         returns (uint256);
88 
89     function approve(address spender, uint256 amount) external returns (bool);
90 
91     function transferFrom(
92         address sender,
93         address recipient,
94         uint256 amount
95     ) external returns (bool);
96 
97     event Transfer(address indexed from, address indexed to, uint256 value);
98     event Approval(
99         address indexed owner,
100         address indexed spender,
101         uint256 value
102     );
103 }
104 
105 library SafeMath {
106     function add(uint256 a, uint256 b) internal pure returns (uint256) {
107         uint256 c = a + b;
108         require(c >= a, "SafeMath: addition overflow");
109         return c;
110     }
111 
112     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
113         return sub(a, b, "SafeMath: subtraction overflow");
114     }
115 
116     function sub(
117         uint256 a,
118         uint256 b,
119         string memory errorMessage
120     ) internal pure returns (uint256) {
121         require(b <= a, errorMessage);
122         uint256 c = a - b;
123         return c;
124     }
125 
126     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
127         if (a == 0) {
128             return 0;
129         }
130         uint256 c = a * b;
131         require(c / a == b, "SafeMath: multiplication overflow");
132         return c;
133     }
134 
135     function div(uint256 a, uint256 b) internal pure returns (uint256) {
136         return div(a, b, "SafeMath: division by zero");
137     }
138 
139     function div(
140         uint256 a,
141         uint256 b,
142         string memory errorMessage
143     ) internal pure returns (uint256) {
144         require(b > 0, errorMessage);
145         uint256 c = a / b;
146         return c;
147     }
148 }
149 
150 contract Ownable is Context {
151     address private _owner;
152     address private _previousOwner;
153     event OwnershipTransferred(
154         address indexed previousOwner,
155         address indexed newOwner
156     );
157 
158     constructor() {
159         address msgSender = _msgSender();
160         _owner = msgSender;
161         emit OwnershipTransferred(address(0), msgSender);
162     }
163 
164     function owner() public view returns (address) {
165         return _owner;
166     }
167 
168     modifier onlyOwner() {
169         require(_owner == _msgSender(), "Ownable: caller is not the owner");
170         _;
171     }
172 
173     function renounceOwnership() public virtual onlyOwner {
174         emit OwnershipTransferred(_owner, address(0));
175         _owner = address(0);
176     }
177 }
178 
179 interface IUniswapV2Factory {
180     function createPair(address tokenA, address tokenB)
181         external
182         returns (address pair);
183 }
184 
185 interface IUniswapV2Router02 {
186     function swapExactTokensForETHSupportingFeeOnTransferTokens(
187         uint256 amountIn,
188         uint256 amountOutMin,
189         address[] calldata path,
190         address to,
191         uint256 deadline
192     ) external;
193 
194     function factory() external pure returns (address);
195 
196     function WETH() external pure returns (address);
197 
198     function addLiquidityETH(
199         address token,
200         uint256 amountTokenDesired,
201         uint256 amountTokenMin,
202         uint256 amountETHMin,
203         address to,
204         uint256 deadline
205     )
206         external
207         payable
208         returns (
209             uint256 amountToken,
210             uint256 amountETH,
211             uint256 liquidity
212         );
213 }
214 
215 contract KhloeKoin is Context, IERC20, Ownable {
216     using SafeMath for uint256;
217 
218     string private constant _name = "Khloe Koin";
219     string private constant _symbol = "KHLOE \xF0\x9F\x94\xA5";
220     uint8 private constant _decimals = 9;
221 
222     // RFI
223     mapping(address => uint256) private _rOwned;
224     mapping(address => uint256) private _tOwned;
225     mapping(address => mapping(address => uint256)) private _allowances;
226     mapping(address => bool) private _isExcludedFromFee;
227     uint256 private constant MAX = ~uint256(0);
228     uint256 private constant _tTotal = 1000000000000 * 10**9;
229     uint256 private _rTotal = (MAX - (MAX % _tTotal));
230     uint256 private _tFeeTotal;
231     uint256 private _taxFee = 5;
232     uint256 private _teamFee = 10;
233 
234     // Bot detection
235     mapping(address => bool) private bots;
236     mapping(address => uint256) private cooldown;
237     address payable private _teamAddress;
238     address payable private _marketingFunds;
239     IUniswapV2Router02 private uniswapV2Router;
240     address private uniswapV2Pair;
241     bool private tradingOpen;
242     bool private inSwap = false;
243     bool private swapEnabled = false;
244     bool private cooldownEnabled = false;
245     uint256 private _maxTxAmount = _tTotal;
246 
247     event MaxTxAmountUpdated(uint256 _maxTxAmount);
248     modifier lockTheSwap {
249         inSwap = true;
250         _;
251         inSwap = false;
252     }
253 
254     constructor(address payable addr1, address payable addr2) {
255         _teamAddress = addr1;
256         _marketingFunds = addr2;
257         _rOwned[_msgSender()] = _rTotal;
258         _isExcludedFromFee[owner()] = true;
259         _isExcludedFromFee[address(this)] = true;
260         _isExcludedFromFee[_teamAddress] = true;
261         _isExcludedFromFee[_marketingFunds] = true;
262         emit Transfer(address(0), _msgSender(), _tTotal);
263     }
264 
265     function name() public pure returns (string memory) {
266         return _name;
267     }
268 
269     function symbol() public pure returns (string memory) {
270         return _symbol;
271     }
272 
273     function decimals() public pure returns (uint8) {
274         return _decimals;
275     }
276 
277     function totalSupply() public pure override returns (uint256) {
278         return _tTotal;
279     }
280 
281     function balanceOf(address account) public view override returns (uint256) {
282         return tokenFromReflection(_rOwned[account]);
283     }
284 
285     function transfer(address recipient, uint256 amount)
286         public
287         override
288         returns (bool)
289     {
290         _transfer(_msgSender(), recipient, amount);
291         return true;
292     }
293 
294     function allowance(address owner, address spender)
295         public
296         view
297         override
298         returns (uint256)
299     {
300         return _allowances[owner][spender];
301     }
302 
303     function approve(address spender, uint256 amount)
304         public
305         override
306         returns (bool)
307     {
308         _approve(_msgSender(), spender, amount);
309         return true;
310     }
311 
312     function transferFrom(
313         address sender,
314         address recipient,
315         uint256 amount
316     ) public override returns (bool) {
317         _transfer(sender, recipient, amount);
318         _approve(
319             sender,
320             _msgSender(),
321             _allowances[sender][_msgSender()].sub(
322                 amount,
323                 "ERC20: transfer amount exceeds allowance"
324             )
325         );
326         return true;
327     }
328 
329     function setCooldownEnabled(bool onoff) external onlyOwner() {
330         cooldownEnabled = onoff;
331     }
332 
333     function tokenFromReflection(uint256 rAmount)
334         private
335         view
336         returns (uint256)
337     {
338         require(
339             rAmount <= _rTotal,
340             "Amount must be less than total reflections"
341         );
342         uint256 currentRate = _getRate();
343         return rAmount.div(currentRate);
344     }
345 
346     function removeAllFee() private {
347         if (_taxFee == 0 && _teamFee == 0) return;
348         _taxFee = 0;
349         _teamFee = 0;
350     }
351 
352     function restoreAllFee() private {
353         _taxFee = 5;
354         _teamFee = 10;
355     }
356 
357     function _approve(
358         address owner,
359         address spender,
360         uint256 amount
361     ) private {
362         require(owner != address(0), "ERC20: approve from the zero address");
363         require(spender != address(0), "ERC20: approve to the zero address");
364         _allowances[owner][spender] = amount;
365         emit Approval(owner, spender, amount);
366     }
367 
368     function _transfer(
369         address from,
370         address to,
371         uint256 amount
372     ) private {
373         require(from != address(0), "ERC20: transfer from the zero address");
374         require(to != address(0), "ERC20: transfer to the zero address");
375         require(amount > 0, "Transfer amount must be greater than zero");
376 
377         if (from != owner() && to != owner()) {
378             if (cooldownEnabled) {
379                 if (
380                     from != address(this) &&
381                     to != address(this) &&
382                     from != address(uniswapV2Router) &&
383                     to != address(uniswapV2Router)
384                 ) {
385                     require(
386                         _msgSender() == address(uniswapV2Router) ||
387                             _msgSender() == uniswapV2Pair,
388                         "ERR: Uniswap only"
389                     );
390                 }
391             }
392             require(amount <= _maxTxAmount);
393             require(!bots[from] && !bots[to]);
394             if (
395                 from == uniswapV2Pair &&
396                 to != address(uniswapV2Router) &&
397                 !_isExcludedFromFee[to] &&
398                 cooldownEnabled
399             ) {
400                 require(cooldown[to] < block.timestamp);
401                 cooldown[to] = block.timestamp + (60 seconds);
402             }
403             uint256 contractTokenBalance = balanceOf(address(this));
404             if (!inSwap && from != uniswapV2Pair && swapEnabled) {
405                 swapTokensForEth(contractTokenBalance);
406                 uint256 contractETHBalance = address(this).balance;
407                 if (contractETHBalance > 0) {
408                     sendETHToFee(address(this).balance);
409                 }
410             }
411         }
412         bool takeFee = true;
413 
414         if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {
415             takeFee = false;
416         }
417 
418         _tokenTransfer(from, to, amount, takeFee);
419     }
420 
421     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
422         address[] memory path = new address[](2);
423         path[0] = address(this);
424         path[1] = uniswapV2Router.WETH();
425         _approve(address(this), address(uniswapV2Router), tokenAmount);
426         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
427             tokenAmount,
428             0,
429             path,
430             address(this),
431             block.timestamp
432         );
433     }
434 
435     function sendETHToFee(uint256 amount) private {
436         _teamAddress.transfer(amount.div(2));
437         _marketingFunds.transfer(amount.div(2));
438     }
439 
440     function openTrading() external onlyOwner() {
441         require(!tradingOpen, "trading is already open");
442         IUniswapV2Router02 _uniswapV2Router =
443             IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
444         uniswapV2Router = _uniswapV2Router;
445         _approve(address(this), address(uniswapV2Router), _tTotal);
446         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
447             .createPair(address(this), _uniswapV2Router.WETH());
448         uniswapV2Router.addLiquidityETH{value: address(this).balance}(
449             address(this),
450             balanceOf(address(this)),
451             0,
452             0,
453             owner(),
454             block.timestamp
455         );
456         swapEnabled = true;
457         cooldownEnabled = true;
458         _maxTxAmount = 2500000000 * 10**9;
459         tradingOpen = true;
460         IERC20(uniswapV2Pair).approve(
461             address(uniswapV2Router),
462             type(uint256).max
463         );
464     }
465 
466     function manualswap() external {
467         require(_msgSender() == _teamAddress);
468         uint256 contractBalance = balanceOf(address(this));
469         swapTokensForEth(contractBalance);
470     }
471 
472     function manualsend() external {
473         require(_msgSender() == _teamAddress);
474         uint256 contractETHBalance = address(this).balance;
475         sendETHToFee(contractETHBalance);
476     }
477 
478     function setBots(address[] memory bots_) public onlyOwner {
479         for (uint256 i = 0; i < bots_.length; i++) {
480             bots[bots_[i]] = true;
481         }
482     }
483 
484     function delBot(address notbot) public onlyOwner {
485         bots[notbot] = false;
486     }
487 
488     function _tokenTransfer(
489         address sender,
490         address recipient,
491         uint256 amount,
492         bool takeFee
493     ) private {
494         if (!takeFee) removeAllFee();
495         _transferStandard(sender, recipient, amount);
496         if (!takeFee) restoreAllFee();
497     }
498 
499     function _transferStandard(
500         address sender,
501         address recipient,
502         uint256 tAmount
503     ) private {
504         (
505             uint256 rAmount,
506             uint256 rTransferAmount,
507             uint256 rFee,
508             uint256 tTransferAmount,
509             uint256 tFee,
510             uint256 tTeam
511         ) = _getValues(tAmount);
512         _rOwned[sender] = _rOwned[sender].sub(rAmount);
513         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
514         _takeTeam(tTeam);
515         _reflectFee(rFee, tFee);
516         emit Transfer(sender, recipient, tTransferAmount);
517     }
518 
519     function _takeTeam(uint256 tTeam) private {
520         uint256 currentRate = _getRate();
521         uint256 rTeam = tTeam.mul(currentRate);
522         _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
523     }
524 
525     function _reflectFee(uint256 rFee, uint256 tFee) private {
526         _rTotal = _rTotal.sub(rFee);
527         _tFeeTotal = _tFeeTotal.add(tFee);
528     }
529 
530     receive() external payable {}
531 
532     function _getValues(uint256 tAmount)
533         private
534         view
535         returns (
536             uint256,
537             uint256,
538             uint256,
539             uint256,
540             uint256,
541             uint256
542         )
543     {
544         (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =
545             _getTValues(tAmount, _taxFee, _teamFee);
546         uint256 currentRate = _getRate();
547         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =
548             _getRValues(tAmount, tFee, tTeam, currentRate);
549         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
550     }
551 
552     function _getTValues(
553         uint256 tAmount,
554         uint256 taxFee,
555         uint256 TeamFee
556     )
557         private
558         pure
559         returns (
560             uint256,
561             uint256,
562             uint256
563         )
564     {
565         uint256 tFee = tAmount.mul(taxFee).div(100);
566         uint256 tTeam = tAmount.mul(TeamFee).div(100);
567         uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
568         return (tTransferAmount, tFee, tTeam);
569     }
570 
571     function _getRValues(
572         uint256 tAmount,
573         uint256 tFee,
574         uint256 tTeam,
575         uint256 currentRate
576     )
577         private
578         pure
579         returns (
580             uint256,
581             uint256,
582             uint256
583         )
584     {
585         uint256 rAmount = tAmount.mul(currentRate);
586         uint256 rFee = tFee.mul(currentRate);
587         uint256 rTeam = tTeam.mul(currentRate);
588         uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
589         return (rAmount, rTransferAmount, rFee);
590     }
591 
592     function _getRate() private view returns (uint256) {
593         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
594         return rSupply.div(tSupply);
595     }
596 
597     function _getCurrentSupply() private view returns (uint256, uint256) {
598         uint256 rSupply = _rTotal;
599         uint256 tSupply = _tTotal;
600         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
601         return (rSupply, tSupply);
602     }
603 
604     function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {
605         require(maxTxPercent > 0, "Amount must be greater than 0");
606         _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);
607         emit MaxTxAmountUpdated(_maxTxAmount);
608     }
609 }