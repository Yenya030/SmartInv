1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 
20 pragma solidity ^0.4.20;
21 
22 
23 /**
24  * @title ERC20Basic
25  * @dev Simpler version of ERC20 interface
26  * @dev see https://github.com/ethereum/EIPs/issues/179
27  */
28 contract ERC20Basic {
29   uint256 public totalSupply;
30   function balanceOf(address who) public view returns (uint256);
31   function transfer(address to, uint256 value) public returns (bool);
32   event Transfer(address indexed from, address indexed to, uint256 value);
33 }
34 
35 
36 
37 /**
38  * @title SafeMath
39  * @dev Math operations with safety checks that throw on error
40  */
41 library SafeMath {
42   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
43     if (a == 0) {
44       return 0;
45     }
46     uint256 c = a * b;
47     assert(c / a == b);
48     return c;
49   }
50 
51   function div(uint256 a, uint256 b) internal pure returns (uint256) {
52     // assert(b > 0); // Solidity automatically throws when dividing by 0
53     uint256 c = a / b;
54     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
55     return c;
56   }
57 
58   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
59     assert(b <= a);
60     return a - b;
61   }
62 
63   function add(uint256 a, uint256 b) internal pure returns (uint256) {
64     uint256 c = a + b;
65     assert(c >= a);
66     return c;
67   }
68 }
69 
70 
71 
72 /**
73  * @title Basic token
74  * @dev Basic version of StandardToken, with no allowances.
75  */
76 contract BasicToken is ERC20Basic {
77   using SafeMath for uint256;
78 
79   mapping(address => uint256) balances;
80 
81   /**
82   * @dev transfer token for a specified address
83   * @param _to The address to transfer to.
84   * @param _value The amount to be transferred.
85   */
86   function transfer(address _to, uint256 _value) public returns (bool) {
87     require(_to != address(0));
88     require(_value <= balances[msg.sender]);
89 
90     // SafeMath.sub will throw if there is not enough balance.
91     balances[msg.sender] = balances[msg.sender].sub(_value);
92     balances[_to] = balances[_to].add(_value);
93     Transfer(msg.sender, _to, _value);
94     return true;
95   }
96 
97   /**
98   * @dev Gets the balance of the specified address.
99   * @param _owner The address to query the the balance of.
100   * @return An uint256 representing the amount owned by the passed address.
101   */
102   function balanceOf(address _owner) public view returns (uint256 balance) {
103     return balances[_owner];
104   }
105 
106 }
107 
108 
109 
110 /**
111  * @title ERC20 interface
112  * @dev see https://github.com/ethereum/EIPs/issues/20
113  */
114 contract ERC20 is ERC20Basic {
115   function allowance(address owner, address spender) public view returns (uint256);
116   function transferFrom(address from, address to, uint256 value) public returns (bool);
117   function approve(address spender, uint256 value) public returns (bool);
118   event Approval(address indexed owner, address indexed spender, uint256 value);
119 }
120 
121 
122 
123 /**
124  * @title Standard ERC20 token
125  *
126  * @dev Implementation of the basic standard token.
127  * @dev https://github.com/ethereum/EIPs/issues/20
128  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
129  */
130 contract StandardToken is ERC20, BasicToken {
131 
132   mapping (address => mapping (address => uint256)) internal allowed;
133 
134 
135   /**
136    * @dev Transfer tokens from one address to another
137    * @param _from address The address which you want to send tokens from
138    * @param _to address The address which you want to transfer to
139    * @param _value uint256 the amount of tokens to be transferred
140    */
141   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
142     require(_to != address(0));
143     require(_value <= balances[_from]);
144     require(_value <= allowed[_from][msg.sender]);
145 
146     balances[_from] = balances[_from].sub(_value);
147     balances[_to] = balances[_to].add(_value);
148     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
149     Transfer(_from, _to, _value);
150     return true;
151   }
152 
153   /**
154    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
155    *
156    * Beware that changing an allowance with this method brings the risk that someone may use both the old
157    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
158    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
159    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
160    * @param _spender The address which will spend the funds.
161    * @param _value The amount of tokens to be spent.
162    */
163   function approve(address _spender, uint256 _value) public returns (bool) {
164     allowed[msg.sender][_spender] = _value;
165     Approval(msg.sender, _spender, _value);
166     return true;
167   }
168 
169   /**
170    * @dev Function to check the amount of tokens that an owner allowed to a spender.
171    * @param _owner address The address which owns the funds.
172    * @param _spender address The address which will spend the funds.
173    * @return A uint256 specifying the amount of tokens still available for the spender.
174    */
175   function allowance(address _owner, address _spender) public view returns (uint256) {
176     return allowed[_owner][_spender];
177   }
178 
179   /**
180    * approve should be called when allowed[_spender] == 0. To increment
181    * allowed value is better to use this function to avoid 2 calls (and wait until
182    * the first transaction is mined)
183    * From MonolithDAO Token.sol
184    */
185   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
186     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
187     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
188     return true;
189   }
190 
191   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
192     uint oldValue = allowed[msg.sender][_spender];
193     if (_subtractedValue > oldValue) {
194       allowed[msg.sender][_spender] = 0;
195     } else {
196       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
197     }
198     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
199     return true;
200   }
201 
202 }
203 
204 
205 
206 /**
207  * @title Ownable
208  * @dev The Ownable contract has an owner address, and provides basic authorization control
209  * functions, this simplifies the implementation of "user permissions".
210  */
211 contract Ownable {
212   address public owner;
213 
214 
215   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
216 
217 
218   /**
219    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
220    * account.
221    */
222   function Ownable() public {
223     owner = msg.sender;
224   }
225 
226 
227   /**
228    * @dev Throws if called by any account other than the owner.
229    */
230   modifier onlyOwner() {
231     require(msg.sender == owner);
232     _;
233   }
234 
235 
236   /**
237    * @dev Allows the current owner to transfer control of the contract to a newOwner.
238    * @param newOwner The address to transfer ownership to.
239    */
240   function transferOwnership(address newOwner) public onlyOwner {
241     require(newOwner != address(0));
242     OwnershipTransferred(owner, newOwner);
243     owner = newOwner;
244   }
245 
246 }
247 
248 
249 
250 /**
251  * @title Mintable token
252  * @dev Simple ERC20 Token example, with mintable token creation
253  * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120
254  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
255  */
256 
257 contract MintableToken is StandardToken, Ownable {
258   event Mint(address indexed to, uint256 amount);
259   event MintFinished();
260 
261   bool public mintingFinished = false;
262 
263 
264   modifier canMint() {
265     require(!mintingFinished);
266     _;
267   }
268 
269   /**
270    * @dev Function to mint tokens
271    * @param _to The address that will receive the minted tokens.
272    * @param _amount The amount of tokens to mint.
273    * @return A boolean that indicates if the operation was successful.
274    */
275   function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {
276     totalSupply = totalSupply.add(_amount);
277     balances[_to] = balances[_to].add(_amount);
278     Mint(_to, _amount);
279     Transfer(address(0), _to, _amount);
280     return true;
281   }
282 
283   /**
284    * @dev Function to stop minting new tokens.
285    * @return True if the operation was successful.
286    */
287   function finishMinting() onlyOwner canMint public returns (bool) {
288     mintingFinished = true;
289     MintFinished();
290     return true;
291   }
292 }
293 
294 
295 /**
296  * @title Crowdsale
297  * @dev Crowdsale is a base contract for managing a token crowdsale.
298  * Crowdsales have a start and end timestamps, where investors can make
299  * token purchases and the crowdsale will assign them tokens based
300  * on a token per ETH rate. Funds collected are forwarded to a wallet
301  * as they arrive.
302  */
303 contract Crowdsale {
304   using SafeMath for uint256;
305 
306   // The token being sold
307   MintableToken public token;
308 
309   // start and end timestamps where investments are allowed (both inclusive)
310   uint256 public startTime;
311   uint256 public endTime;
312 
313   // address where funds are collected
314   address public wallet;
315 
316   // how many token units a buyer gets per wei
317   uint256 public rate;
318 
319   // amount of raised money in wei
320   uint256 public weiRaised;
321 
322   /**
323    * event for token purchase logging
324    * @param purchaser who paid for the tokens
325    * @param beneficiary who got the tokens
326    * @param value weis paid for purchase
327    * @param amount amount of tokens purchased
328    */
329   event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);
330 
331 
332   function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
333     require(_startTime >= now);
334     require(_endTime >= _startTime);
335     require(_rate > 0);
336     require(_wallet != address(0));
337 
338     token = createTokenContract();
339     startTime = _startTime;
340     endTime = _endTime;
341     rate = _rate;
342     wallet = _wallet;
343   }
344 
345   // creates the token to be sold.
346   // override this method to have crowdsale of a specific mintable token.
347   function createTokenContract() internal returns (MintableToken) {
348     return new MintableToken();
349   }
350 
351 
352   // fallback function can be used to buy tokens
353   function () external payable {
354     buyTokens(msg.sender);
355   }
356 
357   // low level token purchase function
358   function buyTokens(address beneficiary) public payable {
359     require(beneficiary != address(0));
360     require(validPurchase());
361 
362     uint256 weiAmount = msg.value;
363 
364     // calculate token amount to be created
365     uint256 tokens = weiAmount.mul(rate);
366 
367     // update state
368     weiRaised = weiRaised.add(weiAmount);
369 
370     token.mint(beneficiary, tokens);
371     TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
372 
373     forwardFunds();
374   }
375 
376   // send ether to the fund collection wallet
377   // override to create custom fund forwarding mechanisms
378   function forwardFunds() internal {
379     wallet.transfer(msg.value);
380   }
381 
382   // @return true if the transaction can buy tokens
383   function validPurchase() internal view returns (bool) {
384     bool withinPeriod = now >= startTime && now <= endTime;
385     bool nonZeroPurchase = msg.value != 0;
386     return withinPeriod && nonZeroPurchase;
387   }
388 
389   // @return true if crowdsale event has ended
390   function hasEnded() public view returns (bool) {
391     return now > endTime;
392   }
393 
394 
395 }
396 
397 
398 /**
399  * @title FinalizableCrowdsale
400  * @dev Extension of Crowdsale where an owner can do extra work
401  * after finishing.
402  */
403 contract FinalizableCrowdsale is Crowdsale, Ownable {
404   using SafeMath for uint256;
405 
406   bool public isFinalized = false;
407 
408   event Finalized();
409 
410   /**
411    * @dev Must be called after crowdsale ends, to do some extra finalization
412    * work. Calls the contract's finalization function.
413    */
414   function finalize() onlyOwner public {
415     require(!isFinalized);
416     require(hasEnded());
417 
418     finalization();
419     Finalized();
420 
421     isFinalized = true;
422   }
423 
424   /**
425    * @dev Can be overridden to add finalization logic. The overriding function
426    * should call super.finalization() to ensure the chain of finalization is
427    * executed entirely.
428    */
429   function finalization() internal {
430   }
431 }
432 
433 
434 /**
435  * @title RefundVault
436  * @dev This contract is used for storing funds while a crowdsale
437  * is in progress. Supports refunding the money if crowdsale fails,
438  * and forwarding it if crowdsale is successful.
439  */
440 contract RefundVault is Ownable {
441   using SafeMath for uint256;
442 
443   enum State { Active, Refunding, Closed }
444 
445   mapping (address => uint256) public deposited;
446   address public wallet;
447   State public state;
448 
449   event Closed();
450   event RefundsEnabled();
451   event Refunded(address indexed beneficiary, uint256 weiAmount);
452 
453   function RefundVault(address _wallet) public {
454     require(_wallet != address(0));
455     wallet = _wallet;
456     state = State.Active;
457   }
458 
459   function deposit(address investor) onlyOwner public payable {
460     require(state == State.Active);
461     deposited[investor] = deposited[investor].add(msg.value);
462   }
463 
464   function close() onlyOwner public {
465     require(state == State.Active);
466     state = State.Closed;
467     Closed();
468     wallet.transfer(this.balance);
469   }
470 
471   function enableRefunds() onlyOwner public {
472     require(state == State.Active);
473     state = State.Refunding;
474     RefundsEnabled();
475   }
476 
477   function refund(address investor) public {
478     require(state == State.Refunding);
479     uint256 depositedValue = deposited[investor];
480     deposited[investor] = 0;
481     investor.transfer(depositedValue);
482     Refunded(investor, depositedValue);
483   }
484 }
485 
486 
487 
488 contract FreezableToken is StandardToken {
489     // freezing chains
490     mapping (bytes32 => uint64) internal chains;
491     // freezing amounts for each chain
492     mapping (bytes32 => uint) internal freezings;
493     // total freezing balance per address
494     mapping (address => uint) internal freezingBalance;
495 
496     event Freezed(address indexed to, uint64 release, uint amount);
497     event Released(address indexed owner, uint amount);
498 
499 
500     /**
501      * @dev Gets the balance of the specified address include freezing tokens.
502      * @param _owner The address to query the the balance of.
503      * @return An uint256 representing the amount owned by the passed address.
504      */
505     function balanceOf(address _owner) public view returns (uint256 balance) {
506         return super.balanceOf(_owner) + freezingBalance[_owner];
507     }
508 
509     /**
510      * @dev Gets the balance of the specified address without freezing tokens.
511      * @param _owner The address to query the the balance of.
512      * @return An uint256 representing the amount owned by the passed address.
513      */
514     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
515         return super.balanceOf(_owner);
516     }
517 
518     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
519         return freezingBalance[_owner];
520     }
521 
522     /**
523      * @dev gets freezing count
524      * @param _addr Address of freeze tokens owner.
525      */
526     function freezingCount(address _addr) public view returns (uint count) {
527         uint64 release = chains[toKey(_addr, 0)];
528         while (release != 0) {
529             count ++;
530             release = chains[toKey(_addr, release)];
531         }
532     }
533 
534     /**
535      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
536      * @param _addr Address of freeze tokens owner.
537      * @param _index Freezing portion index. It ordered by release date descending.
538      */
539     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
540         for (uint i = 0; i < _index + 1; i ++) {
541             _release = chains[toKey(_addr, _release)];
542             if (_release == 0) {
543                 return;
544             }
545         }
546         _balance = freezings[toKey(_addr, _release)];
547     }
548 
549     /**
550      * @dev freeze your tokens to the specified address.
551      *      Be careful, gas usage is not deterministic,
552      *      and depends on how many freezes _to address already has.
553      * @param _to Address to which token will be freeze.
554      * @param _amount Amount of token to freeze.
555      * @param _until Release date, must be in future.
556      */
557     function freezeTo(address _to, uint _amount, uint64 _until) public {
558         require(_to != address(0));
559         require(_amount <= balances[msg.sender]);
560 
561         balances[msg.sender] = balances[msg.sender].sub(_amount);
562 
563         bytes32 currentKey = toKey(_to, _until);
564         freezings[currentKey] = freezings[currentKey].add(_amount);
565         freezingBalance[_to] = freezingBalance[_to].add(_amount);
566 
567         freeze(_to, _until);
568         Transfer(msg.sender, _to, _amount);
569         Freezed(_to, _until, _amount);
570     }
571 
572     /**
573      * @dev release first available freezing tokens.
574      */
575     function releaseOnce() public {
576         bytes32 headKey = toKey(msg.sender, 0);
577         uint64 head = chains[headKey];
578         require(head != 0);
579         require(uint64(block.timestamp) > head);
580         bytes32 currentKey = toKey(msg.sender, head);
581 
582         uint64 next = chains[currentKey];
583 
584         uint amount = freezings[currentKey];
585         delete freezings[currentKey];
586 
587         balances[msg.sender] = balances[msg.sender].add(amount);
588         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
589 
590         if (next == 0) {
591             delete chains[headKey];
592         }
593         else {
594             chains[headKey] = next;
595             delete chains[currentKey];
596         }
597         Released(msg.sender, amount);
598     }
599 
600     /**
601      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
602      * @return how many tokens was released
603      */
604     function releaseAll() public returns (uint tokens) {
605         uint release;
606         uint balance;
607         (release, balance) = getFreezing(msg.sender, 0);
608         while (release != 0 && block.timestamp > release) {
609             releaseOnce();
610             tokens += balance;
611             (release, balance) = getFreezing(msg.sender, 0);
612         }
613     }
614 
615     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
616         // WISH masc to increase entropy
617         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
618         assembly {
619             result := or(result, mul(_addr, 0x10000000000000000))
620             result := or(result, _release)
621         }
622     }
623 
624     function freeze(address _to, uint64 _until) internal {
625         require(_until > block.timestamp);
626         bytes32 key = toKey(_to, _until);
627         bytes32 parentKey = toKey(_to, uint64(0));
628         uint64 next = chains[parentKey];
629 
630         if (next == 0) {
631             chains[parentKey] = _until;
632             return;
633         }
634 
635         bytes32 nextKey = toKey(_to, next);
636         uint parent;
637 
638         while (next != 0 && _until > next) {
639             parent = next;
640             parentKey = nextKey;
641 
642             next = chains[nextKey];
643             nextKey = toKey(_to, next);
644         }
645 
646         if (_until == next) {
647             return;
648         }
649 
650         if (next != 0) {
651             chains[key] = next;
652         }
653 
654         chains[parentKey] = _until;
655     }
656 }
657 
658 /**
659 * @title Contract that will work with ERC223 tokens.
660 */
661 
662 contract ERC223Receiver {
663     /**
664      * @dev Standard ERC223 function that will handle incoming token transfers.
665      *
666      * @param _from  Token sender address.
667      * @param _value Amount of tokens.
668      * @param _data  Transaction metadata.
669      */
670     function tokenFallback(address _from, uint _value, bytes _data) public;
671 }
672 
673 contract ERC223Basic is ERC20Basic {
674     function transfer(address to, uint value, bytes data) public returns (bool);
675     event Transfer(address indexed from, address indexed to, uint value, bytes data);
676 }
677 
678 
679 contract SuccessfulERC223Receiver is ERC223Receiver {
680     event Invoked(address from, uint value, bytes data);
681 
682     function tokenFallback(address _from, uint _value, bytes _data) public {
683         Invoked(_from, _value, _data);
684     }
685 }
686 
687 contract FailingERC223Receiver is ERC223Receiver {
688     function tokenFallback(address, uint, bytes) public {
689         revert();
690     }
691 }
692 
693 contract ERC223ReceiverWithoutTokenFallback {
694 }
695 
696 /**
697  * @title Burnable Token
698  * @dev Token that can be irreversibly burned (destroyed).
699  */
700 contract BurnableToken is StandardToken {
701 
702     event Burn(address indexed burner, uint256 value);
703 
704     /**
705      * @dev Burns a specific amount of tokens.
706      * @param _value The amount of token to be burned.
707      */
708     function burn(uint256 _value) public {
709         require(_value > 0);
710         require(_value <= balances[msg.sender]);
711         // no need to require value <= totalSupply, since that would imply the
712         // sender's balance is greater than the totalSupply, which *should* be an assertion failure
713 
714         address burner = msg.sender;
715         balances[burner] = balances[burner].sub(_value);
716         totalSupply = totalSupply.sub(_value);
717         Burn(burner, _value);
718     }
719 }
720 
721 
722 
723 /**
724  * @title Pausable
725  * @dev Base contract which allows children to implement an emergency stop mechanism.
726  */
727 contract Pausable is Ownable {
728   event Pause();
729   event Unpause();
730 
731   bool public paused = false;
732 
733 
734   /**
735    * @dev Modifier to make a function callable only when the contract is not paused.
736    */
737   modifier whenNotPaused() {
738     require(!paused);
739     _;
740   }
741 
742   /**
743    * @dev Modifier to make a function callable only when the contract is paused.
744    */
745   modifier whenPaused() {
746     require(paused);
747     _;
748   }
749 
750   /**
751    * @dev called by the owner to pause, triggers stopped state
752    */
753   function pause() onlyOwner whenNotPaused public {
754     paused = true;
755     Pause();
756   }
757 
758   /**
759    * @dev called by the owner to unpause, returns to normal state
760    */
761   function unpause() onlyOwner whenPaused public {
762     paused = false;
763     Unpause();
764   }
765 }
766 
767 
768 
769 contract FreezableMintableToken is FreezableToken, MintableToken {
770     /**
771      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
772      *      Be careful, gas usage is not deterministic,
773      *      and depends on how many freezes _to address already has.
774      * @param _to Address to which token will be freeze.
775      * @param _amount Amount of token to mint and freeze.
776      * @param _until Release date, must be in future.
777      * @return A boolean that indicates if the operation was successful.
778      */
779     function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {
780         totalSupply = totalSupply.add(_amount);
781 
782         bytes32 currentKey = toKey(_to, _until);
783         freezings[currentKey] = freezings[currentKey].add(_amount);
784         freezingBalance[_to] = freezingBalance[_to].add(_amount);
785 
786         freeze(_to, _until);
787         Mint(_to, _amount);
788         Freezed(_to, _until, _amount);
789         Transfer(msg.sender, _to, _amount);
790         return true;
791     }
792 }
793 
794 contract Consts {
795     uint constant TOKEN_DECIMALS = 18;
796     uint8 constant TOKEN_DECIMALS_UINT8 = 18;
797     uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
798 
799     string constant TOKEN_NAME = "EURUSDCOIN";
800     string constant TOKEN_SYMBOL = "EUUS";
801     bool constant PAUSED = false;
802     address constant TARGET_USER = 0x5544A710df19D35267844dB9c8923f903A7D7467;
803     
804     uint constant START_TIME = 1527804000;
805     
806     bool constant CONTINUE_MINTING = false;
807 }
808 
809 
810 
811 
812 /**
813  * @title Reference implementation of the ERC223 standard token.
814  */
815 contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {
816     using SafeMath for uint;
817 
818     /**
819      * @dev Transfer the specified amount of tokens to the specified address.
820      *      Invokes the `tokenFallback` function if the recipient is a contract.
821      *      The token transfer fails if the recipient is a contract
822      *      but does not implement the `tokenFallback` function
823      *      or the fallback function to receive funds.
824      *
825      * @param _to    Receiver address.
826      * @param _value Amount of tokens that will be transferred.
827      * @param _data  Transaction metadata.
828      */
829     function transfer(address _to, uint _value, bytes _data) public returns (bool) {
830         // Standard function transfer similar to ERC20 transfer with no _data .
831         // Added due to backwards compatibility reasons .
832         uint codeLength;
833 
834         assembly {
835             // Retrieve the size of the code on target address, this needs assembly.
836             codeLength := extcodesize(_to)
837         }
838 
839         balances[msg.sender] = balances[msg.sender].sub(_value);
840         balances[_to] = balances[_to].add(_value);
841         if(codeLength > 0) {
842             ERC223Receiver receiver = ERC223Receiver(_to);
843             receiver.tokenFallback(msg.sender, _value, _data);
844         }
845         Transfer(msg.sender, _to, _value, _data);
846         return true;
847     }
848 
849     /**
850      * @dev Transfer the specified amount of tokens to the specified address.
851      *      This function works the same with the previous one
852      *      but doesn't contain `_data` param.
853      *      Added due to backwards compatibility reasons.
854      *
855      * @param _to    Receiver address.
856      * @param _value Amount of tokens that will be transferred.
857      */
858     function transfer(address _to, uint256 _value) public returns (bool) {
859         bytes memory empty;
860         return transfer(_to, _value, empty);
861     }
862 }
863 
864 
865 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
866     
867 {
868     
869 
870     function name() pure public returns (string _name) {
871         return TOKEN_NAME;
872     }
873 
874     function symbol() pure public returns (string _symbol) {
875         return TOKEN_SYMBOL;
876     }
877 
878     function decimals() pure public returns (uint8 _decimals) {
879         return TOKEN_DECIMALS_UINT8;
880     }
881 
882     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
883         require(!paused);
884         return super.transferFrom(_from, _to, _value);
885     }
886 
887     function transfer(address _to, uint256 _value) public returns (bool _success) {
888         require(!paused);
889         return super.transfer(_to, _value);
890     }
891 }
892 
893 
894 
895 
896 /**
897  * @title CappedCrowdsale
898  * @dev Extension of Crowdsale with a max amount of funds raised
899  */
900 contract CappedCrowdsale is Crowdsale {
901   using SafeMath for uint256;
902 
903   uint256 public cap;
904 
905   function CappedCrowdsale(uint256 _cap) public {
906     require(_cap > 0);
907     cap = _cap;
908   }
909 
910   // overriding Crowdsale#validPurchase to add extra cap logic
911   // @return true if investors can buy at the moment
912   function validPurchase() internal view returns (bool) {
913     bool withinCap = weiRaised.add(msg.value) <= cap;
914     return super.validPurchase() && withinCap;
915   }
916 
917   // overriding Crowdsale#hasEnded to add cap logic
918   // @return true if crowdsale event has ended
919   function hasEnded() public view returns (bool) {
920     bool capReached = weiRaised >= cap;
921     return super.hasEnded() || capReached;
922   }
923 
924 }
925 
926 
927 
928 /**
929  * @title RefundableCrowdsale
930  * @dev Extension of Crowdsale contract that adds a funding goal, and
931  * the possibility of users getting a refund if goal is not met.
932  * Uses a RefundVault as the crowdsale's vault.
933  */
934 contract RefundableCrowdsale is FinalizableCrowdsale {
935   using SafeMath for uint256;
936 
937   // minimum amount of funds to be raised in weis
938   uint256 public goal;
939 
940   // refund vault used to hold funds while crowdsale is running
941   RefundVault public vault;
942 
943   function RefundableCrowdsale(uint256 _goal) public {
944     require(_goal > 0);
945     vault = new RefundVault(wallet);
946     goal = _goal;
947   }
948 
949   // We're overriding the fund forwarding from Crowdsale.
950   // In addition to sending the funds, we want to call
951   // the RefundVault deposit function
952   function forwardFunds() internal {
953     vault.deposit.value(msg.value)(msg.sender);
954   }
955 
956   // if crowdsale is unsuccessful, investors can claim refunds here
957   function claimRefund() public {
958     require(isFinalized);
959     require(!goalReached());
960 
961     vault.refund(msg.sender);
962   }
963 
964   // vault finalization task, called when owner calls finalize()
965   function finalization() internal {
966     if (goalReached()) {
967       vault.close();
968     } else {
969       vault.enableRefunds();
970     }
971 
972     super.finalization();
973   }
974 
975   function goalReached() public view returns (bool) {
976     return weiRaised >= goal;
977   }
978 
979 }
980 
981 
982 contract MainCrowdsale is Consts, FinalizableCrowdsale {
983     function hasStarted() public constant returns (bool) {
984         return now >= startTime;
985     }
986 
987     function finalization() internal {
988         super.finalization();
989 
990         if (PAUSED) {
991             MainToken(token).unpause();
992         }
993 
994         if (!CONTINUE_MINTING) {
995             token.finishMinting();
996         }
997 
998         token.transferOwnership(TARGET_USER);
999     }
1000 
1001     function buyTokens(address beneficiary) public payable {
1002         require(beneficiary != address(0));
1003         require(validPurchase());
1004 
1005         uint256 weiAmount = msg.value;
1006 
1007         // calculate token amount to be created
1008         uint256 tokens = weiAmount.mul(rate).div(1 ether);
1009 
1010         // update state
1011         weiRaised = weiRaised.add(weiAmount);
1012 
1013         token.mint(beneficiary, tokens);
1014         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1015 
1016         forwardFunds();
1017     }
1018 }
1019 
1020 
1021 contract Checkable {
1022     address private serviceAccount;
1023     /**
1024      * Flag means that contract accident already occurs.
1025      */
1026     bool private triggered = false;
1027 
1028     /**
1029      * Occurs when accident happened.
1030      */
1031     event Triggered(uint balance);
1032     /**
1033      * Occurs when check finished.
1034      */
1035     event Checked(bool isAccident);
1036 
1037     function Checkable() public {
1038         serviceAccount = msg.sender;
1039     }
1040 
1041     /**
1042      * @dev Replace service account with new one.
1043      * @param _account Valid service account address.
1044      */
1045     function changeServiceAccount(address _account) onlyService public {
1046         assert(_account != 0);
1047         serviceAccount = _account;
1048     }
1049 
1050     /**
1051      * @dev Is caller (sender) service account.
1052      */
1053     function isServiceAccount() view public returns (bool) {
1054         return msg.sender == serviceAccount;
1055     }
1056 
1057     /**
1058      * Public check method.
1059      */
1060     function check() onlyService notTriggered payable public {
1061         if (internalCheck()) {
1062             Triggered(this.balance);
1063             triggered = true;
1064             internalAction();
1065         }
1066     }
1067 
1068     /**
1069      * @dev Do inner check.
1070      * @return bool true of accident triggered, false otherwise.
1071      */
1072     function internalCheck() internal returns (bool);
1073 
1074     /**
1075      * @dev Do inner action if check was success.
1076      */
1077     function internalAction() internal;
1078 
1079     modifier onlyService {
1080         require(msg.sender == serviceAccount);
1081         _;
1082     }
1083 
1084     modifier notTriggered() {
1085         require(!triggered);
1086         _;
1087     }
1088 }
1089 
1090 
1091 contract BonusableCrowdsale is Consts, Crowdsale {
1092 
1093     function buyTokens(address beneficiary) public payable {
1094         require(beneficiary != address(0));
1095         require(validPurchase());
1096 
1097         uint256 weiAmount = msg.value;
1098 
1099         // calculate token amount to be created
1100         uint256 bonusRate = getBonusRate(weiAmount);
1101         uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);
1102 
1103         // update state
1104         weiRaised = weiRaised.add(weiAmount);
1105 
1106         token.mint(beneficiary, tokens);
1107         TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
1108 
1109         forwardFunds();
1110     }
1111 
1112     function getBonusRate(uint256 weiAmount) internal view returns (uint256) {
1113         uint256 bonusRate = rate;
1114 
1115         
1116         // apply bonus for time & weiRaised
1117         uint[1] memory weiRaisedStartsBoundaries = [uint(0)];
1118         uint[1] memory weiRaisedEndsBoundaries = [uint(9000000000000000000000)];
1119         uint64[1] memory timeStartsBoundaries = [uint64(1527804000)];
1120         uint64[1] memory timeEndsBoundaries = [uint64(1530396000)];
1121         uint[1] memory weiRaisedAndTimeRates = [uint(500)];
1122 
1123         for (uint i = 0; i < 1; i++) {
1124             bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);
1125             bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);
1126             if (weiRaisedInBound && timeInBound) {
1127                 bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;
1128             }
1129         }
1130         
1131 
1132         
1133 
1134         return bonusRate;
1135     }
1136 }
1137 
1138 
1139 
1140 contract TemplateCrowdsale is Consts, MainCrowdsale
1141     
1142     , BonusableCrowdsale
1143     
1144     
1145     , CappedCrowdsale
1146     
1147     , Checkable
1148     
1149 {
1150     event Initialized();
1151     bool public initialized = false;
1152 
1153     function TemplateCrowdsale(MintableToken _token) public
1154         Crowdsale(START_TIME > now ? START_TIME : now, 1538258400, 100000 * TOKEN_DECIMAL_MULTIPLIER, 0x8d2420D1452c4792751e2C5c2B7a14b0FBDDCE57)
1155         CappedCrowdsale(9000000000000000000000)
1156         
1157     {
1158         token = _token;
1159     }
1160 
1161     function init() public onlyOwner {
1162         require(!initialized);
1163         initialized = true;
1164 
1165         if (PAUSED) {
1166             MainToken(token).pause();
1167         }
1168 
1169         
1170         address[1] memory addresses = [address(0x21c00b4466faf8b367a3102179d2803c655ecd05)];
1171         uint[1] memory amounts = [uint(100000000000000000000000000)];
1172         uint64[1] memory freezes = [uint64(0)];
1173 
1174         for (uint i = 0; i < addresses.length; i++) {
1175             if (freezes[i] == 0) {
1176                 MainToken(token).mint(addresses[i], amounts[i]);
1177             } else {
1178                 MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);
1179             }
1180         }
1181         
1182 
1183         transferOwnership(TARGET_USER);
1184 
1185         Initialized();
1186     }
1187 
1188     /**
1189      * @dev override token creation to set token address in constructor.
1190      */
1191     function createTokenContract() internal returns (MintableToken) {
1192         return MintableToken(0);
1193     }
1194 
1195     
1196     /**
1197      * @dev Do inner check.
1198      * @return bool true of accident triggered, false otherwise.
1199      */
1200     function internalCheck() internal returns (bool) {
1201         bool result = !isFinalized && hasEnded();
1202         Checked(result);
1203         return result;
1204     }
1205 
1206     /**
1207      * @dev Do inner action if check was success.
1208      */
1209     function internalAction() internal {
1210         finalization();
1211         Finalized();
1212 
1213         isFinalized = true;
1214     }
1215     
1216 
1217     
1218     /**
1219      * @dev override purchase validation to add extra value logic.
1220      * @return true if sended more than minimal value
1221      */
1222     function validPurchase() internal view returns (bool) {
1223         
1224         bool minValue = msg.value >= 50000000000000000;
1225         
1226         
1227         bool maxValue = msg.value <= 10000000000000000000;
1228         
1229 
1230         return
1231         
1232             minValue &&
1233         
1234         
1235             maxValue &&
1236         
1237             super.validPurchase();
1238     }
1239     
1240 
1241     
1242     /**
1243      * @dev override hasEnded to add minimal value logic
1244      * @return true if remained to achieve less than minimal
1245      */
1246     function hasEnded() public view returns (bool) {
1247         bool remainValue = cap.sub(weiRaised) < 50000000000000000;
1248         return super.hasEnded() || remainValue;
1249     }
1250     
1251 
1252 }