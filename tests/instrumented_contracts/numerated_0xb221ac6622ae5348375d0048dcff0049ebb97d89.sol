1 pragma solidity 0.4.24;
2 
3 interface ITokenContract {
4     function balanceOf(address _owner) external view returns (uint256 balance);
5   
6     function transfer(
7         address _to, 
8         uint256 _amount
9     )
10         external 
11         returns (bool success);
12 
13     function transferFrom(
14         address _from, 
15         address _to, 
16         uint256 _amount
17     ) 
18         external 
19         returns (bool success);
20 }
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 /**
32 * @dev Supports ERC20 tokens
33 * The escrow smart contract for the OpenBazaar trades in Ethereum
34 * The smart contract is designed keeping in mind the current wallet interface
35 * of OB-core:
36 * https://github.com/OpenBazaar/wallet-interface/blob/master/wallet.go
37 * Current wallet interface strictly adheres to UTXO(bitcoin) model
38 * Please read below mentioned link for detailed specs
39 * https://github.com/OpenBazaar/smart-contracts/blob/master/contracts/escrow/EscrowSpec.md
40 */
41 contract Escrow_v1_0 {
42 
43     using SafeMath for uint256;
44 
45     enum Status {FUNDED, RELEASED}
46 
47     enum TransactionType {ETHER, TOKEN}
48 
49     event Executed(
50         bytes32 indexed scriptHash,
51         address[] destinations,
52         uint256[] amounts
53     );
54 
55     event FundAdded(
56         bytes32 indexed scriptHash,
57         address indexed from,
58         uint256 valueAdded
59     );
60 
61     event Funded(
62         bytes32 indexed scriptHash,
63         address indexed from,
64         uint256 value
65     );
66 
67     struct Transaction {
68         uint256 value;
69         uint256 lastModified; //time txn was last modified (in seconds)
70         Status status;
71         TransactionType transactionType;
72         uint8 threshold;
73         uint32 timeoutHours;
74         address buyer;
75         address seller;
76         address tokenAddress; //token address in case of token transfer
77         address moderator;
78         mapping(address => bool) isOwner; //to keep track of owners.
79         mapping(address => bool) voted; //to keep track of who all voted
80         mapping(address => bool) beneficiaries; //beneficiaries of execution
81     }
82 
83     mapping(bytes32 => Transaction) public transactions;
84 
85     uint256 public transactionCount = 0;
86 
87     //Contains mapping between each party and all of their transactions
88     mapping(address => bytes32[]) private partyVsTransaction;
89 
90     modifier transactionExists(bytes32 scriptHash) {
91         require(
92             transactions[scriptHash].value != 0, "Transaction does not exist"
93         );
94         _;
95     }
96 
97     modifier transactionDoesNotExist(bytes32 scriptHash) {
98         require(transactions[scriptHash].value == 0, "Transaction exists");
99         _;
100     }
101 
102     modifier inFundedState(bytes32 scriptHash) {
103         require(
104             transactions[scriptHash].status == Status.FUNDED,
105             "Transaction is not in FUNDED state"
106         );
107         _;
108     }
109 
110     modifier nonZeroAddress(address addressToCheck) {
111         require(addressToCheck != address(0), "Zero address passed");
112         _;
113     }
114 
115     modifier checkTransactionType(
116         bytes32 scriptHash,
117         TransactionType transactionType
118     )
119     {
120         require(
121             transactions[scriptHash].transactionType == transactionType,
122             "Transaction type does not match"
123         );
124         _;
125     }
126 
127     modifier onlyBuyer(bytes32 scriptHash) {
128         require(
129             msg.sender == transactions[scriptHash].buyer,
130             "The initiator of the transaction is not buyer"
131         );
132         _;
133     }
134 
135     /**
136     * @dev Add new transaction in the contract
137     * @param buyer The buyer of the transaction
138     * @param seller The seller of the listing associated with the transaction
139     * @param moderator Moderator for this transaction
140     * @param threshold Minimum number of signatures required to released funds
141     * @param timeoutHours Hours after which seller can release funds into his
142     * favour by signing transaction unilaterally
143     * @param scriptHash keccak256 hash of the redeem script
144     * @param uniqueId bytes20 unique id for the transaction, generated by
145     * ETH wallet
146     * Redeem Script format will be following
147     * <uniqueId: 20><threshold:1><timeoutHours:4><buyer:20><seller:20>
148     * <moderator:20><multisigAddress:20>
149     * Pass amount of the ETH to be put in escrow
150     */
151     function addTransaction(
152         address buyer,
153         address seller,
154         address moderator,
155         uint8 threshold,
156         uint32 timeoutHours,
157         bytes32 scriptHash,
158         bytes20 uniqueId
159     )
160         external
161         payable
162         transactionDoesNotExist(scriptHash)
163         nonZeroAddress(buyer)
164         nonZeroAddress(seller)
165     {
166         _addTransaction(
167             buyer,
168             seller,
169             moderator,
170             threshold,
171             timeoutHours,
172             scriptHash,
173             msg.value,
174             uniqueId,
175             TransactionType.ETHER,
176             address(0)
177         );
178 
179         emit Funded(scriptHash, msg.sender, msg.value);
180 
181     }
182 
183     /**
184     * @dev Add new transaction in the contract
185     * @param buyer The buyer of the transaction
186     * @param seller The seller of the listing associated with the transaction
187     * @param moderator Moderator for this transaction
188     * @param threshold Minimum number of signatures required to released funds
189     * @param timeoutHours Hours after which seller can release funds into his
190     * favour by signing transaction unilaterally
191     * @param scriptHash keccak256 hash of the redeem script
192     * @param value Amount of tokens to be put in escrow
193     * @param uniqueId bytes20 unique id for the transaction, generated by
194     * ETH wallet
195     * @param tokenAddress Address of the token to be used
196     * Redeem Script format will be following:
197     * <uniqueId: 20><threshold:1><timeoutHours:4><buyer:20><seller:20>
198     * <moderator:20><multisigAddress:20><tokenAddress:20>
199     * Approve escrow contract to spend amount of token on sender's behalf
200     */
201     function addTokenTransaction(
202         address buyer,
203         address seller,
204         address moderator,
205         uint8 threshold,
206         uint32 timeoutHours,
207         bytes32 scriptHash,
208         uint256 value,
209         bytes20 uniqueId,
210         address tokenAddress
211     )
212         external
213         transactionDoesNotExist(scriptHash)
214         nonZeroAddress(buyer)
215         nonZeroAddress(seller)
216         nonZeroAddress(tokenAddress)
217     {
218 
219         _addTransaction(
220             buyer,
221             seller,
222             moderator,
223             threshold,
224             timeoutHours,
225             scriptHash,
226             value,
227             uniqueId,
228             TransactionType.TOKEN,
229             tokenAddress
230         );
231 
232         ITokenContract token = ITokenContract(tokenAddress);
233 
234         require(
235             token.transferFrom(msg.sender, address(this), value),
236             "Token transfer failed, maybe you did not approve escrow contract to spend on behalf of sender"
237         );
238         emit Funded(scriptHash, msg.sender, value);
239     }
240 
241     /**
242     * @dev This method will check whether given address was a beneficiary of
243     * transaction execution or not
244     * @param scriptHash script hash of the transaction
245     * @param beneficiary Beneficiary address to be checked
246     */
247     function checkBeneficiary(
248         bytes32 scriptHash,
249         address beneficiary
250     )
251         external
252         view
253         returns (bool)
254     {
255         return transactions[scriptHash].beneficiaries[beneficiary];
256     }
257 
258     /**
259     * @dev This method will check whether given party has voted or not
260     * @param scriptHash script hash of the transaction
261     * @param party Address of the party whose vote has to be checked
262     * @return bool vote
263     */
264     function checkVote(
265         bytes32 scriptHash,
266         address party
267     )
268         external
269         view
270         returns (bool)
271     {
272         return transactions[scriptHash].voted[party];
273     }
274 
275     /**
276     * @dev Allows buyer of the transaction to add more funds(ether) in the
277     * transaction.
278     * This will help to cater scenarios wherein initially buyer missed to
279     * fund transaction as required
280     * @param scriptHash script hash of the transaction
281     * Only buyer of the transaction can invoke this method
282     */
283     function addFundsToTransaction(
284         bytes32 scriptHash
285     )
286         external
287         payable
288         transactionExists(scriptHash)
289         inFundedState(scriptHash)
290         checkTransactionType(scriptHash, TransactionType.ETHER)
291         onlyBuyer(scriptHash)
292 
293     {
294 
295         require(msg.value > 0, "Value must be greater than zero.");
296 
297         transactions[scriptHash].value = transactions[scriptHash].value
298             .add(msg.value);
299 
300         emit FundAdded(scriptHash, msg.sender, msg.value);
301     }
302 
303     /**
304     * @dev Allows buyer of the transaction to add more funds(Tokens) in the
305     * transaction.
306     * This will help to cater scenarios wherein initially buyer missed to
307     * fund transaction as required
308     * @param scriptHash script hash of the transaction
309     * Only buyer of the transaction can invoke this method
310     */
311     function addTokensToTransaction(
312         bytes32 scriptHash,
313         uint256 value
314     )
315         external
316         transactionExists(scriptHash)
317         inFundedState(scriptHash)
318         checkTransactionType(scriptHash, TransactionType.TOKEN)
319         onlyBuyer(scriptHash)
320     {
321 
322         require(value > 0, "Value must be greater than zero.");
323 
324         ITokenContract token = ITokenContract(
325             transactions[scriptHash].tokenAddress
326         );
327 
328         require(
329             token.transferFrom(msg.sender, address(this), value),
330             "Token transfer failed, maybe you did not approve the escrow contract to spend on behalf of the buyer"
331         );
332 
333         transactions[scriptHash].value = transactions[scriptHash].value
334             .add(value);
335 
336         emit FundAdded(scriptHash, msg.sender, value);
337     }
338 
339     /**
340     *@dev Returns all transaction ids for a party
341     *@param partyAddress Address of the party
342     */
343     function getAllTransactionsForParty(
344         address partyAddress
345     )
346         external
347         view
348         returns (bytes32[])
349     {
350         return partyVsTransaction[partyAddress];
351     }
352 
353     /**
354     *@dev This method will be used to release funds associated with
355     * the transaction
356     * Please see specs https://github.com/OpenBazaar/smart-contracts/blob/master/contracts/escrow/EscrowSpec.md
357     *@param sigV Array containing V component of all the signatures
358     *@param sigR Array containing R component of all the signatures
359     *@param signS Array containing S component of all the signatures
360     *@param scriptHash script hash of the transaction
361     *@param destinations List of addresses who will receive funds
362     *@param amounts amount released to each destination
363     */
364     function execute(
365         uint8[] sigV,
366         bytes32[] sigR,
367         bytes32[] sigS,
368         bytes32 scriptHash,
369         address[] destinations,
370         uint256[] amounts
371     )
372         external
373         transactionExists(scriptHash)
374         inFundedState(scriptHash)
375     {
376 
377         require(
378             destinations.length > 0,
379             "Number of destinations must be greater than 0"
380         );
381         require(
382             destinations.length == amounts.length,
383             "Number of destinations must match number of values sent"
384         );
385 
386         _verifyTransaction(
387             sigV,
388             sigR,
389             sigS,
390             scriptHash,
391             destinations,
392             amounts
393         );
394 
395         transactions[scriptHash].status = Status.RELEASED;
396         //Last modified timestamp modified, which will be used by rewards
397         transactions[scriptHash].lastModified = block.timestamp;
398         require(
399             _transferFunds(scriptHash, destinations, amounts) == transactions[scriptHash].value,
400             "Total value to be released must be equal to the transaction escrow value"
401         );
402 
403         emit Executed(scriptHash, destinations, amounts);
404     }
405 
406 
407     /**
408     *@dev Method for calculating script hash. Calculation will depend upon
409     * the type of transaction
410     * ETHER Type transaction-:
411     * Script Hash- keccak256(uniqueId, threshold, timeoutHours, buyer, seller,
412     * moderator, multiSigContractAddress)
413     * TOKEN Type transaction
414     * Script Hash- keccak256(uniqueId, threshold, timeoutHours, buyer, seller,
415     * moderator, multiSigContractAddress, tokenAddress)
416     * Client can use this method to verify whether it has calculated correct
417     * script hash or not
418     */
419     function calculateRedeemScriptHash(
420         bytes20 uniqueId,
421         uint8 threshold,
422         uint32 timeoutHours,
423         address buyer,
424         address seller,
425         address moderator,
426         address tokenAddress
427     )
428         public
429         view
430         returns (bytes32)
431     {
432         if (tokenAddress == address(0)) {
433             return keccak256(
434                 abi.encodePacked(
435                     uniqueId,
436                     threshold,
437                     timeoutHours,
438                     buyer,
439                     seller,
440                     moderator,
441                     address(this)
442                 )
443             );
444         } else {
445             return keccak256(
446                 abi.encodePacked(
447                     uniqueId,
448                     threshold,
449                     timeoutHours,
450                     buyer,
451                     seller,
452                     moderator,
453                     address(this),
454                     tokenAddress
455                 )
456             );
457         }
458     }
459 
460     /**
461     * @dev This methods checks validity of transaction
462     * 1. Verify Signatures
463     * 2. Check if minimum number of signatures has been acquired
464     * 3. If above condition is false, check if timelock is expired or if the
465     *    execution is signed by seller
466     */
467     function _verifyTransaction(
468         uint8[] sigV,
469         bytes32[] sigR,
470         bytes32[] sigS,
471         bytes32 scriptHash,
472         address[] destinations,
473         uint256[] amounts
474     )
475         private
476     {
477         _verifySignatures(
478             sigV,
479             sigR,
480             sigS,
481             scriptHash,
482             destinations,
483             amounts
484         );
485 
486         bool timeLockExpired = _isTimeLockExpired(
487             transactions[scriptHash].timeoutHours,
488             transactions[scriptHash].lastModified
489         );
490 
491         //if the minimum number of signatures are not gathered and either
492         //timelock has not expired or transaction was not signed by seller
493         //then revert
494         if (sigV.length < transactions[scriptHash].threshold) {
495             if (!timeLockExpired) {
496                 revert("Min number of sigs not present and timelock not expired");
497             }
498             else if (!transactions[scriptHash].voted[transactions[scriptHash].seller]) {
499                 revert("Min number of sigs not present and seller did not sign");
500             }
501         }
502     }
503 
504     /**
505     *@dev Private method to transfer funds to the destination addresses on
506     * the basis of transaction type
507     */
508     function _transferFunds(
509         bytes32 scriptHash,
510         address[]destinations,
511         uint256[]amounts
512     )
513         private
514         returns (uint256)
515     {
516         Transaction storage t = transactions[scriptHash];
517 
518         uint256 valueTransferred = 0;
519 
520         if (t.transactionType == TransactionType.ETHER) {
521             for (uint256 i = 0; i < destinations.length; i++) {
522 
523                 require(
524                     destinations[i] != address(0),
525                     "zero address is not allowed as destination address"
526                 );
527 
528                 require(
529                     t.isOwner[destinations[i]],
530                     "Destination address is not one of the owners"
531                 );
532 
533                 require(
534                     amounts[i] > 0,
535                     "Amount to be sent should be greater than 0"
536                 );
537 
538                 valueTransferred = valueTransferred.add(amounts[i]);
539 
540                 //add receiver as beneficiary
541                 t.beneficiaries[destinations[i]] = true;
542                 destinations[i].transfer(amounts[i]);
543             }
544 
545         } else if (t.transactionType == TransactionType.TOKEN) {
546 
547             ITokenContract token = ITokenContract(t.tokenAddress);
548 
549             for (uint256 j = 0; j<destinations.length; j++) {
550 
551                 require(
552                     destinations[j] != address(0),
553                     "zero address is not allowed as destination address"
554                 );
555 
556                 require(
557                     t.isOwner[destinations[j]],
558                     "Destination address is not one of the owners"
559                 );
560 
561                 require(
562                     amounts[j] > 0,
563                     "Amount to be sent should be greater than 0"
564                 );
565 
566                 valueTransferred = valueTransferred.add(amounts[j]);
567 
568                 //add receiver as beneficiary
569                 t.beneficiaries[destinations[j]] = true;
570 
571                 require(
572                     token.transfer(destinations[j], amounts[j]),
573                     "Token transfer failed."
574                 );
575             }
576         }
577         return valueTransferred;
578     }
579 
580 
581     /**
582     *@dev Checks whether the signatures are valid or not and marks signers as
583     * having "voted".
584     */
585     function _verifySignatures(
586         uint8[] sigV,
587         bytes32[] sigR,
588         bytes32[] sigS,
589         bytes32 scriptHash,
590         address[] destinations,
591         uint256[]amounts
592     )
593         private
594     {
595         require(sigR.length == sigS.length, "R,S length mismatch");
596         require(sigR.length == sigV.length, "R,V length mismatch");
597 
598         // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191
599         bytes32 txHash = keccak256(
600             abi.encodePacked(
601                 "\x19Ethereum Signed Message:\n32",
602                 keccak256(
603                     abi.encodePacked(
604                         byte(0x19),
605                         byte(0),
606                         address(this),
607                         destinations,
608                         amounts,
609                         scriptHash
610                     )
611                 )
612             )
613         );
614 
615         for (uint i = 0; i < sigR.length; i++) {
616 
617             address recovered = ecrecover(
618                 txHash,
619                 sigV[i],
620                 sigR[i],
621                 sigS[i]
622             );
623 
624             require(
625                 transactions[scriptHash].isOwner[recovered],
626                 "Invalid signature"
627             );
628             require(
629                 !transactions[scriptHash].voted[recovered],
630                 "Same signature sent twice"
631             );
632             transactions[scriptHash].voted[recovered] = true;
633         }
634     }
635 
636     function _isTimeLockExpired(
637         uint32 timeoutHours,
638         uint256 lastModified
639     )
640         private
641         view
642         returns (bool)
643     {
644         uint256 timeSince = now.sub(lastModified);
645         return (
646             timeoutHours == 0 ? false : timeSince > uint256(timeoutHours).mul(3600)
647         );
648     }
649 
650     /**
651     * Private method to add transaction to reduce code redundancy
652     */
653     function _addTransaction(
654         address buyer,
655         address seller,
656         address moderator,
657         uint8 threshold,
658         uint32 timeoutHours,
659         bytes32 scriptHash,
660         uint256 value,
661         bytes20 uniqueId,
662         TransactionType transactionType,
663         address tokenAddress
664     )
665         private
666     {
667         require(buyer != seller, "Buyer and seller are same");
668 
669         //value passed should be greater than 0
670         require(value > 0, "Value passed is 0");
671 
672         // For now allowing 0 moderator to support 1-2 multisig wallet
673         require(threshold > 0, "Threshold must be greater than 0");
674         require(threshold <= 3, "Threshold must not be greater than 3");
675 
676         //if threshold is 1 then moderator can be any address
677         //otherwise moderator should be a valid address
678         require(
679             threshold == 1 || moderator != address(0),
680             "Either threshold should be 1 or valid moderator address should be passed"
681         );
682 
683         require(
684             scriptHash == calculateRedeemScriptHash(
685                 uniqueId,
686                 threshold,
687                 timeoutHours,
688                 buyer,
689                 seller,
690                 moderator,
691                 tokenAddress
692             ),
693             "Calculated script hash does not match passed script hash."
694         );
695 
696         transactions[scriptHash] = Transaction({
697             buyer: buyer,
698             seller: seller,
699             moderator: moderator,
700             value: value,
701             status: Status.FUNDED,
702             lastModified: block.timestamp,
703             threshold: threshold,
704             timeoutHours: timeoutHours,
705             transactionType:transactionType,
706             tokenAddress:tokenAddress
707         });
708 
709         transactions[scriptHash].isOwner[seller] = true;
710         transactions[scriptHash].isOwner[buyer] = true;
711 
712         //check if buyer or seller are not passed as moderator
713         require(
714             !transactions[scriptHash].isOwner[moderator],
715             "Either buyer or seller is passed as moderator"
716         );
717 
718         //set moderator as one of the owners only if threshold is greater than
719         // 1 otherwise only buyer and seller should be able to release funds
720         if (threshold > 1) {
721             transactions[scriptHash].isOwner[moderator] = true;
722         }
723 
724 
725         transactionCount++;
726 
727         partyVsTransaction[buyer].push(scriptHash);
728         partyVsTransaction[seller].push(scriptHash);
729     }
730 }
731 
732 
733 
734 
735 
736 
737 
738 
739 
740 
741 /**
742  * @title SafeMath
743  * @dev Math operations with safety checks that revert on error
744  */
745 library SafeMath {
746     /**
747     * @dev Multiplies two numbers, reverts on overflow.
748     */
749     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
750         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
751         // benefit is lost if 'b' is also tested.
752         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
753         if (a == 0) {
754             return 0;
755         }
756 
757         uint256 c = a * b;
758         require(c / a == b);
759 
760         return c;
761     }
762 
763     /**
764     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.
765     */
766     function div(uint256 a, uint256 b) internal pure returns (uint256) {
767         // Solidity only automatically asserts when dividing by 0
768         require(b > 0);
769         uint256 c = a / b;
770         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
771 
772         return c;
773     }
774 
775     /**
776     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).
777     */
778     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
779         require(b <= a);
780         uint256 c = a - b;
781 
782         return c;
783     }
784 
785     /**
786     * @dev Adds two numbers, reverts on overflow.
787     */
788     function add(uint256 a, uint256 b) internal pure returns (uint256) {
789         uint256 c = a + b;
790         require(c >= a);
791 
792         return c;
793     }
794 
795     /**
796     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),
797     * reverts when dividing by zero.
798     */
799     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
800         require(b != 0);
801         return a % b;
802     }
803 }