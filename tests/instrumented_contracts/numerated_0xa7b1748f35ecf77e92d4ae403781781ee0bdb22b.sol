1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "details": {
12         "constantOptimizer": true,
13         "cse": true,
14         "deduplicate": true,
15         "inliner": true,
16         "jumpdestRemover": true,
17         "orderLiterals": true,
18         "peephole": true,
19         "yul": true,
20         "yulDetails": {
21           "optimizerSteps": "dhfoDgvulfnTUtnIf",
22           "stackAllocation": true
23         }
24       },
25       "runs": 2000
26     },
27     "remappings": [],
28     "outputSelection": {
29       "*": {
30         "*": [
31           "evm.bytecode",
32           "evm.deployedBytecode",
33           "devdoc",
34           "userdoc",
35           "metadata",
36           "abi"
37         ]
38       }
39     }
40   },
41   "sources": {
42     "@openzeppelin/contracts/security/Pausable.sol": {
43       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
44     },
45     "@openzeppelin/contracts/utils/Context.sol": {
46       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
47     },
48     "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
49       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
50     },
51     "contracts/ShatteredWL.sol": {
52       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IShatteredWL.sol\";\nimport \"./interfaces/IPytheas.sol\";\nimport \"./interfaces/IOrbitalBlockade.sol\";\nimport \"./interfaces/IColonist.sol\";\nimport \"./interfaces/ITColonist.sol\";\nimport \"./interfaces/IEON.sol\";\nimport \"./interfaces/IRAW.sol\";\nimport \"./interfaces/IImperialGuild.sol\";\n\ncontract ShatteredWL is IShatteredWL, Pausable {\n    // address => can call\n    mapping(address => bool) private admins;\n\n    struct HonorsList {\n        bool isHonorsMember;\n        bool hasClaimed;\n        uint8 honorsId;\n    }\n\n    address public auth;\n\n    address payable ImperialGuildTreasury;\n\n    bool public hasPublicSaleStarted;\n    bool public isWLactive;\n    bool public isHonorsActive;\n\n    uint256 public constant paidTokens = 10000;\n    uint256 public constant whitelistPrice = 0.08 ether;\n    uint256 public constant publicPrice = 0.08 ether;\n\n    mapping(address => uint8) private _WLmints;\n\n    mapping(address => HonorsList) private _honorsAddresses;\n\n    event newUser(address newUser);\n\n    bytes32 internal merkleRoot =\n        0xd60676eb70cb99e173a40e78e3c1d139722ab50092a4afb575ee44c5c3e78e7f;\n\n    bytes32 internal entropySauce;\n\n    // reference to the colonist NFT collection\n    IColonist public colonistNFT;\n\n    constructor() {\n        _pause();\n        auth = msg.sender;\n        admins[msg.sender] = true;\n    }\n\n    /** CRITICAL TO SETUP */\n    modifier requireContractsSet() {\n        require(\n            address(colonistNFT) != address(0),\n            \"Contracts not set\"\n        );\n        _;\n    }\n\n    modifier noCheaters() {\n        uint256 size = 0;\n        address acc = msg.sender;\n        assembly {\n            size := extcodesize(acc)\n        }\n\n        require(\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\n            \"you're trying to cheat!\"\n        );\n        _;\n\n        entropySauce = keccak256(abi.encodePacked(acc, block.coinbase));\n    }\n    modifier onlyOwner() {\n        require(msg.sender == auth);\n        _;\n    }\n\n    function setContracts(address _colonistNFT) external onlyOwner {\n        colonistNFT = IColonist(_colonistNFT);\n    }\n\n    /** EXTERNAL */\n\n    function WlMintColonist(uint256 amount, bytes32[] calldata _merkleProof)\n        external\n        payable\n        noCheaters\n        whenNotPaused\n    {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        uint16 minted = colonistNFT.minted();\n        require(isWLactive == true, \"whitelist mints not yeat active\");\n        require(amount > 0 && amount <= 5, \"5 max mints per tx\");\n        require(minted + amount <= paidTokens, \"All sale tokens minted\");\n        require(amount * whitelistPrice == msg.value, \"Invalid payment amount\");\n        require(\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\n            \"Not on the list\"\n        );\n        require(_WLmints[msg.sender] + amount <= 5, \"limit 5 per whitelist\");\n        _WLmints[msg.sender] += uint8(amount);\n\n        uint256 seed;\n        address origin = tx.origin;\n        bytes32 blockies = blockhash(block.number - 1);\n        bytes32 sauce = entropySauce;\n        uint256 blockTime = block.timestamp;\n        uint16[] memory tokenIds = new uint16[](amount);\n        for (uint256 i = 0; i < amount; i++) {\n            minted++;\n            seed = random(origin, blockies, sauce, minted, blockTime);\n            tokenIds[i] = minted;\n            colonistNFT._mintColonist(msg.sender, seed);\n        }\n        emit newUser(msg.sender);\n    }\n\n    /** Mint colonist.\n     */\n    function mintColonist(uint256 amount)\n        external\n        payable\n        noCheaters\n        whenNotPaused\n    {\n        uint16 minted = colonistNFT.minted();\n        require(amount > 0 && amount <= 5, \"5 max mints per tx\");\n        require(minted + amount <= paidTokens, \"All sale tokens minted\");\n        require(hasPublicSaleStarted == true, \"Public sale not open\");\n        require(msg.value >= amount * publicPrice, \"Invalid Payment amount\");\n        uint256 seed;\n        address origin = tx.origin;\n        bytes32 blockies = blockhash(block.number - 1);\n        bytes32 sauce = entropySauce;\n        uint256 blockTime = block.timestamp;\n        uint16[] memory tokenIds = new uint16[](amount);\n        for (uint256 i = 0; i < amount; i++) {\n            minted++;\n            seed = random(origin, blockies, sauce, minted, blockTime);\n            tokenIds[i] = minted;\n            colonistNFT._mintColonist(msg.sender, seed);\n        }\n        emit newUser(msg.sender);\n    }\n\n    /**Mint to honors */\n    function mintToHonors(uint256 amount, address recipient)\n        external\n        onlyOwner\n    {\n        uint16 minted = colonistNFT.minted();\n        require(minted + amount <= 1000, \"Honor tokens have been sent\");\n        uint16[] memory tokenIds = new uint16[](amount);\n        uint256 seed;\n        address origin = tx.origin;\n        bytes32 blockies = blockhash(block.number - 1);\n        bytes32 sauce = entropySauce;\n        uint256 blockTime = block.timestamp;\n        for (uint256 i = 0; i < amount; i++) {\n            minted++;\n            seed = random(origin, blockies, sauce, minted, blockTime);\n            tokenIds[i] = minted;\n            colonistNFT._mintToHonors(address(recipient), seed);\n        }\n        emit newUser(recipient);\n    }\n\n    function revealHonors() external noCheaters {\n        require(isHonorsActive == true, \"Honor mints have not been activated\");\n        require(\n            _honorsAddresses[msg.sender].isHonorsMember,\n            \"Not an honors student\"\n        );\n        require(\n            _honorsAddresses[msg.sender].hasClaimed == false,\n            \"Already claimed\"\n        );\n\n        uint8 id = _honorsAddresses[msg.sender].honorsId;\n        _honorsAddresses[msg.sender].hasClaimed = true;\n        colonistNFT._mintHonors(msg.sender, id);\n\n        emit newUser(msg.sender);\n    }\n\n    function addToHonorslist(address honorsAddress, uint8 honorsId)\n        external\n        onlyOwner\n    {\n        _honorsAddresses[honorsAddress] = HonorsList({\n            isHonorsMember: true,\n            hasClaimed: false,\n            honorsId: honorsId\n        });\n    }\n\n    function togglePublicSale(bool startPublicSale) external onlyOwner {\n        hasPublicSaleStarted = startPublicSale;\n    }\n\n    function toggleHonorsActive(bool _honorsActive) external onlyOwner {\n        isHonorsActive = _honorsActive;\n    }\n\n    function toggleWLactive(bool _isWLactive) external onlyOwner {\n        isWLactive = _isWLactive;\n    }\n\n    /**\n     * enables owner to pause / unpause contract\n     */\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\n        if (_paused) _pause();\n        else _unpause();\n    }\n\n    /**\n     * enables an address to mint / burn\n     * @param addr the address to enable\n     */\n    function addAdmin(address addr) external onlyOwner {\n        admins[addr] = true;\n    }\n\n    /**\n     * disables an address from minting / burning\n     * @param addr the address to disbale\n     */\n    function removeAdmin(address addr) external onlyOwner {\n        admins[addr] = false;\n    }\n\n    function random(\n        address origin,\n        bytes32 blockies,\n        bytes32 sauce,\n        uint16 seed,\n        uint256 blockTime\n    ) internal pure returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(origin, blockies, blockTime, sauce, seed)\n                )\n            );\n    }\n\n    function setImperialGuildTreasury(address payable _ImperialGuildTreasury)\n        external\n        onlyOwner\n    {\n        ImperialGuildTreasury = _ImperialGuildTreasury;\n    }\n\n    /**\n     * allows owner to withdraw funds from minting\n     */\n    function withdraw() external onlyOwner {\n        payable(ImperialGuildTreasury).transfer(address(this).balance);\n    }\n}\n"
53     },
54     "contracts/interfaces/IColonist.sol": {
55       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IColonist {\r\n    // struct to store each Colonist's traits\r\n    struct Colonist {\r\n        bool isColonist;\r\n        uint8 background;\r\n        uint8 body;\r\n        uint8 shirt;\r\n        uint8 jacket;\r\n        uint8 jaw;\r\n        uint8 eyes;\r\n        uint8 hair;\r\n        uint8 held;\r\n        uint8 gen;\r\n    }\r\n\r\n    struct HColonist {\r\n        uint8 Legendary;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function isOwner(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function minted() external returns (uint16);\r\n\r\n    function totalCir() external returns (uint256);\r\n\r\n    function _mintColonist(address recipient, uint256 seed) external;\r\n\r\n    function _mintToHonors(address recipient, uint256 seed) external;\r\n\r\n    function _mintHonors(address recipient, uint8 id) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function getMaxTokens() external view returns (uint256);\r\n\r\n    function getPaidTokens() external view returns (uint256);\r\n\r\n    function getTokenTraitsColonist(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Colonist memory);\r\n\r\n    function getTokenTraitsHonors(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (HColonist memory);\r\n\r\n    function tokenNameByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\r\n\r\n    function nameColonist(uint256 tokenId, string memory newName) external;\r\n}\r\n"
56     },
57     "contracts/interfaces/IEON.sol": {
58       "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IEON {\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function burn(address from, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n"
59     },
60     "contracts/interfaces/IImperialGuild.sol": {
61       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IImperialGuild {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 paymentId,\r\n        uint16 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint16 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function handlePayment(uint256 amount) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n}\r\n"
62     },
63     "contracts/interfaces/IOrbitalBlockade.sol": {
64       "content": "// SPDX-License-Identifier: MIT LICENSE\n\npragma solidity ^0.8.0;\n\ninterface IOrbitalBlockade {\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\n        external;\n    \n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\n        external;\n\n    function payPirateTax(uint256 amount) external;\n\n    function randomPirateOwner(uint256 seed) external view returns (address);\n}\n"
65     },
66     "contracts/interfaces/IPytheas.sol": {
67       "content": "// SPDX-License-Identifier: MIT LICENSE\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPytheas {\r\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\r\n        external;\r\n\r\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\r\n        external;\r\n\r\n    function getColonistMined(address account, uint16 tokenId)\r\n        external\r\n        returns (uint256);\r\n\r\n    function handleJoinPirates(address addr, uint16 tokenId) external;\r\n\r\n    function payUp(\r\n        uint16 tokenId,\r\n        uint256 amtMined,\r\n        address addr\r\n    ) external;\r\n}\r\n"
68     },
69     "contracts/interfaces/IRAW.sol": {
70       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface IRAW {\r\n\r\n    function getBalance(\r\n        address account,\r\n        uint256 id\r\n    ) external returns(uint256);\r\n\r\n    function mint(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address recipient\r\n    ) external;\r\n\r\n    function burn(\r\n        uint256 typeId,\r\n        uint256 qty,\r\n        address burnFrom\r\n    ) external;\r\n\r\n    function updateMintBurns(\r\n        uint256 typeId,\r\n        uint256 mintQty,\r\n        uint256 burnQty\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external;\r\n\r\n}\r\n"
71     },
72     "contracts/interfaces/IShatteredWL.sol": {
73       "content": "// SPDX-License-Identifier: MIT LICENSE\npragma solidity ^0.8.0;\n\ninterface IShatteredWL {}"
74     },
75     "contracts/interfaces/ITColonist.sol": {
76       "content": "// SPDX-License-Identifier: MIT LICENSE\r\npragma solidity ^0.8.0;\r\n\r\ninterface ITColonist {\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n"
77     }
78   }
79 }}