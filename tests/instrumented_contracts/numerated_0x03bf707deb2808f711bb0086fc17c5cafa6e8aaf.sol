1 {{
2   "language": "Solidity",
3   "sources": {
4     "/contracts/OpenLevDelegator.sol": {
5       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"./Adminable.sol\";\nimport \"./DelegatorInterface.sol\";\n\n\n/**\n  * @title OpenLevDelegator\n  * @author OpenLeverage\n  */\ncontract OpenLevDelegator is DelegatorInterface, Adminable {\n\n    constructor(\n        address _controller,\n        address _dexAggregator,\n        address[] memory _depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs,\n        address payable _admin,\n        address implementation_){\n        admin = msg.sender;\n        // Creator of the contract is admin during initialization\n        // First delegate gets to initialize the delegator (i.e. storage contract)\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address[],address,address,uint8[])\",\n            _controller,\n            _dexAggregator,\n            _depositTokens,\n            _wETH,\n            _xOLE,\n            _supportDexs\n            ));\n        implementation = implementation_;\n\n        // Set the proper admin now that initialization is done\n        admin = _admin;\n    }\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public override onlyAdmin {\n        address oldImplementation = implementation;\n        implementation = implementation_;\n        emit NewImplementation(oldImplementation, implementation);\n    }\n}\n"
6     },
7     "/contracts/DelegatorInterface.sol": {
8       "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nabstract contract DelegatorInterface {\n    /**\n     * Implementation address for this contract\n     */\n    address public implementation;\n\n    /**\n     * Emitted when implementation is changed\n     */\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /**\n     * Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function setImplementation(address implementation_) public virtual;\n\n\n    /**\n    * Internal method to delegate execution to another contract\n    * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n    * @param callee The contract to delegatecall\n    * @param data The raw data to delegatecall\n    * @return The returned bytes from the delegatecall\n    */\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {revert(add(returnData, 0x20), returndatasize())}\n        }\n        return returnData;\n    }\n\n    /**\n     * Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n        return delegateTo(implementation, data);\n    }\n\n    /**\n     * Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n        assembly {\n            if eq(success, 0) {revert(add(returnData, 0x20), returndatasize())}\n        }\n        return abi.decode(returnData, (bytes));\n    }\n    /**\n    * Delegates execution to an implementation contract\n    * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n    */\n    fallback() external payable {\n        _fallback();\n    }\n\n    receive() external payable {\n        _fallback();\n    }\n\n    function _fallback() internal {\n        // delegate all other functions to current implementation\n        if (msg.data.length > 0) {\n            (bool success,) = implementation.delegatecall(msg.data);\n            assembly {\n                let free_mem_ptr := mload(0x40)\n                returndatacopy(free_mem_ptr, 0, returndatasize())\n                switch success\n                case 0 {revert(free_mem_ptr, returndatasize())}\n                default {return (free_mem_ptr, returndatasize())}\n            }\n        }\n    }\n}\n"
9     },
10     "/contracts/Adminable.sol": {
11       "content": "// SPDX-License-Identifier: BUSL-1.1\n\n\npragma solidity 0.7.6;\n\nabstract contract Adminable {\n    address payable public admin;\n    address payable public pendingAdmin;\n    address payable public developer;\n\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n    constructor () {\n        developer = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"caller must be admin\");\n        _;\n    }\n    modifier onlyAdminOrDeveloper() {\n        require(msg.sender == admin || msg.sender == developer, \"caller must be admin or developer\");\n        _;\n    }\n\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    }\n\n    function acceptAdmin() external virtual {\n        require(msg.sender == pendingAdmin, \"only pendingAdmin can accept admin\");\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = address(0);\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    }\n\n}\n"
12     }
13   },
14   "settings": {
15     "remappings": [],
16     "optimizer": {
17       "enabled": true,
18       "runs": 200
19     },
20     "evmVersion": "istanbul",
21     "libraries": {},
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     }
34   }
35 }}