1 /*
2  * This contract was generated by Wechain Network (https://wechain.network/)
3  * Copyright (C) 2018 Wechain Network
4  */
5 pragma solidity ^0.4.23;
6 
7 contract ERC20Basic {
8   function totalSupply() public view returns (uint256);
9   function balanceOf(address who) public view returns (uint256);
10   function transfer(address to, uint256 value) public returns (bool);
11   event Transfer(address indexed from, address indexed to, uint256 value);
12 }
13 
14 library SafeMath {
15 
16   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
17     if (a == 0) {
18       return 0;
19     }
20 
21     c = a * b;
22     assert(c / a == b);
23     return c;
24   }
25 
26   function div(uint256 a, uint256 b) internal pure returns (uint256) {
27     return a / b;
28   }
29 
30   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
31     assert(b <= a);
32     return a - b;
33   }
34 
35   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
36     c = a + b;
37     assert(c >= a);
38     return c;
39   }
40 }
41 
42 contract BasicToken is ERC20Basic {
43   using SafeMath for uint256;
44 
45   mapping(address => uint256) balances;
46 
47   uint256 totalSupply_;
48 
49   function totalSupply() public view returns (uint256) {
50     return totalSupply_;
51   }
52 
53   function transfer(address _to, uint256 _value) public returns (bool) {
54     require(_to != address(0));
55     require(_value <= balances[msg.sender]);
56 
57     balances[msg.sender] = balances[msg.sender].sub(_value);
58     balances[_to] = balances[_to].add(_value);
59     emit Transfer(msg.sender, _to, _value);
60     return true;
61   }
62 
63   function balanceOf(address _owner) public view returns (uint256) {
64     return balances[_owner];
65   }
66 
67 }
68 
69 contract ERC20 is ERC20Basic {
70   function allowance(address owner, address spender)
71     public view returns (uint256);
72 
73   function transferFrom(address from, address to, uint256 value)
74     public returns (bool);
75 
76   function approve(address spender, uint256 value) public returns (bool);
77   event Approval(
78     address indexed owner,
79     address indexed spender,
80     uint256 value
81   );
82 }
83 
84 contract StandardToken is ERC20, BasicToken {
85 
86   mapping (address => mapping (address => uint256)) internal allowed;
87 
88   function transferFrom(
89     address _from,
90     address _to,
91     uint256 _value
92   )
93     public
94     returns (bool)
95   {
96     require(_to != address(0));
97     require(_value <= balances[_from]);
98     require(_value <= allowed[_from][msg.sender]);
99 
100     balances[_from] = balances[_from].sub(_value);
101     balances[_to] = balances[_to].add(_value);
102     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
103     emit Transfer(_from, _to, _value);
104     return true;
105   }
106 
107   function approve(address _spender, uint256 _value) public returns (bool) {
108     allowed[msg.sender][_spender] = _value;
109     emit Approval(msg.sender, _spender, _value);
110     return true;
111   }
112 
113   function allowance(
114     address _owner,
115     address _spender
116    )
117     public
118     view
119     returns (uint256)
120   {
121     return allowed[_owner][_spender];
122   }
123 
124   function increaseApproval(
125     address _spender,
126     uint _addedValue
127   )
128     public
129     returns (bool)
130   {
131     allowed[msg.sender][_spender] = (
132       allowed[msg.sender][_spender].add(_addedValue));
133     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
134     return true;
135   }
136 
137   function decreaseApproval(
138     address _spender,
139     uint _subtractedValue
140   )
141     public
142     returns (bool)
143   {
144     uint oldValue = allowed[msg.sender][_spender];
145     if (_subtractedValue > oldValue) {
146       allowed[msg.sender][_spender] = 0;
147     } else {
148       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
149     }
150     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
151     return true;
152   }
153 
154 }
155 
156 contract Ownable {
157   address public owner;
158 
159 
160   event OwnershipRenounced(address indexed previousOwner);
161   event OwnershipTransferred(
162     address indexed previousOwner,
163     address indexed newOwner
164   );
165 
166   constructor() public {
167     owner = msg.sender;
168   }
169 
170   modifier onlyOwner() {
171     require(msg.sender == owner);
172     _;
173   }
174 
175   function renounceOwnership() public onlyOwner {
176     emit OwnershipRenounced(owner);
177     owner = address(0);
178   }
179 
180   function transferOwnership(address _newOwner) public onlyOwner {
181     _transferOwnership(_newOwner);
182   }
183 
184   function _transferOwnership(address _newOwner) internal {
185     require(_newOwner != address(0));
186     emit OwnershipTransferred(owner, _newOwner);
187     owner = _newOwner;
188   }
189 }
190 
191 contract MintableToken is StandardToken, Ownable {
192   event Mint(address indexed to, uint256 amount);
193   event MintFinished();
194 
195   bool public mintingFinished = false;
196 
197 
198   modifier canMint() {
199     require(!mintingFinished);
200     _;
201   }
202 
203   modifier hasMintPermission() {
204     require(msg.sender == owner);
205     _;
206   }
207 
208   function mint(
209     address _to,
210     uint256 _amount
211   )
212     hasMintPermission
213     canMint
214     public
215     returns (bool)
216   {
217     totalSupply_ = totalSupply_.add(_amount);
218     balances[_to] = balances[_to].add(_amount);
219     emit Mint(_to, _amount);
220     emit Transfer(address(0), _to, _amount);
221     return true;
222   }
223 
224   function finishMinting() onlyOwner canMint public returns (bool) {
225     mintingFinished = true;
226     emit MintFinished();
227     return true;
228   }
229 }
230 
231 contract FreezableToken is StandardToken {
232 
233     mapping (bytes32 => uint64) internal chains;
234 
235     mapping (bytes32 => uint) internal freezings;
236 
237     mapping (address => uint) internal freezingBalance;
238 
239     event Freezed(address indexed to, uint64 release, uint amount);
240     event Released(address indexed owner, uint amount);
241 
242     function balanceOf(address _owner) public view returns (uint256 balance) {
243         return super.balanceOf(_owner) + freezingBalance[_owner];
244     }
245 
246     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
247         return super.balanceOf(_owner);
248     }
249 
250     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
251         return freezingBalance[_owner];
252     }
253 
254     function freezingCount(address _addr) public view returns (uint count) {
255         uint64 release = chains[toKey(_addr, 0)];
256         while (release != 0) {
257             count++;
258             release = chains[toKey(_addr, release)];
259         }
260     }
261 
262     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
263         for (uint i = 0; i < _index + 1; i++) {
264             _release = chains[toKey(_addr, _release)];
265             if (_release == 0) {
266                 return;
267             }
268         }
269         _balance = freezings[toKey(_addr, _release)];
270     }
271 
272     function freezeTo(address _to, uint _amount, uint64 _until) public {
273         require(_to != address(0));
274         require(_amount <= balances[msg.sender]);
275 
276         balances[msg.sender] = balances[msg.sender].sub(_amount);
277 
278         bytes32 currentKey = toKey(_to, _until);
279         freezings[currentKey] = freezings[currentKey].add(_amount);
280         freezingBalance[_to] = freezingBalance[_to].add(_amount);
281 
282         freeze(_to, _until);
283         emit Transfer(msg.sender, _to, _amount);
284         emit Freezed(_to, _until, _amount);
285     }
286 
287     function releaseOnce() public {
288         bytes32 headKey = toKey(msg.sender, 0);
289         uint64 head = chains[headKey];
290         require(head != 0);
291         require(uint64(block.timestamp) > head);
292         bytes32 currentKey = toKey(msg.sender, head);
293 
294         uint64 next = chains[currentKey];
295 
296         uint amount = freezings[currentKey];
297         delete freezings[currentKey];
298 
299         balances[msg.sender] = balances[msg.sender].add(amount);
300         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
301 
302         if (next == 0) {
303             delete chains[headKey];
304         } else {
305             chains[headKey] = next;
306             delete chains[currentKey];
307         }
308         emit Released(msg.sender, amount);
309     }
310 
311     function releaseAll() public returns (uint tokens) {
312         uint release;
313         uint balance;
314         (release, balance) = getFreezing(msg.sender, 0);
315         while (release != 0 && block.timestamp > release) {
316             releaseOnce();
317             tokens += balance;
318             (release, balance) = getFreezing(msg.sender, 0);
319         }
320     }
321 
322     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
323         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
324         assembly {
325             result := or(result, mul(_addr, 0x10000000000000000))
326             result := or(result, _release)
327         }
328     }
329 
330     function freeze(address _to, uint64 _until) internal {
331         require(_until > block.timestamp);
332         bytes32 key = toKey(_to, _until);
333         bytes32 parentKey = toKey(_to, uint64(0));
334         uint64 next = chains[parentKey];
335 
336         if (next == 0) {
337             chains[parentKey] = _until;
338             return;
339         }
340 
341         bytes32 nextKey = toKey(_to, next);
342         uint parent;
343 
344         while (next != 0 && _until > next) {
345             parent = next;
346             parentKey = nextKey;
347 
348             next = chains[nextKey];
349             nextKey = toKey(_to, next);
350         }
351 
352         if (_until == next) {
353             return;
354         }
355 
356         if (next != 0) {
357             chains[key] = next;
358         }
359 
360         chains[parentKey] = _until;
361     }
362 }
363 
364 contract BurnableToken is BasicToken {
365 
366   event Burn(address indexed burner, uint256 value);
367 
368   function burn(uint256 _value) public {
369     _burn(msg.sender, _value);
370   }
371 
372   function _burn(address _who, uint256 _value) internal {
373     require(_value <= balances[_who]);
374 
375     balances[_who] = balances[_who].sub(_value);
376     totalSupply_ = totalSupply_.sub(_value);
377     emit Burn(_who, _value);
378     emit Transfer(_who, address(0), _value);
379   }
380 }
381 
382 contract Pausable is Ownable {
383   event Pause();
384   event Unpause();
385 
386   bool public paused = false;
387 
388   modifier whenNotPaused() {
389     require(!paused);
390     _;
391   }
392 
393   modifier whenPaused() {
394     require(paused);
395     _;
396   }
397 
398   function pause() onlyOwner whenNotPaused public {
399     paused = true;
400     emit Pause();
401   }
402 
403   function unpause() onlyOwner whenPaused public {
404     paused = false;
405     emit Unpause();
406   }
407 }
408 
409 
410 contract FreezableMintableToken is FreezableToken, MintableToken {
411 
412     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
413         totalSupply_ = totalSupply_.add(_amount);
414 
415         bytes32 currentKey = toKey(_to, _until);
416         freezings[currentKey] = freezings[currentKey].add(_amount);
417         freezingBalance[_to] = freezingBalance[_to].add(_amount);
418 
419         freeze(_to, _until);
420         emit Mint(_to, _amount);
421         emit Freezed(_to, _until, _amount);
422         emit Transfer(msg.sender, _to, _amount);
423         return true;
424     }
425 }
426 
427 
428 
429 contract Consts {
430     uint public constant TOKEN_DECIMALS = 2;
431     uint8 public constant TOKEN_DECIMALS_UINT8 = 2;
432     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
433 
434     string public constant TOKEN_NAME = "Wechain Network";
435     string public constant TOKEN_SYMBOL = "WCN";
436     bool public constant PAUSED = false;
437     address public constant TARGET_USER = 0x031e4bd2fa0bbdccf4d97b66abacb190c06aa3fc;
438     
439     bool public constant CONTINUE_MINTING = false;
440 }
441 
442 
443 
444 
445 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
446     
447 {
448     
449     event Initialized();
450     bool public initialized = false;
451 
452     constructor() public {
453         init();
454         transferOwnership(TARGET_USER);
455     }
456     
457 
458     function name() public pure returns (string _name) {
459         return TOKEN_NAME;
460     }
461 
462     function symbol() public pure returns (string _symbol) {
463         return TOKEN_SYMBOL;
464     }
465 
466     function decimals() public pure returns (uint8 _decimals) {
467         return TOKEN_DECIMALS_UINT8;
468     }
469 
470     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
471         require(!paused);
472         return super.transferFrom(_from, _to, _value);
473     }
474 
475     function transfer(address _to, uint256 _value) public returns (bool _success) {
476         require(!paused);
477         return super.transfer(_to, _value);
478     }
479 
480     
481     function init() private {
482         require(!initialized);
483         initialized = true;
484 
485         if (PAUSED) {
486             pause();
487         }
488 
489         
490         address[5] memory addresses = [address(0x58aba8ea204307af256e376ae6a4fe5892c73ea2),address(0x2fd2cbd43d3d1216b6396d9a66119f3f5f3240ae),address(0xc4aab1d48115b48612a87cea26e4f26dd3829354),address(0x0ed43f37598070d7d1c7909d545b96bc2d2e6604),address(0x96abb03c10194606c747d85f5a13911ba5a44920)];
491         uint[5] memory amounts = [uint(300000000000),uint(50000000000),uint(400000000000),uint(100000000000),uint(150000000000)];
492         uint64[5] memory freezes = [uint64(0),uint64(0),uint64(0),uint64(0),uint64(1544547601)];
493 
494         for (uint i = 0; i < addresses.length; i++) {
495             if (freezes[i] == 0) {
496                 mint(addresses[i], amounts[i]);
497             } else {
498                 mintAndFreeze(addresses[i], amounts[i], freezes[i]);
499             }
500         }
501         
502 
503         if (!CONTINUE_MINTING) {
504             finishMinting();
505         }
506 
507         emit Initialized();
508     }
509     
510 }