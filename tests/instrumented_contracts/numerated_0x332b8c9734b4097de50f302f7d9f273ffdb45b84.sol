1 
2 // File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol
3 
4 pragma solidity ^0.5.0;
5 
6 /**
7  * @title Elliptic curve signature operations
8  * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d
9  * TODO Remove this library once solidity supports passing a signature to ecrecover.
10  * See https://github.com/ethereum/solidity/issues/864
11  */
12 
13 library ECDSA {
14     /**
15      * @dev Recover signer address from a message by using their signature
16      * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
17      * @param signature bytes signature, the signature is generated using web3.eth.sign()
18      */
19     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
20         bytes32 r;
21         bytes32 s;
22         uint8 v;
23 
24         // Check the signature length
25         if (signature.length != 65) {
26             return (address(0));
27         }
28 
29         // Divide the signature in r, s and v variables
30         // ecrecover takes the signature parameters, and the only way to get them
31         // currently is to use assembly.
32         // solhint-disable-next-line no-inline-assembly
33         assembly {
34             r := mload(add(signature, 0x20))
35             s := mload(add(signature, 0x40))
36             v := byte(0, mload(add(signature, 0x60)))
37         }
38 
39         // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
40         if (v < 27) {
41             v += 27;
42         }
43 
44         // If the version is correct return the signer address
45         if (v != 27 && v != 28) {
46             return (address(0));
47         } else {
48             return ecrecover(hash, v, r, s);
49         }
50     }
51 
52     /**
53      * toEthSignedMessageHash
54      * @dev prefix a bytes32 value with "\x19Ethereum Signed Message:"
55      * and hash the result
56      */
57     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
58         // 32 is the length in bytes of hash,
59         // enforced by the type signature above
60         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
61     }
62 }
63 
64 // File: contracts/votingMachines/IntVoteInterface.sol
65 
66 pragma solidity ^0.5.4;
67 
68 interface IntVoteInterface {
69     //When implementing this interface please do not only override function and modifier,
70     //but also to keep the modifiers on the overridden functions.
71     modifier onlyProposalOwner(bytes32 _proposalId) {revert(); _;}
72     modifier votable(bytes32 _proposalId) {revert(); _;}
73 
74     event NewProposal(
75         bytes32 indexed _proposalId,
76         address indexed _organization,
77         uint256 _numOfChoices,
78         address _proposer,
79         bytes32 _paramsHash
80     );
81 
82     event ExecuteProposal(bytes32 indexed _proposalId,
83         address indexed _organization,
84         uint256 _decision,
85         uint256 _totalReputation
86     );
87 
88     event VoteProposal(
89         bytes32 indexed _proposalId,
90         address indexed _organization,
91         address indexed _voter,
92         uint256 _vote,
93         uint256 _reputation
94     );
95 
96     event CancelProposal(bytes32 indexed _proposalId, address indexed _organization );
97     event CancelVoting(bytes32 indexed _proposalId, address indexed _organization, address indexed _voter);
98 
99     /**
100      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
101      * generated by calculating keccak256 of a incremented counter.
102      * @param _numOfChoices number of voting choices
103      * @param _proposalParameters defines the parameters of the voting machine used for this proposal
104      * @param _proposer address
105      * @param _organization address - if this address is zero the msg.sender will be used as the organization address.
106      * @return proposal's id.
107      */
108     function propose(
109         uint256 _numOfChoices,
110         bytes32 _proposalParameters,
111         address _proposer,
112         address _organization
113         ) external returns(bytes32);
114 
115     function vote(
116         bytes32 _proposalId,
117         uint256 _vote,
118         uint256 _rep,
119         address _voter
120     )
121     external
122     returns(bool);
123 
124     function cancelVote(bytes32 _proposalId) external;
125 
126     function getNumberOfChoices(bytes32 _proposalId) external view returns(uint256);
127 
128     function isVotable(bytes32 _proposalId) external view returns(bool);
129 
130     /**
131      * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
132      * @param _proposalId the ID of the proposal
133      * @param _choice the index in the
134      * @return voted reputation for the given choice
135      */
136     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256);
137 
138     /**
139      * @dev isAbstainAllow returns if the voting machine allow abstain (0)
140      * @return bool true or false
141      */
142     function isAbstainAllow() external pure returns(bool);
143 
144     /**
145      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
146      * @return min - minimum number of choices
147                max - maximum number of choices
148      */
149     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max);
150 }
151 
152 // File: contracts/libs/RealMath.sol
153 
154 pragma solidity ^0.5.4;
155 
156 /**
157  * RealMath: fixed-point math library, based on fractional and integer parts.
158  * Using uint256 as real216x40, which isn't in Solidity yet.
159  * Internally uses the wider uint256 for some math.
160  *
161  * Note that for addition, subtraction, and mod (%), you should just use the
162  * built-in Solidity operators. Functions for these operations are not provided.
163  *
164  */
165 
166 
167 library RealMath {
168 
169     /**
170      * How many total bits are there?
171      */
172     uint256 constant private REAL_BITS = 256;
173 
174     /**
175      * How many fractional bits are there?
176      */
177     uint256 constant private REAL_FBITS = 40;
178 
179     /**
180      * What's the first non-fractional bit
181      */
182     uint256 constant private REAL_ONE = uint256(1) << REAL_FBITS;
183 
184     /**
185      * Raise a real number to any positive integer power
186      */
187     function pow(uint256 realBase, uint256 exponent) internal pure returns (uint256) {
188 
189         uint256 tempRealBase = realBase;
190         uint256 tempExponent = exponent;
191 
192         // Start with the 0th power
193         uint256 realResult = REAL_ONE;
194         while (tempExponent != 0) {
195             // While there are still bits set
196             if ((tempExponent & 0x1) == 0x1) {
197                 // If the low bit is set, multiply in the (many-times-squared) base
198                 realResult = mul(realResult, tempRealBase);
199             }
200                 // Shift off the low bit
201             tempExponent = tempExponent >> 1;
202             if (tempExponent != 0) {
203                 // Do the squaring
204                 tempRealBase = mul(tempRealBase, tempRealBase);
205             }
206         }
207 
208         // Return the final result.
209         return realResult;
210     }
211 
212     /**
213      * Create a real from a rational fraction.
214      */
215     function fraction(uint216 numerator, uint216 denominator) internal pure returns (uint256) {
216         return div(uint256(numerator) * REAL_ONE, uint256(denominator) * REAL_ONE);
217     }
218 
219     /**
220      * Multiply one real by another. Truncates overflows.
221      */
222     function mul(uint256 realA, uint256 realB) private pure returns (uint256) {
223         // When multiplying fixed point in x.y and z.w formats we get (x+z).(y+w) format.
224         // So we just have to clip off the extra REAL_FBITS fractional bits.
225         uint256 res = realA * realB;
226         require(res/realA == realB, "RealMath mul overflow");
227         return (res >> REAL_FBITS);
228     }
229 
230     /**
231      * Divide one real by another real. Truncates overflows.
232      */
233     function div(uint256 realNumerator, uint256 realDenominator) private pure returns (uint256) {
234         // We use the reverse of the multiplication trick: convert numerator from
235         // x.y to (x+z).(y+w) fixed point, then divide by denom in z.w fixed point.
236         return uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator));
237     }
238 
239 }
240 
241 // File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol
242 
243 pragma solidity ^0.5.0;
244 
245 /**
246  * @title ERC20 interface
247  * @dev see https://github.com/ethereum/EIPs/issues/20
248  */
249 interface IERC20 {
250     function transfer(address to, uint256 value) external returns (bool);
251 
252     function approve(address spender, uint256 value) external returns (bool);
253 
254     function transferFrom(address from, address to, uint256 value) external returns (bool);
255 
256     function totalSupply() external view returns (uint256);
257 
258     function balanceOf(address who) external view returns (uint256);
259 
260     function allowance(address owner, address spender) external view returns (uint256);
261 
262     event Transfer(address indexed from, address indexed to, uint256 value);
263 
264     event Approval(address indexed owner, address indexed spender, uint256 value);
265 }
266 
267 // File: contracts/votingMachines/VotingMachineCallbacksInterface.sol
268 
269 pragma solidity ^0.5.4;
270 
271 
272 interface VotingMachineCallbacksInterface {
273     function mintReputation(uint256 _amount, address _beneficiary, bytes32 _proposalId) external returns(bool);
274     function burnReputation(uint256 _amount, address _owner, bytes32 _proposalId) external returns(bool);
275 
276     function stakingTokenTransfer(IERC20 _stakingToken, address _beneficiary, uint256 _amount, bytes32 _proposalId)
277     external
278     returns(bool);
279 
280     function getTotalReputationSupply(bytes32 _proposalId) external view returns(uint256);
281     function reputationOf(address _owner, bytes32 _proposalId) external view returns(uint256);
282     function balanceOfStakingToken(IERC20 _stakingToken, bytes32 _proposalId) external view returns(uint256);
283 }
284 
285 // File: contracts/votingMachines/ProposalExecuteInterface.sol
286 
287 pragma solidity ^0.5.4;
288 
289 interface ProposalExecuteInterface {
290     function executeProposal(bytes32 _proposalId, int _decision) external returns(bool);
291 }
292 
293 // File: openzeppelin-solidity/contracts/math/SafeMath.sol
294 
295 pragma solidity ^0.5.0;
296 
297 /**
298  * @title SafeMath
299  * @dev Unsigned math operations with safety checks that revert on error
300  */
301 library SafeMath {
302     /**
303     * @dev Multiplies two unsigned integers, reverts on overflow.
304     */
305     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
306         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
307         // benefit is lost if 'b' is also tested.
308         // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
309         if (a == 0) {
310             return 0;
311         }
312 
313         uint256 c = a * b;
314         require(c / a == b);
315 
316         return c;
317     }
318 
319     /**
320     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.
321     */
322     function div(uint256 a, uint256 b) internal pure returns (uint256) {
323         // Solidity only automatically asserts when dividing by 0
324         require(b > 0);
325         uint256 c = a / b;
326         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
327 
328         return c;
329     }
330 
331     /**
332     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).
333     */
334     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
335         require(b <= a);
336         uint256 c = a - b;
337 
338         return c;
339     }
340 
341     /**
342     * @dev Adds two unsigned integers, reverts on overflow.
343     */
344     function add(uint256 a, uint256 b) internal pure returns (uint256) {
345         uint256 c = a + b;
346         require(c >= a);
347 
348         return c;
349     }
350 
351     /**
352     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),
353     * reverts when dividing by zero.
354     */
355     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
356         require(b != 0);
357         return a % b;
358     }
359 }
360 
361 // File: openzeppelin-solidity/contracts/math/Math.sol
362 
363 pragma solidity ^0.5.0;
364 
365 /**
366  * @title Math
367  * @dev Assorted math operations
368  */
369 library Math {
370     /**
371     * @dev Returns the largest of two numbers.
372     */
373     function max(uint256 a, uint256 b) internal pure returns (uint256) {
374         return a >= b ? a : b;
375     }
376 
377     /**
378     * @dev Returns the smallest of two numbers.
379     */
380     function min(uint256 a, uint256 b) internal pure returns (uint256) {
381         return a < b ? a : b;
382     }
383 
384     /**
385     * @dev Calculates the average of two numbers. Since these are integers,
386     * averages of an even and odd number cannot be represented, and will be
387     * rounded down.
388     */
389     function average(uint256 a, uint256 b) internal pure returns (uint256) {
390         // (a + b) / 2 can overflow, so we distribute
391         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
392     }
393 }
394 
395 // File: openzeppelin-solidity/contracts/utils/Address.sol
396 
397 pragma solidity ^0.5.0;
398 
399 /**
400  * Utility library of inline functions on addresses
401  */
402 library Address {
403     /**
404      * Returns whether the target address is a contract
405      * @dev This function will return false if invoked during the constructor of a contract,
406      * as the code is not actually created until after the constructor finishes.
407      * @param account address of the account to check
408      * @return whether the target address is a contract
409      */
410     function isContract(address account) internal view returns (bool) {
411         uint256 size;
412         // XXX Currently there is no better way to check if there is a contract in an address
413         // than to check the size of the code at that address.
414         // See https://ethereum.stackexchange.com/a/14016/36603
415         // for more details about how this works.
416         // TODO Check this again before the Serenity release, because all addresses will be
417         // contracts then.
418         // solhint-disable-next-line no-inline-assembly
419         assembly { size := extcodesize(account) }
420         return size > 0;
421     }
422 }
423 
424 // File: contracts/votingMachines/GenesisProtocolLogic.sol
425 
426 pragma solidity ^0.5.4;
427 
428 
429 
430 
431 
432 
433 
434 
435 
436 
437 
438 /**
439  * @title GenesisProtocol implementation -an organization's voting machine scheme.
440  */
441 contract GenesisProtocolLogic is IntVoteInterface {
442     using SafeMath for uint256;
443     using Math for uint256;
444     using RealMath for uint216;
445     using RealMath for uint256;
446     using Address for address;
447 
448     enum ProposalState { None, ExpiredInQueue, Executed, Queued, PreBoosted, Boosted, QuietEndingPeriod}
449     enum ExecutionState { None, QueueBarCrossed, QueueTimeOut, PreBoostedBarCrossed, BoostedTimeOut, BoostedBarCrossed}
450 
451     //Organization's parameters
452     struct Parameters {
453         uint256 queuedVoteRequiredPercentage; // the absolute vote percentages bar.
454         uint256 queuedVotePeriodLimit; //the time limit for a proposal to be in an absolute voting mode.
455         uint256 boostedVotePeriodLimit; //the time limit for a proposal to be in boost mode.
456         uint256 preBoostedVotePeriodLimit; //the time limit for a proposal
457                                           //to be in an preparation state (stable) before boosted.
458         uint256 thresholdConst; //constant  for threshold calculation .
459                                 //threshold =thresholdConst ** (numberOfBoostedProposals)
460         uint256 limitExponentValue;// an upper limit for numberOfBoostedProposals
461                                    //in the threshold calculation to prevent overflow
462         uint256 quietEndingPeriod; //quite ending period
463         uint256 proposingRepReward;//proposer reputation reward.
464         uint256 votersReputationLossRatio;//Unsuccessful pre booster
465                                           //voters lose votersReputationLossRatio% of their reputation.
466         uint256 minimumDaoBounty;
467         uint256 daoBountyConst;//The DAO downstake for each proposal is calculate according to the formula
468                                //(daoBountyConst * averageBoostDownstakes)/100 .
469         uint256 activationTime;//the point in time after which proposals can be created.
470         //if this address is set so only this address is allowed to vote of behalf of someone else.
471         address voteOnBehalf;
472     }
473 
474     struct Voter {
475         uint256 vote; // YES(1) ,NO(2)
476         uint256 reputation; // amount of voter's reputation
477         bool preBoosted;
478     }
479 
480     struct Staker {
481         uint256 vote; // YES(1) ,NO(2)
482         uint256 amount; // amount of staker's stake
483         uint256 amount4Bounty;// amount of staker's stake used for bounty reward calculation.
484     }
485 
486     struct Proposal {
487         bytes32 organizationId; // the organization unique identifier the proposal is target to.
488         address callbacks;    // should fulfill voting callbacks interface.
489         ProposalState state;
490         uint256 winningVote; //the winning vote.
491         address proposer;
492         //the proposal boosted period limit . it is updated for the case of quiteWindow mode.
493         uint256 currentBoostedVotePeriodLimit;
494         bytes32 paramsHash;
495         uint256 daoBountyRemain; //use for checking sum zero bounty claims.it is set at the proposing time.
496         uint256 daoBounty;
497         uint256 totalStakes;// Total number of tokens staked which can be redeemable by stakers.
498         uint256 confidenceThreshold;
499         uint256 secondsFromTimeOutTillExecuteBoosted;
500         uint[3] times; //times[0] - submittedTime
501                        //times[1] - boostedPhaseTime
502                        //times[2] -preBoostedPhaseTime;
503         bool daoRedeemItsWinnings;
504         //      vote      reputation
505         mapping(uint256   =>  uint256    ) votes;
506         //      vote      reputation
507         mapping(uint256   =>  uint256    ) preBoostedVotes;
508         //      address     voter
509         mapping(address =>  Voter    ) voters;
510         //      vote        stakes
511         mapping(uint256   =>  uint256    ) stakes;
512         //      address  staker
513         mapping(address  => Staker   ) stakers;
514     }
515 
516     event Stake(bytes32 indexed _proposalId,
517         address indexed _organization,
518         address indexed _staker,
519         uint256 _vote,
520         uint256 _amount
521     );
522 
523     event Redeem(bytes32 indexed _proposalId,
524         address indexed _organization,
525         address indexed _beneficiary,
526         uint256 _amount
527     );
528 
529     event RedeemDaoBounty(bytes32 indexed _proposalId,
530         address indexed _organization,
531         address indexed _beneficiary,
532         uint256 _amount
533     );
534 
535     event RedeemReputation(bytes32 indexed _proposalId,
536         address indexed _organization,
537         address indexed _beneficiary,
538         uint256 _amount
539     );
540 
541     event StateChange(bytes32 indexed _proposalId, ProposalState _proposalState);
542     event GPExecuteProposal(bytes32 indexed _proposalId, ExecutionState _executionState);
543     event ExpirationCallBounty(bytes32 indexed _proposalId, address indexed _beneficiary, uint256 _amount);
544     event ConfidenceLevelChange(bytes32 indexed _proposalId, uint256 _confidenceThreshold);
545 
546     mapping(bytes32=>Parameters) public parameters;  // A mapping from hashes to parameters
547     mapping(bytes32=>Proposal) public proposals; // Mapping from the ID of the proposal to the proposal itself.
548     mapping(bytes32=>uint) public orgBoostedProposalsCnt;
549            //organizationId => organization
550     mapping(bytes32        => address     ) public organizations;
551           //organizationId => averageBoostDownstakes
552     mapping(bytes32           => uint256              ) public averagesDownstakesOfBoosted;
553     uint256 constant public NUM_OF_CHOICES = 2;
554     uint256 constant public NO = 2;
555     uint256 constant public YES = 1;
556     uint256 public proposalsCnt; // Total number of proposals
557     IERC20 public stakingToken;
558     address constant private GEN_TOKEN_ADDRESS = 0x543Ff227F64Aa17eA132Bf9886cAb5DB55DCAddf;
559     uint256 constant private MAX_BOOSTED_PROPOSALS = 4096;
560 
561     /**
562      * @dev Constructor
563      */
564     constructor(IERC20 _stakingToken) public {
565       //The GEN token (staking token) address is hard coded in the contract by GEN_TOKEN_ADDRESS .
566       //This will work for a network which already hosted the GEN token on this address (e.g mainnet).
567       //If such contract address does not exist in the network (e.g ganache)
568       //the contract will use the _stakingToken param as the
569       //staking token address.
570         if (address(GEN_TOKEN_ADDRESS).isContract()) {
571             stakingToken = IERC20(GEN_TOKEN_ADDRESS);
572         } else {
573             stakingToken = _stakingToken;
574         }
575     }
576 
577   /**
578    * @dev Check that the proposal is votable
579    * a proposal is votable if it is in one of the following states:
580    *  PreBoosted,Boosted,QuietEndingPeriod or Queued
581    */
582     modifier votable(bytes32 _proposalId) {
583         require(_isVotable(_proposalId));
584         _;
585     }
586 
587     /**
588      * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being
589      * generated by calculating keccak256 of a incremented counter.
590      * @param _paramsHash parameters hash
591      * @param _proposer address
592      * @param _organization address
593      */
594     function propose(uint256, bytes32 _paramsHash, address _proposer, address _organization)
595         external
596         returns(bytes32)
597     {
598       // solhint-disable-next-line not-rely-on-time
599         require(now > parameters[_paramsHash].activationTime, "not active yet");
600         //Check parameters existence.
601         require(parameters[_paramsHash].queuedVoteRequiredPercentage >= 50);
602         // Generate a unique ID:
603         bytes32 proposalId = keccak256(abi.encodePacked(this, proposalsCnt));
604         proposalsCnt = proposalsCnt.add(1);
605          // Open proposal:
606         Proposal memory proposal;
607         proposal.callbacks = msg.sender;
608         proposal.organizationId = keccak256(abi.encodePacked(msg.sender, _organization));
609 
610         proposal.state = ProposalState.Queued;
611         // solhint-disable-next-line not-rely-on-time
612         proposal.times[0] = now;//submitted time
613         proposal.currentBoostedVotePeriodLimit = parameters[_paramsHash].boostedVotePeriodLimit;
614         proposal.proposer = _proposer;
615         proposal.winningVote = NO;
616         proposal.paramsHash = _paramsHash;
617         if (organizations[proposal.organizationId] == address(0)) {
618             if (_organization == address(0)) {
619                 organizations[proposal.organizationId] = msg.sender;
620             } else {
621                 organizations[proposal.organizationId] = _organization;
622             }
623         }
624         //calc dao bounty
625         uint256 daoBounty =
626         parameters[_paramsHash].daoBountyConst.mul(averagesDownstakesOfBoosted[proposal.organizationId]).div(100);
627         proposal.daoBountyRemain = daoBounty.max(parameters[_paramsHash].minimumDaoBounty);
628         proposals[proposalId] = proposal;
629         proposals[proposalId].stakes[NO] = proposal.daoBountyRemain;//dao downstake on the proposal
630 
631         emit NewProposal(proposalId, organizations[proposal.organizationId], NUM_OF_CHOICES, _proposer, _paramsHash);
632         return proposalId;
633     }
634 
635     /**
636       * @dev executeBoosted try to execute a boosted or QuietEndingPeriod proposal if it is expired
637       * it rewards the msg.sender with P % of the proposal's upstakes upon a successful call to this function.
638       * P = t/150, where t is the number of seconds passed since the the proposal's timeout.
639       * P is capped by 10%.
640       * @param _proposalId the id of the proposal
641       * @return uint256 expirationCallBounty the bounty amount for the expiration call
642      */
643     function executeBoosted(bytes32 _proposalId) external returns(uint256 expirationCallBounty) {
644         Proposal storage proposal = proposals[_proposalId];
645         require(proposal.state == ProposalState.Boosted || proposal.state == ProposalState.QuietEndingPeriod,
646         "proposal state in not Boosted nor QuietEndingPeriod");
647         require(_execute(_proposalId), "proposal need to expire");
648 
649         proposal.secondsFromTimeOutTillExecuteBoosted =
650         // solhint-disable-next-line not-rely-on-time
651         now.sub(proposal.currentBoostedVotePeriodLimit.add(proposal.times[1]));
652 
653         expirationCallBounty = calcExecuteCallBounty(_proposalId);
654         proposal.totalStakes = proposal.totalStakes.sub(expirationCallBounty);
655         require(stakingToken.transfer(msg.sender, expirationCallBounty), "transfer to msg.sender failed");
656         emit ExpirationCallBounty(_proposalId, msg.sender, expirationCallBounty);
657     }
658 
659     /**
660      * @dev hash the parameters, save them if necessary, and return the hash value
661      * @param _params a parameters array
662      *    _params[0] - _queuedVoteRequiredPercentage,
663      *    _params[1] - _queuedVotePeriodLimit, //the time limit for a proposal to be in an absolute voting mode.
664      *    _params[2] - _boostedVotePeriodLimit, //the time limit for a proposal to be in an relative voting mode.
665      *    _params[3] - _preBoostedVotePeriodLimit, //the time limit for a proposal to be in an preparation
666      *                  state (stable) before boosted.
667      *    _params[4] -_thresholdConst
668      *    _params[5] -_quietEndingPeriod
669      *    _params[6] -_proposingRepReward
670      *    _params[7] -_votersReputationLossRatio
671      *    _params[8] -_minimumDaoBounty
672      *    _params[9] -_daoBountyConst
673      *    _params[10] -_activationTime
674      * @param _voteOnBehalf - authorized to vote on behalf of others.
675     */
676     function setParameters(
677         uint[11] calldata _params, //use array here due to stack too deep issue.
678         address _voteOnBehalf
679     )
680     external
681     returns(bytes32)
682     {
683         require(_params[0] <= 100 && _params[0] >= 50, "50 <= queuedVoteRequiredPercentage <= 100");
684         require(_params[4] <= 16000 && _params[4] > 1000, "1000 < thresholdConst <= 16000");
685         require(_params[7] <= 100, "votersReputationLossRatio <= 100");
686         require(_params[2] >= _params[5], "boostedVotePeriodLimit >= quietEndingPeriod");
687         require(_params[8] > 0, "minimumDaoBounty should be > 0");
688         require(_params[9] > 0, "daoBountyConst should be > 0");
689 
690         bytes32 paramsHash = getParametersHash(_params, _voteOnBehalf);
691         //set a limit for power for a given alpha to prevent overflow
692         uint256 limitExponent = 172;//for alpha less or equal 2
693         uint256 j = 2;
694         for (uint256 i = 2000; i < 16000; i = i*2) {
695             if ((_params[4] > i) && (_params[4] <= i*2)) {
696                 limitExponent = limitExponent/j;
697                 break;
698             }
699             j++;
700         }
701 
702         parameters[paramsHash] = Parameters({
703             queuedVoteRequiredPercentage: _params[0],
704             queuedVotePeriodLimit: _params[1],
705             boostedVotePeriodLimit: _params[2],
706             preBoostedVotePeriodLimit: _params[3],
707             thresholdConst:uint216(_params[4]).fraction(uint216(1000)),
708             limitExponentValue:limitExponent,
709             quietEndingPeriod: _params[5],
710             proposingRepReward: _params[6],
711             votersReputationLossRatio:_params[7],
712             minimumDaoBounty:_params[8],
713             daoBountyConst:_params[9],
714             activationTime:_params[10],
715             voteOnBehalf:_voteOnBehalf
716         });
717         return paramsHash;
718     }
719 
720     /**
721      * @dev redeem a reward for a successful stake, vote or proposing.
722      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
723      * users to redeem on behalf of someone else.
724      * @param _proposalId the ID of the proposal
725      * @param _beneficiary - the beneficiary address
726      * @return rewards -
727      *           [0] stakerTokenReward
728      *           [1] voterReputationReward
729      *           [2] proposerReputationReward
730      */
731      // solhint-disable-next-line function-max-lines,code-complexity
732     function redeem(bytes32 _proposalId, address _beneficiary) public returns (uint[3] memory rewards) {
733         Proposal storage proposal = proposals[_proposalId];
734         require((proposal.state == ProposalState.Executed)||(proposal.state == ProposalState.ExpiredInQueue),
735         "Proposal should be Executed or ExpiredInQueue");
736         Parameters memory params = parameters[proposal.paramsHash];
737         //as staker
738         Staker storage staker = proposal.stakers[_beneficiary];
739         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
740         uint256 totalStakesLeftAfterCallBounty =
741         proposal.stakes[NO].add(proposal.stakes[YES]).sub(calcExecuteCallBounty(_proposalId));
742         if (staker.amount > 0) {
743 
744             if (proposal.state == ProposalState.ExpiredInQueue) {
745                 //Stakes of a proposal that expires in Queue are sent back to stakers
746                 rewards[0] = staker.amount;
747             } else if (staker.vote == proposal.winningVote) {
748                 if (staker.vote == YES) {
749                     if (proposal.daoBounty < totalStakesLeftAfterCallBounty) {
750                         uint256 _totalStakes = totalStakesLeftAfterCallBounty.sub(proposal.daoBounty);
751                         rewards[0] = (staker.amount.mul(_totalStakes))/totalWinningStakes;
752                     }
753                 } else {
754                     rewards[0] = (staker.amount.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes;
755                 }
756             }
757             staker.amount = 0;
758         }
759             //dao redeem its winnings
760         if (proposal.daoRedeemItsWinnings == false &&
761             _beneficiary == organizations[proposal.organizationId] &&
762             proposal.state != ProposalState.ExpiredInQueue &&
763             proposal.winningVote == NO) {
764             rewards[0] =
765             rewards[0]
766             .add((proposal.daoBounty.mul(totalStakesLeftAfterCallBounty))/totalWinningStakes)
767             .sub(proposal.daoBounty);
768             proposal.daoRedeemItsWinnings = true;
769         }
770 
771         //as voter
772         Voter storage voter = proposal.voters[_beneficiary];
773         if ((voter.reputation != 0) && (voter.preBoosted)) {
774             if (proposal.state == ProposalState.ExpiredInQueue) {
775               //give back reputation for the voter
776                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100);
777             } else if (proposal.winningVote == voter.vote) {
778                 uint256 lostReputation;
779                 if (proposal.winningVote == YES) {
780                     lostReputation = proposal.preBoostedVotes[NO];
781                 } else {
782                     lostReputation = proposal.preBoostedVotes[YES];
783                 }
784                 lostReputation = (lostReputation.mul(params.votersReputationLossRatio))/100;
785                 rewards[1] = ((voter.reputation.mul(params.votersReputationLossRatio))/100)
786                 .add((voter.reputation.mul(lostReputation))/proposal.preBoostedVotes[proposal.winningVote]);
787             }
788             voter.reputation = 0;
789         }
790         //as proposer
791         if ((proposal.proposer == _beneficiary)&&(proposal.winningVote == YES)&&(proposal.proposer != address(0))) {
792             rewards[2] = params.proposingRepReward;
793             proposal.proposer = address(0);
794         }
795         if (rewards[0] != 0) {
796             proposal.totalStakes = proposal.totalStakes.sub(rewards[0]);
797             require(stakingToken.transfer(_beneficiary, rewards[0]), "transfer to beneficiary failed");
798             emit Redeem(_proposalId, organizations[proposal.organizationId], _beneficiary, rewards[0]);
799         }
800         if (rewards[1].add(rewards[2]) != 0) {
801             VotingMachineCallbacksInterface(proposal.callbacks)
802             .mintReputation(rewards[1].add(rewards[2]), _beneficiary, _proposalId);
803             emit RedeemReputation(
804             _proposalId,
805             organizations[proposal.organizationId],
806             _beneficiary,
807             rewards[1].add(rewards[2])
808             );
809         }
810     }
811 
812     /**
813      * @dev redeemDaoBounty a reward for a successful stake.
814      * The function use a beneficiary address as a parameter (and not msg.sender) to enable
815      * users to redeem on behalf of someone else.
816      * @param _proposalId the ID of the proposal
817      * @param _beneficiary - the beneficiary address
818      * @return redeemedAmount - redeem token amount
819      * @return potentialAmount - potential redeem token amount(if there is enough tokens bounty at the organization )
820      */
821     function redeemDaoBounty(bytes32 _proposalId, address _beneficiary)
822     public
823     returns(uint256 redeemedAmount, uint256 potentialAmount) {
824         Proposal storage proposal = proposals[_proposalId];
825         require(proposal.state == ProposalState.Executed);
826         uint256 totalWinningStakes = proposal.stakes[proposal.winningVote];
827         Staker storage staker = proposal.stakers[_beneficiary];
828         if (
829             (staker.amount4Bounty > 0)&&
830             (staker.vote == proposal.winningVote)&&
831             (proposal.winningVote == YES)&&
832             (totalWinningStakes != 0)) {
833             //as staker
834                 potentialAmount = (staker.amount4Bounty * proposal.daoBounty)/totalWinningStakes;
835             }
836         if ((potentialAmount != 0)&&
837             (VotingMachineCallbacksInterface(proposal.callbacks)
838             .balanceOfStakingToken(stakingToken, _proposalId) >= potentialAmount)) {
839             staker.amount4Bounty = 0;
840             proposal.daoBountyRemain = proposal.daoBountyRemain.sub(potentialAmount);
841             require(
842             VotingMachineCallbacksInterface(proposal.callbacks)
843             .stakingTokenTransfer(stakingToken, _beneficiary, potentialAmount, _proposalId));
844             redeemedAmount = potentialAmount;
845             emit RedeemDaoBounty(_proposalId, organizations[proposal.organizationId], _beneficiary, redeemedAmount);
846         }
847     }
848 
849     /**
850       * @dev calcExecuteCallBounty calculate the execute boosted call bounty
851       * @param _proposalId the ID of the proposal
852       * @return uint256 executeCallBounty
853     */
854     function calcExecuteCallBounty(bytes32 _proposalId) public view returns(uint256) {
855         uint maxRewardSeconds = 1500;
856         uint rewardSeconds =
857         uint256(maxRewardSeconds).min(proposals[_proposalId].secondsFromTimeOutTillExecuteBoosted);
858         return rewardSeconds.mul(proposals[_proposalId].stakes[YES]).div(maxRewardSeconds*10);
859     }
860 
861     /**
862      * @dev shouldBoost check if a proposal should be shifted to boosted phase.
863      * @param _proposalId the ID of the proposal
864      * @return bool true or false.
865      */
866     function shouldBoost(bytes32 _proposalId) public view returns(bool) {
867         Proposal memory proposal = proposals[_proposalId];
868         return (_score(_proposalId) > threshold(proposal.paramsHash, proposal.organizationId));
869     }
870 
871     /**
872      * @dev threshold return the organization's score threshold which required by
873      * a proposal to shift to boosted state.
874      * This threshold is dynamically set and it depend on the number of boosted proposal.
875      * @param _organizationId the organization identifier
876      * @param _paramsHash the organization parameters hash
877      * @return uint256 organization's score threshold as real number.
878      */
879     function threshold(bytes32 _paramsHash, bytes32 _organizationId) public view returns(uint256) {
880         uint256 power = orgBoostedProposalsCnt[_organizationId];
881         Parameters storage params = parameters[_paramsHash];
882 
883         if (power > params.limitExponentValue) {
884             power = params.limitExponentValue;
885         }
886 
887         return params.thresholdConst.pow(power);
888     }
889 
890   /**
891    * @dev hashParameters returns a hash of the given parameters
892    */
893     function getParametersHash(
894         uint[11] memory _params,//use array here due to stack too deep issue.
895         address _voteOnBehalf
896     )
897         public
898         pure
899         returns(bytes32)
900         {
901         //double call to keccak256 to avoid deep stack issue when call with too many params.
902         return keccak256(
903             abi.encodePacked(
904             keccak256(
905             abi.encodePacked(
906                 _params[0],
907                 _params[1],
908                 _params[2],
909                 _params[3],
910                 _params[4],
911                 _params[5],
912                 _params[6],
913                 _params[7],
914                 _params[8],
915                 _params[9],
916                 _params[10])
917             ),
918             _voteOnBehalf
919         ));
920     }
921 
922     /**
923       * @dev execute check if the proposal has been decided, and if so, execute the proposal
924       * @param _proposalId the id of the proposal
925       * @return bool true - the proposal has been executed
926       *              false - otherwise.
927      */
928      // solhint-disable-next-line function-max-lines,code-complexity
929     function _execute(bytes32 _proposalId) internal votable(_proposalId) returns(bool) {
930         Proposal storage proposal = proposals[_proposalId];
931         Parameters memory params = parameters[proposal.paramsHash];
932         Proposal memory tmpProposal = proposal;
933         uint256 totalReputation =
934         VotingMachineCallbacksInterface(proposal.callbacks).getTotalReputationSupply(_proposalId);
935         //first divide by 100 to prevent overflow
936         uint256 executionBar = (totalReputation/100) * params.queuedVoteRequiredPercentage;
937         ExecutionState executionState = ExecutionState.None;
938         uint256 averageDownstakesOfBoosted;
939         uint256 confidenceThreshold;
940 
941         if (proposal.votes[proposal.winningVote] > executionBar) {
942          // someone crossed the absolute vote execution bar.
943             if (proposal.state == ProposalState.Queued) {
944                 executionState = ExecutionState.QueueBarCrossed;
945             } else if (proposal.state == ProposalState.PreBoosted) {
946                 executionState = ExecutionState.PreBoostedBarCrossed;
947             } else {
948                 executionState = ExecutionState.BoostedBarCrossed;
949             }
950             proposal.state = ProposalState.Executed;
951         } else {
952             if (proposal.state == ProposalState.Queued) {
953                 // solhint-disable-next-line not-rely-on-time
954                 if ((now - proposal.times[0]) >= params.queuedVotePeriodLimit) {
955                     proposal.state = ProposalState.ExpiredInQueue;
956                     proposal.winningVote = NO;
957                     executionState = ExecutionState.QueueTimeOut;
958                 } else {
959                     confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
960                     if (_score(_proposalId) > confidenceThreshold) {
961                         //change proposal mode to PreBoosted mode.
962                         proposal.state = ProposalState.PreBoosted;
963                         // solhint-disable-next-line not-rely-on-time
964                         proposal.times[2] = now;
965                         proposal.confidenceThreshold = confidenceThreshold;
966                     }
967                 }
968             }
969 
970             if (proposal.state == ProposalState.PreBoosted) {
971                 confidenceThreshold = threshold(proposal.paramsHash, proposal.organizationId);
972               // solhint-disable-next-line not-rely-on-time
973                 if ((now - proposal.times[2]) >= params.preBoostedVotePeriodLimit) {
974                     if (_score(_proposalId) > confidenceThreshold) {
975                         if (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS) {
976                          //change proposal mode to Boosted mode.
977                             proposal.state = ProposalState.Boosted;
978                          // solhint-disable-next-line not-rely-on-time
979                             proposal.times[1] = now;
980                             orgBoostedProposalsCnt[proposal.organizationId]++;
981                          //add a value to average -> average = average + ((value - average) / nbValues)
982                             averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
983                           // solium-disable-next-line indentation
984                             averagesDownstakesOfBoosted[proposal.organizationId] =
985                                 uint256(int256(averageDownstakesOfBoosted) +
986                                 ((int256(proposal.stakes[NO])-int256(averageDownstakesOfBoosted))/
987                                 int256(orgBoostedProposalsCnt[proposal.organizationId])));
988                         }
989                     } else {
990                         proposal.state = ProposalState.Queued;
991                     }
992                 } else { //check the Confidence level is stable
993                     uint256 proposalScore = _score(_proposalId);
994                     if (proposalScore <= proposal.confidenceThreshold.min(confidenceThreshold)) {
995                         proposal.state = ProposalState.Queued;
996                     } else if (proposal.confidenceThreshold > proposalScore) {
997                         proposal.confidenceThreshold = confidenceThreshold;
998                         emit ConfidenceLevelChange(_proposalId, confidenceThreshold);
999                     }
1000                 }
1001             }
1002         }
1003 
1004         if ((proposal.state == ProposalState.Boosted) ||
1005             (proposal.state == ProposalState.QuietEndingPeriod)) {
1006             // solhint-disable-next-line not-rely-on-time
1007             if ((now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit) {
1008                 proposal.state = ProposalState.Executed;
1009                 executionState = ExecutionState.BoostedTimeOut;
1010             }
1011         }
1012 
1013         if (executionState != ExecutionState.None) {
1014             if ((executionState == ExecutionState.BoostedTimeOut) ||
1015                 (executionState == ExecutionState.BoostedBarCrossed)) {
1016                 orgBoostedProposalsCnt[tmpProposal.organizationId] =
1017                 orgBoostedProposalsCnt[tmpProposal.organizationId].sub(1);
1018                 //remove a value from average = ((average * nbValues) - value) / (nbValues - 1);
1019                 uint256 boostedProposals = orgBoostedProposalsCnt[tmpProposal.organizationId];
1020                 if (boostedProposals == 0) {
1021                     averagesDownstakesOfBoosted[proposal.organizationId] = 0;
1022                 } else {
1023                     averageDownstakesOfBoosted = averagesDownstakesOfBoosted[proposal.organizationId];
1024                     averagesDownstakesOfBoosted[proposal.organizationId] =
1025                     (averageDownstakesOfBoosted.mul(boostedProposals+1).sub(proposal.stakes[NO]))/boostedProposals;
1026                 }
1027             }
1028             emit ExecuteProposal(
1029             _proposalId,
1030             organizations[proposal.organizationId],
1031             proposal.winningVote,
1032             totalReputation
1033             );
1034             emit GPExecuteProposal(_proposalId, executionState);
1035             ProposalExecuteInterface(proposal.callbacks).executeProposal(_proposalId, int(proposal.winningVote));
1036             proposal.daoBounty = proposal.daoBountyRemain;
1037         }
1038         if (tmpProposal.state != proposal.state) {
1039             emit StateChange(_proposalId, proposal.state);
1040         }
1041         return (executionState != ExecutionState.None);
1042     }
1043 
1044     /**
1045      * @dev staking function
1046      * @param _proposalId id of the proposal
1047      * @param _vote  NO(2) or YES(1).
1048      * @param _amount the betting amount
1049      * @return bool true - the proposal has been executed
1050      *              false - otherwise.
1051      */
1052     function _stake(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _staker) internal returns(bool) {
1053         // 0 is not a valid vote.
1054         require(_vote <= NUM_OF_CHOICES && _vote > 0, "wrong vote value");
1055         require(_amount > 0, "staking amount should be >0");
1056 
1057         if (_execute(_proposalId)) {
1058             return true;
1059         }
1060         Proposal storage proposal = proposals[_proposalId];
1061 
1062         if ((proposal.state != ProposalState.PreBoosted) &&
1063             (proposal.state != ProposalState.Queued)) {
1064             return false;
1065         }
1066 
1067         // enable to increase stake only on the previous stake vote
1068         Staker storage staker = proposal.stakers[_staker];
1069         if ((staker.amount > 0) && (staker.vote != _vote)) {
1070             return false;
1071         }
1072 
1073         uint256 amount = _amount;
1074         require(stakingToken.transferFrom(_staker, address(this), amount), "fail transfer from staker");
1075         proposal.totalStakes = proposal.totalStakes.add(amount); //update totalRedeemableStakes
1076         staker.amount = staker.amount.add(amount);
1077         //This is to prevent average downstakes calculation overflow
1078         //Note that any how GEN cap is 100000000 ether.
1079         require(staker.amount <= 0x100000000000000000000000000000000, "staking amount is too high");
1080         require(proposal.totalStakes <= uint256(0x100000000000000000000000000000000).sub(proposal.daoBountyRemain),
1081                 "total stakes is too high");
1082 
1083         if (_vote == YES) {
1084             staker.amount4Bounty = staker.amount4Bounty.add(amount);
1085         }
1086         staker.vote = _vote;
1087 
1088         proposal.stakes[_vote] = amount.add(proposal.stakes[_vote]);
1089         emit Stake(_proposalId, organizations[proposal.organizationId], _staker, _vote, _amount);
1090         return _execute(_proposalId);
1091     }
1092 
1093     /**
1094      * @dev Vote for a proposal, if the voter already voted, cancel the last vote and set a new one instead
1095      * @param _proposalId id of the proposal
1096      * @param _voter used in case the vote is cast for someone else
1097      * @param _vote a value between 0 to and the proposal's number of choices.
1098      * @param _rep how many reputation the voter would like to stake for this vote.
1099      *         if  _rep==0 so the voter full reputation will be use.
1100      * @return true in case of proposal execution otherwise false
1101      * throws if proposal is not open or if it has been executed
1102      * NB: executes the proposal if a decision has been reached
1103      */
1104      // solhint-disable-next-line function-max-lines,code-complexity
1105     function internalVote(bytes32 _proposalId, address _voter, uint256 _vote, uint256 _rep) internal returns(bool) {
1106         require(_vote <= NUM_OF_CHOICES && _vote > 0, "0 < _vote <= 2");
1107         if (_execute(_proposalId)) {
1108             return true;
1109         }
1110 
1111         Parameters memory params = parameters[proposals[_proposalId].paramsHash];
1112         Proposal storage proposal = proposals[_proposalId];
1113 
1114         // Check voter has enough reputation:
1115         uint256 reputation = VotingMachineCallbacksInterface(proposal.callbacks).reputationOf(_voter, _proposalId);
1116         require(reputation > 0, "_voter must have reputation");
1117         require(reputation >= _rep, "reputation >= _rep");
1118         uint256 rep = _rep;
1119         if (rep == 0) {
1120             rep = reputation;
1121         }
1122         // If this voter has already voted, return false.
1123         if (proposal.voters[_voter].reputation != 0) {
1124             return false;
1125         }
1126         // The voting itself:
1127         proposal.votes[_vote] = rep.add(proposal.votes[_vote]);
1128         //check if the current winningVote changed or there is a tie.
1129         //for the case there is a tie the current winningVote set to NO.
1130         if ((proposal.votes[_vote] > proposal.votes[proposal.winningVote]) ||
1131             ((proposal.votes[NO] == proposal.votes[proposal.winningVote]) &&
1132             proposal.winningVote == YES)) {
1133             if (proposal.state == ProposalState.Boosted &&
1134             // solhint-disable-next-line not-rely-on-time
1135                 ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod))||
1136                 proposal.state == ProposalState.QuietEndingPeriod) {
1137                 //quietEndingPeriod
1138                 if (proposal.state != ProposalState.QuietEndingPeriod) {
1139                     proposal.currentBoostedVotePeriodLimit = params.quietEndingPeriod;
1140                     proposal.state = ProposalState.QuietEndingPeriod;
1141                     emit StateChange(_proposalId, proposal.state);
1142                 }
1143                 // solhint-disable-next-line not-rely-on-time
1144                 proposal.times[1] = now;
1145             }
1146             proposal.winningVote = _vote;
1147         }
1148         proposal.voters[_voter] = Voter({
1149             reputation: rep,
1150             vote: _vote,
1151             preBoosted:((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued))
1152         });
1153         if ((proposal.state == ProposalState.PreBoosted) || (proposal.state == ProposalState.Queued)) {
1154             proposal.preBoostedVotes[_vote] = rep.add(proposal.preBoostedVotes[_vote]);
1155             uint256 reputationDeposit = (params.votersReputationLossRatio.mul(rep))/100;
1156             VotingMachineCallbacksInterface(proposal.callbacks).burnReputation(reputationDeposit, _voter, _proposalId);
1157         }
1158         emit VoteProposal(_proposalId, organizations[proposal.organizationId], _voter, _vote, rep);
1159         return _execute(_proposalId);
1160     }
1161 
1162     /**
1163      * @dev _score return the proposal score (Confidence level)
1164      * For dual choice proposal S = (S+)/(S-)
1165      * @param _proposalId the ID of the proposal
1166      * @return uint256 proposal score as real number.
1167      */
1168     function _score(bytes32 _proposalId) internal view returns(uint256) {
1169         Proposal storage proposal = proposals[_proposalId];
1170         //proposal.stakes[NO] cannot be zero as the dao downstake > 0 for each proposal.
1171         return uint216(proposal.stakes[YES]).fraction(uint216(proposal.stakes[NO]));
1172     }
1173 
1174     /**
1175       * @dev _isVotable check if the proposal is votable
1176       * @param _proposalId the ID of the proposal
1177       * @return bool true or false
1178     */
1179     function _isVotable(bytes32 _proposalId) internal view returns(bool) {
1180         ProposalState pState = proposals[_proposalId].state;
1181         return ((pState == ProposalState.PreBoosted)||
1182                 (pState == ProposalState.Boosted)||
1183                 (pState == ProposalState.QuietEndingPeriod)||
1184                 (pState == ProposalState.Queued)
1185         );
1186     }
1187 }
1188 
1189 // File: contracts/votingMachines/GenesisProtocol.sol
1190 
1191 pragma solidity ^0.5.4;
1192 
1193 
1194 
1195 
1196 /**
1197  * @title GenesisProtocol implementation -an organization's voting machine scheme.
1198  */
1199 contract GenesisProtocol is IntVoteInterface, GenesisProtocolLogic {
1200     using ECDSA for bytes32;
1201 
1202     // Digest describing the data the user signs according EIP 712.
1203     // Needs to match what is passed to Metamask.
1204     bytes32 public constant DELEGATION_HASH_EIP712 =
1205     keccak256(abi.encodePacked(
1206     "address GenesisProtocolAddress",
1207     "bytes32 ProposalId",
1208     "uint256 Vote",
1209     "uint256 AmountToStake",
1210     "uint256 Nonce"
1211     ));
1212 
1213     mapping(address=>uint256) public stakesNonce; //stakes Nonce
1214 
1215     /**
1216      * @dev Constructor
1217      */
1218     constructor(IERC20 _stakingToken)
1219     public
1220     // solhint-disable-next-line no-empty-blocks
1221     GenesisProtocolLogic(_stakingToken) {
1222     }
1223 
1224     /**
1225      * @dev staking function
1226      * @param _proposalId id of the proposal
1227      * @param _vote  NO(2) or YES(1).
1228      * @param _amount the betting amount
1229      * @return bool true - the proposal has been executed
1230      *              false - otherwise.
1231      */
1232     function stake(bytes32 _proposalId, uint256 _vote, uint256 _amount) external returns(bool) {
1233         return _stake(_proposalId, _vote, _amount, msg.sender);
1234     }
1235 
1236     /**
1237      * @dev stakeWithSignature function
1238      * @param _proposalId id of the proposal
1239      * @param _vote  NO(2) or YES(1).
1240      * @param _amount the betting amount
1241      * @param _nonce nonce value ,it is part of the signature to ensure that
1242               a signature can be received only once.
1243      * @param _signatureType signature type
1244               1 - for web3.eth.sign
1245               2 - for eth_signTypedData according to EIP #712.
1246      * @param _signature  - signed data by the staker
1247      * @return bool true - the proposal has been executed
1248      *              false - otherwise.
1249      */
1250     function stakeWithSignature(
1251         bytes32 _proposalId,
1252         uint256 _vote,
1253         uint256 _amount,
1254         uint256 _nonce,
1255         uint256 _signatureType,
1256         bytes calldata _signature
1257         )
1258         external
1259         returns(bool)
1260         {
1261         // Recreate the digest the user signed
1262         bytes32 delegationDigest;
1263         if (_signatureType == 2) {
1264             delegationDigest = keccak256(
1265                 abi.encodePacked(
1266                     DELEGATION_HASH_EIP712, keccak256(
1267                         abi.encodePacked(
1268                         address(this),
1269                         _proposalId,
1270                         _vote,
1271                         _amount,
1272                         _nonce)
1273                     )
1274                 )
1275             );
1276         } else {
1277             delegationDigest = keccak256(
1278                         abi.encodePacked(
1279                         address(this),
1280                         _proposalId,
1281                         _vote,
1282                         _amount,
1283                         _nonce)
1284                     ).toEthSignedMessageHash();
1285         }
1286         address staker = delegationDigest.recover(_signature);
1287         //a garbage staker address due to wrong signature will revert due to lack of approval and funds.
1288         require(staker != address(0), "staker address cannot be 0");
1289         require(stakesNonce[staker] == _nonce);
1290         stakesNonce[staker] = stakesNonce[staker].add(1);
1291         return _stake(_proposalId, _vote, _amount, staker);
1292     }
1293 
1294     /**
1295      * @dev voting function
1296      * @param _proposalId id of the proposal
1297      * @param _vote NO(2) or YES(1).
1298      * @param _amount the reputation amount to vote with . if _amount == 0 it will use all voter reputation.
1299      * @param _voter voter address
1300      * @return bool true - the proposal has been executed
1301      *              false - otherwise.
1302      */
1303     function vote(bytes32 _proposalId, uint256 _vote, uint256 _amount, address _voter)
1304     external
1305     votable(_proposalId)
1306     returns(bool) {
1307         Proposal storage proposal = proposals[_proposalId];
1308         Parameters memory params = parameters[proposal.paramsHash];
1309         address voter;
1310         if (params.voteOnBehalf != address(0)) {
1311             require(msg.sender == params.voteOnBehalf);
1312             voter = _voter;
1313         } else {
1314             voter = msg.sender;
1315         }
1316         return internalVote(_proposalId, voter, _vote, _amount);
1317     }
1318 
1319   /**
1320    * @dev Cancel the vote of the msg.sender.
1321    * cancel vote is not allow in genesisProtocol so this function doing nothing.
1322    * This function is here in order to comply to the IntVoteInterface .
1323    */
1324     function cancelVote(bytes32 _proposalId) external votable(_proposalId) {
1325        //this is not allowed
1326         return;
1327     }
1328 
1329     /**
1330       * @dev execute check if the proposal has been decided, and if so, execute the proposal
1331       * @param _proposalId the id of the proposal
1332       * @return bool true - the proposal has been executed
1333       *              false - otherwise.
1334      */
1335     function execute(bytes32 _proposalId) external votable(_proposalId) returns(bool) {
1336         return _execute(_proposalId);
1337     }
1338 
1339   /**
1340     * @dev getNumberOfChoices returns the number of choices possible in this proposal
1341     * @return uint256 that contains number of choices
1342     */
1343     function getNumberOfChoices(bytes32) external view returns(uint256) {
1344         return NUM_OF_CHOICES;
1345     }
1346 
1347     /**
1348       * @dev getProposalTimes returns proposals times variables.
1349       * @param _proposalId id of the proposal
1350       * @return proposals times array
1351       */
1352     function getProposalTimes(bytes32 _proposalId) external view returns(uint[3] memory times) {
1353         return proposals[_proposalId].times;
1354     }
1355 
1356     /**
1357      * @dev voteInfo returns the vote and the amount of reputation of the user committed to this proposal
1358      * @param _proposalId the ID of the proposal
1359      * @param _voter the address of the voter
1360      * @return uint256 vote - the voters vote
1361      *        uint256 reputation - amount of reputation committed by _voter to _proposalId
1362      */
1363     function voteInfo(bytes32 _proposalId, address _voter) external view returns(uint, uint) {
1364         Voter memory voter = proposals[_proposalId].voters[_voter];
1365         return (voter.vote, voter.reputation);
1366     }
1367 
1368     /**
1369     * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.
1370     * @param _proposalId the ID of the proposal
1371     * @param _choice the index in the
1372     * @return voted reputation for the given choice
1373     */
1374     function voteStatus(bytes32 _proposalId, uint256 _choice) external view returns(uint256) {
1375         return proposals[_proposalId].votes[_choice];
1376     }
1377 
1378     /**
1379     * @dev isVotable check if the proposal is votable
1380     * @param _proposalId the ID of the proposal
1381     * @return bool true or false
1382     */
1383     function isVotable(bytes32 _proposalId) external view returns(bool) {
1384         return _isVotable(_proposalId);
1385     }
1386 
1387     /**
1388     * @dev proposalStatus return the total votes and stakes for a given proposal
1389     * @param _proposalId the ID of the proposal
1390     * @return uint256 preBoostedVotes YES
1391     * @return uint256 preBoostedVotes NO
1392     * @return uint256 total stakes YES
1393     * @return uint256 total stakes NO
1394     */
1395     function proposalStatus(bytes32 _proposalId) external view returns(uint256, uint256, uint256, uint256) {
1396         return (
1397                 proposals[_proposalId].preBoostedVotes[YES],
1398                 proposals[_proposalId].preBoostedVotes[NO],
1399                 proposals[_proposalId].stakes[YES],
1400                 proposals[_proposalId].stakes[NO]
1401         );
1402     }
1403 
1404   /**
1405     * @dev getProposalOrganization return the organizationId for a given proposal
1406     * @param _proposalId the ID of the proposal
1407     * @return bytes32 organization identifier
1408     */
1409     function getProposalOrganization(bytes32 _proposalId) external view returns(bytes32) {
1410         return (proposals[_proposalId].organizationId);
1411     }
1412 
1413     /**
1414       * @dev getStaker return the vote and stake amount for a given proposal and staker
1415       * @param _proposalId the ID of the proposal
1416       * @param _staker staker address
1417       * @return uint256 vote
1418       * @return uint256 amount
1419     */
1420     function getStaker(bytes32 _proposalId, address _staker) external view returns(uint256, uint256) {
1421         return (proposals[_proposalId].stakers[_staker].vote, proposals[_proposalId].stakers[_staker].amount);
1422     }
1423 
1424     /**
1425       * @dev voteStake return the amount stakes for a given proposal and vote
1426       * @param _proposalId the ID of the proposal
1427       * @param _vote vote number
1428       * @return uint256 stake amount
1429     */
1430     function voteStake(bytes32 _proposalId, uint256 _vote) external view returns(uint256) {
1431         return proposals[_proposalId].stakes[_vote];
1432     }
1433 
1434   /**
1435     * @dev voteStake return the winningVote for a given proposal
1436     * @param _proposalId the ID of the proposal
1437     * @return uint256 winningVote
1438     */
1439     function winningVote(bytes32 _proposalId) external view returns(uint256) {
1440         return proposals[_proposalId].winningVote;
1441     }
1442 
1443     /**
1444       * @dev voteStake return the state for a given proposal
1445       * @param _proposalId the ID of the proposal
1446       * @return ProposalState proposal state
1447     */
1448     function state(bytes32 _proposalId) external view returns(ProposalState) {
1449         return proposals[_proposalId].state;
1450     }
1451 
1452    /**
1453     * @dev isAbstainAllow returns if the voting machine allow abstain (0)
1454     * @return bool true or false
1455     */
1456     function isAbstainAllow() external pure returns(bool) {
1457         return false;
1458     }
1459 
1460     /**
1461      * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.
1462      * @return min - minimum number of choices
1463                max - maximum number of choices
1464      */
1465     function getAllowedRangeOfChoices() external pure returns(uint256 min, uint256 max) {
1466         return (YES, NO);
1467     }
1468 
1469     /**
1470      * @dev score return the proposal score
1471      * @param _proposalId the ID of the proposal
1472      * @return uint256 proposal score.
1473      */
1474     function score(bytes32 _proposalId) public view returns(uint256) {
1475         return  _score(_proposalId);
1476     }
1477 }
