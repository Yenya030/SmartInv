1 pragma solidity ^0.4.14;
2 
3 contract Random {
4   uint64 _seed = 0;
5 
6   // return a pseudo random number between lower and upper bounds
7   // given the number of previous blocks it should hash.
8   function random(uint64 upper) public returns (uint64 randomNumber) {
9     _seed = uint64(sha3(sha3(block.blockhash(block.number), _seed), now));
10     return _seed % upper;
11   }
12 }
13 
14 //This contract is written as a fix for the SatanCoin contract's raffle functionality
15 //The winning index of every round will be randomly generated here. Remaining SATAN coins will then be manually issued based on the results.
16 //The SatanCoin contract itself is located here: https://etherscan.io/address/0xCCcA48874780f9c42b162c9617bC6324c5142C22
17 
18 contract SatanCoinRaffle {
19     
20    // address public constant satanCoinAddress = 0xCCcA48874780f9c42b162c9617bC6324c5142C22;
21   address public constant randomAddress = 0x0230CfC895646d34538aE5b684d76Bf40a8B8B89;
22   
23     address public owner;
24     
25     Random public rand;
26     
27     struct RoundResults {
28         uint roundNum;
29         uint raffleAmount;
30         bool raffleComplete;
31         uint winnerIndex;
32         address winner;
33     }
34     
35     RoundResults[9] public roundResults;
36     
37     event RandomNumGenerated(uint64 _randomNum);
38     event RoundSet(uint64 _coinNumBought, address );
39     event RaffleIssued(uint _roundNumber, uint _amountWon, uint _winnerIndex);
40     event WinnerSet(uint _roundNumber, uint _winnerIndex, address winner);
41     
42     modifier onlyOwner {
43       require(msg.sender == owner);
44       _;
45     }
46 
47     
48     function SatanCoinRaffle () {
49         
50       owner = msg.sender;
51 
52       rand = Random(randomAddress);
53       
54     }
55    
56    function random (uint64 upper) 
57         private
58         returns (uint64)
59     {
60     //uses random contract: https://etherscan.io/address/0x0230CfC895646d34538aE5b684d76Bf40a8B8B89
61     // https://www.npmjs.com/package/eth-random
62       uint64 randomNum = rand.random(upper);
63       
64       RandomNumGenerated(randomNum);
65       
66       return randomNum;
67    }
68    
69    function setRound(uint roundNum, uint raffleAmount)
70         public
71         onlyOwner
72    {
73        require(roundNum < 9 && roundNum > 0);
74        require(raffleAmount < 74 && raffleAmount > 0);
75        require(!roundResults[roundNum-1].raffleComplete);
76        
77        roundResults[roundNum-1] = RoundResults(roundNum, raffleAmount, false, 0, address(0));
78        
79        assert(raffle(roundNum));
80      
81    }
82    
83    function setWinner(uint roundNum, address winner)
84         public
85         onlyOwner
86         returns (bool)
87    {
88        require(roundNum < 9 && roundNum > 0);
89        //the raffle must have already been run
90        require(roundResults[roundNum-1].raffleComplete);
91        //can only set winner once
92        require(roundResults[roundNum-1].winner == address(0));
93        
94        /* winner address is set manually based on the winningIndex using the transaction history of the SatanCoin contract. 
95        results may be compared with the contract itself here: https://etherscan.io/address/0xCCcA48874780f9c42b162c9617bC6324c5142C22 */
96        roundResults[roundNum-1].winner = winner;
97        WinnerSet(roundNum, roundResults[roundNum-1].winnerIndex, roundResults[roundNum-1].winner);
98        
99        return true;
100    }
101    
102    function raffle (uint roundNum)
103         internal
104         returns (bool)
105     {
106         require(roundNum < 9 && roundNum > 0);
107         //can only run a raffle once
108         require(!roundResults[roundNum-1].raffleComplete);
109 
110        //the winning index is generated by random number
111        roundResults[roundNum-1].winnerIndex = random(uint64(74-roundResults[roundNum-1].raffleAmount));
112        roundResults[roundNum-1].raffleComplete = true;
113        
114        RaffleIssued(roundNum, roundResults[roundNum-1].raffleAmount, roundResults[roundNum-1].winnerIndex);
115        return true;
116     }
117    
118    
119 }