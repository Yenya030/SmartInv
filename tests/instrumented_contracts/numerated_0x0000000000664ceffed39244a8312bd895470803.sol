1 {{
2   "language": "Solidity",
3   "sources": {
4     "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
6     },
7     "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
9     },
10     "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
11       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
12     },
13     "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
14       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
15     },
16     "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
18     },
19     "lib/solady/src/utils/ECDSA.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The number which `s` must not exceed in order for\n    /// the signature to be non-malleable.\n    bytes32 private constant _MALLEABILITY_THRESHOLD =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: as of Solady version 0.0.68, these functions will\n    // revert upon recovery failure for more safety by default.\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n            // Copy `r` and `s`.\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\n            let s := mload(add(signature, 0x40))\n            mstore(0x60, s)\n            // Store the `hash` in the scratch space.\n            mstore(0x00, hash)\n            // Compute `v` and store it in the scratch space.\n            mstore(0x20, byte(0, mload(add(signature, 0x60))))\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    and(\n                        // If the signature is exactly 65 bytes in length.\n                        eq(mload(signature), 65),\n                        // If `s` in lower half order, such that the signature is not malleable.\n                        lt(s, add(_MALLEABILITY_THRESHOLD, 1))\n                    ), // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x00, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            result := mload(0x00)\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                // Store the function selector of `InvalidSignature()`.\n                mstore(0x00, 0x8baa579f)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the zero slot.\n            mstore(0x60, 0)\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n            // Directly copy `r` and `s` from the calldata.\n            calldatacopy(0x40, signature.offset, 0x40)\n            // Store the `hash` in the scratch space.\n            mstore(0x00, hash)\n            // Compute `v` and store it in the scratch space.\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    and(\n                        // If the signature is exactly 65 bytes in length.\n                        eq(signature.length, 65),\n                        // If `s` in lower half order, such that the signature is not malleable.\n                        lt(mload(0x60), add(_MALLEABILITY_THRESHOLD, 1))\n                    ), // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x00, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            result := mload(0x00)\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                // Store the function selector of `InvalidSignature()`.\n                mstore(0x00, 0x8baa579f)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the zero slot.\n            mstore(0x60, 0)\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    ///\n    /// To be honest, I do not recommend using EIP-2098 signatures\n    /// for simplicity, performance, and security reasons. Most if not\n    /// all clients support traditional non EIP-2098 signatures by default.\n    /// As such, this method is intentionally not fully inlined.\n    /// It is merely included for completeness.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        uint8 v;\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        result = recover(hash, v, r, s);\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(\n                staticcall(\n                    gas(), // Amount of gas left for the transaction.\n                    // If `s` in lower half order, such that the signature is not malleable.\n                    lt(s, add(_MALLEABILITY_THRESHOLD, 1)), // Address of `ecrecover`.\n                    0x00, // Start of input.\n                    0x80, // Size of input.\n                    0x00, // Start of output.\n                    0x20 // Size of output.\n                )\n            )\n            result := mload(0x00)\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                // Store the function selector of `InvalidSignature()`.\n                mstore(0x00, 0x8baa579f)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the zero slot.\n            mstore(0x60, 0)\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(xor(mload(signature), 65)) {\n                // Copy the free memory pointer so that we can restore it later.\n                let m := mload(0x40)\n                // Copy `r` and `s`.\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                mstore(0x60, s)\n                // If `s` in lower half order, such that the signature is not malleable.\n                if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\n                    // Store the `hash` in the scratch space.\n                    mstore(0x00, hash)\n                    // Compute `v` and store it in the scratch space.\n                    mstore(0x20, byte(0, mload(add(signature, 0x60))))\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            0x01, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x40, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // Restore the zero slot.\n                    mstore(0x60, 0)\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    result := mload(xor(0x60, returndatasize()))\n                }\n                // Restore the free memory pointer.\n                mstore(0x40, m)\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(xor(signature.length, 65)) {\n                // Copy the free memory pointer so that we can restore it later.\n                let m := mload(0x40)\n                // Directly copy `r` and `s` from the calldata.\n                calldatacopy(0x40, signature.offset, 0x40)\n                // If `s` in lower half order, such that the signature is not malleable.\n                if iszero(gt(mload(0x60), _MALLEABILITY_THRESHOLD)) {\n                    // Store the `hash` in the scratch space.\n                    mstore(0x00, hash)\n                    // Compute `v` and store it in the scratch space.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            0x01, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x40, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // Restore the zero slot.\n                    mstore(0x60, 0)\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    result := mload(xor(0x60, returndatasize()))\n                }\n                // Restore the free memory pointer.\n                mstore(0x40, m)\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    ///\n    /// To be honest, I do not recommend using EIP-2098 signatures\n    /// for simplicity, performance, and security reasons. Most if not\n    /// all clients support traditional non EIP-2098 signatures by default.\n    /// As such, this method is intentionally not fully inlined.\n    /// It is merely included for completeness.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        uint8 v;\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        result = tryRecover(hash, v, r, s);\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n            // If `s` in lower half order, such that the signature is not malleable.\n            if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\n                // Store the `hash`, `v`, `r`, `s` in the scratch space.\n                mstore(0x00, hash)\n                mstore(0x20, and(v, 0xff))\n                mstore(0x40, r)\n                mstore(0x60, s)\n                pop(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        0x01, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x40, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n                // Restore the zero slot.\n                mstore(0x60, 0)\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n            }\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store into scratch space for keccak256.\n            mstore(0x20, hash)\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\")\n            // 0x40 - 0x04 = 0x3c\n            result := keccak256(0x04, 0x3c)\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        assembly {\n            // The length of \"\\x19Ethereum Signed Message:\\n\" is 26 bytes (i.e. 0x1a).\n            // If we reserve 2 words, we'll have 64 - 26 = 38 bytes to store the\n            // ASCII decimal representation of the length of `s` up to about 2 ** 126.\n\n            // Instead of allocating, we temporarily copy the 64 bytes before the\n            // start of `s` data to some variables.\n            let m := mload(sub(s, 0x20))\n            // The length of `s` is in bytes.\n            let sLength := mload(s)\n            let ptr := add(s, 0x20)\n            let w := not(0)\n            // `end` marks the end of the memory which we will compute the keccak256 of.\n            let end := add(ptr, sLength)\n            // Convert the length of the bytes to ASCII decimal representation\n            // and store it into the memory.\n            for { let temp := sLength } 1 {} {\n                ptr := add(ptr, w) // `sub(ptr, 1)`.\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            // Copy the header over to the memory.\n            mstore(sub(ptr, 0x20), \"\\x00\\x00\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n\")\n            // Compute the keccak256 of the memory.\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\n            // Restore the previous memory.\n            mstore(s, sLength)\n            mstore(sub(s, 0x20), m)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"
21     },
22     "src/Fundrop/FundropPass.sol": {
23       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport {IERC165} from \"openzeppelin/utils/introspection/IERC165.sol\";\nimport {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"openzeppelin/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\n\nimport \"./NonTransferrableERC721.sol\";\nimport \"./IERC4906.sol\";\nimport \"./IFundropRewards.sol\";\nimport \"./IMetadataRenderer.sol\";\n\ncontract FundropPass is NonTransferrableERC721, IERC4906, Ownable {\n    address public metadataRenderer;\n    address public rewardsDistributor;\n\n    address public metadataUpdater;\n    address public signer;\n    bool public mintOpen;\n\n    error InvalidSignature();\n    error MintClosed();\n    error OnlyOwnerOrMetadataUpdater();\n\n    event MinterReferred(address referrer);\n\n    constructor() NonTransferrableERC721(\"mint.fun !fundrop pass\", \"FUNPASS\") {\n        if (msg.sender != tx.origin) {\n            transferOwnership(tx.origin);\n        }\n    }\n\n    function mint(address referrer, bytes calldata signature) public {\n        if (!mintOpen) revert MintClosed();\n        address recovered = ECDSA.tryRecoverCalldata(keccak256(abi.encodePacked(msg.sender, referrer)), signature);\n        if (recovered != signer) revert InvalidSignature();\n        if (referrer != address(0)) emit MinterReferred(referrer);\n        _mint(msg.sender);\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        if (!_exists(id)) revert InvalidTokenId();\n        return IMetadataRenderer(metadataRenderer).tokenURI(id);\n    }\n\n    // Admin functions\n\n    function refreshMetadata() public {\n        if (msg.sender != metadataUpdater && msg.sender != owner()) {\n            revert OnlyOwnerOrMetadataUpdater();\n        }\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    function setMetadataRenderer(address _metadataRenderer) public onlyOwner {\n        metadataRenderer = _metadataRenderer;\n        refreshMetadata();\n    }\n\n    function setMetadataUpdater(address _metadataUpdater) public onlyOwner {\n        metadataUpdater = _metadataUpdater;\n    }\n\n    function setSigner(address _signer) public onlyOwner {\n        signer = _signer;\n    }\n\n    function setRewardsDistributor(address _rewardsDistributor) public onlyOwner {\n        rewardsDistributor = _rewardsDistributor;\n    }\n\n    function setMintOpen(bool _mintOpen) public onlyOwner {\n        mintOpen = _mintOpen;\n    }\n\n    function adminBurn(uint256[] calldata ids) public onlyOwner {\n        for (uint256 i = 0; i < ids.length; i++) {\n            _burn(ids[i]);\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC4906).interfaceId || interfaceId == type(IERC721Metadata).interfaceId;\n    }\n}\n"
24     },
25     "src/Fundrop/IERC4906.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC4906 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
27     },
28     "src/Fundrop/IFundropRewards.sol": {
29       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.17;\n\ninterface IFundropRewards {\n    function getRewardsBalance(address _minter) external view returns (uint256);\n    function claimRewards(address _minter, bytes memory _args) external;\n}\n"
30     },
31     "src/Fundrop/IMetadataRenderer.sol": {
32       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\ninterface IMetadataRenderer {\n    function tokenURI(uint256 id) external view returns (string memory);\n}\n"
33     },
34     "src/Fundrop/NonTransferrableERC721.sol": {
35       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\nimport {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"openzeppelin/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC165} from \"openzeppelin/utils/introspection/IERC165.sol\";\n\nabstract contract NonTransferrableERC721 is IERC721, IERC721Metadata {\n    string public override name;\n    string public override symbol;\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _tokens;\n    uint256 private _nextTokenId = 1;\n    uint256 private _burnedTokenCount;\n\n    error AlreadyMinted();\n    error InvalidAddress();\n    error InvalidTokenId();\n    error NonTransferrable();\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function _mint(address to) internal {\n        if (to == address(0)) revert InvalidAddress();\n        if (_tokens[to] != 0) revert AlreadyMinted();\n\n        unchecked {\n            uint256 tokenId = _nextTokenId++;\n            _owners[tokenId] = to;\n            _tokens[to] = tokenId;\n\n            emit Transfer(address(0), to, tokenId);\n        }\n    }\n\n    function _burn(uint256 tokenId) internal {\n        address owner = _owners[tokenId];\n        if (owner == address(0)) revert InvalidTokenId();\n\n        _owners[tokenId] = address(0);\n        _tokens[owner] = 0;\n        unchecked {\n            _burnedTokenCount++;\n        }\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _burn(address owner) internal {\n        uint256 tokenId = _tokens[owner];\n        if (tokenId == 0) revert InvalidAddress();\n\n        _owners[tokenId] = address(0);\n        _tokens[owner] = 0;\n        unchecked {\n            _burnedTokenCount++;\n        }\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure virtual override returns (bool) {\n        return interfaceID == type(IERC165).interfaceId || interfaceID == type(IERC721).interfaceId\n            || interfaceID == type(IERC721Metadata).interfaceId;\n    }\n\n    function balanceOf(address _owner) external view override returns (uint256) {\n        if (_owner == address(0)) revert InvalidAddress();\n        return _tokens[_owner] > 0 ? 1 : 0;\n    }\n\n    function ownerOf(uint256 _tokenId) external view override returns (address) {\n        address owner = _owners[_tokenId];\n        if (owner == address(0)) revert InvalidTokenId();\n        return owner;\n    }\n\n    function safeTransferFrom(address, address, uint256) external pure override {\n        revert NonTransferrable();\n    }\n\n    function safeTransferFrom(address, address, uint256, bytes calldata) external pure override {\n        revert NonTransferrable();\n    }\n\n    function transferFrom(address, address, uint256) external pure override {\n        revert NonTransferrable();\n    }\n\n    function approve(address, uint256) external pure override {\n        revert NonTransferrable();\n    }\n\n    function setApprovalForAll(address, bool) external pure override {\n        revert NonTransferrable();\n    }\n\n    function getApproved(uint256) external pure override returns (address) {\n        revert NonTransferrable();\n    }\n\n    function isApprovedForAll(address, address) external pure override returns (bool) {\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _nextTokenId - 1 - _burnedTokenCount;\n    }\n}\n"
36     }
37   },
38   "settings": {
39     "remappings": [
40       "ERC721A/=lib/ERC721A/contracts/",
41       "ds-test/=lib/forge-std/lib/ds-test/src/",
42       "forge-std/=lib/forge-std/src/",
43       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
44       "openzeppelin/=lib/openzeppelin-contracts/contracts/",
45       "solady/=lib/solady/src/",
46       "solmate/=lib/solmate/src/"
47     ],
48     "optimizer": {
49       "enabled": true,
50       "runs": 250000
51     },
52     "metadata": {
53       "bytecodeHash": "ipfs",
54       "appendCBOR": true
55     },
56     "outputSelection": {
57       "*": {
58         "*": [
59           "evm.bytecode",
60           "evm.deployedBytecode",
61           "devdoc",
62           "userdoc",
63           "metadata",
64           "abi"
65         ]
66       }
67     },
68     "evmVersion": "london",
69     "libraries": {}
70   }
71 }}