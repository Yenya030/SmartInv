1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
6     },
7     "contracts/BpxClaim.sol": {
8       "content": "// SPDX-License-Identifier: UNLICENSED\n\nimport { ProxyOwnable } from \"./utils/ProxyOwnable.sol\";\nimport { MerkleProofLib } from \"./utils/MerkleProofLib.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { Errors } from \"./library/errors/Errors.sol\";\n\npragma solidity >=0.8.4 <0.9.0;\n\ncontract BpxClaim is ProxyOwnable {\n    struct ClaimWindow {\n        IERC20 bpxContract;\n        uint48 startTime;\n        uint48 endTime;\n    }\n\n    event CurrencyClaimed(address indexed claimant, uint256 indexed amount, address indexed operator);\n\n    bytes32 public authRoot;\n    ClaimWindow private _claim;\n\n    mapping(address => bool) private _claimed;\n\n    constructor(address bpx) {\n        if (bpx.code.length == 0) {\n            revert Errors.NotAContract();\n        }\n\n        _claim.bpxContract = IERC20(bpx);\n    }\n\n    function bpxSupply() public view returns (uint256) {\n        return _claim.bpxContract.balanceOf(address(this));\n    }\n\n    function getClaimMetadata() public view returns (ClaimWindow memory) {\n        return _claim;\n    }\n\n    function claimed(address claimant) public view returns (bool) {\n        return _claimed[claimant];\n    }\n\n    function withdraw(address recipient) external onlyAuthorized {\n        _claim.bpxContract.transfer(recipient, bpxSupply());\n    }\n\n    function setClaimWindow(uint48 startTime, uint48 endTime, bytes32 merkleRoot) external onlyAuthorized {\n        if (endTime < startTime) {\n            revert Errors.InvalidTimeRange(startTime, endTime);\n        }\n        _claim.startTime = startTime;\n        _claim.endTime = endTime;\n        authRoot = merkleRoot;\n    }\n\n    function claim(address recipient, uint256 quantity, bytes32[] calldata proof) external {\n        uint256 windowStart = _claim.startTime;\n        uint256 windowEnd = _claim.endTime;\n        IERC20 bpx = _claim.bpxContract;\n\n        if (block.timestamp < windowStart) {\n            revert Errors.ClaimWindowClosed();\n        }\n        if (block.timestamp > windowEnd) {\n            revert Errors.ClaimWindowClosed();\n        }\n        if (_claimed[recipient]) {\n            revert Errors.DuplicateCall();\n        }\n\n        bytes32 leaf = keccak256(abi.encodePacked(recipient, quantity));\n        if (!MerkleProofLib.verify(proof, authRoot, leaf)) {\n            revert Errors.UserPermissions();\n        }\n\n        _claimed[recipient] = true;\n        emit CurrencyClaimed(recipient, quantity, msg.sender);\n        bpx.transfer(recipient, quantity);\n    }\n}\n"
9     },
10     "contracts/library/errors/Errors.sol": {
11       "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.8.4 <0.9.0;\n\nlibrary Errors {\n    error LinkError();\n    error ArrayMismatch();\n    error OutOfRange(uint256 value);\n    error OutOfRangeSigned(int256 value);\n    error UnsignedOverflow(uint256 value);\n    error SignedOverflow(int256 value);\n    error DuplicateCall();\n\n    error NotAContract();\n    error InterfaceNotSupported();\n    error NotInitialized();\n    error BadSender(address expected, address caller);\n    error AddressTarget(address target);\n    error UserPermissions();\n\n    error InsufficientBalance(uint256 available, uint256 required);\n    error InsufficientSupply(uint256 supply, uint256 available, int256 requested);  // 0x5437b336\n    error InsufficientAvailable(uint256 available, uint256 requested);\n    error InvalidToken(uint256 tokenId);                                            // 0x925d6b18\n    error TokenNotMintable(uint256 tokenId);\n    error MintingClosed();\n    error ClaimWindowClosed();\n    error ClaimActive();\n    error InvalidTimeRange(uint256 startTime, uint256 endTime);\n\n    error ERC1155Receiver();\n\n    error ContractPaused();\n\n    error PaymentFailed(uint256 amount);\n    error IncorrectPayment(uint256 required, uint256 provided);                     // 0x0d35e921\n\terror TooManyForTransaction(uint256 mintLimit, uint256 amount);\n}\n"
12     },
13     "contracts/utils/MerkleProofLib.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"
15     },
16     "contracts/utils/ProxyOwnable.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\nimport { Errors } from \"../library/errors/Errors.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there are two accounts (an owner and a proxy) that can be granted exclusive\n * access to specific functions. Only the owner can set the proxy.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This contract enables a pattern whereby another contract can be set as a\n * proxy to interact with the inheriting contract with administrative privs.\n * It also enables a pattern whereby the contract owner is never used for\n * general contract admin actions. It's only used to set privileged accounts,\n * while the proxy account operates the contract as the administrator.\n *\n * This module is used through inheritance. It will make available the modifiers\n * `onlyOwner` and `onlyAuthorized`, which can be applied to your functions to\n * restrict their use to the owner or the proxy.\n */\nabstract contract ProxyOwnable {\n    address public _owner;\n    address public _proxy;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the current proxy.\n     */\n    function proxy() public view virtual returns (address) {\n        return _proxy;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert Errors.UserPermissions();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the proxy or the owner.\n     */\n    modifier onlyAuthorized() {\n        if (\n            proxy() != msg.sender &&\n            owner() != msg.sender\n        ) revert Errors.UserPermissions();\n        _;\n    }\n\n    function checkAuthorized(address operator) public view virtual {\n        if (\n            proxy() != operator &&\n            owner() != operator\n        ) revert Errors.UserPermissions();\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert Errors.AddressTarget(newOwner);\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Sets the proxy for the contract to a new account (`newProxy`).\n     * Can only be called by the current owner.\n     */\n    function setProxy(address newProxy) public virtual onlyOwner {\n        _proxy = newProxy;\n    }\n\n    function _setOwner(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
18     }
19   },
20   "settings": {
21     "optimizer": {
22       "enabled": true,
23       "runs": 200
24     },
25     "outputSelection": {
26       "*": {
27         "*": [
28           "evm.bytecode",
29           "evm.deployedBytecode",
30           "devdoc",
31           "userdoc",
32           "metadata",
33           "abi"
34         ]
35       }
36     },
37     "libraries": {}
38   }
39 }}