1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/infrastructure/IModuleRegistry.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"
6     },
7     "contracts/modules/common/BaseModule.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../vault/IVault.sol\";\nimport \"../..//storage/IStorage.sol\";\nimport \"./IModule.sol\";\nimport \"../../infrastructure/IModuleRegistry.sol\";\n\n/**\n * @title BaseModule\n * @notice Base Module contract that contains methods common to all Modules.\n */\nabstract contract BaseModule is IModule {\n\n    // different types of signatures\n    enum Signature {\n        Owner,  \n        KWG,\n        OwnerAndGuardian, \n        OwnerAndGuardianOrOwnerAndKWG,\n        OwnerOrKWG,\n        GuardianOrKWG,\n        OwnerOrGuardianOrKWG\n    }\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n\n    // Zero address\n    address constant internal ZERO_ADDRESS = address(0);\n\n    // The guardians storage\n    IStorage internal immutable _storage;\n\n    // Module Registry address\n    IModuleRegistry internal immutable moduleRegistry;\n\n    /**\n     * @notice Throws if the sender is not the module itself.\n     */\n    modifier onlySelf() {\n        require(_isSelf(msg.sender), \"BM: must be module\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the target vault of the call.\n     */\n    modifier onlyVault(address _vault) {\n        require(\n            msg.sender == _vault,\n            \"BM: caller must be vault\"\n        );\n        _;\n    }\n\n    /**\n     * @param Storage deployed instance of storage contract\n     */\n    constructor(\n        IStorage Storage,\n        IModuleRegistry _moduleRegistry\n    ) {\n        _storage = Storage;\n        moduleRegistry = _moduleRegistry;\n    }\n\n    /**\n     * @notice Helper method to check if an address is the module itself.\n     * @param _addr - The target address.\n     * @return true if locked.\n     */\n    function _isSelf(address _addr) internal view returns (bool) {\n        return _addr == address(this);\n    }\n\n    /**\n     * @notice Helper method to check if an address is the owner of a target vault.\n     * @param _vault The target vault.\n     * @param _addr The address.\n     */\n    function _isOwner(address _vault, address _addr) internal view returns (bool) {\n        return IVault(_vault).owner() == _addr;\n    }\n\n    /**\n     * @notice Helper method to invoke a vault.\n     * @param _vault - The target vault.\n     * @param _to - The target address for the transaction.\n     * @param _value - The value of the transaction.\n     * @param _data - The data of the transaction.\n     * @return _res result of low level call from vault.\n     */\n    function invokeVault(\n        address _vault,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) \n        internal\n        returns\n        (bytes memory _res) \n    {\n        bool success;\n        (success, _res) = _vault.call(\n            abi.encodeWithSignature(\n                \"invoke(address,uint256,bytes)\",\n                _to,\n                _value,\n                _data\n            )\n        );\n        if (success && _res.length > 0) {\n            (_res) = abi.decode(_res, (bytes));\n        } else if (_res.length > 0) {\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        } else if (!success) {\n            revert(\"BM: vault invoke reverted\");\n        }\n    }\n}"
9     },
10     "contracts/modules/common/IModule.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IModule\n * @notice Interface for a Module.\n */\ninterface IModule {\n\n    /**\t\n     * @notice Adds a module to a vault. Cannot execute when vault is locked (or under recovery)\t\n     * @param _vault The target vault.\t\n     * @param _module The modules to authorise.\t\n     */\t\n    function addModule(address _vault, address _module, bytes memory _initData) external;\n\n    /**\n     * @notice Inits a Module for a vault by e.g. setting some vault specific parameters in storage.\n     * @param _vault The target vault.\n     * @param _timeDelay - time in seconds to be expired before executing a queued request.\n     */\n    function init(address _vault, bytes memory _timeDelay) external;\n\n\n    /**\n     * @notice Returns whether the module implements a callback for a given static call method.\n     * @param _methodId The method id.\n     */\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\n}"
12     },
13     "contracts/modules/common/Utils.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title Utils\n * @notice Common utility methods used by modules.\n */\nlibrary Utils {\n\n    /**\n    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    * @return the signer public address.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint256 _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28, \"U: bad v value in signature\");\n\n        address recoveredAddress = ecrecover(_signedHash, v, r, s);\n        require(recoveredAddress != address(0), \"U: ecrecover returned 0\");\n        return recoveredAddress;\n    }\n\n    /**\n    * @notice Helper method to parse data and extract the method signature.\n    * @param _data The calldata.\n    * @return prefix The methodID for the calldata.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"U: Invalid functionPrefix\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n}\n"
15     },
16     "contracts/modules/KresusModule.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./KresusRelayer.sol\";\nimport \"./SecurityManager.sol\";\nimport \"./TransactionManager.sol\";\nimport \"../infrastructure/IModuleRegistry.sol\";\n\n/**\n * @title KresusModule\n * @notice Single module for Kresus vault.\n */\ncontract KresusModule is BaseModule, KresusRelayer, SecurityManager, TransactionManager {\n\n    string constant public NAME = \"KresusModule\";\n    address public immutable kresusGuardian;\n\n    /**\n     * @param _storage deployed instance of storage contract\n     * @param _kresusGuardian default guardian from kresus.\n     * @param _kresusGuardian default guardian of kresus for recovery and unblocking\n     */\n    constructor (\n        IStorage _storage,\n        IModuleRegistry _moduleRegistry,\n        address _kresusGuardian,\n        address _refundAddress\n    )\n        BaseModule(_storage, _moduleRegistry)\n        KresusRelayer(_refundAddress)\n    {\n        require(_kresusGuardian != ZERO_ADDRESS, \"KM: Invalid address\");\n        kresusGuardian = _kresusGuardian;\n    }\n\n    /**\n     * @inheritdoc IModule\n     */\n    function init(\n        address _vault,\n        bytes memory _timeDelay\n    )\n        external\n        override\n        onlyVault(_vault)\n    {\n        uint256 newTimeDelay = uint256(bytes32(_timeDelay));\n        require(\n            newTimeDelay >= MIN_TIME_DELAY &&\n            newTimeDelay <= MAX_TIME_DELAY,\n            \"KM: Invalid Time Delay\"\n        );\n        IVault(_vault).enableStaticCall(address(this));\n        _storage.setTimeDelay(_vault, newTimeDelay);\n    }\n\n    /**\n    * @inheritdoc IModule\n    */\n    function addModule(\n        address _vault,\n        address _module,\n        bytes memory _initData\n    )\n        external\n        onlySelf()\n    {\n        require(moduleRegistry.isRegisteredModule(_module), \"KM: module is not registered\");\n        IVault(_vault).authoriseModule(_module, true, _initData);\n    }\n    \n    /**\n     * @inheritdoc KresusRelayer\n     */\n    function getRequiredSignatures(\n        address _vault,\n        bytes calldata _data\n    )\n        public\n        view\n        override\n        returns (bool, bool, bool, Signature)\n    {\n        bytes4 methodId = Utils.functionPrefix(_data);\n        bool votingEnabled = _storage.votingEnabled(_vault);\n        bool _locked = _storage.isLocked(_vault);\n\n        if (methodId == TransactionManager.multiCall.selector){\n            return((!votingEnabled) ? (!_locked, true, true, Signature.Owner):(!_locked, true, true, Signature.OwnerAndGuardian));    \n        }\n        if (methodId == SecurityManager.setGuardian.selector ||\n            methodId == SecurityManager.transferOwnership.selector ||\n            methodId == SecurityManager.changeHeir.selector ||\n            methodId == SecurityManager.setTimeDelay.selector\n        )\n        {\n            return((!votingEnabled) ? (!_locked, true, false, Signature.Owner):(!_locked, true, false, Signature.OwnerAndGuardian)); \n        }\n        if (methodId == SecurityManager.revokeGuardian.selector){\n            return((!votingEnabled) ? (true, true, false, Signature.OwnerOrGuardianOrKWG):(true, true, false, Signature.OwnerAndGuardianOrOwnerAndKWG)); \n        }\n        if (methodId == SecurityManager.unlock.selector) {\n            return((!votingEnabled) ? (_locked, true, false, Signature.KWG):(_locked, true, false, Signature.GuardianOrKWG)); \n        }\n        if (methodId == SecurityManager.lock.selector) {\n            return((!votingEnabled) ? (!_locked, false, false, Signature.OwnerOrKWG):(!_locked, false, false, Signature.OwnerOrGuardianOrKWG));\n        }\n        if (methodId == SecurityManager.toggleVoting.selector ||\n            methodId == KresusModule.addModule.selector\n        )\n        {\n            return((!votingEnabled) ? (!_locked, false, false, Signature.Owner):(!_locked, false, false, Signature.OwnerAndGuardian)); \n        }\n        if(methodId == SecurityManager.executeBequeathal.selector) {\n            return ((!votingEnabled)) ? (true, true, false, Signature.OwnerOrKWG):(true, true, false, Signature.OwnerOrGuardianOrKWG);\n        }\n        revert(\"KM: unknown method\");\n    }\n\n    /**\n     * @param _data _data The calldata for the required transaction.\n     * @return Signature The required signature from {Signature} enum .\n     */\n    function getCancelRequiredSignatures(\n        bytes calldata _data\n    )\n        public\n        pure\n        override\n        returns(Signature)\n    {\n        bytes4 methodId = Utils.functionPrefix(_data);\n        if(\n            methodId == SecurityManager.transferOwnership.selector ||\n            methodId == SecurityManager.setGuardian.selector ||\n            methodId == SecurityManager.revokeGuardian.selector ||\n            methodId == SecurityManager.setTimeDelay.selector ||\n            methodId == TransactionManager.multiCall.selector ||\n            methodId == SecurityManager.changeHeir.selector\n        ){\n            return Signature.Owner;\n        }\n        revert(\"KM: unknown method\");\n    }\n\n    /**\n    * @notice Validates the signatures provided with a relayed transaction.\n    * @param _vault The target vault.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated bytes array.\n    * @param _option An OwnerSignature enum indicating whether the owner is required, optional or disallowed.\n    * @return A boolean indicating whether the signatures are valid.\n    */\n    function validateSignatures(\n        address _vault,\n        bytes32 _signHash,\n        bytes memory _signatures,\n        Signature _option\n    ) \n        public \n        view\n        override\n        returns (bool)\n    {\n        if ((_signatures.length < 65))\n        {\n            return false;\n        }\n\n        address signer0 = Utils.recoverSigner(_signHash, _signatures, 0);\n        address _ownerAddr = IVault(_vault).owner();\n    \n        if((\n            _option == Signature.Owner || \n            _option == Signature.OwnerOrKWG || \n            _option == Signature.OwnerOrGuardianOrKWG\n           ) \n           &&\n           signer0 == _ownerAddr\n        )\n        {\n            return true;\n        }\n\n        if((\n            _option == Signature.KWG ||\n            _option == Signature.OwnerOrKWG ||\n            _option == Signature.GuardianOrKWG ||\n            _option == Signature.OwnerOrGuardianOrKWG\n           ) \n           &&\n           signer0 == kresusGuardian\n        )\n        {\n            return true;\n        }\n\n        address _guardianAddr = _storage.getGuardian(_vault);\n\n        if((\n            _option == Signature.GuardianOrKWG ||\n             _option == Signature.OwnerOrGuardianOrKWG\n           )\n           &&\n           signer0 == _guardianAddr\n        )\n        {\n            return true;\n        }\n\n        address signer1 = Utils.recoverSigner(_signHash, _signatures, 1);\n\n        if((\n            _option == Signature.OwnerAndGuardian || _option == Signature.OwnerAndGuardianOrOwnerAndKWG\n           ) \n           && \n           signer0 == _ownerAddr \n           && \n           signer1 == _guardianAddr\n        )\n        {\n            return true;\n        }\n        \n        if((\n            _option == Signature.OwnerAndGuardianOrOwnerAndKWG\n           ) \n           && \n           signer0 == _ownerAddr \n           && \n           (signer1 == kresusGuardian)\n        )\n        {\n            return true;\n        }\n        return false;\n    }\n}"
18     },
19     "contracts/modules/KresusRelayer.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"../storage/IStorage.sol\";\n/**\n * @title KresusRelayer\n * @notice Abstract Module to execute transactions signed by ETH-less accounts and sent by a relayer.\n */\nabstract contract KresusRelayer is BaseModule {\n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping(bytes32 => uint256) queuedTransactions;\n        mapping(bytes32 => uint256) arrayIndex;\n        bytes32[] queue;\n    }\n\n    // Used to avoid stack too deep error\n    struct StackExtension {\n        Signature signatureRequirement;\n        bytes32 signHash;\n        bool success;\n        bytes returnData;\n    }\n\n    uint256 constant BLOCKBOUND = 10000;\n\n    address public immutable refundAddress;\n\n    mapping (address => RelayerConfig) internal relayer;\n\n\n    event TransactionExecuted(address indexed vault, bool indexed success, bytes returnData, bytes32 signedHash);\n    event TransactionQueued(address indexed vault, uint256 executionTime, bytes32 signedHash);\n    event Refund(address indexed vault, uint256 refundAmount);\n    event ActionCancelled(address indexed vault, bytes32 signedHash);\n    event AllActionsCancelled(address indexed vault);\n\n    /**\n     * @param _refundAddress the address which the refund amount is sent.\n     */\n    constructor(\n        address _refundAddress\n    ) {\n        require(_refundAddress != ZERO_ADDRESS, \"KR: Invalid address\");\n        refundAddress = _refundAddress;\n    }\n    \n    /**\n    * @notice Executes a relayed transaction.\n    * @param _vault The target vault.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @return true if executed or queued successfully, else returns false.\n    */\n    function execute(\n        address _vault,\n        bytes calldata _data,\n        uint256 _nonce,\n        bytes calldata _signatures\n    )\n        external\n        returns (bool)\n    {\n        // initial gas = 21k + non_zero_bytes * 16 + zero_bytes * 4\n        //            ~= 21k + calldata.length * [1/3 * 16 + 2/3 * 4]\n        uint256 startGas = gasleft() + 21000 + msg.data.length * 8;\n        require(verifyData(_vault, _data), \"KR: Target of _data != _vault\");\n\n        StackExtension memory stack;\n        bool queue;\n        bool _refund;\n        bool allowed;\n        (allowed, queue, _refund, stack.signatureRequirement) = getRequiredSignatures(_vault, _data);\n\n        require(allowed, \"KR: Operation not allowed\");\n\n        stack.signHash = getSignHash(\n            _vault,\n            0,\n            _data,\n            _nonce\n        );\n\n        // Execute a queued tx\n        if (isActionQueued(_vault, stack.signHash)){\n            require(relayer[_vault].queuedTransactions[stack.signHash] < block.timestamp, \"KR: Time not expired\");\n            (stack.success, stack.returnData) = address(this).call(_data);\n            require(stack.success, \"KR: Internal call failed\");\n            if(relayer[_vault].queue.length > 0) {\n                removeQueue(_vault, stack.signHash);\n            }\n            emit TransactionExecuted(_vault, stack.success, stack.returnData, stack.signHash);\n            if(_refund) {\n                refund(_vault, startGas);\n            } \n            return stack.success;\n        }\n        \n        \n        require(validateSignatures(\n                _vault, \n                stack.signHash,\n                _signatures, \n                stack.signatureRequirement\n            ),\n            \"KR: Invalid Signatures\"\n        );\n\n        require(checkAndUpdateUniqueness(_vault, _nonce), \"KR: Duplicate request\");\n        \n\n        // Queue the Tx\n        if(queue) {\n            uint256 executionTime = block.timestamp + _storage.getTimeDelay(_vault);\n            relayer[_vault].queuedTransactions[stack.signHash] = executionTime;\n            relayer[_vault].queue.push(stack.signHash);\n            relayer[_vault].arrayIndex[stack.signHash] = relayer[_vault].queue.length-1;\n            emit TransactionQueued(_vault, executionTime, stack.signHash);\n            return true;\n        }\n         // Execute the tx directly without queuing\n        else{\n            (stack.success, stack.returnData) = address(this).call(_data);\n            require(stack.success, \"KR: Internal call failed\");\n            emit TransactionExecuted(_vault, stack.success, stack.returnData, stack.signHash);\n            return stack.success;\n        }\n    }  \n\n    /**\n     * @notice cancels a transaction which was queued.\n     * @param _vault The target vault.\n     * @param _data The data for the relayed transaction.\n     * @param _nonce The nonce used to prevent replay attacks.\n     * @param _signature The signature needed to validate cancel.\n     */\n    function cancel(\n        address _vault,\n        bytes calldata _data,\n        uint256 _nonce,\n        bytes memory _signature\n    ) \n        external \n    {\n        bytes32 _actionHash = getSignHash(_vault, 0, _data, _nonce);\n        bytes32 _cancelHash = getSignHash(_vault, 0, \"0x\", _nonce);\n        require(isActionQueued(_vault, _actionHash), \"KR: Invalid hash\");\n        Signature _sig = getCancelRequiredSignatures(_data);\n        require(\n            validateSignatures(\n                _vault,\n                _cancelHash,\n                _signature,\n                _sig\n            ), \"KR: Invalid Signatures\"\n        );\n        removeQueue(_vault, _actionHash);\n        emit ActionCancelled(_vault, _actionHash);\n    }\n\n    /**\n     * @notice to cancel all the queued operations for a `_vault` address.\n     * @param _vault The target vault.\n     */\n    function cancelAll(\n        address _vault\n    ) external onlySelf {\n        uint256 len = relayer[_vault].queue.length; \n        for(uint256 i=0;i<len;i++) {\n            bytes32 _actionHash = relayer[_vault].queue[i];\n            relayer[_vault].queuedTransactions[_actionHash] = 0;\n            relayer[_vault].arrayIndex[_actionHash] = 0;\n        }\n        delete relayer[_vault].queue;\n        emit AllActionsCancelled(_vault);\n    }\n\n    /**\n    * @notice Gets the current nonce for a vault.\n    * @param _vault The target vault.\n    * @return nonce gets the last used nonce of the vault.\n    */\n    function getNonce(address _vault) external view returns (uint256 nonce) {\n        return relayer[_vault].nonce;\n    }\n\n    /**\n    * @notice Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _vault The target vault.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the vault owner signature requirement.\n    */\n    function getRequiredSignatures(\n        address _vault,\n        bytes calldata _data\n    ) public view virtual returns (bool, bool, bool, Signature);\n\n    /**\n    * @notice checks validity of a signature depending on status of the vault.\n    * @param _vault The target vault.\n    * @param _actionHash signed hash of the request.\n    * @param _data The data of the relayed transaction.\n    * @param _option Type of signature.\n    * @return true if it is a valid signature.\n    */\n    function validateSignatures(\n        address _vault,\n        bytes32 _actionHash,\n        bytes memory _data,\n        Signature _option\n    ) public view virtual returns(bool);\n\n    /**\n    * @notice Gets the required signature from {Signature} enum to cancel the request.\n    * @param _data The data of the relayed transaction.\n    * @return The required signature from {Signature} enum .\n    */ \n    function getCancelRequiredSignatures(\n        bytes calldata _data\n    ) public pure virtual returns(Signature);\n\n    /**\n    * @notice Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the relayer module)\n    * @param _value The value for the relayed transaction.\n    * @param _data The data for the relayed transaction which includes the vault address.\n    * @param _nonce The nonce used to prevent replay attacks.\n    */\n    function getSignHash(\n        address _from,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _nonce\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(\n                    bytes1(0x19),\n                    bytes1(0),\n                    _from,\n                    _value,\n                    _data,\n                    block.chainid,\n                    _nonce\n                ))\n            )\n        );\n    }\n\n    /**\n    * @notice Checks if the relayed transaction is unique. If yes the state is updated.\n    * @param _vault The target vault.\n    * @param _nonce The nonce.\n    * @return true if the transaction is unique.\n    */\n    function checkAndUpdateUniqueness(\n        address _vault,\n        uint256 _nonce\n    )\n        public\n        returns (bool)\n    {\n        // use the incremental nonce\n        if (_nonce <= relayer[_vault].nonce) {\n            return false;\n        }\n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n        if (nonceBlock > block.number + BLOCKBOUND) {\n            return false;\n        }\n        relayer[_vault].nonce = _nonce;\n        return true;\n    }\n       \n\n    /**\n    * @notice Refunds the gas used to the Relayer.\n    * @param _vault The target vault.\n    * @param _startGas The gas provided at the start of the execution.\n    */\n    function refund(\n        address _vault,\n        uint256 _startGas\n    )\n        internal\n    {\n        uint256 refundAmount;\n        uint256 gasConsumed = _startGas - gasleft() + 23000;\n        refundAmount = gasConsumed * tx.gasprice;\n        bytes memory transferSuccessBytes = invokeVault(_vault, refundAddress, refundAmount, EMPTY_BYTES);\n        // Check token refund is successful, when `transfer` returns a success bool result\n        if (transferSuccessBytes.length > 0) {\n            require(abi.decode(transferSuccessBytes, (bool)), \"RM: Refund transfer failed\");\n        }\n        emit Refund(_vault, refundAmount);\n    }\n\n    /**\n    * @notice Checks that the vault address provided as the first parameter of _data matches _vault\n    * @return false if the addresses are different.\n    */\n    function verifyData(address _vault, bytes calldata _data) internal pure returns (bool) {\n        require(_data.length >= 36, \"KR: Invalid dataVault\");\n        require(_vault != ZERO_ADDRESS, \"KR: Invalid vault\");\n        address dataVault = abi.decode(_data[4:], (address));\n        return dataVault == _vault;\n    }\n\n    /**\n    * @notice Check whether a given action is queued.\n    * @param _vault The target vault.\n    * @param  actionHash  Hash of the action to be checked. \n    * @return Boolean `true` if the underlying action of `actionHash` is queued, otherwise `false`.\n    */\n    function isActionQueued(\n        address _vault,\n        bytes32 actionHash\n    )\n        public\n        view\n        returns (bool)\n    {\n        return (relayer[_vault].queuedTransactions[actionHash] > 0);\n    }\n\n    /**\n    * @notice Return execution time for a given queued action.\n    * @param _vault The target vault.\n    * @param  actionHash  Hash of the action to be checked.\n    * @return uint256   execution time for a given queued action.\n    */\n    function queuedActionExecutionTime(\n        address _vault,\n        bytes32 actionHash\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return relayer[_vault].queuedTransactions[actionHash];\n    }\n    \n    /**\n    * @notice Removes an element at index from the array queue of a user\n    * @param _vault The target vault.\n    * @param  _actionHash  Hash of the action to be checked.\n    * @return false if the index is invalid.\n    */\n    function removeQueue(address _vault, bytes32 _actionHash) internal returns(bool) {\n        RelayerConfig storage _relayer = relayer[_vault];\n        _relayer.queuedTransactions[_actionHash] = 0;\n\n        uint256 index = _relayer.arrayIndex[_actionHash];\n        uint256 len = _relayer.queue.length;\n        if(index != len - 1) {\n            bytes32 lastHash = _relayer.queue[len - 1];\n            _relayer.arrayIndex[lastHash] = index;\n            _relayer.arrayIndex[_actionHash] = 0;\n            _relayer.queue[index] = lastHash;\n        }\n        _relayer.queue.pop();\n        \n        return true;\n    }\n}"
21     },
22     "contracts/modules/SecurityManager.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./common/BaseModule.sol\";\nimport \"../vault/IVault.sol\";\n\n/**\n * @title SecurityManager\n * @notice Abstract module implementing the key security features of the vault: guardians, lock and recovery.\n */\nabstract contract SecurityManager is BaseModule {\n\n    uint256 public constant MIN_TIME_DELAY = 5 minutes;\n    uint256 public constant MAX_TIME_DELAY = 72 hours;\n\n    event OwnershipTransferred(address indexed vault, address indexed _newOwner);\n    event Bequeathed(address indexed vault, address indexed _newOwner);\n    event Locked(address indexed vault);\n    event Unlocked(address indexed vault);\n    event GuardianAdded(address indexed vault, address indexed guardian);\n    event GuardianRevoked(address indexed vault);\n    event HeirChanged(address indexed vault, address indexed heir);\n    event VotingToggled(address indexed vault, bool votingEnabled);\n    event TimeDelayChanged(address indexed vault, uint256 newTimeDelay);\n\n    /**\n     * @notice Lets the owner transfer the vault ownership. This is executed immediately.\n     * @param _vault The target vault.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(\n        address _vault,\n        address _newOwner\n    )\n        external\n        onlySelf()\n    {\n        changeOwner(_vault, _newOwner);\n        emit OwnershipTransferred(_vault, _newOwner);\n    }\n\n    /**\n     * @notice Lets a guardian lock a vault.\n     * @param _vault The target vault.\n     */\n    function lock(address _vault) external onlySelf() {\n        _storage.setLock(_vault, true);\n        (bool success, ) = address(this).call(\n            abi.encodeWithSignature(\"cancelAll(address)\", _vault)\n        );\n        require(success, \"SM: cancel all operation failed\");\n        emit Locked(_vault);\n    }\n\n    /**\n     * @notice Updates the TimeDelay\n     * @param _vault The target vault.\n     * @param _newTimeDelay The new DelayTime to update.\n     */\n    function setTimeDelay(\n        address _vault,\n        uint256 _newTimeDelay\n    )\n        external\n        onlySelf()\n    {\n        require(\n            _newTimeDelay >= MIN_TIME_DELAY &&\n            _newTimeDelay <= MAX_TIME_DELAY,\n            \"SM: Invalid Time Delay\"\n        );\n        _storage.setTimeDelay(_vault, _newTimeDelay);\n        emit TimeDelayChanged(_vault, _newTimeDelay);\n    }\n\n    /**\n     * @notice Lets a guardian unlock a locked vault.\n     * @param _vault The target vault.\n     */\n    function unlock(\n        address _vault\n    ) \n        external\n        onlySelf()\n    {\n        _storage.setLock(_vault, false);\n        emit Unlocked(_vault);\n    }\n\n    /**\n     * @notice To turn voting on and off.\n     * @param _vault The target vault.\n     */\n    function toggleVoting(\n        address _vault\n    )\n        external\n        onlySelf()\n    {\n        bool _enabled = _storage.votingEnabled(_vault);\n        if(!_enabled) {\n            require(_storage.getGuardian(_vault) != ZERO_ADDRESS, \"SM: Cannot enable voting\");\n        }\n        _storage.toggleVoting(_vault);\n        emit VotingToggled(_vault, !_enabled);\n    }\n\n\n    /**\n     * @notice Lets the owner add a guardian to its vault.\n     * @param _vault The target vault.\n     * @param _guardian The guardian to add.\n     */\n    function setGuardian(\n        address _vault,\n        address _guardian\n    ) \n        external \n        onlySelf()\n    {\n        _storage.setGuardian(_vault, _guardian);\n        emit GuardianAdded(_vault, _guardian);\n    }\n    \n    /**\n     * @notice Lets the owner revoke a guardian from its vault.\n     * @param _vault The target vault.\n     */\n    function revokeGuardian(\n        address _vault\n    ) external onlySelf() \n    {\n        _storage.revokeGuardian(_vault);\n        bool _enabled = _storage.votingEnabled(_vault);\n        if(_enabled) {\n            _storage.toggleVoting(_vault);\n        }\n        emit GuardianRevoked(_vault);\n    }\n\n    function changeHeir(\n        address _vault,\n        address _newHeir\n    ) \n        external\n        onlySelf()\n    {\n        require(\n            _newHeir != ZERO_ADDRESS,\n            \"SM: Invalid Heir\"\n        );\n        _storage.setHeir(_vault, _newHeir);\n        emit HeirChanged(_vault, _newHeir);\n    }\n\n    function executeBequeathal(\n        address _vault\n    )\n        external\n        onlySelf()\n    {\n        address heir = _storage.getHeir(_vault);\n        changeOwner(_vault, heir);\n        _storage.setHeir(_vault, ZERO_ADDRESS);\n        emit Bequeathed(_vault, heir);\n    }\n\n    /**\n     * @notice Checks if an address is a guardian for a vault.\n     * @param _vault The target vault.\n     * @param _guardian The address to check.\n     * @return _isGuardian `true` if the address is a guardian for the vault otherwise `false`.\n     */\n    function isGuardian(\n        address _vault,\n        address _guardian\n    ) \n        public\n        view\n        returns(bool _isGuardian)\n    {\n        return _storage.isGuardian(_vault, _guardian);\n    }\n\n    function changeOwner(address _vault, address _newOwner) internal {\n        validateNewOwner(_vault, _newOwner);\n        IVault(_vault).setOwner(_newOwner);\n        (bool success, ) = address(this).call(\n            abi.encodeWithSignature(\"cancelAll(address)\", _vault)\n        );\n        require(success, \"SM: cancel all operation failed\");\n    }\n\n    /**\n     * @notice Checks if the vault address is valid to be a new owner.\n     * @param _vault The target vault.\n     * @param _newOwner The target vault.\n     */\n    function validateNewOwner(address _vault, address _newOwner) internal view {\n        require(_newOwner != ZERO_ADDRESS, \"SM: new owner cannot be null\");\n        require(!isGuardian(_vault, _newOwner), \"SM: new owner cannot be guardian\");\n    }\n}"
24     },
25     "contracts/modules/TransactionManager.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./common/Utils.sol\";\nimport \"./common/BaseModule.sol\";\n\n/**\n * @title TransactionManager\n * @notice Module to execute transactions in sequence to e.g. transfer tokens (ETH, ERC20, ERC721, ERC1155) or call third-party contracts.\n */\nabstract contract TransactionManager is BaseModule {\n\n    struct Call {\n        address to;      //the target address to which transaction to be sent\n        uint256 value;   //native amount to be sent.\n        bytes data;      //the data for the transaction.\n    }\n\n    // Static calls\n    bytes4 private constant ERC1271_IS_VALID_SIGNATURE = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"));\n    bytes4 private constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    bytes4 private constant ERC1155_RECEIVED = bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    bytes4 private constant ERC1155_BATCH_RECEIVED = bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    bytes4 private constant ERC165_INTERFACE = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\n    /**\n     * @notice Makes the target vault execute a sequence of transactions\n     * The method reverts if any of the inner transactions reverts.\n     * @param _vault The target vault.\n     * @param _transactions The sequence of transactions.\n     * @return bytes array of results for  all low level calls.\n     */\n    function multiCall(\n        address _vault,\n        Call[] calldata _transactions\n    )\n        external \n        onlySelf()\n        returns (bytes[] memory)\n    {\n        return multiCallWithApproval(_vault, _transactions);\n    }\n    \n\n    /**\n     * @inheritdoc IModule\n     */\n    function supportsStaticCall(bytes4 _methodId) external pure override returns (bool _isSupported) {\n        return _methodId == ERC1271_IS_VALID_SIGNATURE ||\n               _methodId == ERC721_RECEIVED ||\n               _methodId == ERC165_INTERFACE ||\n               _methodId == ERC1155_RECEIVED ||\n               _methodId == ERC1155_BATCH_RECEIVED;\n    }\n\n    /**\n     * @notice Returns true if this contract implements the interface defined by\n     * `interfaceId` (see https://eips.ethereum.org/EIPS/eip-165).\n     */\n    function supportsInterface(bytes4 _interfaceID) external pure returns (bool) {\n        return  _interfaceID == ERC165_INTERFACE || _interfaceID == (ERC1155_RECEIVED ^ ERC1155_BATCH_RECEIVED);          \n    }\n\n    /**\n    * @notice Implementation of EIP 1271.\n    * Should return whether the signature provided is valid for the provided data.\n    * @param _msgHash Hash of a message signed on the behalf of address(this)\n    * @param _signature Signature byte array associated with _msgHash\n    */\n    function isValidSignature(bytes32 _msgHash, bytes memory _signature) external view returns (bytes4) {\n        require(_signature.length == 65, \"TM: invalid signature length\");\n        address signer = Utils.recoverSigner(_msgHash, _signature, 0);\n        require(_isOwner(msg.sender, signer), \"TM: Invalid signer\");\n        return ERC1271_IS_VALID_SIGNATURE;\n    }\n\n\n    fallback() external {\n        bytes4 methodId = Utils.functionPrefix(msg.data);\n        if(methodId == ERC721_RECEIVED || methodId == ERC1155_RECEIVED || methodId == ERC1155_BATCH_RECEIVED) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {                \n                calldatacopy(0, 0, 0x04)\n                return (0, 0x20)\n            }\n        }\n    }\n\n\n    function multiCallWithApproval(address _vault, Call[] calldata _transactions) internal returns (bytes[] memory) {\n        bytes[] memory results = new bytes[](_transactions.length);\n        for(uint256 i = 0; i < _transactions.length; i++) {\n            results[i] = invokeVault(\n                _vault,\n                _transactions[i].to,\n                _transactions[i].value,\n                _transactions[i].data\n            );\n        }\n        return results;\n    }\n}"
27     },
28     "contracts/storage/IStorage.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IStorage\n * @notice Interface for Storage\n */\ninterface IStorage {\n\n    /**\n     * @notice Lets an authorised module add a guardian to a vault.\n     * @param _vault - The target vault.\n     * @param _guardian - The guardian to add.\n     */\n    function setGuardian(address _vault, address _guardian) external;\n\n    /**\n     * @notice Lets an authorised module revoke a guardian from a vault.\n     * @param _vault - The target vault.\n     */\n    function revokeGuardian(address _vault) external;\n\n    /**\n     * @notice Function to be used to add heir address to bequeath vault ownership.\n     * @param _vault - The target vault.\n     */\n    function setHeir(address _vault, address _newHeir) external;\n\n    /**\n     * @notice Function to be called when voting has to be toggled.\n     * @param _vault - The target vault.\n     */\n    function toggleVoting(address _vault) external;\n\n    /**\n     * @notice Set or unsets lock for a vault contract.\n     * @param _vault - The target vault.\n     * @param _lock - Lock needed to be set.\n     */\n    function setLock(address _vault, bool _lock) external;\n\n    /**\n     * @notice Sets a new time delay for a vault contract.\n     * @param _vault - The target vault.\n     * @param _newTimeDelay - The new time delay.\n     */\n    function setTimeDelay(address _vault, uint256 _newTimeDelay) external;\n\n    /**\n     * @notice Checks if an account is a guardian for a vault.\n     * @param _vault - The target vault.\n     * @param _guardian - The account address to be checked.\n     * @return true if the account is a guardian for a vault.\n     */\n    function isGuardian(address _vault, address _guardian) external view returns (bool);\n\n    /**\n     * @notice Returns guardian address.\n     * @param _vault - The target vault.\n     * @return the address of the guardian account if guardian is added else returns zero address.\n     */\n    function getGuardian(address _vault) external view returns (address);\n\n    /**\n     * @notice Returns boolean indicating state of the vault.\n     * @param _vault - The target vault.\n     * @return true if the vault is locked, else returns false.\n     */\n    function isLocked(address _vault) external view returns (bool);\n\n    /**\n     * @notice Returns boolean indicating if voting is enabled.\n     * @param _vault - The target vault.\n     * @return true if voting is enabled, else returns false.\n     */\n    function votingEnabled(address _vault) external view returns (bool);\n\n    /**\n     * @notice Returns uint256 time delay in seconds for a vault\n     * @param _vault - The target vault.\n     * @return uint256 time delay in seconds for a vault.\n     */\n    function getTimeDelay(address _vault) external view returns (uint256);\n\n    /**\n     * @notice Returns an heir address for a vault.\n     * @param _vault - The target vault.\n     */\n    function getHeir(address _vault) external view returns(address);\n}"
30     },
31     "contracts/vault/IVault.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IVault\n * @notice Interface for the BaseVault\n */\ninterface IVault {\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value, bytes memory _initData) external;\n\n    /**\n     * @notice Enables a static method by specifying the target module to which the call must be delegated.\n     * @param _module The target module.\n     */\n    function enableStaticCall(address _module) external;\n\n\n    /**\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _initData bytes32 initilization data specific to the module.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] calldata _modules, bytes[] calldata _initData) external;\n\n    /**\n     * @notice Sets a new owner for the vault.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Returns the vault owner.\n     * @return The vault owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint256);\n\n    /**\n     * @notice Checks if a module is authorised on the vault.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible, if static call is enabled for `_sig`, otherwise return zero address.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection or zero address\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n}"
33     }
34   },
35   "settings": {
36     "optimizer": {
37       "enabled": true,
38       "runs": 100
39     },
40     "outputSelection": {
41       "*": {
42         "*": [
43           "evm.bytecode",
44           "evm.deployedBytecode",
45           "devdoc",
46           "userdoc",
47           "metadata",
48           "abi"
49         ]
50       }
51     },
52     "libraries": {}
53   }
54 }}