1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
6     },
7     "@openzeppelin-4.5/contracts/utils/math/SafeCast.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
9     },
10     "contracts/engine/GenArt721MinterDAExp_PBAB.sol": {
11       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../interfaces/0.8.x/IGenArt721CoreV2_PBAB.sol\";\n\nimport \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-4.5/contracts/utils/math/SafeCast.sol\";\n\npragma solidity 0.8.17;\n\n/**\n * @title A minter contract that allows tokens to be minted with ETH.\n * Pricing is achieved using an automated Dutch-auction mechanism.\n * This is a fork of MinterDAExpV2, which is intended to be used directly\n * with IGenArt721CoreV2_PBAB contracts rather than with IGenArt721CoreContractV3\n * and as such does not conform to IFilteredMinterV0 nor assume presence\n * of a IMinterFilterV0 conforming minter filter.\n * @author Art Blocks Inc.\n * @notice Privileged Roles and Ownership:\n * This contract is designed to be managed, with limited powers.\n * Privileged roles and abilities are controlled by the core contract's allowlisted\n * (`isWhitelisted` conforming) addresses and a project's artist. Both of these\n * roles hold extensive power and can modify minter details.\n * Care must be taken to ensure that the core contract permissions and artist\n * addresses are secure behind a multi-sig or other access control mechanism.\n * ----------------------------------------------------------------------------\n * The following functions are restricted to the core contract's allowlisted\n * (`isWhitelisted` conforming) address(es):\n * - setAllowablePriceDecayHalfLifeRangeSeconds (note: this range is only\n *   enforced when creating new auctions)\n * - resetAuctionDetails (note: this will prevent minting until a new auction\n *   is created)\n * ----------------------------------------------------------------------------\n * The following functions are restricted to a project's artist:\n * - setAuctionDetails (note: this may only be called when there is no active\n *   auction)\n * ----------------------------------------------------------------------------\n * Additional admin and artist privileged roles may be described on other\n * contracts that this minter integrates with.\n *\n * @dev Note that while this minter makes use of `block.timestamp` and it is\n * technically possible that this value is manipulated by block producers, such\n * manipulation will not have material impact on the price values of this minter\n * given the business practices for how pricing is congfigured for this minter\n * and that variations on the order of less than a minute should not\n * meaningfully impact price given the minimum allowable price decay rate that\n * this minter intends to support.\n */\ncontract GenArt721MinterDAExp_PBAB is ReentrancyGuard {\n    using SafeCast for uint256;\n\n    /// Auction details updated for project `projectId`.\n    event SetAuctionDetails(\n        uint256 indexed projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    );\n\n    /// Auction details cleared for project `projectId`.\n    event ResetAuctionDetails(uint256 indexed projectId);\n\n    /// Maximum and minimum allowed price decay half lifes updated.\n    event AuctionHalfLifeRangeSecondsUpdated(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    );\n\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IGenArt721CoreV2_PBAB\n    IGenArt721CoreV2_PBAB private immutable genArtCoreContract;\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    address payable public ownerAddress;\n    uint256 public ownerPercentage;\n\n    struct ProjectConfig {\n        bool maxHasBeenInvoked;\n        uint24 maxInvocations;\n        // max uint64 ~= 1.8e19 sec ~= 570 billion years\n        uint64 timestampStart;\n        uint64 priceDecayHalfLifeSeconds;\n        uint256 startPrice;\n        uint256 basePrice;\n    }\n\n    mapping(uint256 => ProjectConfig) public projectConfig;\n\n    /// Minimum price decay half life: price must decay with a half life of at\n    /// least this amount (must cut in half at least every N seconds).\n    uint256 public minimumPriceDecayHalfLifeSeconds = 300; // 5 minutes\n    /// Maximum price decay half life: price may decay with a half life of no\n    /// more than this amount (may cut in half at no more than every N seconds).\n    uint256 public maximumPriceDecayHalfLifeSeconds = 3600; // 60 minutes\n\n    // modifier to restrict access to only addresses specified by the\n    // `onlyWhitelisted()` method on the associated core contract\n    modifier onlyCoreAllowlisted() {\n        require(\n            genArtCoreContract.isWhitelisted(msg.sender),\n            \"Only Core allowlisted\"\n        );\n        _;\n    }\n\n    // modifier to restrict access to only the artist for a given project\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            (msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId)),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    // modifier to restrict access to calls only involving a valid projectId\n    // (an existing project)\n    modifier onlyValidProjectId(uint256 _projectId) {\n        require(\n            _projectId < genArtCoreContract.nextProjectId(),\n            \"Only existing projects\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be integrated with\n     * Art Blocks core contract at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     */\n    constructor(address _genArt721Address) ReentrancyGuard() {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreV2_PBAB(_genArt721Address);\n    }\n\n    /**\n     * @notice Sets the minter owner (the platform provider) address to `_ownerAddress`.\n     * @param _ownerAddress New owner address.\n     */\n    function setOwnerAddress(\n        address payable _ownerAddress\n    ) public onlyCoreAllowlisted {\n        ownerAddress = _ownerAddress;\n    }\n\n    /**\n     * @notice Sets the minter owner (the platform provider) revenue % to `_ownerPercentage` percent.\n     * @param _ownerPercentage New owner percentage.\n     */\n    function setOwnerPercentage(\n        uint256 _ownerPercentage\n    ) public onlyCoreAllowlisted {\n        ownerPercentage = _ownerPercentage;\n    }\n\n    /**\n     * @notice Syncs local maximum invocations of project `_projectId` based on\n     * the value currently defined in the core contract. Only used for gas\n     * optimization of mints after maxInvocations has been reached.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     * @dev function is intentionally not gated to any specific access control;\n     * it only syncs a local state variable to the core contract's state.\n     */\n    function setProjectMaxInvocations(uint256 _projectId) external {\n        uint256 maxInvocations;\n        uint256 invocations;\n        (, , invocations, maxInvocations, , , , , ) = genArtCoreContract\n            .projectTokenInfo(_projectId);\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\n        if (invocations < maxInvocations) {\n            projectConfig[_projectId].maxHasBeenInvoked = false;\n        }\n    }\n\n    /**\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\n     * This method exists purely for interface-conformance purposes.\n     */\n    function togglePurchaseToDisabled(\n        uint256 _projectId\n    ) external view onlyArtist(_projectId) {\n        revert(\"Action not supported\");\n    }\n\n    /**\n     * @notice projectId => has project reached its maximum number of\n     * invocations? Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached. A false negative will\n     * only result in a gas cost increase, since the core contract will still\n     * enforce a maxInvocation check during minting. A false positive is not\n     * possible because the V2 engine core contract only allows maximum invocations\n     * to be reduced, not increased. Based on this rationale, we intentionally\n     * do not do input validation in this method as to whether or not the input\n     * `_projectId` is an existing project ID.\n     *\n     */\n    function projectMaxHasBeenInvoked(\n        uint256 _projectId\n    ) external view returns (bool) {\n        return projectConfig[_projectId].maxHasBeenInvoked;\n    }\n\n    /**\n     * @notice projectId => project's maximum number of invocations.\n     * Optionally synced with core contract value, for gas optimization.\n     * Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached.\n     * @dev A number greater than the core contract's project max invocations\n     * will only result in a gas cost increase, since the core contract will\n     * still enforce a maxInvocation check during minting. A number less than\n     * the core contract's project max invocations is only possible when the\n     * project's max invocations have not been synced on this minter, since the\n     * V2 engine core contract only allows maximum invocations to be reduced, not\n     * increased. When this happens, the minter will enable minting, allowing\n     * the core contract to enforce the max invocations check. Based on this\n     * rationale, we intentionally do not do input validation in this method as\n     * to whether or not the input `_projectId` is an existing project ID.\n     */\n    function projectMaxInvocations(\n        uint256 _projectId\n    ) external view returns (uint256) {\n        return uint256(projectConfig[_projectId].maxInvocations);\n    }\n\n    /**\n     * @notice projectId => auction parameters\n     */\n    function projectAuctionParameters(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            uint256 timestampStart,\n            uint256 priceDecayHalfLifeSeconds,\n            uint256 startPrice,\n            uint256 basePrice\n        )\n    {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        return (\n            _projectConfig.timestampStart,\n            _projectConfig.priceDecayHalfLifeSeconds,\n            _projectConfig.startPrice,\n            _projectConfig.basePrice\n        );\n    }\n\n    /**\n     * @notice Sets the minimum and maximum values that are settable for\n     * `_priceDecayHalfLifeSeconds` across all projects.\n     * @param _minimumPriceDecayHalfLifeSeconds Minimum price decay half life\n     * (in seconds).\n     * @param _maximumPriceDecayHalfLifeSeconds Maximum price decay half life\n     * (in seconds).\n     */\n    function setAllowablePriceDecayHalfLifeRangeSeconds(\n        uint256 _minimumPriceDecayHalfLifeSeconds,\n        uint256 _maximumPriceDecayHalfLifeSeconds\n    ) external onlyCoreAllowlisted {\n        require(\n            _maximumPriceDecayHalfLifeSeconds >\n                _minimumPriceDecayHalfLifeSeconds,\n            \"Maximum half life must be greater than minimum\"\n        );\n        require(\n            _minimumPriceDecayHalfLifeSeconds > 0,\n            \"Half life of zero not allowed\"\n        );\n        minimumPriceDecayHalfLifeSeconds = _minimumPriceDecayHalfLifeSeconds;\n        maximumPriceDecayHalfLifeSeconds = _maximumPriceDecayHalfLifeSeconds;\n        emit AuctionHalfLifeRangeSecondsUpdated(\n            _minimumPriceDecayHalfLifeSeconds,\n            _maximumPriceDecayHalfLifeSeconds\n        );\n    }\n\n    ////// Auction Functions\n    /**\n     * @notice Sets auction details for project `_projectId`.\n     * @param _projectId Project ID to set auction details for.\n     * @param _auctionTimestampStart Timestamp at which to start the auction.\n     * @param _priceDecayHalfLifeSeconds The half life with which to decay the\n     *  price (in seconds).\n     * @param _startPrice Price at which to start the auction, in Wei.\n     * @param _basePrice Resting price of the auction, in Wei.\n     * @dev Note that it is intentionally supported here that the configured\n     * price may be explicitly set to `0`.\n     */\n    function setAuctionDetails(\n        uint256 _projectId,\n        uint256 _auctionTimestampStart,\n        uint256 _priceDecayHalfLifeSeconds,\n        uint256 _startPrice,\n        uint256 _basePrice\n    ) external onlyValidProjectId(_projectId) onlyArtist(_projectId) {\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        require(\n            _projectConfig.timestampStart == 0 ||\n                block.timestamp < _projectConfig.timestampStart,\n            \"No modifications mid-auction\"\n        );\n        require(\n            block.timestamp < _auctionTimestampStart,\n            \"Only future auctions\"\n        );\n        require(\n            _startPrice >= _basePrice,\n            \"Auction start price must be greater than or equal to auction end price\"\n        );\n        require(\n            (_priceDecayHalfLifeSeconds >= minimumPriceDecayHalfLifeSeconds) &&\n                (_priceDecayHalfLifeSeconds <=\n                    maximumPriceDecayHalfLifeSeconds),\n            \"Price decay half life must fall between min and max allowable values\"\n        );\n        // EFFECTS\n        _projectConfig.timestampStart = _auctionTimestampStart.toUint64();\n        _projectConfig.priceDecayHalfLifeSeconds = _priceDecayHalfLifeSeconds\n            .toUint64();\n        _projectConfig.startPrice = _startPrice;\n        _projectConfig.basePrice = _basePrice;\n\n        emit SetAuctionDetails(\n            _projectId,\n            _auctionTimestampStart,\n            _priceDecayHalfLifeSeconds,\n            _startPrice,\n            _basePrice\n        );\n    }\n\n    /**\n     * @notice Resets auction details for project `_projectId`, zero-ing out all\n     * relevant auction fields. Not intended to be used in normal auction\n     * operation, but rather only in case of the need to halt an auction.\n     * @param _projectId Project ID to set auction details for.\n     */\n    function resetAuctionDetails(\n        uint256 _projectId\n    ) external onlyCoreAllowlisted onlyValidProjectId(_projectId) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        // reset to initial values\n        _projectConfig.timestampStart = 0;\n        _projectConfig.priceDecayHalfLifeSeconds = 0;\n        _projectConfig.startPrice = 0;\n        _projectConfig.basePrice = 0;\n\n        emit ResetAuctionDetails(_projectId);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice gas-optimized version of purchase(uint256).\n     */\n    function purchase_H4M(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(\n        address _to,\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId) {\n        return purchaseTo_do6(_to, _projectId);\n    }\n\n    /**\n     * @notice gas-optimized version of purchaseTo(address, uint256).\n     */\n    function purchaseTo_do6(\n        address _to,\n        uint256 _projectId\n    ) public payable nonReentrant returns (uint256 tokenId) {\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\n        // consumption after a project has been fully minted.\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\n        // gas consumption, but if not in sync with the core contract's value,\n        // the core contract also enforces its own max invocation check during\n        // minting.\n        require(\n            !_projectConfig.maxHasBeenInvoked,\n            \"Maximum number of invocations reached\"\n        );\n\n        // _getPrice reverts if auction is unconfigured or has not started\n        uint256 currentPriceInWei = _getPrice(_projectId);\n        require(\n            msg.value >= currentPriceInWei,\n            \"Must send minimum value to mint!\"\n        );\n\n        // EFFECTS\n        tokenId = genArtCoreContract.mint(_to, _projectId, msg.sender);\n\n        // okay if this underflows because if statement will always eval false.\n        // this is only for gas optimization (core enforces maxInvocations).\n        unchecked {\n            if (tokenId % ONE_MILLION == _projectConfig.maxInvocations - 1) {\n                _projectConfig.maxHasBeenInvoked = true;\n            }\n        }\n\n        // INTERACTIONS\n        _splitFundsETHAuction(_projectId, currentPriceInWei);\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     * @param _projectId Project ID for which funds shall be split.\n     * @param _currentPriceInWei Current price of token, in Wei.\n     */\n    function _splitFundsETHAuction(\n        uint256 _projectId,\n        uint256 _currentPriceInWei\n    ) internal {\n        if (msg.value > 0) {\n            bool success_;\n            // send refund to sender\n            uint256 refund = msg.value - _currentPriceInWei;\n            if (refund > 0) {\n                (success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            // split remaining funds between render provider, platform provider,\n            // artist, and artist's additional payee\n            uint256 remainingFunds = _currentPriceInWei;\n\n            // Render provider payment\n            uint256 renderProviderAmount = (remainingFunds *\n                genArtCoreContract.renderProviderPercentage()) / 100;\n            if (renderProviderAmount > 0) {\n                (success_, ) = genArtCoreContract.renderProviderAddress().call{\n                    value: renderProviderAmount\n                }(\"\");\n                require(success_, \"Renderer payment failed\");\n                remainingFunds -= renderProviderAmount;\n            }\n\n            // Owner (platform provider) payment\n            uint256 ownerFunds = (remainingFunds * ownerPercentage) / 100;\n            if (ownerFunds > 0) {\n                (success_, ) = ownerAddress.call{value: ownerFunds}(\"\");\n                require(success_, \"Owner payment failed\");\n                remainingFunds -= ownerFunds;\n            }\n\n            // Artist additional payee payment\n            uint256 additionalPayeePercentage = genArtCoreContract\n                .projectIdToAdditionalPayeePercentage(_projectId);\n            if (additionalPayeePercentage > 0) {\n                uint256 additionalPayeeAmount = (remainingFunds *\n                    additionalPayeePercentage) / 100;\n                if (additionalPayeeAmount > 0) {\n                    (success_, ) = genArtCoreContract\n                        .projectIdToAdditionalPayee(_projectId)\n                        .call{value: additionalPayeeAmount}(\"\");\n                    require(success_, \"Additional payment failed\");\n                    remainingFunds -= additionalPayeeAmount;\n                }\n            }\n\n            // Artist payment\n            if (remainingFunds > 0) {\n                (success_, ) = genArtCoreContract\n                    .projectIdToArtistAddress(_projectId)\n                    .call{value: remainingFunds}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @notice Gets price of minting a token on project `_projectId` given\n     * the project's AuctionParameters and current block timestamp.\n     * Reverts if auction has not yet started or auction is unconfigured.\n     * @param _projectId Project ID to get price of token for.\n     * @return current price of token in Wei\n     * @dev This method calculates price decay using a linear interpolation\n     * of exponential decay based on the artist-provided half-life for price\n     * decay, `_priceDecayHalfLifeSeconds`.\n     */\n    function _getPrice(uint256 _projectId) private view returns (uint256) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        // move parameters to memory if used more than once\n        uint256 _timestampStart = uint256(_projectConfig.timestampStart);\n        uint256 _priceDecayHalfLifeSeconds = uint256(\n            _projectConfig.priceDecayHalfLifeSeconds\n        );\n        uint256 _basePrice = _projectConfig.basePrice;\n\n        require(block.timestamp > _timestampStart, \"Auction not yet started\");\n        require(_priceDecayHalfLifeSeconds > 0, \"Only configured auctions\");\n        uint256 decayedPrice = _projectConfig.startPrice;\n        uint256 elapsedTimeSeconds;\n        // Return early if configured in \"fixed price mode\" for gas efficiency\n        if (decayedPrice /* startPrice */ == _basePrice) {\n            return _basePrice;\n        }\n        unchecked {\n            // already checked that block.timestamp > _timestampStart above\n            elapsedTimeSeconds = block.timestamp - _timestampStart;\n        }\n        // Divide by two (via bit-shifting) for the number of entirely completed\n        // half-lives that have elapsed since auction start time.\n        unchecked {\n            // already required _priceDecayHalfLifeSeconds > 0\n            decayedPrice >>= elapsedTimeSeconds / _priceDecayHalfLifeSeconds;\n        }\n        // Perform a linear interpolation between partial half-life points, to\n        // approximate the current place on a perfect exponential decay curve.\n        unchecked {\n            // value of expression is provably always less than decayedPrice,\n            // so no underflow is possible when the subtraction assignment\n            // operator is used on decayedPrice.\n            decayedPrice -=\n                (decayedPrice *\n                    (elapsedTimeSeconds % _priceDecayHalfLifeSeconds)) /\n                _priceDecayHalfLifeSeconds /\n                2;\n        }\n        if (decayedPrice < _basePrice) {\n            // Price may not decay below stay `basePrice`.\n            return _basePrice;\n        }\n        return decayedPrice;\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if project's auction parameters have been\n     * configured on this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if auction has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n\n        isConfigured = (_projectConfig.startPrice > 0);\n        if (block.timestamp <= _projectConfig.timestampStart) {\n            // Provide a reasonable value for `tokenPriceInWei` when it would\n            // otherwise revert, using the starting price before auction starts.\n            tokenPriceInWei = _projectConfig.startPrice;\n        } else if (_projectConfig.startPrice == 0) {\n            // In the case of unconfigured auction, return price of zero when\n            // it would otherwise revert\n            tokenPriceInWei = 0;\n        } else {\n            tokenPriceInWei = _getPrice(_projectId);\n        }\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
12     },
13     "contracts/interfaces/0.8.x/IGenArt721CoreV2_PBAB.sol": {
14       "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IGenArt721CoreV2_PBAB {\n    /**\n     * @notice Token ID `_tokenId` minted on project ID `_projectId` to `_to`.\n     */\n    event Mint(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        uint256 indexed _projectId\n    );\n\n    // getter function of public variable\n    function admin() external view returns (address);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(\n        uint256 tokenId\n    ) external view returns (uint256 projectId);\n\n    function isWhitelisted(address sender) external view returns (bool);\n\n    function projectIdToCurrencySymbol(\n        uint256 _projectId\n    ) external view returns (string memory);\n\n    function projectIdToCurrencyAddress(\n        uint256 _projectId\n    ) external view returns (address);\n\n    function projectIdToArtistAddress(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToPricePerTokenInWei(\n        uint256 _projectId\n    ) external view returns (uint256);\n\n    function projectIdToAdditionalPayee(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToAdditionalPayeePercentage(\n        uint256 _projectId\n    ) external view returns (uint256);\n\n    function projectTokenInfo(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            address,\n            uint256,\n            string memory,\n            address\n        );\n\n    function renderProviderAddress() external view returns (address payable);\n\n    function renderProviderPercentage() external view returns (uint256);\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    function getRoyaltyData(\n        uint256 _tokenId\n    )\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
15     }
16   },
17   "settings": {
18     "optimizer": {
19       "enabled": true,
20       "runs": 25
21     },
22     "outputSelection": {
23       "*": {
24         "*": [
25           "evm.bytecode",
26           "evm.deployedBytecode",
27           "devdoc",
28           "userdoc",
29           "metadata",
30           "abi"
31         ]
32       }
33     },
34     "libraries": {}
35   }
36 }}