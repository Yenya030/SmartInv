1 //*********************************************************************//
2 //*********************************************************************//                                                    
3 //  
4 //       
5 //       8888888b.         d8888 888b     d888 8888888b.  8888888b.  
6 //       888   Y88b       d88888 8888b   d8888 888   Y88b 888   Y88b 
7 //       888    888      d88P888 88888b.d88888 888    888 888    888 
8 //       888   d88P     d88P 888 888Y88888P888 888   d88P 888   d88P 
9 //       8888888P"     d88P  888 888 Y888P 888 8888888P"  8888888P"  
10 //       888 T88b     d88P   888 888  Y8P  888 888        888        
11 //       888  T88b   d8888888888 888   "   888 888        888        
12 //       888   T88b d88P     888 888       888 888        888        
13 //       v1.1.0
14 //     
15 //                                                               
16 //    This project and smart contract was generated by rampp.xyz.
17 //            Rampp allows creators like you to launch 
18 //             large scale NFT projects without code!
19 //
20 //    Rampp is not responsible for the content of this contract and
21 //        hopes it is being used in a responsible and kind way.                                                         
22 //             Twitter: @RamppDAO ---- rampp.xyz
23 //    
24 //*********************************************************************//                                                     
25 //*********************************************************************// 
26 
27 
28 
29     
30     // File: contracts/common/meta-transactions/Initializable.sol
31 
32     pragma solidity ^ 0.8.0;
33 
34     contract Initializable {
35       bool inited = false;
36 
37       modifier initializer() {
38         require(!inited, "already inited");
39         _;
40         inited = true;
41       }
42     }
43 
44     // File: contracts/common/meta-transactions/EIP712Base.sol
45 
46 
47 
48     pragma solidity ^ 0.8.0;
49 
50 
51     contract EIP712Base is Initializable {
52         struct EIP712Domain {
53           string name;
54           string version;
55           address verifyingContract;
56           bytes32 salt;
57         }
58 
59         string public constant ERC712_VERSION = "1";
60 
61         bytes32 internal constant EIP712_DOMAIN_TYPEHASH =
62       keccak256(
63         bytes(
64           "EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)"
65         )
66       );
67         bytes32 internal domainSeperator;
68 
69     // supposed to be called once while initializing.
70     // one of the contracts that inherits this contract follows proxy pattern
71     // so it is not possible to do this in a constructor
72     function _initializeEIP712(string memory name) internal initializer {
73       _setDomainSeperator(name);
74     }
75 
76     function _setDomainSeperator(string memory name) internal {
77       domainSeperator = keccak256(
78         abi.encode(
79           EIP712_DOMAIN_TYPEHASH,
80           keccak256(bytes(name)),
81           keccak256(bytes(ERC712_VERSION)),
82           address(this),
83           bytes32(getChainId())
84         )
85       );
86     }
87 
88     function getDomainSeperator() public view returns(bytes32) {
89       return domainSeperator;
90     }
91 
92     function getChainId() public view returns(uint256) {
93             uint256 id;
94             assembly {
95         id:= chainid()
96       }
97       return id;
98     }
99 
100     /**
101      * Accept message hash and returns hash message in EIP712 compatible form
102      * So that it can be used to recover signer from signature signed using EIP712 formatted data
103      * https://eips.ethereum.org/EIPS/eip-712
104      * "\x19" makes the encoding deterministic
105      * "\x01" is the version byte to make it compatible to EIP-191
106      */
107     function toTypedMessageHash(bytes32 messageHash)
108     internal
109     view
110     returns(bytes32)
111     {
112       return
113       keccak256(
114         abi.encodePacked("\x19\x01", getDomainSeperator(), messageHash)
115       );
116     }
117   }
118 
119 // File: contracts/common/meta-transactions/ContentMixin.sol
120 
121 
122 
123 pragma solidity ^ 0.8.0;
124 
125 abstract contract ContextMixin {
126   function msgSender() internal view returns(address payable sender) {
127     if (msg.sender == address(this)) {
128               bytes memory array = msg.data;
129               uint256 index = msg.data.length;
130               assembly {
131         // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
132         sender:= and(
133           mload(add(array, index)),
134           0xffffffffffffffffffffffffffffffffffffffff
135         )
136       }
137     } else {
138       sender = payable(msg.sender);
139     }
140     return sender;
141   }
142 }
143 
144 // File: @openzeppelin/contracts/utils/math/SafeMath.sol
145 
146 
147 
148 pragma solidity ^ 0.8.0;
149 
150   // CAUTION
151   // This version of SafeMath should only be used with Solidity 0.8 or later,
152   // because it relies on the compiler's built in overflow checks.
153 
154     /**
155      * @dev Wrappers over Solidity's arithmetic operations.
156      *
157      * NOTE: 'SafeMath' is no longer needed starting with Solidity 0.8. The compiler
158      * now has built in overflow checking.
159      */
160     library SafeMath {
161     /**
162      * @dev Returns the addition of two unsigned integers, with an overflow flag.
163      *
164      * _Available since v3.4._
165      */
166     function tryAdd(uint256 a, uint256 b) internal pure returns(bool, uint256) {
167             unchecked {
168                 uint256 c = a + b;
169         if (c < a) return (false, 0);
170         return (true, c);
171       }
172     }
173 
174     /**
175      * @dev Returns the substraction of two unsigned integers, with an overflow flag.
176      *
177      * _Available since v3.4._
178      */
179     function trySub(uint256 a, uint256 b) internal pure returns(bool, uint256) {
180             unchecked {
181         if (b > a) return (false, 0);
182         return (true, a - b);
183       }
184     }
185 
186     /**
187      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
188      *
189      * _Available since v3.4._
190      */
191     function tryMul(uint256 a, uint256 b) internal pure returns(bool, uint256) {
192             unchecked {
193         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
194         // benefit is lost if 'b' is also tested.
195         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
196         if (a == 0) return (true, 0);
197                 uint256 c = a * b;
198         if (c / a != b) return (false, 0);
199         return (true, c);
200       }
201     }
202 
203     /**
204      * @dev Returns the division of two unsigned integers, with a division by zero flag.
205      *
206      * _Available since v3.4._
207      */
208     function tryDiv(uint256 a, uint256 b) internal pure returns(bool, uint256) {
209             unchecked {
210         if (b == 0) return (false, 0);
211         return (true, a / b);
212       }
213     }
214 
215     /**
216      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
217      *
218      * _Available since v3.4._
219      */
220     function tryMod(uint256 a, uint256 b) internal pure returns(bool, uint256) {
221             unchecked {
222         if (b == 0) return (false, 0);
223         return (true, a % b);
224       }
225     }
226 
227     /**
228      * @dev Returns the addition of two unsigned integers, reverting on
229      * overflow.
230      *
231      * Counterpart to Solidity's '+' operator.
232      *
233      * Requirements:
234      *
235      * - Addition cannot overflow.
236      */
237     function add(uint256 a, uint256 b) internal pure returns(uint256) {
238       return a + b;
239     }
240 
241     /**
242      * @dev Returns the subtraction of two unsigned integers, reverting on
243      * overflow (when the result is negative).
244      *
245      * Counterpart to Solidity's '- ' operator.
246      *
247      * Requirements:
248      *
249      * - Subtraction cannot overflow.
250      */
251     function sub(uint256 a, uint256 b) internal pure returns(uint256) {
252       return a - b;
253     }
254 
255     /**
256      * @dev Returns the multiplication of two unsigned integers, reverting on
257      * overflow.
258      *
259      * Counterpart to Solidity's '* ' operator.
260      *
261      * Requirements:
262      *
263      * - Multiplication cannot overflow.
264      */
265     function mul(uint256 a, uint256 b) internal pure returns(uint256) {
266       return a * b;
267     }
268 
269     /**
270      * @dev Returns the integer division of two unsigned integers, reverting on
271      * division by zero. The result is rounded towards zero.
272      *
273      * Counterpart to Solidity's '/ ' operator.
274      *
275      * Requirements:
276      *
277      * - The divisor cannot be zero.
278      */
279     function div(uint256 a, uint256 b) internal pure returns(uint256) {
280       return a / b;
281     }
282 
283     /**
284      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
285      * reverting when dividing by zero.
286      *
287      * Counterpart to Solidity's '% ' operator. This function uses a 'revert'
288      * opcode (which leaves remaining gas untouched) while Solidity uses an
289      * invalid opcode to revert (consuming all remaining gas).
290      *
291      * Requirements:
292      *
293      * - The divisor cannot be zero.
294      */
295     function mod(uint256 a, uint256 b) internal pure returns(uint256) {
296       return a % b;
297     }
298 
299     /**
300      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
301      * overflow (when the result is negative).
302      *
303      * CAUTION: This function is deprecated because it requires allocating memory for the error
304      * message unnecessarily. For custom revert reasons use {trySub}.
305      *
306      * Counterpart to Solidity's '- ' operator.
307      *
308      * Requirements:
309      *
310      * - Subtraction cannot overflow.
311      */
312     function sub(
313       uint256 a,
314       uint256 b,
315       string memory errorMessage
316     ) internal pure returns(uint256) {
317             unchecked {
318         require(b <= a, errorMessage);
319         return a - b;
320       }
321     }
322 
323     /**
324      * @dev Returns the integer division of two unsigned integers, reverting with custom message on
325      * division by zero. The result is rounded towards zero.
326      *
327      * Counterpart to Solidity's '/ ' operator. Note: this function uses a
328      * 'revert' opcode (which leaves remaining gas untouched) while Solidity
329      * uses an invalid opcode to revert (consuming all remaining gas).
330      *
331      * Requirements:
332      *
333      * - The divisor cannot be zero.
334      */
335     function div(
336       uint256 a,
337       uint256 b,
338       string memory errorMessage
339     ) internal pure returns(uint256) {
340             unchecked {
341         require(b > 0, errorMessage);
342         return a / b;
343       }
344     }
345 
346     /**
347      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
348      * reverting with custom message when dividing by zero.
349      *
350      * CAUTION: This function is deprecated because it requires allocating memory for the error
351      * message unnecessarily. For custom revert reasons use {tryMod}.
352      *
353      * Counterpart to Solidity's '% ' operator. This function uses a 'revert'
354      * opcode (which leaves remaining gas untouched) while Solidity uses an
355      * invalid opcode to revert (consuming all remaining gas).
356      *
357      * Requirements:
358      *
359      * - The divisor cannot be zero.
360      */
361     function mod(
362       uint256 a,
363       uint256 b,
364       string memory errorMessage
365     ) internal pure returns(uint256) {
366             unchecked {
367         require(b > 0, errorMessage);
368         return a % b;
369       }
370     }
371   }
372 
373     // File: contracts/common/meta-transactions/NativeMetaTransaction.sol
374 
375 
376 
377     pragma solidity ^ 0.8.0;
378 
379 
380 
381     contract NativeMetaTransaction is EIP712Base {
382         using SafeMath for uint256;
383       bytes32 private constant META_TRANSACTION_TYPEHASH =
384         keccak256(
385           bytes(
386             "MetaTransaction(uint256 nonce,address from,bytes functionSignature)"
387           )
388         );
389         event MetaTransactionExecuted(
390           address userAddress,
391           address payable relayerAddress,
392           bytes functionSignature
393         );
394     mapping(address => uint256) nonces;
395 
396         /*
397         * Meta transaction structure.
398         * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas
399         * He should call the desired function directly in that case.
400         */
401         struct MetaTransaction {
402             uint256 nonce;
403             address from;
404             bytes functionSignature;
405     }
406 
407     function executeMetaTransaction(
408       address userAddress,
409       bytes memory functionSignature,
410       bytes32 sigR,
411       bytes32 sigS,
412       uint8 sigV
413     ) public payable returns(bytes memory) {
414             MetaTransaction memory metaTx = MetaTransaction({
415       nonce: nonces[userAddress],
416       from: userAddress,
417       functionSignature: functionSignature
418     });
419 
420       require(
421         verify(userAddress, metaTx, sigR, sigS, sigV),
422         "Signer and signature do not match"
423       );
424 
425       // increase nonce for user (to avoid re-use)
426       nonces[userAddress] = nonces[userAddress].add(1);
427 
428             emit MetaTransactionExecuted(
429         userAddress,
430         payable(msg.sender),
431         functionSignature
432       );
433 
434       // Append userAddress and relayer address at the end to extract it from calling context
435       (bool success, bytes memory returnData) = address(this).call(
436         abi.encodePacked(functionSignature, userAddress)
437       );
438       require(success, "Function call not successful");
439 
440       return returnData;
441     }
442 
443     function hashMetaTransaction(MetaTransaction memory metaTx)
444     internal
445     pure
446     returns(bytes32)
447     {
448       return
449       keccak256(
450         abi.encode(
451           META_TRANSACTION_TYPEHASH,
452           metaTx.nonce,
453           metaTx.from,
454           keccak256(metaTx.functionSignature)
455         )
456       );
457     }
458 
459     function getNonce(address user) public view returns(uint256 nonce) {
460       nonce = nonces[user];
461     }
462 
463     function verify(
464       address signer,
465       MetaTransaction memory metaTx,
466       bytes32 sigR,
467       bytes32 sigS,
468       uint8 sigV
469     ) internal view returns(bool) {
470       require(signer != address(0), "NativeMetaTransaction: INVALID_SIGNER");
471       return
472       signer ==
473         ecrecover(
474           toTypedMessageHash(hashMetaTransaction(metaTx)),
475           sigV,
476           sigR,
477           sigS
478         );
479     }
480   }
481 
482     // File: @openzeppelin/contracts/utils/Strings.sol
483 
484 
485 
486     pragma solidity ^ 0.8.0;
487 
488     /**
489      * @dev String operations.
490      */
491     library Strings {
492         bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
493 
494     /**
495      * @dev Converts a 'uint256' to its ASCII 'string' decimal representation.
496      */
497     function toString(uint256 value) internal pure returns(string memory) {
498       // Inspired by OraclizeAPI's implementation - MIT licence
499       // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
500 
501       if (value == 0) {
502         return "0";
503       }
504             uint256 temp = value;
505             uint256 digits;
506       while (temp != 0) {
507         digits++;
508         temp /= 10;
509       }
510             bytes memory buffer = new bytes(digits);
511       while (value != 0) {
512         digits -= 1;
513         buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
514         value /= 10;
515       }
516       return string(buffer);
517     }
518 
519     /**
520      * @dev Converts a 'uint256' to its ASCII 'string' hexadecimal representation.
521      */
522     function toHexString(uint256 value) internal pure returns(string memory) {
523       if (value == 0) {
524         return "0x00";
525       }
526             uint256 temp = value;
527             uint256 length = 0;
528       while (temp != 0) {
529         length++;
530         temp >>= 8;
531       }
532       return toHexString(value, length);
533     }
534 
535     /**
536      * @dev Converts a 'uint256' to its ASCII 'string' hexadecimal representation with fixed length.
537      */
538     function toHexString(uint256 value, uint256 length) internal pure returns(string memory) {
539             bytes memory buffer = new bytes(2 * length + 2);
540       buffer[0] = "0";
541       buffer[1] = "x";
542       for (uint256 i = 2 * length + 1; i > 1; --i) {
543         buffer[i] = _HEX_SYMBOLS[value & 0xf];
544         value >>= 4;
545       }
546       require(value == 0, "Strings: hex length insufficient");
547       return string(buffer);
548     }
549   }
550 
551     // File: @openzeppelin/contracts/utils/Context.sol
552 
553 
554 
555     pragma solidity ^ 0.8.0;
556 
557     /**
558      * @dev Provides information about the current execution context, including the
559      * sender of the transaction and its data. While these are generally available
560      * via msg.sender and msg.data, they should not be accessed in such a direct
561      * manner, since when dealing with meta-transactions the account sending and
562      * paying for execution may not be the actual sender (as far as an application
563      * is concerned).
564      *
565      * This contract is only required for intermediate, library-like contracts.
566      */
567     abstract contract Context {
568     function _msgSender() internal view virtual returns(address) {
569       return msg.sender;
570     }
571 
572     function _msgData() internal view virtual returns(bytes calldata) {
573       return msg.data;
574     }
575   }
576 
577     // File: @openzeppelin/contracts/access/Ownable.sol
578 
579 
580 
581     pragma solidity ^ 0.8.0;
582 
583 
584     /**
585      * @dev Contract module which provides a basic access control mechanism, where
586      * there is an account (an owner) that can be granted exclusive access to
587      * specific functions.
588      *
589      * By default, the owner account will be the one that deploys the contract. This
590      * can later be changed with {transferOwnership}.
591      *
592      * This module is used through inheritance. It will make available the modifier
593      * 'onlyOwner', which can be applied to your functions to restrict their use to
594      * the owner.
595      */
596      abstract contract Ownable is Context {
597       address private _owner;
598   
599       event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
600   
601       /**
602        * @dev Initializes the contract setting the deployer as the initial owner.
603        */
604       constructor() {
605           _setOwner(_msgSender());
606       }
607   
608       /**
609        * @dev Returns the address of the current owner.
610        */
611       function owner() public view virtual returns (address) {
612           return _owner;
613       }
614   
615       /**
616        * @dev Throws if called by any account other than the owner.
617        */
618       modifier onlyOwner() {
619           require(owner() == _msgSender(), "Ownable: caller is not the owner");
620           _;
621       }
622      
623       /**
624        * @dev Leaves the contract without owner. It will not be possible to call
625        * 'onlyOwner' functions anymore. Can only be called by the current owner.
626        *
627        * NOTE: Renouncing ownership will leave the contract without an owner,
628        * thereby removing any functionality that is only available to the owner.
629        */
630       
631       function renounceOwnership() public virtual onlyOwner {
632         _setOwner(address(0));
633       }
634   
635       /**
636        * @dev Transfers ownership of the contract to a new account ('newOwner').
637        * Can only be called by the current owner.
638        */
639       function transferOwnership(address newOwner) public virtual onlyOwner {
640           require(newOwner != address(0), "Ownable: new owner is the zero address");
641           _setOwner(newOwner);
642       }
643       
644       function _setOwner(address newOwner) private {
645           address oldOwner = _owner;
646           _owner = newOwner;
647           emit OwnershipTransferred(oldOwner, newOwner);
648       }
649     }
650 
651     // File: @openzeppelin/contracts/utils/Address.sol
652 
653     pragma solidity ^ 0.8.0;
654 
655     /**
656      * @dev Collection of functions related to the address type
657      */
658     library Address {
659     /**
660      * @dev Returns true if 'account' is a contract.
661      *
662      * [IMPORTANT]
663      * ====
664      * It is unsafe to assume that an address for which this function returns
665      * false is an externally-owned account (EOA) and not a contract.
666      *
667      * Among others, 'isContract' will return false for the following
668      * types of addresses:
669      *
670      *  - an externally-owned account
671      *  - a contract in construction
672      *  - an address where a contract will be created
673      *  - an address where a contract lived, but was destroyed
674      * ====
675      */
676     function isContract(address account) internal view returns(bool) {
677             // This method relies on extcodesize, which returns 0 for contracts in
678             // construction, since the code is only stored at the end of the
679             // constructor execution.
680 
681             uint256 size;
682             assembly {
683         size:= extcodesize(account)
684       }
685       return size > 0;
686     }
687 
688     /**
689      * @dev Replacement for Solidity's 'transfer': sends 'amount' wei to
690      * 'recipient', forwarding all available gas and reverting on errors.
691      *
692      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
693      * of certain opcodes, possibly making contracts go over the 2300 gas limit
694      * imposed by 'transfer', making them unable to receive funds via
695      * 'transfer'. {sendValue} removes this limitation.
696      *
697      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
698      *
699      * IMPORTANT: because control is transferred to 'recipient', care must be
700      * taken to not create reentrancy vulnerabilities. Consider using
701      * {ReentrancyGuard} or the
702      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
703      */
704     function sendValue(address payable recipient, uint256 amount) internal {
705       require(address(this).balance >= amount, "Address: insufficient balance");
706 
707       (bool success, ) = recipient.call{ value: amount } ("");
708       require(success, "Address: unable to send value, recipient may have reverted");
709     }
710 
711     /**
712      * @dev Performs a Solidity function call using a low level 'call'. A
713      * plain 'call' is an unsafe replacement for a function call: use this
714      * function instead.
715      *
716      * If 'target' reverts with a revert reason, it is bubbled up by this
717      * function (like regular Solidity function calls).
718      *
719      * Returns the raw returned data. To convert to the expected return value,
720      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions['abi.decode'].
721      *
722      * Requirements:
723      *
724      * - 'target' must be a contract.
725      * - calling 'target' with 'data' must not revert.
726      *
727      * _Available since v3.1._
728      */
729     function functionCall(address target, bytes memory data) internal returns(bytes memory) {
730       return functionCall(target, data, "Address: low-level call failed");
731     }
732 
733     /**
734      * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'], but with
735      * 'errorMessage' as a fallback revert reason when 'target' reverts.
736      *
737      * _Available since v3.1._
738      */
739     function functionCall(
740       address target,
741       bytes memory data,
742       string memory errorMessage
743     ) internal returns(bytes memory) {
744       return functionCallWithValue(target, data, 0, errorMessage);
745     }
746 
747     /**
748      * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],
749      * but also transferring 'value' wei to 'target'.
750      *
751      * Requirements:
752      *
753      * - the calling contract must have an ETH balance of at least 'value'.
754      * - the called Solidity function must be 'payable'.
755      *
756      * _Available since v3.1._
757      */
758     function functionCallWithValue(
759       address target,
760       bytes memory data,
761       uint256 value
762     ) internal returns(bytes memory) {
763       return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
764     }
765 
766     /**
767      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}['functionCallWithValue'], but
768      * with 'errorMessage' as a fallback revert reason when 'target' reverts.
769      *
770      * _Available since v3.1._
771      */
772     function functionCallWithValue(
773       address target,
774       bytes memory data,
775       uint256 value,
776       string memory errorMessage
777     ) internal returns(bytes memory) {
778       require(address(this).balance >= value, "Address: insufficient balance for call");
779       require(isContract(target), "Address: call to non-contract");
780 
781       (bool success, bytes memory returndata) = target.call{ value: value } (data);
782       return verifyCallResult(success, returndata, errorMessage);
783     }
784 
785     /**
786      * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],
787      * but performing a static call.
788      *
789      * _Available since v3.3._
790      */
791     function functionStaticCall(address target, bytes memory data) internal view returns(bytes memory) {
792       return functionStaticCall(target, data, "Address: low-level static call failed");
793     }
794 
795     /**
796      * @dev Same as {xref-Address-functionCall-address-bytes-string-}['functionCall'],
797      * but performing a static call.
798      *
799      * _Available since v3.3._
800      */
801     function functionStaticCall(
802       address target,
803       bytes memory data,
804       string memory errorMessage
805     ) internal view returns(bytes memory) {
806       require(isContract(target), "Address: static call to non-contract");
807 
808       (bool success, bytes memory returndata) = target.staticcall(data);
809       return verifyCallResult(success, returndata, errorMessage);
810     }
811 
812     /**
813      * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],
814      * but performing a delegate call.
815      *
816      * _Available since v3.4._
817      */
818     function functionDelegateCall(address target, bytes memory data) internal returns(bytes memory) {
819       return functionDelegateCall(target, data, "Address: low-level delegate call failed");
820     }
821 
822     /**
823      * @dev Same as {xref-Address-functionCall-address-bytes-string-}['functionCall'],
824      * but performing a delegate call.
825      *
826      * _Available since v3.4._
827      */
828     function functionDelegateCall(
829       address target,
830       bytes memory data,
831       string memory errorMessage
832     ) internal returns(bytes memory) {
833       require(isContract(target), "Address: delegate call to non-contract");
834 
835       (bool success, bytes memory returndata) = target.delegatecall(data);
836       return verifyCallResult(success, returndata, errorMessage);
837     }
838 
839     /**
840      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
841      * revert reason using the provided one.
842      *
843      * _Available since v4.3._
844      */
845     function verifyCallResult(
846       bool success,
847       bytes memory returndata,
848       string memory errorMessage
849     ) internal pure returns(bytes memory) {
850       if (success) {
851         return returndata;
852       } else {
853         // Look for revert reason and bubble it up if present
854         if (returndata.length > 0) {
855                     // The easiest way to bubble the revert reason is using memory via assembly
856 
857                     assembly {
858             let returndata_size:= mload(returndata)
859             revert(add(32, returndata), returndata_size)
860           }
861         } else {
862           revert(errorMessage);
863         }
864       }
865     }
866   }
867 
868 // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
869 
870 
871 
872 pragma solidity ^ 0.8.0;
873 
874 /**
875  * @title ERC721 token receiver interface
876  * @dev Interface for any contract that wants to support safeTransfers
877  * from ERC721 asset contracts.
878  */
879 interface IERC721Receiver {
880   /**
881    * @dev Whenever an {IERC721} 'tokenId' token is transferred to this contract via {IERC721-safeTransferFrom}
882    * by 'operator' from 'from', this function is called.
883    *
884    * It must return its Solidity selector to confirm the token transfer.
885    * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
886    *
887    * The selector can be obtained in Solidity with 'IERC721.onERC721Received.selector'.
888    */
889   function onERC721Received(
890     address operator,
891     address from,
892     uint256 tokenId,
893     bytes calldata data
894   ) external returns(bytes4);
895 }
896 
897 // File: @openzeppelin/contracts/utils/introspection/IERC165.sol
898 
899 
900 
901 pragma solidity ^ 0.8.0;
902 
903 /**
904  * @dev Interface of the ERC165 standard, as defined in the
905  * https://eips.ethereum.org/EIPS/eip-165[EIP].
906  *
907  * Implementers can declare support of contract interfaces, which can then be
908  * queried by others ({ERC165Checker}).
909  *
910  * For an implementation, see {ERC165}.
911  */
912 interface IERC165 {
913         /**
914          * @dev Returns true if this contract implements the interface defined by
915          * 'interfaceId'. See the corresponding
916          * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
917          * to learn more about how these ids are created.
918          *
919          * This function call must use less than 30 000 gas.
920          */
921         function supportsInterface(bytes4 interfaceId) external view returns(bool);
922     }
923 
924 // File: @openzeppelin/contracts/utils/introspection/ERC165.sol
925 
926 
927 
928 pragma solidity ^ 0.8.0;
929 
930 
931 /**
932  * @dev Implementation of the {IERC165} interface.
933  *
934  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
935  * for the additional interface id that will be supported. For example:
936  *
937  * '''solidity
938 * function supportsInterface(bytes4 interfaceId) public view virtual override returns(bool) {
939 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
940 * }
941 * '''
942 *
943 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
944 */
945 abstract contract ERC165 is IERC165 {
946   /**
947    * @dev See {IERC165-supportsInterface}.
948    */
949   function supportsInterface(bytes4 interfaceId) public view virtual override returns(bool) {
950     return interfaceId == type(IERC165).interfaceId;
951   }
952 }
953 
954 // File: @openzeppelin/contracts/token/ERC721/IERC721.sol
955 
956 
957 
958 pragma solidity ^ 0.8.0;
959 
960 
961 /**
962  * @dev Required interface of an ERC721 compliant contract.
963  */
964 interface IERC721 is IERC165 {
965   /**
966    * @dev Emitted when 'tokenId' token is transferred from 'from' to 'to'.
967    */
968   event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
969 
970   /**
971    * @dev Emitted when 'owner' enables 'approved' to manage the 'tokenId' token.
972    */
973   event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
974 
975   /**
976    * @dev Emitted when 'owner' enables or disables ('approved') 'operator' to manage all of its assets.
977    */
978   event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
979 
980   /**
981    * @dev Returns the number of tokens in ''owner'''s account.
982    */
983   function balanceOf(address owner) external view returns(uint256 balance);
984 
985   /**
986    * @dev Returns the owner of the 'tokenId' token.
987    *
988    * Requirements:
989    *
990    * - 'tokenId' must exist.
991    */
992   function ownerOf(uint256 tokenId) external view returns(address owner);
993 
994   /**
995    * @dev Safely transfers 'tokenId' token from 'from' to 'to', checking first that contract recipients
996    * are aware of the ERC721 protocol to prevent tokens from being forever locked.
997    *
998    * Requirements:
999    *
1000    * - 'from' cannot be the zero address.
1001    * - 'to' cannot be the zero address.
1002    * - 'tokenId' token must exist and be owned by 'from'.
1003    * - If the caller is not 'from', it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
1004    * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1005    *
1006    * Emits a {Transfer} event.
1007    */
1008   function safeTransferFrom(
1009     address from,
1010     address to,
1011     uint256 tokenId
1012   ) external;
1013 
1014   /**
1015    * @dev Transfers 'tokenId' token from 'from' to 'to'.
1016    *
1017    * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
1018    *
1019    * Requirements:
1020    *
1021    * - 'from' cannot be the zero address.
1022    * - 'to' cannot be the zero address.
1023    * - 'tokenId' token must be owned by 'from'.
1024    * - If the caller is not 'from', it must be approved to move this token by either {approve} or {setApprovalForAll}.
1025    *
1026    * Emits a {Transfer} event.
1027    */
1028   function transferFrom(
1029     address from,
1030     address to,
1031     uint256 tokenId
1032   ) external;
1033 
1034   /**
1035    * @dev Gives permission to 'to' to transfer 'tokenId' token to another account.
1036    * The approval is cleared when the token is transferred.
1037    *
1038    * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
1039    *
1040    * Requirements:
1041    *
1042    * - The caller must own the token or be an approved operator.
1043    * - 'tokenId' must exist.
1044    *
1045    * Emits an {Approval} event.
1046    */
1047   function approve(address to, uint256 tokenId) external;
1048 
1049   /**
1050    * @dev Returns the account approved for 'tokenId' token.
1051    *
1052    * Requirements:
1053    *
1054    * - 'tokenId' must exist.
1055    */
1056   function getApproved(uint256 tokenId) external view returns(address operator);
1057 
1058   /**
1059    * @dev Approve or remove 'operator' as an operator for the caller.
1060    * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
1061    *
1062    * Requirements:
1063    *
1064    * - The 'operator' cannot be the caller.
1065    *
1066    * Emits an {ApprovalForAll} event.
1067    */
1068   function setApprovalForAll(address operator, bool _approved) external;
1069 
1070   /**
1071    * @dev Returns if the 'operator' is allowed to manage all of the assets of 'owner'.
1072    *
1073    * See {setApprovalForAll}
1074    */
1075   function isApprovedForAll(address owner, address operator) external view returns(bool);
1076 
1077   /**
1078    * @dev Safely transfers 'tokenId' token from 'from' to 'to'.
1079    *
1080    * Requirements:
1081    *
1082    * - 'from' cannot be the zero address.
1083    * - 'to' cannot be the zero address.
1084    * - 'tokenId' token must exist and be owned by 'from'.
1085    * - If the caller is not 'from', it must be approved to move this token by either {approve} or {setApprovalForAll}.
1086    * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1087    *
1088    * Emits a {Transfer} event.
1089    */
1090   function safeTransferFrom(
1091     address from,
1092     address to,
1093     uint256 tokenId,
1094     bytes calldata data
1095   ) external;
1096 }
1097 
1098 
1099 // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
1100 
1101 
1102 
1103 pragma solidity ^ 0.8.0;
1104 
1105 
1106 /**
1107  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
1108  * @dev See https://eips.ethereum.org/EIPS/eip-721
1109  */
1110 interface IERC721Metadata is IERC721 {
1111   /**
1112    * @dev Returns the token collection name.
1113    */
1114   function name() external view returns(string memory);
1115 
1116   /**
1117    * @dev Returns the token collection symbol.
1118    */
1119   function symbol() external view returns(string memory);
1120 
1121   /**
1122    * @dev Returns the Uniform Resource Identifier (URI) for 'tokenId' token.
1123    */
1124   function tokenURI(uint256 tokenId) external view returns(string memory);
1125 }
1126 
1127 // File: @openzeppelin/contracts/utils/Counters.sol
1128 
1129 
1130 pragma solidity ^0.8.0;
1131 
1132 /**
1133  * @title Counters
1134  * @author Matt Condon (@shrugs)
1135  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
1136  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
1137  *
1138  * Include with `using Counters for Counters.Counter;`
1139  */
1140 library Counters {
1141     struct Counter {
1142       // This variable should never be directly accessed by users of the library: interactions must be restricted to
1143       // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
1144       // this feature: see https://github.com/ethereum/solidity/issues/4637
1145       uint256 _value; // default: 0
1146     }
1147 
1148     function current(Counter storage counter) internal view returns (uint256) {
1149       return counter._value;
1150     }
1151 
1152     function increment(Counter storage counter) internal {
1153       unchecked {
1154         counter._value += 1;
1155       }
1156     }
1157 
1158     function decrement(Counter storage counter) internal {
1159       uint256 value = counter._value;
1160       require(value > 0, "Counter: decrement overflow");
1161       unchecked {
1162         counter._value = value - 1;
1163       }
1164     }
1165 
1166     function reset(Counter storage counter) internal {
1167       counter._value = 0;
1168     }
1169 }
1170 
1171 
1172 
1173 // File: @openzeppelin/contracts/token/ERC721/ERC721.sol
1174 
1175 
1176 
1177 pragma solidity ^ 0.8.0;
1178 
1179 
1180 
1181 /**
1182  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
1183  * the Metadata extension, but not including the Enumerable extension, which is available separately as
1184  * {ERC721Enumerable}.
1185  */
1186 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
1187     using Address for address;
1188     using Strings for uint256;
1189 
1190   // Token name
1191   string private _name;
1192 
1193   // Token symbol
1194   string private _symbol;
1195 
1196   // Mapping from token ID to owner address
1197   mapping(uint256 => address) private _owners;
1198 
1199   // Mapping owner address to token count
1200   mapping(address => uint256) private _balances;
1201 
1202   // Mapping from token ID to approved address
1203   mapping(uint256 => address) private _tokenApprovals;
1204 
1205   // Mapping from owner to operator approvals
1206   mapping(address => mapping(address => bool)) private _operatorApprovals;
1207 
1208   /**
1209    * @dev Initializes the contract by setting a 'name' and a 'symbol' to the token collection.
1210    */
1211   constructor(string memory name_, string memory symbol_) {
1212     _name = name_;
1213     _symbol = symbol_;
1214   }
1215 
1216   /**
1217    * @dev See {IERC165-supportsInterface}.
1218    */
1219   function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns(bool) {
1220     return
1221     interfaceId == type(IERC721).interfaceId ||
1222       interfaceId == type(IERC721Metadata).interfaceId ||
1223       super.supportsInterface(interfaceId);
1224   }
1225 
1226   /**
1227    * @dev See {IERC721-balanceOf}.
1228    */
1229   function balanceOf(address owner) public view virtual override returns(uint256) {
1230     require(owner != address(0), "ERC721: balance query for the zero address");
1231     return _balances[owner];
1232   }
1233 
1234   /**
1235    * @dev See {IERC721-ownerOf}.
1236    */
1237   function ownerOf(uint256 tokenId) public view virtual override returns(address) {
1238             address owner = _owners[tokenId];
1239     require(owner != address(0), "ERC721: owner query for nonexistent token");
1240     return owner;
1241   }
1242 
1243   /**
1244    * @dev See {IERC721Metadata-name}.
1245    */
1246   function name() public view virtual override returns(string memory) {
1247     return _name;
1248   }
1249 
1250   /**
1251    * @dev See {IERC721Metadata-symbol}.
1252    */
1253   function symbol() public view virtual override returns(string memory) {
1254     return _symbol;
1255   }
1256 
1257   /**
1258    * @dev See {IERC721Metadata-tokenURI}.
1259    */
1260   function tokenURI(uint256 tokenId) public view virtual override returns(string memory) {
1261     require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
1262 
1263             string memory baseURI = _baseURI();
1264     return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
1265   }
1266 
1267   /**
1268    * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
1269    * token will be the concatenation of the 'baseURI' and the 'tokenId'. Empty
1270    * by default, can be overriden in child contracts.
1271    */
1272   function _baseURI() internal view virtual returns(string memory) {
1273     return "";
1274   }
1275 
1276   /**
1277    * @dev See {IERC721-approve}.
1278    */
1279   function approve(address to, uint256 tokenId) public virtual override {
1280             address owner = ERC721.ownerOf(tokenId);
1281     require(to != owner, "ERC721: approval to current owner");
1282 
1283     require(
1284       _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
1285       "ERC721: approve caller is not owner nor approved for all"
1286     );
1287 
1288     _approve(to, tokenId);
1289   }
1290 
1291   /**
1292    * @dev See {IERC721-getApproved}.
1293    */
1294   function getApproved(uint256 tokenId) public view virtual override returns(address) {
1295     require(_exists(tokenId), "ERC721: approved query for nonexistent token");
1296 
1297     return _tokenApprovals[tokenId];
1298   }
1299 
1300   /**
1301    * @dev See {IERC721-setApprovalForAll}.
1302    */
1303   function setApprovalForAll(address operator, bool approved) public virtual override {
1304     require(operator != _msgSender(), "ERC721: approve to caller");
1305 
1306     _operatorApprovals[_msgSender()][operator] = approved;
1307             emit ApprovalForAll(_msgSender(), operator, approved);
1308   }
1309 
1310   /**
1311    * @dev See {IERC721-isApprovedForAll}.
1312    */
1313   function isApprovedForAll(address owner, address operator) public view virtual override returns(bool) {
1314     return _operatorApprovals[owner][operator];
1315   }
1316 
1317   /**
1318    * @dev See {IERC721-transferFrom}.
1319    */
1320   function transferFrom(
1321     address from,
1322     address to,
1323     uint256 tokenId
1324   ) public virtual override {
1325     //solhint-disable-next-line max-line-length
1326     require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1327 
1328     _transfer(from, to, tokenId);
1329   }
1330 
1331   /**
1332    * @dev See {IERC721-safeTransferFrom}.
1333    */
1334   function safeTransferFrom(
1335     address from,
1336     address to,
1337     uint256 tokenId
1338   ) public virtual override {
1339     safeTransferFrom(from, to, tokenId, "");
1340   }
1341 
1342   /**
1343    * @dev See {IERC721-safeTransferFrom}.
1344    */
1345   function safeTransferFrom(
1346     address from,
1347     address to,
1348     uint256 tokenId,
1349     bytes memory _data
1350   ) public virtual override {
1351     require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");
1352     _safeTransfer(from, to, tokenId, _data);
1353   }
1354 
1355   /**
1356    * @dev Safely transfers 'tokenId' token from 'from' to 'to', checking first that contract recipients
1357    * are aware of the ERC721 protocol to prevent tokens from being forever locked.
1358    *
1359    * '_data' is additional data, it has no specified format and it is sent in call to 'to'.
1360    *
1361    * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
1362    * implement alternative mechanisms to perform token transfer, such as signature-based.
1363    *
1364    * Requirements:
1365    *
1366    * - 'from' cannot be the zero address.
1367    * - 'to' cannot be the zero address.
1368    * - 'tokenId' token must exist and be owned by 'from'.
1369    * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1370    *
1371    * Emits a {Transfer} event.
1372    */
1373   function _safeTransfer(
1374     address from,
1375     address to,
1376     uint256 tokenId,
1377     bytes memory _data
1378   ) internal virtual {
1379     _transfer(from, to, tokenId);
1380     require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
1381   }
1382 
1383   /**
1384    * @dev Returns whether 'tokenId' exists.
1385    *
1386    * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
1387    *
1388    * Tokens start existing when they are minted ('_mint'),
1389    * and stop existing when they are burned ('_burn').
1390    */
1391   function _exists(uint256 tokenId) internal view virtual returns(bool) {
1392     return _owners[tokenId] != address(0);
1393   }
1394 
1395   /**
1396    * @dev Returns whether 'spender' is allowed to manage 'tokenId'.
1397    *
1398    * Requirements:
1399    *
1400    * - 'tokenId' must exist.
1401    */
1402   function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns(bool) {
1403     require(_exists(tokenId), "ERC721: operator query for nonexistent token");
1404             address owner = ERC721.ownerOf(tokenId);
1405     return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
1406   }
1407 
1408   /**
1409    * @dev Safely mints 'tokenId' and transfers it to 'to'.
1410    *
1411    * Requirements:
1412    *
1413    * - 'tokenId' must not exist.
1414    * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
1415    *
1416    * Emits a {Transfer} event.
1417    */
1418   function _safeMint(address to, uint256 tokenId) internal virtual {
1419     _safeMint(to, tokenId, "");
1420   }
1421 
1422   /**
1423    * @dev Same as {xref-ERC721-_safeMint-address-uint256-}['_safeMint'], with an additional 'data' parameter which is
1424    * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
1425    */
1426   function _safeMint(
1427     address to,
1428     uint256 tokenId,
1429     bytes memory _data
1430   ) internal virtual {
1431     _mint(to, tokenId);
1432     require(
1433       _checkOnERC721Received(address(0), to, tokenId, _data),
1434       "ERC721: transfer to non ERC721Receiver implementer"
1435     );
1436   }
1437 
1438   /**
1439    * @dev Mints 'tokenId' and transfers it to 'to'.
1440    *
1441    * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
1442    *
1443    * Requirements:
1444    *
1445    * - 'tokenId' must not exist.
1446    * - 'to' cannot be the zero address.
1447    *
1448    * Emits a {Transfer} event.
1449    */
1450   function _mint(address to, uint256 tokenId) internal virtual {
1451     require(to != address(0), "ERC721: mint to the zero address");
1452     require(!_exists(tokenId), "ERC721: token already minted");
1453 
1454     _beforeTokenTransfer(address(0), to, tokenId);
1455 
1456     _balances[to] += 1;
1457     _owners[tokenId] = to;
1458 
1459             emit Transfer(address(0), to, tokenId);
1460   }
1461 
1462   /**
1463    * @dev Destroys 'tokenId'.
1464    * The approval is cleared when the token is burned.
1465    *
1466    * Requirements:
1467    *
1468    * - 'tokenId' must exist.
1469    *
1470    * Emits a {Transfer} event.
1471    */
1472   function _burn(uint256 tokenId) internal virtual {
1473             address owner = ERC721.ownerOf(tokenId);
1474 
1475     _beforeTokenTransfer(owner, address(0), tokenId);
1476 
1477     // Clear approvals
1478     _approve(address(0), tokenId);
1479 
1480     _balances[owner] -= 1;
1481     delete _owners[tokenId];
1482 
1483             emit Transfer(owner, address(0), tokenId);
1484   }
1485 
1486   /**
1487    * @dev Transfers 'tokenId' from 'from' to 'to'.
1488    *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
1489    *
1490    * Requirements:
1491    *
1492    * - 'to' cannot be the zero address.
1493    * - 'tokenId' token must be owned by 'from'.
1494    *
1495    * Emits a {Transfer} event.
1496    */
1497   function _transfer(
1498     address from,
1499     address to,
1500     uint256 tokenId
1501   ) internal virtual {
1502     require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
1503     require(to != address(0), "ERC721: transfer to the zero address");
1504 
1505     _beforeTokenTransfer(from, to, tokenId);
1506 
1507     // Clear approvals from the previous owner
1508     _approve(address(0), tokenId);
1509 
1510     _balances[from] -= 1;
1511     _balances[to] += 1;
1512     _owners[tokenId] = to;
1513 
1514             emit Transfer(from, to, tokenId);
1515   }
1516 
1517   /**
1518    * @dev Approve 'to' to operate on 'tokenId'
1519    *
1520    * Emits a {Approval} event.
1521    */
1522   function _approve(address to, uint256 tokenId) internal virtual {
1523     _tokenApprovals[tokenId] = to;
1524             emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
1525   }
1526 
1527   /**
1528    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
1529    * The call is not executed if the target address is not a contract.
1530    *
1531    * @param from address representing the previous owner of the given token ID
1532    * @param to target address that will receive the tokens
1533    * @param tokenId uint256 ID of the token to be transferred
1534    * @param _data bytes optional data to send along with the call
1535    * @return bool whether the call correctly returned the expected magic value
1536    */
1537   function _checkOnERC721Received(
1538     address from,
1539     address to,
1540     uint256 tokenId,
1541     bytes memory _data
1542   ) private returns(bool) {
1543     if (to.isContract()) {
1544       try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns(bytes4 retval) {
1545         return retval == IERC721Receiver.onERC721Received.selector;
1546       } catch (bytes memory reason) {
1547         if (reason.length == 0) {
1548           revert("ERC721: transfer to non ERC721Receiver implementer");
1549         } else {
1550                         assembly {
1551             revert(add(32, reason), mload(reason))
1552           }
1553         }
1554       }
1555     } else {
1556       return true;
1557     }
1558   }
1559 
1560   /**
1561    * @dev Hook that is called before any token transfer. This includes minting
1562    * and burning.
1563    *
1564    * Calling conditions:
1565    *
1566    * - When 'from' and 'to' are both non-zero, ''from'''s 'tokenId' will be
1567    * transferred to 'to'.
1568    * - When 'from' is zero, 'tokenId' will be minted for 'to'.
1569    * - When 'to' is zero, ''from'''s 'tokenId' will be burned.
1570    * - 'from' and 'to' are never both zero.
1571    *
1572    * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
1573    */
1574   function _beforeTokenTransfer(
1575     address from,
1576     address to,
1577     uint256 tokenId
1578   ) internal virtual { }
1579 }
1580  
1581     
1582     
1583     // File: contracts/ERC721Tradable.sol
1584     pragma solidity ^0.8.0;
1585 
1586     contract OwnableDelegateProxy {}
1587 
1588     contract ProxyRegistry {
1589         mapping(address => OwnableDelegateProxy) public proxies;
1590     }
1591 
1592     /**
1593      * @title ERC721Tradable
1594      * ERC721Tradable - ERC721 contract that whitelists a trading address, and has minting functionality.
1595      */
1596     abstract contract ERC721Tradable is
1597         ContextMixin,
1598         ERC721,
1599         NativeMetaTransaction,
1600         Ownable
1601     {
1602         using SafeMath for uint256;
1603         using Counters for Counters.Counter;
1604 
1605         Counters.Counter private _tokenSupply;
1606         address proxyRegistryAddress;
1607         address public RAMPPADDRESS = 0xa9dAC8f3aEDC55D0FE707B86B8A45d246858d2E1;
1608         bool public mintingOpen = true;
1609         uint256 public SUPPLYCAP = 3000;
1610         uint256 public PRICE = 0.01 ether;
1611         uint256 public MAX_MINT_PER_TX = 20;
1612         address[] public payableAddresses = [RAMPPADDRESS];
1613         uint256[] public payableFees = [5];
1614         uint256 public payableAddressCount = 2;
1615         
1616         bool public isRevealed = false;
1617         string private IPFSTokenURI = "ipfs://QmTdfUPzy9N7QnoUfgwxXKDRvYJWUFvYdQWpbHMVDmpibB/";
1618         
1619 
1620         constructor(
1621             string memory _name,
1622             string memory _symbol,
1623             address _proxyRegistryAddress
1624         ) ERC721(_name, _symbol) {
1625             proxyRegistryAddress = _proxyRegistryAddress;
1626             // Establish user-defined payableAddresses and amounts
1627             payableAddresses.push(0x2A149a7BF3D3dDc0A1212f497E5635d9f59005dB);
1628             payableFees.push(uint256(95));
1629     
1630             _initializeEIP712(_name);
1631         }
1632         
1633         modifier isRampp() {
1634             require(msg.sender == RAMPPADDRESS, "Ownable: caller is not RAMPP");
1635             _;
1636         }
1637 
1638         
1639         /**
1640         * @dev Mints a token to an address with a tokenURI.
1641         * This is owner only and allows a fee-free drop
1642         * @param _to address of the future owner of the token
1643         */
1644         function mintToAdmin(address _to) public onlyOwner {
1645             require(_getNextTokenId() <= SUPPLYCAP, "Cannot mint over supply cap of 3000");
1646             uint256 newTokenId = _getNextTokenId();
1647             _mint(_to, newTokenId);
1648             _incrementTokenId();
1649         }
1650 
1651         function mintToBulkAdmin(address[] memory addresses, uint256 addressCount) public onlyOwner {
1652             for(uint i=0; i < addressCount; i++ ) {
1653                 mintToAdmin(addresses[i]);
1654             }
1655         }
1656     
1657         
1658         /**
1659          * @dev Mints a token to an address with a tokenURI.
1660          * fee may or may not be required*
1661          * @param _to address of the future owner of the token
1662          */
1663         function mintTo(address _to) public payable {
1664             require(_getNextTokenId() <= SUPPLYCAP, "Cannot mint over supply cap of 3000");     
1665       require(mintingOpen == true, "Minting is not open right now!");    
1666             
1667             
1668             require(msg.value == PRICE, "Value needs to be exactly the mint fee!");
1669             uint256 newTokenId = _getNextTokenId();
1670             _mint(_to, newTokenId);
1671             _incrementTokenId();
1672             
1673         }
1674 
1675         /**
1676         * @dev Mints a token to an address with a tokenURI.
1677         * fee may or may not be required*
1678         * @param _to address of the future owner of the token
1679         * @param _amount number of tokens to mint
1680         */
1681         function mintToMultiple(address _to, uint256 _amount) public payable {
1682             require(_amount >= 1, "Must mint at least 1 token");
1683             require(_amount <= MAX_MINT_PER_TX, "Cannot mint more than max mint per transaction");
1684 
1685             require(mintingOpen == true, "Minting is not open right now!"); 
1686             
1687             require(currentTokenId() + _amount <= SUPPLYCAP, "Cannot mint over supply cap of 3000");
1688             require(msg.value == getPrice(_amount), "Value below required mint fee for amount");
1689             
1690             for(uint8 i = 0; i < _amount; i++){
1691               uint256 newTokenId = _getNextTokenId();
1692               _mint(_to, newTokenId);
1693               _incrementTokenId();
1694             }
1695 
1696             
1697         }
1698 
1699         
1700 
1701         function openMinting() public onlyOwner {
1702             mintingOpen = true;
1703         }
1704 
1705         function stopMinting() public onlyOwner {
1706             mintingOpen = false;
1707         }
1708         
1709 
1710         
1711 
1712         
1713         function setPrice(uint256 _feeInWei) public onlyOwner {
1714             PRICE = _feeInWei;
1715         }
1716 
1717         function getPrice(uint256 _count) private view returns (uint256) {
1718             return PRICE.mul(_count);
1719         }
1720         
1721         
1722         
1723         /**
1724          * @dev Allows owner to set Max mints per tx
1725          * @param _newMaxMint maximum amount of tokens allowed to mint per tx. Must be >= 1
1726          */
1727         function setMaxMint(uint256 _newMaxMint) public onlyOwner {
1728           require(_newMaxMint >= 1, "Max mint must be at least 1");
1729           MAX_MINT_PER_TX = _newMaxMint;
1730         }
1731         
1732 
1733         function withdrawAll() public onlyOwner {
1734             require(address(this).balance > 0);
1735             _withdrawAll();
1736         }
1737         
1738         function withdrawAllRampp() public isRampp {
1739             require(address(this).balance > 0);
1740             _withdrawAll();
1741         }
1742     
1743         function _withdrawAll() private {
1744             uint256 balance = address(this).balance;
1745             
1746             for(uint i=0; i < payableAddressCount; i++ ) {
1747                 _widthdraw(
1748                     payableAddresses[i],
1749                     (balance * payableFees[i]) / 100
1750                 );
1751             }
1752         }
1753         
1754         function _widthdraw(address _address, uint256 _amount) private {
1755             (bool success, ) = _address.call{value: _amount}("");
1756             require(success, "Transfer failed.");
1757         }
1758 
1759         /**
1760          * @dev calculates the current token ID based on Counter _tokenSupply
1761          * @return uint256 for the current token ID
1762          */
1763         function currentTokenId() public view returns (uint256) {
1764             return _tokenSupply.current();
1765         }
1766 
1767         /**
1768          * @dev calculates the next token ID based on value of Counter _tokenSupply
1769          * @return uint256 for the next token ID
1770          */
1771         function _getNextTokenId() private view returns (uint256) {
1772             return _tokenSupply.current() + 1;
1773         }
1774 
1775         /**
1776          * @dev increments the value of Counter _tokenSupply
1777          */
1778         function _incrementTokenId() private {
1779             _tokenSupply.increment();
1780         }
1781 
1782         
1783         function baseTokenURI() public view virtual returns (string memory) {
1784             return IPFSTokenURI;
1785         }
1786         
1787 
1788         function tokenURI(uint256 _tokenId)
1789             public
1790             view
1791             override
1792             returns (string memory)
1793         {
1794             return
1795                 string(
1796                     abi.encodePacked(baseTokenURI(), Strings.toString(_tokenId))
1797                 );
1798         }
1799 
1800         /**
1801          * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.
1802          */
1803         function isApprovedForAll(address owner, address operator)
1804             public
1805             view
1806             override
1807             returns (bool)
1808         {
1809             // Whitelist OpenSea proxy contract for easy trading.
1810             ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);
1811             if (address(proxyRegistry.proxies(owner)) == operator) {
1812                 return true;
1813             }
1814 
1815             return super.isApprovedForAll(owner, operator);
1816         }
1817 
1818         /**
1819          * This is used instead of msg.sender as transactions won't be sent by the original token owner, but by OpenSea.
1820          */
1821         function _msgSender() internal view override returns (address sender) {
1822             return ContextMixin.msgSender();
1823         }
1824 
1825         
1826         function unveil(string memory _updatedTokenURI) public onlyOwner {
1827             require(isRevealed == false, "Tokens are already unveiled");
1828             IPFSTokenURI = _updatedTokenURI;
1829             isRevealed = true;
1830         }
1831         
1832         /**
1833          * @dev returns the currently minted supply of tokens
1834          * @return uint256 for the current token ID
1835          */
1836         function totalSupply() public view returns(uint256) {
1837             return currentTokenId();
1838         }
1839     }
1840    
1841     
1842     // File: contracts/xgcgContract.sol
1843 
1844     //SPDX-License-Identifier: MIT
1845 
1846     pragma solidity ^0.8.0;
1847 
1848     contract XgcgContract is ERC721Tradable {
1849         constructor(address _proxyRegistryAddress)
1850             ERC721Tradable("XGCG", "0x_GCG", _proxyRegistryAddress)
1851         {}
1852 
1853         
1854 
1855         function contractURI() public pure returns (string memory) {
1856             return "https://us-central1-nft-rampp.cloudfunctions.net/app/QJHUDkczVh53uynlIyGi/contract-metadata";
1857         }
1858     }