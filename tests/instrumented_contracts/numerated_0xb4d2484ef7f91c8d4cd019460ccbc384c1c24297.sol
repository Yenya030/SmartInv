1 {"AccessControl.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\ncontract AccessControl {\n\n    // Managed by WISE\n    address public multisig;\n\n    // Mapping to store authorised workers\n    mapping(address =\u003e mapping(address =\u003e bool)) public workers;\n\n    event MultisigUpdated(\n        address newMultisig\n    );\n\n    event WorkerAdded(\n        address wiseGroup,\n        address newWorker\n    );\n\n    event WorkerRemoved(\n        address wiseGroup,\n        address existingWorker\n    );\n\n    /**\n     * @dev Set to address that deploys Factory\n     */\n    constructor() {\n        multisig = tx.origin;\n    }\n\n    /**\n     * @dev Revert if msg.sender if not multisig\n     */\n    modifier onlyMultisig() {\n        require(\n            msg.sender == multisig,\n            \"AccessControl: NOT_MULTISIG\"\n        );\n        _;\n    }\n\n    /**\n     * @dev requires that sender is authorised\n     */\n    modifier onlyWiseWorker(\n        address _group\n    ) {\n        require(\n            workers[_group][msg.sender] == true,\n            \"AccessControl: NOT_WORKER\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Transfer Multisig permission\n     * Call internal function that does the work\n     */\n    function updateMultisig(\n        address _newMultisig\n    )\n        external\n        onlyMultisig\n    {\n        require(\n            _newMultisig \u003e address(0),\n            \"AccessControl: EMPTY_ADDRESS\"\n        );\n\n        multisig = _newMultisig;\n\n        emit MultisigUpdated(\n            _newMultisig\n        );\n    }\n\n    /**\n     * @dev Add a worker address to the system.\n     * Set the bool for the worker to true.\n     */\n    function addWorker(\n        address _group,\n        address _worker\n    )\n        external\n        onlyMultisig\n    {\n        _addWorker(\n            _group,\n            _worker\n        );\n    }\n\n    function _addWorker(\n        address _group,\n        address _worker\n    )\n        internal\n    {\n        workers[_group][_worker] = true;\n\n        emit WorkerAdded(\n            _group,\n            _worker\n        );\n    }\n\n    /**\n     * @dev Remove a worker address from the system.\n     * Set the bool for the worker to false.\n     */\n    function removeWorker(\n        address _group,\n        address _worker\n    )\n        external\n        onlyMultisig\n    {\n        workers[_group][_worker] = false;\n\n        emit WorkerRemoved(\n            _group,\n            _worker\n        );\n    }\n}\n"},"IChainLink.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\ninterface IChainLink {\n\n    function decimals()\n        external\n        view\n        returns (uint8);\n\n    function latestAnswer()\n        external\n        view\n        returns (uint256);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answerdInRound\n        );\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function phaseId()\n        external\n        view\n        returns(\n            uint16 phaseId\n        );\n\n    function aggregator()\n        external\n        view\n        returns (address);\n}\n"},"ILiquidPool.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\ninterface ILiquidPool {\n\n    function depositFunds(\n        uint256 _amount,\n        address _depositor\n    )\n        external\n        returns (uint256);\n\n    function withdrawFunds(\n        uint256 _shares,\n        address _user\n    )\n        external\n        returns (uint256);\n\n    function borrowFunds(\n        address _borrowAddress,\n        uint256 _borrowAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external;\n\n    function borrowMoreFunds(\n        address _borrowAddress,\n        uint256 _borrowAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external;\n\n    function paybackFunds(\n        uint256 _payAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        returns (uint256);\n\n    function liquidateNFT(\n        address _liquidator,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        returns (uint256);\n\n    function getLoanOwner(\n        address _nft,\n        uint256 _tokenID\n    )\n        external\n        view\n        returns (address);\n\n    function withdrawFee()\n        external;\n\n    function poolToken()\n        external\n        view\n        returns (address);\n\n    function calculateWithdrawAmount(\n        uint256 _shares\n    )\n        external\n        view\n        returns (uint256);\n\n    function lockFeeDestination()\n        external;\n\n    function changeFeeDestinationAddress(\n        address _newFeeDestinationAddress\n    )\n        external;\n\n    function expandPool(\n        address _nftAddress\n    )\n        external;\n\n    function addCollection(\n        address _nftAddress\n    )\n        external;\n}\n"},"LiquidRouter.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\n// Interfaces\nimport \"./ILiquidPool.sol\";\nimport \"./IChainLink.sol\";\n\n// Inheritance Contacts\nimport \"./RouterEvents.sol\";\nimport \"./AccessControl.sol\";\nimport \"./LiquidTransfer.sol\";\n\n/**\n * @author Ren√© Hochmuth\n * @author Vitally Marinchenko\n * @author Christoph Krpoun\n */\n\ncontract LiquidRouter is LiquidTransfer, AccessControl, RouterEvents {\n\n    // Factory contract that clones liquid pools\n    address public factoryAddress;\n\n    // Oracle address for ETH\n    address public immutable chainLinkETH;\n\n    // Minimum time for a new merkleRoot to be updated\n    uint256 public constant UPDATE_DURATION = 72 hours;\n\n    // Number of last rounds which are checked for heartbeatlength\n    uint80 public constant MAX_ROUND_COUNT = 50;\n\n    // Official pools that are added to the router\n    mapping(address =\u003e bool) public registeredPools;\n\n    // NFT address =\u003e merkle root\n    mapping(address =\u003e bytes32) public merkleRoot;\n\n    // NFT address =\u003e merkle root IPFS address\n    mapping(address =\u003e string) public merkleIPFS;\n\n    // Mapping for ability to expand pools\n    mapping(address =\u003e bool) public expansionRevoked;\n\n    // Stores the time between chainLink heartbeats\n    mapping(address =\u003e uint256) public chainLinkHeartBeat;\n\n    // Mapping for updates of merkle roots\n    mapping(address =\u003e UpdateRoot) public pendingRoots;\n\n    // Mapping for pool expansion with collections\n    mapping(address =\u003e ExpandPool) public pendingPools;\n\n    // Data object for merkleRoot updates\n    struct UpdateRoot {\n        uint256 updateTime;\n        bytes32 merkleRoot;\n        string ipfsAddress;\n    }\n\n    // Data object for pool expansion\n    struct ExpandPool {\n        uint256 updateTime;\n        address nftAddress;\n    }\n\n    // Marker to avoid unknown pools\n    modifier onlyKnownPools(\n        address _pool\n    ) {\n        require(\n            registeredPools[_pool] == true,\n            \"LiquidRouter: UNKNOWN_POOL\"\n        );\n        _;\n    }\n\n    // Avoids expansion if denied\n    modifier onlyExpandable(\n        address _pool\n    ) {\n        require(\n            expansionRevoked[_pool] == false,\n            \"LiquidRouter: NOT_EXPANDABLE\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Set the address of the factory, and chainLinkETH oracleAddress\n     */\n    constructor(\n        address _factoryAddress,\n        address _chainLinkETH\n    ) {\n\n        require(\n            _chainLinkETH \u003e address(0),\n            \"LiquidRouter: EMPTY_ADDRESS\"\n        );\n\n        factoryAddress = _factoryAddress;\n        chainLinkETH = _chainLinkETH;\n    }\n\n    /**\n     * @dev Calls liquidateNFT on a specific pool. More info see PoolHelper\n     * liquidateNFT\n     */\n    function liquidateNFT(\n        address _pool,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n    {\n        uint256 auctionPrice = ILiquidPool(_pool).liquidateNFT(\n            msg.sender,\n            _nftAddress,\n            _nftTokenId,\n            _merkleIndex,\n            _merklePrice,\n            _merkleProof\n        );\n\n        _safeTransferFrom(\n            ILiquidPool(_pool).poolToken(),\n            msg.sender,\n            _pool,\n            auctionPrice\n        );\n\n        emit Liquidated(\n            _nftAddress,\n            _nftTokenId,\n            auctionPrice,\n            msg.sender,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Register an address as officially known pool\n     */\n    function addLiquidPool(\n        address _pool\n    )\n        external\n    {\n        require(\n            msg.sender == factoryAddress,\n            \"LiquidRouter: NOT_FACTORY\"\n        );\n\n        registeredPools[_pool] = true;\n\n        _addWorker(\n            _pool,\n            multisig\n        );\n\n        emit LiquidPoolRegistered(\n            _pool,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Register initial root for upcoming new collection\n     */\n    function addMerkleRoot(\n        address _nftAddress,\n        bytes32 _merkleRoot,\n        string memory _ipfsAddress\n    )\n        external\n        onlyMultisig\n    {\n        require(\n            merkleRoot[_nftAddress] == 0,\n            \"LiquidRouter: OVERWRITE_DENIED\"\n        );\n\n        _addWorker(\n            _nftAddress,\n            msg.sender\n        );\n\n        merkleRoot[_nftAddress] = _merkleRoot;\n        merkleIPFS[_nftAddress] = _ipfsAddress;\n    }\n\n    /**\n     * @dev Initialise merkle root update for existing collection\n     */\n    function startUpdateRoot(\n        address _nftAddress,\n        bytes32 _merkleRoot,\n        string memory _ipfsAddress\n    )\n        external\n        onlyWiseWorker(_nftAddress)\n    {\n        require(\n            _merkleRoot \u003e 0,\n            \"LiquidRouter: INVALID_ROOT\"\n        );\n\n        uint256 unlockTime = block.timestamp\n            + UPDATE_DURATION;\n\n        pendingRoots[_nftAddress] = UpdateRoot({\n            updateTime: unlockTime,\n            merkleRoot: _merkleRoot,\n            ipfsAddress: _ipfsAddress\n        });\n\n        emit RootAnnounced(\n            msg.sender,\n            unlockTime,\n            _nftAddress,\n            _merkleRoot,\n            _ipfsAddress\n        );\n    }\n\n    /**\n     * @dev Finish merkle root update for existing collection after time lock\n     */\n    function finishUpdateRoot(\n        address _nftAddress\n    )\n        external\n    {\n        UpdateRoot memory update = pendingRoots[_nftAddress];\n\n        require(\n            update.updateTime \u003e 0,\n            \"LiquidRouter: INVALID_TIME\"\n        );\n\n        require(\n            block.timestamp \u003e update.updateTime,\n            \"LiquidRouter: TOO_EARLY\"\n        );\n\n        merkleRoot[_nftAddress] = update.merkleRoot;\n        merkleIPFS[_nftAddress] = update.ipfsAddress;\n\n        delete pendingRoots[_nftAddress];\n\n        emit RootUpdated(\n            msg.sender,\n            block.timestamp,\n            _nftAddress,\n            update.merkleRoot,\n            update.ipfsAddress\n        );\n    }\n\n    /**\n     * @dev Initialise expansion of the pool if allowed and root was announced\n     */\n    function startExpandPool(\n        address _pool,\n        address _nftAddress\n    )\n        external\n        onlyExpandable(_pool)\n        onlyWiseWorker(_pool)\n    {\n        require(\n            merkleRoot[_nftAddress] \u003e 0,\n            \"LiquidRouter: ROOT_NOT_SET\"\n        );\n\n        uint256 updateTime = block.timestamp\n            + UPDATE_DURATION;\n\n        pendingPools[_pool] = ExpandPool({\n            updateTime: updateTime,\n            nftAddress: _nftAddress\n        });\n\n        emit UpdateAnnounced(\n            msg.sender,\n            updateTime,\n            _pool,\n            _nftAddress\n        );\n    }\n\n    /**\n     * @dev Finish introducing new collection to the pool\n     */\n    function finishExpandPool(\n        address _pool\n    )\n        external\n        onlyExpandable(_pool)\n    {\n        ExpandPool memory update = pendingPools[_pool];\n\n        require(\n            update.updateTime \u003e 0,\n            \"LiquidRouter: INVALID_TIME\"\n        );\n\n        require(\n            block.timestamp \u003e update.updateTime,\n            \"LiquidRouter: TOO_EARLY\"\n        );\n\n        ILiquidPool(_pool).addCollection(\n            update.nftAddress\n        );\n\n        delete pendingPools[_pool];\n\n        emit PoolUpdated(\n            msg.sender,\n            block.timestamp,\n            _pool,\n            update.nftAddress\n        );\n    }\n\n    /**\n     * @dev remove expandability from the pool\n     */\n    function revokeExpansion(\n        address _pool\n    )\n        external\n        onlyMultisig\n    {\n        expansionRevoked[_pool] = true;\n\n        emit ExpansionRevoked(\n            _pool\n        );\n    }\n\n    /**\n     * @dev Calls the depositFunds function of a specific pool.\n     * Also handle the transferring of tokens here, only have to approve router\n     * Check that pool is registered\n     */\n    function depositFunds(\n        uint256 _amount,\n        address _pool\n    )\n        public\n        onlyKnownPools(_pool)\n    {\n        uint256 shares = ILiquidPool(_pool).depositFunds(\n            _amount,\n            msg.sender\n        );\n\n        _safeTransferFrom(\n            ILiquidPool(_pool).poolToken(),\n            msg.sender,\n            _pool,\n            _amount\n        );\n\n        emit FundsDeposited(\n            _pool,\n            msg.sender,\n            _amount,\n            shares,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Calls the withdrawFunds function of a specific pool.\n     * more info see LiquidPool withdrawFunds\n     */\n    function withdrawFunds(\n        uint256 _shares,\n        address _pool\n    )\n        public\n        onlyKnownPools(_pool)\n    {\n        uint256 withdrawAmount = ILiquidPool(_pool).withdrawFunds(\n            _shares,\n            msg.sender\n        );\n\n        emit FundsWithdrawn(\n            _pool,\n            msg.sender,\n            withdrawAmount,\n            _shares,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev moves funds as lender from one registered pool\n     * to another with requirement being same poolToken\n     * uses internalShares and no tokenised Shares\n     */\n    function moveFunds(\n        uint256 _shares,\n        address _poolToExit,\n        address _poolToEnter\n    )\n        external\n    {\n        require(\n            ILiquidPool(_poolToExit).poolToken() ==\n            ILiquidPool(_poolToEnter).poolToken(),\n            \"LiquidRouter: TOKENS_MISMATCH\"\n        );\n\n        uint256 amountToDeposit = ILiquidPool(\n            _poolToExit\n        ).calculateWithdrawAmount(\n            _shares\n        );\n\n        withdrawFunds(\n            _shares,\n            _poolToExit\n        );\n\n        depositFunds(\n            amountToDeposit,\n            _poolToEnter\n        );\n    }\n\n    /**\n     * @dev Calls the borrowFunds function of a specific pool.\n     * more info in LiquidPool borrowFunds\n     */\n    function borrowFunds(\n        address _pool,\n        uint256 _takeAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        onlyKnownPools(_pool)\n    {\n        _transferFromNFT(\n            msg.sender,\n            _pool,\n            _nftAddress,\n            _nftTokenId\n        );\n\n        ILiquidPool(_pool).borrowFunds(\n            msg.sender,\n            _takeAmount,\n            _nftAddress,\n            _nftTokenId,\n            _merkleIndex,\n            _merklePrice,\n            _merkleProof\n        );\n\n        emit FundsBorrowed(\n            _pool,\n            _nftAddress,\n            _nftTokenId,\n            _takeAmount,\n            msg.sender,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Calls the borrowMoreFunds function of a specific pool.\n     * more info in LiquidPool borrowMoreFunds\n     */\n    function borrowMoreFunds(\n        address _pool,\n        uint256 _takeAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        onlyKnownPools(_pool)\n    {\n        ILiquidPool(_pool).borrowMoreFunds(\n            msg.sender,\n            _takeAmount,\n            _nftAddress,\n            _nftTokenId,\n            _merkleIndex,\n            _merklePrice,\n            _merkleProof\n        );\n\n        emit MoreFundsBorrowed(\n            _pool,\n            _nftAddress,\n            msg.sender,\n            _nftTokenId,\n            _takeAmount,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Calls paybackFunds for a specific pool\n     * more info see LiquidPool paybackFunds\n     */\n    function paybackFunds(\n        address _pool,\n        uint256 _payAmount,\n        address _nftAddress,\n        uint256 _nftTokenId,\n        uint256 _merkleIndex,\n        uint256 _merklePrice,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        onlyKnownPools(_pool)\n    {\n        uint256 transferAmount = ILiquidPool(_pool).paybackFunds(\n            _payAmount,\n            _nftAddress,\n            _nftTokenId,\n            _merkleIndex,\n            _merklePrice,\n            _merkleProof\n        );\n\n        address loanOwner = ILiquidPool(_pool).getLoanOwner(\n            _nftAddress,\n            _nftTokenId\n        );\n\n        _safeTransferFrom(\n            ILiquidPool(_pool).poolToken(),\n            msg.sender,\n            _pool,\n            transferAmount\n        );\n\n        emit FundsReturned(\n            _pool,\n            _nftAddress,\n            loanOwner,\n            transferAmount,\n            _nftTokenId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Changes the address which\n     * receives fees denominated in shares bulk (internal)\n     */\n    function lockFeeDestination(\n        address[] calldata _pools\n    )\n        external\n        onlyMultisig\n    {\n        for (uint32 i = 0; i \u003c _pools.length; i++) {\n            ILiquidPool(_pools[i]).lockFeeDestination();\n        }\n    }\n\n    /**\n     * @dev Changes the address which\n     * receives fees denominated in shares bulk\n     */\n    function changeFeeDestinationAddress(\n        address[] calldata _pools,\n        address[] calldata _newFeeDestinationAddress\n    )\n        external\n        onlyMultisig\n    {\n        for (uint32 i = 0; i \u003c _pools.length; i++) {\n            ILiquidPool(_pools[i]).changeFeeDestinationAddress(\n                _newFeeDestinationAddress[i]\n            );\n\n            emit FeeDestinatoinChanged(\n                _pools[i],\n                _newFeeDestinationAddress[i]\n            );\n        }\n    }\n\n    /**\n     * @dev\n     * Allows to withdraw accumulated fees\n     * storing them in the router contract\n     */\n    function withdrawFees(\n        address[] calldata _pools,\n        uint256[] calldata _shares\n    )\n        external\n    {\n        for (uint32 i = 0; i \u003c _pools.length; i++) {\n            ILiquidPool(_pools[i]).withdrawFunds(\n                _shares[i],\n                address(this)\n            );\n        }\n    }\n\n    /**\n     * @dev\n     * Removes any tokens accumulated\n     * by the router including fees\n     */\n    function removeToken(\n        address _tokenAddress,\n        address _depositAddress\n    )\n        external\n        onlyMultisig\n    {\n        uint256 tokenBalance = _safeBalance(\n            _tokenAddress,\n            address(this)\n        );\n\n        _safeTransfer(\n            _tokenAddress,\n            _depositAddress,\n            tokenBalance\n        );\n    }\n\n    /**\n     * @dev Determines info for the heartbeat update mechanism for chainlink\n     * oracles (roundIds)\n     */\n    function getLatestAggregatorRoundId(\n        address _feed\n    )\n        public\n        view\n        returns (uint80)\n    {\n        (   uint80 roundId,\n            ,\n            ,\n            ,\n        ) = IChainLink(_feed).latestRoundData();\n\n        return uint64(roundId);\n    }\n\n    /**\n     * @dev Determines info for the heartbeat update mechanism for chainlink\n     * oracles (shifted round Ids)\n     */\n    function getRoundIdByByteShift(\n        uint16 _phaseId,\n        uint80 _aggregatorRoundId\n    )\n        public\n        pure\n        returns (uint80)\n    {\n        return uint80(uint256(_phaseId) \u003c\u003c 64 | _aggregatorRoundId);\n    }\n\n    /**\n     * @dev View function to determine the heartbeat to see if updating heartbeat\n     * is necessary or not (compare to current value).\n     * Looks at the maximal last 50 rounds and takes second highest value to\n     * avoid counting offline time of chainlink as valid heartbeat\n     */\n    function recalibratePreview(\n        address _feed\n    )\n        public\n        view\n        returns (uint256)\n    {\n        uint80 latestAggregatorRoundId = getLatestAggregatorRoundId(\n            _feed\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestAggregatorRoundId\n        );\n\n        if (iterationCount \u003c 2) {\n            revert(\"LiquidRouter: SMALL_SAMPLE\");\n        }\n\n        uint16 phaseId = IChainLink(_feed).phaseId();\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _feed,\n            phaseId,\n            latestAggregatorRoundId\n        );\n\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        for (uint80 i = 1; i \u003c iterationCount; i++) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _feed,\n                phaseId,\n                latestAggregatorRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff \u003e= currentBiggest) {\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n            } else if (currentDiff \u003e currentSecondBiggest \u0026\u0026 currentDiff \u003c currentBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations necessary during recalibrating\n     * heartbeat.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80)\n    {\n        return _latestAggregatorRoundId \u003e MAX_ROUND_COUNT\n            ? MAX_ROUND_COUNT\n            : _latestAggregatorRoundId;\n    }\n\n    /**\n     * @dev fetches timestamp of a byteshifted aggregatorRound with specific\n     * phaseID. For more info see chainlink historical price data documentation\n     */\n    function _getRoundTimestamp(\n        address _feed,\n        uint16 _phaseId,\n        uint80 _aggregatorRoundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp,\n        ) = IChainLink(_feed).getRoundData(\n            getRoundIdByByteShift(\n                _phaseId,\n                _aggregatorRoundId\n            )\n        );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Function to recalibrate the heartbeat for a specific feed\n     */\n    function recalibrate(\n        address _feed\n    )\n        external\n    {\n        chainLinkHeartBeat[_feed] = recalibratePreview(_feed);\n    }\n}\n"},"LiquidTransfer.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\ncontract LiquidTransfer {\n\n    /* @dev\n    * Checks if contract is nonstandard, does transfer according to contract implementation\n    */\n    function _transferNFT(\n        address _from,\n        address _to,\n        address _tokenAddress,\n        uint256 _tokenId\n    )\n        internal\n    {\n        bytes memory data = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256)\",\n            _from,\n            _to,\n            _tokenId\n        );\n\n        (bool success,) = address(_tokenAddress).call(\n            data\n        );\n\n        require(\n            success,\n            \"LiquidTransfer: NFT_TRANSFER_FAILED\"\n        );\n    }\n\n    /* @dev\n    * Checks if contract is nonstandard, does transferFrom according to contract implementation\n    */\n    function _transferFromNFT(\n        address _from,\n        address _to,\n        address _tokenAddress,\n        uint256 _tokenId\n    )\n        internal\n    {\n        bytes memory data = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256)\",\n            _from,\n            _to,\n            _tokenId\n        );\n\n        (bool success, bytes memory resultData) = address(_tokenAddress).call(\n            data\n        );\n\n        require(\n            success,\n            string(resultData)\n        );\n    }\n\n    /**\n     * @dev encoding for transfer\n     */\n    bytes4 constant TRANSFER = bytes4(\n        keccak256(\n            bytes(\n                \"transfer(address,uint256)\"\n            )\n        )\n    );\n\n    /**\n     * @dev encoding for transferFrom\n     */\n    bytes4 constant TRANSFER_FROM = bytes4(\n        keccak256(\n            bytes(\n                \"transferFrom(address,address,uint256)\"\n            )\n        )\n    );\n\n    /**\n     * @dev encoding for balanceOf\n     */\n    bytes4 private constant BALANCE_OF = bytes4(\n        keccak256(\n            bytes(\n                \"balanceOf(address)\"\n            )\n        )\n    );\n\n    /**\n     * @dev does an erc20 transfer then check for success\n     */\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                TRANSFER,\n                _to,\n                _value\n            )\n        );\n\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \"LiquidTransfer: TRANSFER_FAILED\"\n        );\n    }\n\n    /**\n     * @dev does an erc20 transferFrom then check for success\n     */\n    function _safeTransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        internal\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                TRANSFER_FROM,\n                _from,\n                _to,\n                _value\n            )\n        );\n\n        require(\n            success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))),\n            \"LiquidTransfer: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    /**\n     * @dev does an erc20 balanceOf then check for success\n     */\n    function _safeBalance(\n        address _token,\n        address _owner\n    )\n        internal\n        returns (uint256)\n    {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(\n                BALANCE_OF,\n                _owner\n            )\n        );\n\n        if (success == false) return 0;\n\n        return abi.decode(\n            data,\n            (uint256)\n        );\n    }\n\n    event ERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes data\n    );\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    )\n        external\n        returns (bytes4)\n    {\n        emit ERC721Received(\n            _operator,\n            _from,\n            _tokenId,\n            _data\n        );\n\n        return this.onERC721Received.selector;\n    }\n}\n"},"RouterEvents.sol":{"content":"// SPDX-License-Identifier: WISE\n\npragma solidity =0.8.17;\n\ncontract RouterEvents {\n\n    event FundsDeposited(\n        address indexed pool,\n        address indexed user,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsWithdrawn(\n        address indexed pool,\n        address indexed user,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsBorrowed(\n        address indexed pool,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        uint256 amount,\n        address borrower,\n        uint256 timestamp\n    );\n\n    event MoreFundsBorrowed(\n        address indexed pool,\n        address indexed nftAddress,\n        address indexed borrower,\n        uint256 tokenId,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event FundsReturned(\n        address indexed pool,\n        address indexed nftAddress,\n        address indexed tokenOwner,\n        uint256 transferAmount,\n        uint256 tokenId,\n        uint256 timestamp\n    );\n\n    event LiquidPoolRegistered(\n        address indexed pool,\n        uint256 timestamp\n    );\n\n    event Liquidated(\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        uint256 discountAmount,\n        address indexed liquidator,\n        uint256 timestamp\n    );\n\n    event RootAnnounced(\n        address caller,\n        uint256 unlockTime,\n        address indexed nftAddress,\n        bytes32 indexed merkleRoot,\n        string indexed ipfsAddress\n    );\n\n    event RootUpdated(\n        address caller,\n        uint256 updateTime,\n        address indexed nftAddress,\n        bytes32 indexed merkleRoot,\n        string indexed ipfsAddress\n    );\n\n    event UpdateAnnounced(\n        address caller,\n        uint256 unlockTime,\n        address indexed pool,\n        address indexed nftAddress\n    );\n\n    event PoolUpdated(\n        address caller,\n        uint256 updateTime,\n        address indexed pool,\n        address indexed nftAddress\n    );\n\n    event FeeDestinatoinChanged(\n        address indexed pool,\n        address indexed newDestination\n    );\n\n    event ExpansionRevoked(\n        address pool\n    );\n}\n"}}