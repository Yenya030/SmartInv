1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/AdoptAHyphen.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {IAdoptAHyphen} from \"./interfaces/IAdoptAHyphen.sol\";\nimport {IERC721} from \"./interfaces/IERC721.sol\";\nimport {AdoptAHyphenArt} from \"./utils/AdoptAHyphenArt.sol\";\nimport {AdoptAHyphenMetadata} from \"./utils/AdoptAHyphenMetadata.sol\";\nimport {Base64} from \"./utils/Base64.sol\";\n\n/// @title adopt-a-hyphen\n/// @notice Adopt a Hyphen: exchange a Hyphen NFT into this contract to mint a\n/// Hyphen Guy.\ncontract AdoptAHyphen is IAdoptAHyphen, ERC721, ERC721TokenReceiver, Owned {\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice Description of the collection.\n    string constant COLLECTION_DESCRIPTION =\n        unicode\"With each passing day, more and more people are switching from \"\n        unicode\"“on-chain” to “onchain.” While this may seem like a harmless ch\"\n        unicode\"oice, thousands of innocent hyphens are losing their place in t\"\n        unicode\"he world. No longer needed to hold “on-chain” together, these h\"\n        unicode\"yphens are in need of a loving place to call home. What if you \"\n        unicode\"could make a difference in a hyphen’s life forever?\\\\n\\\\nIntrod\"\n        unicode\"ucing the Adopt-a-Hyphen program, where you can adopt a hyphen \"\n        unicode\"and give it a new home...right in your wallet! Each hyphen in t\"\n        unicode\"his collection was adopted via an on-chain mint and is now safe\"\n        unicode\" and sound in this collection. As is their nature, each hyphen \"\n        unicode\"lives fully on-chain and is rendered in Solidity as cute, gener\"\n        unicode\"ative ASCII art.\";\n\n    // -------------------------------------------------------------------------\n    // Immutable storage\n    // -------------------------------------------------------------------------\n\n    /// @notice The Hyphen NFT contract that must be transferred into this\n    /// contract in order to mint a token.\n    IERC721 public immutable override hyphenNft;\n\n    // -------------------------------------------------------------------------\n    // Constructor + Mint\n    // -------------------------------------------------------------------------\n\n    /// @param _owner Initial owner of the contract.\n    constructor(\n        address _hyphenNft,\n        address _owner\n    ) ERC721(\"Adopt-a-Hyphen\", \"-\") Owned(_owner) {\n        hyphenNft = IERC721(_hyphenNft);\n    }\n\n    /// @inheritdoc IAdoptAHyphen\n    function mint(uint256 _tokenId) external {\n        // Transfer the Hyphen NFT into this contract.\n        hyphenNft.transferFrom(msg.sender, address(this), _tokenId);\n\n        // Mint token.\n        _mint(msg.sender, _tokenId);\n    }\n\n    // -------------------------------------------------------------------------\n    // ERC721Metadata\n    // -------------------------------------------------------------------------\n\n    /// @inheritdoc ERC721\n    function tokenURI(\n        uint256 _tokenId\n    ) public view override returns (string memory) {\n        // Revert if the token hasn't been minted.\n        if (_ownerOf[_tokenId] == address(0)) revert TokenUnminted();\n\n        // Seed to generate the art and metadata from.\n        uint256 seed = uint256(keccak256(abi.encodePacked(_tokenId)));\n\n        // Generate the metadata.\n        string memory name = AdoptAHyphenMetadata.generateName(seed);\n        string memory attributes = AdoptAHyphenMetadata.generateAttributes(\n            seed\n        );\n\n        return\n            string.concat(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    abi.encodePacked(\n                        '{\"name\":\"',\n                        name,\n                        '\",\"description\":\"',\n                        COLLECTION_DESCRIPTION,\n                        '\",\"image_data\":\"data:image/svg+xml;base64,',\n                        Base64.encode(\n                            abi.encodePacked(AdoptAHyphenArt.render(seed))\n                        ),\n                        '\",\"attributes\":',\n                        attributes,\n                        \"}\"\n                    )\n                )\n            );\n    }\n\n    // -------------------------------------------------------------------------\n    // Contract metadata\n    // -------------------------------------------------------------------------\n\n    /// @inheritdoc IAdoptAHyphen\n    function contractURI() external pure override returns (string memory) {\n        return\n            string.concat(\n                \"data:application/json;base64,\",\n                Base64.encode(\n                    abi.encodePacked(\n                        '{\"name\":\"Adopt-a-Hyphen\",\"description\":\"',\n                        COLLECTION_DESCRIPTION,\n                        '\"}'\n                    )\n                )\n            );\n    }\n}\n"
6     },
7     "lib/solmate/src/tokens/ERC721.sol": {
8       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
9     },
10     "lib/solmate/src/auth/Owned.sol": {
11       "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"
12     },
13     "src/interfaces/IAdoptAHyphen.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title The interface for {AdoptAHyphen}\ninterface IAdoptAHyphen {\n    // -------------------------------------------------------------------------\n    // Errors\n    // -------------------------------------------------------------------------\n\n    /// @notice Emitted when a token hasn't been minted.\n    error TokenUnminted();\n\n    // -------------------------------------------------------------------------\n    // Immutable storage\n    // -------------------------------------------------------------------------\n\n    /// @return The Hyphen NFT contract.\n    function hyphenNft() external view returns (IERC721);\n\n    // -------------------------------------------------------------------------\n    // Functions\n    // -------------------------------------------------------------------------\n\n    /// @notice Mints a token to the sender in exchange for the hyphen NFT (the\n    /// NFT gets transferred into this contract, and it can never be transferred\n    /// out).\n    /// @dev `msg.sender` must have approvals set to `true` on the hyphen NFT\n    /// with the operator as this contract's address.\n    function mint(uint256 _tokenId) external;\n\n    // -------------------------------------------------------------------------\n    // Metadata\n    // -------------------------------------------------------------------------\n\n    /// @return The contract URI for this contract.\n    function contractURI() external view returns (string memory);\n}\n"
15     },
16     "src/interfaces/IERC721.sol": {
17       "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external payable;\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external;\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n}\n"
18     },
19     "src/utils/AdoptAHyphenArt.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {LibPRNG} from \"solady/utils/LibPRNG.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\n\n/// @title Adopt-a-Hyphen art\n/// @notice A library for generating SVGs for {AdoptAHyphen}.\n/// @dev For this library to be correct, all `_seed` values must be consistent\n/// with every function in both {AdoptAHyphenArt} and {AdoptAHyphenMetadata}.\nlibrary AdoptAHyphenArt {\n    using LibPRNG for LibPRNG.PRNG;\n    using LibString for uint256;\n\n    // -------------------------------------------------------------------------\n    // Structs\n    // -------------------------------------------------------------------------\n\n    /// @notice The traits that make up a Hyphen Guy.\n    /// @param head Head trait, a number in `[0, 3]`. Equal chances.\n    /// @param eye Eye trait, a number in `[0, 16]`. Equal chances.\n    /// @param hat Hat trait, a number in `[0, 14]`. 25% chance of being `0`,\n    /// which indicates no hat trait. Equal chances amongst the other hats.\n    /// @param arm Arm trait, a number in `[0, 4]`. Equal chances.\n    /// @param body Body trait, a number in `[0, 2]`. Equal chances.\n    /// @param chest Chest trait, a number in `[0, 4]`. 50% chance of being `0`,\n    /// which indicates no chest trait. Equal chances amongst the other chests.\n    /// @param leg Leg trait, a number in `[0, 3]`. Equal chances.\n    /// @param background Background trait, a number in `[0, 8]`. Equal chances.\n    /// @param chaosBg Whether the background is made up of multiple background\n    /// characters, or just 1. 25% chance of being true.\n    /// @param intensity Number of positions (out of 253 (`23 * 11`)) to fill\n    /// with a background character, a number in `[50, 200]`. 25% chance of\n    /// being `252`, which indicates no variable intensity (every empty position\n    /// would be filled). Equal chances amongst the other intensities.\n    struct HyphenGuy {\n        uint8 head;\n        uint8 eye;\n        uint8 hat;\n        uint8 arm;\n        uint8 body;\n        uint8 chest;\n        uint8 leg;\n        uint8 background;\n        bool chaosBg;\n        uint8 intensity;\n        bool inverted;\n        uint8 color;\n    }\n\n    // -------------------------------------------------------------------------\n    // Constants\n    // -------------------------------------------------------------------------\n\n    /// @notice Starting string for the SVG.\n    /// @dev The `line-height` attribute for `pre` elements is set to `51px`\n    /// because we want to fit in 11 lines into a `600 - 32 * 2 + 12` = 548px\n    /// tall container. At 32px, the Martian Mono Extra Bold font has a width of\n    /// 22.4px and a height of 38.5px. Additionally, we want to fit 11 lines\n    /// with 23 characters each into a 600px square container with 32px padding\n    /// on each side. Martian Mono comes with an overhead of 12px above each\n    /// character, and 0px on either side, so effectively, we want to fit in\n    /// `22.4px/character * 11 characters` into a `600 - 32 * 2 + 12` = 548px\n    /// tall container, and `38.5px/character * 23 characters` into a\n    /// `600 - 32 * 2` = 536px wide container. Therefore, we calculate 51px for\n    /// the `line-height` property:\n    /// `38.5 + (548 - 38.5 * 11) / (11 - 1) = 50.95 ≈ 51`. We round to `51`\n    /// because Safari doesn't support decimal values for `line-height`, so\n    /// technically, the text is off by `0.05 * 23` = 1.15px. Similarly, we\n    /// calculate 0.945 for the `letter-spacing` property:\n    /// `(536 - 23 * 22.4) / 22 ≈ 0.945`. We set these properties on the `pre`\n    /// element.\n    string constant SVG_START =\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"600\" height=\"600\" viewB'\n        'ox=\"0 0 600 600\"><style>@font-face{font-family:A;src:url(data:font/wof'\n        \"f2;utf-8;base64,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)}pre{font-family:A;font-s\"\n        \"ize:32px;text-align:center;margin:0;letter-spacing:0.945px;line-height\"\n        \":51px}@supports (color:color(display-p3 1 1 1)){.z{color:oklch(79.59% \"\n        \"0.042 250.64)!important}.y{color:oklch(60.59% 0.306 309.33)!important}\"\n        \".x{color:oklch(69.45% 0.219 157.46)!important}.w{color:oklch(75.22% 0.\"\n        \"277 327.48)!important}.v{color:oklch(77.86% 0.16 226.017)!important}.u\"\n        \"{color:oklch(74.3% 0.213 50.613)!important}.t{color:oklch(61.52% 0.224\"\n        \" 256.099)!important}.s{color:oklch(62.61% 0.282 29.234)!important}}</s\"\n        \"tyle><path \";\n\n    /// @notice Ending string for the SVG.\n    string constant SVG_END = \"</pre></foreignObject></svg>\";\n\n    /// @notice Characters corresponding to the `head` trait's left characters.\n    bytes32 constant HEADS_LEFT = \"|[({\";\n\n    /// @notice Characters corresponding to the `head` trait's right characters.\n    bytes32 constant HEADS_RIGHT = \"|])}\";\n\n    /// @notice Characters corresponding to the `eye` trait's characters.\n    bytes32 constant EYES = \"\\\"#$'*+-.0=OTX^oxz\";\n\n    /// @notice Characters corresponding to the `hat` trait's characters.\n    /// @dev An index of 0 corresponds to no hat trait, so the character at\n    /// index 0 can be anything, but we just made it a space here.\n    /// @dev If the hat character is `&` (i.e. index of `5`), then it must be\n    /// drawn in its entity form, i.e. `&amp;`.\n    bytes32 constant HATS = \" !#$%&'*+-.=@^~\";\n\n    /// @notice Characters corresponding to the `arm` trait's left characters.\n    /// @dev If the arm character is `<` (i.e. index of `1`), then it must be\n    /// drawn in its entity form, i.e. `&lt;`.\n    bytes32 constant ARMS_LEFT = \"/<~J2\";\n\n    /// @notice Characters corresponding to the `arm` trait's right characters.\n    /// @dev If the arm character is `>` (i.e. index of `1`), then it must be\n    /// drawn in its entity form, i.e. `&gt;`.\n    bytes32 constant ARMS_RIGHT = \"\\\\>~L7\";\n\n    /// @notice Characters corresponding to the `body` trait's left characters.\n    bytes32 constant BODIES_LEFT = \"[({\";\n\n    /// @notice Characters corresponding to the `body` trait's right characters.\n    bytes32 constant BODIES_RIGHT = \"])}\";\n\n    /// @notice Characters corresponding to the `chest` trait's characters.\n    /// @dev An index of 0 corresponds to no chest trait, so the character at\n    /// index 0 can be anything, but we just made it a space here.\n    bytes32 constant CHESTS = \"  :*=.\";\n\n    /// @notice Characters corresponding to the `leg` trait's left characters.\n    bytes32 constant LEGS_LEFT = \"|/|/\";\n\n    /// @notice Characters corresponding to the `leg` trait's right characters.\n    bytes32 constant LEGS_RIGHT = \"||\\\\\\\\\";\n\n    /// @notice Characters corresponding to the `background` trait's characters.\n    /// @dev If the background character is `\\` (i.e. index of `6`), then it\n    /// must be escaped properly in JSONs, i.e. `\\\\\\\\`.\n    bytes32 constant BACKGROUNDS = \"#*+-/=\\\\|.\";\n\n    /// @notice Characters for the last few characters in the background that\n    /// spell out ``CHAIN''.\n    /// @dev The character at index 0 can be anything, but we just made it `N`\n    /// here.\n    bytes32 constant CHAIN_REVERSED = \"NIAHC\";\n\n    /// @notice Bitpacked integer of 32-bit words containing 24-bit colors.\n    /// @dev The first 8 bits in each word are unused, but we made each word\n    /// 32-bit so we can calculate the bit index via `<< 5`, rather than `* 24`.\n    uint256 constant COLORS =\n        0xA9BFD700AD43ED0000BA7300FE63FF0000C9FF00FF8633000080FF00FE0000;\n\n    /// @notice Utility string for converting targetting classes that provide\n    /// p3 color support (see classes `s` through `z` in `SVG_START`'s `<style>`\n    /// block).\n    bytes32 constant COLOR_CLASSES = \"stuvwxyz\";\n\n    // -------------------------------------------------------------------------\n    // `render`\n    // -------------------------------------------------------------------------\n\n    /// @notice Renders a Hyphen Guy SVG.\n    /// @param _seed Seed to select traits for the Hyphen Guy.\n    /// @return SVG string representing the Hyphen Guy.\n    function render(uint256 _seed) internal pure returns (string memory) {\n        // Initialize PRNG.\n        LibPRNG.PRNG memory prng = LibPRNG.PRNG(_seed);\n\n        // The Hyphen Guy.\n        HyphenGuy memory hyphenGuy;\n\n        // Select traits from `prng`.\n        hyphenGuy.head = uint8(prng.state & 3); // 4 heads (2 bits)\n        prng.state >>= 2;\n        hyphenGuy.eye = uint8(prng.state % 17); // 17 eyes (5 bits)\n        prng.state >>= 5;\n        hyphenGuy.hat = uint8( // 25% chance + 14 hats (2 + 4 = 6 bits)\n            prng.state & 3 == 0 ? 0 : 1 + ((prng.state >> 2) % 14)\n        );\n        prng.state >>= 6;\n        hyphenGuy.arm = uint8(prng.state % 5); // 5 arms (3 bits)\n        prng.state >>= 3;\n        hyphenGuy.body = uint8(prng.state % 3); // 3 bodies (2 bits)\n        prng.state >>= 2;\n        hyphenGuy.chest = uint8(\n            prng.state & 1 == 0 ? 0 : 1 + ((prng.state >> 1) % 5)\n        ); // 50% chance + 5 chests (1 + 3 = 4 bits)\n        prng.state >>= 4;\n        hyphenGuy.leg = uint8(prng.state & 3); // 4 legs (2 bits)\n        prng.state >>= 2;\n        hyphenGuy.background = uint8(prng.state % 9); // 9 backgrounds (4 bits)\n        prng.state >>= 4;\n        hyphenGuy.chaosBg = prng.state & 3 == 0; // 25% chance (2 bits)\n        prng.state >>= 2;\n        hyphenGuy.intensity = uint8(\n            prng.state & 3 == 0 ? 50 + ((prng.state >> 2) % 151) : 252\n        ); // 25% chance + 151 intensities (2 + 8 = 10 bits)\n        prng.state >>= 10;\n        hyphenGuy.inverted = prng.state & 7 == 0; // 12.5% chance (3 bits)\n        prng.state >>= 3;\n        hyphenGuy.color = uint8(prng.state & 7); // 8 colors (3 bits)\n\n        // Get the next state in the PRNG.\n        prng.state = prng.next();\n\n        // `bitmap` has `0`s where the index corresponds to a Hyphen Guy\n        // character, and `1` where not. We use this to determine whether to\n        // render a Hyphen Guy character or a background character. i.e. it\n        // looks like the following:\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        //                        11111111100000111111111\n        //                        11111111100100111111111\n        //                        11111111100100111111111\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        //                        11111111111111111111111\n        // By default, `bitmap` has `1`s set in the positions for hat and chest\n        // characters. In the following `assembly` block, we determine whether a\n        // hat or chest exists and `XOR` the relevant parts to transform the\n        // bitmap.\n        uint256 bitmap = 0x1FFFFFFFFFFFFFFFFFFFFFFFFF07FFFE4FFFFC9FFFFFFFFFFFFFFFFFFFFFFFFF;\n        uint8 hat = hyphenGuy.hat;\n        uint8 chest = hyphenGuy.chest;\n        assembly {\n            // Equivalent to\n            // `bitmap ^= (((hat != 0) << 172) | ((chest != 0) << 126))`. We\n            // flip the bit corresponding to the position of the chest if there\n            // exists a chest trait because we don't want to draw both a\n            // background character and the chest character.\n            bitmap := xor(\n                bitmap,\n                or(shl(172, gt(hat, 0)), shl(126, gt(chest, 0)))\n            )\n        }\n\n        // Here, we initialize another bitmap to determine whether to render a\n        // space character or a background character when we're not observing a\n        // `hyphenGuy` character position. Since we want to render as many\n        // characters in the background as equals the intensity value, we can:\n        //     1. Instantiate a 253-bit long bitmap.\n        //     2. Set the first `intensity` bits to `1`, and `0` otherwise.\n        //     3. Shuffle the bitmap.\n        // Then, by reading the bits at each index, we can determine whether to\n        // render a space character (i.e. empty) or a background character. We\n        // begin by instantiating an array of 253 `uint256`s, each with a single\n        // `1` bit set to make use of `LibPRNG.shuffle`.\n        uint256[] memory bgBitmapBits = new uint256[](253);\n        for (uint256 i; i <= hyphenGuy.intensity; ) {\n            bgBitmapBits[i] = 1;\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Shuffle the array if intensity mode.\n        if (hyphenGuy.intensity < 252) prng.shuffle(bgBitmapBits);\n\n        uint256 bgBitmap;\n        for (uint256 i; i < 253; ) {\n            // `intensity >= 252` implies `intenseBg = true`\n            bgBitmap <<= 1;\n            bgBitmap |= bgBitmapBits[i];\n            unchecked {\n                ++i;\n            }\n        }\n        prng.state = prng.next();\n\n        uint256 row;\n        uint256 col;\n        // The string corresponding to the characters of the contents of the\n        // background `<text>` element.\n        string memory bgStr = \"\";\n        // The string corresponding to the characters of the contents of the\n        // Hyphen Guy `<text>` element. We generate the entire first row here.\n        string memory charStr = string.concat(\n            \"  \", // Start with 2 spaces for positioning.\n            // If the hat character is `&`, we need to draw it as\n            // its entity form.\n            hyphenGuy.hat != 5\n                ? string(abi.encodePacked(HATS[hyphenGuy.hat]))\n                : \"&amp;\",\n            hyphenGuy.hat != 0 ? \"\" : \" \",\n            \"  \\n\"\n        );\n        // Iterate through the positions in reverse order. Note that the last\n        // character (i.e. the one that contains ``N'' from ``CHAIN'') is not\n        // drawn, and it must be accounted for after the loop.\n        for (uint256 i = 252; i != 0; ) {\n            assembly {\n                row := div(i, 11)\n                col := mod(i, 23)\n            }\n\n            // Add word characters (i.e. ``ON'' and ``CHAIN'').\n            if (i == 252) bgStr = string.concat(bgStr, \"O\");\n            else if (i == 251) bgStr = string.concat(bgStr, \"N\");\n            else if (i < 5) {\n                bgStr = string.concat(\n                    bgStr,\n                    string(abi.encodePacked(CHAIN_REVERSED[i]))\n                );\n            } else if ((bitmap >> i) & 1 == 0) {\n                // Is a Hyphen Guy character.\n                // Since there's a Hyphen Guy character that'll be drawn, the\n                // background character in the same position must be empty.\n                bgStr = string.concat(bgStr, \" \");\n\n                // Generate the Hyphen Guy by drawing rows of characters. Note\n                // that we've already passed the check for whether a chest\n                // character exists and applied it to the bitmap accordingly, so\n                // we can safely draw the chest character here--if no chest\n                // piece exists, a background character will be drawn anyway\n                // because it wouldn't pass the `(bitmap >> i) & 1 == 0` check.\n                if (i == 151) {\n                    charStr = string.concat(\n                        charStr,\n                        string(abi.encodePacked(HEADS_LEFT[hyphenGuy.head])),\n                        string(abi.encodePacked(EYES[hyphenGuy.eye])),\n                        \"-\",\n                        string(abi.encodePacked(EYES[hyphenGuy.eye])),\n                        string(abi.encodePacked(HEADS_RIGHT[hyphenGuy.head])),\n                        \"\\n\"\n                    );\n                } else if (i == 128) {\n                    charStr = string.concat(\n                        charStr,\n                        // If the arm character is `<`, we need to draw it as\n                        // its entity form.\n                        hyphenGuy.arm != 1\n                            ? string(abi.encodePacked(ARMS_LEFT[hyphenGuy.arm]))\n                            : \"&lt;\",\n                        string(abi.encodePacked(BODIES_LEFT[hyphenGuy.body]))\n                    );\n                    {\n                        charStr = string.concat(\n                            charStr,\n                            string(abi.encodePacked(CHESTS[hyphenGuy.chest])),\n                            string(\n                                abi.encodePacked(BODIES_RIGHT[hyphenGuy.body])\n                            ),\n                            // If the arm character is `>`, we need to draw it\n                            // as its entity form.\n                            hyphenGuy.arm != 1\n                                ? string(\n                                    abi.encodePacked(ARMS_RIGHT[hyphenGuy.arm])\n                                )\n                                : \"&gt;\",\n                            \"\\n\"\n                        );\n                    }\n                } else if (i == 105) {\n                    charStr = string.concat(\n                        charStr,\n                        \"_\",\n                        string(abi.encodePacked(LEGS_LEFT[hyphenGuy.leg])),\n                        \" \",\n                        string(abi.encodePacked(LEGS_RIGHT[hyphenGuy.leg])),\n                        \"_\"\n                    );\n                }\n            } else if ((bgBitmap >> i) & 1 != 0) {\n                // We make use of the `bgBitmap` generated earlier from the\n                // intensity value here. If the check above passed, it means a\n                // background character must be drawn here.\n                bgStr = string.concat(\n                    bgStr,\n                    string(\n                        abi.encodePacked(\n                            BACKGROUNDS[\n                                // Select a random background if `chaosBg` is\n                                // true.\n                                hyphenGuy.chaosBg\n                                    ? prng.state % 9\n                                    : hyphenGuy.background\n                            ]\n                        )\n                    )\n                );\n                // We need to generate a new random number for the next\n                // potentially-random character.\n                prng.state = prng.next();\n            } else {\n                // Failed all checks. Empty background character.\n                bgStr = string.concat(bgStr, \" \");\n            }\n\n            // Draw a newline character if we've reached the end of a row.\n            if (col == 0) bgStr = string.concat(bgStr, \"\\n\");\n            unchecked {\n                --i;\n            }\n        }\n\n        string memory colorHexString = string.concat(\n            \"#\",\n            ((COLORS >> (hyphenGuy.color << 5)) & 0xFFFFFF).toHexStringNoPrefix(\n                3\n            )\n        );\n\n        return\n            string.concat(\n                SVG_START,\n                hyphenGuy.inverted\n                    ? string.concat(\n                        'class=\"',\n                        string(\n                            abi.encodePacked(COLOR_CLASSES[hyphenGuy.color])\n                        ),\n                        '\" '\n                    )\n                    : \"\",\n                'd=\"M0 0h600v600H0z\" fill=\"',\n                hyphenGuy.inverted ? colorHexString : \"#FFF\",\n                // `x` is `32` because we want a left padding of 32px. `y` is\n                // `20` because the Martian Mono font has an overhead of 12px,\n                // and we want a top padding of 32px. Thus, by setting it to\n                // `32 - 12` = 20px, we align the top of the letters with 32px\n                // down from the top of the SVG. `width` is `536` because we\n                // want left/right padding of 32px: `600 - 32*2 = 536`. Finally,\n                // `height` is `561` because we have 11 lines, and each line is\n                // 51 pixels tall: `11 * 51 = 561`.\n                '\"/><foreignObject x=\"32\" y=\"20\" width=\"536\" height=\"561\"><pre '\n                'style=\"color:rgba(0,0,0,0.05)\" xmlns=\"http://www.w3.org/1999/x'\n                'html\">',\n                bgStr,\n                // Recall that ``N'' was not accounted for in the loop because\n                // we didn't look at index 0, so we draw it here. `x` is `32`\n                // for the same reason outlined in the previous comment. `y` is\n                // `173` because the character starts 3 lines below the first\n                // (`3 * 51 = 153`), and we have the same 20px overhead as\n                // before, so `153 + 20 = 173`. `width` is `536` for the same\n                // reason. Finally, `height` is `204` because the character is 4\n                // lines tall, and each line is 51 pixels tall: `4 * 51 = 204`.\n                'N</pre></foreignObject><foreignObject x=\"32\" y=\"173\" width=\"53'\n                '6\" height=\"204\"><pre',\n                hyphenGuy.inverted\n                    ? \"\"\n                    : string.concat(\n                        ' class=\"',\n                        string(\n                            abi.encodePacked(COLOR_CLASSES[hyphenGuy.color])\n                        ),\n                        '\"'\n                    ),\n                ' style=\"color:',\n                hyphenGuy.inverted ? \"#FFF\" : colorHexString,\n                '\" xmlns=\"http://www.w3.org/1999/xhtml\">',\n                charStr,\n                SVG_END\n            );\n    }\n}\n"
21     },
22     "src/utils/AdoptAHyphenMetadata.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {AdoptAHyphenArt} from \"./AdoptAHyphenArt.sol\";\n\n/// @title adopt-a-hyphen metadata\n/// @notice A library for generating metadata for {AdoptAHyphen}.\n/// @dev For this library to be correct, all `_seed` values must be consistent\n/// with every function in both {AdoptAHyphenArt} and {AdoptAHyphenMetadata}.\nlibrary AdoptAHyphenMetadata {\n    using LibString for string;\n    using LibString for uint256;\n\n    /// @notice Number of bits used to generate the art. We take note of this\n    /// because we don't want to use the same bits to generate the metadata.\n    uint256 constant BITS_USED = 47;\n\n    /// @notice Joined list of adjectives to use when generating the name with\n    /// `_` as the delimiter.\n    /// @dev To read from this constant, use\n    /// `LibString.split(string(ADJECTIVES), \"_\")`.\n    bytes constant ADJECTIVES =\n        \"All-Important_Angel-Faced_Awe-Inspiring_Battle-Scarred_Big-Boned_Bird-\"\n        \"Like_Black-and-White_Breath-Taking_Bright-Eyed_Broad-Shouldered_Bull-H\"\n        \"eaded_Butter-Soft_Cat-Eyed_Cool-Headed_Cross-Eyed_Death-Defying_Devil-\"\n        \"May-Care_Dew-Fresh_Dim-Witted_Down-to-Earth_Eagle-Nosed_Easy-Going_Eve\"\n        \"r-Changing_Faint-Hearted_Feather-Brained_Fish-Eyed_Fly-by-Night_Free-T\"\n        \"hinking_Fun-Loving_Half-Baked_Hawk-Eyed_Heart-Breaking_High-Spirited_H\"\n        \"oney-Dipped_Honey-Tongued_Ice-Cold_Ill-Gotten_Iron-Grey_Iron-Willed_Ke\"\n        \"en-Eyed_Kind-Hearted_Left-Handed_Lion-Hearted_Off-the-Grid_Open-Faced_\"\n        \"Pale-Faced_Razor-Sharp_Red-Faced_Rosy-Cheeked_Ruby-Red_Self-Satisfied_\"\n        \"Sharp-Nosed_Short-Sighted_Silky-Haired_Silver-Tongued_Sky-Blue_Slow-Fo\"\n        \"oted_Smooth-as-Silk_Smooth-Talking_Snake-Like_Snow-Cold_Snow-White_Sof\"\n        \"t-Voiced_Sour-Faced_Steel-Blue_Stiff-Necked_Straight-Laced_Strong-Mind\"\n        \"ed_Sugar-Sweet_Thick-Headed_Tight-Fisted_Tongue-in-Cheek_Tough-Minded_\"\n        \"Trigger-Happy_Velvet-Voiced_Water-Washed_White-Faced_Wide-Ranging_Wild\"\n        \"-Haired_Wishy-Washy_Work-Weary_Yellow-Bellied_Camera-Shy_Cold-as-Ice_E\"\n        \"mpty-Handed_Fair-Weather_Fire-Breathing_Jaw-Dropping_Mind-Boggling_No-\"\n        \"Nonsense_Rough-and-ready_Slap-Happy_Smooth-Faced_Snail-Paced_Soul-Sear\"\n        \"ching_Star-Studded_Tongue-Tied_Too-Good-to-be-True_Turtle-Necked_Diamo\"\n        \"nd-Handed\";\n\n    /// @notice Joined list of first names to use when generating the name with\n    /// `_` as the delimiter.\n    /// @dev To read from this constant, use\n    /// `LibString.split(string(FIRST_NAMES), \"_\")`.\n    bytes constant FIRST_NAMES =\n        \"Alexis_Ali_Alicia_Andres_Asha_Barb_Betty_Bruce_Charles_Chris_Coco_Dan_\"\n        \"David_Dennis_Elijah_Eugene_James_Jayden_Jenny_Jess_Joe_John_Jose_Karen\"\n        \"_Linda_Lisa_Liz_Marco_Mark_Mary_Matt_Mert_Mike_Mirra_Nancy_Noor_Novak_\"\n        \"Patty_Peggy_Ravi_Richard_Robert_Sandra_Sarah_Sue_Tayne_Tom_Tony_Will_Y\"\n        \"ana\";\n\n    /// @notice Joined list of hue names to use when generating the name with\n    /// `_` as the delimiter.\n    /// @dev To read from this constant, use\n    /// `LibString.split(string(HUES), \"_\")`.\n    bytes constant HUES = \"red_blue_orange_teal_pink_green_purple_gray\";\n\n    /// @notice Joined list of hobbies to use when generating the name with `_`\n    /// as the delimiter.\n    /// @dev To read from this constant, use\n    /// `LibString.split(string(HOBBIES), \"_\")`.\n    bytes constant HOBBIES =\n        \"blit-mapp_terra-form_shield-build_loot-bagg_OKPC-draw_mooncat-rescu_au\"\n        \"to-glyph_animal-color_ava-starr_party-card_chain-runn_forgotten-run_bi\"\n        \"bo-glint\";\n\n    /// @notice Generates a Hyphen Guy name.\n    /// @param _seed Seed to select traits for the Hyphen Guy.\n    /// @return Hyphen Guy's name.\n    function generateName(uint256 _seed) internal pure returns (string memory) {\n        string[] memory adjectives = string(ADJECTIVES).split(\"_\");\n        string[] memory firstNames = string(FIRST_NAMES).split(\"_\");\n\n        _seed >>= BITS_USED;\n\n        return\n            string.concat(\n                firstNames[(_seed >> 7) % 50], // Adjectives used 7 bits\n                \" \",\n                adjectives[_seed % 100]\n            );\n    }\n\n    /// @notice Generates a Hyphen Guy's attributes.\n    /// @param _seed Seed to select traits for the Hyphen Guy.\n    /// @return Hyphen Guy's attributes.\n    function generateAttributes(\n        uint256 _seed\n    ) internal pure returns (string memory) {\n        string[] memory hues = string(HUES).split(\"_\");\n        string[] memory hobbies = string(HOBBIES).split(\"_\");\n\n        // We directly use the value of `_seed` because we don't need further\n        // randomness.\n        // The bits used to determine the color value are bits [24, 27]\n        // (0-indexed). See {AdoptAHyphenArt.render} for more information.\n        uint256 background = (_seed >> 24) % 9;\n\n        // The bits used to determine whether the background is in ``intensity\n        // mode'' or not are bits [30, 31] (0-indexed). See\n        // {AdoptAHyphenArt.render} for more information.\n        bool intensityMode = ((_seed >> 30) & 3) == 0;\n\n        // The bits used to determine the color value are bits [43, 45]\n        // (0-indexed). See {AdoptAHyphenArt.render} for more information.\n        uint256 color = (_seed >> 43) & 7;\n\n        // The art renderer uses the last `BITS_USED` bits to generate its\n        // traits, and `generateName` uses 12 bits to generate the name, so we\n        // shift those portions off.\n        _seed >>= BITS_USED;\n        _seed >>= 12;\n        uint256 rizz = _seed % 101; // [0, 100] (7 bits)\n        _seed >>= 7;\n        uint256 hobby = _seed % 13; // 13 hobbies (4 bits)\n        _seed >>= 4;\n\n        return\n            string.concat(\n                '[{\"trait_type\":\"hue\",\"value\":\"',\n                hues[color],\n                '\"},',\n                '{\"trait_type\":\"vibe\",\"value\":\"',\n                background == 6\n                    ? \"\\\\\\\\\"\n                    : string(\n                        abi.encodePacked(\n                            AdoptAHyphenArt.BACKGROUNDS[background]\n                        )\n                    ),\n                '\"},{\"trait_type\":\"demeanor\",\"value\":\"',\n                intensityMode ? \"ex\" : \"in\",\n                'troverted\"},{\"trait_type\":\"hobby\",\"value\":\"',\n                hobbies[hobby],\n                'ing\"},{\"trait_type\":\"rizz\",\"value\":',\n                rizz.toString(),\n                \"}]\"\n            );\n    }\n}\n"
24     },
25     "src/utils/Base64.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678\"\n        \"9+/\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n        string memory table = TABLE;\n        uint256 encodedLength = ((data.length + 2) / 3) << 2;\n        string memory result = new string(encodedLength + 0x20);\n\n        assembly {\n            mstore(result, encodedLength)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 0x20)\n\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(\n                    resultPtr,\n                    shl(0xF8, mload(add(tablePtr, and(shr(0x12, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(0xF8, mload(add(tablePtr, and(shr(0xC, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(0xF8, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore(\n                    resultPtr,\n                    shl(0xF8, mload(add(tablePtr, and(input, 0x3F))))\n                )\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(0xF0, 0x3D3D))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(0xF8, 0x3D))\n            }\n        }\n\n        return result;\n    }\n}\n"
27     },
28     "lib/solady/src/utils/LibPRNG.sol": {
29       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for generating psuedorandom numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibPRNG.sol)\nlibrary LibPRNG {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev A psuedorandom number state in memory.\n    struct PRNG {\n        uint256 state;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         OPERATIONS                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Seeds the `prng` with `state`.\n    function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }\n\n    /// @dev Returns the next psuedorandom uint256.\n    /// All bits of the returned uint256 pass the NIST Statistical Test Suite.\n    function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }\n\n    /// @dev Returns a psuedorandom uint256, uniformly distributed\n    /// between 0 (inclusive) and `upper` (exclusive).\n    /// If your modulus is big, this method is recommended\n    /// for uniform sampling to avoid modulo bias.\n    /// For uniform sampling across all uint256 values,\n    /// or for small enough moduli such that the bias is neligible,\n    /// use {next} instead.\n    function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }\n\n    /// @dev Shuffles the array in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Shuffles the bytes in-place with Fisher-Yates shuffle.\n    function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }\n}\n"
30     },
31     "lib/solady/src/utils/LibString.sol": {
32       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(mload(a), 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
33     }
34   },
35   "settings": {
36     "remappings": [
37       "ds-test/=lib/forge-std/lib/ds-test/src/",
38       "forge-std/=lib/forge-std/src/",
39       "solady/=lib/solady/src/",
40       "solmate/=lib/solmate/src/"
41     ],
42     "optimizer": {
43       "enabled": true,
44       "runs": 7777777
45     },
46     "metadata": {
47       "bytecodeHash": "none"
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "devdoc",
55           "userdoc",
56           "metadata",
57           "abi"
58         ]
59       }
60     },
61     "evmVersion": "london",
62     "libraries": {}
63   }
64 }}