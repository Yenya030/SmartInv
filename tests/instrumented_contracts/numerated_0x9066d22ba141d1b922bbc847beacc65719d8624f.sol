1 /**
2 helo am spoderman an 2dai am guna teech u howe 2 go milyons
3 
4 Telegram:http://t.me/SpodermanETH
5 Website: https://spoderman.org/
6 Twitter: https://twitter.com/spodermankoin
7 
8 
9 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
10 â¬œâ¬œâ¬œâ¬œâ¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
11 â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
12 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
13 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
14 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
15 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
16 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
17 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
18 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
19 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
20 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
21 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
22 â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
23 â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œ
24 â¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œâ¬œâ¬œâ¬œ
25 â¬œâ¬œâ¬œâ¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œ
26 â¬œâ¬œâ¬›ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œ
27 â¬œâ¬œâ¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œ
28 â¬œâ¬œâ¬›â¬›â¬›ðŸŸ¥â¬›ðŸŸ¥â¬›â¬›ðŸŸ¥ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œ
29 â¬œâ¬›ðŸŸ¥â¬›ðŸŸ¥â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¥ðŸŸ¥â¬›â¬œ
30 â¬œâ¬›ðŸŸ¥â¬›â¬›ðŸŸ¥â¬›ðŸŸ¥â¬›â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›â¬œ
31 â¬œâ¬›ðŸŸ¥â¬›ðŸŸ¥â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›
32 â¬œâ¬›ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›
33 â¬œâ¬œâ¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›
34 â¬œâ¬›ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›
35 â¬œâ¬›ðŸŸ¥â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¥â¬›
36 â¬›ðŸŸ¥ðŸŸ¥â¬›ðŸŸ¦â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¦ðŸŸ¥ðŸŸ¥â¬›
37 â¬›ðŸŸ¥â¬›â¬›ðŸŸ¦ðŸŸ¦â¬›â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
38 â¬›ðŸŸ¥â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›ðŸŸ¥â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
39 â¬›ðŸŸ¥â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›
40 â¬œâ¬›â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›ðŸŸ¥ðŸŸ¥â¬›â¬›â¬œ
41 â¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›â¬›â¬œâ¬œâ¬œ
42 â¬œâ¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
43 â¬œâ¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬œâ¬›ðŸŸ¦ðŸŸ¦ðŸŸ¦ðŸŸ¦â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œ
44 â¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬›â¬›â¬›â¬›ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œ
45 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œ
46 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œ
47 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œ
48 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œ
49 â¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œ
50 â¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œ
51 â¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œ
52 â¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›ðŸŸ¥ðŸŸ¥ðŸŸ¥ðŸŸ¥â¬›â¬œâ¬œ
53 â¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬œâ¬›â¬›â¬›â¬›â¬›â¬›â¬œâ¬œ
54 */
55 
56 // SPDX-License-Identifier: Unlicensed
57 pragma solidity ^0.8.9;
58 
59 abstract contract Context {
60     function _msgSender() internal view virtual returns (address) {
61         return msg.sender;
62     }
63 }
64 
65 interface IERC20 {
66     function totalSupply() external view returns (uint256);
67 
68     function balanceOf(address account) external view returns (uint256);
69 
70     function transfer(address recipient, uint256 amount) external returns (bool);
71 
72     function allowance(address owner, address spender) external view returns (uint256);
73 
74     function approve(address spender, uint256 amount) external returns (bool);
75 
76     function transferFrom(
77         address sender,
78         address recipient,
79         uint256 amount
80     ) external returns (bool);
81 
82     event Transfer(address indexed from, address indexed to, uint256 value);
83     event Approval(
84         address indexed owner,
85         address indexed spender,
86         uint256 value
87     );
88 }
89 
90 contract Ownable is Context {
91     address private _owner;
92     address private _previousOwner;
93     event OwnershipTransferred(
94         address indexed previousOwner,
95         address indexed newOwner
96     );
97 
98     constructor() {
99         address msgSender = _msgSender();
100         _owner = msgSender;
101         emit OwnershipTransferred(address(0), msgSender);
102     }
103 
104     function owner() public view returns (address) {
105         return _owner;
106     }
107 
108     modifier onlyOwner() {
109         require(_owner == _msgSender(), "Ownable: caller is not the owner");
110         _;
111     }
112 
113     function renounceOwnership() public virtual onlyOwner {
114         emit OwnershipTransferred(_owner, address(0));
115         _owner = address(0);
116     }
117 
118     function transferOwnership(address newOwner) public virtual onlyOwner {
119         require(newOwner != address(0), "Ownable: new owner is the zero address");
120         emit OwnershipTransferred(_owner, newOwner);
121         _owner = newOwner;
122     }
123 
124 }
125 
126 library SafeMath {
127     function add(uint256 a, uint256 b) internal pure returns (uint256) {
128         uint256 c = a + b;
129         require(c >= a, "SafeMath: addition overflow");
130         return c;
131     }
132 
133     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
134         return sub(a, b, "SafeMath: subtraction overflow");
135     }
136 
137     function sub(
138         uint256 a,
139         uint256 b,
140         string memory errorMessage
141     ) internal pure returns (uint256) {
142         require(b <= a, errorMessage);
143         uint256 c = a - b;
144         return c;
145     }
146 
147     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
148         if (a == 0) {
149             return 0;
150         }
151         uint256 c = a * b;
152         require(c / a == b, "SafeMath: multiplication overflow");
153         return c;
154     }
155 
156     function div(uint256 a, uint256 b) internal pure returns (uint256) {
157         return div(a, b, "SafeMath: division by zero");
158     }
159 
160     function div(
161         uint256 a,
162         uint256 b,
163         string memory errorMessage
164     ) internal pure returns (uint256) {
165         require(b > 0, errorMessage);
166         uint256 c = a / b;
167         return c;
168     }
169 }
170 
171 interface IUniswapV2Factory {
172     function createPair(address tokenA, address tokenB)
173         external
174         returns (address pair);
175 }
176 
177 interface IUniswapV2Router02 {
178     function swapExactTokensForETHSupportingFeeOnTransferTokens(
179         uint256 amountIn,
180         uint256 amountOutMin,
181         address[] calldata path,
182         address to,
183         uint256 deadline
184     ) external;
185 
186     function factory() external pure returns (address);
187 
188     function WETH() external pure returns (address);
189 
190     function addLiquidityETH(
191         address token,
192         uint256 amountTokenDesired,
193         uint256 amountTokenMin,
194         uint256 amountETHMin,
195         address to,
196         uint256 deadline
197     )
198         external
199         payable
200         returns (
201             uint256 amountToken,
202             uint256 amountETH,
203             uint256 liquidity
204         );
205 }
206 
207 contract SPODERMAN is Context, IERC20, Ownable {
208 
209     using SafeMath for uint256;
210 
211     string private constant _name = "SPODERMAN";
212     string private constant _symbol = "SPODERMAN";
213     uint8 private constant _decimals = 9;
214 
215     mapping(address => uint256) private _rOwned;
216     mapping(address => uint256) private _tOwned;
217     mapping(address => mapping(address => uint256)) private _allowances;
218     mapping(address => bool) private _isExcludedFromFee;
219     uint256 private constant MAX = ~uint256(0);
220     uint256 private constant _tTotal = 420690000000 * 10**9;
221     uint256 private _rTotal = (MAX - (MAX % _tTotal));
222     uint256 private _tFeeTotal;
223     uint256 private _redisFeeOnBuy = 0;
224     uint256 private _taxFeeOnBuy = 20;
225     uint256 private _redisFeeOnSell = 0;
226     uint256 private _taxFeeOnSell = 60;
227 
228     //Original Fee
229     uint256 private _redisFee = _redisFeeOnSell;
230     uint256 private _taxFee = _taxFeeOnSell;
231 
232     uint256 private _previousredisFee = _redisFee;
233     uint256 private _previoustaxFee = _taxFee;
234 
235     mapping(address => bool) public bots; mapping (address => uint256) public _buyMap;
236     address payable private _developmentAddress = payable(0x82b31FD2C2C3FC73B5D7C60A3D542662F37Fd32F);
237     address payable private _marketingAddress = payable(0x82b31FD2C2C3FC73B5D7C60A3D542662F37Fd32F);
238 
239     IUniswapV2Router02 public uniswapV2Router;
240     address public uniswapV2Pair;
241 
242     bool private tradingOpen = false;
243     bool private inSwap = false;
244     bool private swapEnabled = true;
245 
246     uint256 public _maxTxAmount = 6310350000 * 10**9;
247     uint256 public _maxWalletSize = 6310350000 * 10**9;
248     uint256 public _swapTokensAtAmount = 1051725000 * 10**9;
249 
250     event MaxTxAmountUpdated(uint256 _maxTxAmount);
251     modifier lockTheSwap {
252         inSwap = true;
253         _;
254         inSwap = false;
255     }
256 
257     constructor() {
258 
259         _rOwned[_msgSender()] = _rTotal;
260 
261         IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);//
262         uniswapV2Router = _uniswapV2Router;
263         uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())
264             .createPair(address(this), _uniswapV2Router.WETH());
265 
266         _isExcludedFromFee[owner()] = true;
267         _isExcludedFromFee[address(this)] = true;
268         _isExcludedFromFee[_developmentAddress] = true;
269         _isExcludedFromFee[_marketingAddress] = true;
270 
271         emit Transfer(address(0), _msgSender(), _tTotal);
272     }
273 
274     function name() public pure returns (string memory) {
275         return _name;
276     }
277 
278     function symbol() public pure returns (string memory) {
279         return _symbol;
280     }
281 
282     function decimals() public pure returns (uint8) {
283         return _decimals;
284     }
285 
286     function totalSupply() public pure override returns (uint256) {
287         return _tTotal;
288     }
289 
290     function balanceOf(address account) public view override returns (uint256) {
291         return tokenFromReflection(_rOwned[account]);
292     }
293 
294     function transfer(address recipient, uint256 amount)
295         public
296         override
297         returns (bool)
298     {
299         _transfer(_msgSender(), recipient, amount);
300         return true;
301     }
302 
303     function allowance(address owner, address spender)
304         public
305         view
306         override
307         returns (uint256)
308     {
309         return _allowances[owner][spender];
310     }
311 
312     function approve(address spender, uint256 amount)
313         public
314         override
315         returns (bool)
316     {
317         _approve(_msgSender(), spender, amount);
318         return true;
319     }
320 
321     function transferFrom(
322         address sender,
323         address recipient,
324         uint256 amount
325     ) public override returns (bool) {
326         _transfer(sender, recipient, amount);
327         _approve(
328             sender,
329             _msgSender(),
330             _allowances[sender][_msgSender()].sub(
331                 amount,
332                 "ERC20: transfer amount exceeds allowance"
333             )
334         );
335         return true;
336     }
337 
338     function tokenFromReflection(uint256 rAmount)
339         private
340         view
341         returns (uint256)
342     {
343         require(
344             rAmount <= _rTotal,
345             "Amount must be less than total reflections"
346         );
347         uint256 currentRate = _getRate();
348         return rAmount.div(currentRate);
349     }
350 
351     function removeAllFee() private {
352         if (_redisFee == 0 && _taxFee == 0) return;
353 
354         _previousredisFee = _redisFee;
355         _previoustaxFee = _taxFee;
356 
357         _redisFee = 0;
358         _taxFee = 0;
359     }
360 
361     function restoreAllFee() private {
362         _redisFee = _previousredisFee;
363         _taxFee = _previoustaxFee;
364     }
365 
366     function _approve(
367         address owner,
368         address spender,
369         uint256 amount
370     ) private {
371         require(owner != address(0), "ERC20: approve from the zero address");
372         require(spender != address(0), "ERC20: approve to the zero address");
373         _allowances[owner][spender] = amount;
374         emit Approval(owner, spender, amount);
375     }
376 
377     function _transfer(
378         address from,
379         address to,
380         uint256 amount
381     ) private {
382         require(from != address(0), "ERC20: transfer from the zero address");
383         require(to != address(0), "ERC20: transfer to the zero address");
384         require(amount > 0, "Transfer amount must be greater than zero");
385 
386         if (from != owner() && to != owner()) {
387 
388             //Trade start check
389             if (!tradingOpen) {
390                 require(from == owner(), "TOKEN: This account cannot send tokens until trading is enabled");
391             }
392 
393             require(amount <= _maxTxAmount, "TOKEN: Max Transaction Limit");
394             require(!bots[from] && !bots[to], "TOKEN: Your account is blacklisted!");
395 
396             if(to != uniswapV2Pair) {
397                 require(balanceOf(to) + amount < _maxWalletSize, "TOKEN: Balance exceeds wallet size!");
398             }
399 
400             uint256 contractTokenBalance = balanceOf(address(this));
401             bool canSwap = contractTokenBalance >= _swapTokensAtAmount;
402 
403             if(contractTokenBalance >= _maxTxAmount)
404             {
405                 contractTokenBalance = _maxTxAmount;
406             }
407 
408             if (canSwap && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {
409                 swapTokensForEth(contractTokenBalance);
410                 uint256 contractETHBalance = address(this).balance;
411                 if (contractETHBalance > 0) {
412                     sendETHToFee(address(this).balance);
413                 }
414             }
415         }
416 
417         bool takeFee = true;
418 
419         //Transfer Tokens
420         if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {
421             takeFee = false;
422         } else {
423 
424             //Set Fee for Buys
425             if(from == uniswapV2Pair && to != address(uniswapV2Router)) {
426                 _redisFee = _redisFeeOnBuy;
427                 _taxFee = _taxFeeOnBuy;
428             }
429 
430             //Set Fee for Sells
431             if (to == uniswapV2Pair && from != address(uniswapV2Router)) {
432                 _redisFee = _redisFeeOnSell;
433                 _taxFee = _taxFeeOnSell;
434             }
435 
436         }
437 
438         _tokenTransfer(from, to, amount, takeFee);
439     }
440 
441     function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
442         address[] memory path = new address[](2);
443         path[0] = address(this);
444         path[1] = uniswapV2Router.WETH();
445         _approve(address(this), address(uniswapV2Router), tokenAmount);
446         uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
447             tokenAmount,
448             0,
449             path,
450             address(this),
451             block.timestamp
452         );
453     }
454 
455     function sendETHToFee(uint256 amount) private {
456         _marketingAddress.transfer(amount);
457     }
458 
459     function setTrading(bool _tradingOpen) public onlyOwner {
460         tradingOpen = _tradingOpen;
461     }
462 
463     function manualswap() external {
464         require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);
465         uint256 contractBalance = balanceOf(address(this));
466         swapTokensForEth(contractBalance);
467     }
468 
469     function manualsend() external {
470         require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);
471         uint256 contractETHBalance = address(this).balance;
472         sendETHToFee(contractETHBalance);
473     }
474 
475     function blockBots(address[] memory bots_) public onlyOwner {
476         for (uint256 i = 0; i < bots_.length; i++) {
477             bots[bots_[i]] = true;
478         }
479     }
480 
481     function unblockBot(address notbot) public onlyOwner {
482         bots[notbot] = false;
483     }
484 
485     function _tokenTransfer(
486         address sender,
487         address recipient,
488         uint256 amount,
489         bool takeFee
490     ) private {
491         if (!takeFee) removeAllFee();
492         _transferStandard(sender, recipient, amount);
493         if (!takeFee) restoreAllFee();
494     }
495 
496     function _transferStandard(
497         address sender,
498         address recipient,
499         uint256 tAmount
500     ) private {
501         (
502             uint256 rAmount,
503             uint256 rTransferAmount,
504             uint256 rFee,
505             uint256 tTransferAmount,
506             uint256 tFee,
507             uint256 tTeam
508         ) = _getValues(tAmount);
509         _rOwned[sender] = _rOwned[sender].sub(rAmount);
510         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
511         _takeTeam(tTeam);
512         _reflectFee(rFee, tFee);
513         emit Transfer(sender, recipient, tTransferAmount);
514     }
515 
516     function _takeTeam(uint256 tTeam) private {
517         uint256 currentRate = _getRate();
518         uint256 rTeam = tTeam.mul(currentRate);
519         _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
520     }
521 
522     function _reflectFee(uint256 rFee, uint256 tFee) private {
523         _rTotal = _rTotal.sub(rFee);
524         _tFeeTotal = _tFeeTotal.add(tFee);
525     }
526 
527     receive() external payable {}
528 
529     function _getValues(uint256 tAmount)
530         private
531         view
532         returns (
533             uint256,
534             uint256,
535             uint256,
536             uint256,
537             uint256,
538             uint256
539         )
540     {
541         (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =
542             _getTValues(tAmount, _redisFee, _taxFee);
543         uint256 currentRate = _getRate();
544         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =
545             _getRValues(tAmount, tFee, tTeam, currentRate);
546         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
547     }
548 
549     function _getTValues(
550         uint256 tAmount,
551         uint256 redisFee,
552         uint256 taxFee
553     )
554         private
555         pure
556         returns (
557             uint256,
558             uint256,
559             uint256
560         )
561     {
562         uint256 tFee = tAmount.mul(redisFee).div(100);
563         uint256 tTeam = tAmount.mul(taxFee).div(100);
564         uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
565         return (tTransferAmount, tFee, tTeam);
566     }
567 
568     function _getRValues(
569         uint256 tAmount,
570         uint256 tFee,
571         uint256 tTeam,
572         uint256 currentRate
573     )
574         private
575         pure
576         returns (
577             uint256,
578             uint256,
579             uint256
580         )
581     {
582         uint256 rAmount = tAmount.mul(currentRate);
583         uint256 rFee = tFee.mul(currentRate);
584         uint256 rTeam = tTeam.mul(currentRate);
585         uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
586         return (rAmount, rTransferAmount, rFee);
587     }
588 
589     function _getRate() private view returns (uint256) {
590         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
591         return rSupply.div(tSupply);
592     }
593 
594     function _getCurrentSupply() private view returns (uint256, uint256) {
595         uint256 rSupply = _rTotal;
596         uint256 tSupply = _tTotal;
597         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
598         return (rSupply, tSupply);
599     }
600 
601     function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {
602         _redisFeeOnBuy = redisFeeOnBuy;
603         _redisFeeOnSell = redisFeeOnSell;
604         _taxFeeOnBuy = taxFeeOnBuy;
605         _taxFeeOnSell = taxFeeOnSell;
606     }
607 
608     //Set minimum tokens required to swap.
609     function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {
610         _swapTokensAtAmount = swapTokensAtAmount;
611     }
612 
613     //Set minimum tokens required to swap.
614     function toggleSwap(bool _swapEnabled) public onlyOwner {
615         swapEnabled = _swapEnabled;
616     }
617 
618     //Set maximum transaction
619     function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {
620         _maxTxAmount = maxTxAmount;
621     }
622 
623     function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {
624         _maxWalletSize = maxWalletSize;
625     }
626 
627     function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {
628         for(uint256 i = 0; i < accounts.length; i++) {
629             _isExcludedFromFee[accounts[i]] = excluded;
630         }
631     }
632 
633 }