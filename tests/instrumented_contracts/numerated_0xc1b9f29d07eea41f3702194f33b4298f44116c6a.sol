1 {{
2   "language": "Solidity",
3   "settings": {
4     "evmVersion": "london",
5     "libraries": {},
6     "metadata": {
7       "bytecodeHash": "ipfs",
8       "useLiteralContent": true
9     },
10     "optimizer": {
11       "enabled": true,
12       "runs": 200
13     },
14     "remappings": [],
15     "outputSelection": {
16       "*": {
17         "*": [
18           "evm.bytecode",
19           "evm.deployedBytecode",
20           "devdoc",
21           "userdoc",
22           "metadata",
23           "abi"
24         ]
25       }
26     }
27   },
28   "sources": {
29     "@openzeppelin/contracts/access/Ownable.sol": {
30       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
31     },
32     "@openzeppelin/contracts/utils/Address.sol": {
33       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
34     },
35     "@openzeppelin/contracts/utils/Context.sol": {
36       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
37     },
38     "contracts/AVATAR.sol": {
39       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract AVATAR is ERC20, Ownable {\n    uint256 private constant MAX_BPS = 100_00;\n\n    uint256 public immutable start;\n    uint256 public immutable end;\n    uint256 public immutable initialPenalty;\n\n    uint96 public fee;\n    address public pair;\n    bool private active;\n\n    mapping(address => bool) public whitelisted;\n\n    constructor() ERC20(\"Avatar Moon\", \"AVATAR\", 18) {\n        start = block.timestamp;\n        initialPenalty = 7_00; // 7%\n        end = block.timestamp + 30 days;\n        fee = 3_33; // 3.33%\n        active = false;\n\n        require(initialPenalty <= MAX_BPS, \"max penalty is 100%\");\n        require(fee <= MAX_BPS, \"max fee is 100%\");\n        require(start <= end, \"start must be <= end\");\n\n        whitelisted[msg.sender] = true;\n\n        _mint(msg.sender, 250_000_000e18);\n    }\n\n    function currentPenalty() public view returns (uint256 _penalty) {\n        if (block.timestamp < end) {\n            unchecked {\n                uint256 _remaining = end - block.timestamp;\n                _penalty = (initialPenalty * _remaining) / (end - start);\n            }\n        }\n    }\n\n    function _transfer(address sender_, address recipient_, uint256 amount_) internal override {\n        if (!whitelisted[sender_]) {\n            require(active, \"!active\");\n\n            uint256 _feeAmount = (amount_ * fee) / MAX_BPS;\n\n            // Burn penalty\n            if (sender_ != pair && block.timestamp < end) {\n                uint256 _burnt = (amount_ * currentPenalty()) / MAX_BPS;\n\n                if (_burnt > 0) {\n                    super._transfer(sender_, address(0), _burnt);\n\n                    // `_burnt` is always <= `amount_`\n                    unchecked {\n                        amount_ -= _burnt;\n                    }\n                }\n            }\n\n            // Collect fee\n            if (_feeAmount > 0) {\n                super._transfer(sender_, owner(), _feeAmount);\n                // `_feeAmount` is always <= `amount_`\n                unchecked {\n                    amount_ -= _feeAmount;\n                }\n            }\n        }\n\n        super._transfer(sender_, recipient_, amount_);\n    }\n\n    function updatePair(address pair_) external onlyOwner {\n        pair = pair_;\n        active = true;\n    }\n\n    function updateFee(uint96 fee_) external onlyOwner {\n        require(fee_ <= MAX_BPS, \"max fee is 100%\");\n        fee = fee_;\n    }\n\n    function toggleWhitelist(address address_) external onlyOwner {\n        whitelisted[address_] = !whitelisted[address_];\n    }\n\n    function sweep(IERC20 token_) external onlyOwner {\n        if (address(token_) == address(0)) {\n            Address.sendValue(payable(owner()), address(this).balance);\n        } else {\n            token_.transfer(owner(), token_.balanceOf(address(this)));\n        }\n    }\n}\n"
40     },
41     "contracts/ERC20.sol": {
42       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport {IERC20} from \"./interfaces/IERC20.sol\";\n\n/*\n    ███████╗██████╗  ██████╗    ██████╗  ██████╗\n    ██╔════╝██╔══██╗██╔════╝    ╚════██╗██╔═████╗\n    █████╗  ██████╔╝██║          █████╔╝██║██╔██║\n    ██╔══╝  ██╔══██╗██║         ██╔═══╝ ████╔╝██║\n    ███████╗██║  ██║╚██████╗    ███████╗╚██████╔╝\n    ╚══════╝╚═╝  ╚═╝ ╚═════╝    ╚══════╝ ╚═════╝\n*/\n\n/**\n *  @title Modern ERC-20 implementation.\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\n */\ncontract ERC20 is IERC20 {\n    /**************/\n    /*** ERC-20 ***/\n    /**************/\n\n    string public override name;\n    string public override symbol;\n\n    uint8 public immutable override decimals;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    /**\n     *  @param name_     The name of the token.\n     *  @param symbol_   The symbol of the token.\n     *  @param decimals_ The decimal precision used by the token.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    function approve(address spender_, uint256 amount_) public virtual override returns (bool success_) {\n        _approve(msg.sender, spender_, amount_);\n        return true;\n    }\n\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_)\n        public\n        virtual\n        override\n        returns (bool success_)\n    {\n        _decreaseAllowance(msg.sender, spender_, subtractedAmount_);\n        return true;\n    }\n\n    function increaseAllowance(address spender_, uint256 addedAmount_) public virtual override returns (bool success_) {\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\n        return true;\n    }\n\n    function transfer(address recipient_, uint256 amount_) public virtual override returns (bool success_) {\n        _transfer(msg.sender, recipient_, amount_);\n        return true;\n    }\n\n    function transferFrom(\n        address owner_,\n        address recipient_,\n        uint256 amount_\n    ) public virtual override returns (bool success_) {\n        _decreaseAllowance(owner_, msg.sender, amount_);\n        _transfer(owner_, recipient_, amount_);\n        return true;\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _approve(\n        address owner_,\n        address spender_,\n        uint256 amount_\n    ) internal {\n        emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\n    }\n\n    function _burn(address owner_, uint256 amount_) internal {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot underflow because a user's balance will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount_;\n        }\n\n        emit Transfer(owner_, address(0), amount_);\n    }\n\n    function _decreaseAllowance(\n        address owner_,\n        address spender_,\n        uint256 subtractedAmount_\n    ) internal {\n        uint256 spenderAllowance = allowance[owner_][spender_]; // Cache to memory.\n\n        if (spenderAllowance != type(uint256).max) {\n            _approve(owner_, spender_, spenderAllowance - subtractedAmount_);\n        }\n    }\n\n    function _mint(address recipient_, uint256 amount_) internal {\n        totalSupply += amount_;\n\n        // Cannot overflow because totalSupply would first overflow in the statement above.\n        unchecked {\n            balanceOf[recipient_] += amount_;\n        }\n\n        emit Transfer(address(0), recipient_, amount_);\n    }\n\n    function _transfer(\n        address owner_,\n        address recipient_,\n        uint256 amount_\n    ) internal virtual {\n        balanceOf[owner_] -= amount_;\n\n        // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances == totalSupply.\n        unchecked {\n            balanceOf[recipient_] += amount_;\n        }\n\n        emit Transfer(owner_, recipient_, amount_);\n    }\n}\n"
43     },
44     "contracts/interfaces/IERC20.sol": {
45       "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n/// @title Interface of the ERC20 standard as defined in the EIP, including EIP-2612 permit functionality.\ninterface IERC20 {\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    /**\n     *  @dev   Emitted when one account has set the allowance of another account over their tokens.\n     *  @param owner_   Account that tokens are approved from.\n     *  @param spender_ Account that tokens are approved for.\n     *  @param amount_  Amount of tokens that have been approved.\n     */\n    event Approval(address indexed owner_, address indexed spender_, uint256 amount_);\n\n    /**\n     *  @dev   Emitted when tokens have moved from one account to another.\n     *  @param owner_     Account that tokens have moved from.\n     *  @param recipient_ Account that tokens have moved to.\n     *  @param amount_    Amount of tokens that have been transferred.\n     */\n    event Transfer(address indexed owner_, address indexed recipient_, uint256 amount_);\n\n    /**************************/\n    /*** External Functions ***/\n    /**************************/\n\n    /**\n     *  @dev    Function that allows one account to set the allowance of another account over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender_ Account that tokens are approved for.\n     *  @param  amount_  Amount of tokens that have been approved.\n     *  @return success_ Boolean indicating whether the operation succeeded.\n     */\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\n\n    /**\n     *  @dev    Function that allows one account to decrease the allowance of another account over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender_          Account that tokens are approved for.\n     *  @param  subtractedAmount_ Amount to decrease approval by.\n     *  @return success_          Boolean indicating whether the operation succeeded.\n     */\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external returns (bool success_);\n\n    /**\n     *  @dev    Function that allows one account to increase the allowance of another account over their tokens.\n     *          Emits an {Approval} event.\n     *  @param  spender_     Account that tokens are approved for.\n     *  @param  addedAmount_ Amount to increase approval by.\n     *  @return success_     Boolean indicating whether the operation succeeded.\n     */\n    function increaseAllowance(address spender_, uint256 addedAmount_) external returns (bool success_);\n\n    /**\n     *  @dev    Moves an amount of tokens from `msg.sender` to a specified account.\n     *          Emits a {Transfer} event.\n     *  @param  recipient_ Account that receives tokens.\n     *  @param  amount_    Amount of tokens that are transferred.\n     *  @return success_   Boolean indicating whether the operation succeeded.\n     */\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\n\n    /**\n     *  @dev    Moves a pre-approved amount of tokens from a sender to a specified account.\n     *          Emits a {Transfer} event.\n     *          Emits an {Approval} event.\n     *  @param  owner_     Account that tokens are moving from.\n     *  @param  recipient_ Account that receives tokens.\n     *  @param  amount_    Amount of tokens that are transferred.\n     *  @return success_   Boolean indicating whether the operation succeeded.\n     */\n    function transferFrom(\n        address owner_,\n        address recipient_,\n        uint256 amount_\n    ) external returns (bool success_);\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    /**\n     *  @dev    Returns the allowance that one account has given another over their tokens.\n     *  @param  owner_     Account that tokens are approved from.\n     *  @param  spender_   Account that tokens are approved for.\n     *  @return allowance_ Allowance that one account has given another over their tokens.\n     */\n    function allowance(address owner_, address spender_) external view returns (uint256 allowance_);\n\n    /**\n     *  @dev    Returns the amount of tokens owned by a given account.\n     *  @param  account_ Account that owns the tokens.\n     *  @return balance_ Amount of tokens owned by a given account.\n     */\n    function balanceOf(address account_) external view returns (uint256 balance_);\n\n    /**\n     *  @dev    Returns the decimal precision used by the token.\n     *  @return decimals_ The decimal precision used by the token.\n     */\n    function decimals() external view returns (uint8 decimals_);\n\n    /**\n     *  @dev    Returns the name of the token.\n     *  @return name_ The name of the token.\n     */\n    function name() external view returns (string memory name_);\n\n    /**\n     *  @dev    Returns the symbol of the token.\n     *  @return symbol_ The symbol of the token.\n     */\n    function symbol() external view returns (string memory symbol_);\n\n    /**\n     *  @dev    Returns the total amount of tokens in existence.\n     *  @return totalSupply_ The total amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256 totalSupply_);\n}\n"
46     }
47   }
48 }}