1 pragma solidity ^0.4.18;
2 
3 /*
4 This is the main contract for MyEtherCity. Join us at https://myethercity.com/  
5 Game Name: MyEtherCity (The first city-building game built on top of the Ethereum Blockchain)
6 Game Link: https://myethercity.com/
7 */
8 
9 contract MyEtherCityGame {
10 
11     address ceoAddress = 0x699dE541253f253a4eFf0D3c006D70c43F2E2DaE;
12     address InitiateLandsAddress = 0xa93a135e3c73ab77ea00e194bd080918e65149c3;
13     
14     modifier onlyCeo() {
15         require (
16             msg.sender == ceoAddress||
17             msg.sender == InitiateLandsAddress
18             );
19         _;
20     }
21 
22     uint256 priceMetal = 5000000000000000;     // The developer can update the price of metak to regulate the market
23 
24     struct Land {
25         address ownerAddress;
26         uint256 landPrice;
27         bool landForSale;
28         bool landForRent;
29         uint landOwnerCommission;
30         bool isOccupied;
31         uint cityRentingId;
32     }
33     Land[] lands;
34 
35     struct City {
36         uint landId;
37         address ownerAddress;
38         uint256 cityPrice;
39         uint256 cityGdp; 
40         bool cityForSale;
41         uint squaresOccupied; // Equals 0 when we create the city
42         uint metalStock;
43     }
44     City[] cities;
45 
46     struct Business {
47         uint itemToProduce;
48         uint256 itemPrice;
49         uint cityId;
50         uint32 readyTime;
51     }
52     Business[] businesses;
53 
54     /*
55     Building type:
56     0 = house => Can house 5 citizens
57     1 = school => Can educate 30 citizens
58     2 = clean energy => Can energize 20 citizens
59     3 = fossil energy => Can energize 30 citizens
60     4 = hospital => Can heal 30 citizens
61     5 = amusement => Can amuse 35 citizens
62     6 = businesses
63     */
64 
65     struct Building {
66         uint buildingType;
67         uint cityId;
68         uint32 readyTime;
69     }
70     Building[] buildings;
71 
72     struct Transaction {
73         uint buyerId;
74         uint sellerId;
75         uint256 transactionValue;
76         uint itemId;
77         uint blockId;
78     }
79     Transaction[] transactions;
80 
81     mapping (uint => uint) public CityBuildingsCount;        // The amount of buildings owned by this address
82     mapping (uint => uint) public BuildingTypeMetalNeeded;   // The amount of metal needed to build all the buildings
83     mapping (uint => uint) public BuildingTypeSquaresOccupied;  // The land occupied by each building
84     mapping (uint => uint) public CountBusinessesPerType;       // We keep track of the amount of businesses created per type
85     mapping (uint => uint) public CityBusinessCount;            // We keep track of the amount of businesses owned by a city
86     mapping (uint => uint) public CitySalesTransactionsCount;    // We keep track of the sales generated by a city
87 
88     ///
89     /// GET
90     ///
91 
92     // This function will return the details for a land
93     function getLand(uint _landId) public view returns (
94         address ownerAddress,
95         uint256 landPrice,
96         bool landForSale,
97         bool landForRent,
98         uint landOwnerCommission,
99         bool isOccupied,
100         uint cityRentingId
101     ) {
102         Land storage _land = lands[_landId];
103 
104         ownerAddress = _land.ownerAddress;
105         landPrice = _land.landPrice;
106         landForSale = _land.landForSale;
107         landForRent = _land.landForRent;
108         landOwnerCommission = _land.landOwnerCommission;
109         isOccupied = _land.isOccupied;
110         cityRentingId = _land.cityRentingId;
111     }
112 
113     // This function will return the details for a city
114     function getCity(uint _cityId) public view returns (
115         uint landId,
116         address landOwner,
117         address cityOwner,
118         uint256 cityPrice,
119         uint256 cityGdp,
120         bool cityForSale,
121         uint squaresOccupied,
122         uint metalStock,
123         uint cityPopulation,
124         uint healthCitizens,
125         uint educationCitizens,
126         uint happinessCitizens,
127         uint productivityCitizens
128     ) {
129         City storage _city = cities[_cityId];
130 
131         landId = _city.landId;
132         landOwner = lands[_city.landId].ownerAddress;
133         cityOwner = _city.ownerAddress;
134         cityPrice = _city.cityPrice;
135         cityGdp = _city.cityGdp;
136         cityForSale = _city.cityForSale;
137         squaresOccupied = _city.squaresOccupied;
138         metalStock = _city.metalStock;
139         cityPopulation = getCityPopulation(_cityId);
140         healthCitizens = getHealthCitizens(_cityId);
141         educationCitizens = getEducationCitizens(_cityId);
142         happinessCitizens = getHappinessCitizens(_cityId);
143         productivityCitizens = getProductivityCitizens(_cityId);
144     }
145 
146     // This function will return the details for a business
147     function getBusiness(uint _businessId) public view returns (
148         uint itemToProduce,
149         uint256 itemPrice,
150         uint cityId,
151         uint cityMetalStock,
152         uint readyTime,
153         uint productionTime,
154         uint cityLandId,
155         address cityOwner
156     ) {
157         Business storage _business = businesses[_businessId];
158 
159         itemToProduce = _business.itemToProduce;
160         itemPrice = _business.itemPrice;
161         cityId = _business.cityId;
162         cityMetalStock = cities[_business.cityId].metalStock;
163         readyTime = _business.readyTime;
164         productionTime = getProductionTimeBusiness(_businessId);
165         cityLandId = cities[_business.cityId].landId;
166         cityOwner = cities[_business.cityId].ownerAddress;
167         
168     }
169 
170     // This function will return the details for a building
171     function getBuilding(uint _buildingId) public view returns (
172         uint buildingType,
173         uint cityId,
174         uint32 readyTime
175     ) {
176         Building storage _building = buildings[_buildingId];
177 
178         buildingType = _building.buildingType;
179         cityId = _building.cityId;
180         readyTime = _building.readyTime;
181     }
182 
183     // This function will return the details for a transaction
184     function getTransaction(uint _transactionId) public view returns (
185         uint buyerId,
186         uint sellerId,
187         uint256 transactionValue,
188         uint itemId,
189         uint blockId
190     ) {
191         Transaction storage _transaction = transactions[_transactionId];
192 
193         buyerId = _transaction.buyerId;
194         sellerId = _transaction.sellerId;
195         transactionValue = _transaction.transactionValue;
196         itemId = _transaction.itemId;
197         blockId = _transaction.blockId;
198     }
199 
200     // Returns the count of buildings for a city 
201     function getCityBuildings(uint _cityId, bool _active) public view returns (
202         uint countBuildings,
203         uint countHouses,
204         uint countSchools,
205         uint countHospital,
206         uint countAmusement
207     ) {
208         countBuildings = getCountAllBuildings(_cityId, _active);
209         countHouses = getCountBuildings(_cityId, 0, _active);
210         countSchools = getCountBuildings(_cityId, 1, _active);
211         countHospital = getCountBuildings(_cityId, 2, _active);
212         countAmusement = getCountBuildings(_cityId, 3, _active);
213     }
214         
215     // Get all the lands owned by a city
216     function getSenderLands(address _senderAddress) public view returns(uint[]) {
217         uint[] memory result = new uint[](getCountSenderLands(_senderAddress));
218         uint counter = 0;
219         for (uint i = 0; i < lands.length; i++) {
220           if (lands[i].ownerAddress == _senderAddress) {
221             result[counter] = i;
222             counter++;
223           }
224         }
225         return result;
226     }
227     
228     function getCountSenderLands(address _senderAddress) public view returns(uint) {
229         uint counter = 0;
230         for (uint i = 0; i < lands.length; i++) {
231           if (lands[i].ownerAddress == _senderAddress) {
232             counter++;
233           }
234         }
235         return(counter);
236     }
237     
238      // Get all the lands owned by a city
239     function getSenderCities(address _senderAddress) public view returns(uint[]) {
240         uint[] memory result = new uint[](getCountSenderCities(_senderAddress));
241         uint counter = 0;
242         for (uint i = 0; i < cities.length; i++) {
243           if (cities[i].ownerAddress == _senderAddress) {
244             result[counter] = i;
245             counter++;
246           }
247         }
248         return result;
249     }
250     
251     function getCountSenderCities(address _senderAddress) public view returns(uint) {
252         uint counter = 0;
253         for (uint i = 0; i < cities.length; i++) {
254           if (cities[i].ownerAddress == _senderAddress) {
255             counter++;
256           }
257         }
258         return(counter);
259     }
260 
261     // We use this function to return the population of a city
262     function getCityPopulation(uint _cityId) public view returns (uint) {
263         // We multiply the number of houses per 5 to get the population of a city
264         uint _cityActiveBuildings = getCountBuildings(_cityId, 0, true);
265         return(_cityActiveBuildings * 5);
266     }
267 
268     // Count the number of active or pending buildings
269     function getCountAllBuildings(uint _cityId, bool _active) public view returns(uint) {
270         uint counter = 0;
271         for (uint i = 0; i < buildings.length; i++) {
272             if(_active == true) {
273                 // If active == true we loop through the active buildings
274                 if(buildings[i].cityId == _cityId && buildings[i].readyTime < now) {
275                     counter++;
276                 }
277             } else {
278                 // If active == false we loop through the pending buildings
279                 if(buildings[i].cityId == _cityId && buildings[i].readyTime >= now) {
280                     counter++;
281                 }
282             }
283             
284         }
285         return counter;
286     }
287     
288     // Count the number of active or pending buildings
289     function getCountBuildings(uint _cityId, uint _buildingType, bool _active) public view returns(uint) {
290         uint counter = 0;
291         for (uint i = 0; i < buildings.length; i++) {
292             if(_active == true) {
293                 // If active == true we loop through the active buildings
294                 if(buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime < now) {
295                     counter++;
296                 }
297             } else {
298                 // If active == false we loop through the pending buildings
299                 if(buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime >= now) {
300                     counter++;
301                 }
302             }
303         }
304         return counter;
305     }
306 
307     // Get the active buildings (by type) owned by a specific city
308     function getCityActiveBuildings(uint _cityId, uint _buildingType) public view returns(uint[]) {
309         uint[] memory result = new uint[](getCountBuildings(_cityId, _buildingType, true));
310         uint counter = 0;
311         for (uint i = 0; i < buildings.length; i++) {
312             // We add the ready building owned by this user
313             if (buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime < now) {
314                 result[counter] = i;
315                 counter++;
316             }
317         }
318         return result;
319     }
320 
321     // Get the pending buildings (by type) owned by a specific city
322     function getCityPendingBuildings(uint _cityId, uint _buildingType) public view returns(uint[]) {
323         uint[] memory result = new uint[](getCountBuildings(_cityId, _buildingType, false));
324         uint counter = 0;
325         for (uint i = 0; i < buildings.length; i++) {
326             // We add the pending building owned by this user
327             if (buildings[i].buildingType == _buildingType && buildings[i].cityId == _cityId && buildings[i].readyTime >= now) {
328                 result[counter] = i;
329                 counter++;
330             }
331         }
332         return result;
333     }
334 
335     // Get Businesses per type
336     function getActiveBusinessesPerType(uint _businessType) public view returns(uint[]) {
337         uint[] memory result = new uint[](CountBusinessesPerType[_businessType]);
338         uint counter = 0;
339         for (uint i = 0; i < businesses.length; i++) {
340             // We add the pending building owned by this user
341             if (businesses[i].itemToProduce == _businessType) {
342                 result[counter] = i;
343                 counter++;
344             }
345         }
346         // returns an array of id for the active businesses
347         return result;
348     }
349 
350     // Get Businesses per city
351     function getActiveBusinessesPerCity(uint _cityId) public view returns(uint[]) {
352         uint[] memory result = new uint[](CityBusinessCount[_cityId]);
353         uint counter = 0;
354         for (uint i = 0; i < businesses.length; i++) {
355             // We add the pending building owned by this user
356             if (businesses[i].cityId == _cityId) {
357                 result[counter] = i;
358                 counter++;
359             }
360         }
361         // returns an array of id for the active businesses
362         return result;
363     }
364     
365     // Get the sales generated by a city
366     function getSalesCity(uint _cityId) public view returns(uint[]) {
367         uint[] memory result = new uint[](CitySalesTransactionsCount[_cityId]);
368         uint counter = 0;
369         uint startId = transactions.length - 1;
370         for (uint i = 0; i < transactions.length; i++) {
371             uint _tId = startId - i;
372             // We add the pending building owned by this user
373             if (transactions[_tId].sellerId == _cityId) {
374                 result[counter] = _tId;
375                 counter++;
376             }
377         }
378         // returns an array of id for the sales generated by the city (the most recent sales comes in first)
379         return result;
380     }
381 
382     // Return the health of the citizens of a city
383     function getHealthCitizens(uint _cityId) public view returns(uint) {
384         uint _hospitalsCount = getCountBuildings(_cityId, 2, true);
385         uint pointsHealth = (_hospitalsCount * 500) + 50;
386         uint _population = getCityPopulation(_cityId);
387         uint256 _healthPopulation = 10;
388         
389         if(_population > 0) {
390             _healthPopulation = (pointsHealth / uint256(_population));
391         } else {
392             _healthPopulation = 0;
393         }
394         
395         // The indicator can't be more than 10
396         if(_healthPopulation > 10) {
397             _healthPopulation = 10;
398         }
399         return(_healthPopulation);
400     }
401 
402     // Return the education of the citizens of a city
403     function getEducationCitizens(uint _cityId) public view returns(uint) {
404         uint _schoolsCount = getCountBuildings(_cityId, 1, true);
405         uint pointsEducation = (_schoolsCount * 250) + 25;
406         uint _population = getCityPopulation(_cityId);
407         uint256 _educationPopulation = 10;
408 
409         if(_population > 0) {
410             _educationPopulation = (pointsEducation / uint256(_population));
411         } else {
412             _educationPopulation = 0;
413         }
414         
415         if(_educationPopulation > 10) {
416             _educationPopulation = 10;
417         }
418         return(_educationPopulation);
419     }
420 
421     // Return the happiness of the citizens of a city
422     function getHappinessCitizens(uint _cityId) public view returns(uint) {
423         uint _amusementCount = getCountBuildings(_cityId, 3, true);
424         uint pointsAmusement = (_amusementCount * 350) + 35;
425         uint _population = getCityPopulation(_cityId);
426         uint256 _amusementPopulation = 10;
427         
428         if(_population > 0) {
429             _amusementPopulation = (pointsAmusement / uint256(_population));
430         } else {
431             _amusementPopulation = 0;
432         }
433         
434         // The indicator can't be more than 10
435         if(_amusementPopulation > 10) {
436             _amusementPopulation = 10;
437         }
438         return(_amusementPopulation);
439     }
440 
441     // Return the productivity of the citizens of a city
442     function getProductivityCitizens(uint _cityId) public view returns(uint) {
443         return((getEducationCitizens(_cityId) + getHealthCitizens(_cityId) + getHappinessCitizens(_cityId)) / 3);
444     }
445 
446     // This function returns the maximum businesses a city can build (according to its population)
447     function getMaxBusinessesPerCity(uint _cityId) public view returns(uint) {
448         uint _citizens = getCityPopulation(_cityId);
449         uint _maxBusinesses;
450 
451         // Calculate the max amount of businesses available per city
452         if(_citizens >= 75) {
453             _maxBusinesses = 4;
454         } else if(_citizens >= 50) {
455             _maxBusinesses = 3;
456         } else if(_citizens >= 25) {
457             _maxBusinesses = 2;
458         } else {
459             _maxBusinesses = 1;
460         }
461 
462         return(_maxBusinesses);
463     }
464     
465     function getCountCities() public view returns(uint) {
466         return(cities.length);
467     }
468 
469     ///
470     /// ACTIONS
471     ///
472     
473     // Land owner can use this function to remove a city from their land 
474     function removeTenant(uint _landId) public {
475         require(lands[_landId].ownerAddress == msg.sender);
476         lands[_landId].landForRent = false;
477         lands[_landId].isOccupied = false;
478         cities[lands[_landId].cityRentingId].landId = 0;
479         lands[_landId].cityRentingId = 0;
480     }
481 
482     // We use this function to purchase a business
483     // Businesses are free to create but each city can run only one business.
484     function createBusiness(uint _itemId, uint256 _itemPrice, uint _cityId) public {
485         // We check if the price of the item sold is enough regarding the current price of the metal
486         require(_itemPrice >= BuildingTypeMetalNeeded[_itemId] * priceMetal);
487 
488         // We verifiy that the sender is the owner of the city
489         require(cities[_cityId].ownerAddress == msg.sender);
490 
491         // We check that the city has enough squares to host this new building
492         require((cities[_cityId].squaresOccupied + BuildingTypeSquaresOccupied[4]) <= 100);
493         
494         // We check if the city has enough population to create this business (1 building / 25 citizens)
495         require(CityBusinessCount[_cityId] < getMaxBusinessesPerCity(_cityId));
496 
497         // We create the business
498         businesses.push(Business(_itemId, _itemPrice, _cityId, 0));
499 
500         // We increment the businesses count for this type and city
501         CountBusinessesPerType[_itemId]++;
502 
503         // We increment the count of businesses for this city
504         CityBusinessCount[_cityId]++;
505 
506         // Increment the squares used in this land
507         cities[_cityId].squaresOccupied = cities[_cityId].squaresOccupied + BuildingTypeSquaresOccupied[4];
508     }
509 
510     // This function can let business owner update the price of the building they are selling
511     function updateBusiness(uint _businessId, uint256 _itemPrice) public {
512         // We check if the user is the owner of the business
513         require(cities[businesses[_businessId].cityId].ownerAddress == msg.sender);
514 
515         // We check if the price of the item sold is enough regarding the current price of the metal
516         require(_itemPrice >= BuildingTypeMetalNeeded[businesses[_businessId].itemToProduce] * priceMetal);
517 
518         businesses[_businessId].itemPrice = _itemPrice;
519     }
520 
521     // We use this function to purchase metal
522     function purchaseMetal(uint _cityId, uint _amount) public payable {
523         // We check that the user is paying the correct price 
524         require(msg.value == _amount * priceMetal);
525 
526         // We verifiy that the sender is the owner of the city
527         require(cities[_cityId].ownerAddress == msg.sender);
528 
529         // Transfer the amount paid to the ceo
530         ceoAddress.transfer(msg.value);
531 
532         // Add the metal to the city stock
533         cities[_cityId].metalStock = cities[_cityId].metalStock + _amount;
534     }
535     
536     // This function will return the production time for a specific business
537     function getProductionTimeBusiness(uint _businessId) public view returns(uint256) {
538         uint _productivityIndicator = getProductivityCitizens(businesses[_businessId].cityId);
539         uint _countCitizens = getCityPopulation(businesses[_businessId].cityId);
540         
541         uint256 productivityFinal;
542         
543         if(_countCitizens == 0) {
544             // The min production time with 0 citizens should be 7000
545             productionTime = 7000; 
546         } else {
547             // We calculat the production time
548             if(_productivityIndicator <= 1) {
549             productivityFinal = _countCitizens;
550             } else {
551                 productivityFinal = _countCitizens * (_productivityIndicator / 2);
552             }
553             
554             uint256 productionTime = 60000 / uint256(productivityFinal);
555         }
556         return(productionTime);
557     }
558 
559     // We use this function to purchase a building from a business
560     function purchaseBuilding(uint _itemId, uint _businessId, uint _cityId) public payable {
561         // We verify that the user is paying the correct price
562         require(msg.value == businesses[_businessId].itemPrice);
563 
564         // We verifiy that the sender is the owner of the city
565         require(cities[_cityId].ownerAddress == msg.sender);
566 
567         // We check if this business is authorized to produce this building
568         require(_itemId == businesses[_businessId].itemToProduce);
569 
570         // We check if the city where the business is located as enough Metal in Stock
571         require(cities[businesses[_businessId].cityId].metalStock >= BuildingTypeMetalNeeded[_itemId]);
572 
573         // We check that the city has enough squares to host this new building
574         require((cities[_cityId].squaresOccupied + BuildingTypeSquaresOccupied[_itemId]) <= 100);
575 
576         // We check if the business is ready to produce another building
577         require(businesses[_businessId].readyTime < now);
578 
579         uint256 onePercent = msg.value / 100;
580 
581         // Send commission of the amount paid to land owner of where the business is located
582         uint _landId = cities[businesses[_businessId].cityId].landId;
583         address landOwner = lands[_landId].ownerAddress;
584         uint256 landOwnerCommission = onePercent * lands[cities[businesses[_businessId].cityId].landId].landOwnerCommission;
585         landOwner.transfer(landOwnerCommission);
586 
587         // Send the rest to the business owner
588         cities[businesses[_businessId].cityId].ownerAddress.transfer(msg.value - landOwnerCommission);
589 
590         // Reduce the metal stock of the city where the business is located
591         cities[businesses[_businessId].cityId].metalStock = cities[businesses[_businessId].cityId].metalStock - BuildingTypeMetalNeeded[_itemId];
592 
593         // Calculate production time
594         uint productionTime = getProductionTimeBusiness(_businessId);
595         uint32 _buildingReadyTime = uint32(now + productionTime);
596 
597         // Update production time for the business
598         businesses[_businessId].readyTime = uint32(now + productionTime);
599 
600         // Create the building
601         buildings.push(Building(_itemId, _cityId, _buildingReadyTime));
602 
603         // Increment the squares used in this land
604         cities[_cityId].squaresOccupied = cities[_cityId].squaresOccupied + BuildingTypeSquaresOccupied[_itemId];
605 
606         // Increment the GDP generated by this city
607         cities[_cityId].cityGdp = cities[_cityId].cityGdp + msg.value;
608 
609         // Increment the buildings count in this city
610         CityBuildingsCount[_cityId]++;
611 
612         // Save transaction in smart contract
613         transactions.push(Transaction(_cityId, businesses[_businessId].cityId, msg.value, _itemId, block.number));
614         CitySalesTransactionsCount[businesses[_businessId].cityId]++;
615     }
616 
617     // We use this function to let the land owner update its land
618     function updateLand(uint _landId, uint256 _landPrice, uint _typeUpdate, uint _commission) public {
619         require(lands[_landId].ownerAddress == msg.sender);
620 
621         /// Types update:
622         /// 0: Sell land
623         /// 1: Put the land for rent
624 
625         if(_typeUpdate == 0) {
626 
627             // Land is for sale
628             lands[_landId].landForSale = true;
629             lands[_landId].landForRent = false;
630             lands[_landId].landPrice = _landPrice;
631             
632         } else if(_typeUpdate == 1) {
633             // The owner can't change the commission if the land is occupied
634             require(lands[_landId].isOccupied == false);
635             
636             // Land is for rent
637             lands[_landId].landForRent = true;
638             lands[_landId].landForSale = false;
639             lands[_landId].landOwnerCommission = _commission;
640 
641         } else if(_typeUpdate == 2) {
642             // The owner cancel the sale of its land
643             lands[_landId].landForRent = false;
644             lands[_landId].landForSale = false;
645         }
646     }
647 
648     function purchaseLand(uint _landId, uint _typePurchase, uint _commission) public payable {
649         require(lands[_landId].landForSale == true);
650         require(msg.value == lands[_landId].landPrice);
651 
652         // Transfer the amount paid to the previous land owner
653         lands[_landId].ownerAddress.transfer(msg.value);
654 
655         // Update the land
656         lands[_landId].ownerAddress = msg.sender;
657         lands[_landId].landForSale = false;
658 
659         /// _typePurchase:
660         /// 0: Create city
661         /// 1: Rent the land
662         /// 2: Cancel sale
663         
664         if(_typePurchase == 0) {
665             // The user in purchasing the land to build the city on top of it we create the city directly
666             createCity(_landId);
667         } else if(_typePurchase == 1) {
668             // The user is purchasing the land to rent it to another user
669             lands[_landId].landForRent = true;
670             lands[_landId].landForSale = false;
671             lands[_landId].landOwnerCommission = _commission;
672         } 
673     }
674     
675     // We use this function to let users rent lands.
676     function rentLand(uint _landId, bool _createCity, uint _cityId) public {
677         // The owner can rent the land even if it's not marked forRent
678         if(lands[_landId].ownerAddress != msg.sender) {
679             require(lands[_landId].landForRent == true);
680         }
681 
682         // Cities can't rent a land if it's already occupied
683         require(lands[_landId].isOccupied == false);
684                     
685         if(_createCity == true) {
686             // We create the city if the user is renting this land for a new city
687             createCity(_landId);
688         } else {
689             // Cities can't rent a land if they are already landing one
690             require(cities[_cityId].landId == 0);
691         
692             // We update the land and city if the user is renting the land for an existing city
693             cities[_cityId].landId = _landId;
694             lands[_landId].cityRentingId = _cityId;
695             lands[_landId].landForSale == false;
696             lands[_landId].landForRent == true;
697             lands[_landId].isOccupied = true;
698         }
699     }
700 
701     function createCity(uint _landId) public {
702         require(lands[_landId].isOccupied == false);
703 
704         // Create the city
705         uint cityId = cities.push(City(_landId, msg.sender, 0, 0, false, 0, 0)) - 1;
706 
707         lands[_landId].landForSale == false;
708         lands[_landId].landForRent == false;
709         lands[_landId].cityRentingId = cityId;
710         lands[_landId].isOccupied = true;
711     }
712     
713     // The dev can use this function to create an innocupied land
714     function CreateLand(uint256 _landPrice, address _owner) public onlyCeo {
715         // We can't create more than 300 lands.
716         if(lands.length < 300) {
717             lands.push(Land(_owner, _landPrice, false, false, 0, false, 0));
718         }
719         
720     }
721     
722     function UpdateInitiateContractAddress(address _newAddress) public onlyCeo { 
723         InitiateLandsAddress = _newAddress;
724     }
725     
726     // We initialize some datas with this function
727     function Initialize() public onlyCeo {
728         // To be able to use the land id in the city struct
729         lands.push(Land(ceoAddress, 0, false, false, 5, true, 0)); // Fake Land #0 is created here
730 
731         // Save the amount of metal needed to produce the buildings
732         BuildingTypeMetalNeeded[0] = 3;
733         BuildingTypeMetalNeeded[1] = 4;
734         BuildingTypeMetalNeeded[2] = 5;
735         BuildingTypeMetalNeeded[3] = 4;
736 
737         // Save the squares used by buildings
738         BuildingTypeSquaresOccupied[0] = 2;
739         BuildingTypeSquaresOccupied[1] = 4;
740         BuildingTypeSquaresOccupied[2] = 6;
741         BuildingTypeSquaresOccupied[3] = 4;
742         BuildingTypeSquaresOccupied[4] = 5; // Businesses
743     }
744 }