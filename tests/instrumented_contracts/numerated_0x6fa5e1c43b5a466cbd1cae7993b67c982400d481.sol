1 {{
2   "language": "Solidity",
3   "sources": {
4     "contracts/COIN.sol": {
5       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport { SafeMath } from './libs/SafeMath.sol';\nimport { ERC20 } from './libs/ERC20.sol';\n\nimport { IUniswapV2Router02 } from './interfaces/IUniswapV2Router02.sol';\nimport { IUniswapV2Factory } from './interfaces/IUniswapV2Factory.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\n\ncontract COINBOT is ERC20 {\n  using SafeMath for uint256;\n\n  bool private swapping;\n  IUniswapV2Router02 public immutable uniswapV2Router;\n  address public immutable uniswapV2Pair;\n\n  address public revShareAddress;\n  address public teamAddress;\n\n  uint256 public maxTransactionAmount;\n  uint256 public swapTokensAtAmount;\n  uint256 public maxWallet;\n\n  bool public limitsInEffect = true;\n  bool public tradingActive = false;\n  bool public swapBackEnabled = false;\n\n  bool public banCapabilityRenounced = false;\n  mapping(address => bool) banned;\n\n  uint256 public tradingTotalFees;\n  uint256 public tradingRevShareFee;\n  uint256 public tradingLiquidityFee;\n  uint256 public tradingTeamFee;\n\n  uint256 public tokensForRevShare;\n  uint256 public tokensForLiquidity;\n  uint256 public tokensForTeam;\n\n  // exclude from fees and max transaction amount\n  mapping(address => bool) private _isExcludedFromFees;\n  mapping(address => bool) public _isExcludedMaxTransactionAmount;\n\n  // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n  // could be subject to a maximum transfer amount\n  mapping(address => bool) public aMMPairs;\n\n  event SetAMMPair(address indexed pair, bool indexed value);\n\n  event revShareAddressUpdated(address indexed newAddress, address indexed oldAddress);\n\n  event teamAddressUpdated(address indexed newAddress, address indexed oldAddress);\n\n  event SwapToLP(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\n\n  constructor(address uniswapRouter) ERC20('CoinBot', 'COINBT') {\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouter);\n\n    uniswapV2Router = _uniswapV2Router;\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\n      address(this),\n      _uniswapV2Router.WETH()\n    );\n\n    uint256 _tradingRevShareFee = 0;\n    uint256 _tradingLiquidityFee = 1;\n    uint256 _tradingTeamFee = 4;\n\n    uint256 totalSupply = 1_000_000 * 1e18;\n\n    maxTransactionAmount = 10_000 * 1e18; // 1%\n    maxWallet = 50_000 * 1e18; // 5%\n    swapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05%\n\n    tradingRevShareFee = _tradingRevShareFee;\n    tradingLiquidityFee = _tradingLiquidityFee;\n    tradingTeamFee = _tradingTeamFee;\n    tradingTotalFees = tradingRevShareFee + tradingLiquidityFee + tradingTeamFee;\n\n    revShareAddress = address(0x0185c185007a3099480a3D929944a805141C67CA);\n    teamAddress = owner(); // set as team wallet\n\n    _isExcludedMaxTransactionAmount[uniswapRouter] = true;\n    _isExcludedMaxTransactionAmount[uniswapV2Pair] = true;\n    _setAMMPair(address(uniswapV2Pair), true);\n    _excludeFromRules(owner());\n    _excludeFromRules(address(this));\n    _excludeFromRules(address(0xdead));\n\n    // _mint is an internal function in ERC20.sol that is only called here, once.\n    _mint(msg.sender, totalSupply);\n  }\n\n  receive() external payable {}\n\n  // once enabled, can never be turned off\n  function enableTrading() external onlyOwner {\n    tradingActive = true;\n    swapBackEnabled = true;\n  }\n\n  // remove limits after token is stable\n  function removeLimits() external onlyOwner returns (bool) {\n    limitsInEffect = false;\n    return true;\n  }\n\n  // target amount to trigger swap back\n  function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool) {\n    require(\n      newAmount >= (totalSupply() * 1) / 100000,\n      'Swap amount cannot be lower than 0.001% total supply.'\n    );\n\n    require(\n      newAmount <= (totalSupply() * 5) / 1000,\n      'Swap amount cannot be higher than 0.5% total supply.'\n    );\n\n    swapTokensAtAmount = newAmount;\n    return true;\n  }\n\n  function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\n    require(\n      newNum >= ((totalSupply() * 5) / 1000) / 1e18,\n      'Cannot set maxTransactionAmount lower than 0.5%'\n    );\n    maxTransactionAmount = newNum * (10 ** 18);\n  }\n\n  function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\n    require(newNum >= ((totalSupply() * 10) / 1000) / 1e18, 'Cannot set maxWallet lower than 1.0%');\n    maxWallet = newNum * (10 ** 18);\n  }\n  \n  // devs are initially excluded from fees\n  // once we are ready to remove limits, we should have the vault created first\n  // then we can turn off the limits and renounce the privilege granting capability\n  function excludeFromFees(address _address, bool value) external onlyOwner {\n    require(limitsInEffect, 'Cannot grant privileges after limits have been removed.');\n    _isExcludedFromFees[_address] = value;\n  }\n\n  // should only be used to add a staking vault, before limits are removed\n  function excludeFromRules(address _address) external onlyOwner {\n    require(limitsInEffect, 'Cannot grant privileges after limits have been removed.');\n    _excludeFromRules(_address);\n  }\n\n  // called in relevant methods, including constructor\n  function _excludeFromRules(address _address) internal {\n    _isExcludedFromFees[_address] = true;\n    _isExcludedMaxTransactionAmount[_address] = true;\n  }\n\n  function updateTradingFees(\n    uint256 _revShareFee,\n    uint256 _liquidityFee,\n    uint256 _teamFee\n  ) external onlyOwner {\n    tradingRevShareFee = _revShareFee;\n    tradingLiquidityFee = _liquidityFee;\n    tradingTeamFee = _teamFee;\n    tradingTotalFees = tradingRevShareFee + tradingLiquidityFee + tradingTeamFee;\n\n    require(tradingTeamFee <= tradingRevShareFee, 'teamFee cannot be greater than revShareFee.');\n    require(tradingTotalFees <= 5, 'Buy fees must be <= 5.');\n  }\n\n  function setAMMPair(address pair, bool value) external onlyOwner {\n    require(pair != uniswapV2Pair, 'The pair cannot be removed from aMMPairs');\n    _setAMMPair(pair, value);\n  }\n\n  function _setAMMPair(address pair, bool value) private {\n    aMMPairs[pair] = value;\n    _isExcludedMaxTransactionAmount[pair] = value;\n    emit SetAMMPair(pair, value);\n  }\n\n  function updateRevShareAddress(address newRevShareAddress) external onlyOwner {\n    emit revShareAddressUpdated(newRevShareAddress, revShareAddress);\n    _excludeFromRules(newRevShareAddress);\n    revShareAddress = newRevShareAddress;\n  }\n\n  function updateTeamAddress(address newAddress) external onlyOwner {\n    emit teamAddressUpdated(newAddress, teamAddress);\n    _excludeFromRules(newAddress);\n    teamAddress = newAddress;\n  }\n\n  function _transfer(address from, address to, uint256 amount) internal override {\n    require(from != address(0), 'ERC20: transfer from the zero address');\n    require(to != address(0), 'ERC20: transfer to the zero address');\n    require(!banned[from], 'Sender banned');\n    require(!banned[to], 'Receiver banned');\n\n    if (amount == 0) {\n      super._transfer(from, to, 0);\n      return;\n    }\n\n    if (limitsInEffect) {\n      if (\n        from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !swapping\n      ) {\n        if (!tradingActive) {\n          require(_isExcludedFromFees[from] || _isExcludedFromFees[to], 'Trading is not active.');\n        }\n\n        // when buy\n        if (aMMPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n          require(\n            amount <= maxTransactionAmount,\n            'Buy transfer amount exceeds the maxTransactionAmount.'\n          );\n          require(amount + balanceOf(to) <= maxWallet, 'Max wallet exceeded');\n        }\n        // when sell\n        else if (aMMPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n          require(\n            amount <= maxTransactionAmount,\n            'Sell transfer amount exceeds the maxTransactionAmount.'\n          );\n        } else if (!_isExcludedMaxTransactionAmount[to]) {\n          require(amount + balanceOf(to) <= maxWallet, 'Max wallet exceeded');\n        }\n      }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n    if (\n      canSwap &&\n      swapBackEnabled &&\n      !swapping &&\n      !aMMPairs[from] &&\n      !_isExcludedFromFees[from] &&\n      !_isExcludedFromFees[to]\n    ) {\n      swapping = true;\n\n      swapBack();\n\n      swapping = false;\n    }\n\n    bool takeFee = !swapping;\n\n    // if any account belongs to _isExcludedFromFee account then remove the fee\n    if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n      takeFee = false;\n    }\n\n    uint256 fees = 0;\n    // only take fees on trading, do not take on wallet transfers\n    if (takeFee) {\n      // trading fees\n      if ((aMMPairs[to] || aMMPairs[from]) && tradingTotalFees > 0) {\n        fees = amount.mul(tradingTotalFees).div(100);\n        tokensForLiquidity += (fees * tradingLiquidityFee) / tradingTotalFees;\n        tokensForTeam += (fees * tradingTeamFee) / tradingTotalFees;\n        tokensForRevShare += (fees * tradingRevShareFee) / tradingTotalFees;\n      }\n\n      if (fees > 0) {\n        super._transfer(from, address(this), fees);\n      }\n\n      amount -= fees;\n    }\n\n    super._transfer(from, to, amount);\n  }\n\n  function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      tokenAmount,\n      0, // safe because the token swap fees make most MEV unprofitable\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    // approve token transfer to cover all possible scenarios\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n    // add the liquidity\n    uniswapV2Router.addLiquidityETH{ value: ethAmount }(\n      address(this),\n      tokenAmount,\n      0, // slippage is unavoidable\n      0, // slippage is unavoidable\n      owner(),\n      block.timestamp\n    );\n  }\n\n  function swapBack() private {\n    uint256 contractBalance = balanceOf(address(this));\n    uint256 totalTokensToSwap = tokensForLiquidity + tokensForRevShare + tokensForTeam;\n    bool success;\n\n    if (contractBalance == 0 || totalTokensToSwap == 0) {\n      return;\n    }\n\n    if (contractBalance > swapTokensAtAmount * 20) {\n      contractBalance = swapTokensAtAmount * 20;\n    }\n\n    // Halve the amount of liquidity tokens\n    uint256 liquidityTokens = (contractBalance * tokensForLiquidity) / totalTokensToSwap / 2;\n    uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\n\n    uint256 initialETHBalance = address(this).balance;\n\n    swapTokensForEth(amountToSwapForETH);\n\n    uint256 ethBalance = address(this).balance.sub(initialETHBalance);\n\n    uint256 ethForRevShare = ethBalance.mul(tokensForRevShare).div(\n      totalTokensToSwap - (tokensForLiquidity / 2)\n    );\n\n    uint256 ethForTeam = ethBalance.mul(tokensForTeam).div(\n      totalTokensToSwap - (tokensForLiquidity / 2)\n    );\n\n    uint256 ethForLiquidity = ethBalance - ethForRevShare - ethForTeam;\n\n    tokensForLiquidity = 0;\n    tokensForRevShare = 0;\n    tokensForTeam = 0;\n\n    (success, ) = address(teamAddress).call{ value: ethForTeam }('');\n\n    if (liquidityTokens > 0 && ethForLiquidity > 0) {\n      addLiquidity(liquidityTokens, ethForLiquidity);\n      emit SwapToLP(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\n    }\n\n    (success, ) = address(revShareAddress).call{ value: address(this).balance }('');\n  }\n\n  // --- emergency withdraw\n  function withdrawStuckToken(address _token) external onlyOwner {\n    require(_token != address(0), '_token address cannot be 0');\n    uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\n    IERC20(_token).transfer(teamAddress, _contractBalance);\n  }\n\n// --- emergency withdraw\n  function withdrawStuckEth() external onlyOwner {\n    (bool success, ) = teamAddress.call{ value: address(this).balance }('');\n    require(success, 'Failed to withdraw ETH');\n  }\n\n  function isBanned(address account) external view returns (bool) {\n    return banned[account];\n  }\n\n  function renounceBanCapability() external onlyOwner {\n    banCapabilityRenounced = true;\n  }\n\n  // --- banning methods to prevent abuses and bots\n  function ban(address _address) external onlyOwner {\n    require(!banCapabilityRenounced, 'Team has revoked ban rights');\n    require(\n      _address != address(uniswapV2Pair) &&\n        _address != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), // UniV2 router\n      'Cannot ban Uniswap'\n    );\n\n    banned[_address] = true;\n  }\n\n  function unban(address _addr) external onlyOwner {\n    banned[_addr] = false;\n  }\n}\n"
6     },
7     "contracts/interfaces/IERC20.sol": {
8       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
9     },
10     "contracts/interfaces/IUniswapV2Factory.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IUniswapV2Factory {\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n}\n"
12     },
13     "contracts/interfaces/IUniswapV2Router02.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
15     },
16     "contracts/libs/Context.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
18     },
19     "contracts/libs/ERC20.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport { Ownable } from '../libs/Owners.sol';\n\nimport { SafeMath } from '../libs/SafeMath.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\n\ncontract ERC20 is Ownable, IERC20 {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  constructor(string memory __name, string memory __symbol) {\n    _name = __name;\n    _symbol = __symbol;\n  }\n\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n    return true;\n  }\n\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\n    unchecked {\n      _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\n    unchecked {\n      _balances[sender] = senderBalance - amount;\n    }\n    _balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n\n    _afterTokenTransfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: mint to the zero address');\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), 'ERC20: burn from the zero address');\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), 'ERC20: approve from the zero address');\n    require(spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
21     },
22     "contracts/libs/Owners.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport { Context } from './Context.sol';\n\nabstract contract Ownable is Context {\n  address private _owner;\n\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\n    _transferOwnership(newOwner);\n  }\n\n  function _transferOwnership(address newOwner) internal virtual {\n    _owner = newOwner;\n  }\n}\n"
24     },
25     "contracts/libs/SafeMath.sol": {
26       "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
27     }
28   },
29   "settings": {
30     "optimizer": {
31       "enabled": true,
32       "runs": 2000,
33       "details": {
34         "yul": true
35       }
36     },
37     "outputSelection": {
38       "*": {
39         "*": [
40           "evm.bytecode",
41           "evm.deployedBytecode",
42           "devdoc",
43           "userdoc",
44           "metadata",
45           "abi"
46         ]
47       }
48     },
49     "libraries": {}
50   }
51 }}