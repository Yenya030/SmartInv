1 /*
2  * This file was generated by MyWish Platform (https://mywish.io/)
3  * The complete code could be found at https://github.com/MyWishPlatform/
4  * Copyright (C) 2018 MyWish
5  *
6  * This program is free software: you can redistribute it and/or modify
7  * it under the terms of the GNU Lesser General Public License as published by
8  * the Free Software Foundation, either version 3 of the License, or
9  * (at your option) any later version.
10  *
11  * This program is distributed in the hope that it will be useful,
12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
14  * GNU Lesser General Public License for more details.
15  *
16  * You should have received a copy of the GNU Lesser General Public License
17  * along with this program. If not, see <http://www.gnu.org/licenses/>.
18  */
19 pragma solidity ^0.4.23;
20 
21 
22 /**
23  * @title ERC20Basic
24  * @dev Simpler version of ERC20 interface
25  * @dev see https://github.com/ethereum/EIPs/issues/179
26  */
27 contract ERC20Basic {
28   function totalSupply() public view returns (uint256);
29   function balanceOf(address who) public view returns (uint256);
30   function transfer(address to, uint256 value) public returns (bool);
31   event Transfer(address indexed from, address indexed to, uint256 value);
32 }
33 
34 
35 
36 /**
37  * @title SafeMath
38  * @dev Math operations with safety checks that throw on error
39  */
40 library SafeMath {
41 
42   /**
43   * @dev Multiplies two numbers, throws on overflow.
44   */
45   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {
46     // Gas optimization: this is cheaper than asserting 'a' not being zero, but the
47     // benefit is lost if 'b' is also tested.
48     // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
49     if (a == 0) {
50       return 0;
51     }
52 
53     c = a * b;
54     assert(c / a == b);
55     return c;
56   }
57 
58   /**
59   * @dev Integer division of two numbers, truncating the quotient.
60   */
61   function div(uint256 a, uint256 b) internal pure returns (uint256) {
62     // assert(b > 0); // Solidity automatically throws when dividing by 0
63     // uint256 c = a / b;
64     // assert(a == b * c + a % b); // There is no case in which this doesn't hold
65     return a / b;
66   }
67 
68   /**
69   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
70   */
71   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
72     assert(b <= a);
73     return a - b;
74   }
75 
76   /**
77   * @dev Adds two numbers, throws on overflow.
78   */
79   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
80     c = a + b;
81     assert(c >= a);
82     return c;
83   }
84 }
85 
86 
87 
88 /**
89  * @title Basic token
90  * @dev Basic version of StandardToken, with no allowances.
91  */
92 contract BasicToken is ERC20Basic {
93   using SafeMath for uint256;
94 
95   mapping(address => uint256) balances;
96 
97   uint256 totalSupply_;
98 
99   /**
100   * @dev total number of tokens in existence
101   */
102   function totalSupply() public view returns (uint256) {
103     return totalSupply_;
104   }
105 
106   /**
107   * @dev transfer token for a specified address
108   * @param _to The address to transfer to.
109   * @param _value The amount to be transferred.
110   */
111   function transfer(address _to, uint256 _value) public returns (bool) {
112     require(_to != address(0));
113     require(_value <= balances[msg.sender]);
114 
115     balances[msg.sender] = balances[msg.sender].sub(_value);
116     balances[_to] = balances[_to].add(_value);
117     emit Transfer(msg.sender, _to, _value);
118     return true;
119   }
120 
121   /**
122   * @dev Gets the balance of the specified address.
123   * @param _owner The address to query the the balance of.
124   * @return An uint256 representing the amount owned by the passed address.
125   */
126   function balanceOf(address _owner) public view returns (uint256) {
127     return balances[_owner];
128   }
129 
130 }
131 
132 
133 /**
134  * @title ERC20 interface
135  * @dev see https://github.com/ethereum/EIPs/issues/20
136  */
137 contract ERC20 is ERC20Basic {
138   function allowance(address owner, address spender)
139     public view returns (uint256);
140 
141   function transferFrom(address from, address to, uint256 value)
142     public returns (bool);
143 
144   function approve(address spender, uint256 value) public returns (bool);
145   event Approval(
146     address indexed owner,
147     address indexed spender,
148     uint256 value
149   );
150 }
151 
152 
153 /**
154  * @title Standard ERC20 token
155  *
156  * @dev Implementation of the basic standard token.
157  * @dev https://github.com/ethereum/EIPs/issues/20
158  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol
159  */
160 contract StandardToken is ERC20, BasicToken {
161 
162   mapping (address => mapping (address => uint256)) internal allowed;
163 
164 
165   /**
166    * @dev Transfer tokens from one address to another
167    * @param _from address The address which you want to send tokens from
168    * @param _to address The address which you want to transfer to
169    * @param _value uint256 the amount of tokens to be transferred
170    */
171   function transferFrom(
172     address _from,
173     address _to,
174     uint256 _value
175   )
176     public
177     returns (bool)
178   {
179     require(_to != address(0));
180     require(_value <= balances[_from]);
181     require(_value <= allowed[_from][msg.sender]);
182 
183     balances[_from] = balances[_from].sub(_value);
184     balances[_to] = balances[_to].add(_value);
185     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
186     emit Transfer(_from, _to, _value);
187     return true;
188   }
189 
190   /**
191    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
192    *
193    * Beware that changing an allowance with this method brings the risk that someone may use both the old
194    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
195    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
196    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
197    * @param _spender The address which will spend the funds.
198    * @param _value The amount of tokens to be spent.
199    */
200   function approve(address _spender, uint256 _value) public returns (bool) {
201     allowed[msg.sender][_spender] = _value;
202     emit Approval(msg.sender, _spender, _value);
203     return true;
204   }
205 
206   /**
207    * @dev Function to check the amount of tokens that an owner allowed to a spender.
208    * @param _owner address The address which owns the funds.
209    * @param _spender address The address which will spend the funds.
210    * @return A uint256 specifying the amount of tokens still available for the spender.
211    */
212   function allowance(
213     address _owner,
214     address _spender
215    )
216     public
217     view
218     returns (uint256)
219   {
220     return allowed[_owner][_spender];
221   }
222 
223   /**
224    * @dev Increase the amount of tokens that an owner allowed to a spender.
225    *
226    * approve should be called when allowed[_spender] == 0. To increment
227    * allowed value is better to use this function to avoid 2 calls (and wait until
228    * the first transaction is mined)
229    * From MonolithDAO Token.sol
230    * @param _spender The address which will spend the funds.
231    * @param _addedValue The amount of tokens to increase the allowance by.
232    */
233   function increaseApproval(
234     address _spender,
235     uint _addedValue
236   )
237     public
238     returns (bool)
239   {
240     allowed[msg.sender][_spender] = (
241       allowed[msg.sender][_spender].add(_addedValue));
242     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
243     return true;
244   }
245 
246   /**
247    * @dev Decrease the amount of tokens that an owner allowed to a spender.
248    *
249    * approve should be called when allowed[_spender] == 0. To decrement
250    * allowed value is better to use this function to avoid 2 calls (and wait until
251    * the first transaction is mined)
252    * From MonolithDAO Token.sol
253    * @param _spender The address which will spend the funds.
254    * @param _subtractedValue The amount of tokens to decrease the allowance by.
255    */
256   function decreaseApproval(
257     address _spender,
258     uint _subtractedValue
259   )
260     public
261     returns (bool)
262   {
263     uint oldValue = allowed[msg.sender][_spender];
264     if (_subtractedValue > oldValue) {
265       allowed[msg.sender][_spender] = 0;
266     } else {
267       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
268     }
269     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
270     return true;
271   }
272 
273 }
274 
275 
276 
277 /**
278  * @title Ownable
279  * @dev The Ownable contract has an owner address, and provides basic authorization control
280  * functions, this simplifies the implementation of "user permissions".
281  */
282 contract Ownable {
283   address public owner;
284 
285 
286   event OwnershipRenounced(address indexed previousOwner);
287   event OwnershipTransferred(
288     address indexed previousOwner,
289     address indexed newOwner
290   );
291 
292 
293   /**
294    * @dev The Ownable constructor sets the original `owner` of the contract to the sender
295    * account.
296    */
297   constructor() public {
298     owner = msg.sender;
299   }
300 
301   /**
302    * @dev Throws if called by any account other than the owner.
303    */
304   modifier onlyOwner() {
305     require(msg.sender == owner);
306     _;
307   }
308 
309   /**
310    * @dev Allows the current owner to relinquish control of the contract.
311    */
312   function renounceOwnership() public onlyOwner {
313     emit OwnershipRenounced(owner);
314     owner = address(0);
315   }
316 
317   /**
318    * @dev Allows the current owner to transfer control of the contract to a newOwner.
319    * @param _newOwner The address to transfer ownership to.
320    */
321   function transferOwnership(address _newOwner) public onlyOwner {
322     _transferOwnership(_newOwner);
323   }
324 
325   /**
326    * @dev Transfers control of the contract to a newOwner.
327    * @param _newOwner The address to transfer ownership to.
328    */
329   function _transferOwnership(address _newOwner) internal {
330     require(_newOwner != address(0));
331     emit OwnershipTransferred(owner, _newOwner);
332     owner = _newOwner;
333   }
334 }
335 
336 
337 /**
338  * @title Mintable token
339  * @dev Simple ERC20 Token example, with mintable token creation
340  * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120
341  * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol
342  */
343 contract MintableToken is StandardToken, Ownable {
344   event Mint(address indexed to, uint256 amount);
345   event MintFinished();
346 
347   bool public mintingFinished = false;
348 
349 
350   modifier canMint() {
351     require(!mintingFinished);
352     _;
353   }
354 
355   modifier hasMintPermission() {
356     require(msg.sender == owner);
357     _;
358   }
359 
360   /**
361    * @dev Function to mint tokens
362    * @param _to The address that will receive the minted tokens.
363    * @param _amount The amount of tokens to mint.
364    * @return A boolean that indicates if the operation was successful.
365    */
366   function mint(
367     address _to,
368     uint256 _amount
369   )
370     hasMintPermission
371     canMint
372     public
373     returns (bool)
374   {
375     totalSupply_ = totalSupply_.add(_amount);
376     balances[_to] = balances[_to].add(_amount);
377     emit Mint(_to, _amount);
378     emit Transfer(address(0), _to, _amount);
379     return true;
380   }
381 
382   /**
383    * @dev Function to stop minting new tokens.
384    * @return True if the operation was successful.
385    */
386   function finishMinting() onlyOwner canMint public returns (bool) {
387     mintingFinished = true;
388     emit MintFinished();
389     return true;
390   }
391 }
392 
393 
394 contract FreezableToken is StandardToken {
395     // freezing chains
396     mapping (bytes32 => uint64) internal chains;
397     // freezing amounts for each chain
398     mapping (bytes32 => uint) internal freezings;
399     // total freezing balance per address
400     mapping (address => uint) internal freezingBalance;
401 
402     event Freezed(address indexed to, uint64 release, uint amount);
403     event Released(address indexed owner, uint amount);
404 
405     /**
406      * @dev Gets the balance of the specified address include freezing tokens.
407      * @param _owner The address to query the the balance of.
408      * @return An uint256 representing the amount owned by the passed address.
409      */
410     function balanceOf(address _owner) public view returns (uint256 balance) {
411         return super.balanceOf(_owner) + freezingBalance[_owner];
412     }
413 
414     /**
415      * @dev Gets the balance of the specified address without freezing tokens.
416      * @param _owner The address to query the the balance of.
417      * @return An uint256 representing the amount owned by the passed address.
418      */
419     function actualBalanceOf(address _owner) public view returns (uint256 balance) {
420         return super.balanceOf(_owner);
421     }
422 
423     function freezingBalanceOf(address _owner) public view returns (uint256 balance) {
424         return freezingBalance[_owner];
425     }
426 
427     /**
428      * @dev gets freezing count
429      * @param _addr Address of freeze tokens owner.
430      */
431     function freezingCount(address _addr) public view returns (uint count) {
432         uint64 release = chains[toKey(_addr, 0)];
433         while (release != 0) {
434             count++;
435             release = chains[toKey(_addr, release)];
436         }
437     }
438 
439     /**
440      * @dev gets freezing end date and freezing balance for the freezing portion specified by index.
441      * @param _addr Address of freeze tokens owner.
442      * @param _index Freezing portion index. It ordered by release date descending.
443      */
444     function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {
445         for (uint i = 0; i < _index + 1; i++) {
446             _release = chains[toKey(_addr, _release)];
447             if (_release == 0) {
448                 return;
449             }
450         }
451         _balance = freezings[toKey(_addr, _release)];
452     }
453 
454     /**
455      * @dev freeze your tokens to the specified address.
456      *      Be careful, gas usage is not deterministic,
457      *      and depends on how many freezes _to address already has.
458      * @param _to Address to which token will be freeze.
459      * @param _amount Amount of token to freeze.
460      * @param _until Release date, must be in future.
461      */
462     function freezeTo(address _to, uint _amount, uint64 _until) public {
463         require(_to != address(0));
464         require(_amount <= balances[msg.sender]);
465 
466         balances[msg.sender] = balances[msg.sender].sub(_amount);
467 
468         bytes32 currentKey = toKey(_to, _until);
469         freezings[currentKey] = freezings[currentKey].add(_amount);
470         freezingBalance[_to] = freezingBalance[_to].add(_amount);
471 
472         freeze(_to, _until);
473         emit Transfer(msg.sender, _to, _amount);
474         emit Freezed(_to, _until, _amount);
475     }
476 
477     /**
478      * @dev release first available freezing tokens.
479      */
480     function releaseOnce() public {
481         bytes32 headKey = toKey(msg.sender, 0);
482         uint64 head = chains[headKey];
483         require(head != 0);
484         require(uint64(block.timestamp) > head);
485         bytes32 currentKey = toKey(msg.sender, head);
486 
487         uint64 next = chains[currentKey];
488 
489         uint amount = freezings[currentKey];
490         delete freezings[currentKey];
491 
492         balances[msg.sender] = balances[msg.sender].add(amount);
493         freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);
494 
495         if (next == 0) {
496             delete chains[headKey];
497         } else {
498             chains[headKey] = next;
499             delete chains[currentKey];
500         }
501         emit Released(msg.sender, amount);
502     }
503 
504     /**
505      * @dev release all available for release freezing tokens. Gas usage is not deterministic!
506      * @return how many tokens was released
507      */
508     function releaseAll() public returns (uint tokens) {
509         uint release;
510         uint balance;
511         (release, balance) = getFreezing(msg.sender, 0);
512         while (release != 0 && block.timestamp > release) {
513             releaseOnce();
514             tokens += balance;
515             (release, balance) = getFreezing(msg.sender, 0);
516         }
517     }
518 
519     function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {
520         // WISH masc to increase entropy
521         result = 0x5749534800000000000000000000000000000000000000000000000000000000;
522         assembly {
523             result := or(result, mul(_addr, 0x10000000000000000))
524             result := or(result, _release)
525         }
526     }
527 
528     function freeze(address _to, uint64 _until) internal {
529         require(_until > block.timestamp);
530         bytes32 key = toKey(_to, _until);
531         bytes32 parentKey = toKey(_to, uint64(0));
532         uint64 next = chains[parentKey];
533 
534         if (next == 0) {
535             chains[parentKey] = _until;
536             return;
537         }
538 
539         bytes32 nextKey = toKey(_to, next);
540         uint parent;
541 
542         while (next != 0 && _until > next) {
543             parent = next;
544             parentKey = nextKey;
545 
546             next = chains[nextKey];
547             nextKey = toKey(_to, next);
548         }
549 
550         if (_until == next) {
551             return;
552         }
553 
554         if (next != 0) {
555             chains[key] = next;
556         }
557 
558         chains[parentKey] = _until;
559     }
560 }
561 
562 
563 /**
564  * @title Burnable Token
565  * @dev Token that can be irreversibly burned (destroyed).
566  */
567 contract BurnableToken is BasicToken {
568 
569   event Burn(address indexed burner, uint256 value);
570 
571   /**
572    * @dev Burns a specific amount of tokens.
573    * @param _value The amount of token to be burned.
574    */
575   function burn(uint256 _value) public {
576     _burn(msg.sender, _value);
577   }
578 
579   function _burn(address _who, uint256 _value) internal {
580     require(_value <= balances[_who]);
581     // no need to require value <= totalSupply, since that would imply the
582     // sender's balance is greater than the totalSupply, which *should* be an assertion failure
583 
584     balances[_who] = balances[_who].sub(_value);
585     totalSupply_ = totalSupply_.sub(_value);
586     emit Burn(_who, _value);
587     emit Transfer(_who, address(0), _value);
588   }
589 }
590 
591 
592 
593 /**
594  * @title Pausable
595  * @dev Base contract which allows children to implement an emergency stop mechanism.
596  */
597 contract Pausable is Ownable {
598   event Pause();
599   event Unpause();
600 
601   bool public paused = false;
602 
603 
604   /**
605    * @dev Modifier to make a function callable only when the contract is not paused.
606    */
607   modifier whenNotPaused() {
608     require(!paused);
609     _;
610   }
611 
612   /**
613    * @dev Modifier to make a function callable only when the contract is paused.
614    */
615   modifier whenPaused() {
616     require(paused);
617     _;
618   }
619 
620   /**
621    * @dev called by the owner to pause, triggers stopped state
622    */
623   function pause() onlyOwner whenNotPaused public {
624     paused = true;
625     emit Pause();
626   }
627 
628   /**
629    * @dev called by the owner to unpause, returns to normal state
630    */
631   function unpause() onlyOwner whenPaused public {
632     paused = false;
633     emit Unpause();
634   }
635 }
636 
637 
638 contract FreezableMintableToken is FreezableToken, MintableToken {
639     /**
640      * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.
641      *      Be careful, gas usage is not deterministic,
642      *      and depends on how many freezes _to address already has.
643      * @param _to Address to which token will be freeze.
644      * @param _amount Amount of token to mint and freeze.
645      * @param _until Release date, must be in future.
646      * @return A boolean that indicates if the operation was successful.
647      */
648     function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {
649         totalSupply_ = totalSupply_.add(_amount);
650 
651         bytes32 currentKey = toKey(_to, _until);
652         freezings[currentKey] = freezings[currentKey].add(_amount);
653         freezingBalance[_to] = freezingBalance[_to].add(_amount);
654 
655         freeze(_to, _until);
656         emit Mint(_to, _amount);
657         emit Freezed(_to, _until, _amount);
658         emit Transfer(msg.sender, _to, _amount);
659         return true;
660     }
661 }
662 
663 
664 
665 contract Consts {
666     uint public constant TOKEN_DECIMALS = 18;
667     uint8 public constant TOKEN_DECIMALS_UINT8 = 18;
668     uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;
669 
670     string public constant TOKEN_NAME = "OREToken";
671     string public constant TOKEN_SYMBOL = "ORET";
672     bool public constant PAUSED = false;
673     address public constant TARGET_USER = 0xdb0bb4b165bCC6a5b308E10F1388f87c3385d71a;
674     
675     uint public constant START_TIME = 1540958439;
676     
677     bool public constant CONTINUE_MINTING = false;
678 }
679 
680 
681 
682 
683 contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable
684     
685 {
686     
687 
688     function name() public pure returns (string _name) {
689         return TOKEN_NAME;
690     }
691 
692     function symbol() public pure returns (string _symbol) {
693         return TOKEN_SYMBOL;
694     }
695 
696     function decimals() public pure returns (uint8 _decimals) {
697         return TOKEN_DECIMALS_UINT8;
698     }
699 
700     function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {
701         require(!paused);
702         return super.transferFrom(_from, _to, _value);
703     }
704 
705     function transfer(address _to, uint256 _value) public returns (bool _success) {
706         require(!paused);
707         return super.transfer(_to, _value);
708     }
709 
710     
711 }