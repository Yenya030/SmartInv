1 {{
2   "language": "Solidity",
3   "sources": {
4     "@openzeppelin/contracts/access/Ownable.sol": {
5       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
6     },
7     "@openzeppelin/contracts/utils/Context.sol": {
8       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
9     },
10     "contracts/interfaces/IMetro.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n//                        888\n//                        888\n//                        888\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\n// 888 \"888 \"88b d8P  Y8b 888    888P\"  d88\"\"88b\n// 888  888  888 88888888 888    888    888  888\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\n// 888  888  888  \"Y8888   \"Y888 888     \"Y88P\"\n\n// 888                    d8b          888                          888\n// 888                    Y8P          888                          888\n// 888                                 888                          888\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\n// 888 \"88b 888  888      888 888 \"88b 888             \"88b 888P\"   888\n// 888  888 888  888      888 888  888 888         .d888888 888     888\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\n// 88888P\"   \"Y88888      888 888  888  \"Y888      \"Y888888 888      \"Y888\n//               888\n//          Y8b d88P\n//           \"Y88P\"\n\nstruct MetroTokenProperties {\n    uint256 mode; // 0: Curate, 1: Evolve, 2: Lock\n    uint256 progress;\n    uint256 maxProgress;\n    uint256 progressSeedStep;\n    uint256 curateCount;\n    bytes32 seed;\n    bytes32[] progressSeeds;\n}\n\ninterface IMetro {\n    function mint(address target, uint256 count) external;\n    function getTokenProperties(uint256 tokenId)\n        external\n        view\n        returns (MetroTokenProperties memory);\n}\n"
12     },
13     "contracts/interfaces/IMetroMinter.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n//                        888\n//                        888\n//                        888\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\n// 888 \"888 \"88b d8P  Y8b 888    888P\"  d88\"\"88b\n// 888  888  888 88888888 888    888    888  888\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\n// 888  888  888  \"Y8888   \"Y888 888     \"Y88P\"\n\n// 888                    d8b          888                          888\n// 888                    Y8P          888                          888\n// 888                                 888                          888\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\n// 888 \"88b 888  888      888 888 \"88b 888             \"88b 888P\"   888\n// 888  888 888  888      888 888  888 888         .d888888 888     888\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\n// 88888P\"   \"Y88888      888 888  888  \"Y888      \"Y888888 888      \"Y888\n//               888\n//          Y8b d88P\n//           \"Y88P\"\n\ninterface IMetroMinter {\n    function usedTheDudesTokenIds(uint256 tokenId) external view returns (bool);\n\n    function mintCountForPixelsIncAddresses(\n        address _address\n    ) external view returns (uint256);\n\n    function mintCountForCollabAddresses(\n        address _address\n    ) external view returns (uint256);\n}\n"
15     },
16     "contracts/MetroMinterV3.sol": {
17       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n//                        888\n//                        888\n//                        888\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\n// 888 \"888 \"88b d8P  Y8b 888    888P\"  d88\"\"88b\n// 888  888  888 88888888 888    888    888  888\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\n// 888  888  888  \"Y8888   \"Y888 888     \"Y88P\"\n\n// 888                    d8b          888                          888\n// 888                    Y8P          888                          888\n// 888                                 888                          888\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\n// 888 \"88b 888  888      888 888 \"88b 888             \"88b 888P\"   888\n// 888  888 888  888      888 888  888 888         .d888888 888     888\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\n// 88888P\"   \"Y88888      888 888  888  \"Y888      \"Y888888 888      \"Y888\n//               888\n//          Y8b d88P\n//           \"Y88P\"\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {MerkleProofLib} from \"solmate/src/utils/MerkleProofLib.sol\";\nimport {IMetroMinter} from \"./interfaces/IMetroMinter.sol\";\n\nimport {IMetro} from \"./interfaces/IMetro.sol\";\n\ncontract MetroMinterV3 is Ownable {\n    IMetro public immutable metro;\n\n    bool public isPublicMintOpen;\n    mapping(address => bool) public addressesForPublicMint;\n    bytes32 public publicMerkleProof;\n\n    error MintNotOpen();\n    error AlreadyMinted();\n    error InvalidProof();\n    error InvalidAmount();\n\n    constructor(address metroAddress) {\n        metro = IMetro(metroAddress);\n    }\n\n    // - owner operations\n\n    function setIsPublicMintOpen(bool _isPublicMintOpen) public onlyOwner {\n        isPublicMintOpen = _isPublicMintOpen;\n    }\n\n    function updatePublicMerkleProof(\n        bytes32 _publicMerkleProof\n    ) public onlyOwner {\n        publicMerkleProof = _publicMerkleProof;\n    }\n\n    // - public mint\n\n    function canMint(\n        address _address,\n        uint256 quantity,\n        bytes32[] calldata merkleProof\n    ) public view returns (bool) {\n        bytes32 node = keccak256(abi.encodePacked(_address, quantity));\n        if (!MerkleProofLib.verify(merkleProof, publicMerkleProof, node)) {\n            return false;\n        }\n        if (addressesForPublicMint[_address]) {\n            return false;\n        }\n        return true;\n    }\n\n    function publicMint(\n        uint256 quantity,\n        bytes32[] calldata merkleProof\n    ) public {\n        if (!isPublicMintOpen) {\n            revert MintNotOpen();\n        }\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, quantity));\n        if (!MerkleProofLib.verify(merkleProof, publicMerkleProof, node)) {\n            revert InvalidProof();\n        }\n        if (addressesForPublicMint[msg.sender]) {\n            revert AlreadyMinted();\n        }\n        addressesForPublicMint[msg.sender] = true;\n        metro.mint(msg.sender, quantity);\n    }\n}\n"
18     },
19     "solmate/src/utils/MerkleProofLib.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"
21     }
22   },
23   "settings": {
24     "optimizer": {
25       "enabled": true,
26       "runs": 1000,
27       "details": {
28         "yul": false
29       }
30     },
31     "outputSelection": {
32       "*": {
33         "*": [
34           "evm.bytecode",
35           "evm.deployedBytecode",
36           "devdoc",
37           "userdoc",
38           "metadata",
39           "abi"
40         ]
41       }
42     },
43     "libraries": {}
44   }
45 }}