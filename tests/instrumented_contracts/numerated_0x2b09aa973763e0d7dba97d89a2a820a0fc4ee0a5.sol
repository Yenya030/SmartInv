1 {{
2   "language": "Solidity",
3   "sources": {
4     "src/Shuffle.sol": {
5       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\nimport { IShuffle } from \"./interfaces/IShuffle.sol\";\nimport { Ownable } from \"solady/auth/Ownable.sol\";\nimport { SSTORE2 } from \"solady/utils/SSTORE2.sol\";\nimport { IERC721A } from \"erc721a/contracts/IERC721A.sol\";\nimport { VRFCoordinatorV2Interface } from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport { VRFConsumerBaseV2 } from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ninterface IShards {\n    function burn(address account, uint256 id, uint256 amount) external;\n}\n\ncontract Shuffle is IShuffle, Ownable, VRFConsumerBaseV2 {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SSTORE2 for address;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       BIT OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Bit mask used to parse out the pool value.\n    uint256 private constant _BITMASK_POOL = (1 << 4) - 1;\n\n    // Bit mask used to parse out the token ID value.\n    uint256 private constant _BITMASK_TOKEN_ID = (1 << 16) - 1;\n\n    // Bit mask used to parse out the address value.\n    uint256 private constant _BITMASK_USER = (1 << 160) - 1;\n\n    // Bit mask used to parse out each weight value.\n    uint256 private constant _BITMASK_WEIGHT = (1 << 14) - 1;\n\n    // Bit mask used to zeroise the non-weight related upper bits.\n    uint256 private constant _BITMASK_WEIGHTS = (1 << 70) - 1;\n    \n    // Bit position of `fulfilled` boolean value.\n    uint256 private constant _BITPOS_FULFILLED = 255;\n\n    // Bit position of `exists` boolean value.\n    uint256 private constant _BITPOS_EXISTS = 254;\n\n    // Bit position of `TokenPools` enum value.\n    uint256 private constant _BITPOS_POOL = 246;\n\n    // Bit position of `tokenId` value.\n    uint256 private constant _BITPOS_TOKEN_ID = 230;\n\n    // Bit position of `user` address.\n    uint256 private constant _BITPOS_USER = 70;\n    \n    // Bit position of the first weight.\n    uint256 private constant _BITPOS_WEIGHT = 14;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      RANK THRESHOLDS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Ranks between 7777 and 3889 are categorised as common.\n    uint256 private constant _THRESHOLD_COMMON = 3889;\n\n    // Ranks between 3888 and 2333 are categorised as uncommon.\n    uint256 private constant _THRESHOLD_UNCOMMON = 2333;\n\n    // Ranks between 2332 and 1167 are categorised as rare.\n    uint256 private constant _THRESHOLD_RARE = 1167;\n\n    // Ranks between 1166 and 312 are categorised as epic.\n    uint256 private constant _THRESHOLD_EPIC = 312;\n\n    // NOTE: Tokens that exceed rank 312 are considered as grail tokens.\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER CONSTANTS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    uint256 private constant _EXPECTED_WEIGHT = 10000;\n\n    uint256 private constant _EXPECTED_SIZE = 15554;\n\n    uint256 private constant _SHARD_ID = 0;\n\n    /**\n     * `requestData` bit layout.\n     * [255..255] fulfilled: Boolean value indicating whether the request has been successfully fulfilled.\n     * [254..254] exists: Boolean value indicating whether a request exists.\n     * [246..253] pool: Respective pool that `id` will be placed into upon fulfillment.\n     * [230..245] tokenId: Isekai Meta token identifier associated with the request.\n     * [70...229] user: Address of the caller that invoked the request.\n     * [0.....69] weights: Packed weightings associated with each token pool, 14 bits per weight.\n     */\n    mapping(uint256 requestId => uint256 requestData) private _requests;\n    \n    // Mapping of pool type to the token IDs that reside within it.\n    mapping(TokenPools pool => EnumerableSet.UintSet tokenIds) private _pools;\n\n    // Mapping of pool type to a packed `uint256[5]` weights array.\n    mapping(TokenPools pool => uint256 weights) private _weights;\n\n    // Interface of Isekai Meta contract.\n    IERC721A public immutable ISEKAI = IERC721A(0x684E4ED51D350b4d76A3a07864dF572D24e6dC4c);\n    \n    // Interface of Isekai Shards contract.\n    IShards public immutable SHARDS = IShards(0xb842b4605F7D3340329122faeA90954CbD15a849);\n    \n    // Interface for Chainlink VRFCoordinatorV2.\n    VRFCoordinatorV2Interface public immutable COORDINATOR;\n\n    // There is no intention to support gwei key hashes above 200 so this variable\n    // has been defined as immutable.\n    bytes32 public immutable KEY_HASH;\n\n    // Address of the SSTORE2'd ranking data.\n    address public immutable rankings;\n\n    // Tracks the current state of the contract.\n    ShuffleState public shuffleState;\n\n    // Chainlink stuff.\n    uint64 public subscriptionId;\n    uint32 public callbackGasLimit = 500_000;\n    uint16 public requestConfirmations = 3;\n\n    // Tracks the current number of pending requests. This value been casted to a uint16\n    // to prevent a zero to non-zero SSTORE by packing it into the storage slot with the\n    // values defined above.\n    uint16 public pendingRequests = 0;\n\n    /**\n     * Modifier that checks if `shuffleState` matches `desiredState`.\n     */\n    modifier checkState(ShuffleState desiredState) {\n        _checkState(desiredState);\n        _;\n    }\n    \n    constructor(\n        address coordinator,\n        bytes32 keyHash,\n        uint64 subId,\n        bytes memory data,\n        uint256[5][5] memory weightings\n    ) VRFConsumerBaseV2(coordinator) {\n        _initializeOwner(msg.sender);\n\n        COORDINATOR = VRFCoordinatorV2Interface(coordinator);\n        KEY_HASH = keyHash;\n        subscriptionId = subId;\n\n        // Expected bytes length of constructor argument `data`. Since each ranking\n        // is consolidated into 2 bytes of information and there is 7,777 tokens\n        // in the Isekai Meta collection, 2 * 7777 (15554) is the desired length.\n        if (data.length != _EXPECTED_SIZE) revert InvalidDataSize();\n        rankings = SSTORE2.write(data);\n\n        _setPoolWeights(weightings);\n    }\n\n    /**\n     * @notice Function used to shuffle an Isekai Meta token.\n     * @param tokenId Isekai Meta token Identifier.\n     */\n    function shuffle(uint256 tokenId) external checkState(ShuffleState.ACTIVE) {\n        // Ensure that the request can be fulfilled, this line updates `pendingRequests`\n        // then checks its value against the return value of `_minPoolSize()`.\n        if (++pendingRequests > _minPoolSize()) revert InvalidPoolSize();\n\n        SHARDS.burn(msg.sender, _SHARD_ID, 1);\n        ISEKAI.transferFrom(msg.sender, address(this), tokenId);\n\n        TokenPools pool = _poolFromId(tokenId);\n        uint256 weightings = _weights[pool];\n\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            KEY_HASH,\n            subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            1\n        );\n\n        _requests[requestId] = _packData(pool, tokenId, msg.sender, weightings);\n    }\n\n    /**\n     * @notice Function used to add reward tokens to the shuffler.\n     * @param tokenIds Array of Isekai Meta token identifiers.\n     */\n    function addRewardTokens(uint256[] calldata tokenIds)\n        external\n        onlyOwner\n        checkState(ShuffleState.INACTIVE)\n    {\n        if (tokenIds.length == 0) revert ZeroLengthArray();\n\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            uint256 tokenId = tokenIds[i];\n            ISEKAI.transferFrom(msg.sender, address(this), tokenId);\n\n            if (!_pools[_poolFromId(tokenId)].add(tokenId)) revert AddFailed();\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Function used to remove reward tokens from the shuffler.\n     * @param tokenIds Array of Isekai Meta token identifiers.\n     */\n    function removeRewardTokens(uint256[] calldata tokenIds)\n        external\n        onlyOwner\n        checkState(ShuffleState.INACTIVE)\n    {\n        if (tokenIds.length == 0) revert ZeroLengthArray();\n\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            uint256 tokenId = tokenIds[i];\n            if (!_pools[_poolFromId(tokenId)].remove(tokenId)) revert RemoveFailed();\n\n            ISEKAI.transferFrom(address(this), msg.sender, tokenId);\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Function used to withdraw tokens from the contract. This function\n     * is here to ensure tokens NEVER become stuck due to unforseen circumstances.\n     * @param tokenIds Array of Isekai Meta token identifiers.\n     * @dev If this function is ever called, the contract itself will require\n     * redeployment. Use with EXTREME caution.\n     */\n    function emergencyWithdraw(uint256[] calldata tokenIds) external onlyOwner {\n        if (tokenIds.length == 0) revert ZeroLengthArray();\n        for (uint256 i = 0; i < tokenIds.length; ) {\n            ISEKAI.transferFrom(address(this), msg.sender, tokenIds[i]);\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * @notice Function used to set a new `shuffleState` value.\n     * @param newShuffleState Newly desired `shuffleState` value.\n     */\n    function setShuffleState(ShuffleState newShuffleState) external onlyOwner {\n        shuffleState = newShuffleState;\n    }\n\n    /**\n     * @notice Function used to view all tokens in `pool`.\n     * @param pool Desired token pool to check.\n     * @return Returns an array of all token IDs within `pool`.\n     */\n    function getTokensInPool(TokenPools pool) external view returns (uint256[] memory) {\n        return _pools[pool].values();\n    }\n\n    /**\n     * @notice Function used to view all tokens in every pool.\n     * @return tokenIds A multi-dimensional array that contains all token IDs within each token pool.\n     */\n    function getTokensInAllPools() external view returns (uint256[][] memory tokenIds) {\n        uint256 maxPools = uint256(type(TokenPools).max);\n        tokenIds = new uint256[][](maxPools + 1);\n\n        for (uint256 i = 0; i <= maxPools; i++) {\n            tokenIds[i] = _pools[TokenPools(i)].values();\n        }\n\n        return tokenIds;\n    }\n\n    /**\n     * @notice Function used to view the number of tokens in `pool`.\n     * @param pool Desired token pool to check.\n     */\n    function getAmountOfTokensInPool(TokenPools pool) external view returns (uint256) {\n        return _pools[pool].length();\n    }\n\n    /**\n     * @notice Function used to check if `tokenId` is in `pool`.\n     * @param pool Desired token pool to check.\n     * @param tokenId Isekai Meta token identifier.\n     * @return Returns `true` if `tokenId` exists within `pool`, `false` otherwise.\n     */\n    function isTokenInPool(TokenPools pool, uint256 tokenId) external view returns (bool) {\n        return _pools[pool].contains(tokenId);\n    }\n\n    /**\n     * @notice Function used to check the weights associated with `pool`.\n     * @param pool Desired token pool to check.\n     * @return Returns the weights of each token pool for `pool`.\n     */\n    function weights(TokenPools pool) external view returns (uint256[5] memory) {\n        return _unpackWeights(_weights[pool]);\n    }\n\n    /**\n     * @notice Function used to view the token pool associated with `tokenId`.\n     * @param tokenId Isekai Meta token identifier.\n     * @return Returns the token pool associated with `tokenId`.\n     */\n    function poolFromId(uint256 tokenId) external view returns (TokenPools) {\n        return _poolFromId(tokenId);\n    }\n\n    /**\n     * @notice Function used to view the rank of a given `tokenId`.\n     * @param tokenId Isekai Meta token identifier.\n     * @return Returns the rank associated with the provided `tokenId`.\n     */\n    function getRank(uint256 tokenId) external view returns (uint256) {\n        return _getRank(tokenId);\n    }\n\n    /**\n     * @notice Function used to view the request data for a given `requestId` value.\n     * @param requestId A Chainlink request identifier.\n     * @return Returns Human readable request data derived from `PackedRequest.data[requestId]`.\n     */\n    function requests(uint256 requestId) external view returns (Request memory) {\n        uint256 data = _requests[requestId];\n        return Request({\n            fulfilled: data >> _BITPOS_FULFILLED & 1 == 1,\n            exists: data >> _BITPOS_EXISTS & 1 == 1,\n            pool: TokenPools(data >> _BITPOS_POOL & _BITMASK_POOL),\n            tokenId: data >> _BITPOS_TOKEN_ID & _BITMASK_TOKEN_ID,\n            user: address(uint160(data >> _BITPOS_USER & _BITMASK_USER)),\n            weights: _unpackWeights(data)\n        });\n    }\n\n    /**\n     * @notice Function used to handle random number fulfillment.\n     * @dev It is critical that this function NEVER reverts.\n     */\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords\n    ) internal override {\n        // Access the packed data associated with `requestId`.\n        uint256 data = _requests[requestId];\n        \n        // Confirm that the randomness request exists.\n        if (data >> _BITPOS_EXISTS & 1 != 1) revert RequestNotFound();\n\n        // Acknowledge the request is being fulfilled and update the respective value.\n        _requests[requestId] |= 1 << _BITPOS_FULFILLED;\n\n        // Update pending requests.\n        --pendingRequests;\n\n        // Assign random number from `randomWords`.\n        uint256 randomNumber = randomWords[0];\n\n        // Run weighted random number algorithm to determine which pool a token will be selected from. The\n        // second parameter zeroises the non-weight related bits of `data` to ensure cleanliness.\n        TokenPools chosenPool = _chosePool(randomNumber, data & _BITMASK_WEIGHTS);\n\n        // Select a token from the chosen pool, the operation defined within `.at()` mods `randomNumber`\n        // by the length of `_pools[chosenPool]` to derive a pseudorandom index between 0 and `length - 1`.\n        uint256 tokenOut = _pools[chosenPool].at(randomNumber % _pools[chosenPool].length());\n\n        // Remove the token ID from the pool.\n        _pools[chosenPool].remove(tokenOut);\n\n        // Assign original token value.\n        uint256 tokenIn = data >> _BITPOS_TOKEN_ID & _BITMASK_TOKEN_ID;\n\n        // Update the pool with the original Isekai that was provided in the initial invocation of `shuffle()`.\n        _pools[TokenPools(data >> _BITPOS_POOL & _BITMASK_POOL)].add(tokenIn);\n\n        // Assign receiver.\n        address receiver = address(uint160(data >> _BITPOS_USER & _BITMASK_USER));\n\n        // Transfer the chosen Isekai to the owner.\n        ISEKAI.transferFrom(address(this), receiver, tokenOut);\n        \n        // Event emission.\n        emit Shuffled(receiver, tokenIn, tokenOut);\n    }\n\n    /** \n     * Helper function used to set the weights of each pool. This function is only\n     * called within the constructor and pool weightings cannot be modified once set.\n     */\n    function _setPoolWeights(uint256[5][5] memory weightings) internal {\n        for (uint256 i = 0; i < weightings.length; i++) {\n            if (_sumWeights(weightings[i]) != _EXPECTED_WEIGHT) revert WeightMismatch();   \n            _weights[TokenPools(i)] = _packWeights(weightings[i]);\n        }\n    }\n\n    /**\n     * Helper function that implements a weighted random number algorithim to derive\n     * a chosen token pool from the seeded random number and the packed weights.\n     */\n    function _chosePool(\n        uint256 randomNumber,\n        uint256 packedWeights\n    ) internal pure returns (TokenPools pool) {\n        assembly (\"memory-safe\") {\n            // Derive a value within the range of 1 - 10,000.\n            let roll := add(mod(randomNumber, _EXPECTED_WEIGHT), 1)\n\n            // Define iterator value.\n            let i := 0\n            for { let cumulativeWeight := 0 } 1 {} {\n                // Assign the current value of `weights[i]`.\n                let poolWeight := and(shr(mul(_BITPOS_WEIGHT, i), packedWeights), _BITMASK_WEIGHT)\n                \n                // Update our `cumulativeWeight` by adding the previous value with `poolWeight`.\n                cumulativeWeight := add(cumulativeWeight, poolWeight)\n\n                // If the condition is satifised, break.\n                if iszero(gt(roll, cumulativeWeight)) { break }\n\n                // Update iterator value.\n                i := add(i, 1)\n            }\n\n            // Set the associated `pool` value.\n            pool := i\n        }\n    }\n\n    /**\n     * Helper function used to efficiently calculate the sum of the `weightings` array. Since\n     * `weightings` is bounded to 5 indices, we can safely unroll the operations.\n     */\n    function _sumWeights(uint256[5] memory weightings) internal pure returns (uint256 sum) {\n        assembly (\"memory-safe\") {\n            sum := mload(weightings)\n            sum := add(sum, mload(add(weightings, 0x20)))\n            sum := add(sum, mload(add(weightings, 0x40)))\n            sum := add(sum, mload(add(weightings, 0x60)))\n            sum := add(sum, mload(add(weightings, 0x80)))\n        }\n    }\n\n    /**\n     * Helper function used to efficiently pack the `weightings` array into 70 bits. Since\n     * the sum of `weightings` is bounded 10,000, each weight fits snugly into 14 bits.\n     */\n    function _packWeights(uint256[5] memory weightings) internal pure returns (uint256 packed) {\n        assembly (\"memory-safe\") {\n            packed := mload(weightings)\n            packed := or(packed, shl(_BITPOS_WEIGHT, mload(add(weightings, 0x20))))\n            packed := or(packed, shl(mul(_BITPOS_WEIGHT, 2), mload(add(weightings, 0x40))))\n            packed := or(packed, shl(mul(_BITPOS_WEIGHT, 3), mload(add(weightings, 0x60))))\n            packed := or(packed, shl(mul(_BITPOS_WEIGHT, 4), mload(add(weightings, 0x80))))\n        }\n    }\n\n    /**\n     * Helper function used to efficiently unpack the `weights_` array from `packedWeights`.\n     */\n    function _unpackWeights(uint256 packedWeights) internal pure returns (uint256[5] memory weights_) {\n        assembly (\"memory-safe\") {\n            mstore(weights_, and(packedWeights, _BITMASK_WEIGHT))\n            mstore(add(weights_, 0x20), and(shr(_BITPOS_WEIGHT, packedWeights), _BITMASK_WEIGHT))\n            mstore(add(weights_, 0x40), and(shr(mul(_BITPOS_WEIGHT, 2), packedWeights), _BITMASK_WEIGHT))\n            mstore(add(weights_, 0x60), and(shr(mul(_BITPOS_WEIGHT, 3), packedWeights), _BITMASK_WEIGHT))\n            mstore(add(weights_, 0x80), and(shr(mul(_BITPOS_WEIGHT, 4), packedWeights), _BITMASK_WEIGHT))\n        }\n    }\n\n    /**\n     * Helper function used to efficiently pack the provided data into a single word.\n     * Refer to `PackedRequest` comment for bit layout.\n     */\n    function _packData(\n        TokenPools pool,\n        uint256 tokenId,\n        address account,\n        uint256 weightings\n    ) internal pure returns (uint256 packed) {\n        assembly (\"memory-safe\") {\n            packed := or(packed, shl(_BITPOS_EXISTS, 1))\n            packed := or(packed, shl(_BITPOS_POOL, pool))\n            packed := or(packed, shl(_BITPOS_TOKEN_ID, tokenId))\n            packed := or(packed, shl(_BITPOS_USER, account))\n            packed := or(packed, weightings)\n        }\n    }\n\n    /**\n     * Helper function that returns the number of tokens in the lowest supplied token pool.\n     */\n    function _minPoolSize() internal view returns (uint256 min) {\n        min = _pools[TokenPools.COMMON].length();\n\n        for (uint256 i = 1; i <= uint256(type(TokenPools).max); ) {\n            uint256 n = _pools[TokenPools(i)].length();\n            if (min > n) min = n;\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     * Helper function used to get the pool associated with `tokenId`.\n     */\n    function _poolFromId(uint256 tokenId) internal view returns (TokenPools pool) {\n        uint256 rank = _getRank(tokenId);\n\n        assembly (\"memory-safe\") {\n            pool := add(\n                add(gt(_THRESHOLD_EPIC, rank), gt(_THRESHOLD_RARE, rank)),\n                add(gt(_THRESHOLD_UNCOMMON, rank), gt(_THRESHOLD_COMMON, rank))\n            )\n        }\n    }\n\n    /**\n     * Helper function used to get the rank of a given token identifier.\n     */\n    function _getRank(uint256 id) internal view returns (uint256 rank) {\n        uint256 start = (id - 1) * 2;\n        uint256 end = start + 2;\n        \n        bytes memory data = rankings.read(start, end);\n\n        assembly (\"memory-safe\") {\n            rank := shr(240, mload(add(data, 0x20)))\n        }\n    }\n\n    /**\n     * Helper function used to reduce bytecode size.\n     */\n    function _checkState(ShuffleState desiredState) private view {\n        if (shuffleState != desiredState) revert InvalidState();\n    }\n\n}\n"
6     },
7     "src/interfaces/IShuffle.sol": {
8       "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\ninterface IShuffle {\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERRORS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * The expected state value does not match the current state.\n     */\n    error InvalidState();\n\n    /**\n     * The provided array has no length.\n     */\n    error ZeroLengthArray();\n\n    /**\n     * The sum of the provided array does not match the expected value.\n     */\n    error WeightMismatch();\n\n    /**\n     * A non-existing request is attempting to be fulfilled by the Oracle.\n     */\n    error RequestNotFound();\n\n    /**\n     * The new number of pending requests will outsize the lowest supplied token pool.\n     */\n    error InvalidPoolSize();\n\n    /**\n     * The data size provided does not match the expected data size.\n     */\n    error InvalidDataSize();\n\n    /**\n     * Failed to add a token to the EnumerableSet.\n     */\n    error AddFailed();\n\n    /**\n     * Failed to remove a token from the EnumerableSet.\n     */\n    error RemoveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ENUMS                            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Used to track the shuffling state of the contract.\n     */\n    enum ShuffleState {\n        INACTIVE,\n        ACTIVE\n    }\n\n    /**\n     * Used to reference a token pool that a token should be deposited\n     * or withdrawn from.\n     */\n    enum TokenPools {\n        COMMON,\n        UNCOMMON,\n        RARE,\n        EPIC,\n        LEGENDARY\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * This struct imitates the unpacked values from `PackedRequest.data`.\n     */\n    struct Request {\n        bool fulfilled;\n        bool exists;\n        TokenPools pool;\n        uint256 tokenId;\n        address user;\n        uint256[5] weights;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event Shuffled(address indexed user, uint256 tokenIn, uint256 tokenOut);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         FUNCTIONS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * Function used to shuffle an Isekai Meta token.\n     */\n    function shuffle(uint256 tokenId) external;\n\n    /**\n     * Function used to add reward tokens to the shuffler.\n     */\n    function addRewardTokens(uint256[] calldata tokenIds) external;\n\n    /**\n     * Function used to remove reward tokens from the shuffler.\n     */\n    function removeRewardTokens(uint256[] calldata tokenIds) external;\n\n    /** \n     * Function used to withdraw reward tokens from the shuffler without pool updates.\n     */\n    function emergencyWithdraw(uint256[] calldata tokenIds) external;\n\n    /**\n     * Function used to set a new `shuffleState` value.\n     */\n    function setShuffleState(ShuffleState newShuffleState) external;\n\n    /**\n     * Function used to view all tokens in `pool`. \n     */\n    function getTokensInPool(TokenPools pool) external view returns (uint256[] memory);\n\n    /**\n     * Function used to view the number of tokens in `pool`.\n     */\n    function getAmountOfTokensInPool(TokenPools pool) external view returns (uint256);\n\n    /**\n     * Function used to check if `tokenId` is in `pool`.\n     */\n    function isTokenInPool(TokenPools pool, uint256 tokenId) external view returns (bool);\n\n    /**\n     * Function used to check the weights associated with `pool`.\n     */\n    function weights(TokenPools pool) external view returns (uint256[5] memory);\n\n    /**\n     * Function used to view the token pool associated with `tokenId`.\n     */\n    function poolFromId(uint256 tokenId) external view returns (TokenPools);\n\n    /**\n     * Function used to view the rank associated with `tokenId`.\n     */\n    function getRank(uint256 tokenId) external view returns (uint256);\n\n    /**\n     * Function used to view an unpacked request for `requestId`.\n     */\n    function requests(uint256 requestId) external view returns (Request memory);\n\n}"
9     },
10     "lib/solady/src/auth/Ownable.sol": {
11       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover\n/// may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"NewOwnerIsZeroAddress()\")))`.\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\n\n    /// @dev `bytes4(keccak256(bytes(\"NoHandoverRequest()\")))`.\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally choosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
12     },
13     "lib/solady/src/utils/SSTORE2.sol": {
14       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASIZE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"
15     },
16     "lib/erc721a/contracts/IERC721A.sol": {
17       "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
18     },
19     "lib/chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
20       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
21     },
22     "lib/chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
23       "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
24     },
25     "lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol": {
26       "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
27     }
28   },
29   "settings": {
30     "remappings": [
31       "@chainlink/=lib/chainlink/",
32       "@openzeppelin/=lib/openzeppelin-contracts/",
33       "chainlink/=lib/chainlink/",
34       "ds-test/=lib/forge-std/lib/ds-test/src/",
35       "erc721a/=lib/erc721a/",
36       "forge-std/=lib/forge-std/src/",
37       "openzeppelin-contracts/=lib/openzeppelin-contracts/",
38       "solady/=lib/solady/src/",
39       "solmate/=lib/solady/lib/solmate/src/"
40     ],
41     "optimizer": {
42       "enabled": true,
43       "runs": 200
44     },
45     "metadata": {
46       "bytecodeHash": "ipfs",
47       "appendCBOR": true
48     },
49     "outputSelection": {
50       "*": {
51         "*": [
52           "evm.bytecode",
53           "evm.deployedBytecode",
54           "devdoc",
55           "userdoc",
56           "metadata",
57           "abi"
58         ]
59       }
60     },
61     "evmVersion": "paris",
62     "libraries": {}
63   }
64 }}