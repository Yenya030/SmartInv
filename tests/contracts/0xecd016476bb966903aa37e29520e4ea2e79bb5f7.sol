{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address, address, uint256);\r\n    event Transfer(address, address, uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n\r\n    function allowance(address, address) external view returns (uint256);\r\n\r\n    function approve(address, uint256) external returns (bool);\r\n\r\n    function transfer(address, uint256) external returns (bool);\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IWETH is IERC20 {\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function deposit() external payable;\r\n}\r\n"
    },
    "contracts/lib/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\nimport \"../interfaces/IERC20.sol\";\r\n\r\nlibrary SafeTransfer {\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool s, ) = address(token).call(\r\n            abi.encodeWithSelector(\r\n                IERC20.transferFrom.selector,\r\n                from,\r\n                to,\r\n                value\r\n            )\r\n        );\r\n        require(s, \"safeTransferFrom failed\");\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        (bool s, ) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\r\n        );\r\n        require(s, \"safeTransfer failed\");\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address to, uint256 value) internal {\r\n        (bool s, ) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\r\n        );\r\n        require(s, \"safeApprove failed\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n"
    },
    "contracts/MeowlRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport {IERC20} from \"./interfaces/IERC20.sol\";\r\nimport {SafeTransfer} from \"./lib/SafeTransfer.sol\";\r\nimport {IWETH} from \"./interfaces/IWETH.sol\";\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function swap(\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// &&&&&&&&&%%%&%#(((/,,,**,,,**,,,*******/*,,/%%%%%%#.,%%%%%%%%%%%%%%%% ./(#%%%%/. #%%/***,,*,*,,,,**,\r\n// %&&&&&&&&&%%%/((((*,,,,,,,**/.,,,*****/%%#.      ,**,,%%%%%%%%%%%%%%%%%%#.     #%%%%%#*,,,,,,*,,,,,*\r\n// ,.,,*(%&&%%/*/((((,,,,,,,,**((%%,,**,  .#%%/*%%%%%%%,*%%%%%%%%%%%%%%%%#%    ..  #%%%%%,*,*,,**,*,**,\r\n// ..,.,,.,,.,.*((((,,,,,,,****(#%%%%%,*%%%%%. .(%%%%%#,#%%%%%%%%%%%%%%%%,  &@# . * (%%%%***,*,,*,*,,,,\r\n// .,.,,..,.,.,/(((,,,,,*****/#%%%%%%%%%%%%%,         ,%%%%%%%%%%%%%%%%%% .    .  / *#%%#***,*,*,**,,**\r\n// ,,.,,,,.,,.,/((,,,****/#%%%%%%%%%%%%%%,     , ....   #%%%%%%%%&&%%%%%, /  ...  ,(%%%%/****,****,*#%#\r\n// .,,.,.,.,.,,/(##%%%%%%%%%%%%%%%%%%%%% , /, .......    %%%%%%%%&&%%%%%% /*  .  , @%%%%/*******/(##%##\r\n// ,..,,..,.,,%%%%%%%%%%%%%%%%%%%%%%%%%(#@..(/ .....  /, %%%%%%%%&&&%%%%%(.*////  @%%%%%/****(#%%%%%%#/\r\n// ,,,..,.,,,.%%%%%%%%%%%%%%%%%%%%%%%%%%%%@../(*     @ .,%%%%%%%%%%%%%%%%%%%%/ ./(%%%%%/*/(#%%%%%%%#**/\r\n// .,,,,,,,,,,*,#%%%%%%%%%%%%%%%%%%%%%%%%%%&@, ,*/(/,. #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#(#%%%%%%%#//*///\r\n// ,,.,,.,,,,,,,,,,#%%%%%%%%%%%%%%%%%%%%%%%%%%(    .#%%%%%%%%%%%%#%&&&%%%%%%%%%%%%%%%*%%%#%%%#(**(**//*\r\n// .,,,,..,*..,.,,,,...*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%,(%#%%%(*/*///*//#%\r\n\r\ncontract MeowlRouter {\r\n    using SafeTransfer for IERC20;\r\n    using SafeTransfer for IWETH;\r\n\r\n    address internal immutable feeAddress;\r\n\r\n    // MAINNET: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    // BASE: 0x4200000000000000000000000000000000000006\r\n\r\n    address internal constant WETH9 =\r\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    uint32 internal constant FEE_NUMERATOR = 875;\r\n    uint32 internal constant FEE_DENOMINATOR = 100000;\r\n\r\n    event Swap(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint actualAmountIn,\r\n        uint actualAmountOut,\r\n        uint feeAmount\r\n    );\r\n\r\n    constructor() {\r\n        feeAddress = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // *** Receive profits from contract *** //\r\n    function recover(address token) public {\r\n        require(msg.sender == feeAddress, \"shoo\");\r\n        if (token == address(0)) {\r\n            SafeTransfer.safeTransferETH(msg.sender, address(this).balance);\r\n            return;\r\n        } else {\r\n            IERC20(token).safeTransfer(\r\n                msg.sender,\r\n                IERC20(token).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n        Payload structure\r\n\r\n        - tokenIn: address       - Address of the token you're swapping\r\n        - tokenOut: address      - Address of the token you want\r\n        - pair: address          - Univ2 pair\r\n        - minAmountOut: uint128  - Min amount out\r\n        - amountIn?: uint128     - Amount you're giving via swap\r\n    */\r\n\r\n    fallback() external payable {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address pair;\r\n        uint minAmountOut;\r\n        uint amountIn;\r\n        address receiver;\r\n        uint feeAmount;\r\n\r\n        assembly {\r\n            // bytes20\r\n            tokenIn := shr(96, calldataload(0))\r\n            // bytes20\r\n            tokenOut := shr(96, calldataload(20))\r\n            // bytes20\r\n            pair := shr(96, calldataload(40))\r\n            // uint128\r\n            minAmountOut := shr(128, calldataload(60))\r\n        }\r\n\r\n        if (address(tokenIn) == WETH9 && msg.value > 0) {\r\n            feeAmount = (msg.value * FEE_NUMERATOR) / FEE_DENOMINATOR;\r\n            amountIn = msg.value - feeAmount;\r\n            IWETH weth = IWETH(WETH9);\r\n\r\n            weth.deposit{value: amountIn}();\r\n            weth.safeTransfer(pair, amountIn);\r\n            receiver = msg.sender;\r\n        } else {\r\n            assembly {\r\n                // uint128\r\n                amountIn := shr(128, calldataload(76))\r\n            }\r\n            IERC20(tokenIn).safeTransferFrom(msg.sender, pair, amountIn);\r\n            receiver = address(this);\r\n        }\r\n\r\n        // Prepare variables for calculating expected amount out\r\n        uint reserveIn;\r\n        uint reserveOut;\r\n\r\n        {\r\n            (uint reserve0, uint reserve1, ) = IUniswapV2Pair(pair)\r\n                .getReserves();\r\n\r\n            // sort reserves\r\n            if (tokenIn < tokenOut) {\r\n                // Token0 is equal to inputToken\r\n                // Token1 is equal to outputToken\r\n                reserveIn = reserve0;\r\n                reserveOut = reserve1;\r\n            } else {\r\n                // Token0 is equal to outputToken\r\n                // Token1 is equal to inputToken\r\n                reserveIn = reserve1;\r\n                reserveOut = reserve0;\r\n            }\r\n        }\r\n\r\n        // Find the actual amountIn sent to pair (accounts for tax if any) and amountOut\r\n        uint actualAmountIn = IERC20(tokenIn).balanceOf(address(pair)) -\r\n            reserveIn;\r\n        uint amountOut = _getAmountOut(actualAmountIn, reserveIn, reserveOut);\r\n\r\n        // Prepare swap variables and call pair.swap()\r\n        (uint amount0Out, uint amount1Out) = tokenIn < tokenOut\r\n            ? (uint(0), amountOut)\r\n            : (amountOut, uint(0));\r\n\r\n        uint balBefore = IERC20(tokenOut).balanceOf(address(receiver));\r\n\r\n        IUniswapV2Pair(pair).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            receiver,\r\n            new bytes(0)\r\n        );\r\n\r\n        uint actualAmountOut = IERC20(tokenOut).balanceOf(address(receiver)) -\r\n            balBefore;\r\n\r\n        require(actualAmountOut >= minAmountOut, \"Too little received\");\r\n\r\n        if (receiver == address(this)) {\r\n            // Only support native ETH out because we can't differentiate\r\n            if (tokenOut == WETH9) {\r\n                IWETH(WETH9).withdraw(amountOut);\r\n\r\n                feeAmount = (actualAmountOut * FEE_NUMERATOR) / FEE_DENOMINATOR;\r\n\r\n                SafeTransfer.safeTransferETH(msg.sender, amountOut - feeAmount);\r\n            } else {\r\n                feeAmount = (actualAmountOut * FEE_NUMERATOR) / FEE_DENOMINATOR;\r\n\r\n                IERC20(tokenOut).safeTransfer(\r\n                    msg.sender,\r\n                    actualAmountOut - feeAmount\r\n                );\r\n            }\r\n        }\r\n\r\n        emit Swap(\r\n            tokenIn,\r\n            tokenOut,\r\n            actualAmountIn,\r\n            actualAmountOut,\r\n            feeAmount\r\n        );\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint amountInWithFee = amountIn * 997;\r\n        uint numerator = amountInWithFee * reserveOut;\r\n        uint denominator = reserveIn * 1000 + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}