{{
  "language": "Solidity",
  "sources": {
    "/contracts/Bridge.sol": {
      "content": "//The Licensed Work is (c) 2022 Sygma\n//SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"./utils/Pausable.sol\";\n\n\nimport \"./interfaces/IERCHandler.sol\";\nimport \"./interfaces/IHandler.sol\";\nimport \"./interfaces/IFeeHandler.sol\";\nimport \"./interfaces/IAccessControlSegregator.sol\";\n\n/**\n    @title Facilitates deposits and creation of deposit proposals, and deposit executions.\n    @author ChainSafe Systems.\n */\ncontract Bridge is Pausable, Context, EIP712 {\n    using ECDSA for bytes32;\n\n    bytes32 private constant _PROPOSALS_TYPEHASH =\n        keccak256(\"Proposals(Proposal[] proposals)Proposal(uint8 originDomainID,uint64 depositNonce,bytes32 resourceID,bytes data)\");\n    bytes32 private constant _PROPOSAL_TYPEHASH =\n        keccak256(\"Proposal(uint8 originDomainID,uint64 depositNonce,bytes32 resourceID,bytes data)\");\n\n\n    uint8   public immutable _domainID;\n    address public _MPCAddress;\n\n    IFeeHandler public _feeHandler;\n\n    IAccessControlSegregator public _accessControl;\n\n    struct Proposal {\n        uint8   originDomainID;\n        uint64  depositNonce;\n        bytes32 resourceID;\n        bytes   data;\n    }\n\n    // destinationDomainID => number of deposits\n    mapping(uint8 => uint64) public _depositCounts;\n    // resourceID => handler address\n    mapping(bytes32 => address) public _resourceIDToHandlerAddress;\n    // forwarder address => is Valid\n    mapping(address => bool) public isValidForwarder;\n    // origin domainID => nonces set => used deposit nonces\n    mapping(uint8 => mapping(uint256 => uint256)) public usedNonces;\n\n    event FeeHandlerChanged(address newFeeHandler);\n    event AccessControlChanged(address newAccessControl);\n    event Deposit(\n        uint8   destinationDomainID,\n        bytes32 resourceID,\n        uint64  depositNonce,\n        address indexed user,\n        bytes   data,\n        bytes   handlerResponse\n    );\n    event ProposalExecution(\n        uint8   originDomainID,\n        uint64  depositNonce,\n        bytes32 dataHash,\n        bytes handlerResponse\n    );\n\n    event FailedHandlerExecution(\n        bytes  lowLevelData,\n        uint8  originDomainID,\n        uint64 depositNonce\n    );\n\n    event StartKeygen();\n\n    event EndKeygen();\n\n    event KeyRefresh(string hash);\n\n    event Retry(string txHash);\n\n    error AccessNotAllowed(address sender, bytes4 funcSig);\n\n    error ResourceIDNotMappedToHandler();\n\n    error DepositToCurrentDomain();\n\n    error InvalidProposalSigner();\n\n    error EmptyProposalsArray();\n\n    error NonceDecrementsNotAllowed();\n\n    error MPCAddressAlreadySet();\n\n    error MPCAddressNotSet();\n\n    error MPCAddressIsNotUpdatable();\n\n    error MPCAddressZeroAddress();\n\n    modifier onlyAllowed() {\n        _onlyAllowed(msg.sig, _msgSender());\n        _;\n    }\n\n    function _onlyAllowed(bytes4 sig, address sender) private view {\n        if (!_accessControl.hasAccess(sig, sender)) revert AccessNotAllowed(sender, sig);\n    }\n\n    function _msgSender() internal override view returns (address) {\n        address signer = msg.sender;\n        if (msg.data.length >= 20 && isValidForwarder[signer]) {\n            assembly {\n                signer := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        }\n        return signer;\n    }\n\n    /**\n        @notice Initializes Bridge, creates and grants {_msgSender()} the admin role, sets access control\n        contract for bridge and sets the inital state of the Bridge to paused.\n        @param domainID ID of chain the Bridge contract exists on.\n        @param accessControl Address of access control contract.\n     */\n    constructor (uint8 domainID, address accessControl) EIP712(\"Bridge\", \"3.1.0\") {\n        _domainID = domainID;\n        _accessControl = IAccessControlSegregator(accessControl);\n\n        _pause(_msgSender());\n    }\n\n    /**\n        @notice Pauses deposits, proposal creation and voting, and deposit executions.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n     */\n    function adminPauseTransfers() external onlyAllowed {\n        _pause(_msgSender());\n    }\n\n    /**\n        @notice Unpauses deposits, proposal creation and voting, and deposit executions.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @notice MPC address has to be set before Bridge can be unpaused\n     */\n    function adminUnpauseTransfers() external onlyAllowed {\n        if (_MPCAddress == address(0)) revert MPCAddressNotSet();\n        _unpause(_msgSender());\n    }\n\n    /**\n        @notice Sets a new resource for handler contracts that use the IERCHandler interface,\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param handlerAddress Address of handler resource will be set for.\n        @param resourceID ResourceID to be used when making deposits.\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\n        @param args Additional data to be passed to specified handler.\n     */\n    function adminSetResource(address handlerAddress, bytes32 resourceID, address contractAddress, bytes calldata args) external onlyAllowed {\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\n        IHandler handler = IHandler(handlerAddress);\n        handler.setResource(resourceID, contractAddress, args);\n    }\n\n    /**\n        @notice Sets a resource as burnable for handler contracts that use the IERCHandler interface.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param handlerAddress Address of handler resource will be set for.\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\n     */\n    function adminSetBurnable(address handlerAddress, address tokenAddress) external onlyAllowed {\n        IERCHandler handler = IERCHandler(handlerAddress);\n        handler.setBurnable(tokenAddress);\n    }\n\n    /**\n        @notice Sets the nonce for the specific domainID.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param domainID Domain ID for increasing nonce.\n        @param nonce The nonce value to be set.\n     */\n    function adminSetDepositNonce(uint8 domainID, uint64 nonce) external onlyAllowed {\n        require(nonce > _depositCounts[domainID], \"Does not allow decrements of the nonce\");\n        _depositCounts[domainID] = nonce;\n    }\n\n    /**\n        @notice Set a forwarder to be used.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param forwarder Forwarder address to be added.\n        @param valid Decision for the specific forwarder.\n     */\n    function adminSetForwarder(address forwarder, bool valid) external onlyAllowed {\n        isValidForwarder[forwarder] = valid;\n    }\n\n    /**\n        @notice Changes access control contract address.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param newAccessControl Address {_accessControl} will be updated to.\n     */\n    function adminChangeAccessControl(address newAccessControl) external onlyAllowed {\n        _accessControl = IAccessControlSegregator(newAccessControl);\n        emit AccessControlChanged(newAccessControl);\n    }\n\n    /**\n        @notice Changes deposit fee handler contract address.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param newFeeHandler Address {_feeHandler} will be updated to.\n     */\n    function adminChangeFeeHandler(address newFeeHandler) external onlyAllowed {\n        _feeHandler = IFeeHandler(newFeeHandler);\n        emit FeeHandlerChanged(newFeeHandler);\n    }\n\n    /**\n        @notice Used to manually withdraw funds from ERC safes.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param handlerAddress Address of handler to withdraw from.\n        @param data ABI-encoded withdrawal params relevant to the specified handler.\n     */\n    function adminWithdraw(\n        address handlerAddress,\n        bytes memory data\n    ) external onlyAllowed {\n        IERCHandler handler = IERCHandler(handlerAddress);\n        handler.withdraw(data);\n    }\n\n    /**\n        @notice Initiates a transfer using a specified handler contract.\n        @notice Only callable when Bridge is not paused.\n        @param destinationDomainID ID of chain deposit will be bridged to.\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\n        @param depositData Additional data to be passed to specified handler.\n        @param feeData Additional data to be passed to the fee handler.\n        @notice Emits {Deposit} event with all necessary parameters and a handler response.\n        @return depositNonce deposit nonce for the destination domain.\n        @return handlerResponse a handler response:\n        - ERC20Handler: responds with an empty data.\n        - ERC721Handler: responds with the deposited token metadata acquired by calling a tokenURI method in the token contract.\n        - PermissionedGenericHandler: responds with the raw bytes returned from the call to the target contract.\n        - PermissionlessGenericHandler: responds with an empty data.\n     */\n    function deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata depositData, bytes calldata feeData)\n        external payable whenNotPaused\n        returns (uint64 depositNonce, bytes memory handlerResponse) {\n        if (destinationDomainID == _domainID) revert DepositToCurrentDomain();\n\n        address sender = _msgSender();\n        if (address(_feeHandler) == address(0)) {\n            require(msg.value == 0, \"no FeeHandler, msg.value != 0\");\n        } else {\n            // Reverts on failure\n            _feeHandler.collectFee{value: msg.value}(sender, _domainID, destinationDomainID, resourceID, depositData, feeData);\n        }\n        address handler = _resourceIDToHandlerAddress[resourceID];\n        if (handler == address(0)) revert ResourceIDNotMappedToHandler();\n\n        depositNonce = ++_depositCounts[destinationDomainID];\n\n        IHandler depositHandler = IHandler(handler);\n        handlerResponse = depositHandler.deposit(resourceID, sender, depositData);\n\n        emit Deposit(destinationDomainID, resourceID, depositNonce, sender, depositData, handlerResponse);\n        return (depositNonce, handlerResponse);\n    }\n\n    /**\n        @notice Executes a deposit proposal using a specified handler contract (only if signature is signed by MPC).\n        @notice Failed executeProposal from handler don't revert, emits {FailedHandlerExecution} event.\n        @param proposal Proposal which consists of:\n        - originDomainID ID of chain deposit originated from.\n        - resourceID ResourceID to be used when making deposits.\n        - depositNonce ID of deposit generated by origin Bridge contract.\n        - data Data originally provided when deposit was made.\n        @param signature bytes memory signature composed of MPC key shares\n        @notice Emits {ProposalExecution} event.\n        @notice Behaviour of this function is different for {PermissionedGenericHandler} and other specific ERC handlers.\n        In the case of ERC handler, when execution fails, the handler will terminate the function with revert.\n        In the case of {PermissionedGenericHandler}, when execution fails, the handler will emit a failure event and terminate the function normally.\n     */\n    function executeProposal(Proposal memory proposal, bytes calldata signature) public {\n        Proposal[] memory proposalArray = new Proposal[](1);\n        proposalArray[0] = proposal;\n\n        executeProposals(proposalArray, signature);\n    }\n\n    /**\n        @notice Executes a batch of deposit proposals using a specified handler contract for each proposal (only if signature is signed by MPC).\n        @notice If executeProposals fails it doesn't revert, emits {FailedHandlerExecution} event.\n        @param proposals Array of Proposal which consists of:\n        - originDomainID ID of chain deposit originated from.\n        - resourceID ResourceID to be used when making deposits.\n        - depositNonce ID of deposit generated by origin Bridge contract.\n        - data Data originally provided when deposit was made.\n        @param signature bytes memory signature for the whole array composed of MPC key shares\n        @notice Emits {ProposalExecution} event for each proposal in the batch.\n        @notice Behaviour of this function is different for {PermissionedGenericHandler} and other specific handlers.\n        In the case of ERC handler, when execution fails, the handler will terminate the function with revert.\n        In the case of {PermissionedGenericHandler}, when execution fails, the handler will emit a failure event and terminate the function normally.\n     */\n    function executeProposals(Proposal[] memory proposals, bytes calldata signature) public whenNotPaused {\n        if (proposals.length == 0) revert EmptyProposalsArray();\n        if (!verify(proposals, signature)) revert InvalidProposalSigner();\n\n        for (uint256 i = 0; i < proposals.length; i++) {\n            if(isProposalExecuted(proposals[i].originDomainID, proposals[i].depositNonce)) {\n                continue;\n            }\n\n            address handler = _resourceIDToHandlerAddress[proposals[i].resourceID];\n            bytes32 dataHash = keccak256(abi.encodePacked(handler, proposals[i].data));\n\n            IHandler depositHandler = IHandler(handler);\n\n            usedNonces[proposals[i].originDomainID][proposals[i].depositNonce / 256] |= 1 << (proposals[i].depositNonce % 256);\n\n            try depositHandler.executeProposal(proposals[i].resourceID, proposals[i].data) returns (bytes memory handlerResponse) {\n                emit ProposalExecution(proposals[i].originDomainID, proposals[i].depositNonce, dataHash, handlerResponse);\n            } catch (bytes memory lowLevelData) {\n                emit FailedHandlerExecution(lowLevelData, proposals[i].originDomainID, proposals[i].depositNonce);\n                usedNonces[proposals[i].originDomainID][proposals[i].depositNonce / 256] &= ~(1 << (proposals[i].depositNonce % 256));\n                continue;\n            }\n        }\n    }\n\n    /**\n        @notice Once MPC address is set, this method can't be invoked anymore.\n        It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n     */\n    function startKeygen() external onlyAllowed {\n        if (_MPCAddress != address(0)) revert MPCAddressAlreadySet();\n        emit StartKeygen();\n    }\n\n    /**\n        @notice This method can be called only once, after the MPC address is set Bridge is unpaused.\n        It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param MPCAddress Address that will be set as MPC address.\n     */\n    function endKeygen(address MPCAddress) external onlyAllowed {\n        if( MPCAddress == address(0)) revert MPCAddressZeroAddress();\n        if (_MPCAddress != address(0)) revert MPCAddressIsNotUpdatable();\n        _MPCAddress = MPCAddress;\n        _unpause(_msgSender());\n        emit EndKeygen();\n    }\n\n    /**\n        @notice It's used to trigger the belonging process on the MPC side.\n        It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param hash Topology hash which prevents changes during refresh process.\n     */\n    function refreshKey(string memory hash) external onlyAllowed {\n        emit KeyRefresh(hash);\n    }\n\n    /**\n        @notice This method is used to trigger the process for retrying failed deposits on the MPC side.\n        @notice Only callable by address that has the right to call the specific function,\n        which is mapped in {functionAccess} in AccessControlSegregator contract.\n        @param txHash Transaction hash which contains deposit that should be retried\n        @notice This is not applicable for failed executions on {PermissionedGenericHandler}\n     */\n    function retry(string memory txHash) external onlyAllowed {\n        emit Retry(txHash);\n    }\n\n    /**\n        @notice Returns a boolean value.\n        @param domainID ID of chain deposit originated from.\n        @param depositNonce ID of deposit generated by origin Bridge contract.\n        @return Boolean value depending if deposit nonce has already been used or not.\n     */\n    function isProposalExecuted(uint8 domainID, uint256 depositNonce) public view returns (bool) {\n        return usedNonces[domainID][depositNonce / 256] & (1 << (depositNonce % 256)) != 0;\n    }\n\n    /**\n        @notice Verifies that proposal data is signed by MPC address.\n        @param proposals array of Proposals.\n        @param signature signature bytes memory signature composed of MPC key shares.\n        @return Boolean value depending if signer is vaild or not.\n     */\n    function verify(Proposal[] memory proposals, bytes calldata signature) public view returns (bool) {\n        bytes32[] memory keccakData = new bytes32[](proposals.length);\n        for (uint256 i = 0; i < proposals.length; i++) {\n            keccakData[i] = keccak256(\n                abi.encode(\n                    _PROPOSAL_TYPEHASH,\n                    proposals[i].originDomainID,\n                    proposals[i].depositNonce,\n                    proposals[i].resourceID,\n                    keccak256(proposals[i].data)\n                )\n            );\n        }\n\n        address signer = _hashTypedDataV4(\n          keccak256(abi.encode(\n            _PROPOSALS_TYPEHASH, keccak256(abi.encodePacked(keccakData))))\n        ).recover(signature);\n        return signer == _MPCAddress;\n    }\n}\n"
    },
    "/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This is a stripped down version of Open zeppelin's Pausable contract.\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\n *\n */\ncontract Pausable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _whenNotPaused();\n        _;\n    }\n\n    function _whenNotPaused() private view {\n        require(!_paused, \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _whenPaused();\n        _;\n    }\n\n    function _whenPaused() private view {\n        require(_paused, \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     * @param sender Address which executes pause.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause(address sender) internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(sender);\n    }\n\n    /**\n     * @dev Returns to normal state.\n     * @param sender Address which executes unpause.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause(address sender) internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(sender);\n    }\n}"
    },
    "/contracts/interfaces/IHandler.sol": {
      "content": "// The Licensed Work is (c) 2022 Sygma\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.11;\n\n/**\n    @title Interface for handler that handles generic deposits and deposit executions.\n    @author ChainSafe Systems.\n */\ninterface IHandler {\n    /**\n        @notice It is intended that deposit are made using the Bridge contract.\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\n        @param depositor Address of account making the deposit in the Bridge contract.\n        @param data Consists of additional data needed for a specific deposit.\n     */\n    function deposit(bytes32 resourceID, address depositor, bytes calldata data) external returns (bytes memory);\n\n    /**\n        @notice It is intended that proposals are executed by the Bridge contract.\n        @param resourceID ResourceID to be used when making deposits.\n        @param data Consists of additional data needed for a specific deposit execution.\n     */\n    function executeProposal(bytes32 resourceID, bytes calldata data) external returns (bytes memory);\n\n    /**\n        @notice Correlates {_resourceIDToContractAddress} with {contractAddress}, {_tokenContractAddressToTokenProperties[tokenAddress].resourceID} with {resourceID} and marks\n        {_tokenContractAddressToTokenProperties[tokenAddress].isWhitelisted} to true for {contractAddress} in ERCHandlerHelpers contract.\n        @param resourceID ResourceID to be used when making deposits.\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\n        @param args Additional data to be passed to specified handler.\n     */\n    function setResource(bytes32 resourceID, address contractAddress, bytes calldata args) external;\n}\n"
    },
    "/contracts/interfaces/IFeeHandler.sol": {
      "content": "// The Licensed Work is (c) 2022 Sygma\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.11;\n\n/**\n    @title Interface to be used with fee handlers.\n    @author ChainSafe Systems.\n */\ninterface IFeeHandler {\n\n    /**\n        @notice This event is emitted when the fee is collected.\n        @param sender Sender of the deposit.\n        @param fromDomainID ID of the source chain.\n        @param destinationDomainID ID of chain deposit will be bridged to.\n        @param resourceID ResourceID to be used when making deposits.\n        @param fee Collected fee amount.\n        @param tokenAddress Address of the token in which the fee was collected (0 for the base currency).\n     */\n    event FeeCollected(\n        address sender,\n        uint8 fromDomainID,\n        uint8 destinationDomainID,\n        bytes32 resourceID,\n        uint256 fee,\n        address tokenAddress\n    );\n\n    /**\n        @notice This event is emitted when the fee is distributed to an address.\n        @param tokenAddress Address of the token in which the fee was collected (0 for the base currency).\n        @param recipient Address that receives the distributed fee.\n        @param amount Amount that is distributed.\n     */\n    event FeeDistributed(\n        address tokenAddress,\n        address recipient,\n        uint256 amount\n    );\n\n    /**\n        @notice Collects fee for deposit.\n        @param sender Sender of the deposit.\n        @param fromDomainID ID of the source chain.\n        @param destinationDomainID ID of chain deposit will be bridged to.\n        @param resourceID ResourceID to be used when making deposits.\n        @param depositData Additional data to be passed to specified handler.\n        @param feeData Additional data to be passed to the fee handler.\n     */\n    function collectFee(address sender, uint8 fromDomainID, uint8 destinationDomainID, bytes32 resourceID, bytes calldata depositData, bytes calldata feeData) payable external;\n\n    /**\n        @notice Calculates fee for deposit.\n        @param sender Sender of the deposit.\n        @param fromDomainID ID of the source chain.\n        @param destinationDomainID ID of chain deposit will be bridged to.\n        @param resourceID ResourceID to be used when making deposits.\n        @param depositData Additional data to be passed to specified handler.\n        @param feeData Additional data to be passed to the fee handler.\n        @return Returns the fee amount.\n        @return Returns the address of the token to be used for fee.\n     */\n    function calculateFee(address sender, uint8 fromDomainID, uint8 destinationDomainID, bytes32 resourceID, bytes calldata depositData, bytes calldata feeData) external view returns(uint256, address);\n}\n"
    },
    "/contracts/interfaces/IERCHandler.sol": {
      "content": "// The Licensed Work is (c) 2022 Sygma\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.11;\n\n/**\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\n    @author ChainSafe Systems.\n */\ninterface IERCHandler {\n    /**\n        @notice Marks {contractAddress} as mintable/burnable.\n        @param contractAddress Address of contract to be used when making or executing deposits.\n     */\n    function setBurnable(address contractAddress) external;\n\n    /**\n        @notice Withdraw funds from ERC safes.\n        @param data ABI-encoded withdrawal params relevant to the handler.\n     */\n    function withdraw(bytes memory data) external;\n\n    /**\n        @notice Exposing getter for {_resourceIDToTokenContractAddress}.\n        @param resourceID ResourceID to be used.\n        @return address The {tokenContractAddress} that is currently set for the resourceID.\n     */\n    function _resourceIDToTokenContractAddress(bytes32 resourceID) external view returns (address);\n}\n"
    },
    "/contracts/interfaces/IAccessControlSegregator.sol": {
      "content": "// The Licensed Work is (c) 2022 Sygma\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.11;\n\n/**\n    @title Interface to be used with contracts that want per function access control.\n    @author ChainSafe Systems.\n */\ninterface IAccessControlSegregator {\n    /**\n        @notice Returns boolean value if account has access to function.\n        @param sig Function identifier.\n        @param account Address of account.\n        @return Boolean value depending if account has access.\n    */\n    function hasAccess(bytes4 sig, address account) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}