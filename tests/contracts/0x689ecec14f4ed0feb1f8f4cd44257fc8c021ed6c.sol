{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Break.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Sig.sol\";\n\ninterface IToken {\n    function balanceOf(address owner, uint256 id) external returns (uint256);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external returns (bool);\n\n    function burnFT(address owner, uint256 tokenID, uint256 quantity) external;\n\n    function mintFT(address to, uint256 tokenID, uint256 quantity) external;\n\n    function mintNFT(address to, uint256 tokenID) external;\n\n    function batchMintNFT(address to, uint256[] calldata ids) external;\n}\n\ncontract Break is Ownable {\n    address private _token;\n    address private _signer;\n\n    event SignatureConsumed(bytes32 indexed from, bytes32 indexed sigHash);\n\n    mapping(bytes32 => bytes32) public lastSigUsed;\n\n    function setTokenAddress(address addr) public onlyOwner {\n        _token = addr;\n    }\n\n    function getToken() public view returns (address) {\n        return _token;\n    }\n\n    function setSignerAddress(address addr) public onlyOwner {\n        _signer = addr;\n    }\n\n    function getSigner() public view returns (address) {\n        return _signer;\n    }\n\n    function mintFTs(\n        bytes32 from,\n        address to,\n        uint256 id,\n        uint256 qty,\n        uint256 expiry,\n        bytes32 prevSigHash,\n        bytes calldata sig\n    ) public {\n        IToken token = IToken(_token);\n\n        require(to != address(0), \"Destination cannot be null address.\");\n\n        require(\n            verify(\n                sig,\n                keccak256(abi.encode(from, id, qty, expiry, prevSigHash)),\n                _signer\n            ),\n            \"Signature mismatch.\"\n        );\n\n        require(\n            lastSigUsed[from] == prevSigHash,\n            \"Wrong previous signature supplied.\"\n        );\n\n        require(block.timestamp < expiry, \"Signature has expired.\");\n\n        lastSigUsed[from] = keccak256(sig);\n\n        token.mintFT(to, id, qty);\n\n        emit SignatureConsumed(from, keccak256(sig));\n    }\n\n    function mintNFTs(\n        bytes32 from,\n        address to,\n        uint256 burn,\n        uint256 burnQty,\n        uint256[] calldata mints,\n        uint256 expiry,\n        bytes32 prevSigHash,\n        bytes calldata sig\n    ) public {\n        IToken token = IToken(_token);\n\n        require(to != address(0), \"Destination cannot be null address.\");\n\n        if (burnQty > 0) {\n            require(\n                token.isApprovedForAll(_msgSender(), address(this)),\n                \"Approval required\"\n            );\n        }\n\n        require(\n            verify(\n                sig,\n                keccak256(\n                    abi.encode(\n                        from,\n                        burn,\n                        burnQty,\n                        keccak256(abi.encodePacked(mints)),\n                        expiry,\n                        prevSigHash\n                    )\n                ),\n                _signer\n            ),\n            \"Signature mismatch.\"\n        );\n\n        require(\n            lastSigUsed[from] == prevSigHash,\n            \"Wrong previous signature supplied.\"\n        );\n\n        require(block.timestamp < expiry, \"Signature has expired.\");\n\n        lastSigUsed[from] = keccak256(sig);\n\n        if (burnQty > 0) {\n            token.burnFT(_msgSender(), burn, burnQty);\n        }\n\n        token.batchMintNFT(to, mints);\n\n        emit SignatureConsumed(from, keccak256(sig));\n    }\n\n    function verify(\n        bytes memory sig,\n        bytes32 hash,\n        address signer\n    ) internal pure returns (bool) {\n        return Sig.verify(sig, hash, signer);\n    }\n}\n"
    },
    "contracts/Sig.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nlibrary Sig {\n    function verify(\n        bytes memory signature,\n        bytes32 digestHash,\n        address expected\n    ) internal pure returns (bool) {\n        address std = getSigner(signature, digestHash);\n        if (std == expected) {\n            return true;\n        }\n\n        address packed = getSignerPacked(signature, digestHash);\n        if (packed == expected) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function getSigner(\n        bytes memory signature,\n        bytes32 digestHash\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n\n        bytes32 signed = getMessageHash(digestHash);\n        return ecrecover(signed, v, r, s);\n    }\n\n    function getSignerPacked(\n        bytes memory signature,\n        bytes32 digestHash\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n\n        bytes32 signed = getMessageHashPacked(digestHash);\n        return ecrecover(signed, v, r, s);\n    }\n\n    function getMessageHash(\n        bytes32 digestHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\"\\x19Ethereum Signed Message:\\n32\", digestHash)\n            );\n    }\n\n    function getMessageHashPacked(\n        bytes32 digestHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", digestHash)\n            );\n    }\n\n    function splitSignature(\n        bytes memory sig\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}