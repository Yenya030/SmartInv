{{
  "language": "Solidity",
  "sources": {
    "contracts/SmashversePrimarySaleRelay.sol": {
      "content": "// SPDX-License-Identifier: BUSL 1.0\n// Metadrop Contracts (v1)\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n// EPS implementation\nimport \"./EPS/IEPS_DR.sol\";\n\ninterface ISublists {\n  struct Sublist {\n    uint256 sublistInteger;\n    uint256 sublistPosition;\n  }\n}\n\ninterface ITitanMinting is ISublists {\n  /**\n   *\n   * @dev listMint: mint from any of the lists\n   *\n   */\n  function listMint(\n    Sublist memory sublist_,\n    uint256 quantityEligible_,\n    uint256 quantityToMint_,\n    uint256 unitPrice_,\n    uint256 vestingInDays_,\n    bytes32[] calldata proof_\n  ) external payable;\n}\n\ninterface ITitan is IERC721 {\n  /**\n   * @dev Returns the total number of tokens ever minted\n   */\n  function totalMinted() external view returns (uint256);\n}\n\ncontract SmashversePrimarySaleRelay is Pausable, Ownable, ISublists {\n  using Strings for uint256;\n\n  // The current status of the mint:\n  //   - notEnabled: This type of mint is not part of this drop\n  //   - notYetOpen: This type of mint is part of the drop, but it hasn't started yet\n  //   - open: it's ready for ya, get in there.\n  //   - finished: been and gone.\n  //   - unknown: theoretically impossible.\n  enum MintStatus {\n    notEnabled,\n    notYetOpen,\n    open,\n    finished,\n    unknown\n  }\n\n  enum AllocationCheck {\n    invalidListType,\n    hasAllocation,\n    invalidProof,\n    allocationExhausted\n  }\n\n  enum MintingType {\n    publicMint,\n    allowlistMint,\n    mintPassMint\n  }\n\n  struct SubListConfig {\n    uint256 start;\n    uint256 end;\n    uint256 phaseMaxSupply;\n  }\n\n  struct PublicMintConfig {\n    uint256 price;\n    uint256 maxPerAddress;\n    uint32 start;\n    uint32 end;\n  }\n\n  address constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n\n  // =======================================\n  // CONFIG\n  // =======================================\n\n  // Pause cutoff\n  uint256 public immutable pauseCutOffInDays;\n\n  // The merkleroot for the list\n  bytes32 public listMerkleRoot;\n\n  // Config for the list mints\n  SubListConfig[] public subListConfig;\n\n  // The NFT contract\n  ITitan immutable smashverseTitansContract;\n\n  // V1 sale contract\n  ITitanMinting immutable smashverseSaleContract;\n\n  IERC721 immutable mintPassContract;\n\n  bytes32[] private mintPassProof;\n\n  bytes32[] private freeMintProof;\n\n  uint256 private totalMintPassMintQuantity;\n\n  uint256 private totalFreeMintQuantity;\n\n  uint32 public publicMintStart;\n  uint32 public publicMintEnd;\n  bool public publicMintingClosedForever;\n\n  bool public listDetailsLocked;\n\n  IEPS_DR public epsDeligateRegister;\n\n  address public beneficiary;\n\n  // Track publicMint minting allocations:\n  mapping(address => uint256) public publicMintAllocationMinted;\n\n  // Track list minting allocations:\n  mapping(address => mapping(uint256 => uint256))\n    public listMintAllocationMinted;\n\n  error MintingIsClosedForever();\n  error TransferFailed();\n  error MaxPublicMintAllowanceExceeded(\n    uint256 requested,\n    uint256 alreadyMinted,\n    uint256 maxAllowance\n  );\n  error ProofInvalid();\n  error RequestingMoreThanRemainingAllocation(\n    uint256 requested,\n    uint256 remainingAllocation\n  );\n  error IncorrectConfirmationValue();\n  error ThisListMintIsClosed();\n  error PublicMintClosed();\n  error ListDetailsLocked();\n  error InvalidMintPass();\n\n  event EPSDelegateRegisterUpdated(address epsDelegateRegisterAddress);\n  event MerkleRootSet(bytes32 merkleRoot);\n  event SmashMint(\n    address indexed minter,\n    MintingType mintType,\n    uint256 subListInteger,\n    uint256 quantityMinted\n  );\n  event SublistConfigSet(\n    uint256 sublistInteger,\n    uint256 start,\n    uint256 end,\n    uint256 supply\n  );\n\n  event MintPassRedeemed(\n    address indexed receiver,\n    uint256 indexed mintPassTokenId\n  );\n\n  constructor(\n    PublicMintConfig memory publicMintConfig_,\n    bytes32 listMerkleRoot_,\n    address epsDeligateRegister_,\n    uint256 pauseCutOffInDays_,\n    address beneficiary_,\n    SubListConfig[] memory subListParams,\n    address smashverseTitansContract_,\n    address smashverseSaleContract_,\n    address mintPassContract_\n  ) {\n    listMerkleRoot = listMerkleRoot_;\n    publicMintStart = uint32(publicMintConfig_.start);\n    publicMintEnd = uint32(publicMintConfig_.end);\n    epsDeligateRegister = IEPS_DR(epsDeligateRegister_);\n    pauseCutOffInDays = pauseCutOffInDays_;\n    beneficiary = beneficiary_;\n    _loadSubListDetails(subListParams);\n    smashverseTitansContract = ITitan(smashverseTitansContract_);\n    smashverseSaleContract = ITitanMinting(smashverseSaleContract_);\n    mintPassContract = IERC721(mintPassContract_);\n  }\n\n  function onERC721Received(\n    address,\n    address from_,\n    uint256 tokenId_,\n    bytes memory\n  ) external returns (bytes4) {\n    // Allow mints from the Smashverse Titans NFT contract to be sent to this contract\n    if (\n      msg.sender == address(smashverseTitansContract) && from_ == address(0)\n    ) {\n      return this.onERC721Received.selector;\n    } else {\n      // Revert if the sender is not the mint pass contract, since this is a callback from a contract.\n      if (msg.sender != address(mintPassContract)) {\n        revert InvalidMintPass();\n      }\n\n      _performMintPassMinting(tokenId_, from_, address(this));\n\n      return this.onERC721Received.selector;\n    }\n  }\n\n  function mintPassMint(uint256[] memory mintPassTokenIds_) external {\n    for (uint256 i = 0; i < mintPassTokenIds_.length; i++) {\n      _performMintPassMinting(mintPassTokenIds_[i], msg.sender, msg.sender);\n    }\n  }\n\n  function _performMintPassMinting(\n    uint256 mintPassTokenId_,\n    address receiver_,\n    address currentPassHolder_\n  ) internal whenNotPaused {\n    // safeTransferFrom will revert if the sender does not own the token or does not have approval to transfer it.\n    // Burn the mint pass. Since we can't burn NFTs, we transfer it to 0xdEaD.\n    mintPassContract.safeTransferFrom(\n      currentPassHolder_,\n      DEAD_ADDRESS,\n      mintPassTokenId_\n    );\n\n    // Cache the next tokenId from the NFT:\n    uint256 nextTokenId = smashverseTitansContract.totalMinted();\n\n    smashverseSaleContract.listMint(\n      Sublist(0, 0),\n      totalMintPassMintQuantity,\n      2,\n      0,\n      0,\n      mintPassProof\n    );\n\n    smashverseTitansContract.safeTransferFrom(\n      address(this),\n      receiver_,\n      nextTokenId,\n      \"\"\n    );\n\n    smashverseTitansContract.safeTransferFrom(\n      address(this),\n      receiver_,\n      nextTokenId + 1,\n      \"\"\n    );\n\n    emit MintPassRedeemed(receiver_, mintPassTokenId_);\n  }\n\n  // =======================================\n  // MINTING\n  // =======================================\n\n  /**\n   *\n   * @dev _loadSubListDetails\n   *\n   */\n  function _loadSubListDetails(SubListConfig[] memory config_) internal {\n    for (uint256 i = 0; i < config_.length; i++) {\n      subListConfig.push(config_[i]);\n    }\n  }\n\n  /**\n   *\n   * @dev listMintStatus: View of a list mint status\n   *\n   */\n  function listMintStatus(uint256 listInteger)\n    public\n    view\n    returns (\n      MintStatus status,\n      uint256 start,\n      uint256 end\n    )\n  {\n    return (\n      _mintTypeStatus(\n        subListConfig[listInteger].start,\n        subListConfig[listInteger].end\n      ),\n      subListConfig[listInteger].start,\n      subListConfig[listInteger].end\n    );\n  }\n\n  /**\n   *\n   * @dev _mintTypeStatus: return the status of the mint type\n   *\n   */\n  function _mintTypeStatus(uint256 start_, uint256 end_)\n    internal\n    view\n    returns (MintStatus)\n  {\n    // Explicitly check for open before anything else. This is the only valid path to making a\n    // state change, so keep the gas as low as possible for the code path through 'open'\n    if (block.timestamp >= (start_) && block.timestamp <= (end_)) {\n      return (MintStatus.open);\n    }\n\n    if ((start_ + end_) == 0) {\n      return (MintStatus.notEnabled);\n    }\n\n    if (block.timestamp > end_) {\n      return (MintStatus.finished);\n    }\n\n    if (block.timestamp < start_) {\n      return (MintStatus.notYetOpen);\n    }\n\n    return (MintStatus.unknown);\n  }\n\n  /**\n   *\n   * @dev publicMintStatus: View of public mint status\n   *\n   */\n  function publicMintStatus() public view returns (MintStatus) {\n    return _mintTypeStatus(publicMintStart, publicMintEnd);\n  }\n\n  /**\n   *\n   * @dev allowlistFreeMint one free mint per address on the allowlist\n   *\n   */\n  function listMint(\n    Sublist memory sublist_,\n    uint256, // ignored but kept for consistency with ABI\n    uint256, // ignored but kept for consistency with ABI\n    uint256 unitPrice_,\n    uint256 vestingInDays_,\n    bytes32[] calldata proof_\n  ) public payable whenNotPaused {\n    _allowlistFreeMint(sublist_, 1, 1, unitPrice_, vestingInDays_, proof_);\n  }\n\n  /**\n   *\n   * @dev publicMint\n   *\n   */\n  function publicMint(uint256) external payable whenNotPaused {\n    _publicMint();\n  }\n\n  function _publicMint() internal {\n    if (publicMintStatus() != MintStatus.open) revert PublicMintClosed();\n\n    uint256 publicMintsForAddress = publicMintAllocationMinted[msg.sender];\n\n    if (publicMintsForAddress != 0) {\n      revert MaxPublicMintAllowanceExceeded({\n        requested: 1,\n        alreadyMinted: 1,\n        maxAllowance: 1\n      });\n    }\n    publicMintAllocationMinted[msg.sender] += 1;\n\n    // Cache the next tokenId from the NFT:\n    uint256 nextTokenId = smashverseTitansContract.totalMinted();\n\n    smashverseSaleContract.listMint(\n      Sublist(0, 0),\n      totalFreeMintQuantity,\n      1,\n      0,\n      0,\n      freeMintProof\n    );\n\n    smashverseTitansContract.safeTransferFrom(\n      address(this),\n      msg.sender,\n      nextTokenId,\n      \"\"\n    );\n\n    emit SmashMint(msg.sender, MintingType.publicMint, 0, 1);\n  }\n\n  /**\n   *\n   * @dev _allowlistFreeMint:\n   *\n   */\n  function _allowlistFreeMint(\n    Sublist memory sublist_,\n    uint256 quantityEligible_,\n    uint256 quantityToMint_,\n    uint256 unitPrice_,\n    uint256 vestingInDays_,\n    bytes32[] calldata proof_\n  ) internal {\n    (address minter, bool valid) = merkleListValid(\n      msg.sender,\n      sublist_,\n      quantityEligible_,\n      proof_,\n      unitPrice_,\n      vestingInDays_,\n      listMerkleRoot\n    );\n\n    MintStatus status;\n    (status, , ) = listMintStatus(sublist_.sublistInteger);\n    if (status != MintStatus.open) revert ThisListMintIsClosed();\n\n    if (!valid) revert ProofInvalid();\n    // See if this address has already minted its full allocation:\n\n    if (listMintAllocationMinted[minter][sublist_.sublistInteger] != 0)\n      revert RequestingMoreThanRemainingAllocation({\n        requested: quantityToMint_,\n        remainingAllocation: 0\n      });\n\n    listMintAllocationMinted[minter][\n      sublist_.sublistInteger\n    ] += quantityToMint_;\n\n    // Cache the next tokenId from the NFT:\n    uint256 nextTokenId = smashverseTitansContract.totalMinted();\n\n    smashverseSaleContract.listMint(\n      Sublist(0, 0),\n      totalFreeMintQuantity,\n      1,\n      0,\n      0,\n      freeMintProof\n    );\n\n    smashverseTitansContract.safeTransferFrom(\n      address(this),\n      msg.sender,\n      nextTokenId,\n      \"\"\n    );\n\n    emit SmashMint(\n      msg.sender,\n      MintingType.allowlistMint,\n      sublist_.sublistInteger,\n      quantityToMint_\n    );\n  }\n\n  /**\n   *\n   * @dev merkleListValid: Eligibility check for the merkleroot controlled minting. This can be called from front-end (for example to control\n   * screen components that indicate if the connected address is eligible) as well as from within the contract.\n   *\n   * Function flow is as follows:\n   * (1) Check that the address and eligible quantity are in the rafflelist.\n   *   -> (1a) If NOT then go to (2),\n   *   -> (1b) if it IS go to (4).\n   * (2) If (1) is false, check if the sender address is a proxy for a nominator,\n   *   -> (2a) If there is NO nominator exit with false eligibility and reason \"Mint proof invalid\"\n   *   -> (2b) if there IS a nominator go to (3)\n   * (3) Check if the nominator is in the rafflelist.\n   *   -> (3a) if NOT then exit with false eligibility and reason \"Mint proof invalid\"\n   *   -> (3b) if it IS then go to (4), having set the minter to the nominator which is the eligible address for this mint.\n   * (4) Check if this minter address has already minted. If so, exit with false eligibility and reason \"Requesting more than remaining allocation\"\n   * (5) All checks passed, return elibility = true, the delivery address and valid minter adress.\n   *\n   */\n  function merkleListValid(\n    address addressToCheck_,\n    Sublist memory sublist_,\n    uint256 quantityEligible_,\n    bytes32[] calldata proof_,\n    uint256 unitPrice_,\n    uint256 vestingInDays_,\n    bytes32 root_\n  ) public view returns (address minter, bool success) {\n    // Default delivery and minter address are the addresses passed in, which from the contract will be the msg.sender:\n    minter = addressToCheck_;\n\n    bytes32 leaf = _getListHash(\n      addressToCheck_,\n      sublist_,\n      quantityEligible_,\n      unitPrice_,\n      vestingInDays_\n    );\n\n    // (1) Check rafflelist for addressToCheck_:\n    if (MerkleProof.verify(proof_, root_, leaf) == false) {\n      // (2) addressToCheck_ is not on the list. Check if they are a cold EPS address for a hot EPS address:\n      if (address(epsDeligateRegister) != address(0)) {\n        address epsCold;\n        address[] memory epsAddresses;\n        (epsAddresses, ) = epsDeligateRegister.getAllAddresses(\n          addressToCheck_,\n          1\n        );\n\n        if (epsAddresses.length > 1) {\n          epsCold = epsAddresses[1];\n        } else {\n          return (minter, false);\n        }\n\n        // (3) If this matches a proxy record and the nominator isn't the addressToCheck_ we have a nominator to check\n        if (epsCold != addressToCheck_) {\n          leaf = _getListHash(\n            epsCold,\n            sublist_,\n            quantityEligible_,\n            unitPrice_,\n            vestingInDays_\n          );\n\n          if (MerkleProof.verify(proof_, root_, leaf) == false) {\n            // (3a) Not valid at either address. Say so and return\n            return (minter, false);\n          } else {\n            // (3b) There is a value at the nominator. The nominator is the minter, use it to check and track allowance.\n            minter = epsCold;\n          }\n        } else {\n          // (2a) Sender isn't on the list, and there is no proxy to consider:\n          return (minter, false);\n        }\n      }\n    }\n\n    // (5) Can only reach here for a valid address and quantity:\n    return (minter, true);\n  }\n\n  /**\n   *\n   * @dev _getListHash: Get hash of information for the rafflelist mint.\n   *\n   */\n  function _getListHash(\n    address minter_,\n    Sublist memory sublist_,\n    uint256 quantity_,\n    uint256 unitPrice_,\n    uint256 vestingInDays_\n  ) internal pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encodePacked(\n          minter_,\n          sublist_.sublistPosition,\n          quantity_,\n          unitPrice_,\n          vestingInDays_,\n          sublist_.sublistInteger\n        )\n      );\n  }\n\n  /**\n   *\n   * @dev checkAllocation: Eligibility check for all lists. Will return a count of remaining allocation (if any) and an optional\n   * status code.\n   */\n  function checkAllocation(\n    Sublist memory sublist_,\n    uint256 quantityEligible_,\n    uint256 unitPrice_,\n    uint256 vestingInDays_,\n    bytes32[] calldata proof_,\n    address addressToCheck_\n  ) external view returns (uint256 allocation, AllocationCheck statusCode) {\n    (address minter, bool valid) = merkleListValid(\n      addressToCheck_,\n      sublist_,\n      quantityEligible_,\n      proof_,\n      unitPrice_,\n      vestingInDays_,\n      listMerkleRoot\n    );\n\n    if (!valid) {\n      return (0, AllocationCheck.invalidProof);\n    } else {\n      allocation =\n        quantityEligible_ -\n        listMintAllocationMinted[minter][sublist_.sublistInteger];\n      if (allocation > 0) {\n        return (allocation, AllocationCheck.hasAllocation);\n      } else {\n        return (allocation, AllocationCheck.allocationExhausted);\n      }\n    }\n  }\n\n  // =======================================\n  // ADMINISTRATION\n  // =======================================\n\n  /**\n   *\n   * @dev setSublistConfig:\n   *\n   */\n  function setSublistConfig(\n    uint256 sublistInteger_,\n    uint256 start_,\n    uint256 end_,\n    uint256 supply_\n  ) external onlyOwner {\n    if (listDetailsLocked) {\n      revert ListDetailsLocked();\n    }\n\n    subListConfig[sublistInteger_].start = start_;\n    subListConfig[sublistInteger_].end = end_;\n    subListConfig[sublistInteger_].phaseMaxSupply = supply_;\n\n    emit SublistConfigSet(sublistInteger_, start_, end_, supply_);\n  }\n\n  /**\n   *\n   * @dev setList: Set the merkleroot\n   *\n   */\n  function setList(bytes32 merkleRoot_) external onlyOwner {\n    if (listDetailsLocked) {\n      revert ListDetailsLocked();\n    }\n\n    listMerkleRoot = merkleRoot_;\n\n    emit MerkleRootSet(merkleRoot_);\n  }\n\n  /**\n   *\n   *\n   * @dev setpublicMintStart: Allow owner to set minting open time.\n   *\n   *\n   */\n  function setpublicMintStart(uint32 time_) external onlyOwner {\n    if (publicMintingClosedForever) {\n      revert MintingIsClosedForever();\n    }\n    publicMintStart = time_;\n  }\n\n  /**\n   *\n   *\n   * @dev setpublicMintEnd: Allow owner to set minting closed time.\n   *\n   *\n   */\n  function setpublicMintEnd(uint32 time_) external onlyOwner {\n    if (publicMintingClosedForever) {\n      revert MintingIsClosedForever();\n    }\n    publicMintEnd = time_;\n  }\n\n  /**\n   *\n   *\n   * @dev setPublicMintingClosedForeverCannotBeUndone: Allow owner to set minting complete\n   * Enter confirmation value of \"SmashversePrimarySale\" to confirm that you are closing\n   * this mint forever.\n   *\n   *\n   */\n  function setPublicMintingClosedForeverCannotBeUndone(\n    string memory confirmation_\n  ) external onlyOwner {\n    string memory expectedValue = \"SmashversePrimarySale\";\n    if (\n      keccak256(abi.encodePacked(confirmation_)) ==\n      keccak256(abi.encodePacked(expectedValue))\n    ) {\n      publicMintEnd = uint32(block.timestamp);\n      publicMintingClosedForever = true;\n    } else {\n      revert IncorrectConfirmationValue();\n    }\n  }\n\n  /**\n   *\n   *\n   * @dev setListDetailsLockedForeverCannotBeUndone: Allow owner to set minting complete\n   * Enter confirmation value of \"SmashversePrimarySale\" to confirm that you are closing\n   * this mint forever.\n   *\n   *\n   */\n  function setListDetailsLockedForeverCannotBeUndone(\n    string memory confirmation_\n  ) external onlyOwner {\n    string memory expectedValue = \"SmashversePrimarySale\";\n    if (\n      keccak256(abi.encodePacked(confirmation_)) ==\n      keccak256(abi.encodePacked(expectedValue))\n    ) {\n      listDetailsLocked = true;\n    } else {\n      revert IncorrectConfirmationValue();\n    }\n  }\n\n  /**\n   *\n   *\n   * @dev pause: Allow owner to pause.\n   *\n   *\n   */\n  function pause() external onlyOwner {\n    require(\n      publicMintStart == 0 ||\n        block.timestamp < (publicMintStart + pauseCutOffInDays * 1 days),\n      \"Pause cutoff passed\"\n    );\n    _pause();\n  }\n\n  /**\n   *\n   *\n   * @dev unpause: Allow owner to unpause.\n   *\n   *\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   *\n   *\n   * @dev setEPSDelegateRegisterAddress. Owner can update the EPS DelegateRegister address\n   *\n   *\n   */\n  function setEPSDelegateRegisterAddress(address epsDelegateRegister_)\n    external\n    onlyOwner\n  {\n    epsDeligateRegister = IEPS_DR(epsDelegateRegister_);\n    emit EPSDelegateRegisterUpdated(epsDelegateRegister_);\n  }\n\n  /**\n   *\n   * @dev setProofsAndTotalQuantities\n   *\n   */\n  function setProofsAndTotalQuantities(\n    bytes32[] calldata mintPassProof_,\n    uint256 totalMintPassMintQuantity_,\n    bytes32[] calldata freeMintProof_,\n    uint256 totalFreeMintQuantity_\n  ) external onlyOwner {\n    mintPassProof = mintPassProof_;\n    totalMintPassMintQuantity = totalMintPassMintQuantity_;\n    freeMintProof = freeMintProof_;\n    totalFreeMintQuantity = totalFreeMintQuantity_;\n  }\n\n  // =======================================\n  // FINANCE\n  // =======================================\n\n  /**\n   *\n   *\n   * @dev withdrawETH: A withdraw function to allow ETH to be withdrawn to the vesting contract.\n   * Note that this can be performed by anyone, as all funds flow to the vesting contract only.\n   *\n   *\n   */\n  function withdrawETH(uint256 amount) external {\n    (bool success, ) = beneficiary.call{value: amount}(\"\");\n    if (!success) revert TransferFailed();\n  }\n\n  /**\n   *\n   *\n   * @dev withdrawERC20: A withdraw function to allow ERC20s to be withdrawn to the vesting contract.\n   * Note that this can be performed by anyone, as all funds flow to the vesting contract only.\n   *\n   *\n   */\n  function withdrawERC20(IERC20 token, uint256 amount) external {\n    token.transfer(beneficiary, amount);\n  }\n\n  /**\n   *\n   * @dev Revert unexpected ETH and function calls\n   *\n   */\n  receive() external payable {\n    require(msg.sender == owner(), \"Only owner can fund contract\");\n  }\n\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "contracts/EPS/IEPS_DR.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//* IEPS_DR: EPS Delegate Regsiter Interface\n//* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// EPS Contracts v2.0.0\n\npragma solidity ^0.8.17;\n\n/**\n *\n * @dev Interface for the EPS portal\n *\n */\n\n/**\n * @dev Returns the beneficiary of the `tokenId` token.\n */\ninterface IEPS_DR {\n  function beneficiaryOf(\n    address tokenContract_,\n    uint256 tokenId_,\n    uint256 rightsIndex_\n  ) external view returns (address beneficiary_);\n\n  /**\n   * @dev Returns the beneficiary balance for a contract.\n   */\n  function beneficiaryBalanceOf(\n    address queryAddress_,\n    address tokenContract_,\n    uint256 rightsIndex_\n  ) external view returns (uint256 balance_);\n\n  /**\n   * @dev beneficiaryBalance: Returns the beneficiary balance of ETH.\n   */\n  function beneficiaryBalance(address queryAddress_)\n    external\n    view\n    returns (uint256 balance_);\n\n  /**\n   * @dev beneficiaryBalanceOf1155: Returns the beneficiary balance for an ERC1155.\n   */\n  function beneficiaryBalanceOf1155(\n    address queryAddress_,\n    address tokenContract_,\n    uint256 id_\n  ) external view returns (uint256 balance_);\n\n  function getAddresses(address receivedAddress_, uint256 rightsIndex_)\n    external\n    view\n    returns (address[] memory proxyAddresses_, address delivery_);\n\n  function getAddresses1155(address receivedAddress_, uint256 rightsIndex_)\n    external\n    view\n    returns (address[] memory proxyAddresses_, address delivery_);\n\n  function getAddresses20(address receivedAddress_, uint256 rightsIndex_)\n    external\n    view\n    returns (address[] memory proxyAddresses_, address delivery_);\n\n  function getAllAddresses(address receivedAddress_, uint256 rightsIndex_)\n    external\n    view\n    returns (address[] memory proxyAddresses_, address delivery_);\n\n  /**\n   * @dev coldIsLive: Return if a cold wallet is live\n   */\n  function coldIsLive(address cold_) external view returns (bool);\n\n  /**\n   * @dev hotIsLive: Return if a hot wallet is live\n   */\n  function hotIsLive(address hot_) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}