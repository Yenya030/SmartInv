{{
  "language": "Solidity",
  "sources": {
    "lib/ERC721A/contracts/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
    },
    "src/interfaces/IERC721Drop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IMetadataRenderer} from \"../interfaces/IMetadataRenderer.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n*/\n/// @notice Interface for ZORA Drops contract\ninterface IERC721Drop {\n    // Access errors\n\n    /// @notice Only admin can access this function\n    error Access_OnlyAdmin();\n    /// @notice Missing the given role or admin access\n    error Access_MissingRoleOrAdmin(bytes32 role);\n    /// @notice Withdraw is not allowed by this user\n    error Access_WithdrawNotAllowed();\n    /// @notice Cannot withdraw funds due to ETH send failure.\n    error Withdraw_FundsSendFailure();\n    /// @notice Missing the owner role.\n    error Access_OnlyOwner();\n    /// @notice Missing the owner role or approved nft access.\n    error Access_MissingOwnerOrApproved();\n\n    // CRE8ING errors\n    /// @notice Cre8ing Closed\n    error Cre8ing_Cre8ingClosed();\n    /// @notice Cre8ing\n    error Cre8ing_Cre8ing();\n\n    // Sale/Purchase errors\n    /// @notice Sale is inactive\n    error Sale_Inactive();\n    /// @notice Presale is inactive\n    error Presale_Inactive();\n    /// @notice Presale merkle root is invalid\n    error Presale_MerkleNotApproved();\n    /// @notice Wrong price for purchase\n    error Purchase_WrongPrice(uint256 correctPrice);\n    /// @notice NFT sold out\n    error Mint_SoldOut();\n    /// @notice Too many purchase for address\n    error Purchase_TooManyForAddress();\n    /// @notice Too many presale for address\n    error Presale_TooManyForAddress();\n\n    // Admin errors\n    /// @notice Royalty percentage too high\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n    /// @notice Invalid admin upgrade address\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n    error Admin_UnableToFinalizeNotOpenEdition();\n\n    /// @notice Event emitted for each sale\n    /// @param to address sale was made to\n    /// @param quantity quantity of the minted nfts\n    /// @param pricePerToken price for each token\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n    event Sale(\n        address indexed to,\n        uint256 indexed quantity,\n        uint256 indexed pricePerToken,\n        uint256 firstPurchasedTokenId\n    );\n\n    /// @notice Sales configuration has been changed\n    /// @dev To access new sales configuration, use getter function.\n    /// @param changedBy Changed by user\n    event SalesConfigChanged(address indexed changedBy);\n\n    /// @notice Event emitted when the funds recipient is changed\n    /// @param newAddress new address for the funds recipient\n    /// @param changedBy address that the recipient is changed by\n    event FundsRecipientChanged(\n        address indexed newAddress,\n        address indexed changedBy\n    );\n\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\n    /// @param withdrawnBy address that issued the withdraw\n    /// @param withdrawnTo address that the funds were withdrawn to\n    /// @param amount amount that was withdrawn\n    event FundsWithdrawn(\n        address indexed withdrawnBy,\n        address indexed withdrawnTo,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n    /// @param sender address sending close mint\n    /// @param numberOfMints number of mints the contract is finalized at\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n    /// @notice Event emitted when metadata renderer is updated.\n    /// @param sender address of the updater\n    /// @param renderer new metadata renderer address\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n    /// @notice General configuration for NFT Minting and bookkeeping\n    struct Configuration {\n        /// @dev Metadata renderer (uint160)\n        IMetadataRenderer metadataRenderer;\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\n        uint64 editionSize;\n        /// @dev Royalty amount in bps (uint224+16 = 240)\n        uint16 royaltyBPS;\n        /// @dev Funds recipient for sale (new slot, uint160)\n        address payable fundsRecipient;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct SalesConfiguration {\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\n    struct BurnConfiguration {\n        /// @dev Token to burn\n        address burnToken;\n        /// @dev Required number of tokens to burn\n        uint256 burnQuantity;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct ERC20SalesConfiguration {\n        /// @notice Public sale price\n        /// @dev max ether value > 1000 ether with this value\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct SaleDetails {\n        // Synthesized status variables for sale and presale\n        bool publicSaleActive;\n        bool presaleActive;\n        // Price for public sale\n        uint256 publicSalePrice;\n        // Timed sale actions for public sale\n        uint64 publicSaleStart;\n        uint64 publicSaleEnd;\n        // Timed sale actions for presale\n        uint64 presaleStart;\n        uint64 presaleEnd;\n        // Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        // Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        // Information about the rest of the supply\n        // Total that have been minted\n        uint256 totalMinted;\n        // The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct ERC20SaleDetails {\n        /// @notice Synthesized status variables for sale\n        bool publicSaleActive;\n        /// @notice Synthesized status variables for presale\n        bool presaleActive;\n        /// @notice Price for public sale\n        uint256 publicSalePrice;\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\n        address erc20PaymentToken;\n        /// @notice public sale start\n        uint64 publicSaleStart;\n        /// @notice public sale end\n        uint64 publicSaleEnd;\n        /// @notice Timed sale actions for presale start\n        uint64 presaleStart;\n        /// @notice Timed sale actions for presale end\n        uint64 presaleEnd;\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        /// @notice Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        /// @notice Total that have been minted\n        uint256 totalMinted;\n        /// @notice The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return type of specific mint counts and details per address\n    struct AddressMintDetails {\n        /// Number of total mints from the given address\n        uint256 totalMints;\n        /// Number of presale mints from the given address\n        uint256 presaleMints;\n        /// Number of public mints from the given address\n        uint256 publicMints;\n    }\n\n    /// @notice External purchase function (payable in eth)\n    /// @param quantity to purchase\n    /// @return first minted token ID\n    function purchase(uint256 quantity) external payable returns (uint256);\n\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n    /// @param quantity to purchase\n    /// @param maxQuantity can purchase (verified by merkle root)\n    /// @param pricePerToken price per token allowed (verified by merkle root)\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\n    /// @return first minted token ID\n    function purchasePresale(\n        uint256 quantity,\n        uint256 maxQuantity,\n        uint256 pricePerToken,\n        bytes32[] memory merkleProof\n    ) external payable returns (uint256);\n\n    /// @notice Function to return the global sales details for the given drop\n    function saleDetails() external view returns (ERC20SaleDetails memory);\n\n    /// @notice Function to return the specific sales details for a given address\n    /// @param minter address for minter to return mint information for\n    function mintedPerAddress(\n        address minter\n    ) external view returns (AddressMintDetails memory);\n\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\n    function owner() external view returns (address);\n\n    /// @notice Update the metadata renderer\n    /// @param newRenderer new address for renderer\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n    function setMetadataRenderer(\n        IMetadataRenderer newRenderer,\n        bytes memory setupRenderer\n    ) external;\n\n    /// @notice This is an admin mint function to mint a quantity to a specific address\n    /// @param to address to mint to\n    /// @param quantity quantity to mint\n    /// @return the id of the first minted NFT\n    function adminMint(address to, uint256 quantity) external returns (uint256);\n\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n    /// @param to list of addresses to mint an NFT each to\n    /// @return the id of the first minted NFT\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n    /// @dev Getter for admin role associated with the contract to handle metadata\n    /// @return boolean if address is admin\n    function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interfaces/IMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\ninterface IMetadataRenderer {\n    function tokenURI(uint256) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function initializeWithData(bytes memory initData) external;\n}\n"
    },
    "src/minter/BurnCrosschainMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC721A} from \"lib/ERC721A/contracts/IERC721A.sol\";\nimport {IERC721Drop} from \"../interfaces/IERC721Drop.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n */\ncontract BurnCrosschainMinter {\n    /// @notice Storage for contract mint information\n    struct ContractMintInfo {\n        string secretPasscode;\n    }\n\n    /// @notice incorrect code error\n    error Code_Incorrect();\n\n    /// @notice Event for a new contract initialized\n    /// @dev admin function indexer feedback\n    event NewMinterInitialized(address indexed target);\n\n    /// @notice Contract information mapping storage\n    mapping(address => ContractMintInfo) internal _contractInfos;\n    mapping(address => uint256) internal _balances;\n\n    /// @dev Gas limit to send funds\n    uint256 internal constant FUNDS_SEND_GAS_LIMIT = 210_000;\n\n    /// @notice Getter for admin role associated with the contract to handle minting\n    /// @param target target for contract to check admin\n    /// @param user user address\n    /// @return boolean if address is admin\n    function isAdmin(address target, address user) public view returns (bool) {\n        return IERC721Drop(target).isAdmin(user);\n    }\n\n    /// @notice Default initializer for burn data from a specific contract\n    /// @param target target for contract to set mint data\n    /// @param data data to init with\n    function initializeWithData(\n        address target,\n        bytes memory data\n    ) external onlyAdmin(target) {\n        (bytes32 hashedFrom, uint256 burnQuantity, string memory passcode) = abi\n            .decode(data, (bytes32, uint256, string));\n        _contractInfos[target] = ContractMintInfo({secretPasscode: passcode});\n        emit NewMinterInitialized({target: target});\n    }\n\n    /// @notice mint function\n    /// @dev This allows the user to purchase an edition\n    /// @dev at the given price in the contract.\n    /// @param target target for contract to purchase\n    function purchase(\n        address target,\n        bytes calldata data\n    ) external payable returns (uint256) {\n        (\n            bytes32 hashedFrom,\n            uint256 burnQuantity,\n            bytes32 encryptedPasscode\n        ) = abi.decode(data, (bytes32, uint256, bytes32));\n\n        verifyCode(target, encryptedPasscode);\n        uint256 salePrice = calculateDiscountedPrice(target, burnQuantity);\n\n        if (msg.value != salePrice) {\n            revert IERC721Drop.Purchase_WrongPrice(salePrice);\n        }\n\n        _balances[target] += msg.value;\n\n        uint256 firstMintedTokenId = IERC721Drop(target).adminMint(\n            msg.sender,\n            1\n        );\n\n        return firstMintedTokenId;\n    }\n\n    /// @notice calculates discount for relics burned\n    /// @param target target for contract to calculate discount\n    /// @param burnQuantity number of relics to burn\n    function calculateDiscountedPrice(\n        address target,\n        uint256 burnQuantity\n    ) internal view returns (uint256) {\n        require(burnQuantity < 89, \"CRE8ORS: max burn 88\");\n        uint256 price = IERC721Drop(target).saleDetails().publicSalePrice;\n        uint256 discountPerRelic = (price / 88);\n        return price - (discountPerRelic * burnQuantity);\n    }\n\n    /// @notice This withdraws ETH from the contract to the contract owner.\n    /// @param target target for contract to withdraw\n    function withdraw(address target) external {\n        // Get fee amount\n        uint256 funds = _balances[target];\n\n        // Payout recipient\n        (bool successFunds, ) = IERC721Drop(target).owner().call{\n            value: funds,\n            gas: FUNDS_SEND_GAS_LIMIT\n        }(\"\");\n        if (!successFunds) {\n            revert IERC721Drop.Withdraw_FundsSendFailure();\n        }\n    }\n\n    /// @notice verifies code\n    function verifyCode(address target, bytes32 code) internal view {\n        bytes32 wad = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _contractInfos[target].secretPasscode,\n                IERC721Drop(target).mintedPerAddress(msg.sender).totalMints\n            )\n        );\n        if (code != wad) {\n            revert Code_Incorrect();\n        }\n    }\n\n    /////////////////////////////////////////////////\n    /// MODIFIERS\n    /////////////////////////////////////////////////\n\n    /// @notice Only allow for users with admin access\n    /// @param target target for contract to check admin access\n    modifier onlyAdmin(address target) {\n        if (!isAdmin(target, msg.sender)) {\n            revert IERC721Drop.Access_OnlyAdmin();\n        }\n\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "remappings": [
      ":@ERC721A/=lib/ERC721A/",
      ":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      ":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      ":ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",
      ":ERC721A/=lib/ERC721A/contracts/",
      ":base64/=lib/base64/",
      ":ds-test/=lib/ds-test/src/",
      ":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      ":erc721a-upgradeable/=lib/ERC721A-Upgradeable/contracts/",
      ":forge-std/=lib/forge-std/src/",
      ":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      ":openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/"
    ],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}