{{
  "language": "Solidity",
  "sources": {
    "/contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface ERC721 /* is ERC165 */ {\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    function balanceOf(address _owner) external view returns (uint256);\n    function ownerOf(uint256 _tokenId) external view returns (address);\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function approve(address _approved, uint256 _tokenId) external payable;\n    function setApprovalForAll(address _operator, bool _approved) external;\n    function getApproved(uint256 _tokenId) external view returns (address);\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract Staking is Ownable, IERC721Receiver {\n    mapping(uint=>uint) public stakingStartTime;   // Timestamp of when the staking started.\n    mapping(uint=>address) public tokenOwner;      // Owner of the token\n    mapping(uint=>uint) public tokenLevel;         // Level of the token\n    mapping(uint=>uint) public lastClaimTime;      // Timestamp of when the user last claimed.\n    mapping(address=>uint[]) public stakers;       // stakers mapped to tokens\n\n\n    uint public reward = 10;        // Basic Reward\n    uint public maxLevel = 20;\n    ERC721 erc721;  // NFT contract\n    ERC20 erc20;    // Reward Token Contract\n\n    bool public stakingStarted;\n    uint public stakingPeriod = 24 hours;\n\n    /**\n     * @dev Sets the NFT contract.\n        Can only be called by the current owner.\n     * @notice\n        Once you deployed this smart contract, don't forget to call this method.\n    */\n    function setErc721(address addr) public onlyOwner {\n        erc721 = ERC721(addr);\n    }\n\n    /**\n     * @dev Sets the ERC20 reward contract.\n        Can only be called by the current owner.\n     * @notice\n        Once you deployed this smart contract, don't forget to call this method.\n    */\n    function setErc20(address addr) public onlyOwner {\n        erc20 = ERC20(addr);\n    }\n\n    /**\n     * @dev Sets if the staking is started or not.\n        Can only be called by the current owner.\n     * @notice\n        The staking works only after you set the staking 'true'\n    */\n    function setStakingStarted(bool s) public onlyOwner {\n        stakingStarted = s;\n    }\n\n    function setMaxLevel(uint _level) public onlyOwner {\n        maxLevel = _level;\n    }\n\n    /**\n     * @dev Starts staking of the 'tokenId'\n        Can only be called by the owner of the tokenId\n    */\n    function stake(uint tokenId, uint level) external {\n        require(level > 0, \"below 0\");\n        require(level <= maxLevel, \"over max level\");\n        require(erc721.ownerOf(tokenId) == msg.sender, \"You are not the owner.\");\n        require(stakingStartTime[tokenId] == 0, \"The Token is already on staking.\");\n\n        stakers[msg.sender].push(tokenId);\n        erc721.safeTransferFrom(msg.sender, address(this), tokenId);\n        stakingStartTime[tokenId] = block.timestamp;\n        tokenOwner[tokenId] = msg.sender;\n        tokenLevel[tokenId] = level;\n        lastClaimTime[tokenId] = block.timestamp;\n    }\n\n\n    function getStakedTokens(address _user) public view returns (uint[] memory)\n    {\n        return stakers[_user];\n    }\n\n    /**\n     * @dev Unstake 'tokenId'\n        Can only be called by the owner of the tokenId\n        Can only be called 1 day after staking\n    */\n    function unstake(uint tokenId) external {\n        require(stakingStartTime[tokenId] > 0, \"This token is not on staking.\");\n        require(tokenOwner[tokenId] == msg.sender, \"You are not the owner of this token.\");\n\n        uint rwd = calcReward(tokenId);\n\n        if(rwd > 0) {\n            erc20.transfer(msg.sender, rwd * 10 ** 18);\n        }\n\n        erc721.safeTransferFrom(address(this), tokenOwner[tokenId], tokenId);\n        uint256 index = indexOf(stakers[msg.sender], tokenId);\n        delete stakers[msg.sender][index];\n        stakingStartTime[tokenId] = 0;\n        lastClaimTime[tokenId] = 0;\n\n        tokenOwner[tokenId] = address(0);\n    }\n\n    function indexOf(uint256[] memory arr, uint256 searchFor) private returns (uint256) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] == searchFor) {\n                return i;\n            }\n        }\n        revert(\"Not Found\");\n    }\n\n    /**\n     * @dev Unstake 'tokenId'\n        Can only be called by the owner of the tokenId\n        Can only be called 1 day after the last claim\n    */\n    function claimReward(uint tokenId) external {\n        require(stakingStartTime[tokenId] > 0, \"This token is not on staking.\");\n        require(tokenOwner[tokenId] == msg.sender, \"You are not the owner of this token.\");\n\n        uint rwd = calcReward(tokenId);\n        require(rwd > 0, \"You don't have funds to claim.\");\n        erc20.transfer(msg.sender, rwd * 10 ** 18);\n        lastClaimTime[tokenId] = block.timestamp - (block.timestamp - lastClaimTime[tokenId]) % (stakingPeriod);\n    }\n\n    /**\n     * @dev Calculates the reward of 'tokenId'\n    */\n    function calcReward(uint tokenId) public view returns(uint) {\n        uint rwd;\n        if(lastClaimTime[tokenId] > 0) {\n            rwd = (reward + tokenLevel[tokenId]) * ((block.timestamp - lastClaimTime[tokenId]) / stakingPeriod);\n        }\n        return rwd;\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external override returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}