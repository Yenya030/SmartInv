{{
  "language": "Solidity",
  "sources": {
    "lib/Bytes2.0/contracts/Staking/NeoTokyoStaker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../access/PermitControl.sol\";\nimport \"../interfaces/IByteContract.sol\";\nimport \"../interfaces/IGenericGetter.sol\";\nimport \"../interfaces/INTStakedToken.sol\";\n\n/**\n\tThrown when attempting to operate on a non-existent Citizen (S1 or S2).\n\n\t@param citizenId The ID of the caller's specified Citizen.\n*/\nerror CitizenDoesNotExist (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to get a staker's position of an unknowable asset type.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnknowablePosition (\n\tuint256 assetType\n);\n\n/**\n\tThrown when an S1 Citizen with a component Vault attempts to stake while \n\tattaching an optional non-component Vault.\n\n\t@param componentVaultId The ID of the S1 Citizen's component Vault.\n\t@param noncomponentVaultId The ID of the Vault the caller attempted to stake.\n*/\nerror CitizenAlreadyHasVault (\n\tuint256 componentVaultId,\n\tuint256 noncomponentVaultId\n);\n\n/**\n\tThrown when an S1 Citizen attempts to wrongfully claim the Hand bonus.\n\n\t@param citizenId The ID of the caller's specified S1 Citizen.\n*/\nerror CitizenIsNotHand (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when a BYTES stake would exceed the cap of its corresponding Citizen.\n\n\t@param attemptedAmount The amount that the user is attempting to stake to.\n\t@param cap The staking cap of the Citizen.\n*/\nerror AmountExceedsCap (\n\tuint256 attemptedAmount,\n\tuint256 cap\n);\n\n/**\n\tThrown when attempting to stake BYTES into an unowned Citizen.\n\n\t@param citizenId The token ID of the Citizen involved in the attempted stake.\n\t@param seasonId The season ID of the Citizen, whether S1 or S2.\n*/\nerror CannotStakeIntoUnownedCitizen (\n\tuint256 citizenId,\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to stake BYTES into an invalid Citizen season.\n\n\t@param seasonId The ID of the Citizen season to try staking BYTES into.\n*/\nerror InvalidSeasonId (\n\tuint256 seasonId\n);\n\n/**\n\tThrown when attempting to increase a stake in an asset without matching the \n\texisting timelock of the asset.\n*/\nerror MismatchedTimelock ();\n\n/**\n\tThrown during staking or unstaking if an invalid AssetType is specified.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InvalidAssetType (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an unconfigured asset pool.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror UnconfiguredPool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if attempting to stake into an asset pool whose rewards \n\tare not yet active.\n\n\t@param assetType The caller's specified asset type.\n*/\nerror InactivePool (\n\tuint256 assetType\n);\n\n/**\n\tThrown during staking if an invalid timelock option is specified. Each \n\tAssetType being staked may have independently-configured timelock options.\n\n\t@param assetType The caller's specified asset type.\n\t@param timelockId The caller's specified timelock ID against `assetType`.\n*/\nerror InvalidTimelockOption (\n\tuint256 assetType,\n\tuint256 timelockId\n);\n\n/// Thrown if the caller of a function is not the BYTES contract.\nerror CallerIsNotBYTES ();\n\n/**\n\tThrown when withdrawing an asset fails to clear a timelock.\n\t\n\t@param endTime The time that the staked asset timelock ends.\n*/\nerror TimelockNotCleared (\n\tuint256 endTime\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S1 Citizen.\n\n\t@param citizenId The ID of the S1 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS1 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown when attempting to withdraw an unowned S2 Citizen.\n\n\t@param citizenId The ID of the S2 Citizen attempted to be withdrawn.\n*/\nerror CannotWithdrawUnownedS2 (\n\tuint256 citizenId\n);\n\n/**\n\tThrown if a caller tries to withdraw more LP tokens than they had staked.\n\n\t@param attemptedWithdraw The amount of LP tokens that the caller attempted to \n\t\twithdraw.\n\t@param position The amount of LP tokens that the caller has actually staked.\n*/\nerror NotEnoughLPTokens (\n\tuint256 attemptedWithdraw,\n\tuint256 position\n);\n\n/// Thrown if attempting to configure the LP token address post-lock.\nerror LockedConfigurationOfLP ();\n\n/// Thrown when specifying invalid reward windows for a pool.\nerror RewardWindowTimesMustIncrease ();\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title A pool-based staking contract for the Neo Tokyo ecosystem.\n\t@author Tim Clancy <tim-clancy.eth>\n\t@author Rostislav Khlebnikov <catpic5buck.eth>\n\n\tThis contract allows callers to stake their Neo Tokyo Citizens (both S1 and \n\tS2) and BYTES for\ttime-locked emission rewards. The staker operates on a \n\tpoint-based, competitive system where stakers compete for a finite amount of \n\tdaily emissions. It allows permissioned managers to configure various \n\temission details for the Neo Tokyo ecosystem.\n\n\t@custom:date February 14th, 2023.\n*/\ncontract NeoTokyoStaker is PermitControl, ReentrancyGuard {\n\n\t/// The `transferFrom` selector for ERC-20 and ERC-721 tokens.\n\tbytes4 constant private _TRANSFER_FROM_SELECTOR = 0x23b872dd;\n\n\t/// The `transfer` selector for ERC-20 tokens.\n\tbytes4 constant private _TRANSFER_SELECTOR = 0xa9059cbb;\n\n\t/// A constant multiplier to reduce overflow in staking calculations.\n\tuint256 constant private _PRECISION = 1e12;\n\n\t/// A constant divisor to calculate points and multipliers as basis points.\n\tuint256 constant private _DIVISOR = 100;\n\n\t/// The number of BYTES needed to get one point in BYTES staking calculations.\n\tuint256 constant private _BYTES_PER_POINT = 200 * 1e18;\n\n\t/// The identifier for the right to configure the LP token address.\n\tbytes32 public constant CONFIGURE_LP = keccak256(\"CONFIGURE_LP\");\n\n\t/// The identifier for the right to configure timelock options.\n\tbytes32 public constant CONFIGURE_TIMELOCKS = keccak256(\n\t\t\"CONFIGURE_TIMELOCKS\"\n\t);\n\n\t/// The identifier for the right to configure Identity and Vault points.\n\tbytes32 public constant CONFIGURE_CREDITS = keccak256(\"CONFIGURE_CREDITS\");\n\n\t/// The identifier for the right to configure emission rates and the DAO tax.\n\tbytes32 public constant CONFIGURE_POOLS = keccak256(\"CONFIGURE_POOLS\");\n\n\t/// The identifier for the right to configure BYTES staking caps.\n\tbytes32 public constant CONFIGURE_CAPS = keccak256(\"CONFIGURE_CAPS\");\n\n\t/// The address of the new BYTES 2.0 token contract.\n\taddress immutable public BYTES;\n\n\t/// The address of the assembled Neo Tokyo S1 Citizen contract.\n\taddress immutable public S1_CITIZEN;\n\n\t/// The address of the assembled Neo Tokyo S2 Citizen contract.\n\taddress immutable public S2_CITIZEN;\n\n\t/// The address of the LP token contract.\n\taddress public LP;\n\n\t/**\n\t\tThe address of the Neo Tokyo S1 Identity contract. This specific contract \n\t\taddress is stored to check an assembled S1 Citizen's specific component \n\t\tidentity in order to check for Hands of the Citadel.\n\t*/\n\taddress immutable public IDENTITY;\n\n\t/// The address of the Neo Tokyo S1 Vault contract.\n\taddress immutable public VAULT;\n\n\n\t// The address of the soulbound token that is given to wallets upon staking a citizen\n\t// and burned upon unstaking.    \n\taddress public NT_STAKED_CITIZEN;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S1 Citizen \n\t\tassembled with a component Vault or per Vault-less S1 Citizen staked \n\t\talongside a Vault.\n\t*/\n\tuint256 public VAULT_CAP;\n\n\t/**\n\t\tThe limit on the number of BYTES that may be staked per S2 Citizen or S1 \n\t\tCitizen without Vault.\n\t*/\n\tuint256 public NO_VAULT_CAP;\n\n\t/**\n\t\tThis enum tracks each type of asset that may be operated on with this \n\t\tstaker.\n\n\t\t@param S1_CITIZEN A staked Neo Tokyo S1 Citizen.\n\t\t@param S2_CITIZEN A staked Neo Tokyo S2 Citizen.\n\t\t@param BYTES A set of staked BYTES ERC-20 token.\n\t\t@param LP Staked BYTES-ETH LP ERC-20 token.\n\t*/\n\tenum AssetType {\n\t\tS1_CITIZEN,\n\t\tS2_CITIZEN,\n\t\tBYTES,\n\t\tLP\n\t}\n\n\t/**\n\t\tThis mapping contains the per-asset configuration of different timelock \n\t\tperiods with their associated multipliers. For each asset, the interior \n\t\tmapping correlates a particular timelock option to a uint256 which encodes \n\t\tthe duration of the timelock in its upper 128 bits and the multiplier \n\t\toffered by that timelock, as basis points, in its lower 128 bits.\n\t*/\n\tmapping ( AssetType => mapping ( uint256 => uint256 )) public\ttimelockOptions;\n\n\t/**\n\t\tThis struct defines a specific time window in reward emission history. For \n\t\ta particular asset staking pool, it represents that beginning from \n\t\t`startTime`, the pool had a per-second reward emission rate of `reward`.\n\n\t\t@param startTime The time at which the daily reward activated.\n\t\t@param reward The reward emission rate beginning at `startTime`.\n\t*/\n\tstruct RewardWindow {\n\t\tuint128 startTime;\n\t\tuint128 reward;\n\t}\n\n\t/**\n\t\tThis struct is used to define both the configuration details for a \n\t\tparticular asset staking pool and the state of that pool as callers begin \n\t\tinteracting with it.\n\n\t\t@param totalPoints The total number of points in the pool.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardPerPoint The cumulative rewards earned for each point in the pool.\n\t\t@param lastUpdated The time at which this pool's points were last updated.\n\t\t@param rewardCount A count of the number of reward windows in the \n\t\t\t`rewardWindows` mapping, used for iterating.\n\t\t@param rewardWindows A mapping of the historic amount of BYTES token \t\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolData {\n\t\tuint256 totalPoints;\n\t\tuint256 daoTax;\n\t\tuint256 rewardPerPoint;\n\t\tuint256 lastUpdated;\n\t\tuint256 rewardCount;\n\t\tmapping ( uint256 => RewardWindow ) rewardWindows;\n\t\tmapping ( address => uint256 ) rewardsMissed;\n\t}\n\n\t/// Map an asset type to its corresponding pool data. \n\tmapping ( AssetType => PoolData ) private _pools;\n\t\n\t/// Track the last time a caller was granted their rewards for each asset.\n\tmapping ( address => mapping ( AssetType => uint256 )) public lastRewardTime;\n\n\t/// Track the total reward amount earnings accrued to a particular caller.\n\tmapping ( address => mapping ( AssetType => uint256 )) public rewardAccrued;\n\n\t/** \n\t\tThis admin-configurable double-mapping allows us to deduce the Identity \n\t\t\"Credit Yield\" string of a Neo Tokyo S1 Citizen given the Citizen's reward \n\t\trate and the reward rate of the Citizen's Vault.\n\t*/\n\tmapping ( uint256 => mapping ( string => string )) public identityCreditYield;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Identity credit. \n\tmapping ( string => uint256 ) public identityCreditPoints;\n\n\t/// Assign a configurable multiplier to each S1 Citizen's Vault credit. \n\tmapping ( string => uint256 ) public vaultCreditMultiplier;\n\n\t/**\n\t\tThis struct records the state of each staked S1 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S1 Citizen token ID to \n\t\tthe staking status of each S1 Citizen. This records the unique per-user \n\t\tstaking status of each S1 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS1Citizen )) public stakedS1;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S1 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS1Position;\n\n\t/**\n\t\tThis struct records the state of each staked S2 Citizen.\n\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2Citizen {\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tA double mapping from a caller address to a specific S2 Citizen token ID to \n\t\tthe staking status of each S2 Citizen. This records the unique per-user \n\t\tstaking status of each S2 citizen.\n\t*/\n\tmapping ( address => mapping( uint256 => StakedS2Citizen )) public stakedS2;\n\n\t/**\n\t\tThis mapping correlates a caller address to a list of their \n\t\tcurrently-staked S2 Citizen token IDs.\n\t*/\n\tmapping ( address => uint256[] ) private _stakerS2Position;\n\n\t/**\n\t\tThis struct defines the LP token staking position of a particular staker.\n\n\t\t@param amount The amount of LP tokens staked by the staker.\n\t\t@param timelockEndTime The tiume at which the forced, timelocked staking of \n\t\t\tthese LP tokens ends. After this the LP tokens may be withdrawn.\n\t\t@param points The number of points that this LP position accrues.\n\t\t@param multiplier The multiplier portion of the timelock option recorded so \n\t\t\tas to enforce later stakes to use the same point rate.\n\t*/\n\tstruct LPPosition {\n\t\tuint256 amount;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 multiplier;\n\t}\n\n\t/**\n\t\tThis mapping correlates each caller address to details regarding the LP \n\t\ttoken stake of that caller.\n\t*/\n\tmapping ( address => LPPosition ) public stakerLPPosition;\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S1 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S1 \n\t\t\tCitizen. Depending on the value of `hasVault`, this S1 Citizen  will be \n\t\t\tbound to either the `VAULT_CAP` limit or `NO_VAULT_CAP` limit on the \n\t\t\tnumber of BYTES that may be staked.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S1 Citizen ends. After this time the S1 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S1 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S1 Citizen's base \n\t\t\tpoints are a function of the S1 Citizen's component Identity and any \n\t\t\tassociated Vault multiplier. The base points are also multiplied by the \n\t\t\ttimelock option chosen at the time of staking. The base points are \n\t\t\tsupplemented in points calculations by the value of `stakedBytes`.\n\t\t@param stakedVaultId The optional ID of the Vault, if there is one, that \n\t\t\thas been staked alongside this S1 Citizen. If `hasVault` is true, this \n\t\t\tvalue may be non-zero to indicate a staked but non-component Vault. If \n\t\t\t`hasVault` is true and this value is zero, that is indicative of an S1 \n\t\t\tCitizen with a component Vault.\n\t\t@param hasVault A boolean indicating whether or not this S1 Citizen has an \n\t\t\tassociated Vault, whether that Vault is a component Vault assembled into \n\t\t\tthe S1 Citizen or one that has been staked alongside the S1 Citizen.\n\t*/\n\tstruct StakedS1CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t\tuint256 stakedVaultId;\n\t\tbool hasVault;\n\t}\n\n\t/**\n\t\tThis struct supplies the position output state of each staked S2 Citizen.\n\n\t\t@param citizenId The token ID of this S1 Citizen.\n\t\t@param stakedBytes The number of BYTES that have been staked into this S2 \n\t\t\tCitizen.\n\t\t@param timelockEndTime The time at which the forced, timelocked staking of \n\t\t\tthis S2 Citizen ends. After this time the S2 Citizen may be withdrawn \n\t\t\tfrom the staker.\n\t\t@param points The number of base points that this staked S2 Citizen is \n\t\t\tworth, thus determining its share of emissions. An S2 Citizen's base \n\t\t\tpoints are a function of the timelock option chosen at the time of \n\t\t\tstaking. The base points are supplemented in points calculations by the \n\t\t\tvalue of `stakedBytes`.\n\t*/\n\tstruct StakedS2CitizenOutput {\n\t\tuint256 citizenId;\n\t\tuint256 stakedBytes;\n\t\tuint256 timelockEndTime;\n\t\tuint256 points;\n\t}\n\n\t/**\n\t\tThis struct records the state of all assets staked by a particular staker \n\t\taddress in this staker.\n\n\t\t@param stakedS1Citizens An array containing information about each S1 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedS2Citizens An array containing information about each S2 \n\t\t\tCitizen staked by a particular staker address.\n\t\t@param stakedLPPosition Details regarding the LP token stake of a particular\n\t\t\tstaker address.\n\t*/\n\tstruct StakerPosition {\n\t\tStakedS1CitizenOutput[] stakedS1Citizens;\n\t\tStakedS2CitizenOutput[] stakedS2Citizens;\n\t\tLPPosition stakedLPPosition;\n\t}\n\n\t/// Whether or not setting the LP token contract address is locked.\n\tbool public lpLocked;\n\n\t/**\n\t\tThis struct records an input to the staker's `configurePools` function.\n\n\t\t@param assetType The asset type for the corresponding pool to set.\n\t\t@param daoTax The percent, in basis points, of the reward emissions sent to \n\t\t\tthe DAO.\n\t\t@param rewardWindows An array specifying the historic amount of BYTES token\n\t\t\trewarded per-second across all stakers in this particular pool.\n\t*/\n\tstruct PoolConfigurationInput {\n\t\tAssetType assetType;\n\t\tuint256 daoTax;\n\t\tRewardWindow[] rewardWindows;\n\t}\n\n\t/**\n\t\tThis event is emitted when an asset is successfully staked.\n\n\t\t@param staker The address of the caller who staked an `asset`.\n\t\t@param asset The address of the asset being staked.\n\t\t@param timelockOption Data encoding the parameters surrounding the timelock \n\t\t\toption used in staking the particular asset. Alternatively, this encodes \n\t\t\tctiizen information for BYTES staking.\n\t\t@param amountOrTokenId The amount of `asset` staked or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token staked.\n\t*/\n\tevent Stake (\n\t\taddress indexed staker,\n\t\taddress indexed asset,\n\t\tuint256 timelockOption,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tThis event is emitted each time a recipient claims a reward.\n\n\t\t@param recipient The recipient of the reward.\n\t\t@param reward The amount of BYTES rewarded to the `recipient`.\n\t\t@param tax The amount of BYTES minted as tax to the DAO.\n\t*/\n\tevent Claim (\n\t\taddress indexed recipient,\n\t\tuint256 reward,\n\t\tuint256 tax\n\t);\n\n\t/**\n\t\tThis event is emitted when an asset is successfully withdrawn.\n\n\t\t@param caller The address of the caller who withdrew an `asset`.\n\t\t@param asset The address of the asset being withdrawn.\n\t\t@param amountOrTokenId The amount of `asset` withdrawn or, for S1 and S2 \n\t\t\tCitizens, the ID of the specific token withdrawn.\n\t*/\n\tevent Withdraw (\n\t\taddress indexed caller,\n\t\taddress indexed asset,\n\t\tuint256 amountOrTokenId\n\t);\n\n\t/**\n\t\tConstruct a new instance of this Neo Tokyo staker configured with the given \n\t\timmutable contract addresses.\n\n\t\t@param _bytes The address of the BYTES 2.0 ERC-20 token contract.\n\t\t@param _s1Citizen The address of the assembled Neo Tokyo S1 Citizen.\n\t\t@param _s2Citizen The address of the assembled Neo Tokyo S2 Citizen.\n\t\t@param _lpToken The address of the LP token.\n\t\t@param _identity The address of the specific Neo Tokyo Identity sub-item.\n\t\t@param _vault The address of the specific Neo Tokyo Vault sub-item.\n\t\t@param _vaultCap The limit on the number of BYTES that may be staked per S1 \n\t\t\tCitizen assembled with a component Vault or staked alongside a Vault.\n\t\t@param _noVaultCap The limit on the number of BYTES that may be staked per \n\t\t\tS2 Citizen or S1 Citizen without Vault.\n\t*/\n\tconstructor (\n\t\taddress _bytes,\n\t\taddress _s1Citizen,\n\t\taddress _s2Citizen,\n\t\taddress _lpToken,\n\t\taddress _identity,\n\t\taddress _vault,\n\t\taddress _sbt,\n\t\tuint256 _vaultCap,\n\t\tuint256 _noVaultCap\n\t) {\n\t\tBYTES = _bytes;\n\t\tS1_CITIZEN = _s1Citizen;\n\t\tS2_CITIZEN = _s2Citizen;\n\t\tLP = _lpToken;\n\t\tIDENTITY = _identity;\n\t\tVAULT = _vault;\n\t\tNT_STAKED_CITIZEN = _sbt;\n\t\tVAULT_CAP = _vaultCap;\n\t\tNO_VAULT_CAP = _noVaultCap;\n\t}\n\n\t/**\n\t\tNeo Tokyo Identity items do not expose their \"Credit Yield\" trait values in \n\t\tan easily-consumed fashion. This function works backwards to calculate the \n\t\tunderlying \"Credit Yield\" trait value of the component Identity item of the \n\t\tNeo Tokyo S1 Citizen with the token ID of `_citizenId` given the reward \n\t\trate of the S1 Citizen as a whole and the credit multiplier of any \n\t\tcomponent Vault.\n\n\t\t@param _citizenId The token ID of the Neo Tokyo S1 Citizen to retrieve an \n\t\t\tIdentity \"Credit Yield\" trait value for.\n\t\t@param _vaultId The token ID of the Neo Tokyo S1 Citizen's component Vault, \n\t\t\tif there is one. This parameter is separated to optimized for callers who \n\t\t\thave already predetermined the token ID of the Vault.\n\n\t\t@return The \"Credit Yield\" trait value of the component Identity item of \n\t\t\tthe S1 Citizen with the token ID of `_citizenId`.\n\t*/\n\tfunction getCreditYield (\n\t\tuint256 _citizenId,\n\t\tuint256 _vaultId\n\t) public view returns (string memory) {\n\n\t\t// Retrieve the total reward rate of this S1 Citizen.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 rewardRate = citizen.getRewardRateOfTokenId(_citizenId);\n\t\tif (rewardRate == 0) {\n\t\t\trevert CitizenDoesNotExist(_citizenId);\n\t\t}\n\n\t\t// Retrieve the credit rate multiplier of any associated Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the original Identity credit yield.\n\t\treturn identityCreditYield[rewardRate][vaultMultiplier];\n\t}\n\n\t/**\n\t\tThe multipliers to S1 Citizen points contributed by their component Vaults \n\t\tmay be independently configured by permitted administrators of this staking \n\t\tcontract. This helper function returns any of the multipliers that may have \n\t\tbeen configured.\n\n\t\t@param _vaultId The token ID of a Neo Tokyo S1 Vault to retrieve the \n\t\t\tconfigued multiplier for.\n\n\t\t@return The configured point multiplier for the Vault with token ID of \n\t\t\t`_vaultId`.\n\t*/\n\tfunction getConfiguredVaultMultiplier (\n\t\tuint256 _vaultId\n\t) public view returns (uint256) {\n\n\t\t// Retrieve the credit rate multiplier of the Vault.\n\t\tIGenericGetter vault = IGenericGetter(VAULT);\n\t\tstring memory vaultMultiplier = (_vaultId != 0)\n\t\t\t? vault.getCreditMultiplier(_vaultId)\n\t\t\t: \"\";\n\t\t\n\t\t// Deduce the configured Vault multiplier.\n\t\treturn vaultCreditMultiplier[vaultMultiplier];\n\t}\n\n\t/**\n\t\tReturn the list of `_staker`'s token IDs for the specified `_assetType` if \n\t\tthat type is the Neo Tokyo S1 Citizen or S2 Citizen. In order to determine \n\t\tthe staker's position in the LP asset type, the public `stakerLPPosition` \n\t\tmapping should be used. It is not valid to directly determine the position \n\t\tin BYTES of a particular staker; to retrieve that kind of cumulative data \n\t\tthe full output `getStakerPositions` function should be used.\n\n\t\t@param _staker The address of the staker to check for staked Citizen \n\t\t\tholdings.\n\t\t@param _assetType The asset type to check for staked holdings. This must be \n\t\t\tthe S1 Citizen or S2 Citizen type.\n\n\t\t@return The list of token IDs of a particular Citizen type that have been \n\t\t\tstaked by `_staker`.\n\t*/\n\tfunction getStakerPosition (\n\t\taddress _staker,\n\t\tAssetType _assetType\n\t) external view returns (uint256[] memory) {\n\t\tif (_assetType == AssetType.S1_CITIZEN) {\n\t\t\treturn _stakerS1Position[_staker];\n\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n\t\t\treturn _stakerS2Position[_staker];\n\t\t} else {\n\t\t\trevert UnknowablePosition(uint256(_assetType));\n\t\t}\n\t}\n\n\t/**\n\t\tRetrieve the entire position of the specified `_staker` across all asset \n\t\ttypes in this staker.\n\n\t\t@param _staker The address of the staker to check for assets.\n\n\t\t@return The position of the `_staker` across all asset types.\n\t*/\n\tfunction getStakerPositions (\n\t\taddress _staker\n\t) external view returns (StakerPosition memory) {\n\n\t\t// Compile the S1 Citizen details.\n\t\tStakedS1CitizenOutput[] memory stakedS1Details =\n\t\t\tnew StakedS1CitizenOutput[](_stakerS1Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS1Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS1Position[_staker][i];\n\t\t\tStakedS1Citizen memory citizenDetails = stakedS1[_staker][citizenId];\n\t\t\tstakedS1Details[i] = StakedS1CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points,\n\t\t\t\thasVault: citizenDetails.hasVault,\n\t\t\t\tstakedVaultId: citizenDetails.stakedVaultId\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Compile the S2 Citizen details.\n\t\tStakedS2CitizenOutput[] memory stakedS2Details =\n\t\t\tnew StakedS2CitizenOutput[](_stakerS2Position[_staker].length);\n\t\tfor (uint256 i; i < _stakerS2Position[_staker].length; ) {\n\t\t\tuint256 citizenId = _stakerS2Position[_staker][i];\n\t\t\tStakedS2Citizen memory citizenDetails = stakedS2[_staker][citizenId];\n\t\t\tstakedS2Details[i] = StakedS2CitizenOutput({\n\t\t\t\tcitizenId: citizenId,\n\t\t\t\tstakedBytes: citizenDetails.stakedBytes,\n\t\t\t\ttimelockEndTime: citizenDetails.timelockEndTime,\n\t\t\t\tpoints: citizenDetails.points\n\t\t\t});\n\t\t\tunchecked { i++; }\n\t\t}\n\n\t\t// Return the final output position struct.\n\t\treturn StakerPosition({\n\t\t\tstakedS1Citizens: stakedS1Details,\n\t\t\tstakedS2Citizens: stakedS2Details,\n\t\t\tstakedLPPosition: stakerLPPosition[_staker]\n\t\t});\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to \n\t\t`transferFrom` on either a specific ERC-721 token or some amount of ERC-20 \n\t\ttokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _from The address to attempt to transfer the asset from.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _idOrAmount This parameter encodes either an ERC-721 token ID or an \n\t\t\tamount of ERC-20 tokens to attempt to transfer, depending on what \n\t\t\tinterface is implemented by `_asset`.\n\t*/\n\tfunction _assetTransferFrom (\n\t\taddress _asset,\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _idOrAmount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_FROM_SELECTOR,\n\t\t\t\t\t_from,\n\t\t\t\t\t_to, \n\t\t\t\t\t_idOrAmount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper function for performing the low-level call to `transfer` \n\t\ton some amount of ERC-20 tokens.\n\n\t\t@param _asset The address of the asset to perform the transfer call on.\n\t\t@param _to The address to attempt to transfer the asset to.\n\t\t@param _amount The amount of ERC-20 tokens to attempt to transfer.\n\t*/\n\tfunction _assetTransfer (\n\t\taddress _asset,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) private {\n\t\t(bool success, bytes memory data) = \n\t\t\t_asset.call(\n\t\t\t\tabi.encodeWithSelector(\n\t\t\t\t\t_TRANSFER_SELECTOR,\n\t\t\t\t\t_to, \n\t\t\t\t\t_amount\n\t\t\t\t)\n\t\t\t);\n\n\t\t// Revert if the low-level call fails.\n\t\tif (!success) {\n\t\t\trevert(string(data));\n\t\t}\n\t}\n\n\t/**\n\t\tA private helper for checking equality between two strings.\n\n\t\t@param _a The first string to compare.\n\t\t@param _b The second string to compare.\n\n\t\t@return Whether or not `_a` and `_b` are equal.\n\t*/\n\tfunction _stringEquals (\n\t\tstring memory _a,\n\t\tstring memory _b\n\t) private pure returns (bool) {\n\t\tbytes memory a = bytes(_a);\n\t\tbytes memory b = bytes(_b);\n\t\t\n\t\t// Check equivalence of the two strings by comparing their contents.\n\t\tbool equal = true;\n\t\tassembly {\n\t\t\tlet length := mload(a)\n\t\t\tswitch eq(length, mload(b))\n\n\t\t\t// Proceed to compare string contents if lengths are equal. \n\t\t\tcase 1 {\n\t\t\t\tlet cb := 1\n\n\t\t\t\t// Iterate through the strings and compare contents.\n\t\t\t\tlet mc := add(a, 0x20)\n\t\t\t\tlet end := add(mc, length)\n\t\t\t\tfor {\n\t\t\t\t\tlet cc := add(b, 0x20)\n\t\t\t\t} eq(add(lt(mc, end), cb), 2) {\n\t\t\t\t\tmc := add(mc, 0x20)\n\t\t\t\t\tcc := add(cc, 0x20)\n\t\t\t\t} {\n\n\t\t\t\t\t// If any of these checks fails then arrays are not equal.\n\t\t\t\t\tif iszero(eq(mload(mc), mload(cc))) {\n\t\t\t\t\t\tequal := 0\n\t\t\t\t\t\tcb := 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// By default the array length is not equal so the strings are not equal.\n\t\t\tdefault {\n\t\t\t\tequal := 0\n\t\t\t}\n\t\t}\n\t\treturn equal;\n\t}\n\n\t/**\n\t\tA private helper function for managing the staking of a particular S1 \n\t\tCitizen. S1 Citizens may optionally be staked at the same time as a Vault, \n\t\tif they do not already contain a Vault.\n\n\t\t@param _timelock The selected timelock option for the asset being staked. \n\t\t\tThis encodes the timelock duration and multiplier.\n\t*/\n\tfunction _stakeS1Citizen (\n\t\tuint256 _timelock\n\t) private {\n\t\tuint256 citizenId;\n\t\tuint256 vaultId;\n\t\tuint256 handClaimant;\n\n\t\t/*\n\t\t\tExtract the S1 Citizen ID, optional Vault token ID, and optional Hand \n\t\t\tclaimant ID from calldata.\n\t\t*/\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x44)\n\t\t\tvaultId := calldataload(0x64)\n\t\t\thandClaimant := calldataload(0x84)\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the S1 Citizen to be held in escrow by this staking \n\t\t\tcontract. This transfer will fail if the caller is not the holder of the \n\t\t\tCitizen. This prevents double staking.\n\t\t*/\n\t\t_assetTransferFrom(S1_CITIZEN, msg.sender, address(this), citizenId);\n\n\t\t// Retrieve storage for tracking the staking state of this S1 Citizen.\n\t\tStakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];\n\n\t\t// Attach a getter to the S1 Citizen and check for a component Vault.\n\t\tIGenericGetter citizen = IGenericGetter(S1_CITIZEN);\n\t\tuint256 citizenVaultId = citizen.getVaultIdOfTokenId(citizenId);\n\n\t\t/*\n\t\t\tA new Vault to stake may only be provided if the S1 Citizen being staked \n\t\t\tdoes not already have a component Vault.\n\t\t*/\n\t\tif (citizenVaultId != 0 && vaultId != 0) {\n\t\t\trevert CitizenAlreadyHasVault(citizenVaultId, vaultId);\n\n\t\t/*\n\t\t\tIf no optional vault is provided, and the S1 Citizen being staked already \n\t\t\thas an existing Vault, override the provided `vaultId`.\n\t\t*/\n\t\t} else if (citizenVaultId != 0 && vaultId == 0) {\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tvaultId = citizenVaultId;\n\n\t\t/*\n\t\t\tOtherwise, if the S1 Citizen has no component Vault, the newly-provided \n\t\t\tVault is staked and the S1 Citizen is recorded as carrying an optional, \n\t\t\tseparately-attached vault.\n\t\t*/\n\t\t} else if (citizenVaultId == 0 && vaultId != 0) {\n\t\t\t_assetTransferFrom(VAULT, msg.sender, address(this), vaultId);\n\t\t\tcitizenStatus.hasVault = true;\n\t\t\tcitizenStatus.stakedVaultId = vaultId;\n\t\t}\n\n\t\t/*\n\t\t\tIf the S1 Citizen contains no component Vault and is not staked alongside \n\t\t\tan optional Vault (`citizenVaultId` == 0 && `vaultId` == 0), we need not \n\t\t\tdo anything to change the initial state of a staked S1 Citizen's Vault.\n\t\t*/\n\n\t\t// Determine the base worth in points of the S1 Citizen's Identity.\n\t\tstring memory citizenCreditYield = getCreditYield(\n\t\t\tcitizenId,\n\t\t\tcitizenVaultId\n\t\t);\n\t\tuint256 identityPoints = identityCreditPoints[citizenCreditYield];\n\n\t\t// Hands of the Citadel are always given the same multiplier as '?' Vaults.\n\t\tuint256 vaultMultiplier = 100;\n\t\tif (handClaimant == 1) {\n\t\t\tuint256 identityId = citizen.getIdentityIdOfTokenId(citizenId);\n\t\t\tstring memory class = IGenericGetter(IDENTITY).getClass(identityId);\n\t\t\tif (_stringEquals(class, \"Hand of Citadel\")) {\n\t\t\t\tvaultMultiplier = vaultCreditMultiplier[\"?\"];\n\t\t\t} else {\n\t\t\t\trevert CitizenIsNotHand(citizenId);\n\t\t\t}\n\n\t\t// Otherwise use the configured Vault multiplier, if any.\n\t\t} else if (vaultId != 0) {\n\t\t\tvaultMultiplier = getConfiguredVaultMultiplier(vaultId);\n\t\t}\n\n\t\t// Decode the timelock option's duration and multiplier.\n\t\tuint256 timelockDuration = _timelock >> 128;\n\t\tuint256 timelockMultiplier = _timelock & type(uint128).max;\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S1_CITIZEN];\n\t\tunchecked {\n\t\t\tcitizenStatus.points =\n\t\t\t\tidentityPoints * vaultMultiplier * timelockMultiplier /\n\t\t\t\t_DIVISOR / _DIVISOR;\n\t\t\tcitizenStatus.timelockEndTime = block.timestamp + timelockDuration;\n\n\t\t\t// Record the caller's staked S1 Citizen.\n\t\t\t_stakerS1Position[msg.sender].push(citizenId);\n\n\t\t\t// Update stakers missed rewards.\n\t\t\tpool.rewardsMissed[msg.sender] += \n\t\t\t\tpool.rewardPerPoint * citizenStatus.points;\n\n\t\t\t// Update the pool point weights for rewards\n\t\t\tpool.totalPoints += citizenStatus.points;\n\t\t}\n\n\t\t// mint the soulbound token upon staking\n        INTStakedToken(NT_STAKED_CITIZEN).give(msg.sender, abi.encode(S1_CITIZEN, uint64(citizenId)), \"\");\n\n\t\t// Emit an event recording this S1 Citizen staking.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tS1_CITIZEN,\n\t\t\t_timelock,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private function for managing the staking of a particular S2 Citizen.\n\n\t\t@param _timelock The selected timelock option for the asset being staked. \n\t\t\tThis encodes the timelock duration and multiplier.\n\t*/\n\tfunction _stakeS2Citizen (\n\t\tuint256 _timelock\n\t) private {\n\t\tuint256 citizenId;\n\n\t\t// Extract the S2 Citizen ID from the calldata.\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x44)\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the S2 Citizen to be held in escrow by this staking \n\t\t\tcontract. This transfer will fail if the caller is not the holder of the \n\t\t\tCitizen. This prevents double staking.\n\t\t*/\n\t\t_assetTransferFrom(S2_CITIZEN, msg.sender, address(this), citizenId);\n\n\t\t// Retrieve storage for tracking the staking state of this S2 Citizen.\n\t\tStakedS2Citizen storage citizenStatus = stakedS2[msg.sender][citizenId];\n\n\t\t// Decode the timelock option's duration and multiplier.\n\t\tuint256 timelockDuration = _timelock >> 128;\n\t\tuint256 timelockMultiplier = _timelock & type(uint128).max;\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S2_CITIZEN];\n\t\tunchecked {\n\t\t\tcitizenStatus.points = 100 * timelockMultiplier / _DIVISOR;\n\t\t\tcitizenStatus.timelockEndTime = block.timestamp + timelockDuration;\n\n\t\t\t// Record the caller's staked S2 Citizen.\n\t\t\t_stakerS2Position[msg.sender].push(citizenId);\n\n\t\t\t// Update the pool point weights for rewards\n\t\t\tpool.totalPoints += citizenStatus.points;\n\n\t\t\t// Update stakers missed rewards.\n\t\t\tpool.rewardsMissed[msg.sender] += \n\t\t\t\tpool.rewardPerPoint * citizenStatus.points;\n\t\t}\n\n\n\t\t// mint the soulbound token upon staking\n        INTStakedToken(NT_STAKED_CITIZEN).give(msg.sender, abi.encode(S2_CITIZEN, uint64(citizenId)), \"\");\n\n\n\n\t\t// Emit an event recording this S1 Citizen staking.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tS2_CITIZEN,\n\t\t\t_timelock,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private function for managing the staking of BYTES into a Citizen.\n\t*/\n\tfunction _stakeBytes (\n\t\tuint256\n\t) private {\n\t\tuint256 amount;\n\t\tuint256 citizenId;\n\t\tuint256 seasonId;\n\t\tassembly{\n\t\t\tamount := calldataload(0x44)\n\t\t\tcitizenId := calldataload(0x64)\n\t\t\tseasonId := calldataload(0x84)\n\t\t}\n\n\t\t// Attempt to transfer BYTES to escrow.\n\t\t_assetTransferFrom(BYTES, msg.sender, address(this), amount);\n\n\t\t// Handle staking BYTES into an S1 Citizen.\n\t\tif (seasonId == 1) {\n\t\t\tStakedS1Citizen storage citizenStatus = stakedS1[msg.sender][citizenId];\n\t\t\tuint256 cap = VAULT_CAP;\n\t\t\tif (!citizenStatus.hasVault) {\n\t\t\t\tcap = NO_VAULT_CAP;\n\t\t\t}\n\t\t\tif (citizenStatus.stakedBytes + amount > cap) {\n\t\t\t\trevert AmountExceedsCap(citizenStatus.stakedBytes + amount, cap);\n\t\t\t}\n\n\t\t\t// Validate that the caller actually staked the Citizen.\n\t\t\tif (citizenStatus.timelockEndTime == 0) {\n\t\t\t\trevert CannotStakeIntoUnownedCitizen(citizenId, seasonId);\n\t\t\t}\n\n\t\t\tPoolData storage pool = _pools[AssetType.S1_CITIZEN];\n\t\t\tunchecked {\n\t\t\t\tuint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT);\n\t\t\t\tcitizenStatus.stakedBytes += amount;\n\t\t\t\tcitizenStatus.points += bonusPoints;\n\t\t\t\tpool.totalPoints += bonusPoints;\n\n\t\t\t\t// Update stakers missed rewards.\n\t\t\t\tpool.rewardsMissed[msg.sender] += \n\t\t\t\t\tpool.rewardPerPoint * bonusPoints;\n\t\t\t}\n\n\t\t// Handle staking BYTES into an S2 Citizen.\n\t\t} else if (seasonId == 2) {\n\t\t\tStakedS2Citizen storage citizenStatus = stakedS2[msg.sender][citizenId];\n\t\t\tuint256 cap = NO_VAULT_CAP;\n\t\t\tif (citizenStatus.stakedBytes + amount > cap) {\n\t\t\t\trevert AmountExceedsCap(citizenStatus.stakedBytes + amount, cap);\n\t\t\t}\n\n\t\t\t// Validate that the caller actually staked the Citizen.\n\t\t\tif (citizenStatus.timelockEndTime == 0) {\n\t\t\t\trevert CannotStakeIntoUnownedCitizen(citizenId, seasonId);\n\t\t\t}\n\n\t\t\tPoolData storage pool = _pools[AssetType.S2_CITIZEN];\n\t\t\tunchecked {\n\t\t\t\tuint256 bonusPoints = (amount * 100 / _BYTES_PER_POINT);\n\t\t\t\tcitizenStatus.stakedBytes += amount;\n\t\t\t\tcitizenStatus.points += bonusPoints;\n\t\t\t\tpool.totalPoints += bonusPoints;\n\n\t\t\t\t// Update stakers missed rewards.\n\t\t\t\tpool.rewardsMissed[msg.sender] += \n\t\t\t\t\tpool.rewardPerPoint * bonusPoints;\n\t\t\t}\n\n\t\t// Revert because an invalid season ID has been supplied.\n\t\t} else {\n\t\t\trevert InvalidSeasonId(seasonId);\n\t\t}\n\n\t\t// Emit an event.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tBYTES,\n\t\t\t(seasonId << 128) + citizenId,\n\t\t\tamount\n\t\t);\n\t}\n\n\t/**\n\t\tA private function for managing the staking of LP tokens.\n\n\t\t@param _timelock The selected timelock option for the asset being staked. \n\t\t\tThis encodes the timelock duration and multiplier.\n\t*/\n\tfunction _stakeLP (\n\t\tuint256 _timelock\n\t) private {\n\t\tuint256 amount;\n\t\tassembly{\n\t\t\tamount := calldataload(0x44)\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the LP tokens to be held in escrow by this staking \n\t\t\tcontract. This transfer will fail if the caller does not hold enough \n\t\t\ttokens.\n\t\t*/\n\t\t_assetTransferFrom(LP, msg.sender, address(this), amount);\n\n\t\t// Decode the timelock option's duration and multiplier.\n\t\tuint256 timelockDuration = _timelock >> 128;\n\t\tuint256 timelockMultiplier = _timelock & type(uint128).max;\n\n\t\t// If this is a new stake of this asset, initialize the multiplier details.\n\t\tif (stakerLPPosition[msg.sender].multiplier == 0) {\n\t\t\tstakerLPPosition[msg.sender].multiplier = timelockMultiplier;\n\n\t\t// If a multiplier exists already, we must match it.\n\t\t} else if (stakerLPPosition[msg.sender].multiplier != timelockMultiplier) {\n\t\t\trevert MismatchedTimelock();\n\t\t}\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.LP];\n\t\tunchecked {\n\t\t\tuint256 points = amount * 100 / 1e18 * timelockMultiplier / _DIVISOR;\n\n\t\t\t// Update the caller's LP token stake.\n\t\t\tstakerLPPosition[msg.sender].timelockEndTime =\n\t\t\t\tblock.timestamp + timelockDuration;\n\t\t\tstakerLPPosition[msg.sender].amount += amount;\n\t\t\tstakerLPPosition[msg.sender].points += points;\n\n\t\t\t/// Update stakers missed rewards.\n\t\t\tpool.rewardsMissed[msg.sender] += \n\t\t\t\tpool.rewardPerPoint * points;\n\n\t\t\t// Update the pool point weights for rewards.\n\t\t\tpool.totalPoints += points;\n\t\t}\n\n\t\t// Emit an event recording this LP staking.\n\t\temit Stake(\n\t\t\tmsg.sender,\n\t\t\tLP,\n\t\t\t_timelock,\n\t\t\tamount\n\t\t);\n\t}\n\n\t/**\n\t\tUse the emission schedule of a particular asset pool to calculate the total\n\t\tamount of staking reward token emitted between two specified timestamps.\n\n\t\t@param _assetType The type of the asset to calculate emissions for.\n\t\t@param _from The time to begin calculating emissions from.\n\t*/\n\tfunction getTotalEmissions (\n\t\tAssetType _assetType,\n\t\tuint256 _from\n\t) public view returns (uint256) {\n\t\tPoolData storage pool = _pools[_assetType];\n\n\t\t/*\n\t\t\t\tDetermine the reward for the `_recipient` based on their points total. \n\t\t\t\tIterate through the entire array of pool reward windows to find the \n\t\t\t\tapplicable time period.\n\t\t\t*/\n\t\t\tuint256 totalReward;\n\t\t\tuint256 windowCount = pool.rewardCount;\n\t\t\tfor (uint256 i; i < windowCount; ) {\n\t\t\t\tRewardWindow memory window = pool.rewardWindows[i];\n\n\t\t\t\t/*\n\t\t\t\t\tIf the last reward time is less than the starting time of this \n\t\t\t\t\twindow, then the reward was accrued in the previous window.\n\t\t\t\t*/\n\t\t\t\tif (_from < window.startTime) {\n\t\t\t\t\tuint256 currentRewardRate = pool.rewardWindows[i - 1].reward;\n\n\t\t\t\t\t/*\n\t\t\t\t\t\tIterate forward to the present timestamp over any unclaimed reward \n\t\t\t\t\t\twindows.\n\t\t\t\t\t*/\n\t\t\t\t\tfor (uint256 j = i; j < windowCount; ) {\n\n\t\t\t\t\t\t// If the current time falls within this window, complete.\n\t\t\t\t\t\tif (block.timestamp <= window.startTime) {\n\t\t\t\t\t\t\tunchecked {\n\t\t\t\t\t\t\t\tuint256 timeSinceReward = block.timestamp - _from;\n\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\t\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.\n\t\t\t\t\t\t\ti = windowCount;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// Otherwise, accrue the remainder of this window and iterate.\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunchecked {\n\t\t\t\t\t\t\t\tuint256 timeSinceReward = window.startTime - _from;\n\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentRewardRate = window.reward;\n\t\t\t\t\t\t\t_from = window.startTime;\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\tHandle the special case of overrunning the final window by \n\t\t\t\t\t\t\t\tfulfilling the prior window and then jumping forward to use the \n\t\t\t\t\t\t\t\tfinal reward window.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif (j == windowCount - 1) {\n\t\t\t\t\t\t\t\tunchecked {\n\t\t\t\t\t\t\t\t\tuint256 timeSinceReward =\n\t\t\t\t\t\t\t\t\t\tblock.timestamp - _from;\n\t\t\t\t\t\t\t\t\ttotalReward += currentRewardRate * timeSinceReward;\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t// We have no forward goto and thus include this bastardry.\n\t\t\t\t\t\t\t\ti = windowCount;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t// Otherwise, iterate.\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twindow = pool.rewardWindows[j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunchecked { j++; }\n\t\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t\tOtherwise, the last reward rate, and therefore the entireity of \n\t\t\t\t\taccrual, falls in the last window.\n\t\t\t\t*/\n\t\t\t\t} else if (i == windowCount - 1) {\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\tuint256 timeSinceReward = block.timestamp - _from;\n\t\t\t\t\t\ttotalReward = window.reward * timeSinceReward;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tunchecked { i++; }\n\t\t\t}\n\t\t\n\t\treturn totalReward;\n\t}\n\n  /**\n\t\tThis function supports retrieving the reward and tax earned by a particular \n\t\t`_recipient` on a specific pool of type `_assetType`. It is meant to be\n    called by a frontend interface that needs to show pending rewards.\n\n\t\t@param _assetType The type of the asset to calculate rewards for.\n\t\t@param _recipient The recipient of the reward.\n\t*/\n\tfunction getPendingPoolReward (\n\t\tAssetType _assetType,\n\t\taddress _recipient\n\t) external view returns (uint256, uint256) {\n\n\t\t/*\n\t\t\tDuring the very first stake, there will not be any points in the pool. In \n\t\t\tthis case, do not attempt to grant any rewards so as to prevent reversion.\n\t\t*/\n\t\tPoolData storage pool = _pools[_assetType];\n    if (pool.totalPoints == 0) {\n\t\t\treturn (0, 0);\n\t\t}\n\n\t\t// Calculate rewards for this pool.\n\t\tuint256 totalEmissions = getTotalEmissions(\n\t\t\t_assetType,\n\t\t\tpool.lastUpdated\n\t\t);\n\n\t\t// Update the pool rewards per point to pay users the amount remaining.\n\t\tuint256 pendingRPP = pool.rewardPerPoint\n\t\t\t+ (totalEmissions / pool.totalPoints);\n\n\t\t// Calculate the total number of points accrued to the `_recipient`.\n\t\tuint256 points;\n\t\tif (_assetType == AssetType.S1_CITIZEN) {\n\t\t\tfor (uint256 i; i < _stakerS1Position[_recipient].length; ) {\n\t\t\t\tuint256 citizenId = _stakerS1Position[_recipient][i];\n\t\t\t\tStakedS1Citizen memory s1Citizen = stakedS1[_recipient][citizenId];\n\t\t\t\tunchecked {\n\t\t\t\t\tpoints += s1Citizen.points;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n\t\t\tfor (uint256 i; i < _stakerS2Position[_recipient].length; ) {\n\t\t\t\tuint256 citizenId = _stakerS2Position[_recipient][i];\n\t\t\t\tStakedS2Citizen memory s2Citizen = stakedS2[_recipient][citizenId];\n\t\t\t\tunchecked {\n\t\t\t\t\tpoints += s2Citizen.points;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_assetType == AssetType.LP) {\n\t\t\tunchecked {\n\t\t\t\tpoints += stakerLPPosition[_recipient].points;\n\t\t\t}\n\t\t} else {\n\t\t\trevert InvalidAssetType(uint256(_assetType));\n\t\t}\n\t\tif (points > 0) {\n  \t\tuint256 share = points * pendingRPP\n\t  \t\t- rewardAccrued[_recipient][_assetType]\n\t\t\t\t- pool.rewardsMissed[_recipient];\n\t\t\tuint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);\n\t\t\treturn ((share - daoShare), daoShare);\n\t\t}\n\t\treturn (0, 0);\n\t}\n\n\t/**\n\t\tUpdate the pool corresponding to the specified asset.\n\t\t\n\t\t@param _assetType The type of the asset to update pool rewards for.\n\t*/\n\tfunction _updatePool (\n\t\tAssetType _assetType\n\t) private {\n\t\tPoolData storage pool = _pools[_assetType];\n\t\tif (pool.totalPoints == 0) {\n\t\t\tpool.lastUpdated = block.timestamp;\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate rewards for this pool.\n\t\tuint256 totalEmissions = getTotalEmissions(\n\t\t\t_assetType,\n\t\t\tpool.lastUpdated\n\t\t);\n\n\t\t// Update the pool rewards per point to pay users the amount remaining.\n\t\tpool.rewardPerPoint = pool.rewardPerPoint\n\t\t\t+ (totalEmissions / pool.totalPoints);\n\t\tpool.lastUpdated = block.timestamp;\n\t}\n\n\t/**\n\t\tStake a particular asset into this contract, updating its corresponding \n\t\trewards.\n\n\t\t@param _assetType An ID of the specific asset that the caller is attempting \n\t\t\tto deposit into this staker.\n\t\t@param _timelockId The ID of a specific timelock period to select. This \n\t\t\ttimelock ID must be configured for the specific `_assetType`.\n\t\t@custom:param The third parameter is overloaded to have different meaning \n\t\t\tdepending on the `assetType` selected. In the event of staking an S1 or \n\t\t\tS2 Citizen, this parameter is the token ID of the Citizen being staked. \n\t\t\tIn the event of staking BYTES or LP tokens, this parameter is the amount \n\t\t\tof the respective token being staked.\n\t\t@custom:param If the asset being staked is an S1 Citizen, this is the ID of \n\t\t\ta Vault to attempt to optionally attach.\n\t\t@custom:param If the asset being staked is an S1 Citizen, this is a flag to \n\t\t\tattempt to claim a Hand of the Citadel bonus. If the asset being staked \n\t\t\tis BYTES, this is either one or two to select the Neo Tokyo season ID of \n\t\t\tthe S1 or S2 Citizen that BYTES are being staked into.\n\t*/\n\tfunction stake (\n\t\tAssetType _assetType,\n\t\tuint256 _timelockId,\n\t\tuint256,\n\t\tuint256,\n\t\tuint256\n\t) external nonReentrant {\n\n\t\t// Validate that the asset being staked is of a valid type.\n\t\tif (uint8(_assetType) > 4) {\n\t\t\trevert InvalidAssetType(uint256(_assetType));\n\t\t}\n\n\t\t// Validate that the asset being staked matches a configured pool.\n\t\tif (_pools[_assetType].rewardCount == 0) {\n\t\t\trevert UnconfiguredPool(uint256(_assetType));\n\t\t}\n\n\t\t// Validate that the asset being staked matches an active pool.\n\t\tif (_pools[_assetType].rewardWindows[0].startTime >= block.timestamp) {\n\t\t\trevert InactivePool(uint256(_assetType));\n\t\t}\n\n\t\t// Validate that the selected timelock option is valid for the staked asset.\n\t\tuint256 timelockOption = timelockOptions[_assetType][_timelockId];\n\t\tif (timelockOption == 0) {\n\t\t\trevert InvalidTimelockOption(uint256(_assetType), _timelockId);\n\t\t}\n\n\t\t// Update pool rewards.\n\t\t_updatePool(_assetType);\n\n\t\t// Grant the caller their total rewards with each staking action.\n\t\tIByteContract(BYTES).getReward(msg.sender);\n\n\t\t// Store references to each available staking function.\n\t\tfunction (uint256) _s1 = _stakeS1Citizen;\n\t\tfunction (uint256) _s2 = _stakeS2Citizen;\n\t\tfunction (uint256) _b = _stakeBytes;\n\t\tfunction (uint256) _lp = _stakeLP;\n\n\t\t// Select the proper staking function based on the asset type being staked.\n\t\tfunction (uint256) _stake;\n\t\tassembly {\n\t\t\tswitch _assetType\n\t\t\t\tcase 0 {\n\t\t\t\t\t_stake := _s1\n\t\t\t\t}\n\t\t\t\tcase 1 {\n\t\t\t\t\t_stake := _s2\n\t\t\t\t}\n\t\t\t\tcase 2 {\n\t\t\t\t\t_stake := _b\n\t\t\t\t}\n\t\t\t\tcase 3 {\n\t\t\t\t\t_stake := _lp\n\t\t\t\t}\n\t\t\t\tdefault {}\n\t\t}\n\n\t\t// Invoke the correct staking function.\n\t\t_stake(timelockOption);\n\t}\n\n\t/**\n\t\tThis function supports retrieving the reward and tax earned by a particular \n\t\t`_recipient` on a specific pool of type `_assetType`. It is meant to be\n    called in conjuction with `_updatePool` and a reward claim.\n\n\t\t@param _assetType The type of the asset to calculate rewards for.\n\t\t@param _recipient The recipient of the reward.\n\t*/\n\tfunction _getPoolReward (\n\t\tAssetType _assetType,\n\t\taddress _recipient\n\t) private view returns (uint256, uint256) {\n\n\t\t/*\n\t\t\tDuring the very first stake, there will not be any points in the pool. In \n\t\t\tthis case, do not attempt to grant any rewards so as to prevent reversion.\n\t\t*/\n\t\tPoolData storage pool = _pools[_assetType];\n\n\t\t// Calculate the total number of points accrued to the `_recipient`.\n\t\tuint256 points;\n\t\tif (_assetType == AssetType.S1_CITIZEN) {\n\t\t\tfor (uint256 i; i < _stakerS1Position[_recipient].length; ) {\n\t\t\t\tuint256 citizenId = _stakerS1Position[_recipient][i];\n\t\t\t\tStakedS1Citizen memory s1Citizen = stakedS1[_recipient][citizenId];\n\t\t\t\tunchecked {\n\t\t\t\t\tpoints += s1Citizen.points;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_assetType == AssetType.S2_CITIZEN) {\n\t\t\tfor (uint256 i; i < _stakerS2Position[_recipient].length; ) {\n\t\t\t\tuint256 citizenId = _stakerS2Position[_recipient][i];\n\t\t\t\tStakedS2Citizen memory s2Citizen = stakedS2[_recipient][citizenId];\n\t\t\t\tunchecked {\n\t\t\t\t\tpoints += s2Citizen.points;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_assetType == AssetType.LP) {\n\t\t\tunchecked {\n\t\t\t\tpoints += stakerLPPosition[_recipient].points;\n\t\t\t}\n\t\t} else {\n\t\t\trevert InvalidAssetType(uint256(_assetType));\n\t\t}\n\t\tif (points > 0) {\n  \t\tuint256 share = points * pool.rewardPerPoint\n\t  \t\t- rewardAccrued[_recipient][_assetType]\n\t\t\t\t- pool.rewardsMissed[_recipient];\n\t\t\tuint256 daoShare = share * pool.daoTax / (100 * _DIVISOR);\n\t\t\treturn ((share - daoShare), daoShare);\n\t\t}\n\t\treturn (0, 0);\n\t}\n\n\t/**\n\t\tDetermine the reward, based on staking participation at this moment, of a \n\t\tparticular recipient. Due to a historic web of Neo Tokyo dependencies, \n\t\trewards are actually minted through the BYTES contract.\n\n\t\t@param _recipient The recipient to calculate the reward for.\n\n\t\t@return A tuple containing (the number of tokens due to be minted to \n\t\t\t`_recipient` as a reward, and the number of tokens that should be minted \n\t\t\tto the DAO treasury as a DAO tax).\n\t*/\n\tfunction claimReward (\n\t\taddress _recipient\n\t) external returns (uint256, uint256) {\n\n\t\t// This function may only be called by the BYTES contract.\n\t\tif (msg.sender != BYTES) {\n\t\t\trevert CallerIsNotBYTES();\n\t\t}\n\n\t\t// Update pool rewards.\n\t\t_updatePool(AssetType.S1_CITIZEN);\n\t\t_updatePool(AssetType.S2_CITIZEN);\n\t\t_updatePool(AssetType.LP);\n\n\t\t// Retrieve the `_recipient` reward share from each pool.\n\t\t(uint256 s1Reward, uint256 s1Tax) = _getPoolReward(\n\t\t\tAssetType.S1_CITIZEN,\n\t\t\t_recipient\n\t\t);\n\t\t(uint256 s2Reward, uint256 s2Tax) = _getPoolReward(\n\t\t\tAssetType.S2_CITIZEN,\n\t\t\t_recipient\n\t\t);\n\t\t(uint256 lpReward, uint256 lpTax) = _getPoolReward(\n\t\t\tAssetType.LP,\n\t\t\t_recipient\n\t\t);\n\n\t\t// Record the current time as the beginning time for checking rewards.\n\t\tlastRewardTime[_recipient][AssetType.S1_CITIZEN] = block.timestamp;\n\t\tlastRewardTime[_recipient][AssetType.S2_CITIZEN] = block.timestamp;\n\t\tlastRewardTime[_recipient][AssetType.LP] = block.timestamp;\n\n\t\t// Calculate total reward and tax.\n\t\tuint256 totalReward;\n\t\tuint256 totalTax;\n\t\tunchecked {\n\t\t\ttotalReward = (s1Reward + s2Reward + lpReward);\n\t\t\ttotalTax = (s1Tax + s2Tax + lpTax);\n\t\t\trewardAccrued[_recipient][AssetType.S1_CITIZEN] += (s1Reward + s1Tax);\n\t\t\trewardAccrued[_recipient][AssetType.S2_CITIZEN] += (s2Reward + s2Tax);\n\t\t\trewardAccrued[_recipient][AssetType.LP] += (lpReward + lpTax);\n\t\t}\n\n\t\t// Emit an event.\n\t\temit Claim (\n\t\t\t_recipient,\n\t\t\ttotalReward,\n\t\t\ttotalTax\n\t\t);\n\n\t\t// Return the final reward for the user and the tax rewarded to the DAO.\n\t\treturn (totalReward, totalTax);\n\t}\n\n\t/**\n\t\tA private function for managing the withdrawal of S1 Citizens.\n\t*/\n\tfunction _withdrawS1Citizen () private {\n\t\tuint256 citizenId;\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x24)\n\t\t}\n\n\t\t// Validate that the caller has cleared their asset timelock.\n\t\tStakedS1Citizen storage stakedCitizen = stakedS1[msg.sender][citizenId];\n\t\tif (block.timestamp < stakedCitizen.timelockEndTime) {\n\t\t\trevert TimelockNotCleared(stakedCitizen.timelockEndTime);\n\t\t}\n\n\t\t// Validate that the caller actually staked this asset.\n\t\tif (stakedCitizen.timelockEndTime == 0) {\n\t\t\trevert CannotWithdrawUnownedS1(citizenId);\n\t\t}\n\t\t\n\t\t// Return any staked BYTES.\n\t\tif (stakedCitizen.stakedBytes > 0) {\n\t\t\t_assetTransfer(BYTES, msg.sender, stakedCitizen.stakedBytes);\n\t\t}\n\t\t\n\t\t// Return any non-component Vault if one is present.\n\t\tif (stakedCitizen.stakedVaultId != 0) {\n\t\t\t_assetTransferFrom(\n\t\t\t\tVAULT,\n\t\t\t\taddress(this),\n\t\t\t\tmsg.sender,\n\t\t\t\tstakedCitizen.stakedVaultId\n\t\t\t);\n\t\t}\n\n\t\t// Return the S1 Citizen.\n\t\t_assetTransferFrom(S1_CITIZEN, address(this), msg.sender, citizenId);\n\n\t\t// burn the soulbound token\n\t\tuint256 tokenId;\n\t\taddress addr = S1_CITIZEN;\n        assembly {\n            // this is the equivalent of\n            // encoded = uint256(addr);\n            // encoded <<= 96;\n            // encoded |= citizen id\n            tokenId := or(shl(96, addr), citizenId)\n        }\n\t\tINTStakedToken(NT_STAKED_CITIZEN).burn(tokenId);\n\n\t\t/*\n\t\t\tCheck each citizen ID to find its index and remove the token from the\n\t\t\tstaked item array of its old position.\n\t\t*/\n\t\tuint256[] storage oldPosition = _stakerS1Position[msg.sender];\n\t\tfor (uint256 stakedIndex; stakedIndex < oldPosition.length; ) {\n\n\t\t\t// Remove the element at the matching index.\n\t\t\tif (citizenId == oldPosition[stakedIndex]) {\n\t\t\t\tif (stakedIndex != oldPosition.length - 1) {\n\t\t\t\t\toldPosition[stakedIndex] = oldPosition[oldPosition.length - 1];\n\t\t\t\t}\n\t\t\t\toldPosition.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunchecked { stakedIndex++; }\n\t\t}\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S1_CITIZEN];\n\t\tuint256 leftoverPoints;\n\t\tfor (uint256 i; i < _stakerS1Position[msg.sender].length; ) {\n\t\t\tuint256 leftoverId = _stakerS1Position[msg.sender][i];\n\t\t\tStakedS1Citizen memory s1Citizen = stakedS1[msg.sender][leftoverId];\n\t\t\tunchecked {\n\t\t\t\tleftoverPoints += s1Citizen.points;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tunchecked {\n\t\t\tpool.totalPoints -= stakedCitizen.points;\n\t\t}\n\n\t\tpool.rewardsMissed[msg.sender] = leftoverPoints * pool.rewardPerPoint;\n\t\tdelete rewardAccrued[msg.sender][AssetType.S1_CITIZEN];\n\t\tstakedCitizen.stakedBytes = 0;\n\t\tstakedCitizen.timelockEndTime = 0;\n\t\tstakedCitizen.points = 0;\n\t\tstakedCitizen.hasVault = false;\n\t\tstakedCitizen.stakedVaultId = 0;\n\n\t\t// Emit an event recording this S1 withdraw.\n\t\temit Withdraw(\n\t\t\tmsg.sender,\n\t\t\tS1_CITIZEN,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private function for managing the withdrawal of S2 Citizens.\n\t*/\n\tfunction _withdrawS2Citizen () private {\n\t\tuint256 citizenId;\n\t\tassembly {\n\t\t\tcitizenId := calldataload(0x24)\n\t\t}\n\n\t\t// Validate that the caller has cleared their asset timelock.\n\t\tStakedS2Citizen storage stakedCitizen = stakedS2[msg.sender][citizenId];\n\t\tif (block.timestamp < stakedCitizen.timelockEndTime) {\n\t\t\trevert TimelockNotCleared(stakedCitizen.timelockEndTime);\n\t\t}\n\n\t\t// Validate that the caller actually staked this asset.\n\t\tif (stakedCitizen.timelockEndTime == 0) {\n\t\t\trevert CannotWithdrawUnownedS2(citizenId);\n\t\t}\n\n\t\t// Return any staked BYTES.\n\t\tif (stakedCitizen.stakedBytes > 0) {\n\t\t\t_assetTransfer(BYTES, msg.sender, stakedCitizen.stakedBytes);\n\t\t}\n\n\t\t// Return the S2 Citizen.\n\t\t_assetTransferFrom(S2_CITIZEN, address(this), msg.sender, citizenId);\n\n\t\t// burn the soulbound token\n\t\tuint256 tokenId;\n\t\taddress addr = S2_CITIZEN;\n        assembly {\n            // this is the equivalent of\n            // encoded = uint256(addr);\n            // encoded <<= 96;\n            // encoded |= citizen id\n            tokenId := or(shl(96, addr), citizenId)\n        }\n\t\tINTStakedToken(NT_STAKED_CITIZEN).burn(tokenId);\n\n\t\t/*\n\t\t\tCheck each citizen ID to find its index and remove the token from the\n\t\t\tstaked item array of its old position.\n\t\t*/\n\t\tuint256[] storage oldPosition = _stakerS2Position[msg.sender];\n\t\tfor (uint256 stakedIndex; stakedIndex < oldPosition.length; ) {\n\n\t\t\t// Remove the element at the matching index.\n\t\t\tif (citizenId == oldPosition[stakedIndex]) {\n\t\t\t\tif (stakedIndex != oldPosition.length - 1) {\n\t\t\t\t\toldPosition[stakedIndex] = oldPosition[oldPosition.length - 1];\n\t\t\t\t}\n\t\t\t\toldPosition.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunchecked { stakedIndex++; }\n\t\t}\n\n\t\t// Calculate the caller's leftover points.\n\t\tuint256 leftoverPoints;\n\t\tfor (uint256 i; i < _stakerS2Position[msg.sender].length; ) {\n\t\t\tuint256 leftoverId = _stakerS2Position[msg.sender][i];\n\t\t\tStakedS2Citizen memory s2Citizen = stakedS2[msg.sender][leftoverId];\n\t\t\tunchecked {\n\t\t\t\tleftoverPoints += s2Citizen.points;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.S2_CITIZEN];\n\t\tunchecked {\n\t\t\tpool.totalPoints -= stakedCitizen.points;\n\t\t}\n\t\tpool.rewardsMissed[msg.sender] = leftoverPoints * pool.rewardPerPoint;\n\t\tdelete rewardAccrued[msg.sender][AssetType.S2_CITIZEN];\n\t\tstakedCitizen.stakedBytes = 0;\n\t\tstakedCitizen.timelockEndTime = 0;\n\t\tstakedCitizen.points = 0;\n\n\t\t// Emit an event recording this S2 withdraw.\n\t\temit Withdraw(\n\t\t\tmsg.sender,\n\t\t\tS2_CITIZEN,\n\t\t\tcitizenId\n\t\t);\n\t}\n\n\t/**\n\t\tA private function for managing the withdrawal of LP tokens.\n\t*/\n\tfunction _withdrawLP () private {\n\t\tuint256 amount;\n\t\tassembly{\n\t\t\tamount := calldataload(0x24)\n\t\t}\n\n\t\t// Validate that the caller has cleared their asset timelock.\n\t\tLPPosition storage lpPosition = stakerLPPosition[msg.sender];\n\t\tif (block.timestamp < lpPosition.timelockEndTime) {\n\t\t\trevert TimelockNotCleared(lpPosition.timelockEndTime);\n\t\t}\n\n\t\t// Validate that the caller has enough staked LP tokens to withdraw.\n\t\tif (lpPosition.amount < amount) {\n\t\t\trevert NotEnoughLPTokens(amount, lpPosition.amount);\n\t\t}\n\n\t\t/*\n\t\t\tAttempt to transfer the LP tokens held in escrow by this staking contract \n\t\t\tback to the caller.\n\t\t*/\n\t\t_assetTransfer(LP, msg.sender, amount);\n\n\t\t// Update caller staking information and asset data.\n\t\tPoolData storage pool = _pools[AssetType.LP];\n\t\tunchecked {\n\t\t\tuint256 points = amount * 100 / 1e18 * lpPosition.multiplier / _DIVISOR;\n\t\t\tuint256 pointsIntact = points > lpPosition.points ? 0 : lpPosition.points - points;\n\t\t\tdelete rewardAccrued[msg.sender][AssetType.LP];\n\t\t\tpool.rewardsMissed[msg.sender] = pointsIntact * pool.rewardCount;\n\n\t\t\t// Update the caller's LP token stake.\n\t\t\tlpPosition.amount -= amount;\n\t\t\tlpPosition.points = pointsIntact;\n\n\t\t\t// Update the pool point weights for rewards.\n\t\t\tpool.totalPoints -= points;\n\t\t}\n\n\t\t// If all LP tokens are withdrawn, we must clear the multiplier.\n\t\tif (lpPosition.amount == 0) {\n\t\t\tlpPosition.multiplier = 0;\n\t\t}\n\n\t\t// Emit an event recording this LP withdraw.\n\t\temit Withdraw(\n\t\t\tmsg.sender,\n\t\t\tLP,\n\t\t\tamount\n\t\t);\n\t}\n\n\t/**\n\t\tWithdraw a particular asset from this contract, updating its corresponding \n\t\trewards. A caller may only withdraw an asset provided they are the staker \n\t\tand that timelocks are not violated.\n\n\t\t@param _assetType An ID of the specific asset that the caller is attempting \n\t\t\tto withdraw from this staker.\n\t\t@custom:param The third parameter is overloaded to have different meaning \n\t\t\tdepending on the `assetType` selected. In the event of withdrawing an S1 \n\t\t\tor S2 Citizen, this is the token ID of the Citizen to attempt to \n\t\t\twithdraw. In the event of withdrawing LP tokens, this is the amount of \n\t\t\tthe LP token to withdraw.\n\t*/\n\tfunction withdraw (\n\t\tAssetType _assetType,\n\t\tuint256\n\t) external nonReentrant {\n\n\t\t/*\n\t\t\tValidate that the asset being withdrawn is of a valid type. BYTES may not \n\t\t\tbe withdrawn independently of the Citizen that they are staked into.\n\t\t*/\n\t\tif (uint8(_assetType) == 2 || uint8(_assetType) > 4) {\n\t\t\trevert InvalidAssetType(uint256(_assetType));\n\t\t}\n\n\t\t// Update pool rewards.\n\t\t_updatePool(_assetType);\n\n\t\t// Grant the caller their total rewards with each withdrawal action.\n\t\tIByteContract(BYTES).getReward(msg.sender);\n\n\t\t// Store references to each available withdraw function.\n\t\tfunction () _s1 = _withdrawS1Citizen;\n\t\tfunction () _s2 = _withdrawS2Citizen;\n\t\tfunction () _lp = _withdrawLP;\n\n\t\t// Select the proper withdraw function based on the asset type.\n\t\tfunction () _withdraw;\n\t\tassembly {\n\t\t\tswitch _assetType\n\t\t\t\tcase 0 {\n\t\t\t\t\t_withdraw := _s1\n\t\t\t\t}\n\t\t\t\tcase 1 {\n\t\t\t\t\t_withdraw := _s2\n\t\t\t\t}\n\t\t\t\tcase 3 {\n\t\t\t\t\t_withdraw := _lp\n\t\t\t\t}\n\t\t\t\tdefault {}\n\t\t}\n\n\t\t// Invoke the correct withdraw function.\n\t\t_withdraw();\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to configure the LP token contract \n\t\taddress. Extreme care must be taken to avoid doing this if there are any LP \n\t\tstakers, lest staker funds be lost. It is recommended that `lockLP` be \n\t\tinvoked.\n\n\t\t@param _lp The address of the LP token contract to specify.\n\t*/\n\tfunction configureLP (\n\t\taddress _lp\n\t) external hasValidPermit(UNIVERSAL, CONFIGURE_LP) {\n\t\tif (lpLocked) {\n\t\t\trevert LockedConfigurationOfLP();\n\t\t}\n\t\tLP = _lp;\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to forever prevent alteration of the \n\t\tLP token contract address.\n\t*/\n\tfunction lockLP () external hasValidPermit(UNIVERSAL, CONFIGURE_LP) {\n\t\tlpLocked = true;\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to configure the timelock options \n\t\tavailable for each type of asset.\n\n\t\t@param _assetType The type of asset whose timelock options are being \n\t\t\tconfigured.\n\t\t@param _timelockIds An array with IDs for specific timelock options \n\t\t\tavailable under `_assetType`.\n\t\t@param _encodedSettings An array keyed to `_timelockIds` containing a \n\t\t\tbit-packed value specifying the details of the timelock. The upper 128 \n\t\t\tbits are the timelock duration and the lower 128 bits are the multiplier.\n\t*/\n\tfunction configureTimelockOptions (\n\t\tAssetType _assetType,\n\t\tuint256[] memory _timelockIds,\n\t\tuint256[] memory _encodedSettings\n\t) external hasValidPermit(bytes32(uint256(_assetType)), CONFIGURE_TIMELOCKS) {\n\t\tfor (uint256 i; i < _timelockIds.length; ) {\n\t\t\ttimelockOptions[_assetType][_timelockIds[i]] = _encodedSettings[i];\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to configure the double mapping of \n\t\tcombined S1 Citizen reward rates and Vault reward credit multipliers \n\t\trequired to deduce the resulting S1 Identity \"Credit Yield\" strings.\n\n\t\t@param _citizenRewardRates An array of S1 Citizen reward rate values.\n\t\t@param _vaultRewardRates An array of Vault reward rate multipliers \n\t\t\tcorresponding to the provided `_citizenRewardRates`.\n\t\t@param _identityCreditYields An array of the S1 Identity \"Credit Yield\" \n\t\t\tstrings that must correspond to the provided `_citizenRewardRates` and \n\t\t\t`_vaultRewardRates`.\n\t*/\n\tfunction configureIdentityCreditYields (\n\t\tuint256[] memory _citizenRewardRates, \n\t\tstring[] memory _vaultRewardRates,\n\t\tstring[] memory _identityCreditYields\n\t) hasValidPermit(UNIVERSAL, CONFIGURE_CREDITS) external {\n\t\tfor (uint256 i; i < _citizenRewardRates.length; ) {\n\t\t\tidentityCreditYield[\n\t\t\t\t_citizenRewardRates[i]\n\t\t\t][\n\t\t\t\t_vaultRewardRates[i]\n\t\t\t] = _identityCreditYields[i];\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/**\n\t\tThis funciton allows a permitted user to override the base points \n\t\tassociated with a particular S1 Identity \"Credit Yield\" string.\n\n\t\t@param _identityCreditYields An array of S1 Identity \"Credit Yield\" strings.\n\t\t@param _points The base points associated with each value in \n\t\t\t`_identityCreditYields`.\n\t*/\n\tfunction configureIdentityCreditPoints (\n\t\tstring[] memory _identityCreditYields,\n\t\tuint256[] memory _points\n\t) hasValidPermit(UNIVERSAL, CONFIGURE_CREDITS) external {\n\t\tfor (uint256 i; i < _identityCreditYields.length; ) {\n\t\t\tidentityCreditPoints[_identityCreditYields[i]] = _points[i];\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to override the S1 Vault multiplier \n\t\trates associated with a particular S1 Vault \"credit multiplier\" string.\n\n\t\t@param _vaultCreditMultipliers An array of S1 Vault credit multiplier \n\t\t\tstrings.\n\t\t@param _multipliers An array of multipliers, in basis points, keyed to each \n\t\t\tvalue in `_vaultCreditMultipliers`.\n\t*/\n\tfunction configureVaultCreditMultipliers (\n\t\tstring[] memory _vaultCreditMultipliers,\n\t\tuint256[] memory _multipliers\n\t) hasValidPermit(UNIVERSAL, CONFIGURE_CREDITS) external {\n\t\tfor (uint256 i; i < _vaultCreditMultipliers.length; ) {\n\t\t\tvaultCreditMultiplier[_vaultCreditMultipliers[i]] = _multipliers[i];\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to set the reward emission and DAO \n\t\ttax rates of the asset staking pools.\n\n\t\t@param _inputs An array of `PoolConfigurationInput` structs defining \n\t\t\tconfiguration details for each of the pools being updated.\n\t*/\n\tfunction configurePools (\n\t\tPoolConfigurationInput[] memory _inputs\n\t) hasValidPermit(UNIVERSAL, CONFIGURE_POOLS) external {\n\t\tfor (uint256 i; i < _inputs.length; ) {\n\t\t\tuint256 poolRewardWindowCount = _inputs[i].rewardWindows.length;\n\t\t\t_pools[_inputs[i].assetType].rewardCount = poolRewardWindowCount;\n\t\t\t_pools[_inputs[i].assetType].daoTax = _inputs[i].daoTax;\n\n\t\t\t// Set the pool reward window details by populating the mapping.\n\t\t\tuint256 lastTime;\n\t\t\tfor (uint256 j; j < poolRewardWindowCount; ) {\n\t\t\t\t_pools[_inputs[i].assetType].rewardWindows[j] =\n\t\t\t\t\t_inputs[i].rewardWindows[j];\n\n\t\t\t\t// Revert if an invalid pool configuration is supplied.\n\t\t\t\tif (j != 0 && _inputs[i].rewardWindows[j].startTime <= lastTime) {\n\t\t\t\t\trevert RewardWindowTimesMustIncrease();\n\t\t\t\t}\n\t\t\t\tlastTime = _inputs[i].rewardWindows[j].startTime;\n\t\t\t\tunchecked { j++; }\n\t\t\t}\n\t\t\tunchecked { ++i; }\n\t\t}\n\t}\n\n\t/**\n\t\tThis function allows a permitted user to update the vaulted and unvaulted \n\t\tCitizen BYTES staking caps.\n\n\t\t@param _vaultedCap The new cap of BYTES staking on vaulted Citizens.\n\t\t@param _unvaultedCap The new cap of BYTES staking on unvaulted Citizens.\n\t*/\n\tfunction configureCaps (\n\t\tuint256 _vaultedCap,\n\t\tuint256 _unvaultedCap\n\t) hasValidPermit(UNIVERSAL, CONFIGURE_CAPS) external {\n\t\tVAULT_CAP = _vaultedCap;\n\t\tNO_VAULT_CAP = _unvaultedCap;\n\t}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "lib/Bytes2.0/contracts/access/PermitControl.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title An advanced permission-management contract.\n\t@author Tim Clancy <@_Enoch>\n\n\tThis contract allows for a contract owner to delegate specific rights to\n\texternal addresses. Additionally, these rights can be gated behind certain\n\tsets of circumstances and granted expiration times. This is useful for some\n\tmore finely-grained access control in contracts.\n\n\tThe owner of this contract is always a fully-permissioned super-administrator.\n\n\t@custom:date August 23rd, 2021.\n*/\nabstract contract PermitControl is Ownable {\n\tusing Address for address;\n\n\t/// A special reserved constant for representing no rights.\n\tbytes32 public constant ZERO_RIGHT = hex\"00000000000000000000000000000000\";\n\n\t/// A special constant specifying the unique, universal-rights circumstance.\n\tbytes32 public constant UNIVERSAL = hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n\n\t/**\n\t\tA special constant specifying the unique manager right. This right allows an\n\t\taddress to freely-manipulate the `managedRight` mapping.\n\t*/\n\tbytes32 public constant MANAGER = hex\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n\n\t/**\n\t\tA mapping of per-address permissions to the circumstances, represented as\n\t\tan additional layer of generic bytes32 data, under which the addresses have\n\t\tvarious permits. A permit in this sense is represented by a per-circumstance\n\t\tmapping which couples some right, represented as a generic bytes32, to an\n\t\texpiration time wherein the right may no longer be exercised. An expiration\n\t\ttime of 0 indicates that there is in fact no permit for the specified\n\t\taddress to exercise the specified right under the specified circumstance.\n\n\t\t@dev Universal rights MUST be stored under the 0xFFFFFFFFFFFFFFFFFFFFFFFF...\n\t\tmax-integer circumstance. Perpetual rights may be given an expiry time of\n\t\tmax-integer.\n\t*/\n\tmapping ( address => mapping( bytes32 => mapping( bytes32 => uint256 ))) \n\t\tpublic permissions;\n\n\t/**\n\t\tAn additional mapping of managed rights to manager rights. This mapping\n\t\trepresents the administrator relationship that various rights have with one\n\t\tanother. An address with a manager right may freely set permits for that\n\t\tmanager right's managed rights. Each right may be managed by only one other\n\t\tright.\n\t*/\n\tmapping ( bytes32 => bytes32 ) public managerRight;\n\n\t/**\n\t\tAn event emitted when an address has a permit updated. This event captures,\n\t\tthrough its various parameter combinations, the cases of granting a permit,\n\t\tupdating the expiration time of a permit, or revoking a permit.\n\n\t\t@param updater The address which has updated the permit.\n\t\t@param updatee The address whose permit was updated.\n\t\t@param circumstance The circumstance wherein the permit was updated.\n\t\t@param role The role which was updated.\n\t\t@param expirationTime The time when the permit expires.\n\t*/\n\tevent PermitUpdated (\n\t\taddress indexed updater,\n\t\taddress indexed updatee,\n\t\tbytes32 circumstance,\n\t\tbytes32 indexed role,\n\t\tuint256 expirationTime\n\t);\n\n\t/**\n\t\tAn event emitted when a management relationship in `managerRight` is\n\t\tupdated. This event captures adding and revoking management permissions via\n\t\tobserving the update history of the `managerRight` value.\n\n\t\t@param manager The address of the manager performing this update.\n\t\t@param managedRight The right which had its manager updated.\n\t\t@param managerRight The new manager right which was updated to.\n\t*/\n\tevent ManagementUpdated (\n\t\taddress indexed manager,\n\t\tbytes32 indexed managedRight,\n\t\tbytes32 indexed managerRight\n\t);\n\n\t/**\n\t\tA modifier which allows only the super-administrative owner or addresses\n\t\twith a specified valid right to perform a call.\n\n\t\t@param _circumstance The circumstance under which to check for the validity\n\t\t\tof the specified `right`.\n\t\t@param _right The right to validate for the calling address. It must be\n\t\t\tnon-expired and exist within the specified `_circumstance`.\n\t*/\n\tmodifier hasValidPermit (\n\t\tbytes32 _circumstance,\n\t\tbytes32 _right\n\t) {\n\t\trequire(\n\t\t\t_msgSender() == owner() || hasRight(_msgSender(), _circumstance, _right),\n\t\t\t\"P1\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t\tSet the `_managerRight` whose `UNIVERSAL` holders may freely manage the\n\t\tspecified `_managedRight`.\n\n\t\t@param _managedRight The right which is to have its manager set to\n\t\t\t`_managerRight`.\n\t\t@param _managerRight The right whose `UNIVERSAL` holders may manage\n\t\t\t`_managedRight`.\n\t*/\n\tfunction setManagerRight (\n\t\tbytes32 _managedRight,\n\t\tbytes32 _managerRight\n\t) external virtual hasValidPermit(UNIVERSAL, MANAGER) {\n\t\trequire(_managedRight != ZERO_RIGHT, \"P3\");\n\t\tmanagerRight[_managedRight] = _managerRight;\n\t\temit ManagementUpdated(_msgSender(), _managedRight, _managerRight);\n\t}\n\n\t/**\n\t\tSet the permit to a specific address under some circumstances. A permit may\n\t\tonly be set by the super-administrative contract owner or an address holding\n\t\tsome delegated management permit.\n\n\t\t@param _address The address to assign the specified `_right` to.\n\t\t@param _circumstance The circumstance in which the `_right` is valid.\n\t\t@param _right The specific right to assign.\n\t\t@param _expirationTime The time when the `_right` expires for the provided\n\t\t\t`_circumstance`.\n\t*/\n\tfunction setPermit (\n\t\taddress _address,\n\t\tbytes32 _circumstance,\n\t\tbytes32 _right,\n\t\tuint256 _expirationTime\n\t) public virtual hasValidPermit(UNIVERSAL, managerRight[_right]) {\n\t\trequire(_right != ZERO_RIGHT, \"P2\");\n\t\tpermissions[_address][_circumstance][_right] = _expirationTime;\n\t\temit PermitUpdated(\n\t\t\t_msgSender(),\n\t\t\t_address,\n\t\t\t_circumstance,\n\t\t\t_right,\n\t\t\t_expirationTime\n\t\t);\n\t}\n\n\t/**\n\t\tDetermine whether or not an address has some rights under the given\n\t\tcircumstance, and if they do have the right, until when.\n\n\t\t@param _address The address to check for the specified `_right`.\n\t\t@param _circumstance The circumstance to check the specified `_right` for.\n\t\t@param _right The right to check for validity.\n\n\t\t@return The timestamp in seconds when the `_right` expires. If the timestamp\n\t\t\tis zero, we can assume that the user never had the right.\n\t*/\n\tfunction hasRightUntil (\n\t\taddress _address,\n\t\tbytes32 _circumstance,\n\t\tbytes32 _right\n\t) public view returns (uint256) {\n\t\treturn permissions[_address][_circumstance][_right];\n\t}\n\n\t/**\n\t\tDetermine whether or not an address has some rights under the given\n\t\tcircumstance,\n\n\t\t@param _address The address to check for the specified `_right`.\n\t\t@param _circumstance The circumstance to check the specified `_right` for.\n\t\t@param _right The right to check for validity.\n\n\t\t@return true or false, whether user has rights and time is valid.\n\t*/\n\tfunction hasRight (\n\t\taddress _address,\n\t\tbytes32 _circumstance,\n\t\tbytes32 _right\n\t) public view returns (bool) {\n\t\treturn permissions[_address][_circumstance][_right] > block.timestamp;\n\t}\n}\n"
    },
    "lib/Bytes2.0/contracts/interfaces/IByteContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title A migrated ERC-20 BYTES token contract for the Neo Tokyo ecosystem.\n\t@author Tim Clancy <@_Enoch>\n\n\tThis is the interface for the BYTES 2.0 contract.\n\n\t@custom:date February 14th, 2023.\n*/\ninterface IByteContract {\n\n\t/**\n\t\tPermit authorized callers to burn BYTES from the `_from` address. When \n\t\tBYTES are burnt, 2/3 of the BYTES are sent to the DAO treasury. This \n\t\toperation is never expected to overflow given operational bounds on the \n\t\tamount of BYTES tokens ever allowed to enter circulation.\n\n\t\t@param _from The address to burn tokens from.\n\t\t@param _amount The amount of tokens to burn.\n\t*/\n\tfunction burn (\n\t\taddress _from,\n\t\tuint256 _amount\n\t) external;\n\t\n\t/**\n\t\tThis function is called by the S1 Citizen contract to emit BYTES to callers \n\t\tbased on their state from the staker contract.\n\n\t\t@param _to The reward address to mint BYTES to.\n\t*/\n\tfunction getReward (\n\t\taddress _to\n\t) external;\n}\n"
    },
    "lib/Bytes2.0/contracts/interfaces/IGenericGetter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.19;\n\n/**\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\n\t@title A generic interface for getting details in the Neo Tokyo ecosystem.\n\t@author Tim Clancy <@_Enoch>\n\t@author Rostislav Khlebnikov <@catpic5buck>\n\n\tThis is a lazy interface that combines various functions from different \n\tindependent contracts in the Neo Tokyo ecosystem.\n\n\t@custom:date February 14th, 2023.\n*/\ninterface IGenericGetter {\n\t\n\t// S1 Citizen\n\n\t/**\n\t\tRetrieve the total reward rate of a Neo Tokyo S1 Citizen. This reward rate \n\t\tis a function of the S1 Citizen's underlying Identity and any optional \n\t\tVault that has been assembled into the S1 Citizen.\n\n\t\t@param _citizenId The ID of the S1 Citizen to get a reward rate for. If the \n\t\t\treward rate is zero, then the S1 Citizen does not exist.\n\n\t\t@return _ The reward rate of `_citizenId`.\n\t*/\n\tfunction getRewardRateOfTokenId (\n\t\tuint256 _citizenId\n\t) external view returns (uint256);\n\n\t/**\n\t\tRetrieve the token ID of an S1 Citizen's component Identity.\n\n\t\t@param _citizenId The ID of the S1 Citizen to get an Identity ID for.\n\n\t\t@return _ The token ID of the component Identity for `_citizenId`.\n\t*/\n\tfunction getIdentityIdOfTokenId (\n\t\tuint256 _citizenId\n\t) external view returns (uint256);\n\n\t// S1 Identity\n\n\t/**\n\t\tRetrieve the class of an S1 Identity.\n\n\t\t@param _identityId The token ID of the S1 Identity to get the class for.\n\n\t\t@return _ The class of the Identity with token ID `_identityId`.\n\t*/\n\tfunction getClass (\n\t\tuint256 _identityId\n\t) external view returns (string memory);\n\n\t// S1 Vault\n\n\t/**\n\t\tRetrieve the credit multiplier string associated with a particular Vault.\n\n\t\t@param _vaultId The ID of the Vault to get the credit multiplier for.\n\n\t\t@return _ The credit multiplier string associated with `_vaultId`.\n\t*/\n\tfunction getCreditMultiplier (\n\t\tuint256 _vaultId\n\t) external view returns (string memory);\n\n\t// S1 Citizen\n\n\t/**\n\t\tRetrieve the token ID of a component Vault in a particular S1 Citizen with \n\t\tthe token ID of `_tokenId`.\n\n\t\t@param _tokenId The ID of the S1 Citizen to retrieve the Vault token ID for.\n\n\t\t@return _ The correspnding Vault token ID.\n\t*/\n\tfunction getVaultIdOfTokenId (\n\t\tuint256 _tokenId\n\t) external view returns (uint256);\n}\n"
    },
    "lib/Bytes2.0/contracts/interfaces/INTStakedToken.sol": {
      "content": "pragma solidity ^0.8.19;\n\ninterface INTStakedToken {\n\n    function give(address to, bytes calldata metadata, bytes calldata) external returns(uint256);\n\n    function burn(uint256 tokenId) external returns (uint256);\n}"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "Bytes2.0/=lib/Bytes2.0/contracts/",
      "bytes/=lib/Bytes2.0/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "nt-with-oracle/=lib/nt-with-oracle/contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/contracts/",
      "operator-filter-registry/=lib/operator-filter-registry/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "metadata": {
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}