{{
  "language": "Solidity",
  "sources": {
    "contracts/DoomsdaySettlers.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\nimport \"./interfaces/IDoomsdaySettlersDarkAge.sol\";\r\nimport \"./interfaces/IDoomsdaySettlersMetadata.sol\";\r\n\r\ncontract DoomsdaySettlers {\r\n\r\n    struct Settlement{\r\n        uint32 settleBlock;\r\n        uint24 supplyAtMint;\r\n        uint16 age;\r\n        uint8 settlementType;\r\n        uint80 relics;\r\n        uint80 supplies;\r\n    }\r\n\r\n    uint80 constant CREATOR_PERCENT = 15;\r\n    uint80 constant DESTRUCTION_FEE = 0.01 ether;\r\n    uint80 constant REINFORCE_PERCENT_WINNER  = 85;\r\n    uint80 constant REINFORCE_PERCENT_CREATOR = 15;\r\n    uint256 constant BLOCK_TIME = 12 seconds;\r\n\r\n    uint256 immutable BASE_DIFFICULTY;\r\n    uint256 immutable DIFFICULTY_RAMP;\r\n    uint256 immutable DIFFICULTY_COOLDOWN;\r\n    uint256 immutable DIFFICULTY_COOLDOWN_SLOPE;\r\n    address immutable DARK_AGE;\r\n    uint256 immutable COLLAPSE_INITIAL;\r\n    uint256 immutable COLLAPSE_RAMP;\r\n    uint256 immutable COLLAPSE_MIN;\r\n\r\n    uint16 age = 1;\r\n    uint32 firstSettlement;\r\n    uint32 abandoned;\r\n    bool itIsTheDawnOfANewAge;\r\n    address public owner;\r\n    address public creator;\r\n    uint80 supplies;\r\n    uint80 relics;\r\n    uint80 public mintFee;\r\n    uint80 creatorEarnings;\r\n    uint256 creatorRoyaltiesBasisPoints;\r\n\r\n    bytes32[] hashes;\r\n\r\n    mapping( uint32 => Settlement) public settlements;\r\n\r\n    event Settle(uint32 _tokenId, bytes32 _hash, address _settler, uint24 _newSupply, uint80 _newMintFee, uint32 _collapseBlock, uint8 _settlementType, uint32 _blockNumber);\r\n    event Abandon(uint32 _tokenId, bytes32 _hash, uint80 _growth, uint24 _supplyAtMint, uint32 _newAbandoned, uint80 _newMintFee, uint80 _eth, uint32 _settled, bool _itIsTheDawnOfANewAge, uint32 _blockNumber);\r\n    event Reinforce(uint32 indexed _tokenId, uint8 _type);\r\n    event Disaster(uint32 indexed _tokenId, uint8 _type, bool _destroyed, bool _darkAgeOver);\r\n\r\n    constructor(\r\n            address _darkAge,\r\n            uint256 _BASE_DIFFICULTY,\r\n            uint256 _DIFFICULTY_RAMP,\r\n            uint256 _DIFFICULTY_COOLDOWN,\r\n            uint256 _DIFFICULTY_COOLDOWN_SLOPE,\r\n            uint256 _COLLAPSE_INITIAL,\r\n            uint256 _COLLAPSE_RAMP,\r\n            uint256 _COLLAPSE_MIN\r\n        ) payable {\r\n\r\n        BASE_DIFFICULTY     = _BASE_DIFFICULTY;\r\n        DIFFICULTY_RAMP     = _DIFFICULTY_RAMP;\r\n        DIFFICULTY_COOLDOWN = _DIFFICULTY_COOLDOWN;\r\n        DIFFICULTY_COOLDOWN_SLOPE = _DIFFICULTY_COOLDOWN_SLOPE;\r\n        COLLAPSE_INITIAL    = _COLLAPSE_INITIAL;\r\n        COLLAPSE_RAMP       = _COLLAPSE_RAMP;\r\n        COLLAPSE_MIN        = _COLLAPSE_MIN;\r\n\r\n        DARK_AGE = _darkAge;\r\n\r\n        require(msg.value == DESTRUCTION_FEE,\"destruction\");\r\n\r\n        // ERC165 stuff\r\n        supportsInterface[0x80ac58cd] = true; //ERC721\r\n        supportsInterface[0x5b5e139f] = true; //ERC721Metadata\r\n        supportsInterface[0x01ffc9a7] = true; //ERC165\r\n        supportsInterface[0x2a55205a] = true; //ERC2981\r\n\r\n        owner = msg.sender;\r\n        creator = msg.sender;\r\n\r\n        bytes32 _hash = blockhash(block.number - 1);\r\n        uint256 _settlementType = settlementType(_hash,0);\r\n\r\n        _mint(1,msg.sender,_hash);\r\n        settlements[1] = Settlement(uint32(block.number),0,age,uint8(_settlementType), 0,0);\r\n        mintFee += uint80((uint88(2363029719748390562045450) >> _settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n        firstSettlement = 1;\r\n    }\r\n\r\n    function settle(uint256 location) external payable {\r\n        require(!isDarkAge(),\"dark age\");\r\n\r\n        unchecked{\r\n            require(address(this).balance < type(uint80).max,\"balance overflow failsafe\");\r\n\r\n            uint32 tokenId = uint32(hashes.length + 1);\r\n\r\n            if(itIsTheDawnOfANewAge){\r\n                ++age;\r\n                firstSettlement = tokenId;\r\n                itIsTheDawnOfANewAge = false;\r\n            }\r\n\r\n            uint256 supply = uint256(hashes.length - abandoned);\r\n            uint256 difficulty = BASE_DIFFICULTY - (DIFFICULTY_RAMP * supply);\r\n            uint256 lastSettleBlock = settlements[uint32(hashes.length )].settleBlock;\r\n\r\n            require(block.number > lastSettleBlock,\"lastSettleBlock\");\r\n            uint256 blockDif = (block.number - lastSettleBlock);\r\n\r\n            if(blockDif < DIFFICULTY_COOLDOWN){\r\n                difficulty /= DIFFICULTY_COOLDOWN_SLOPE * (DIFFICULTY_COOLDOWN - blockDif);\r\n            }\r\n\r\n            uint256 cost = uint256(mintFee) + DESTRUCTION_FEE;\r\n            uint80 creatorFee = uint80(cost * CREATOR_PERCENT / 100);\r\n            creatorEarnings += creatorFee;\r\n            cost += creatorFee;\r\n\r\n            bytes32 hash = keccak256(abi.encodePacked(\r\n                    msg.sender,\r\n                    hashes[hashes.length - 1],\r\n                    location\r\n                ));\r\n\r\n            require(uint256(hash) < difficulty,\"difficulty\");\r\n            require(msg.value >= cost,\"cost\");\r\n            uint8 _settlementType = uint8(settlementType(hash,supply));\r\n\r\n            hash = keccak256(abi.encodePacked(hash,block.prevrandao));\r\n            settlements[tokenId] = Settlement( uint32(block.number), uint24(supply), age, _settlementType, 0, 0);\r\n            relics += mintFee/2;\r\n            mintFee +=    uint80((uint88(2363029719748390562045450) >> _settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n            ++supply;\r\n\r\n            uint256 collapse;\r\n            if(supply * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\r\n                collapse = COLLAPSE_INITIAL - supply * COLLAPSE_RAMP;\r\n            } else{\r\n                collapse = COLLAPSE_MIN;\r\n            }\r\n\r\n            _mint(tokenId,msg.sender,hash);\r\n            emit Settle(tokenId, hash, msg.sender, uint24(supply), mintFee, uint32(block.number + collapse / BLOCK_TIME), _settlementType, uint32(block.number));\r\n\r\n            require(gasleft() > 10000,\"gas failsafe\");\r\n            if(msg.value > cost){\r\n                payable(msg.sender).transfer(msg.value - cost);\r\n            }\r\n        }\r\n    }\r\n\r\n    function abandon(uint32 _tokenId, uint32 _data) external {\r\n        payable(msg.sender).transfer(_abandon(_tokenId,_data));\r\n    }\r\n\r\n    function abandonMultiple(uint32[] calldata _tokenIds, uint32 _data) external {\r\n        unchecked{\r\n            require(_tokenIds.length > 0,\"tokenIds\");\r\n            uint256 total;\r\n            for(uint256 i = 0; i < _tokenIds.length; ++i){\r\n                total += _abandon(_tokenIds[i],_data);\r\n            }\r\n            payable(msg.sender).transfer(total);\r\n        }\r\n    }\r\n\r\n    function confirmDisaster(uint32 _tokenId, uint32 _data) external {\r\n        require(isDarkAge(),\"dark age\");\r\n        require(_isValidToken(_tokenId),\"invalid\");\r\n\r\n        uint8 _type;\r\n        bool destroyed;\r\n\r\n        unchecked{\r\n            (_type, destroyed) =\r\n                IDoomsdaySettlersDarkAge(DARK_AGE).disaster(_tokenId, hashes.length - abandoned);\r\n        }\r\n\r\n        bool darkAgeOver = false;\r\n        if(destroyed){\r\n           unchecked{\r\n                uint80 tokenFee = uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n\r\n                uint80 growth;\r\n                if(_tokenId >= firstSettlement){\r\n                    growth = uint80(hashes.length - _tokenId);\r\n                }else{\r\n                    growth = uint80(hashes.length - firstSettlement) + 1;\r\n                }\r\n                uint80 _relics = growth * tokenFee;\r\n\r\n                relics += _relics/2 +\r\n                           settlements[_tokenId].relics +\r\n                           settlements[_tokenId].supplies +\r\n                           IDoomsdaySettlersDarkAge(DARK_AGE).getUnusedFees(_tokenId) * DESTRUCTION_FEE;\r\n\r\n                ++abandoned;\r\n                _burn(_tokenId);\r\n                if(hashes.length - abandoned == 1){\r\n                    _processWinner(_data);\r\n                    darkAgeOver = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Disaster(_tokenId,_type,destroyed, darkAgeOver);\r\n        payable(msg.sender).transfer(DESTRUCTION_FEE);\r\n    }\r\n\r\n    function reinforce(uint32 _tokenId, bool[4] memory _resources) external payable{\r\n        require(msg.sender == ownerOf(_tokenId),\"ownerOf\");\r\n        unchecked{\r\n            require(address(this).balance < type(uint80).max,\"balance overflow failsafe\");\r\n            uint80 cost = IDoomsdaySettlersDarkAge(DARK_AGE).reinforce(\r\n                _tokenId,\r\n                hashOf(_tokenId),\r\n                _resources,\r\n                isDarkAge()\r\n            );\r\n            uint80 total;\r\n            for(uint256 i = 0; i < 4; ++i){\r\n                if(_resources[i]){\r\n                    total += DESTRUCTION_FEE;\r\n                    emit Reinforce(_tokenId,uint8(i));\r\n                }\r\n            }\r\n            require(total > 0,\"empty\");\r\n\r\n            cost *= mintFee / uint80(4);\r\n            total += cost;\r\n\r\n            require(total <= msg.value,\"msg.value\");\r\n\r\n            creatorEarnings += cost * REINFORCE_PERCENT_CREATOR / 100;\r\n            supplies        += cost * REINFORCE_PERCENT_WINNER  / 100;\r\n\r\n            require(gasleft() > 10000,\"gas failsafe\");\r\n            if(msg.value > total){\r\n                payable(msg.sender).transfer(msg.value - total);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getGrowth(uint32 _tokenId) external view returns(uint80){\r\n        uint80 growth;\r\n        if(_tokenId >= firstSettlement){\r\n            growth = uint80(hashes.length - _tokenId);\r\n        }else{\r\n            growth = uint80(hashes.length - firstSettlement) + 1;\r\n        }\r\n        return growth * uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n    }\r\n\r\n    function miningState() external view returns(\r\n            bytes32 _lastHash,\r\n            uint32 _settled,\r\n            uint32 _abandoned,\r\n            uint32 _lastSettleBlock,\r\n            uint32 _collapseBlock,\r\n            uint80 _mintFee,\r\n            uint256 _blockNumber\r\n        ){\r\n        uint256 collapseBlock = settlements[uint32(hashes.length )].settleBlock;\r\n        uint32 collapseSupply = settlements[uint32(hashes.length)].supplyAtMint + 1;\r\n\r\n        if(collapseSupply * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\r\n            collapseBlock += ( COLLAPSE_INITIAL - collapseSupply * COLLAPSE_RAMP ) / BLOCK_TIME;\r\n        } else{\r\n            collapseBlock +=  COLLAPSE_MIN / BLOCK_TIME;\r\n        }\r\n        return (\r\n            hashes[hashes.length - 1],\r\n            uint32(hashes.length),\r\n            abandoned,\r\n            settlements[uint32(hashes.length)].settleBlock,\r\n            uint32(collapseBlock),\r\n            mintFee,\r\n            block.number\r\n        );\r\n    }\r\n\r\n    function currentState() external view returns(\r\n            bool _itIsTheDawnOfANewAge,\r\n            uint32 _firstSettlement,\r\n            uint16 _age,\r\n            uint80 _creatorEarnings,\r\n            uint80 _relics,\r\n            uint80 _supplies,\r\n            uint256 _blockNumber\r\n        ){\r\n        return (\r\n            itIsTheDawnOfANewAge,\r\n            firstSettlement,\r\n            age,\r\n            creatorEarnings,\r\n            relics,\r\n            supplies,\r\n            block.number\r\n        );\r\n    }\r\n\r\n\r\n    function settlementType(bytes32 hash, uint256 _supplyAtMint) public pure returns(uint256){\r\n        unchecked{\r\n            uint256 settlementTypeMax = _supplyAtMint / 1000 + 2 ;\r\n            if(settlementTypeMax > 8) settlementTypeMax = 8;\r\n            return (uint256(hash)%100)**2 * ( settlementTypeMax + 1 ) / 1_00_00;\r\n        }\r\n    }\r\n\r\n    function isDarkAge() public view returns(bool){\r\n        unchecked{\r\n            uint256 supply = (hashes.length - abandoned);\r\n            uint256 collapseBlock = settlements[uint32(hashes.length)].settleBlock;\r\n            uint32 collapseSupply = settlements[uint32(hashes.length)].supplyAtMint + 1;\r\n\r\n            if(collapseSupply * COLLAPSE_RAMP <  COLLAPSE_INITIAL - COLLAPSE_MIN){\r\n                collapseBlock += ( COLLAPSE_INITIAL - collapseSupply * COLLAPSE_RAMP ) / BLOCK_TIME;\r\n            } else{\r\n                collapseBlock +=  COLLAPSE_MIN / BLOCK_TIME;\r\n            }\r\n            return supply > 1 && (block.number > collapseBlock );\r\n        }\r\n    }\r\n\r\n\r\n    function hashOf(uint32 _tokenId) public view returns(bytes32){\r\n        require(_isValidToken(_tokenId),\"invalid\");\r\n        unchecked{\r\n            return hashes[_tokenId - 1];\r\n        }\r\n    }\r\n\r\n    function getLastHash() external view returns(bytes32){\r\n        return hashes[hashes.length - 1];\r\n    }\r\n\r\n    function getCost() external view returns(uint256){\r\n        uint256 cost = uint256(mintFee) + DESTRUCTION_FEE;\r\n        uint256 creatorFee = cost * CREATOR_PERCENT / 100;\r\n        cost += creatorFee;\r\n        return cost;\r\n    }\r\n\r\n\r\n    function _processWinner(uint32 _winner) private{\r\n        require(_isValidToken(_winner),\"invalid\");\r\n        unchecked{\r\n            settlements[_winner].relics     += relics;\r\n            settlements[_winner].supplies   += supplies;\r\n\r\n            uint80 tokenFee = uint80((uint88(2363029719748390562045450) >> settlements[_winner].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n            uint80 growth;\r\n            if(_winner > firstSettlement){\r\n                growth = uint80(hashes.length) - uint80(_winner);\r\n            }else{\r\n                growth = (uint80(hashes.length) - uint80(firstSettlement)) + 1;\r\n            }\r\n            uint80 _relics = growth * tokenFee;\r\n            settlements[_winner].relics += _relics / 2;\r\n            relics = 0;\r\n            supplies = 0;\r\n            mintFee = tokenFee;\r\n            itIsTheDawnOfANewAge = true;\r\n        }\r\n    }\r\n\r\n    function _abandon(uint32 _tokenId, uint32 _data) private returns(uint256){\r\n        unchecked{\r\n            require(msg.sender == ownerOf(_tokenId),\"ownerOf\");\r\n            bytes32 hash = hashes[_tokenId - 1];\r\n            uint80 growth;\r\n            if(_tokenId >= firstSettlement){\r\n                growth = uint80(hashes.length - _tokenId);\r\n            }else{\r\n                growth = uint80(hashes.length) - uint80(firstSettlement) + 1;\r\n            }\r\n\r\n            uint80 _relics;\r\n            if(!itIsTheDawnOfANewAge){\r\n                _relics = growth * uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n            }\r\n\r\n            bool _isDarkAge = isDarkAge();\r\n            if(_isDarkAge){\r\n                require(!IDoomsdaySettlersDarkAge(DARK_AGE).checkVulnerable(_tokenId),\"vulnerable\");\r\n                _relics /= 2;\r\n                uint80 spoils = uint80(relics) / uint80(hashes.length - abandoned) / 2;\r\n                _relics += spoils;\r\n                relics -= spoils;\r\n            }else if(!itIsTheDawnOfANewAge){\r\n                relics -= _relics / 2;\r\n                mintFee -= uint80((uint88(2363029719748390562045450) >> settlements[_tokenId].settlementType * 9)%uint88(512))  * uint80(0.000001 ether);\r\n            }\r\n\r\n            ++abandoned;\r\n            _relics +=\r\n                (uint80(1) + IDoomsdaySettlersDarkAge(DARK_AGE).getUnusedFees(_tokenId)) * DESTRUCTION_FEE\r\n                + settlements[_tokenId].relics\r\n                + settlements[_tokenId].supplies;\r\n\r\n            _burn(_tokenId);\r\n            if(_isDarkAge){\r\n                if(hashes.length - abandoned == 1){\r\n                    _processWinner(_data);\r\n                }\r\n            }\r\n            emit Abandon(\r\n                _tokenId,\r\n                hash,\r\n                growth,\r\n                settlements[_tokenId].supplyAtMint,\r\n                abandoned,\r\n                mintFee,\r\n                _relics,\r\n                uint32(hashes.length),\r\n                itIsTheDawnOfANewAge,\r\n                uint32(block.number)\r\n            );\r\n            return _relics;\r\n        }\r\n    }\r\n\r\n\r\n\r\n//////===721 Standard\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n//////===721 Implementation\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping (uint256 => address) internal allowance;\r\n    mapping (address => mapping (address => bool)) public isApprovedForAll;\r\n\r\n    mapping(uint256 => address) owners;\r\n\r\n//    METADATA VARS\r\n    string constant public name = \"Doomsday: Settlers of the Wasteland\";\r\n    string constant public symbol = \"SETTLEMENT\";\r\n\r\n    address private __metadata;\r\n    function _mint(uint256 _tokenId,address _to, bytes32 _hash) private{\r\n        unchecked{\r\n            owners[_tokenId] = msg.sender;\r\n            ++balanceOf[_to];\r\n            hashes.push(_hash);\r\n            emit Transfer(address(0),_to,_tokenId);\r\n        }\r\n    }\r\n    function _burn(uint256 _tokenId) private{\r\n        unchecked{\r\n            address _owner = owners[_tokenId];\r\n            --balanceOf[ _owner ];\r\n            delete owners[_tokenId];\r\n            emit Transfer(_owner,address(0),_tokenId);\r\n        }\r\n    }\r\n\r\n    function _isValidToken(uint256 _tokenId) internal view returns(bool){\r\n        return owners[_tokenId] != address(0);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns(address){\r\n        require(_isValidToken(_tokenId),\"invalid\");\r\n        return owners[_tokenId];\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)  external{\r\n        address _owner = ownerOf(_tokenId);\r\n        require( _owner == msg.sender\r\n            || isApprovedForAll[_owner][msg.sender]\r\n        ,\"permission\");\r\n        emit Approval(_owner, _approved, _tokenId);\r\n        allowance[_tokenId] = _approved;\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        require(_isValidToken(_tokenId),\"invalid\");\r\n        return allowance[_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        isApprovedForAll[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\r\n        address _owner = ownerOf(_tokenId);\r\n        if(isDarkAge()){\r\n            require(!IDoomsdaySettlersDarkAge(DARK_AGE).checkVulnerable(uint32(_tokenId)),\"vulnerable\");\r\n        }\r\n        require ( _owner == msg.sender\r\n            || allowance[_tokenId] == msg.sender\r\n            || isApprovedForAll[_owner][msg.sender]\r\n        ,\"permission\");\r\n\r\n        require(_owner == _from,\"owner\");\r\n        require(_to != address(0),\"zero\");\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n        owners[_tokenId] =_to;\r\n        --balanceOf[_from];\r\n        ++balanceOf[_to];\r\n\r\n        if(allowance[_tokenId] != address(0)){\r\n            delete allowance[_tokenId];\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\r\n        transferFrom(_from, _to, _tokenId);\r\n\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if(size > 0){\r\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(0x150b7a02),\"receiver\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        safeTransferFrom(_from,_to,_tokenId,\"\");\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory){\r\n        require(_isValidToken(_tokenId),'tokenId');\r\n        return IDoomsdaySettlersMetadata(__metadata).tokenURI(\r\n                _tokenId\r\n        );\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256){\r\n        unchecked{\r\n            return hashes.length - uint256(abandoned);\r\n        }\r\n    }\r\n///==End 721\r\n\r\n///////===165 Implementation\r\n    mapping (bytes4 => bool) public supportsInterface;\r\n///==End 165\r\n\r\n////////===2981\r\n    function royaltyInfo(\r\n        uint256 _tokenId,\r\n        uint256 _salePrice\r\n    ) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    ){\r\n        _tokenId;\r\n        return (creator,\r\n            creatorRoyaltiesBasisPoints * _salePrice / 10000\r\n        );\r\n    }\r\n///==End 2981\r\n\r\n//// ==== Admin\r\n    function _onlyOwner() private view{\r\n        require(msg.sender == owner,\"owner\");\r\n    }\r\n    function _onlyCreator() private view{\r\n        require(msg.sender == creator,\"creator\");\r\n    }\r\n\r\n    function setOwner(address newOwner) external  {\r\n        _onlyOwner();\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setMetadata(address _metadata) external {\r\n        _onlyOwner();\r\n        __metadata = _metadata;\r\n    }\r\n\r\n    function creatorWithdraw() external {\r\n        _onlyCreator();\r\n        uint256 toWithdraw = creatorEarnings;\r\n        delete creatorEarnings;\r\n        payable(msg.sender).transfer(toWithdraw);\r\n    }\r\n\r\n    function setCreator(address newCreator) external {\r\n        _onlyCreator();\r\n        creator = newCreator;\r\n    }\r\n\r\n    function setCreatorRoyalties(uint256 _basisPoints) external{\r\n        _onlyOwner();\r\n        require(_basisPoints <= 10000,\"max\");\r\n        creatorRoyaltiesBasisPoints = _basisPoints;\r\n    }\r\n}"
    },
    "contracts/interfaces/IDoomsdaySettlersDarkAge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\ninterface IDoomsdaySettlersDarkAge {\r\n    function checkVulnerable(uint32 _tokenId) external view returns (bool);\r\n    function getUnusedFees(uint32 _tokenId) external view returns (uint80);\r\n    function disaster(uint32 _tokenId, uint256 _totalSupply) external returns(uint8 _type, bool destroyed);\r\n    function reinforce(\r\n        uint32 _tokenId,\r\n        bytes32 _tokenHash,\r\n        bool[4] memory _resources,\r\n        bool _isDarkAge\r\n    ) external returns (uint80 _cost);\r\n}"
    },
    "contracts/interfaces/IDoomsdaySettlersMetadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.18;\r\n\r\ninterface IDoomsdaySettlersMetadata {\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}"
    },
    "contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}