{{
  "language": "Solidity",
  "sources": {
    "/contracts/TrackSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\nimport \"./MarketRegistry.sol\";\nimport \"./SpecialTransferHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ncontract TrackSwap is SpecialTransferHelper, Ownable, ReentrancyGuard {\n\n    struct ERC20Details {\n        address[] tokenAddrs;\n        uint256[] amounts;\n    }\n\n    struct ERC1155Details {\n        address tokenAddr;\n        uint256[] ids;\n        uint256[] amounts;\n    }\n\n    struct ConverstionDetails {\n        bytes conversionData;\n    }\n\n    address public constant GOV = 0xD92ed451d94983957957c97F54d3c685D84D316a;\n    address public guardian;\n    address public converter;\n    address public punkProxy;\n    bool public openForTrades;\n    bool public openForFreeTrades;\n    MarketRegistry public marketRegistry;\n\n    modifier isOpenForTrades() {\n        require(openForTrades, \"trades not allowed\");\n        _;\n    }\n\n    modifier isOpenForFreeTrades() {\n        require(openForFreeTrades, \"free trades not allowed\");\n        _;\n    }\n\n    event BatchBuyEvent(uint256 indexed totalNum, uint256 indexed successNum);\n\n    constructor(address _marketRegistry, address _guardian) {\n        marketRegistry = MarketRegistry(_marketRegistry);\n        guardian = _guardian;\n        openForTrades = true;\n        openForFreeTrades = true;\n    }\n\n    function setUp() external onlyOwner {\n        // Create CryptoPunk Proxy\n        IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).registerProxy();\n        punkProxy = IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).proxyInfo(address(this));\n\n        // approve wrapped mooncats rescue to Acclimatedâ€‹MoonCats contract\n        IERC721(0x7C40c393DC0f283F318791d746d894DdD3693572).setApprovalForAll(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69, true);\n    }\n\n    // modifies `src`\n    function _arrayReplace(\n        bytes memory src,\n        bytes memory replacement,\n        bytes memory mask\n    ) internal view virtual {\n        require(src.length == replacement.length);\n        require(src.length == mask.length);\n\n        for (uint256 i = 0; i < src.length; i++) {\n            if (mask[i] != 0) {\n                src[i] = replacement[i];\n            }\n        }\n    }\n    // @audit This function is used to approve specific tokens to specific market contracts with high volume.\n    // This is done in very rare cases for the gas optimization purposes. \n    function setOneTimeApproval(IERC20 token, address operator, uint256 amount) external onlyOwner {\n        token.approve(operator, amount);\n    }\n\n    function updateGuardian(address _guardian) external onlyOwner {\n        guardian = _guardian;\n    }\n\n    function setOpenForTrades(bool _openForTrades) external onlyOwner {\n        openForTrades = _openForTrades;\n    }\n\n    function setOpenForFreeTrades(bool _openForFreeTrades) external onlyOwner {\n        openForFreeTrades = _openForFreeTrades;\n    }\n\n    // @audit we will setup a system that will monitor the contract for any leftover\n    // assets. In case any asset is leftover, the system should be able to trigger this\n    // function to close all the trades until the leftover assets are rescued.\n    function closeAllTrades() external {\n        require(_msgSender() == guardian);\n        openForTrades = false;\n        openForFreeTrades = false;\n    }\n\n    function setConverter(address _converter) external onlyOwner {\n        converter = _converter;\n    }\n\n    function setMarketRegistry(MarketRegistry _marketRegistry) external onlyOwner {\n        marketRegistry = _marketRegistry;\n    }\n\n    function _transferEth(address _to, uint256 _amount) internal {\n        bool callStatus;\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callStatus, \"_transferEth: Eth transfer failed\");\n    }\n\n    function _checkCallResult(bool _success) internal pure {\n        if (!_success) {\n            // Copy revert reason from call\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function _transferFromHelper(\n        ERC20Details memory erc20Details,\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\n        ERC1155Details[] memory erc1155Details\n    ) internal {\n        // transfer ERC20 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\n        }\n\n        // transfer ERC721 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc721Details.length; i++) {\n            // accept CryptoPunks\n            if (erc721Details[i].tokenAddr == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB) {\n                _acceptCryptoPunk(erc721Details[i]);\n            }\n            // accept Mooncat\n            else if (erc721Details[i].tokenAddr == 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6) {\n                _acceptMoonCat(erc721Details[i]);\n            }\n            // default\n            else {\n                for (uint256 j = 0; j < erc721Details[i].ids.length; j++) {\n                    IERC721(erc721Details[i].tokenAddr).transferFrom(\n                        _msgSender(),\n                        address(this),\n                        erc721Details[i].ids[j]\n                    );\n                }\n            }\n        }\n\n        // transfer ERC1155 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc1155Details.length; i++) {\n            IERC1155(erc1155Details[i].tokenAddr).safeBatchTransferFrom(\n                _msgSender(),\n                address(this),\n                erc1155Details[i].ids,\n                erc1155Details[i].amounts,\n                \"\"\n            );\n        }\n    }\n\n    function _conversionHelper(\n        ConverstionDetails[] memory _converstionDetails\n    ) internal {\n        for (uint256 i = 0; i < _converstionDetails.length; i++) {\n            // convert to desired asset\n            (bool success, ) = converter.delegatecall(_converstionDetails[i].conversionData);\n            // check if the call passed successfully\n            _checkCallResult(success);\n        }\n    }\n\n    // skip the function signature (4 bytes)\n    function _sliceCalldata(bytes calldata data) public pure returns (bytes memory){\n      return data[4:];\n    }\n\n    function _trade(\n        MarketRegistry.TradeDetails[] memory _tradeDetails\n    ) internal returns (uint256) {\n        uint256 totalValue = 0;\n        for (uint256 i = 0; i < _tradeDetails.length; i++) {\n            totalValue += _tradeDetails[i].value;\n        }\n        require(msg.value >= totalValue * 1005/1000, \"Insuficient total funds!\");\n        uint256 fee = 0;\n        uint256 successNum = 0;\n\n        for (uint256 i = 0; i < _tradeDetails.length; i++) {\n            // get market details\n            (address _proxy, bool _isLib, bool _isActive) = marketRegistry.markets(_tradeDetails[i].marketId);\n            // market should be active\n            require(_isActive, \"_trade: InActive Market\");\n            // execute trade\n            (bool success, ) = _isLib\n                ? _proxy.delegatecall(_tradeDetails[i].tradeData)\n                : _proxy.call{value:_tradeDetails[i].value}(_tradeDetails[i].tradeData);\n            // check if the call passed successfully\n            if(success)\n            {\n                fee += _tradeDetails[i].value * 5 / 1000;\n                successNum += 1;\n            }\n        }\n        if(fee > 0)\n            payable(GOV).transfer(fee);\n        return successNum;\n    }\n\n    function _singleTrade(\n        MarketRegistry.TradeDetails memory _tradeDetail\n    ) internal {\n        uint256 totalValue = _tradeDetail.value;\n        require(msg.value >= totalValue * 1005/1000, \"Insuficient total funds!\");\n        uint256 fee = 0;\n\n        // get market details\n        (address _proxy, bool _isLib, bool _isActive) = marketRegistry.markets(_tradeDetail.marketId);\n        // market should be active\n        require(_isActive, \"_trade: InActive Market\");\n        // execute trade\n        (bool success, ) = _isLib\n            ? _proxy.delegatecall(_tradeDetail.tradeData)\n            : _proxy.call{value:_tradeDetail.value}(_tradeDetail.tradeData);\n        require(success, \"buy single item failed!\");\n        fee += _tradeDetail.value * 5 / 1000;\n\n        if(fee > 0)\n            payable(GOV).transfer(fee);\n    }\n\n    function _returnDust(address[] memory _tokens) internal {\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n        // return remaining tokens (if any)\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (IERC20(_tokens[i]).balanceOf(address(this)) > 0) {\n                _tokens[i].call(abi.encodeWithSelector(0xa9059cbb, msg.sender, IERC20(_tokens[i]).balanceOf(address(this))));\n            }\n        }\n    }\n\n    function batchBuyWithETH(\n        MarketRegistry.TradeDetails[] memory tradeDetails\n    ) payable external nonReentrant {\n        // execute trades\n        uint256 successNum = _trade(tradeDetails);\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n        emit BatchBuyEvent(tradeDetails.length, successNum);\n    }\n\n    function singleBuyWithETH(\n        MarketRegistry.TradeDetails memory tradeDetail\n    ) payable external nonReentrant {\n        // execute trades\n        _singleTrade(tradeDetail);\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n        emit BatchBuyEvent(1, 1);\n    }\n\n    function batchBuyWithERC20s(\n        ERC20Details memory erc20Details,\n        MarketRegistry.TradeDetails[] memory tradeDetails,\n        ConverstionDetails[] memory converstionDetails,\n        address[] memory dustTokens\n    ) payable external nonReentrant {\n        // transfer ERC20 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\n        }\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        uint256 successNum = _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n\n        emit BatchBuyEvent(tradeDetails.length, successNum);\n    }\n\n    // swaps any combination of ERC-20/721/1155\n    // User needs to approve assets before invoking swap\n    // WARNING: DO NOT SEND TOKENS TO THIS FUNCTION DIRECTLY!!!\n    function multiAssetSwap(\n        ERC20Details memory erc20Details,\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\n        ERC1155Details[] memory erc1155Details,\n        ConverstionDetails[] memory converstionDetails,\n        MarketRegistry.TradeDetails[] memory tradeDetails,\n        address[] memory dustTokens\n    ) payable external isOpenForTrades nonReentrant returns (uint256){\n        // transfer all tokens\n        _transferFromHelper(\n            erc20Details,\n            erc721Details,\n            erc1155Details\n        );\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        uint256 successNum = _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n\n        return successNum;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    // Used by ERC721BasicToken.sol\n    function onERC721Received(\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return 0xf0b9e5ba;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        external\n        virtual\n        view\n        returns (bool)\n    {\n        return interfaceId == this.supportsInterface.selector;\n    }\n\n    receive() external payable {}\n\n    // Emergency function: In case any ETH get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueETH(address recipient) onlyOwner external {\n        _transferEth(recipient, address(this).balance);\n    }\n\n    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC20(address asset, address recipient) onlyOwner external { \n        (bool success, ) = asset.call(abi.encodeWithSelector(0xa9059cbb, recipient, IERC20(asset).balanceOf(address(this))));\n        _checkCallResult(success);\n    }\n\n    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC721(address asset, uint256[] calldata ids, address recipient) onlyOwner external {\n        for (uint256 i = 0; i < ids.length; i++) {\n            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\n        }\n    }\n\n    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\n    // Only owner can retrieve the asset balance to a recipient address\n    function rescueERC1155(address asset, uint256[] calldata ids, uint256[] calldata amounts, address recipient) onlyOwner external {\n        for (uint256 i = 0; i < ids.length; i++) {\n            IERC1155(asset).safeTransferFrom(address(this), recipient, ids[i], amounts[i], \"\");\n        }\n    }\n}\n"
    },
    "/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private reentrancyStatus = 1;\n\n    modifier nonReentrant() {\n        require(reentrancyStatus == 1, \"REENTRANCY\");\n\n        reentrancyStatus = 2;\n\n        _;\n\n        reentrancyStatus = 1;\n    }\n}\n"
    },
    "/contracts/interfaces/IWrappedPunk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\ninterface IWrappedPunk {\n    /**\n     * @dev Mints a wrapped punk\n     */\n    function mint(uint256 punkIndex) external;\n\n    /**\n     * @dev Burns a specific wrapped punk\n     */\n    function burn(uint256 punkIndex) external;\n    \n    /**\n     * @dev Registers proxy\n     */\n    function registerProxy() external;\n\n    /**\n     * @dev Gets proxy address\n     */\n    function proxyInfo(address user) external view returns (address);\n}\n"
    },
    "/contracts/interfaces/IMoonCatsRescue.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\ninterface IMoonCatsRescue {\n    function acceptAdoptionOffer(bytes5 catId) payable external;\n    function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) external;\n    function giveCat(bytes5 catId, address to) external;\n    function catOwners(bytes5 catId) external view returns(address);\n    function rescueOrder(uint256 rescueIndex) external view returns(bytes5 catId);\n}\n"
    },
    "/contracts/interfaces/ICryptoPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\ninterface ICryptoPunks {\n    function punkIndexToAddress(uint index) external view returns(address owner);\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) external;\n    function buyPunk(uint punkIndex) external payable;\n    function transferPunk(address to, uint punkIndex) external;\n}\n"
    },
    "/contracts/SpecialTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./interfaces/ICryptoPunks.sol\";\nimport \"./interfaces/IWrappedPunk.sol\";\nimport \"./interfaces/IMoonCatsRescue.sol\";\n\ncontract SpecialTransferHelper is Context {\n\n    struct ERC721Details {\n        address tokenAddr;\n        address[] to;\n        uint256[] ids;\n    }\n\n    function _uintToBytes5(uint256 id)\n        internal\n        pure\n        returns (bytes5 slicedDataBytes5)\n    {\n        bytes memory _bytes = new bytes(32);\n        assembly {\n            mstore(add(_bytes, 32), id)\n        }\n\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n            let lengthmod := and(5, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n            let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n            let end := add(mc, 5)\n\n            for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), 27)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            mstore(tempBytes, 5)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n            mstore(0x40, and(add(mc, 31), not(31)))\n        }\n\n        assembly {\n            slicedDataBytes5 := mload(add(tempBytes, 32))\n        }\n    }\n\n\n    function _acceptMoonCat(ERC721Details memory erc721Details) internal {\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\n            bytes5 catId = _uintToBytes5(erc721Details.ids[i]);\n            address owner = IMoonCatsRescue(erc721Details.tokenAddr).catOwners(catId);\n            require(owner == _msgSender(), \"_acceptMoonCat: invalid mooncat owner\");\n            IMoonCatsRescue(erc721Details.tokenAddr).acceptAdoptionOffer(catId);\n        }\n    }\n\n    function _transferMoonCat(ERC721Details memory erc721Details) internal {\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\n            IMoonCatsRescue(erc721Details.tokenAddr).giveCat(_uintToBytes5(erc721Details.ids[i]), erc721Details.to[i]);\n        }\n    }\n\n    function _acceptCryptoPunk(ERC721Details memory erc721Details) internal {\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {    \n            address owner = ICryptoPunks(erc721Details.tokenAddr).punkIndexToAddress(erc721Details.ids[i]);\n            require(owner == _msgSender(), \"_acceptCryptoPunk: invalid punk owner\");\n            ICryptoPunks(erc721Details.tokenAddr).buyPunk(erc721Details.ids[i]);\n        }\n    }\n\n    function _transferCryptoPunk(ERC721Details memory erc721Details) internal {\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\n            ICryptoPunks(erc721Details.tokenAddr).transferPunk(erc721Details.to[i], erc721Details.ids[i]);\n        }\n    }\n}\n"
    },
    "/contracts/MarketRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >= 0.8.10;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MarketRegistry is Ownable {\n\n    enum MarketId {\n        INVALID,\n        OPENSEA,\n        X2Y2,\n        LOOKSRARE\n    }\n\n    struct TradeDetails {\n        uint256 marketId;\n        uint256 value;\n        bytes tradeData;\n    }\n\n    struct Market {\n        address proxy;\n        bool isLib;\n        bool isActive;\n    }\n\n    Market[] public markets;\n\n    constructor(address[] memory proxies, bool[] memory isLibs) {\n        for (uint256 i = 0; i < proxies.length; i++) {\n            markets.push(Market(proxies[i], isLibs[i], true));\n        }\n    }\n\n    function addMarket(address proxy, bool isLib) external onlyOwner {\n        markets.push(Market(proxy, isLib, true));\n    }\n\n    function setMarketStatus(uint256 marketId, bool newStatus) external onlyOwner {\n        Market storage market = markets[marketId];\n        market.isActive = newStatus;\n    }\n\n    function setMarketProxy(uint256 marketId, address newProxy, bool isLib) external onlyOwner {\n        Market storage market = markets[marketId];\n        market.proxy = newProxy;\n        market.isLib = isLib;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}