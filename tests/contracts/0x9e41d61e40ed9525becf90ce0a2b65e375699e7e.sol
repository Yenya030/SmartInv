{{
  "language": "Solidity",
  "sources": {
    "/contracts/ARESSHIELD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\nimport \"./ROCKSHIELD.sol\";\n\ncontract ARESSHIELD is ROCKSHIELD {\n\n  constructor(string memory name_, string memory symbol_) ROCKSHIELD(name_, symbol_) {  }\n\n}\n"
    },
    "/contracts/TokenSwapSimpleDATA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n\n\n///////////////////////// TOKENSWAP & PEERSALE  COMPLETE\n\n\n\ncontract TokenSwapSimpleDATA {\n\n  uint256  public  _swapPrice = 10*59;\n  address  public  _swapCurrency = address(0);\n  uint256  _swapForSale = 0;\n\n}\n"
    },
    "/contracts/TokenSwapHEADER.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\n\nstruct swapSet {\n  address token;\n  uint256 price;\n}\n"
    },
    "/contracts/TokenSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\n\nimport \"./TokenSwapHEADER.sol\";\n\n\ninterface TokenSwap {\n\n\n  // Passive\n  function paws( address owner, uint256 tokenParam, uint256 amount ) payable external  returns (bool);\n\n  // Active\n  function swap( address tokenAddress, uint256 tokenParam, uint256 amount ) external;\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n\n  // Price for fast Selling\n  function setSwap(uint256 tokenParam, address currency, uint256 price) external;\n  function getSwaps(uint256 tokenParam) external view returns ( swapSet[] memory);\n  function delSwap(uint256 tokenParam) external;\n\n\n}\n"
    },
    "/contracts/Shield.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\n\n\nimport \"./AxxessControl2.sol\";\n\n\nabstract contract Shield is AxxessControl2 {\n\n    constructor() payable AxxessControl2() {}\n\n    function allowOperate(address _contract) external onlyMaster {\n      PeerContractAddress = _contract;\n    }\n\n    function authorizeOperate(address _contract) internal view onlyOperator {\n      require( PeerContractAddress == _contract , \"not authorized\");\n    }\n\n    function protect(address a) public {\n        authorizeOperate(address(this));\n        delegate = a;\n    }\n\n    function protect2(address a) public {\n        authorizeOperate(address(this));\n        delegate2 = a;\n    }\n\n\n    function _delegate(address implementation, address implementation2) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            /* first level */\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            if eq(result,0) {\n               result := delegatecall(gas(), implementation2, 0, calldatasize(), 0, 0)\n            }\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n              // delegatecall returns 0 on error.\n              case  0 {\n                  revert(1, returndatasize())\n              }\n              default {\n                  return(0, returndatasize())\n              }\n\n\n\n        }\n    }\n\n\n    fallback() external payable {\n       _delegate( delegate, delegate2 );\n    }\n\n\n    receive() external payable  {\n\n    }\n\n}\n"
    },
    "/contracts/ROCKSHIELD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\n// Interfaces\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Gemini Shield Implementation\nimport \"./Shield.sol\";\n\n// Enums\nimport \"./ROCK2ENUM.sol\";\n\n// Data\nimport \"./TokenSwapSimpleDATA.sol\";\nimport \"./AddressTree2DATA.sol\";\nimport \"./ROCK2DATA.sol\";\n\n// Interfaces\nimport \"./TokenSwap.sol\";\nimport \"./ROCK2INTERFACE.sol\";\nimport \"./MiniERC20.sol\";\n\n\ncontract ROCKSHIELD is ROCK2DATA,                 AddressTree2DATA, Shield,                                                           TokenSwapSimpleDATA,           ROCK2INTERFACE {\n\n\n    constructor(string memory name_, string memory symbol_) Shield() ROCK2DATA(name_, symbol_) AddressTree2DATA() {  }\n\n\n    uint8 lastBT = uint8(Balance.blocked)+6;\n\n\n    /* Basic ERC 20 Meta Functionality */\n\n\n    function name() public view override returns (string memory) {\n      return _name;\n    }\n    function symbol() public view override returns (string memory) {\n      return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n      return _decimals;\n    }\n\n\n    function totalSupply() public view override returns (uint256) {\n      return _totalSupplyERC20 + _totalSupplyBlocked;\n    }\n\n\n    function balanceOf(address account) public override view returns (uint256) {\n    if (r[account].b[uint8(Balance.isNoticed)] > 0) {\n      return r[account].b[uint8(Balance.erc20)];\n    }\n    return 0;\n    }\n\n\n\n\n\n\n    ////////// Gemini's Real Time Provisioning Implementation  - helpers ///////////////////////////\n\n\n    function hasDig(address sender) public view override returns (bool) {\n     return r[sender].dCount>0;\n    }\n\n    function getPrice() public override view returns ( uint256 price, address currency, uint8 decimal, uint256 forSale) {\n     return (\n       _digPrice,\n       _digCurrency,\n       _digDecimals,\n       _digForSale\n     );\n    }\n\n\n\n    ////////// Gemini's SelfStaking / Rocking Implementation  - helpers ///////////////////////////\n\n\n    function getAPY() public override view returns (uint256) {\n       return _apy;\n    }\n\n    function getAPY( uint256 now_ ) public override  view returns (uint256 rate, uint256 from, uint256 till, bool valid ) {\n      uint256 _apyTillDate = _apySetDate + _apyValid;\n      return (\n        _apy,\n        _apySetDate,\n        _apyTillDate,\n        now_ >= _apyTillDate\n      );\n    }\n\n\n\n\n\n\n    ////////// ISD's  ROCK Implementation - specific helpers ///////////////////////////\n\n\n    function deployedBy() public pure returns (string memory) {\n        return \"Interactive Software Development LLC\";\n    }\n\n\n    function getTimeStamp() public view override returns (uint256) {\n        return block.timestamp;\n    }\n\n\n    function totalFlow(address currency) public view override returns (uint) {\n        return _totalFlow[currency];\n    }\n    function totalBalance() public view override returns (uint256) {\n        return (payable(address(this))).balance;\n    }\n\n\n    function isProtected(address account) public view override returns (bool) {\n      if (r[account].b[uint8(Balance.isNoticed)] > 0) {\n        return r[account].b[uint8(Balance.protected)] != 0;\n      }\n      return false;\n    }\n\n\n      function totals() public view  override returns (uint256 [5] memory) {\n          return [\n          _totalSupplyERC20,\n          _totalSupplyBlocked,\n          _totalSummarized,\n          _totalSummarizedAPY,\n          _totalDigged\n        ];\n      }\n\n      function notice(address account, bool f) internal {\n        RockEntry storage rm = r[ account ];\n        if (rm.b[uint8(Balance.isNoticed)] == 0) {\n          rm.b[uint8(Balance.isNoticed)] = block.timestamp;\n          if (f == true) {\n            balancedAddress.push(account);\n          }\n        }\n      }\n\n      function balancesOf( address account) public view override returns (uint256 [16] memory b) {\n\n        for (uint8 i =0; i< 16; i++) {\n\n          // member or naked => if protected, we do not show these values\n          if (r[account].b[uint8(Balance.protected)]>0 && msg.sender != account) {\n            if (  i >= uint8(Balance.blocked) && i <= lastBT ) {\n                // keep balance zero\n                continue;\n            }\n          }\n\n          // regged member\n          if (mExists[account] == true){\n            b[i] = r[account].b[i];\n            continue;\n          }\n\n          // naked\n          if ( i == uint8(Balance.erc20)\n            || i == uint8(Balance.blocked) ) {\n              b[i] = r[account].b[i];\n              continue;\n            }\n        }\n\n        return b;\n      }\n\n\n     function getFee() public override view returns (uint256 fee, uint96 unit){\n       return ( _rockFee, _rockFeeUnit); // ETHEREUM\n     }\n\n     function lastBlockingOf(address account) public override view returns (uint256) {\n       if (r[account].b[uint8(Balance.isNoticed)] > 0) {\n         if (r[account].b[uint8(Balance.protected)]==0 || msg.sender == account) {\n           uint256 r = r[account].b[lastBT];\n           return r;\n         }\n       }\n       return block.timestamp;\n     }\n\n\n\n\n    ////////// OpenZeppelin's ERC20 Implementation ///////////////////////////\n\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        if (block.timestamp - r[owner].allowancesTime[spender] > _maxAllowanceTime) {\n          return 0;\n        }\n        return r[owner].allowances[spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n\n\n    function transferFrom(        address sender,        address recipient,        uint256 amount    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        require(block.timestamp - r[sender].allowancesTime[_msgSender()] <= _maxAllowanceTime, \"ERC20: transfer amount exceeds allowance time\");\n\n        uint256 currentAllowance = r[sender].allowances[_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, r[_msgSender()].allowances[spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\n        uint256 currentAllowance = r[_msgSender()].allowances[spender];\n        require(currentAllowance >= subtractedValue, \"XRC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n\n\n    function _transfer(        address sender,        address recipient,        uint256 amount    ) internal virtual {\n        require(sender != address(0), \"IERC20: transfer from the zero address\");\n        require(recipient != address(0), \"IERC20: transfer to the zero address\");\n\n        //      _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = r[sender].b[uint8(Balance.erc20)];\n        require(senderBalance >= amount, \"IERC20: transfer amount exceeds balance\");\n        unchecked {\n            r[sender].b[uint8(Balance.erc20)] = senderBalance - amount;\n        }\n\n\n        /* WARNING: notice() registers balance for new unseen addresses */\n        notice(recipient, true); // rescue relevant\n\n        r[recipient].b[uint8(Balance.erc20)] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n       //      _afterTokenTransfer(sender, recipient, amount);\n    }\n\n\n\n    function _approve(        address owner,        address spender,        uint256 amount    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        r[owner].allowancesTime[spender] = block.timestamp;\n        r[owner].allowances[spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n\n\n\n\n  }\n"
    },
    "/contracts/ROCK2INTERFACE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.0;\n\nimport \"./ROCK2HEADER.sol\";\n\n\ninterface ROCK2INTERFACE  {\n\n\n  function name() external view  returns (string memory) ;\n  function symbol() external view  returns (string memory) ;\n  function decimals() external view  returns (uint8) ;\n  function totalSupply() external view returns (uint256) ;\n  function balanceOf(address account) external view returns (uint256) ;\n\n  function transfer(address recipient, uint256 amount) external returns (bool) ;\n  function allowance(address owner, address spender) external view returns (uint256) ;\n\n// part of TokenSwap Interface\n// function approve(address spender, uint256 amount) external returns (bool) ;\n  function transferFrom( address sender, address recipient,       uint256 amount   ) external returns (bool) ;\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) ;\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) ;\n\n\n\n  function lastBlockingOf(address account) external view returns (uint256) ;\n\n  function balancesOf( address account) external returns (uint256 [16] memory b) ;\n  function totals() external view returns (uint256 [5] memory) ;\n\n\n\n\n  function getTimeStamp() external view returns (uint256) ;\n  function totalFlow(address currency) external view returns (uint) ;\n  function totalBalance() external view returns (uint256) ;\n  function isProtected(address account) external view returns (bool) ;\n\n  function getAPY() external view returns (uint256) ;\n  function getAPY( uint256 now_ ) external view returns (uint256 rate, uint256 from, uint256 till, bool valid ) ;\n  function getPrice() external view returns ( uint256 price, address currency, uint8 decimal, uint256 forSale) ;\n  function getFee() external view returns (uint256 fee, uint96 unit);\n\n  function hasDig(address sender) external view returns (bool) ;\n\n\n}\n"
    },
    "/contracts/ROCK2HEADER.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// 1795284 gas\n\npragma solidity ^0.8.0;\n\n\nimport \"./AddressTree2HEADER.sol\";\n\n\nstruct Calcs {\n    uint256 start;\n    uint256 end;\n    uint256 volume;\n}\n\nstruct Digs {\n    uint256 timestamp;\n    uint256 units;\n\n    uint sIndex;\n\n    address currency;\n    uint256 price;\n    uint256 decimals;\n}\n\nstruct Rocking {\n    address currency;\n    uint256 price;\n    uint256 decimals;\n\n    uint256 apy;\n    uint256 from;\n    uint256 till;\n    uint256 limit;\n}\n\n\nstruct RockEntryLight {\n  address delegatePaymentToAddress;\n\n  uint[ 25 ] b;\n  uint dCount;\n  uint cCount;\n\n}\n\nstruct RockEntry {\n  address delegatePaymentToAddress;\n\n  uint[ 25 ] b;\n  uint dCount;\n  uint cCount;\n\n  mapping(uint => Digs) d;\n  mapping(uint => Calcs) c;\n  mapping(address => uint256) allowances;\n  mapping(address => uint256) allowancesTime;\n  mapping(uint256 => uint256) deadStore;\n\n}\n"
    },
    "/contracts/ROCK2ENUM.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.0;\n\n\n\nenum Balance {\n  isNoticed,\n  protected,\n  erc20,\n  blocked\n}\n"
    },
    "/contracts/ROCK2DATA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./ROCK2HEADER.sol\";\n\n\n\n\nabstract contract ROCK2DATA is Context {\n\n  // Events\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  event Rocked(bytes32 id);\n\n\n  // IDs\n  bytes4 constant _INTERFACE_ID_SWAP = 0x83838383;\n\n  bytes4 constant _INTERFACE_ID_PAWS = 0x38383838;\n\n\n\n  // RockManagement\n\n  mapping(address => RockEntry) r;\n\n  mapping(uint256 => uint256) _deadBox;\n\n  mapping(uint => mapping(uint => Rocking)) s;\n  mapping(uint => uint) sCount;\n  uint sIndex = 0;\n\n  uint256 _maxAllowanceTime = 15*60; // 15 min\n\n\n  // dig params\n\n  uint256 digQualChildCountMin = 5;\n  uint256 digSumChildMin = 10 * 10 * 10**_decimals;\n  uint256 digSumNorm     =       5 * 10**_decimals;\n  uint256 digSumMin      =       1 * 10**_decimals;\n\n  uint256 _digPrice = 0.001 * ( 10**18);\n  address _digCurrency = address(0);\n  uint256 _digForSale = 1;\n  uint8   _digDecimals = 18;\n\n\n  // rt prov params\n\n  uint256 _rate = 100;\n  uint256 _keep = 85 + 45;\n\n\n  // rock params\n\n  uint256 _rockPrice = 0.001 * ( 10**18);\n  address _rockCurrency = address(0);\n  uint256 _rockToPayout = 0;\n  uint8   _rockDecimals = 18;\n\n  uint256 _rockFee = 0.001 *  10**18;\n  uint96  _rockFeeUnit = 1000;\n\n  uint256 _apy = 85;\n  uint256 _apySetDate;\n  uint256 _apyValid;\n\n\n  uint256 public y2s = 365 * 24 * 60 * 60;\n\n\n  // stats\n\n  address[] balancedAddress;\n\n\n  // totals\n\n  uint256 _totalSupplyERC20 = 0;\n  uint256 _totalSupplyBlocked = 0;\n  uint256 _totalSummarized = 0;\n  uint256 _totalSummarizedAPY = 0;\n  uint256 _totalDigged = 0;\n  uint256 _totalSale = 0;\n\n  // money on the contract\n  mapping( address => uint ) _totalFlow;\n\n\n  // misc\n  address[10] chargeAddresses;\n\n  bool chainPayEnabled = true;\n\n  uint256 controlSeed = 0;\n\n  uint256 lastrn = 1;\n\n\n\n  // ts param\n\n  bool _swapAllowed = false;\n\n\n  // basics\n\n  string public _name;\n  string public _symbol;\n\n  uint8 _decimals = 10;\n\n  uint8 dummy = 0;\n\n\n\n  constructor(string memory name_, string memory symbol_) payable {\n\n      _name = name_;\n      _symbol = symbol_;\n\n      _apySetDate = block.timestamp;\n      _apyValid   = y2s;\n\n      _totalFlow[address(0)] += msg.value;\n\n  }\n\n}\n"
    },
    "/contracts/MiniERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.1;\n\n\ninterface MiniERC20 {\n\n      function decimals() external view returns (uint8);\n\n}\n"
    },
    "/contracts/AxxessControl2DATA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\nabstract contract AxxessControl2DATA  {\n\n  /**\n   * @notice Master's address FOOBAR\n   */\n  address[2] MasterAddress;\n\n  /**\n   * @notice Admin's address\n   */\n  address public AdminAddress;\n\n  /**\n   * @notice Operator's address\n   */\n  address[2] OperatorAddress;\n\n\n\n  /**\n   * @notice peer authorized contrat address\n   */\n  address PeerContractAddress;\n\n  address delegate;\n  address delegate2;\n\n  // mem test\n  uint8 public xs = 9;\n\n\n  mapping(address => mapping (address => uint256)) allowed;\n\n\n}\n"
    },
    "/contracts/AxxessControl2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AxxessControl2DATA.sol\";\n\n/**\n * @title AxxessControl2\n */\nabstract contract AxxessControl2 is AxxessControl2DATA {\n\n\n  constructor() {\n\n    MasterAddress[0]     = msgSender();\n    MasterAddress[1]     = msgSender();\n    AdminAddress         = msgSender();\n    OperatorAddress[0]   = msgSender();\n    OperatorAddress[1]   = msgSender();\n\n  }\n\n\n  function msgSender() public view virtual returns (address) {\n      return msg.sender;\n  }\n\n  function msgData() public view virtual returns (bytes calldata) {\n      return msg.data;\n  }\n\n\n\n\n  /**\n   * @dev Modifier to make a function only callable by the Master\n   */\n  modifier onlyMaster() {\n    require(msgSender() == MasterAddress[0] || msgSender() == MasterAddress[1], \"AC: c.i.n.  Master\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function only callable by the Admin\n   */\n  modifier onlyAdmin() {\n    require(msgSender() == AdminAddress, \"AC: c.i.n.  Admin\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function only callable by the Operator\n   */\n  modifier onlyOperator() {\n    require(msgSender() == OperatorAddress[0] || msgSender() == OperatorAddress[1], \"AC: c.i.n.  Operator\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function only callable by C-level execs\n   */\n  modifier onlyChiefLevel() {\n    require(\n      msgSender() == OperatorAddress[0] || msgSender() == OperatorAddress[1] ||\n      msgSender() == MasterAddress[0] || msgSender() == MasterAddress[1] ||\n      msgSender() == AdminAddress\n    , \"AC: c.i.n.  Master nor Admin nor Operator\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function only callable by Master or Operator\n   */\n\n  modifier onlyMasterOrOperator() {\n    require(\n      msgSender() == OperatorAddress[0] || msgSender() == OperatorAddress[1] ||\n      msgSender() == MasterAddress[0] || msgSender() == MasterAddress[1]\n    , \"AC: c.i.n.  Master nor Operator\");\n    _;\n  }\n\n  /**\n   * @notice Sets a new Master\n   * @param _newMaster - the address of the new Master\n   */\n  function setMaster(address _newMaster,uint level) external {\n    require(_newMaster != address(0), \"ad is null\");\n    require( level <2, \"wrong level\");\n    require( msgSender() == MasterAddress[level], \"AC: c.i.n. Master\");\n    MasterAddress[level] = _newMaster;\n  }\n\n\n  /**\n   * @notice Sets a new Admin\n   * @param _newAdmin - the address of the new Admin\n   */\n  function setAdmin(address _newAdmin) external onlyMasterOrOperator {\n    require(_newAdmin != address(0), \"ad is null\");\n    AdminAddress = _newAdmin;\n  }\n\n  /**\n   * @notice Sets a new Operator\n   * @param _newOperator - the address of the new Operator\n   */\n  function setOperator(address _newOperator, uint level) external {\n    require(_newOperator != address(0), \"ad is null\");\n    require( level <2, \"wrong level\");\n    require( msgSender() == OperatorAddress[level], \"AC: c.i.n. Master\");\n    OperatorAddress[level] = _newOperator;\n  }\n\n\n  // test access\n  function getAccess(address testAddress) public view  returns (bool [4] memory) {\n     address caller = testAddress;\n     return [\n       caller == MasterAddress[0] || caller == MasterAddress[1] || caller == AdminAddress || caller == OperatorAddress[0] || caller == OperatorAddress[1],\n       caller == MasterAddress[0] || caller == MasterAddress[1],\n       caller == AdminAddress,\n       caller == OperatorAddress[0] || caller == OperatorAddress[1]\n     ];\n   }\n\n  // show access\n  function getAccessWallets() public view  returns (address [5] memory) {\n    return [\n      MasterAddress[0],\n      MasterAddress[1],\n      AdminAddress,\n      OperatorAddress[0],\n      OperatorAddress[1]\n     ];\n   }\n}\n"
    },
    "/contracts/AddressTree2HEADER.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\nstruct Entry {\n\n  uint256 id;\n\n  address promotedByAddress;\n  address walletAddress;\n\n  address[] childs;\n\n}\n"
    },
    "/contracts/AddressTree2DATA.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AddressTree2HEADER.sol\";\n\n\n\nabstract contract AddressTree2DATA {\n\n  // database\n  mapping(address => Entry) m;\n\n  // database entry helper\n  mapping(address => bool) mExists;\n\n  // reverse lookup\n  mapping(address => address) mPromotedBy;\n\n  //array of all stakers\n  address[] _mAddress;\n\n\n\n  bool simpleMode = false;\n\n  uint256 globalMemberId = 0;\n\n\n\n  uint8 _maxDepth = 6;\n\n  uint8 _balanceMax = 20;\n\n  uint8 public max = 17;\n\n\n  constructor() {\n\n    address promotedByAddress = address(0);\n\n    mExists[ promotedByAddress ] = true;\n  }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 15
    },
    "evmVersion": "byzantium",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}