{{
  "language": "Solidity",
  "sources": {
    "contracts/governance/NounsDAOProxyV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title The CNNouns DAO proxy contract for V2\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// NounsDAOProxyV2.sol is a modified version of NounsDAOProxy.sol, tailored for the DAO's V2.\n// Its main purpose is to support people wishing to deploy V2 directly, without having to deploy V1 first and then upgrade.\n\n// LICENSE\n// NounsDAOProxy.sol is a modified version of Compound Lab's GovernorBravoDelegator.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoDelegator.sol\n//\n// GovernorBravoDelegator.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n// With modifications by CNNouns DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n//\n// NounsDAOProxy.sol uses parts of Open Zeppelin's Proxy.sol:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5c8746f56b4bed8cc9e0e044f5f69ab2f9428ce1/contracts/proxy/Proxy.sol\n//\n// Proxy.sol source code licensed under MIT License.\n//\n// MODIFICATIONS\n// The fallback() and receive() functions of Proxy.sol have been used to allow Solidity > 0.6.0 compatibility\n\npragma solidity ^0.8.6;\n\nimport './NounsDAOInterfaces.sol';\n\ncontract NounsDAOProxyV2 is NounsDAOStorageV2, NounsDAOEvents {\n    constructor(\n        address timelock_,\n        address nouns_,\n        address vetoer_,\n        address admin_,\n        address implementation_,\n        uint256 votingPeriod_,\n        uint256 votingDelay_,\n        uint256 proposalThreshold_,\n        DynamicQuorumParams memory dynamicQuorumParams_\n    ) {\n        // Admin set to msg.sender for initialization\n        admin = msg.sender;\n\n        delegateTo(\n            implementation_,\n            abi.encodeWithSignature(\n                'initialize(address,address,address,uint256,uint256,uint256,(uint16,uint16,uint32))',\n                timelock_,\n                nouns_,\n                vetoer_,\n                votingPeriod_,\n                votingDelay_,\n                proposalThreshold_,\n                dynamicQuorumParams_\n            )\n        );\n\n        _setImplementation(implementation_);\n\n        admin = admin_;\n    }\n\n    /**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function _setImplementation(address implementation_) public {\n        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n        require(implementation_ != address(0), 'NounsDAOProxy::_setImplementation: invalid implementation address');\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        emit NewImplementation(oldImplementation, implementation);\n    }\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal {\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function _fallback() internal {\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n\n            switch success\n            case 0 {\n                revert(free_mem_ptr, returndatasize())\n            }\n            default {\n                return(free_mem_ptr, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the `implementation`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to `implementation`. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n}\n"
    },
    "contracts/governance/NounsDAOInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title CNNouns DAO Logic interfaces and events\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOInterfaces.sol is a modified version of Compound Lab's GovernorBravoInterfaces.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoInterfaces.sol\n//\n// GovernorBravoInterfaces.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n// With modifications by CNNouns DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOEvents, NounsDAOProxyStorage, NounsDAOStorageV1 add support for changes made by Nouns DAO to GovernorBravo.sol\n// See NounsDAOLogicV1.sol for more details.\n// NounsDAOStorageV1Adjusted and NounsDAOStorageV2 add support for a dynamic vote quorum.\n// See NounsDAOLogicV2.sol for more details.\n// NounsDAOEvents and NounsDAOStorageV1Adjusted add support for fixed proposal threshold.\n// See NounsDAOLogicV2.sol for more details.\n\npragma solidity ^0.8.6;\n\ncontract NounsDAOEvents {\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a new proposal is created, which includes additional information\n    event ProposalCreatedWithRequirements(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 proposalThreshold,\n        uint256 quorumVotes,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    /// @param voter The address which casted a vote\n    /// @param proposalId The proposal id which was voted on\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\n    /// @param votes Number of votes which were cast by the voter\n    /// @param reason The reason given for the vote by the voter\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the NounsDAOExecutor\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the NounsDAOExecutor\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\n    event ProposalVetoed(uint256 id);\n\n    /// @notice An event emitted when the voting delay is set\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n    /// @notice An event emitted when the voting period is set\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /// @notice Emitted when proposal threshold is set\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /// @notice Emitted when quorum votes basis points is set\n    event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when vetoer is changed\n    event NewVetoer(address oldVetoer, address newVetoer);\n}\n\ncontract NounsDAOEventsV2 is NounsDAOEvents {\n    /// @notice Emitted when minQuorumVotesBPS is set\n    event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n    /// @notice Emitted when maxQuorumVotesBPS is set\n    event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n    /// @notice Emitted when quorumCoefficient is set\n    event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n    /// @notice Emitted when a voter cast a vote requesting a gas refund.\n    event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\n\n    /// @notice Emitted when admin withdraws the DAO's balance.\n    event Withdraw(uint256 amount, bool sent);\n\n    /// @notice Emitted when pendingVetoer is changed\n    event NewPendingVetoer(address oldPendingVetoer, address newPendingVetoer);\n}\n\ncontract NounsDAOProxyStorage {\n    /// @notice Administrator for this contract\n    address public admin;\n\n    /// @notice Pending administrator for this contract\n    address public pendingAdmin;\n\n    /// @notice Active brains of Governor\n    address public implementation;\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV1. Create a new\n * contract which implements NounsDAOStorageV1 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV1 is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The number of votes required in order for a voter to become a proposer *DIFFERS from GovernerBravo and NounsDAO: When calling propose(), getPriorVotes() must be **greater equal** than proposalThreshold in the current implementation, but in the original implementation, getPriorVotes() must be **greater than** proposalThreshold\n    uint256 public proposalThreshold;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Extra fields added to the `Proposal` struct from NounsDAOStorageV1\n * @notice The following fields were added to the `Proposal` struct:\n * - `Proposal.totalSupply`\n * - `Proposal.creationBlock`\n */\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n    uint256 public proposalThreshold;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) internal _proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV2. Create a new\n * contract which implements NounsDAOStorageV2 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV2 is NounsDAOStorageV1Adjusted {\n    DynamicQuorumParamsCheckpoint[] public quorumParamsCheckpoints;\n\n    /// @notice Pending new vetoer\n    address public pendingVetoer;\n\n    struct DynamicQuorumParams {\n        /// @notice The minimum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 minQuorumVotesBPS;\n        /// @notice The maximum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 maxQuorumVotesBPS;\n        /// @notice The dynamic quorum coefficient\n        /// @dev Assumed to be fixed point integer with 6 decimals, i.e 0.2 is represented as 0.2 * 1e6 = 200000\n        uint32 quorumCoefficient;\n    }\n\n    /// @notice A checkpoint for storing dynamic quorum params from a given block\n    struct DynamicQuorumParamsCheckpoint {\n        /// @notice The block at which the new values were set\n        uint32 fromBlock;\n        /// @notice The parameter values of this checkpoint\n        DynamicQuorumParams params;\n    }\n\n    struct ProposalCondensed {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n}\n\ninterface INounsDAOExecutor {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n\ninterface NounsTokenLike {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}