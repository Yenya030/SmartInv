{{
  "language": "Solidity",
  "sources": {
    "contracts/SeedMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./MintPass.sol\";\nimport \"./QQL.sol\";\n\nstruct ListingData {\n    address lister;\n    uint96 price;\n}\n\n/// @title A market for QQL seeds\n/// @author Dandelion Wist & William Chargin\n/// @notice This contract is used to list QQL seeds for sale, to be used by a QQL mint pass holder to mint the corresponding seed.\ncontract SeedMarket is Ownable {\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using Address for address payable;\n\n    QQL immutable qql_;\n    MintPass immutable pass_;\n    uint256 blessingFee_;\n\n    mapping(bytes32 => bool) blessed_;\n    mapping(bytes32 => ListingData) listings_;\n\n    event BlessingFeeUpdate(uint256 oldFee, uint256 newFee);\n    event Blessing(bytes32 indexed seed, address indexed cleric);\n    event Trade(\n        bytes32 indexed seed,\n        address indexed seller,\n        address indexed buyer,\n        uint256 price\n    );\n    event Listing(bytes32 indexed seed, address indexed lister, uint256 price);\n    event Delisting(bytes32 indexed seed);\n\n    /// Emitted when the contract owner withdraws accumulated fees\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(\n        QQL _qql,\n        MintPass _pass,\n        uint256 _blessingFee\n    ) {\n        qql_ = _qql;\n        pass_ = _pass;\n        blessingFee_ = _blessingFee;\n        emit BlessingFeeUpdate(0, _blessingFee);\n    }\n\n    /// Change the blessing fee. May only be called by the owner.\n    function setBlessingFee(uint256 _blessingFee) external onlyOwner {\n        emit BlessingFeeUpdate(blessingFee_, _blessingFee);\n        blessingFee_ = _blessingFee;\n    }\n\n    function isSeedOperatorOrParametricArtist(address operator, bytes32 seed)\n        internal\n        view\n        returns (bool)\n    {\n        if (operator == address(bytes20(seed))) return true;\n        return qql_.isApprovedOrOwnerForSeed(operator, seed);\n    }\n\n    /// Returns the \"blessing fee\", which must be paid to \"bless\" a seed before it is listed\n    /// on the market. The fee is intended as a spam-prevention mechanism, and to pay the\n    /// server costs of generating and storing canonical renders of blessed seeds.\n    /// If interacting via etherscan: remember, this value is in wei, so 0.01E\n    /// would be 10000000000000000\n    function blessingFee() external view returns (uint256) {\n        return blessingFee_;\n    }\n\n    /// Bless a seed, at which point the seed is canonically tracked as part of the seed\n    /// marketplace and is available for listing. Blessing a seed does not also list it.\n    /// You can only bless a seed if you either own it, or were the parametric artist for it.\n    function bless(bytes32 seed) public payable {\n        if (!isSeedOperatorOrParametricArtist(msg.sender, seed))\n            revert(\"SeedMarket: unauthorized\");\n        if (msg.value != blessingFee_) revert(\"SeedMarket: wrong fee\");\n        if (blessed_[seed]) revert(\"SeedMarket: already blessed\");\n        emit Blessing(seed, msg.sender);\n        blessed_[seed] = true;\n    }\n\n    /// Bless a seed and simultaneously list it on the Seed Marketplace.\n    /// See docs on `bless` and `list`.\n    function blessAndList(bytes32 seed, uint256 price) external payable {\n        bless(seed);\n        list(seed, price);\n    }\n\n    /// Check whether a seed has been blessed\n    function isBlessed(bytes32 seed) external view returns (bool) {\n        return blessed_[seed];\n    }\n\n    /// List a seed on the marketplace, specifying a price.\n    /// Someone who wants to use the seed can trustlessly mint it using their own\n    /// QQL mint pass, provided that they transfer you the requested `price`.\n    /// If using this function on etherscan: remember that price is wei, so\n    /// 1 ether would be 1000000000000000000\n    function list(bytes32 seed, uint256 price) public {\n        if (!qql_.isApprovedOrOwnerForSeed(msg.sender, seed))\n            revert(\"SeedMarket: unauthorized\");\n        if (!blessed_[seed]) revert(\"SeedMarket: must bless to list\");\n        qql_.transferSeed(qql_.ownerOfSeed(seed), address(this), seed);\n        uint96 price96 = uint96(price);\n        if (price96 != price) revert(\"SeedMarket: price too high\");\n        listings_[seed] = ListingData({lister: msg.sender, price: price96});\n        emit Listing(seed, msg.sender, price);\n    }\n\n    /// Retrieve the listing for a given seed (if it exists). Returns it as being\n    /// listed by the zero address if unlisted.\n    function getListing(bytes32 seed)\n        external\n        view\n        returns (address lister, uint256 price)\n    {\n        ListingData memory lst = listings_[seed];\n        return (lst.lister, uint256(lst.price));\n    }\n\n    /// Change the price for a listed seed.\n    function reprice(bytes32 seed, uint256 price) external {\n        ListingData memory lst = listings_[seed];\n        if (lst.lister != msg.sender) revert(\"SeedMarket: unauthorized\");\n        lst.price = uint96(price);\n        if (lst.price != price) revert(\"SeedMarket: price too high\");\n        listings_[seed] = lst;\n        emit Listing(seed, msg.sender, price);\n    }\n\n    /// Remove the listing for a listed seed, making it no longer available for sale on the\n    /// market. May only be called by the address that listed that seed. The seed will remain\n    /// blessed\n    function delist(bytes32 seed) external {\n        if (listings_[seed].lister != msg.sender)\n            revert(\"SeedMarket: unauthorized\");\n        delete listings_[seed];\n        qql_.transferSeed(address(this), msg.sender, seed);\n        emit Delisting(seed);\n    }\n\n    /// Fill a listing, purchasing a seed from the marketplace and using it to mint a QQL.\n    /// This is called by the seed purchaser. They must pay the requested amount by the seed\n    /// lister, and must have access to a mint pass.\n    function fillListing(bytes32 seed, uint256 mintPassId) external payable {\n        ListingData memory lst = listings_[seed];\n        address payable lister = payable(lst.lister);\n        uint256 price = uint256(lst.price);\n        if (lister == address(0)) revert(\"SeedMarket: unlisted seed\");\n        if (msg.value != price) revert(\"SeedMarket: incorrect payment\");\n        if (!pass_.isApprovedOrOwner(msg.sender, mintPassId))\n            revert(\"SeedMarket: not owner or approved for pass\");\n        delete listings_[seed];\n        qql_.transferSeed(address(this), msg.sender, seed);\n        emit Trade(seed, lister, msg.sender, price);\n        // Careful: invokes ERC721 received hook for buyer\n        qql_.mintTo(mintPassId, seed, msg.sender);\n        if (price > 0) {\n            // Careful: invokes fallback function on seller\n            lister.sendValue(price);\n        }\n    }\n\n    /// Sends a seed that's been accidentally transferred directly to this\n    /// contract back to the original artist.\n    function rescue(bytes32 seed) external {\n        if (listings_[seed].lister != address(0))\n            revert(\"SeedMarket: seed is listed\");\n        address artist = address(bytes20(seed));\n        qql_.transferSeed(address(this), artist, seed);\n    }\n\n    function withdraw(address payable recipient) external onlyOwner {\n        uint256 balance = address(this).balance;\n        emit Withdrawal(recipient, balance);\n        recipient.sendValue(balance);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/MintPass.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1 (see LICENSE)\npragma solidity ^0.8.8;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./ERC721TokenUriDelegate.sol\";\nimport \"./ERC721OperatorFilter.sol\";\nimport \"./IManifold.sol\";\n\n/// @dev\n/// Parameters for a piecewise-constant price function with the following\n/// shape:\n///\n/// (1) Prior to `startTimestamp`, the price is `type(uint256).max`.\n///\n/// (2) At `startTimestamp`, the price jumps to `startGwei` gwei.\n///     Every `dropPeriodSeconds` seconds, the price drops as follows:.\n///\n///     (a) Each of the first `n1` drops is for `c1 * dropGwei` gwei.\n///     (b) Each of the next `n2` drops is for `c2 * dropGwei` gwei.\n///     (c) Each of the next `n3` drops is for `c3 * dropGwei` gwei.\n///     (d) Each subsequent drop is for `c4 * dropGwei` gwei.\n///\n/// (3) The price never drops below `reserveGwei` gwei.\n///\n/// For example, suppose that `dropPeriodSeconds` is 60, `startGwei` is 100e9,\n/// `dropGwei` is 5e8, `[n1, n2, n3]` is `[10, 15, 20]`, and `[c1, c2, c3, c4]`\n/// is [8, 4, 2, 1]`. Then: the price starts at 100 ETH, then drops in 4 ETH\n/// increments down to 60 ETH, then drops in 2 ETH increments down to 30 ETH,\n/// then drops in 1 ETH increments down to 10 ETH, then drops in 0.5 ETH\n/// increments down to the reserve price.\n///\n/// As a special case, if `startTimestamp == 0`, the auction is considered to\n/// not be scheduled yet, and the price is `type(uint256).max` at all times.\nstruct AuctionSchedule {\n    uint40 startTimestamp;\n    uint16 dropPeriodSeconds;\n    uint48 startGwei;\n    uint48 dropGwei;\n    uint48 reserveGwei;\n    uint8 n1;\n    uint8 n2;\n    uint8 n3;\n    uint8 c1;\n    uint8 c2;\n    uint8 c3;\n    uint8 c4;\n}\n\nlibrary ScheduleMath {\n    /// @dev The result of this function must be (weakly) monotonically\n    /// decreasing. If the reported price were to increase, then users who\n    /// bought mint passes at multiple price points might receive a smaller\n    /// rebate than they had expected, and the owner might not be able to\n    /// withdraw all the proceeds.\n    function currentPrice(AuctionSchedule memory s, uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (s.startTimestamp == 0) return type(uint256).max;\n        if (timestamp < s.startTimestamp) return type(uint256).max;\n        if (s.dropPeriodSeconds == 0) return s.reserveGwei * 1 gwei;\n\n        uint256 secondsElapsed = timestamp - s.startTimestamp;\n        uint256 drops = secondsElapsed / s.dropPeriodSeconds;\n\n        uint256 priceGwei = s.startGwei;\n        uint256 dropGwei = s.dropGwei;\n\n        uint256 inf = type(uint256).max;\n        (drops, priceGwei) = doDrop(s.n1, drops, priceGwei, s.c1 * dropGwei);\n        (drops, priceGwei) = doDrop(s.n2, drops, priceGwei, s.c2 * dropGwei);\n        (drops, priceGwei) = doDrop(s.n3, drops, priceGwei, s.c3 * dropGwei);\n        (drops, priceGwei) = doDrop(inf, drops, priceGwei, s.c4 * dropGwei);\n\n        if (priceGwei < s.reserveGwei) priceGwei = s.reserveGwei;\n        return priceGwei * 1 gwei;\n    }\n\n    function doDrop(\n        uint256 limit,\n        uint256 remaining,\n        uint256 priceGwei,\n        uint256 dropGwei\n    ) private pure returns (uint256 _remaining, uint256 _priceGwei) {\n        uint256 effectiveDrops = remaining;\n        if (effectiveDrops > limit) effectiveDrops = limit;\n        (bool ok, uint256 totalDropGwei) = SafeMath.tryMul(\n            effectiveDrops,\n            dropGwei\n        );\n        if (!ok || totalDropGwei > priceGwei) totalDropGwei = priceGwei;\n        priceGwei -= totalDropGwei;\n        return (remaining - effectiveDrops, priceGwei);\n    }\n}\n\n/// @dev\n/// A record of each buyer's interactions with the auction contract.\n/// The buyer's outstanding rebate can be calculated from this receipt combined\n/// with the current (or final) clearing price. Specifically, the clearing\n/// value of the buyer's mint passes is `clearingPrice * numPurchased`.\n/// The `netPaid` amount must never be less than the clearing value; if it's\n/// greater than the clearing value, then the buyer is entitled to claim the\n/// difference.\nstruct Receipt {\n    /// The total amount that the buyer paid for all mint passes that they\n    /// purchased, minus the total amount of rebates claimed so far.\n    uint192 netPaid;\n    /// The total number of mint passes that the buyer purchased. (This does\n    /// not count any mint passes created by `reserve`.)\n    uint64 numPurchased;\n}\n\n/// @dev These fields are grouped because they change at the same time and can\n/// be written atomically to save on storage I/O.\nstruct SupplyStats {\n    /// The total number of mint passes that have ever been created. This\n    /// counts passes created by both `purchase` and `reserve`, and does not\n    /// decrease when passes are burned.\n    uint64 created;\n    /// The number of mint passes that have been purchased at auction. This\n    /// differs from `created_` in that it does not count mint passes created\n    /// for free via `reserve`.\n    uint64 purchased;\n}\n\ncontract MintPass is\n    Ownable,\n    IManifold,\n    ERC721OperatorFilter,\n    ERC721TokenUriDelegate,\n    ERC721Enumerable\n{\n    using Address for address payable;\n    using ScheduleMath for AuctionSchedule;\n\n    /// The maximum number of mint passes that may ever be created.\n    uint64 immutable maxCreated_;\n    SupplyStats supplyStats_;\n\n    mapping(address => Receipt) receipts_;\n    /// Whether `withdrawProceeds` has been called yet.\n    bool proceedsWithdrawn_;\n\n    AuctionSchedule schedule_;\n    /// The block timestamp at which the auction ended, or 0 if the auction has\n    /// not yet ended (i.e., either is still ongoing or has not yet started).\n    /// The auction ends when the last mint pass is created, which may be\n    /// before or after the price would hit its terminal scheduled value.\n    uint256 endTimestamp_;\n\n    /// The address permitted to burn mint passes when minting QQL tokens.\n    address burner_;\n\n    address payable projectRoyaltyRecipient_;\n    address payable platformRoyaltyRecipient_;\n    uint256 constant PROJECT_ROYALTY_BPS = 500; // 5%\n    uint256 constant PLATFORM_ROYALTY_BPS = 200; // 2%\n\n    /// For use in an emergency where funds are locked in the contract (e.g.,\n    /// the auction gets soft-locked due to a logic error and can never be\n    /// completed). After an owner calls `declareEmergency()` and waits the\n    /// required duration, they can withdraw any amount of funds from the\n    /// contract. Doing so *will* break the contract invariants and make future\n    /// behavior of `claimRebate` and `withdrawProceeds` unpredictable, so\n    /// should only be used as a last resort.\n    uint256 emergencyStartTimestamp_;\n    uint256 constant EMERGENCY_DELAY_SECONDS = 3 days;\n\n    /// Emitted whenever mint passes are reserved by the owner with `reserve`.\n    /// Creating mint passes with `purchase` does not emit this event.\n    event MintPassReservation(\n        address indexed recipient,\n        uint256 firstTokenId,\n        uint256 count\n    );\n\n    /// Emitted whenever mint passes are purchased at auction. The `payment`\n    /// field represents the amount of Ether deposited with the message call;\n    /// this may be more than the current price of the purchased mint passes,\n    /// adding to the buyer's rebate, or it may be less, consuming some of the\n    /// rebate.\n    ///\n    /// Creating mint passes with `reserve` does not emit this event.\n    event MintPassPurchase(\n        address indexed buyer,\n        uint256 firstTokenId,\n        uint256 count,\n        uint256 payment,\n        uint256 priceEach\n    );\n\n    /// Emitted whenever a buyer claims a rebate. This may happen more than\n    /// once per buyer, since rebates can be claimed incrementally as the\n    /// auction goes on. The `claimed` amount may be 0 if there is no new\n    /// rebate to claim, which may happen if the price has not decreased since\n    /// the last claim.\n    event RebateClaim(address indexed buyer, uint256 claimed);\n\n    /// Emitted when the contract owner withdraws the auction proceeds.\n    event ProceedsWithdrawal(uint256 amount);\n\n    /// Emitted whenever the auction schedule changes, including when the\n    /// auction is first scheduled. The `schedule` value is the same as the\n    /// result of the `auctionSchedule()` method; see that method for more\n    /// details.\n    event AuctionScheduleChange(AuctionSchedule schedule);\n\n    event ProjectRoyaltyRecipientChanged(address payable recipient);\n    event PlatformRoyaltyRecipientChanged(address payable recipient);\n\n    event EmergencyDeclared();\n    event EmergencyWithdrawal(uint256 amount);\n\n    constructor(uint64 _maxCreated) ERC721(\"\", \"\") {\n        maxCreated_ = _maxCreated;\n    }\n\n    function name() public pure override returns (string memory) {\n        return \"QQL Mint Pass\";\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"QQL-MP\";\n    }\n\n    /// Returns the total number of mint passes ever created.\n    function totalCreated() external view returns (uint256) {\n        return supplyStats_.created;\n    }\n\n    /// Returns the maximum number of mint passes that can ever be created\n    /// (cumulatively, not just active at one time). That is, `totalCreated()`\n    /// will never exceed `maxCreated()`.\n    ///\n    /// When `totalCreated() == maxCreated()`, the auction is over.\n    function maxCreated() external view returns (uint256) {\n        return maxCreated_;\n    }\n\n    /// Returns information about how many mint passes have been reserved by\n    /// the owner, how many have been purchased at auction, and the maximum\n    /// number of mint passes that will ever be created. These statistics\n    /// include passes that have been burned.\n    function supplyStats()\n        external\n        view\n        returns (\n            uint256 reserved,\n            uint256 purchased,\n            uint256 max\n        )\n    {\n        SupplyStats memory stats = supplyStats_;\n        return (stats.created - stats.purchased, stats.purchased, maxCreated_);\n    }\n\n    /// Configures the mint pass auction. Can be called multiple times,\n    /// including while the auction is active. Reverts if this would cause the\n    /// current price to increase or if the auction is already over.\n    function updateAuctionSchedule(AuctionSchedule memory schedule)\n        public\n        onlyOwner\n    {\n        if (endTimestamp_ != 0) revert(\"MintPass: auction ended\");\n        uint256 oldPrice = currentPrice();\n        schedule_ = schedule;\n        uint256 newPrice = currentPrice();\n        if (newPrice > oldPrice) revert(\"MintPass: price would increase\");\n        emit AuctionScheduleChange(schedule);\n    }\n\n    /// Sets a new schedule that remains at the current price forevermore.\n    /// If the auction is not yet started, this unschedules the auction\n    /// (regardless of whether it is scheduled or not). Otherwise, the auction\n    /// remains open at the current price until a further schedule update.\n    function pauseAuctionSchedule() external {\n        // (no `onlyOwner` modifier; check happens in `updateAuctionSchedule`)\n        uint256 price = currentPrice();\n        AuctionSchedule memory schedule; // zero-initialized\n        if (price != type(uint256).max) {\n            uint48 priceGwei = uint48(price / 1 gwei);\n            assert(priceGwei * 1 gwei == price);\n            schedule.startTimestamp = 1;\n            schedule.dropPeriodSeconds = 0;\n            schedule.reserveGwei = priceGwei;\n        }\n        updateAuctionSchedule(schedule);\n    }\n\n    /// Returns the parameters of the auction schedule. These parameters define\n    /// the price curve over time; see `AuctionSchedule` for semantics.\n    function auctionSchedule() external view returns (AuctionSchedule memory) {\n        return schedule_;\n    }\n\n    /// Returns the block timestamp at which the auction ended, or 0 if the\n    /// auction has not ended yet (including if it hasn't started).\n    function endTimestamp() external view returns (uint256) {\n        return endTimestamp_;\n    }\n\n    /// Creates `count` mint passes owned by `recipient`. The new token IDs\n    /// will be allocated sequentially (even if the recipient's ERC-721 receive\n    /// hook causes more mint passes to be created in the middle); the return\n    /// value is the first token ID.\n    ///\n    /// If this creates the final mint pass, it also ends the auction by\n    /// setting `endTimestamp_`. If this would create more mint passes than the\n    /// max supply supports, it reverts.\n    function _createMintPasses(\n        address recipient,\n        uint256 count,\n        bool isPurchase\n    ) internal returns (uint256) {\n        // Can't return a valid new token ID, and, more importantly, don't want\n        // to stomp `endTimestamp_` if the auction is already over.\n        if (count == 0) revert(\"MintPass: count is zero\");\n\n        SupplyStats memory stats = supplyStats_;\n        uint256 oldCreated = stats.created;\n\n        uint256 newCreated = stats.created + count;\n        if (newCreated > maxCreated_) revert(\"MintPass: minted out\");\n\n        // Lossless since `newCreated <= maxCreated_ <= type(uint64).max`.\n        stats.created = _losslessU64(newCreated);\n        if (isPurchase) {\n            // Lossless since `purchased <= created <= type(uint64).max`.\n            stats.purchased = _losslessU64(stats.purchased + count);\n        }\n\n        supplyStats_ = stats;\n        if (newCreated == maxCreated_) endTimestamp_ = block.timestamp;\n\n        uint256 firstTokenId = oldCreated + 1;\n        uint256 nextTokenId = firstTokenId;\n        for (uint256 i = 0; i < count; i++) {\n            _safeMint(recipient, nextTokenId++);\n        }\n        return firstTokenId;\n    }\n\n    /// @dev Helper for `_createMintPasses`.\n    function _losslessU64(uint256 x) internal pure returns (uint64 result) {\n        result = uint64(x);\n        assert(result == x);\n        return result;\n    }\n\n    /// Purchases `count` mint passes at the current auction price. Reverts if\n    /// the auction has not started, if the auction has minted out, or if the\n    /// value associated with this message is less than required. Returns the\n    /// first token ID.\n    function purchase(uint256 count) external payable returns (uint256) {\n        uint256 priceEach = currentPrice();\n        if (priceEach == type(uint256).max) {\n            // Just a nicer error message.\n            revert(\"MintPass: auction not started\");\n        }\n\n        Receipt memory receipt = receipts_[msg.sender];\n\n        uint256 newNetPaid = receipt.netPaid + msg.value;\n        receipt.netPaid = uint192(newNetPaid);\n        if (receipt.netPaid != newNetPaid) {\n            // Truncation here would require cumulative payments of 2^192 wei,\n            // which seems implausible.\n            revert(\"MintPass: too large\");\n        }\n\n        uint256 newNumPurchased = receipt.numPurchased + count;\n        receipt.numPurchased = uint64(newNumPurchased);\n        if (receipt.numPurchased != newNumPurchased) {\n            // Truncation here would require purchasing 2^64 passes, which\n            // would likely cause out-of-gas errors anyway.\n            revert(\"MintPass: too large\");\n        }\n\n        (bool ok, uint256 priceTotal) = SafeMath.tryMul(\n            priceEach,\n            receipt.numPurchased\n        );\n        if (!ok || receipt.netPaid < priceTotal) revert(\"MintPass: underpaid\");\n\n        receipts_[msg.sender] = receipt;\n\n        uint256 firstTokenId = _createMintPasses({\n            recipient: msg.sender,\n            count: count,\n            isPurchase: true\n        });\n        emit MintPassPurchase(\n            msg.sender,\n            firstTokenId,\n            count,\n            msg.value,\n            priceEach\n        );\n        return firstTokenId;\n    }\n\n    /// Creates one or more mint passes outside of the auction process, at no\n    /// cost. Returns the first token ID.\n    function reserve(address recipient, uint256 count)\n        external\n        onlyOwner\n        returns (uint256)\n    {\n        uint256 firstTokenId = _createMintPasses({\n            recipient: recipient,\n            count: count,\n            isPurchase: false\n        });\n        emit MintPassReservation(recipient, firstTokenId, count);\n        return firstTokenId;\n    }\n\n    /// Gets the record of the given buyer's purchases so far. The `netPaid`\n    /// value indicates the total amount paid to the contract less any rebates\n    /// claimed so far. With this data, clients can compute the amount of\n    /// rebate available to the buyer at any given auction price; the rebate is\n    /// given by `netPaid - currentPrice * numPurchased`.\n    function getReceipt(address buyer)\n        external\n        view\n        returns (uint256 netPaid, uint256 numPurchased)\n    {\n        Receipt memory receipt = receipts_[buyer];\n        return (receipt.netPaid, receipt.numPurchased);\n    }\n\n    /// Computes the rebate that `buyer` is currently entitled to, and returns\n    /// that amount along with the value that should be stored into\n    /// `receipts_[buyer]` if they claim it.\n    function _computeRebate(address buyer)\n        internal\n        view\n        returns (uint256 rebate, Receipt memory receipt)\n    {\n        receipt = receipts_[buyer];\n        uint256 clearingCost = currentPrice() * receipt.numPurchased;\n        rebate = receipt.netPaid - clearingCost;\n        // This truncation should be lossless because `clearingCost` is\n        // strictly less than the prior value of `receipt.netPaid`.\n        receipt.netPaid = uint192(clearingCost);\n    }\n\n    /// Gets the amount that `buyer` would currently receive if they called\n    /// `claimRebate()`.\n    function rebateAmount(address buyer) public view returns (uint256) {\n        (uint256 rebate, ) = _computeRebate(buyer);\n        return rebate;\n    }\n\n    /// Claims a rebate equal to the difference between the total amount that\n    /// the buyer paid for all their mint passes and the amount that their mint\n    /// passes would have cost at the clearing price. The rebate is sent to the\n    /// buyer's address; see `claimTo` if this is inconvenient.\n    function claimRebate() external {\n        claimRebateTo(payable(msg.sender));\n    }\n\n    /// Claims a rebate equal to the difference between the total amount that\n    /// the buyer paid for all their mint passes and the amount that their mint\n    /// passes would have cost at the clearing price.\n    function claimRebateTo(address payable recipient) public {\n        (uint256 rebate, Receipt memory receipt) = _computeRebate(msg.sender);\n        receipts_[msg.sender] = receipt;\n        emit RebateClaim(msg.sender, rebate);\n        recipient.sendValue(rebate);\n    }\n\n    /// Withdraws all the auction proceeds. This values each purchased mint\n    /// pass at the final clearing price. It can only be called after the\n    /// auction has ended, and it can only be called once.\n    function withdrawProceeds(address payable recipient) external onlyOwner {\n        if (endTimestamp_ == 0) revert(\"MintPass: auction not ended\");\n        if (proceedsWithdrawn_) revert(\"MintPass: already withdrawn\");\n        proceedsWithdrawn_ = true;\n        uint256 proceeds = currentPrice() * supplyStats_.purchased;\n        if (proceeds > address(this).balance) {\n            // The auction price shouldn't increase, so this shouldn't happen.\n            // In case it does, permit rescuing what we can.\n            proceeds = address(this).balance;\n        }\n        emit ProceedsWithdrawal(proceeds);\n        recipient.sendValue(proceeds);\n    }\n\n    /// Gets the current price of a mint pass (in wei). If the auction has\n    /// ended, this returns the final clearing price. If the auction has not\n    /// started, this returns `type(uint256).max`.\n    function currentPrice() public view returns (uint256) {\n        uint256 timestamp = block.timestamp;\n        uint256 _endTimestamp = endTimestamp_;\n        if (_endTimestamp != 0) timestamp = _endTimestamp;\n        return schedule_.currentPrice(timestamp);\n    }\n\n    /// Returns the price (in wei) that a mint pass would cost at the given\n    /// timestamp, according to the auction schedule and under the (possibly\n    /// counterfactual) assumption that the auction does not end before it\n    /// reaches the reserve price. That is, unlike `currentPrice()`, the result\n    /// of this method does not depend on whether or when the auction has\n    /// actually ended.\n    function priceAt(uint256 timestamp) external view returns (uint256) {\n        return schedule_.currentPrice(timestamp);\n    }\n\n    /// Sets the address that's permitted to burn mint passes when minting QQL\n    /// tokens.\n    function setBurner(address _burner) external onlyOwner {\n        burner_ = _burner;\n    }\n\n    /// Gets the address that's permitted to burn mint passes when minting QQL\n    /// tokens.\n    function burner() external view returns (address) {\n        return burner_;\n    }\n\n    /// Burns a mint pass. Intended to be called when minting a QQL token.\n    function burn(uint256 tokenId) external {\n        if (msg.sender != burner_) revert(\"MintPass: unauthorized\");\n        _burn(tokenId);\n    }\n\n    /// Checks whether the given address is approved to operate the given mint\n    /// pass. Reverts if the mint pass does not exist.\n    ///\n    /// This is equivalent to calling and combining the results of `ownerOf`,\n    /// `getApproved`, and `isApprovedForAll`, but is cheaper because it\n    /// requires fewer message calls.\n    function isApprovedOrOwner(address operator, uint256 tokenId)\n        external\n        view\n        returns (bool)\n    {\n        return _isApprovedOrOwner(operator, tokenId);\n    }\n\n    function getRoyalties(\n        uint256 /*unusedTokenId */\n    )\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory bps)\n    {\n        recipients = new address payable[](2);\n        bps = new uint256[](2);\n        recipients[0] = projectRoyaltyRecipient_;\n        recipients[1] = platformRoyaltyRecipient_;\n        bps[0] = PROJECT_ROYALTY_BPS;\n        bps[1] = PLATFORM_ROYALTY_BPS;\n    }\n\n    function setProjectRoyaltyRecipient(address payable projectRecipient)\n        external\n        onlyOwner\n    {\n        projectRoyaltyRecipient_ = projectRecipient;\n        emit ProjectRoyaltyRecipientChanged(projectRecipient);\n    }\n\n    function projectRoyaltyRecipient() external view returns (address payable) {\n        return projectRoyaltyRecipient_;\n    }\n\n    function setPlatformRoyaltyRecipient(address payable platformRecipient)\n        external\n        onlyOwner\n    {\n        platformRoyaltyRecipient_ = platformRecipient;\n        emit PlatformRoyaltyRecipientChanged(platformRecipient);\n    }\n\n    function platformRoyaltyRecipient()\n        external\n        view\n        returns (address payable)\n    {\n        return platformRoyaltyRecipient_;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Enumerable, ERC721)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        virtual\n        override(ERC721, ERC721Enumerable, ERC721OperatorFilter)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721TokenUriDelegate, ERC721)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function declareEmergency() external onlyOwner {\n        if (emergencyStartTimestamp_ != 0) return;\n        emergencyStartTimestamp_ = block.timestamp;\n        emit EmergencyDeclared();\n    }\n\n    function emergencyStartTimestamp() external view returns (uint256) {\n        return emergencyStartTimestamp_;\n    }\n\n    function emergencyWithdraw(address payable recipient, uint256 amount)\n        external\n        onlyOwner\n    {\n        uint256 start = emergencyStartTimestamp_;\n        if (start == 0 || block.timestamp < start + EMERGENCY_DELAY_SECONDS)\n            revert(\"MintPass: declare emergency and wait\");\n        recipient.sendValue(amount);\n        emit EmergencyWithdrawal(amount);\n    }\n}\n"
    },
    "contracts/QQL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\nimport \"./ERC721TokenUriDelegate.sol\";\nimport \"./ERC721OperatorFilter.sol\";\nimport \"./MintPass.sol\";\n\ncontract QQL is\n    Ownable,\n    ERC721OperatorFilter,\n    ERC721TokenUriDelegate,\n    ERC721Enumerable\n{\n    MintPass immutable pass_;\n    uint256 nextTokenId_ = 1;\n    mapping(uint256 => bytes32) tokenSeed_;\n    mapping(bytes32 => uint256) seedToTokenId_;\n    mapping(uint256 => string) scriptPieces_;\n\n    /// By default, an artist has the right to mint all of their seeds. However,\n    /// they may irrevocably transfer that right, at which point the current owner\n    /// of the right has exclusive opportunity to mint it.\n    mapping(bytes32 => address) seedOwners_;\n    /// If seed approval is given, then the approved party may claim rights for any\n    /// seed.\n    mapping(address => mapping(address => bool)) approvalForAllSeeds_;\n\n    mapping(uint256 => address payable) tokenRoyaltyRecipient_;\n    address payable projectRoyaltyRecipient_;\n    uint256 constant PROJECT_ROYALTY_BPS = 500; // 5%\n    uint256 constant TOKEN_ROYALTY_BPS = 200; // 2%\n    uint256 immutable unlockTimestamp_;\n    uint256 immutable maxPremintPassId_;\n\n    event SeedTransfer(\n        address indexed from,\n        address indexed to,\n        bytes32 indexed seed\n    );\n    event ApprovalForAllSeeds(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event TokenRoyaltyRecipientChange(\n        uint256 indexed tokenId,\n        address indexed newRecipient\n    );\n\n    event ProjectRoyaltyRecipientChange(address indexed newRecipient);\n\n    constructor(\n        MintPass pass,\n        uint256 _maxPremintPassId,\n        uint256 _unlockTimestamp\n    ) ERC721(\"\", \"\") {\n        pass_ = pass;\n        maxPremintPassId_ = _maxPremintPassId;\n        unlockTimestamp_ = _unlockTimestamp;\n    }\n\n    function name() public pure override returns (string memory) {\n        return \"QQL\";\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return \"QQL\";\n    }\n\n    function setScriptPiece(uint256 id, string memory data) external onlyOwner {\n        if (bytes(scriptPieces_[id]).length != 0)\n            revert(\"QQL: script pieces are immutable\");\n\n        scriptPieces_[id] = data;\n    }\n\n    function scriptPiece(uint256 id) external view returns (string memory) {\n        return scriptPieces_[id];\n    }\n\n    function transferSeed(\n        address from,\n        address to,\n        bytes32 seed\n    ) external {\n        if (!isApprovedOrOwnerForSeed(msg.sender, seed))\n            revert(\"QQL: unauthorized for seed\");\n        if (ownerOfSeed(seed) != from) revert(\"QQL: wrong owner for seed\");\n        if (to == address(0)) revert(\"QQL: can't send seed to zero address\");\n        emit SeedTransfer(from, to, seed);\n        seedOwners_[seed] = to;\n    }\n\n    function ownerOfSeed(bytes32 seed) public view returns (address) {\n        address explicitOwner = seedOwners_[seed];\n        if (explicitOwner == address(0)) {\n            return address(bytes20(seed));\n        }\n        return explicitOwner;\n    }\n\n    function approveForAllSeeds(address operator, bool approved) external {\n        address artist = msg.sender;\n        approvalForAllSeeds_[artist][operator] = approved;\n        emit ApprovalForAllSeeds(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAllSeeds(address owner, address operator)\n        external\n        view\n        returns (bool)\n    {\n        return approvalForAllSeeds_[owner][operator];\n    }\n\n    function isApprovedOrOwnerForSeed(address operator, bytes32 seed)\n        public\n        view\n        returns (bool)\n    {\n        address seedOwner = ownerOfSeed(seed);\n        if (seedOwner == operator) {\n            return true;\n        }\n        return approvalForAllSeeds_[seedOwner][operator];\n    }\n\n    function mint(uint256 mintPassId, bytes32 seed) external returns (uint256) {\n        return mintTo(mintPassId, seed, msg.sender);\n    }\n\n    /// Consumes the specified mint pass to mint a QQL with the specified seed,\n    /// which will be owned by the specified recipient. The royalty stream will\n    /// be owned by the original parametric artist (the address embedded in the\n    /// seed).\n    ///\n    /// The caller must be authorized by the owner of the mint pass to operate\n    /// the mint pass, and the recipient must be authorized by the owner of the\n    /// seed to operate the seed.\n    ///\n    /// Returns the ID of the newly minted QQL token.\n    function mintTo(\n        uint256 mintPassId,\n        bytes32 seed,\n        address recipient\n    ) public returns (uint256) {\n        if (!isApprovedOrOwnerForSeed(recipient, seed))\n            revert(\"QQL: unauthorized for seed\");\n        if (!pass_.isApprovedOrOwner(msg.sender, mintPassId))\n            revert(\"QQL: unauthorized for pass\");\n        if (seedToTokenId_[seed] != 0) revert(\"QQL: seed already used\");\n        if (\n            block.timestamp < unlockTimestamp_ && mintPassId > maxPremintPassId_\n        ) revert(\"QQL: mint pass not yet unlocked\");\n\n        uint256 tokenId = nextTokenId_++;\n        tokenSeed_[tokenId] = seed;\n        seedToTokenId_[seed] = tokenId;\n        // Royalty recipient is always the original artist, which may be\n        // distinct from the minter (`msg.sender`).\n        tokenRoyaltyRecipient_[tokenId] = payable(address(bytes20(seed)));\n        pass_.burn(mintPassId);\n        _safeMint(recipient, tokenId);\n        return tokenId;\n    }\n\n    function parametricArtist(uint256 tokenId) external view returns (address) {\n        bytes32 seed = tokenSeed_[tokenId];\n        if (seed == bytes32(0)) revert(\"QQL: token does not exist\");\n        return address(bytes20(seed));\n    }\n\n    function setProjectRoyaltyRecipient(address payable recipient)\n        public\n        onlyOwner\n    {\n        projectRoyaltyRecipient_ = recipient;\n        emit ProjectRoyaltyRecipientChange(recipient);\n    }\n\n    function projectRoyaltyRecipient() external view returns (address payable) {\n        return projectRoyaltyRecipient_;\n    }\n\n    function tokenRoyaltyRecipient(uint256 tokenId)\n        external\n        view\n        returns (address)\n    {\n        return tokenRoyaltyRecipient_[tokenId];\n    }\n\n    function changeTokenRoyaltyRecipient(\n        uint256 tokenId,\n        address payable newRecipient\n    ) external {\n        if (tokenRoyaltyRecipient_[tokenId] != msg.sender) {\n            revert(\"QQL: unauthorized\");\n        }\n        if (newRecipient == address(0)) {\n            revert(\"QQL: can't set zero address as token royalty recipient\");\n        }\n        emit TokenRoyaltyRecipientChange(tokenId, newRecipient);\n        tokenRoyaltyRecipient_[tokenId] = newRecipient;\n    }\n\n    function getRoyalties(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory bps)\n    {\n        recipients = new address payable[](2);\n        bps = new uint256[](2);\n        recipients[0] = projectRoyaltyRecipient_;\n        recipients[1] = tokenRoyaltyRecipient_[tokenId];\n        if (recipients[1] == address(0)) {\n            revert(\"QQL: royalty for nonexistent token\");\n        }\n        bps[0] = PROJECT_ROYALTY_BPS;\n        bps[1] = TOKEN_ROYALTY_BPS;\n    }\n\n    /// Returns the seed associated with the given QQL token. Returns\n    /// `bytes32(0)` if and only if the token does not exist.\n    function tokenSeed(uint256 tokenId) external view returns (bytes32) {\n        return tokenSeed_[tokenId];\n    }\n\n    /// Returns the token ID associated with the given seed. Returns 0 if\n    /// and only if no token was ever minted with that seed.\n    function seedToTokenId(bytes32 seed) external view returns (uint256) {\n        return seedToTokenId_[seed];\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Enumerable, ERC721)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    )\n        internal\n        virtual\n        override(ERC721, ERC721Enumerable, ERC721OperatorFilter)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override(ERC721TokenUriDelegate, ERC721)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function unlockTimestamp() public view returns (uint256) {\n        return unlockTimestamp_;\n    }\n\n    function maxPremintPassId() public view returns (uint256) {\n        return maxPremintPassId_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/ERC721TokenUriDelegate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"./ITokenUriDelegate.sol\";\n\nabstract contract ERC721TokenUriDelegate is ERC721, Ownable {\n    ITokenUriDelegate private tokenUriDelegate_;\n\n    function setTokenUriDelegate(ITokenUriDelegate delegate) public onlyOwner {\n        tokenUriDelegate_ = delegate;\n    }\n\n    function tokenUriDelegate() public view returns (ITokenUriDelegate) {\n        return tokenUriDelegate_;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        if (!_exists(tokenId)) revert(\"ERC721: invalid token ID\");\n        ITokenUriDelegate delegate = tokenUriDelegate_;\n        if (address(delegate) == address(0)) return \"\";\n        return delegate.tokenURI(tokenId);\n    }\n}\n"
    },
    "contracts/ERC721OperatorFilter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"./IOperatorFilter.sol\";\n\nabstract contract ERC721OperatorFilter is ERC721, Ownable {\n    IOperatorFilter private operatorFilter_;\n\n    function setOperatorFilter(IOperatorFilter filter) public onlyOwner {\n        operatorFilter_ = filter;\n    }\n\n    function operatorFilter() public view returns (IOperatorFilter) {\n        return operatorFilter_;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override(ERC721) {\n        if (\n            from != address(0) &&\n            to != address(0) &&\n            !_mayTransfer(msg.sender, tokenId)\n        ) {\n            revert(\"ERC721OperatorFilter: illegal operator\");\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _mayTransfer(address operator, uint256 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        IOperatorFilter filter = operatorFilter_;\n        if (address(filter) == address(0)) return true;\n        if (operator == ownerOf(tokenId)) return true;\n        return filter.mayTransfer(msg.sender);\n    }\n}\n"
    },
    "contracts/IManifold.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\n/**\n * @dev Royalty interface for creator core classes\n */\ninterface IManifold {\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     *\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n     *\n     *  => 0xbb3bafd6 = 0xbb3bafd6\n     */\n    function getRoyalties(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory bps);\n}\n"
    },
    "contracts/ITokenUriDelegate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\ninterface ITokenUriDelegate {\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/IOperatorFilter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\ninterface IOperatorFilter {\n    function mayTransfer(address operator) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}