{{
  "language": "Solidity",
  "sources": {
    "contracts/token/ERC721/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}"
    },
    "contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\nerror CallerNotOwner();\nerror OwnerNotZero();\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address internal _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) revert CallerNotOwner();\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) revert OwnerNotZero();\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/ValhallaDNA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./utils/Ownable.sol\";\nimport \"./token/ERC721/IERC721A.sol\";\n\n/////////////////////////////////////////////////////////////////////////////\n//                                                                         //\n//                                                                         //\n//    ██╗░░░██╗░█████╗░██╗░░░░░██╗░░██╗░█████╗░██╗░░░░░██╗░░░░░░█████╗░    //\n//    ██║░░░██║██╔══██╗██║░░░░░██║░░██║██╔══██╗██║░░░░░██║░░░░░██╔══██╗    //\n//    ╚██╗░██╔╝███████║██║░░░░░███████║███████║██║░░░░░██║░░░░░███████║    //\n//    ░╚████╔╝░██╔══██║██║░░░░░██╔══██║██╔══██║██║░░░░░██║░░░░░██╔══██║    //\n//    ░░╚██╔╝░░██║░░██║███████╗██║░░██║██║░░██║███████╗███████╗██║░░██║    //\n//    ░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝╚══════╝╚═╝░░╚═╝    //\n//                                                                         //\n//                                                                         //\n/////////////////////////////////////////////////////////////////////////////\n\n/**\n * Subset of a Utility with only the methods that the dna contract will call.\n */\ninterface Utility {\n    function approvedBurn(address spender, uint256 tokenId, uint256 amount) external;\n}\n\ncontract ValhallaDNA is Ownable {\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // This IPFS code hash will have a function that can translate any token's\n    // DNA into the corresponding traits. This logic is put here instead of on the \n    // contract so that the gas fee for rerolling is minimal for the user.\n    string public constant DNA_TRANSLATOR_CODE_HASH = \"QmbFBwrDdSSd7VxsSGxhyPAASMuJJBqY5n8RY6LkUg1smx\";\n\n    // Checks the `ownerOf` method of this address for tokenId re-roll eligibility\n    address public immutable TOKEN_CONTRACT;\n\n    // Hash for the initial revealed tokens.\n    string public constant MINT_PROVENANCE_HASH = \"037226b21636376001dbfd22f52d1dd72845efa9613baf51a6a011ac731b2327\";\n\n    // Proof of hash will be given after all tokens are auctioned.\n    string public constant AUCTION_PROVENANCE_HASH = \"eb8c88969a4b776d757de962a194f5b4ffaaadb991ecfbb24d806c7bc6397d30\";\n\n    // The Initial DNA is composed of 128 bits for each token\n    // with each trait taking up 8 bits.\n    uint256 private constant _BITMASK_INITIAL_DNA = (1 << 8) - 1;\n\n    // Each call to reroll will give this many options to select during boost\n    uint256 public constant NUM_BOOSTS = 3;\n    \n    // Offset in bits where the booster information will start\n    uint256 private constant _BOOSTER_OFFSET = 128;\n\n    // 3 rerollable traits will fit in 2 bits\n    uint256 private constant _BITLEN_BOOSTER_TRAIT = 2;\n    uint256 private constant _BITMASK_BOOSTER_TRAIT = (1 << _BITLEN_BOOSTER_TRAIT) - 1;\n\n    uint256 private constant _BITLEN_SINGLE_BOOST = 20;\n    uint256 private constant _BITMASK_SINGLE_BOOST = (1 << _BITLEN_SINGLE_BOOST) - 1;\n    uint256 private constant _BITLEN_TRAIT_BOOST = 21;\n    uint256 private constant _BITMASK_TRAIT_BOOST = (1 << _BITLEN_TRAIT_BOOST) - 1;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // These will define what token is required to reroll traits\n    address public utilityAddress;\n    uint256 public utilityTokenId;\n\n    // Only address allowed to change a token's dna.\n    address public dnaInjectorAddress;\n    // Will be locked after all the tokens are auctioned\n    bool public dnaInjectionLocked;\n\n    // A token's dna cannot be changed unless both of these are active.\n    bool public rerollActive;\n    bool public boostingActive;\n\n    // for pseudo-rng\n    uint256 private _seed;\n    \n    // Mapping tokenId to DNA information. An extra bit is needed for\n    // each trait because the random boosterValue does have the tiniest\n    // but non-zero probability to roll a 0. (1 in 1_048_576)\n    //\n    // Bits Layout:\n    // - [0..127]   `initialDna`\n    // - [128]      `hasHairBooster`\n    // - [129..148] `hairBooster`\n    // - [149]      `hasClothingBooster`\n    // - [150..169] `clothingBooster`\n    // - [170]      `hasPrimaryBooster`\n    // - [171..190] `primaryBooster`\n    // - [191..255]  Extra Unused Bits\n    mapping(uint256 => uint256) private _dna;\n\n    // Bits Layout:\n    // - [0..1]     `boosterIdx`\n    // - [2..21]    `boosterRoll`\n    // - [22..41]   `boosterRoll`\n    // - [42..61]   `boosterRoll`\n    // - [62..256]   Extra Unused Bits\n    mapping(uint256 => uint256) public activeBooster;\n\n    // =============================================================\n    //                         Events\n    // =============================================================\n\n    event Bought(\n        uint256 indexed tokenId,\n        uint256 indexed traitId,\n        uint256 tokenDna,\n        uint256 boosterVal\n    );\n    event Boost(uint256 indexed tokenId, uint256 boosterId, uint256 tokenDna);\n\n    // =============================================================\n    //                         Constructor\n    // =============================================================\n    constructor (address tokenAddress) {\n        TOKEN_CONTRACT = tokenAddress;\n    }\n\n    // =============================================================\n    //                          Only Owner\n    // =============================================================\n\n    /**\n     * @notice Allows the owner to change the dna of any tokenId. Used for initial dna injection,\n     * and the owner can call {lockDnaInjection} below to ensure that future dna changes can only \n     * be achieved by the token owner themselves.\n     */\n    function injectDna(uint256[] memory dna, uint256[] memory tokenIds) external {\n        if (msg.sender != dnaInjectorAddress) revert NotDnaInjector();\n        if (dnaInjectionLocked) revert DnaLocked();\n\n        for (uint i = 0; i < tokenIds.length; ) {\n            _dna[tokenIds[i]] = dna[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Allows the owner to prevent the owner from injecting dna forever. \n     * THIS CANNOT BE UNDONE.\n     */\n    function lockDnaInjection() external onlyOwner {\n        dnaInjectionLocked = true;\n    }\n\n    /**\n     * @notice Allows the owner to update the dna translator script. \n     */\n    function setDnaInjector(address dnaInjector) external onlyOwner {\n        dnaInjectorAddress = dnaInjector;\n    }\n\n    /**\n     * @notice Allows the owner to select an address and token that must be burned to alter a token's \n     * dna. This address must have an {approvedBurn} method that is callable by this contract for\n     * another user's tokens.\n     */\n    function setRerollToken(address token, uint256 tokenId) external onlyOwner {\n        utilityAddress = token;\n        utilityTokenId = tokenId;\n    }\n\n    /**\n     * @notice Allows the owner to enable or disable token owners from rolling their dna.\n     */\n    function setRerollActive(bool active) external onlyOwner {\n        rerollActive = active;\n    }\n\n    /**\n     * @notice Allows the owner to enable or disable token owners from finalizing rolls into their dna.\n     */\n    function setBoostingActive(bool active) external onlyOwner {\n        boostingActive = active;\n    }\n\n    // =============================================================\n    //                    Dna Interactions\n    // =============================================================\n\n    /**\n     * @dev Returns the saved token dna for a given id. This dna can be translated into\n     * metadata using the scripts that are part of the DNA_TRANSLATOR_CODE_HASH constant. \n     */\n    function getTokenDna(uint256 tokenId) external view returns (uint256) {\n        return _dna[tokenId];\n    }\n\n    /**\n     * @dev Adds an activeBooster to a given tokenId for a certain trait. The caller cannot be\n     * a contract address and they must own both the Valhalla tokenId as well as the corresponding\n     * Utility token to be burned.\n     * \n     * Note: \n     * - A token CANNOT reroll a trait they do not have\n     * - A token CAN override an existing activeBooster with another roll without calling {boost}\n     * - The override is true even if a different rerollTraitId is selected from the first roll\n     * \n     * @param tokenId tokenId that the booster is attached to\n     * @param rerollTraitId 0 for hair, 1 for clothing, 2 for primary\n     */\n    function reroll(uint256 tokenId, uint256 rerollTraitId) external {\n        if (!rerollActive) revert RerollInactive();\n        if (msg.sender != tx.origin) revert NotEOA();\n        if (rerollTraitId > 2) revert TraitNotRerollable();\n        if (IERC721A(TOKEN_CONTRACT).ownerOf(tokenId) != msg.sender) revert NotTokenOwner();\n\n        Utility(utilityAddress).approvedBurn(msg.sender, utilityTokenId, 1);\n\n        // Cheaper gaswise to do bitshift than to multiply rerollTraitId by 8\n        if (_dna[tokenId] & (_BITMASK_INITIAL_DNA << (rerollTraitId << 3)) == 0) revert TraitNotOnToken();\n\n        // Shift _randomNumber up to make room for reroll traitId\n        uint256 boosterVal = _randomNumber() << _BITLEN_BOOSTER_TRAIT;\n        boosterVal = boosterVal | rerollTraitId;\n\n        activeBooster[tokenId] = boosterVal;\n        emit Bought(tokenId, rerollTraitId, _dna[tokenId], boosterVal);\n    }\n\n    /**\n     * @dev Selects one of the boosters rolled from the {reroll} method and replaces the appropriate\n     * section in the token dna's bits with one of the new values that was randomly rolled.\n     */\n    function boost(uint256 tokenId, uint256 boosterIdx) external {\n        if(!boostingActive) revert BoostingInactive();\n        if(IERC721A(TOKEN_CONTRACT).ownerOf(tokenId) != msg.sender) revert NotTokenOwner();\n        uint256 boosterVal = activeBooster[tokenId];\n        if (boosterVal == 0) revert NoBoosterAtIdx();\n        activeBooster[tokenId] = 0;\n\n        if (boosterIdx >= NUM_BOOSTS) revert InvalidBoostIdx();\n        uint256 selectedVal = \n            (boosterVal >> (boosterIdx * _BITLEN_SINGLE_BOOST + _BITLEN_BOOSTER_TRAIT)) &\n            _BITMASK_SINGLE_BOOST;\n\n        // This shifts the value up one bit and adds a flag to show that this trait has been boosted.\n        // This is needed on the small chance that random value generated is exactly 0.\n        selectedVal = selectedVal << 1 | 1;\n\n        uint256 rerollTraitId = boosterVal & _BITMASK_BOOSTER_TRAIT;\n        uint256 traitShiftAmount = rerollTraitId * _BITLEN_TRAIT_BOOST + _BOOSTER_OFFSET;\n\n        _dna[tokenId] = _dna[tokenId] & ~(_BITMASK_TRAIT_BOOST << traitShiftAmount) | (selectedVal << traitShiftAmount);\n        emit Boost(tokenId, boosterIdx, _dna[tokenId]);\n    }\n\n    /**\n     * @dev Makes a pseudo-random number. Although there is some room for the block.timestamp to be\n     * manipulated by miners, the random number used here is not used to determine something with high\n     * impact such as determining a lottery winner. \n     * \n     * Implementing a more secure random number generator would lead to a worse reroll experience. \n     */\n    function _randomNumber() internal returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, ++_seed)));\n    }\n\n    error BoostingInactive();\n    error DnaLocked();\n    error InvalidBoostIdx();\n    error NoBoosterAtIdx();\n    error NotDnaInjector();\n    error NotEOA();\n    error NotTokenOwner();\n    error RerollInactive();\n    error TraitNotRerollable();\n    error TraitNotOnToken();\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}