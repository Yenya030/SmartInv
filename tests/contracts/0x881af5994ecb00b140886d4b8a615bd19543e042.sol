{{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "src/ExclusivesYieldMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\ncontract ExclusivesYieldMap {\n    uint256[] public YIELD_MAP = [\n        127689209163621340800975369692887101994514425976037930576731308074077257728,\n        6753153917220401196899736694153029318930711892062416711752429375504,\n        8143398124117396899987774834844922863974330482361793009967084270027538472960,\n        904846606982687445547887032273189160859675851540267250047031488062456627200,\n        221341162137358637457934410757978275112249602007170343361381244113780800,\n        1766847066449606368897757431762078670333126734602310857023130828808421377,\n        14488145931195919154652211730312669894721622402245540684164609667634818973696,\n        107839786674879660962284295149278626613731412961974160436439994662976,\n        855714193558978439600180920575387457109609170093290301725354295296,\n        107841432223488566448886464657249700657495345086125706239647338725376,\n        42435387414890550099181881421510309192222220764397156893696321252516442624,\n        904653735511092325205405702522746983442865158853724658543027888974473461824,\n        53933083088045683062968712886885842090668581084422208199274109337608,\n        8141852561846376966633364494578066340832735700825023457147381546746577682433,\n        7237009034947508087999372842444878193351586692892858927190258174099139330050,\n        1809251825692212629736148548004775327449081419426083295371710407222461726720,\n        42404437501432180058531776494431691926741654233591182749010509113426445312,\n        14163678425198499775079031680960538338078575496093723048039448098369437696,\n        113299129636810209322791409486204458102728459423630940986290520940334813713,\n        906861863088205211094597746465241253180168885996822765039538221723869777920,\n        14588863116477154331764461313260546006573195324256945577023454839394036355592,\n        30257310852239479033653781943308815454419542226881113133482467444473987136,\n        26353791772251548151867970195806678612595411784355624021865267208,\n        7237009890923735787562481262902339512443458934001442233980709118408403190336,\n        251913741659111010848457020105384818928415929242265780952450868143226880,\n        10063960881820201593675291886165623334308687336540197642300748756910973386768,\n        7351850636542857659901632359859819723445084295634860096310858908355042508801,\n        1809251833380016350089876474113563869124297516159721017250839217992007422978,\n        951104854286571783208133907009074371232312303136073372744624177216,\n        14356064602972600589748753907742128318739053374838267391099376786586206272,\n        7238803483205057291789354599244276030967730650142414209554458908525837942786,\n        224306771080334774167065072968001954953696202454525699444820666472235016,\n        113078212146022285371799082393245919705963271557061666824257666410510091265,\n        14700168064353879710598725997397176632414730459792095013297043515395312451648,\n        15406906404987710370678569893662259257989112169811933387866230488841072934912,\n        466530931455402736694290967607979784713001307600537720088663197527134175232,\n        906395995104510267405146335308482677385440270153399930823313892608533610496,\n        7585780026693951011482627432448869271820260484043928587553141161984,\n        6740012377796368092512590431295524108232846806650884555150377091584,\n        113078232365779811345067185773594749929150852809930468810917583206563717128,\n        906451262997003458014082321514027972232888594543177317347691244013257491073,\n        113519923912011595008512198883679820430683831855976137610662321283951230976,\n        7238772431979525598438887302793835152656041262399837108196878931751516504066,\n        118379184804620357792205379675498758854940509597182637391989759956098224128,\n        1794454066620592157951083256470526566762981605162225958026251593932865608,\n        14474011155508671486791512291545797300541743934179547279151429563876777132544,\n        113079090029286086210336889245199195099549637127375276628487137132764234248,\n        34563494177444330947274478893706677544627277771697322024963795847249920,\n        904626142007301553581652972237627498579873114720395349012578344521825517568,\n        14488591148913612073061307345770174297937538647232319597193655577988573462528,\n        3457823787866344712686117832039218792975529736246459513907316273512448,\n        1809282506111519445429699406957582417154249943304742438650319701142223192065,\n        55268734837207824145625580455255387568304346831893000537489779153993729,\n        904847099093865596522140236962995496036376488637811700395123008875496742976,\n        127433844575320241592428800946479265618683713055309463557170681707162244169,\n        9046256971691861529435617292951362444633158331217486644900811458644174438400,\n        141375372167664336373990955765518093842425620077422766175527094373941510280,\n        842528519930702968132587061673755889989271988690100710659506831872,\n        113305969985885275312580760415007944698097287198703669553034562204634186752,\n        1766847064778385117286005609999271580063413208369541046665640420935991872,\n        13494782874591857290810104294732169541585520292341407105998479458304,\n        7237005584282925287850080220409917625866194770839212719101591292290376176648,\n        1991153821074889879648559879757476930928063262872123503706621672647917568,\n        3561301430880806704632065855709544429574547346876693474557063173228470336,\n        3561793239282898180129956422570005972210051656801055502201999514264437256,\n        918981437407644722812439118464180761162935733758462115229503352478330257408,\n        904680911453449683263202305584476759212635064755296398543971614037555355649,\n        14476026464610977421774095971673611407465069238645853752591083284445765042177,\n        7240539273252127955906133936318951131543738422584407175125987038040869306377,\n        17668908760084434842213282868721737307911909751941415813573777397886779400,\n        221718603039365295081533249583754996873794408800998779671592037546725440,\n        14134938383219375486164444238479109723859805214341124516282178528323076104,\n        7237033615676796050638573064237669191610500533620517567464614144233818816576,\n        16129387965600301035811000112710144018440539041619528541699708798364057672,\n        14359952734426553198912187632495361369158910179570702581256668441603211776,\n        1259789995531782590154412715662325340653412082130742869699133419322689749504,\n        9046257403052474941938603303641840649587120260274892449652214385456886153281,\n        15901631270802851204552820941873458526156516555833692983023826853411422792,\n        3451715674992821333700795175505918826028676663227588154392269698371584,\n        1019471242722455121785783966193669719829701652335502260261384737706884472897,\n        116611913122343696702287879134720683711343087729323246864159392157348659201,\n        14474038769234299205080122666462799806694047821797400711566218246399882952832,\n        842498383664910525231275040345923083389172625665506952342633743872,\n        27607011920923242148788330674807481805009270601750753872695180134481921,\n        27622150360433682032463218364699410653018529705344201403741426247798784,\n        1017704394591389388828597773976732888748944250441704161613089220516405837833,\n        14809541114165170860870095719723875792871240101783780657509466176,\n        904629148039731883037256170128553661599509525106111692529594151263887425536,\n        906392604891602550858704988087731411260025424846305311767502371557367353856,\n        1766900984671724920440093735242524140592919450540546860778944999971356744,\n        14474038761650194412083483414727729989458634441604697908963498258282961698816,\n        127240757619941108308408961178450997360559305308259232856947489146367377408,\n        7237009574354980202408023435265650670642126926145009597285851302741133000704,\n        1019470817158775096598357196589097987842228210222704486240458982891511124032,\n        7254674156032154336217058350043602349772460699659836735598086491076904878664,\n        904625697298224563374329659623520538978022168948990626535023634548114104449,\n        14474011154664550189184155117350792680795144919866412405937101540740586545665,\n        10352621374592446859686861356000752357132795677755290852952342110666752,\n        1766860546423736939957667382745409558746572509807994482938555604991738384,\n        906392611736721971665073928643624589532943524841735976169328406107405942785,\n        3450993295630485490545996418370363455588296746857931148839633171779593,\n        1987702947875682371167700873324666625949945547007673112433848320178257920,\n        1017707361029666607827641434929577056827015183098958030876992422803293864448,\n        118386147105738135448168900540292710969639135357391453087087635893487435840,\n        7265503326099145387412455242527196694404064649625661436141073700463210397696,\n        14135207995850083549211386303615913891561671596781362991568365487225044993,\n        248469717074484361122817141759026500163695769888095257742737053434511872,\n        8256511280540672661225559411097223470381662237496123455253228054799622078464,\n        14475778001729714992780821879469884102266619167805629333807862650756472537666,\n        113078272805696999930766039027606061227608684993350363740153609103494611521,\n        14359090016130341039250983986311775663286255439760245485124354682698891337,\n        120152502151276925763349302054185068409437481943491329738316521882802716688,\n        445654671558703322041850078082278151053253327410107833138026457161793600,\n        113299068884579529034482442756143511200239602510821331384521101519943401537,\n        7237005578280098551568211806181589330883481559192745478211019140041269051392,\n        1017704018945736411658888247275988221725379335841022243163919229243357397120,\n        906392545929677552302913899681359060986451221064839408926391696429670465600,\n        66902235595922171653472526251057195641733120\n    ];\n}\n"
    },
    "src/MintUpdater.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\n\ninterface ILandMintUpdater {\n\n    function updateLandMintingTime(uint256 _id) external;\n\n}\n\ninterface ITierTwoMintUpdater {\n\n    function updateTierTwoMintingTime(uint256 _id) external;\n\n}"
    },
    "src/PccLand.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"./PccTierTwoItem.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./MintUpdater.sol\";\n\ncontract PccLand is ERC721, Ownable {\n\n    using Strings for uint256;\n    mapping(address => mapping(uint256 => bool)) public HasClaimed;\n\n    uint256 public constant MAX_SUPPLY = 9856;\n    uint256 public constant MAX_MINT = 20;\n    uint256 public CurrentMaxSupply = 500;\n    uint256 public MintPrice = 0.09 ether;\n    string public BaseUri;\n    uint256 public totalSupply;\n    bytes32 public MerkleRoot;\n    bool public PublicMintingOpen;\n    uint256 public currentPhase;\n\n    ILandMintUpdater public tokenContract;\n\n\n    constructor()ERC721(\"Country Club Land\", \"PCCL\") {\n        \n    }\n\n\n    function claimLand(bytes32[] memory _proofs, uint256 _quantity) public payable canMint(_proofs, _quantity) {\n        require(totalSupply + _quantity < CurrentMaxSupply, \"too many minted\");\n        \n\n        if(msg.value == 0 && !HasClaimed[msg.sender][currentPhase]){\n            HasClaimed[msg.sender][currentPhase] = true;\n        }\n\n        for(uint256 i; i < _quantity; ){\n\n            _mint(msg.sender, totalSupply);\n            tokenContract.updateLandMintingTime(totalSupply);\n            unchecked {\n                ++i;\n                ++totalSupply;\n            }\n        }\n\n    }\n\n\n    modifier canMint(bytes32[] memory _proofs, uint256 _qty) {\n        if(PublicMintingOpen){\n            require(msg.value == MintPrice * _qty, \"incorrect ether\");\n            require(_qty <= MAX_MINT, \"too many\");\n        }\n        else{\n            require(msg.value == 0, \"free\");\n            \n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _qty));\n            require(\n                MerkleProof.verify(_proofs, MerkleRoot, leaf),\n                \"not authorised\"\n            );\n            require(!HasClaimed[msg.sender][currentPhase], \"already claimed from this wallet\");\n        }\n        _;\n    }\n\n    function setMintPrice(uint256 _priceInWei) public onlyOwner {\n        MintPrice = _priceInWei;\n    }\n\n\n    function setMerkleRoot(bytes32 _root) public onlyOwner {\n        MerkleRoot = _root;\n    }\n\n    function setBaseUri(string calldata _uri) public onlyOwner {\n        BaseUri = _uri;\n    }\n\n    function setTokenContract(address _token) public onlyOwner{\n        tokenContract = ILandMintUpdater(_token);\n    }\n\n    function setPublicMintingOpen(bool _mintingOpen) public onlyOwner {\n        PublicMintingOpen =  _mintingOpen;\n    }\n    \n    function incrementPhase() public onlyOwner {\n        unchecked{\n            ++currentPhase;\n        }\n    }\n\n    function withdraw() public onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function setTempMaxSupply(uint256 _supply) public onlyOwner {\n        require(_supply > totalSupply, \"cannot set supply to less than current supply\");\n        require(_supply <= MAX_SUPPLY, \"cannot set supply to higher than max supply\");\n        CurrentMaxSupply = _supply;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"not minted\");\n        return string(abi.encodePacked(BaseUri, id.toString()));\n    }\n\n\n}"
    },
    "src/PccTierTwo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\n\n\npragma solidity ^0.8.14;\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"./PccTierTwoItem.sol\";\nimport \"./MintUpdater.sol\";\n\n\n\n\ncontract PccTierTwo is ERC721, Ownable {\n    using SafeMath for uint256;\n    using Strings for uint256;\n\n    uint256 constant NUMBER_OF_TICKETS = 6;\n    uint256 constant MAX_NUMBER_PER_TYPE = 3000;\n    uint256 constant MAX_MINT = 30;\n\n    uint256[MAX_NUMBER_PER_TYPE][NUMBER_OF_TICKETS] private Ids;\n    uint256[2000] private finalIds;\n    uint256[NUMBER_OF_TICKETS] public CurrentSupplyByType;\n\n    uint256 public totalSupply;\n    uint256 public CurrentSupplyFinalSubcollection;\n    address public TicketContract;\n    address public FinalMintContract;\n    string public BaseUri;\n\n    ITierTwoMintUpdater public tokenContract;\n\n    \n\n    constructor() ERC721(\"PCC Tier Two\", \"PTT\") {\n\n \n\n    }\n\n    function mintTeamTierTwo() external onlyOwner{\n               uint256 remaining = MAX_NUMBER_PER_TYPE -\n        CurrentSupplyByType[0];       \n\n        for (uint256 index; index < 3; ) {\n\n            --remaining;\n\n\n            _safeMint(\n                0x112E62d5906F9239D9fabAb7D0237A328F128e22,\n                index\n            );\n\n            tokenContract.updateTierTwoMintingTime(index);\n\n            Ids[0][index] = Ids[0][remaining] == 0\n                ? remaining\n                : Ids[0][remaining];\n\n            unchecked {\n                ++CurrentSupplyByType[0];\n                ++totalSupply;\n                ++index;\n            }\n        }\n    }\n\n    function mint(\n        uint256 _ticketId,\n        uint256 _quantity,\n        address _to\n    ) public {\n        require(msg.sender == TicketContract, \"not authorised\");\n        require(_quantity <= MAX_MINT, \"cannot exceed max mint\");\n        require(CurrentSupplyByType[_ticketId] + _quantity <= MAX_NUMBER_PER_TYPE, \"cannot exceed maximum\");\n\n        uint256 remaining = MAX_NUMBER_PER_TYPE -\n        CurrentSupplyByType[_ticketId];       \n\n        for (uint256 i; i < _quantity; ) {\n\n            --remaining;\n\n            uint256 index = getRandomNumber(remaining, uint256(block.number));\n\n            uint256 id = ((Ids[_ticketId][index] == 0) ? index : Ids[_ticketId][index]) +\n                    (MAX_NUMBER_PER_TYPE * _ticketId);\n\n            _safeMint(\n                _to,\n                id\n            );\n\n            \n            tokenContract.updateTierTwoMintingTime(id);\n\n            Ids[_ticketId][index] = Ids[_ticketId][remaining] == 0\n                ? remaining\n                : Ids[_ticketId][remaining];\n\n            unchecked {\n                ++CurrentSupplyByType[_ticketId];\n                ++totalSupply;\n                ++i;\n            }\n        }\n    }\n\n    function finalSubcollectionMint(\n        uint256 _quantity,\n        address _to\n    ) public {\n        require(msg.sender == FinalMintContract, \"not authorised\");\n        require(_quantity <= MAX_MINT, \"cannot exceed max mint\");\n        require(CurrentSupplyFinalSubcollection + _quantity <= 2000, \"cannot exceed maximum\");\n\n        uint256 remaining = 2000 -\n        CurrentSupplyFinalSubcollection;       \n\n        for (uint256 i; i < _quantity; ) {\n\n            --remaining;\n\n            uint256 index = getRandomNumber(remaining, uint256(block.number));\n\n            _safeMint(\n                _to,\n                ((finalIds[index] == 0) ? index : finalIds[index]) + 18000\n            );\n\n            finalIds[index] = finalIds[remaining] == 0\n                ? remaining\n                : finalIds[remaining];\n\n            unchecked {\n                ++CurrentSupplyFinalSubcollection;\n                ++totalSupply;\n                ++i;\n            }\n        }\n    }\n\n\n    function getRandomNumber(uint256 maxValue, uint256 salt)\n        private\n        view\n        returns (uint256)\n    {\n        if (maxValue == 0) return 0;\n\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.difficulty +\n                        ((\n                            uint256(\n                                keccak256(abi.encodePacked(tx.origin, msg.sig))\n                            )\n                        ) / (block.timestamp)) +\n                        block.number +\n                        salt\n                )\n            )\n        );\n        return seed.mod(maxValue);\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"not minted\");\n        return string(abi.encodePacked(BaseUri, id.toString()));\n    }\n\n    function setFinalSubcollectionMintAddress(address _addr) external onlyOwner {\n        FinalMintContract = _addr;\n    }\n\n    function setUri(string calldata _baseUri) external onlyOwner {\n        BaseUri = _baseUri;\n    }\n    function setTicketContract(address _ticket) external onlyOwner{\n                TicketContract = _ticket;\n    }\n\n    function setTokenContract(address _token) public onlyOwner{\n        tokenContract = ITierTwoMintUpdater(_token);\n    }\n\n    function withdrawTokens(IERC20 token) public onlyOwner {\n\t\trequire(address(token) != address(0));\n\t\tuint256 balance = token.balanceOf(address(this));\n\t\ttoken.transfer(msg.sender, balance);\n\t}\n\n\n    modifier onlyTicketContract() {\n        require(msg.sender == TicketContract, \"not authorised address\");\n        _;\n    }\n}\n"
    },
    "src/PccTierTwoItem.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport \"solmate/tokens/ERC1155.sol\";\nimport \"src/PccToken.sol\";\nimport \"src/PccTierTwo.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"./PccTierTwo.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\n\n\n\n\ncontract PccTierTwoItem is ERC1155, Ownable {\n    using Strings for uint256;\n    PccToken public TokenContract;\n    PccTierTwo public TierTwo;\n\n    string public symbol = \"PTTI\";\n    string public name = \"PCC Tier Two Item\";\n\n    uint256[6] public ItemPrice;\n    string public BaseUri;\n\n    bool[6] public IsForSale;\n\n    constructor(PccTierTwo _tierTwo) {\n\n        TierTwo = _tierTwo;\n    }\n\n    function purchaseTierTwo(uint256 _ticketId, uint256 _quantity) public {\n        require(\n            balanceOf[msg.sender][_ticketId] >= _quantity,\n            \"not enough tickets\"\n        );\n        require(IsForSale[_ticketId], \"not for sale currently\");\n\n        _burn(msg.sender, _ticketId, _quantity);\n        TierTwo.mint(_ticketId, _quantity, msg.sender);\n    }\n\n    function purchaseTicket(uint256 _ticketId, uint256 _quantity) public {\n        uint256 price = ItemPrice[_ticketId];\n        require(price > 0, \"sale not open for this item\");\n\n        TokenContract.payForTierTwoItem(msg.sender, price * _quantity);\n        _mint(msg.sender, _ticketId, _quantity, \"\");\n    }\n\n    function uri(uint256 id) public view override returns (string memory) {\n        return string(abi.encodePacked(BaseUri, id.toString()));\n    }\n\n    function setPricePerTicket(uint256 _ticketId, uint256 _price)\n        external\n        onlyOwner\n    {\n        ItemPrice[_ticketId] = _price * 1 ether;\n    }\n\n    function setTokenContract(PccToken _token) external onlyOwner {\n        TokenContract = _token;\n    }\n\n    function setUri(string calldata _baseUri) external onlyOwner {\n        BaseUri = _baseUri;\n    }\n\n    function setIsForSale(bool _isForSale, uint256 _ticketId)\n        external\n        onlyOwner\n    {\n        IsForSale[_ticketId] = _isForSale;\n    }\n\n    \tfunction withdrawTokens(IERC20 token) public onlyOwner {\n\t\trequire(address(token) != address(0));\n\t\tuint256 balance = token.balanceOf(address(this));\n\t\ttoken.transfer(msg.sender, balance);\n\t}\n\n}\n"
    },
    "src/PccToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.14;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./ExclusivesYieldMap.sol\";\nimport \"./PccTierTwoItem.sol\";\nimport \"./PccLand.sol\";\nimport \"./MintUpdater.sol\";\nimport \"./PccTierTwo.sol\";\n\nstruct TokenBucket {\n    uint256 AvailableCurrently;\n    uint256 DailyYield;\n    uint256 MaxYield;\n    uint256 CurrentYield;\n    uint256 LastClaimTimestamp;\n}\n\n\ncontract PccToken is ERC20, Ownable, ExclusivesYieldMap, ILandMintUpdater {\n    uint256 public constant SECOND_RATE_FOR_ONE_PER_DAY = 11574074074074;\n    uint256 public packedNumbers;\n\n    PccTierTwoItem public TierTwoItem;\n    IERC721 public TierTwo;\n\n    bytes32 public MerkleRoot;\n\n    event AddedClaimBucket(\n        string indexed _name,\n        uint256 _dailyYield,\n        uint256 _maxYield\n    );\n\n    mapping(string => TokenBucket) public TokenClaimBuckets;\n    mapping(address => bool) public ClaimedAirdrop;\n\n    uint256[5] public EXCLUSIVES_DAILY_YIELD = [\n        5 * SECOND_RATE_FOR_ONE_PER_DAY,\n        10 * SECOND_RATE_FOR_ONE_PER_DAY,\n        25 * SECOND_RATE_FOR_ONE_PER_DAY,\n        50 * SECOND_RATE_FOR_ONE_PER_DAY,\n        100 * SECOND_RATE_FOR_ONE_PER_DAY\n    ];\n    IERC721 immutable public EXCLUSIVES_CONTRACT;\n    IERC721 immutable public landContract;\n\n    uint256 public EXCLUSIVES_START_TIME;\n\n    uint256 private constant MAX_VALUE_3_BIT_INT = 7;\n\n    uint256 contractCount;\n\n    mapping(uint256 => uint256) public test;\n\n    mapping(IERC721 => uint256) public NftContracts;\n\n    mapping(IERC721 => mapping(uint256 => uint256)) public LastClaimedTimes;\n\n    mapping(IERC721 => uint256) public FirstClaimTime;\n\n    constructor(PccLand _land, PccTierTwoItem _ticket, PccTierTwo _tierTwo, IERC721 _nft1, IERC721 _nft2, IERC721 _nft3) ERC20(\"YARN\", \"PCC Yarn\", 18) {\n        TierTwoItem = _ticket;\n\n        EXCLUSIVES_CONTRACT = IERC721(0x9e8a92F833c0ae4842574cE9cC0ef4c7300Ddb12);\n\n        landContract = IERC721(address(_land));\n        TierTwo = IERC721(address(_tierTwo));\n\n        EXCLUSIVES_START_TIME = block.timestamp;\n\n        FirstClaimTime[\n            _nft1\n        ] = block.timestamp; //PCC\n        FirstClaimTime[\n            _nft2\n        ] = block.timestamp; //kittens\n        FirstClaimTime[\n            _nft3\n        ] = block.timestamp; //grandmas\n\n        addNewContract(IERC721(address(_tierTwo)), 5);\n        addNewContract(landContract, 5);\n\n        addTokenBucket(\n        \"employee\",\n        7847312 ether, //start number\n        12960 ether,    //daily yield\n        78803313 ether); //max tokens\n\n        addTokenBucket(\n        \"team\",\n        16176000 ether, //start number\n        51840 ether,   //daily yield\n        300000000 ether); //max tokens\n\n\n            addNewContract(IERC721(address(_nft1)), 10);\n            addNewContract(IERC721(address(_nft2)), 1);\n            addNewContract(IERC721(address(_nft3)), 1);\n\n    }\n\n    function updateLandMintingTime(uint256 _id) external {\n        require(address(landContract) == msg.sender, \"not authorised\");\n\n        LastClaimedTimes[landContract][_id] = block.timestamp;\n    }\n\n    function updateTierTwoMintingTime(uint256 _id) external {\n        require(address(TierTwo) == msg.sender, \"not authorised\");\n\n        LastClaimedTimes[TierTwo][_id] = block.timestamp;\n    }\n\n    function payForTierTwoItem(address _sender, uint256 _amount) public {\n        address tierTwoAddress = address(TierTwoItem);\n        require(msg.sender == tierTwoAddress, \"not authorised\");\n        require(balanceOf[_sender] >= _amount, \"insufficient balance\");\n\n        balanceOf[_sender] -= _amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[tierTwoAddress] += _amount;\n        }\n\n        emit Transfer(_sender, tierTwoAddress, _amount);\n    }\n\n    function burn(address _from, uint256 _quantity) public onlyTicketContract {\n        _burn(_from, _quantity);\n    }\n\n    function addTokenBucket(\n        string memory _name,\n        uint256 _startNumber,\n        uint256 _dailyYield,\n        uint256 _maxYield\n    ) private {\n        TokenBucket memory bucket = TokenBucket(\n            _startNumber,\n            _dailyYield,\n            _maxYield,\n            0,\n            uint80(block.timestamp)\n        );\n\n        TokenClaimBuckets[_name] = bucket;\n        emit AddedClaimBucket(_name, _dailyYield, _maxYield);\n    }\n\n\n    function addNewContract(IERC721 _contract, uint256 _yield)\n        private\n\n    {\n        require(NftContracts[_contract] == 0, \"duplicate contract\");\n        require(_yield < 11 && _yield > 0, \"yield out of range\");\n        unchecked {\n            ++contractCount;\n        }\n\n        NftContracts[_contract] = _yield * SECOND_RATE_FOR_ONE_PER_DAY;\n    }\n\n    function claimCommunitityAirdrop(\n        bytes32[] calldata _merkleProof,\n        uint256 _amount\n    ) public {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, MerkleRoot, leaf),\n            \"not authorised\"\n        );\n        require(!ClaimedAirdrop[msg.sender], \"already claimed airdrop\");\n\n        ClaimedAirdrop[msg.sender] = true;\n        _mint(msg.sender, _amount * 1 ether);\n    }\n\n    function setMerkleRoot(bytes32 _root) public onlyOwner {\n        MerkleRoot = _root;\n    }\n\n    function claimTokens(IERC721[] calldata _contracts, uint256[] calldata _ids)\n        public\n    {\n        uint256 contractsLength = _contracts.length;\n        require(contractsLength == _ids.length, \"invalid array lengths\");\n        uint256 amountToMint;\n\n        for (uint256 i; i < contractsLength; ) {\n            amountToMint += getYield(_contracts[i], _ids[i], msg.sender);\n            LastClaimedTimes[_contracts[i]][_ids[i]] = block.timestamp;\n            unchecked {\n                ++i;\n            }\n        }\n\n        _mint(msg.sender, amountToMint);\n        require(totalSupply < 2000000000 ether, \"reached max cap\");\n    }\n\n    function currentTokenToClaim(\n        address _owner,\n        IERC721[] calldata _contracts,\n        uint256[] calldata _ids\n    ) external view returns (uint256) {\n        uint256 contractsLength = _contracts.length;\n        require(contractsLength == _ids.length, \"invalid array lengths\");\n        uint256 amountToClaim;\n\n        for (uint256 i; i < contractsLength; ) {\n            unchecked {\n                amountToClaim += getYield(_contracts[i], _ids[i], _owner);\n                ++i;\n            }\n        }\n\n        return amountToClaim;\n    }\n\n    function availableFromBucket(string calldata _name)\n        public\n        view\n        returns (uint256)\n    {\n        TokenBucket memory bucket = TokenClaimBuckets[_name];\n\n        require(bucket.LastClaimTimestamp > 0, \"bucket does not exist\");\n\n        uint256 amountToMint = bucket.AvailableCurrently;\n\n        amountToMint +=\n\n                (block.timestamp - bucket.LastClaimTimestamp) *\n                    (bucket.DailyYield / 86400)\n            ;\n\n        if (bucket.CurrentYield + (amountToMint) > bucket.MaxYield) {\n            return bucket.MaxYield - bucket.CurrentYield;\n        }\n\n        return amountToMint;\n    }\n\n    function bucketMint(string calldata _name, uint256 _amount)\n        public\n        onlyOwner\n    {\n        TokenBucket memory bucket = TokenClaimBuckets[_name];\n\n        require(bucket.LastClaimTimestamp > 0, \"bucket does not exist\");\n\n        uint256 amountToMint = bucket.AvailableCurrently;\n\n        uint256 timeSinceLastClaim = (block.timestamp - bucket.LastClaimTimestamp);\n\n        amountToMint += (timeSinceLastClaim * (bucket.DailyYield / 86400));\n\n        bucket.CurrentYield += _amount;\n        require(\n            bucket.CurrentYield <= bucket.MaxYield && amountToMint >= _amount,\n            \"cannot mint this many from this bucket\"\n        );\n\n        _mint(msg.sender, _amount);\n\n\n        bucket.AvailableCurrently = amountToMint - _amount;\n        bucket.LastClaimTimestamp = uint80(block.timestamp);\n\n        TokenClaimBuckets[_name] = bucket;\n    }\n\n    function getYield(\n        IERC721 _contract,\n        uint256 _id,\n        address _operator\n    ) private view returns (uint256) {\n        address owner = _contract.ownerOf(_id);\n        require(\n            owner == _operator || _contract.isApprovedForAll(owner, _operator),\n            \"not eligible\"\n        );\n        if (_contract == EXCLUSIVES_CONTRACT) {\n            return getExclusivesYield(_id);\n        } else {\n            return getNftYield(_contract, _id);\n        }\n    }\n\n    function getExclusivesYield(uint256 _id) public view returns (uint256) {\n        uint256 lastClaim = (\n            LastClaimedTimes[EXCLUSIVES_CONTRACT][_id] == 0\n                ? EXCLUSIVES_START_TIME\n                : LastClaimedTimes[EXCLUSIVES_CONTRACT][_id]\n        );\n        return\n            (block.timestamp - lastClaim) *\n            EXCLUSIVES_DAILY_YIELD[getExclusivesDailyYield(_id)];\n    }\n\n    function getNftYield(IERC721 _nft, uint256 _id)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 lastClaim = (\n            LastClaimedTimes[_nft][_id] == 0\n                ? FirstClaimTime[_nft] == 0\n                    ? block.timestamp - (5 days - 1)\n                    : FirstClaimTime[_nft]\n                : LastClaimedTimes[_nft][_id]\n        );\n        return (block.timestamp - lastClaim) * NftContracts[_nft];\n    }\n\n    function getExclusivesDailyYield(uint256 _id)\n        public\n        view\n        returns (uint256)\n    {\n        return unpackNumber(YIELD_MAP[_id / 85], _id % 85);\n    }\n\n    function unpackNumber(uint256 _packedNumbers, uint256 _position)\n        private\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 number = (_packedNumbers >> (_position * 3)) &\n                MAX_VALUE_3_BIT_INT;\n            return number;\n        }\n    }\n\n    modifier onlyTicketContract() {\n        require(address(TierTwoItem) == msg.sender, \"only ticket contract\");\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/solmate/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}