{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@solidstate/contracts/access/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/access/IERC173Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from '../IERC173.sol';\n\ninterface IOwnable is IERC173 {}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173Internal } from '../IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from './IOwnable.sol';\n\ninterface ISafeOwnable is IOwnable {\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function nomineeOwner() external view returns (address);\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnableInternal } from './IOwnableInternal.sol';\n\ninterface ISafeOwnableInternal is IOwnableInternal {}\n"
    },
    "@solidstate/contracts/access/ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC173 } from '../IERC173.sol';\nimport { IOwnable } from './IOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IOwnable, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual returns (address) {\n        return _owner();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account) public virtual onlyOwner {\n        _transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == OwnableStorage.layout().owner,\n            'Ownable: sender must be owner'\n        );\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { ISafeOwnable } from './ISafeOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function nomineeOwner() public view virtual returns (address) {\n        return _nomineeOwner();\n    }\n\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        _acceptOwnership();\n    }\n\n    function _transferOwnership(address account)\n        internal\n        virtual\n        override(OwnableInternal, SafeOwnableInternal)\n    {\n        super._transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        require(\n            msg.sender == _nomineeOwner(),\n            'SafeOwnable: sender must be nominee owner'\n        );\n        _;\n    }\n\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function _nomineeOwner() internal view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function _acceptOwnership() internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n\n    /**\n     * @notice set nominee owner, granting permission to call acceptOwnership\n     */\n    function _transferOwnership(address account) internal virtual override {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from './IERC165.sol';\nimport { ERC165Storage } from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC165Storage {\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IProxy {\n    fallback() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\nimport { IProxy } from './IProxy.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy is IProxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        require(\n            implementation.isContract(),\n            'Proxy: implementation must be contract'\n        );\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\nimport { IDiamondBase } from './base/IDiamondBase.sol';\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\n\ninterface ISolidStateDiamond is\n    IDiamondBase,\n    IDiamondReadable,\n    IDiamondWritable,\n    ISafeOwnable,\n    IERC165\n{\n    receive() external payable;\n\n    /**\n     * @notice get the address of the fallback contract\n     * @return fallback address\n     */\n    function getFallbackAddress() external view returns (address);\n\n    /**\n     * @notice set the address of the fallback contract\n     * @param fallbackAddress fallback address\n     */\n    function setFallbackAddress(address fallbackAddress) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable, Ownable, OwnableInternal, OwnableStorage } from '../../access/ownable/Ownable.sol';\nimport { ISafeOwnable, SafeOwnable } from '../../access/ownable/SafeOwnable.sol';\nimport { IERC173 } from '../../access/IERC173.sol';\nimport { ERC165, IERC165, ERC165Storage } from '../../introspection/ERC165.sol';\nimport { DiamondBase, DiamondBaseStorage } from './base/DiamondBase.sol';\nimport { DiamondReadable, IDiamondReadable } from './readable/DiamondReadable.sol';\nimport { DiamondWritable, IDiamondWritable } from './writable/DiamondWritable.sol';\nimport { ISolidStateDiamond } from './ISolidStateDiamond.sol';\n\n/**\n * @title SolidState \"Diamond\" proxy reference implementation\n */\nabstract contract SolidStateDiamond is\n    ISolidStateDiamond,\n    DiamondBase,\n    DiamondReadable,\n    DiamondWritable,\n    SafeOwnable,\n    ERC165\n{\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n    using ERC165Storage for ERC165Storage.Layout;\n    using OwnableStorage for OwnableStorage.Layout;\n\n    constructor() {\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n        bytes4[] memory selectors = new bytes4[](12);\n\n        // register DiamondWritable\n\n        selectors[0] = IDiamondWritable.diamondCut.selector;\n\n        erc165.setSupportedInterface(type(IDiamondWritable).interfaceId, true);\n\n        // register DiamondReadable\n\n        selectors[1] = IDiamondReadable.facets.selector;\n        selectors[2] = IDiamondReadable.facetFunctionSelectors.selector;\n        selectors[3] = IDiamondReadable.facetAddresses.selector;\n        selectors[4] = IDiamondReadable.facetAddress.selector;\n\n        erc165.setSupportedInterface(type(IDiamondReadable).interfaceId, true);\n\n        // register ERC165\n\n        selectors[5] = IERC165.supportsInterface.selector;\n\n        erc165.setSupportedInterface(type(IERC165).interfaceId, true);\n\n        // register SafeOwnable\n\n        selectors[6] = Ownable.owner.selector;\n        selectors[7] = SafeOwnable.nomineeOwner.selector;\n        selectors[8] = Ownable.transferOwnership.selector;\n        selectors[9] = SafeOwnable.acceptOwnership.selector;\n\n        erc165.setSupportedInterface(type(IERC173).interfaceId, true);\n\n        // register Diamond\n\n        selectors[10] = SolidStateDiamond.getFallbackAddress.selector;\n        selectors[11] = SolidStateDiamond.setFallbackAddress.selector;\n\n        // diamond cut\n\n        FacetCut[] memory facetCuts = new FacetCut[](1);\n\n        facetCuts[0] = FacetCut({\n            target: address(this),\n            action: IDiamondWritable.FacetCutAction.ADD,\n            selectors: selectors\n        });\n\n        DiamondBaseStorage.layout().diamondCut(facetCuts, address(0), '');\n\n        // set owner\n\n        OwnableStorage.layout().setOwner(msg.sender);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @inheritdoc ISolidStateDiamond\n     */\n    function getFallbackAddress() external view returns (address) {\n        return DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    /**\n     * @inheritdoc ISolidStateDiamond\n     */\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n\n    function _transferOwnership(address account)\n        internal\n        virtual\n        override(OwnableInternal, SafeOwnable)\n    {\n        super._transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Proxy } from '../../Proxy.sol';\nimport { IDiamondBase } from './IDiamondBase.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is IDiamondBase, Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation() internal view override returns (address) {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        address implementation = address(bytes20(l.facets[msg.sig]));\n\n        if (implementation == address(0)) {\n            implementation = l.fallbackAddress;\n            require(\n                implementation != address(0),\n                'DiamondBase: no facet found for function signature'\n            );\n        }\n\n        return implementation;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { IDiamondWritable } from '../writable/IDiamondWritable.sol';\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    using AddressUtils for address;\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    event DiamondCut(\n        IDiamondWritable.FacetCut[] facetCuts,\n        address target,\n        bytes data\n    );\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param l storage layout\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function diamondCut(\n        Layout storage l,\n        IDiamondWritable.FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                IDiamondWritable.FacetCut memory facetCut = facetCuts[i];\n                IDiamondWritable.FacetCutAction action = facetCut.action;\n\n                require(\n                    facetCut.selectors.length > 0,\n                    'DiamondBase: no selectors specified'\n                );\n\n                if (action == IDiamondWritable.FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = l.addFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == IDiamondWritable.FacetCutAction.REPLACE) {\n                    l.replaceFacetSelectors(facetCut);\n                } else if (action == IDiamondWritable.FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = l.removeFacetSelectors(\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            initialize(target, data);\n        }\n    }\n\n    function addFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondWritable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(this) ||\n                    facetCut.target.isContract(),\n                'DiamondBase: ADD target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    'DiamondBase: selector already added'\n                );\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function removeFacetSelectors(\n        Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        IDiamondWritable.FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            require(\n                facetCut.target == address(0),\n                'DiamondBase: REMOVE target must be zero address'\n            );\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                require(\n                    address(bytes20(oldFacet)) != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    address(bytes20(oldFacet)) != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function replaceFacetSelectors(\n        Layout storage l,\n        IDiamondWritable.FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            require(\n                facetCut.target.isContract(),\n                'DiamondBase: REPLACE target has no code'\n            );\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                require(\n                    oldFacetAddress != address(0),\n                    'DiamondBase: selector not found'\n                );\n\n                require(\n                    oldFacetAddress != address(this),\n                    'DiamondBase: selector is immutable'\n                );\n\n                require(\n                    oldFacetAddress != facetCut.target,\n                    'DiamondBase: REPLACE target is identical'\n                );\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function initialize(address target, bytes memory data) private {\n        require(\n            (target == address(0)) == (data.length == 0),\n            'DiamondBase: invalid initialization parameters'\n        );\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                require(\n                    target.isContract(),\n                    'DiamondBase: initialization target has no code'\n                );\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IProxy } from '../../IProxy.sol';\n\ninterface IDiamondBase is IProxy {}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondReadable } from './IDiamondReadable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondReadable is IDiamondReadable {\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facets() external view returns (Facet[] memory diamondFacets) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        returns (bytes4[] memory selectors)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        returns (address facet)\n    {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondReadable {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(address facet)\n        external\n        view\n        returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(bytes4 selector)\n        external\n        view\n        returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondWritable } from './IDiamondWritable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondWritable is IDiamondWritable, OwnableInternal {\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    /**\n     * @inheritdoc IDiamondWritable\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external onlyOwner {\n        DiamondBaseStorage.layout().diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondWritable {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional target of initialization delegatecall\n     * @param data optional initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155Internal } from './IERC1155Internal.sol';\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title ERC1155 interface\n * @dev see https://github.com/ethereum/EIPs/issues/1155\n */\ninterface IERC1155 is IERC1155Internal, IERC165 {\n    /**\n     * @notice query the balance of given token held by given address\n     * @param account address to query\n     * @param id token to query\n     * @return token balance\n     */\n    function balanceOf(address account, uint256 id)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice query the balances of given tokens held by given addresses\n     * @param accounts addresss to query\n     * @param ids tokens to query\n     * @return token balances\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @notice query approval status of given operator with respect to given address\n     * @param account address to query for approval granted\n     * @param operator address to query for approval received\n     * @return whether operator is approved to spend tokens held by account\n     */\n    function isApprovedForAll(address account, address operator)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\n     * @param operator address whose approval status to update\n     * @param status whether operator should be considered approved\n     */\n    function setApprovalForAll(address operator, bool status) external;\n\n    /**\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param id token ID\n     * @param amount quantity of tokens to transfer\n     * @param data data payload\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param ids list of token IDs\n     * @param amounts list of quantities of tokens to transfer\n     * @param data data payload\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/IERC1155Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC165 } from '../../introspection/IERC165.sol';\n\n/**\n * @title Partial ERC1155 interface needed by internal functions\n */\ninterface IERC1155Internal {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed account,\n        address indexed operator,\n        bool approved\n    );\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC1155 metadata extensions\n */\nlibrary ERC1155MetadataStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\n\n    struct Layout {\n        string baseURI;\n        mapping(uint256 => string) tokenURIs;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\n\n/**\n * @title ERC1155Metadata interface\n */\ninterface IERC1155Metadata is IERC1155MetadataInternal {\n    /**\n     * @notice get generated URI for given token\n     * @return token URI\n     */\n    function uri(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial ERC1155Metadata interface needed by internal functions\n */\ninterface IERC1155MetadataInternal {\n    event URI(string value, uint256 indexed tokenId);\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        require(success, 'AddressUtils: failed to send value');\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'AddressUtils: insufficient balance for call'\n        );\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        require(\n            isContract(target),\n            'AddressUtils: function call to non-contract'\n        );\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        require(value == 0, 'UintUtils: hex length insufficient');\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/land/LandPriceStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Category, SegmentPrice } from \"./LandTypes.sol\";\n\nlibrary LandPriceStorage {\n\tstruct Layout {\n\t\tSegmentPrice price;\n\t\tmapping(uint8 => SegmentPrice) discountPrices;\n\t}\n\n\tbytes32 internal constant STORAGE_SLOT =\n\t\tkeccak256(\"co.sportsmetaverse.contracts.storage.LandPriceStorage\");\n\n\tfunction layout() internal pure returns (Layout storage l) {\n\t\tbytes32 slot = STORAGE_SLOT;\n\t\tassembly {\n\t\t\tl.slot := slot\n\t\t}\n\t}\n\n\t// Getters\n\n\tfunction _getDiscountPrice(uint8 zoneId) internal view returns (SegmentPrice storage) {\n\t\treturn layout().discountPrices[zoneId];\n\t}\n\n\tfunction _getDiscountPrice(uint8 zoneId, uint8 category) internal view returns (uint64) {\n\t\tSegmentPrice memory price = layout().discountPrices[zoneId];\n\t\treturn _getPrice(price, category);\n\t}\n\n\tfunction _getPrice() internal view returns (SegmentPrice storage) {\n\t\treturn layout().price;\n\t}\n\n\tfunction _getPrice(uint8 category) internal view returns (uint64) {\n\t\tSegmentPrice storage price = layout().price;\n\t\treturn _getPrice(price, category);\n\t}\n\n\tfunction _getPrice(SegmentPrice memory price, uint8 category) internal pure returns (uint64) {\n\t\tif (Category(category) == Category.ONExONE) {\n\t\t\treturn price.one;\n\t\t}\n\t\tif (Category(category) == Category.TWOxTWO) {\n\t\t\treturn price.two;\n\t\t}\n\t\tif (Category(category) == Category.THREExTHREE) {\n\t\t\treturn price.three;\n\t\t}\n\t\tif (Category(category) == Category.SIXxSIX) {\n\t\t\treturn price.four;\n\t\t}\n\t\trevert(\"_getPrice: wrong category\");\n\t}\n\n\t// determine if a specific zone is discountable\n\tfunction _isDiscountable(uint8 zoneId) internal view returns (bool) {\n\t\treturn\n\t\t\tlayout().discountPrices[zoneId].one != 0 &&\n\t\t\tlayout().discountPrices[zoneId].two != 0 &&\n\t\t\tlayout().discountPrices[zoneId].three != 0 &&\n\t\t\tlayout().discountPrices[zoneId].four != 0;\n\t}\n\n\t// Setters\n\n\tfunction _setDiscountPrice(uint8 zoneId, SegmentPrice memory price) internal {\n\t\tlayout().discountPrices[zoneId] = price;\n\t}\n\n\tfunction _setPrice(SegmentPrice memory price) internal {\n\t\tlayout().price = price;\n\t}\n}\n"
    },
    "contracts/land/LandProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@solidstate/contracts/access/ownable/OwnableInternal.sol\";\nimport \"@solidstate/contracts/introspection/ERC165Storage.sol\";\nimport \"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\";\nimport \"@solidstate/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\";\nimport \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\";\n\nimport \"../vendor/ERC2981/IERC2981Royalties.sol\";\nimport \"../vendor/ERC2981/ERC2981Storage.sol\";\nimport \"../vendor/OpenSea/OpenSeaCompatible.sol\";\nimport \"../vendor/OpenSea/OpenSeaProxyStorage.sol\";\n\nimport \"./LandPriceStorage.sol\";\nimport \"./LandStorage.sol\";\nimport \"./LandTypes.sol\";\n\ncontract LandProxy is SolidStateDiamond {\n\tusing ERC165Storage for ERC165Storage.Layout;\n\n\tconstructor() {\n\t\tERC165Storage.layout().setSupportedInterface(type(IERC1155).interfaceId, true);\n\t\tERC165Storage.layout().setSupportedInterface(type(IERC1155Metadata).interfaceId, true);\n\t\tERC165Storage.layout().setSupportedInterface(type(IERC2981Royalties).interfaceId, true);\n\t}\n}\n\ncontract LandProxyInitializer {\n\tfunction init(\n\t\tLandInitArgs memory landInit,\n\t\tRoyaltyInfo memory royaltyInit,\n\t\taddress opensea721Proxy,\n\t\taddress opensea1155Proxy,\n\t\tstring memory contractURI,\n\t\tstring memory baseURI\n\t) external {\n\t\t// Init ERC1155 Metadata\n\t\tERC1155MetadataStorage.layout().baseURI = baseURI;\n\t\tOpenSeaCompatibleStorage.layout().contractURI = contractURI;\n\n\t\t// Init Land\n\t\tLandStorage.layout().mintState = uint8(MintState.CLOSED);\n\t\tLandStorage.layout().lions = landInit.lions;\n\t\tLandStorage.layout().icons = landInit.icons;\n\t\tLandStorage.layout().signer = landInit.signer;\n\t\tLandStorage.layout().zoneIndex = 2;\n\n\t\t// Init Price\n\t\tLandPriceStorage._setPrice(landInit.price);\n\t\tLandPriceStorage._setDiscountPrice(\n\t\t\tLandStorage._getIndexLionLands(),\n\t\t\tlandInit.lionsDiscountPrice\n\t\t);\n\n\t\tLandStorage.layout().zones[LandStorage._getIndexSportsCity()] = landInit.zoneOne;\n\t\tLandStorage.layout().zones[LandStorage._getIndexLionLands()] = landInit.zoneTwo;\n\n\t\t// Init Royalties\n\t\tERC2981Storage.layout().royalties = royaltyInit;\n\n\t\t// Init Opensea Proxy\n\t\tOpenSeaProxyStorage._setProxies(opensea721Proxy, opensea1155Proxy);\n\t}\n}\n"
    },
    "contracts/land/LandStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Category, Segment, Zone } from \"./LandTypes.sol\";\n\nlibrary LandStorage {\n\tstruct Layout {\n\t\tuint8 mintState;\n\t\taddress signer;\n\t\taddress icons;\n\t\taddress lions;\n\t\tuint8 zoneIndex;\n\t\tmapping(uint8 => Zone) zones;\n\t\tmapping(address => bool) proxies;\n\t}\n\n\tbytes32 internal constant STORAGE_SLOT =\n\t\tkeccak256(\"co.sportsmetaverse.contracts.storage.LandStorage\");\n\n\tfunction layout() internal pure returns (Layout storage l) {\n\t\tbytes32 slot = STORAGE_SLOT;\n\t\t// slither-disable-next-line timestamp\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tl.slot := slot\n\t\t}\n\t}\n\n\t// Adders\n\n\t// add the count of minted inventory to the zone segment\n\tfunction _addCount(\n\t\tuint8 zoneId,\n\t\tuint8 segmentId,\n\t\tuint16 count\n\t) internal {\n\t\tZone storage zone = LandStorage.layout().zones[zoneId];\n\t\tCategory category = Category(segmentId);\n\n\t\tif (category == Category.ONExONE) {\n\t\t\tzone.one.count += count;\n\t\t} else if (category == Category.TWOxTWO) {\n\t\t\tzone.two.count += count;\n\t\t} else if (category == Category.THREExTHREE) {\n\t\t\tzone.three.count += count;\n\t\t} else if (category == Category.SIXxSIX) {\n\t\t\tzone.four.count += count;\n\t\t}\n\t}\n\n\tfunction _addInventory(\n\t\tZone storage zone,\n\t\tuint8 segmentId,\n\t\tuint16 count\n\t) internal {\n\t\tCategory category = Category(segmentId);\n\n\t\tif (category == Category.ONExONE) {\n\t\t\tzone.one.max += count;\n\t\t} else if (category == Category.TWOxTWO) {\n\t\t\tzone.two.max += count;\n\t\t} else if (category == Category.THREExTHREE) {\n\t\t\tzone.three.max += count;\n\t\t} else if (category == Category.SIXxSIX) {\n\t\t\tzone.four.max += count;\n\t\t}\n\t}\n\n\tfunction _removeInventory(\n\t\tZone storage zone,\n\t\tuint8 segmentId,\n\t\tuint16 count\n\t) internal {\n\t\tCategory category = Category(segmentId);\n\n\t\tif (category == Category.ONExONE) {\n\t\t\tzone.one.max -= count;\n\t\t} else if (category == Category.TWOxTWO) {\n\t\t\tzone.two.max -= count;\n\t\t} else if (category == Category.THREExTHREE) {\n\t\t\tzone.three.max -= count;\n\t\t} else if (category == Category.SIXxSIX) {\n\t\t\tzone.four.max -= count;\n\t\t}\n\t}\n\n\t// add a new zone\n\tfunction _addZone(Zone memory zone) internal {\n\t\tuint8 index = _getZoneIndex();\n\t\tindex += 1;\n\t\t_setZone(index, zone);\n\t\t_setZoneIndex(index);\n\t}\n\n\t// Getters\n\n\t// TODO: resolve the indicies in a way that does not\n\t// require a contract upgrade to add a named zone\n\tfunction _getIndexSportsCity() internal pure returns (uint8) {\n\t\treturn 1;\n\t}\n\n\tfunction _getIndexLionLands() internal pure returns (uint8) {\n\t\treturn 2;\n\t}\n\n\t// get a segment for a zoneId and segmentId\n\tfunction _getSegment(uint8 zoneId, uint8 segmentId)\n\t\tinternal\n\t\tview\n\t\treturns (Segment memory segment)\n\t{\n\t\tZone memory zone = _getZone(zoneId);\n\t\treturn _getSegment(zone, segmentId);\n\t}\n\n\t// get a segment for a zone and segmentId\n\tfunction _getSegment(Zone memory zone, uint8 segmentId)\n\t\tinternal\n\t\tpure\n\t\treturns (Segment memory segment)\n\t{\n\t\tCategory category = Category(segmentId);\n\t\tif (category == Category.ONExONE) {\n\t\t\treturn zone.one;\n\t\t}\n\t\tif (category == Category.TWOxTWO) {\n\t\t\treturn zone.two;\n\t\t}\n\t\tif (category == Category.THREExTHREE) {\n\t\t\treturn zone.three;\n\t\t}\n\t\tif (category == Category.SIXxSIX) {\n\t\t\treturn zone.four;\n\t\t}\n\t\trevert(\"_getCategory: wrong category\");\n\t}\n\n\tfunction _getSigner() internal view returns (address) {\n\t\treturn layout().signer;\n\t}\n\n\t// get the current index of zones\n\tfunction _getZoneIndex() internal view returns (uint8) {\n\t\treturn layout().zoneIndex;\n\t}\n\n\t// get a zone from storage\n\tfunction _getZone(uint8 zoneId) internal view returns (Zone storage) {\n\t\treturn LandStorage.layout().zones[zoneId];\n\t}\n\n\t// Setters\n\n\t// set maximum available inventory\n\t// note setting to the current count effectively makes none available.\n\tfunction _setInventory(\n\t\tZone storage zone,\n\t\tuint16 maxOne,\n\t\tuint16 maxTwo,\n\t\tuint16 maxThree,\n\t\tuint16 maxFour\n\t) internal {\n\t\tzone.one.max = maxOne;\n\t\tzone.two.max = maxTwo;\n\t\tzone.three.max = maxThree;\n\t\tzone.four.max = maxFour;\n\t}\n\n\t// set an approved proxy\n\tfunction _setProxy(address proxy, bool enabled) internal {\n\t\tlayout().proxies[proxy] = enabled;\n\t}\n\n\t// set the account that can sign tgransactions\n\tfunction _setSigner(address signer) internal {\n\t\tlayout().signer = signer;\n\t}\n\n\tfunction _setZone(uint8 zoneId, Zone memory zone) internal {\n\t\tlayout().zones[zoneId] = zone;\n\t}\n\n\tfunction _setZoneIndex(uint8 index) internal {\n\t\tlayout().zoneIndex = index;\n\t}\n\n\tfunction _isValidInventory(Segment memory segment, uint16 maxCount) internal pure returns (bool) {\n\t\trequire(maxCount >= segment.count, \"_isValidInventory: invalid\");\n\t\trequire(\n\t\t\tmaxCount <= segment.endIndex - segment.startIndex - segment.count,\n\t\t\t\"_isValidInventory: too much\"\n\t\t);\n\n\t\treturn true;\n\t}\n\n\tfunction _isValidSegment(Segment memory last, Segment memory incoming)\n\t\tinternal\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\trequire(incoming.count == 0, \"_isValidSegment: wrong count\");\n\t\trequire(incoming.startIndex == last.endIndex, \"_isValidSegment: wrong start\");\n\t\trequire(incoming.startIndex <= incoming.endIndex, \"_isValidSegment: wrong end\");\n\t\trequire(incoming.max <= incoming.endIndex - incoming.startIndex, \"_isValidSegment: wrong max\");\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/land/LandTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// Enums\n\nenum MintState {\n\tCLOSED,\n\tPRESALE,\n\tOPEN\n}\n\n// item category\nenum Category {\n\tUNKNOWN,\n\tONExONE,\n\tTWOxTWO,\n\tTHREExTHREE,\n\tSIXxSIX\n}\n\n// Data Types\n\n// defines the valid range of token id's of a segment\nstruct Segment {\n\tuint16 count; // count of tokens minted in the segment\n\tuint16 max; // max available for the segment (make sure it doesnt overflow)\n\tuint24 startIndex; // starting index of the segment\n\tuint24 endIndex; // end index of the segment\n}\n\n// price per type\nstruct SegmentPrice {\n\tuint64 one; // 1x1\n\tuint64 two; // 2x2\n\tuint64 three; // 3x3\n\tuint64 four; // 6x6\n}\n\n// a zone is a specific area of land\nstruct Zone {\n\tSegment one; // 1x1\n\tSegment two; // 2x2\n\tSegment three; // 3x3\n\tSegment four; // 6x6\n}\n\n// Init Args\n\n// initialization args for the proxy\nstruct LandInitArgs {\n\taddress signer;\n\taddress lions;\n\taddress icons;\n\tSegmentPrice price;\n\tSegmentPrice lionsDiscountPrice;\n\tZone zoneOne; // City\n\tZone zoneTwo; // Lion\n}\n\n// requests\n\n// request to mint a single item\nstruct MintRequest {\n\taddress to;\n\tuint64 deadline; // block.timestamp\n\tuint8 zoneId;\n\tuint8 segmentId;\n\tuint16 count;\n}\n\n// request to mint many different types\n// expects the SegmentCount array to be in index order\nstruct MintManyRequest {\n\taddress to;\n\tuint64 deadline;\n\tSegmentCount[] zones;\n}\n\n// requested amount for a specific segment\nstruct SegmentCount {\n\tuint16 countOne; // 1x1\n\tuint16 countTwo; // 2x2\n\tuint16 countThree; // 3x3\n\tuint16 countFour; // 6x6\n}\n"
    },
    "contracts/vendor/ERC2981/ERC2981Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct RoyaltyInfo {\n\taddress recipient;\n\tuint24 amount;\n}\n\nlibrary ERC2981Storage {\n\tstruct Layout {\n\t\tRoyaltyInfo royalties;\n\t}\n\n\tbytes32 internal constant STORAGE_SLOT =\n\t\tkeccak256(\"IERC2981Royalties.contracts.storage.ERC2981Storage\");\n\n\tfunction layout() internal pure returns (Layout storage l) {\n\t\tbytes32 slot = STORAGE_SLOT;\n\t\t// slither-disable-next-line timestamp\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tl.slot := slot\n\t\t}\n\t}\n}\n"
    },
    "contracts/vendor/ERC2981/IERC2981Royalties.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IERC2981Royalties\n/// @dev Interface for the ERC2981 - Token Royalty standard\ninterface IERC2981Royalties {\n\t/// @notice Called with the sale price to determine how much royalty\n\t//          is owed and to whom.\n\t/// @param _tokenId - the NFT asset queried for royalty information\n\t/// @param _value - the sale price of the NFT asset specified by _tokenId\n\t/// @return _receiver - address of who should be sent the royalty payment\n\t/// @return _royaltyAmount - the royalty payment amount for value sale price\n\tfunction royaltyInfo(uint256 _tokenId, uint256 _value)\n\t\texternal\n\t\tview\n\t\treturns (address _receiver, uint256 _royaltyAmount);\n}\n"
    },
    "contracts/vendor/OpenSea/IOpenSeaCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IOpenSeaCompatible {\n\t/**\n\t * Get the contract metadata\n\t */\n\tfunction contractURI() external view returns (string memory);\n}\n"
    },
    "contracts/vendor/OpenSea/OpenSeaCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOpenSeaCompatible } from \"./IOpenSeaCompatible.sol\";\n\nlibrary OpenSeaCompatibleStorage {\n\tstruct Layout {\n\t\tstring contractURI;\n\t}\n\n\tbytes32 internal constant STORAGE_SLOT =\n\t\tkeccak256(\"com.opensea.contracts.storage.OpenSeaCompatibleStorage\");\n\n\tfunction layout() internal pure returns (Layout storage l) {\n\t\tbytes32 slot = STORAGE_SLOT;\n\t\tassembly {\n\t\t\tl.slot := slot\n\t\t}\n\t}\n}\n\nabstract contract OpenSeaCompatibleInternal {\n\tfunction _setContractURI(string memory contractURI) internal virtual {\n\t\tOpenSeaCompatibleStorage.layout().contractURI = contractURI;\n\t}\n}\n\nabstract contract OpenSeaCompatible is OpenSeaCompatibleInternal, IOpenSeaCompatible {\n\tfunction contractURI() external view returns (string memory) {\n\t\treturn OpenSeaCompatibleStorage.layout().contractURI;\n\t}\n}\n"
    },
    "contracts/vendor/OpenSea/OpenSeaProxyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nstruct OpenSeaProxyInitArgs {\n\taddress os721Proxy;\n\taddress os1155Proxy;\n}\n\nlibrary OpenSeaProxyStorage {\n\tstruct Layout {\n\t\taddress os721Proxy;\n\t\taddress os1155Proxy;\n\t}\n\n\tbytes32 internal constant STORAGE_SLOT = keccak256(\"com.opensea.contracts.storage.proxy\");\n\n\tfunction layout() internal pure returns (Layout storage l) {\n\t\tbytes32 slot = STORAGE_SLOT;\n\t\t// slither-disable-next-line timestamp\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tl.slot := slot\n\t\t}\n\t}\n\n\tfunction _setProxies(OpenSeaProxyInitArgs memory init) internal {\n\t\t_setProxies(init.os721Proxy, init.os1155Proxy);\n\t}\n\n\tfunction _setProxies(address os721Proxy, address os1155Proxy) internal {\n\t\tlayout().os721Proxy = os721Proxy;\n\t\tlayout().os1155Proxy = os1155Proxy;\n\t}\n}\n"
    }
  }
}}