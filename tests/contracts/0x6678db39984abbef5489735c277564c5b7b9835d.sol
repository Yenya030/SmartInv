{{
  "language": "Solidity",
  "sources": {
    "contracts/DeadWillRise.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"./ERC721A.sol\";\r\nimport \"../delegatecash/IDelegationRegistry.sol\";\r\nimport \"../weth/IWETH.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\r\n\r\n\r\n/** Dead Will Rise presented by Gutter Punks\r\n  * Contract by 0xth0mas (0xjustadev)\r\n  * Gas optimization credit 0xDelco\r\n*/\r\n\r\ncontract DeadWillRise is ERC721A, Ownable {\r\n\r\n    event IndividualDailyActivity(uint256 tokenId, uint256 currentDay, uint256 riskChoice, uint256 activityOutcome);\r\n    event IndividualCured(uint256 tokenId);\r\n    event GroupDailyActivity(uint256 groupNum, uint256 currentDay, uint256 riskChoice, uint256 activityOutcome);\r\n    event InfectionSpreading(uint256 currentProgress, uint256 infectionRate);\r\n    event GroupRegistered(uint256 groupNum, address collectionAddress, address groupManager);\r\n    event GroupTransferred(uint256 groupNum, address collectionAddress, address groupManager);\r\n\r\n    struct IndividualData {\r\n        uint32 lastBlock;\r\n        uint32 lastScore;\r\n        uint32 individualSeed;\r\n        uint32 groupNumber;\r\n        bool bitten; // potential outcome from an activity, when bitten individual score rate decreases substantially\r\n    }\r\n\r\n    struct GroupData {\r\n        uint32 lastBlock;\r\n        uint32 lastScore;\r\n        uint32 groupSeed;\r\n        uint32 totalMembers;\r\n    }\r\n\r\n    struct InfectionData {\r\n        uint32 lastBlock;\r\n        uint32 lastProgress;\r\n        uint32 infectionRate; // rate that the infection progress will increase per block\r\n    }\r\n\r\n    struct ActivityRecord {\r\n        uint32 riskChoice; // 1 = low risk, 2 = medium risk, 3 = high risk\r\n        uint32 activityOutcome; // 1 = small reward, 2 = medium reward, 3 = large reward, 4 = devastation\r\n    }\r\n\r\n    uint256 public constant INDIVIDUAL_DAILY_ACTIVITY_COST = 0.001 ether;\r\n    uint256 public constant GROUP_DAILY_ACTIVITY_COST = 0.01 ether;\r\n    uint256 public constant GROUP_REGISTRATION_COST = 0.1 ether;\r\n    uint256 public constant FINAL_CURE_COST = 10 ether;\r\n    uint32 constant CURE_PROGRESS_INCREMENT = 72000;\r\n\r\n    uint8 constant RISK_LEVEL_LOW = 1;\r\n    uint8 constant RISK_LEVEL_MEDIUM = 2;\r\n    uint8 constant RISK_LEVEL_HIGH = 3;\r\n    uint8 constant ACTIVITY_OUTCOME_SMALL = 1;\r\n    uint8 constant ACTIVITY_OUTCOME_MEDIUM = 2;\r\n    uint8 constant ACTIVITY_OUTCOME_LARGE = 3;\r\n    uint8 constant ACTIVITY_OUTCOME_DEVASTATED = 4;\r\n    uint8 constant ACTIVITY_OUTCOME_CURED = 5;\r\n    uint8 constant ACTIVITY_OUTCOME_STILL_A_ZOMBIE = 6;\r\n\r\n    uint8 public constant MAX_DAY = 19;\r\n\r\n    // Individuals will have a rate between 100-150 if unbitten, 25-37 if bitten\r\n    uint32 constant INDIVIDUAL_BASE_RATE = 100;\r\n    uint32 constant INDIVIDUAL_VARIABLE_RATE = 50;\r\n    uint32 constant INDIVIDUAL_MAXIMUM_LUCK = 1000; // luck used to determine outcome of activities\r\n    uint32 constant TOTAL_MAXIMUM_LUCK = 10000; // luck used to determine outcome of activities\r\n    uint32 constant RISK_LOW_OUTCOME_LARGE = 9900;\r\n    uint32 constant RISK_LOW_OUTCOME_MEDIUM = 9500;\r\n    uint32 constant RISK_LOW_OUTCOME_SMALL = 100;\r\n    uint32 constant RISK_MEDIUM_OUTCOME_LARGE = 9000;\r\n    uint32 constant RISK_MEDIUM_OUTCOME_MEDIUM = 7500;\r\n    uint32 constant RISK_MEDIUM_OUTCOME_SMALL = 1000;\r\n    uint32 constant RISK_HIGH_OUTCOME_LARGE = 7500;\r\n    uint32 constant RISK_HIGH_OUTCOME_MEDIUM = 5000;\r\n    uint32 constant RISK_HIGH_OUTCOME_SMALL = 3300;\r\n    uint32 constant RANDOM_CURE_CHANCE = 9500;\r\n    uint32 constant INDIVIDUAL_REWARD_OUTCOME_LARGE = 360000;\r\n    uint32 constant INDIVIDUAL_REWARD_OUTCOME_MEDIUM = 180000;\r\n    uint32 constant INDIVIDUAL_REWARD_OUTCOME_SMALL = 72000;\r\n    uint32 constant GROUP_REWARD_OUTCOME_LARGE = 36000;\r\n    uint32 constant GROUP_REWARD_OUTCOME_MEDIUM = 18000;\r\n    uint32 constant GROUP_REWARD_OUTCOME_SMALL = 3600;\r\n\r\n    // Group scoring rate will increase by 1 for every 10th member that joins, 1 member = 1, 9 members = 1, 10 members = 2, 95 members = 10\r\n    uint32 constant GROUP_BASE_RATE = 1;\r\n    uint32 constant GROUP_VARIABLE_RATE = 10;\r\n    uint32 constant GROUP_RATE_MULTIPLIER = 1;\r\n\r\n    uint256 public constant MAX_SUPPLY = 5000;\r\n\r\n    bool public eventOver;\r\n    uint64 public eventStartTime;\r\n    uint32 public eventStartBlock;\r\n\r\n    uint32 public collectionSeed; // random seed set at start of game, collection seed == 0 means event not started\r\n    uint32 public groupsRegistered; // current count of groups registered for Dead Will Rise\r\n\r\n    bool public groupRegistrationOpen;\r\n    bool public publicMintOpen;\r\n\r\n    uint32 public maxPerWalletPerGroup = 1;\r\n    uint32 public maxPerGroup = 500;\r\n    uint32 public cureSupply = 500;\r\n\r\n    uint32 public lastSurvivorTokenID; // declared at end of game\r\n    uint32 public winningGroupNumber; // declared at end of game\r\n    uint32 constant BLOCKS_PER_DAY = 7200;\r\n    uint32 constant WITHDRAWAL_DELAY = 3600; // blocks to wait after winners declared for withdrawal\r\n    uint32 constant LATE_JOINER_PROGRESS = 21600;\r\n\r\n    InfectionData public infectionProgress; // current infection data - currentProgress = lastProgress + (block.number - lastBlock) * infectionRate\r\n    mapping(address => uint256) public groupNumbers; // key = ERC-721 collection address, value = group number\r\n    mapping(uint256 => address) public groupNumberToCollection; // key = group number, value = ERC-721 collection address\r\n    mapping(uint256 => GroupData) public groupRecord; // key = group number, value = group data\r\n    mapping(uint256 => address) public groupManager; // key = group number, value = current manager of group, will receive payout if group wins\r\n    mapping(uint256 => ActivityRecord) public groupActivity; // key = groupNumber<<32 + day, value = activity results\r\n    mapping(uint256 => IndividualData) public individualRecord; // key = tokenId, value = individual data\r\n    mapping(uint256 => ActivityRecord) public individualActivity; // key = tokenId<<32 + day, value = activity results\r\n\r\n    mapping(uint256 => uint256) public mintCount; // key = account<<32 + groupNumber, value = # minted\r\n\r\n    IWETH weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IDelegationRegistry delegateCash = IDelegationRegistry(0x00000000000076A84feF008CDAbe6409d2FE638B);\r\n\r\n    string internal _baseTokenURI;\r\n    string internal _placeholderURI;\r\n    string internal _contractURI;\r\n\r\n    string public constant TOKEN_URI_SEPARATOR = \"/\";\r\n    bool public includeStatsInURI = true;\r\n\r\n    modifier eventInProgress() {\r\n        require(collectionSeed > 0 && !eventOver);\r\n        _;\r\n    }\r\n\r\n    modifier eventEnded() {\r\n        require(eventOver);\r\n        _;\r\n    }\r\n\r\n    modifier canWithdraw() {\r\n        require(uint32(block.number) > (infectionProgress.lastBlock + WITHDRAWAL_DELAY));\r\n        _;\r\n    }\r\n\r\n    constructor(string memory mContractURI, string memory mPlaceholderURI) ERC721A(\"Dead Will Rise\", \"DWR\") {\r\n        _contractURI = mContractURI;\r\n        _placeholderURI = mPlaceholderURI;\r\n    }\r\n\r\n    // to receive royalties and/or donations\r\n    receive() external payable { }\r\n    fallback() external payable { }\r\n    //unwrap WETH from any royalties paid in WETH\r\n    function unwrapWETH() external onlyOwner {\r\n        uint256 wethBalance = weth.balanceOf(address(this));\r\n        weth.withdraw(wethBalance);\r\n    }\r\n\r\n    /** GAME MANAGEMENT FUNCTIONS\r\n    */ \r\n    function startEvent(uint32 _infectionRate) external onlyOwner {\r\n        require(collectionSeed == 0);\r\n        eventStartTime = uint64(block.timestamp);\r\n        collectionSeed = uint32(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))));\r\n        infectionProgress.lastBlock = uint32(block.number);\r\n        infectionProgress.infectionRate = _infectionRate;\r\n        emit InfectionSpreading(infectionProgress.lastProgress, infectionProgress.infectionRate);\r\n        eventStartBlock = uint32(block.number);\r\n    }\r\n\r\n    function endEvent() external onlyOwner eventInProgress {\r\n        require(!eventOver);\r\n        infectionProgress.lastProgress = this.currentInfectionProgress();\r\n        infectionProgress.lastBlock = uint32(block.number);\r\n        infectionProgress.infectionRate = 0;\r\n        emit InfectionSpreading(infectionProgress.lastProgress, infectionProgress.infectionRate);\r\n        eventOver = true;\r\n    }\r\n\r\n    function resumeEvent(uint32 _infectionRate) external onlyOwner eventEnded {\r\n        require(eventOver);\r\n        infectionProgress.lastProgress = this.currentInfectionProgress();\r\n        infectionProgress.lastBlock = uint32(block.number);\r\n        infectionProgress.infectionRate = _infectionRate;\r\n        emit InfectionSpreading(infectionProgress.lastProgress, infectionProgress.infectionRate);\r\n        eventOver = false;\r\n    }\r\n\r\n    function setInfectionRate(uint32 _infectionRate, uint32 _progressAdder) external onlyOwner eventInProgress {\r\n        infectionProgress.lastProgress = this.currentInfectionProgress() + _progressAdder;\r\n        infectionProgress.lastBlock = uint32(block.number);\r\n        infectionProgress.infectionRate = _infectionRate;\r\n        emit InfectionSpreading(infectionProgress.lastProgress, infectionProgress.infectionRate);\r\n    }\r\n\r\n    function setInfectionProgress(uint32 _infectionProgress) external onlyOwner {\r\n        infectionProgress.lastProgress = _infectionProgress;\r\n        emit InfectionSpreading(infectionProgress.lastProgress, infectionProgress.infectionRate);\r\n    }\r\n\r\n    /** Save gas vs iterating collection for winner by declaring winner and allow anyone to challenge that another token has a higher score\r\n        Winner can be declared after event has ended but withdrawals are delayed until 12 hours after event ends to allow for challenges\r\n        In the event of a tie, first to declare wins... because this is an apocalypse and you have to be ready.\r\n    */\r\n    function declareLastSurvivor(uint256 tokenId) external eventEnded {\r\n        uint256 _currentTokenID = lastSurvivorTokenID;\r\n        if(_currentTokenID == 0 || this.getIndividualScore(tokenId) > this.getIndividualScore(_currentTokenID)) {\r\n            lastSurvivorTokenID = uint32(tokenId);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /** Save gas vs iterating groups for winner by declaring winner and allow anyone to challenge that another group has a higher score\r\n        Winner can be declared after event has ended but withdrawals are delayed until 12 hours after event ends to allow for challenges\r\n        In the event of a tie, first to declare wins... because this is an apocalypse and you have to be ready.\r\n    */ \r\n    function declareWinningGroup(uint32 groupNumber) external eventEnded {\r\n        uint32 _currentGroupNumber = winningGroupNumber;\r\n        if(_currentGroupNumber == 0 || this.getGroupScore(groupNumber) > this.getGroupScore(_currentGroupNumber)) {\r\n            winningGroupNumber = groupNumber;\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    uint256 public totalWithdrawn;\r\n    uint256 public totalSwept;\r\n    uint256 public hostBalance;\r\n    uint256 public groupBalance;\r\n    uint256 public survivorBalance;\r\n\r\n    /** Sweep rewards into a balance mapping first to avoid survivor/group owner set to contract with revert\r\n    */\r\n    function sweepRewards() external onlyOwner canWithdraw {\r\n        uint256 currentPool = totalWithdrawn + address(this).balance - totalSwept;\r\n        totalSwept = totalSwept + currentPool;\r\n\r\n        uint256 survivorShare = currentPool * 30 / 100;\r\n        uint256 groupShare = currentPool * 20 / 100;\r\n        uint256 hostShare = (currentPool - survivorShare - groupShare);\r\n\r\n        hostBalance += hostShare;\r\n        groupBalance += groupShare;\r\n        survivorBalance += survivorShare;\r\n    }\r\n\r\n    function withdraw(uint256 share) external onlyOwner {\r\n        address recipient;\r\n        uint256 recipientBalance;\r\n        if(share == 1) {\r\n            recipient = owner();\r\n            recipientBalance = hostBalance;\r\n            hostBalance = 0;\r\n        } else if(share == 2) {\r\n            recipient = groupManager[winningGroupNumber];\r\n            recipientBalance = groupBalance;\r\n            groupBalance = 0;\r\n        } else if(share == 3) {\r\n            recipient = ownerOf(lastSurvivorTokenID);\r\n            recipientBalance = survivorBalance;\r\n            survivorBalance = 0;\r\n        }\r\n        require(recipientBalance > 0);\r\n        (bool sent, ) = payable(recipient).call{value: recipientBalance}(\"\");\r\n        require(sent);\r\n        totalWithdrawn = totalWithdrawn + recipientBalance;\r\n    }\r\n\r\n    /** SCORE FUNCTIONS \r\n    */\r\n\r\n    function currentInfectionProgress() external view returns (uint32) {\r\n        if(eventOver) return infectionProgress.lastProgress;\r\n        return (infectionProgress.lastProgress + (uint32(block.number) - infectionProgress.lastBlock) * infectionProgress.infectionRate);\r\n    }\r\n\r\n    function getIndividualScore(uint256 tokenId) external view returns (uint32) {\r\n        require(_exists(tokenId));\r\n        if(eventStartTime == 0) return 0;\r\n        uint32 _endBlock = uint32(block.number);\r\n        if(eventOver) _endBlock = infectionProgress.lastBlock;\r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        uint32 _lastBlock = individual.lastBlock;\r\n        if(_lastBlock == 0) _lastBlock = eventStartBlock;\r\n        return (individual.lastScore + (_endBlock - _lastBlock) * this.getIndividualRate(tokenId,false) + this.getGroupScore(individual.groupNumber));\r\n    }\r\n\r\n    function getIndividualOnlyScore(uint256 tokenId) external view returns (uint32) {\r\n        require(_exists(tokenId));\r\n        if(eventStartTime == 0) return 0;\r\n        uint32 _endBlock = uint32(block.number);\r\n        if(eventOver) _endBlock = infectionProgress.lastBlock;\r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        uint32 _lastBlock = individual.lastBlock;\r\n        if(_lastBlock == 0) _lastBlock = eventStartBlock;\r\n        return (individual.lastScore + (_endBlock - _lastBlock) * this.getIndividualRate(tokenId,false));\r\n    }\r\n\r\n    function getIndividualRate(uint256 tokenId, bool ignoreBite) external view returns (uint32) {\r\n        if(eventStartTime == 0) return 0;\r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        uint32 _individualRate = uint32(uint256(keccak256(abi.encodePacked(individual.individualSeed, collectionSeed)))) % INDIVIDUAL_VARIABLE_RATE + INDIVIDUAL_BASE_RATE;\r\n        if(individual.bitten && !ignoreBite) { _individualRate = _individualRate / 4; }\r\n        return _individualRate;\r\n    }\r\n\r\n    function getIndividualLuck(uint256 tokenId) external view returns (uint32) {\r\n        if(eventStartTime == 0) return 0;\r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        uint32 _individualLuck = uint32(uint256(keccak256(abi.encodePacked(collectionSeed, individual.individualSeed)))) % INDIVIDUAL_MAXIMUM_LUCK;\r\n        return _individualLuck;\r\n    }\r\n\r\n    function getGroupScoreByAddress(address _collectionAddress) external view returns(uint32) {\r\n        return this.getGroupScore(uint32(groupNumbers[_collectionAddress]));\r\n    }\r\n\r\n    function getGroupScore(uint32 _groupNumber) external view returns (uint32) {\r\n        if(_groupNumber == 0) return 0;\r\n        if(eventStartTime == 0) return 0;\r\n        uint32 _endBlock = uint32(block.number);\r\n        if(eventOver) _endBlock = infectionProgress.lastBlock;\r\n        GroupData memory group = groupRecord[uint256(_groupNumber)];\r\n        uint32 _lastBlock = group.lastBlock;\r\n        if(_lastBlock == 0) _lastBlock = eventStartBlock;\r\n        return (group.lastScore + (_endBlock - _lastBlock) * this.getGroupRate(_groupNumber));\r\n    }\r\n\r\n    function getGroupRate(uint32 _groupNumber) external view returns (uint32) {\r\n        if(eventStartTime == 0) return 0;\r\n        if(_groupNumber == 0 || _groupNumber > groupsRegistered) return 0;\r\n        uint32 _totalMembers = groupRecord[uint256(_groupNumber)].totalMembers;\r\n        return (_totalMembers / GROUP_VARIABLE_RATE + GROUP_BASE_RATE) * GROUP_RATE_MULTIPLIER;\r\n    }\r\n\r\n    /** DAILY ACTIVITY FUNCTIONS \r\n    */\r\n    function currentDay() external view returns (uint32) {\r\n        if(eventStartTime == 0) return 0;\r\n        uint32 _currentDay = uint32((block.timestamp - uint256(eventStartTime)) / 1 days + 1);\r\n        if(_currentDay > MAX_DAY) { _currentDay = MAX_DAY; }\r\n        return _currentDay;\r\n    }\r\n\r\n    function getIndividualDailyActivityRecords(uint256 tokenId) external view returns(ActivityRecord[] memory) {\r\n        uint256 numRecords = this.currentDay();\r\n        ActivityRecord[] memory records = new ActivityRecord[](numRecords);\r\n        for(uint256 i = 1;i <= numRecords;i++) {\r\n            records[i-1] = individualActivity[((tokenId << 32) + i)];\r\n        }\r\n        return records;\r\n    }\r\n\r\n    function getGroupDailyActivityRecords(uint32 _groupNumber) external view returns(ActivityRecord[] memory) {\r\n        uint256 numRecords = this.currentDay();\r\n        ActivityRecord[] memory records = new ActivityRecord[](numRecords);\r\n        for(uint256 i = 1;i <= numRecords;i++) {\r\n            records[i-1] = groupActivity[((uint256(_groupNumber) << 32) + i)];\r\n        }\r\n        return records;\r\n    }\r\n\r\n    function getGroupDailyActivityRecordsByAddress(address _collectionAddress) external view returns(ActivityRecord[] memory) {\r\n        return this.getGroupDailyActivityRecords(uint32(groupNumbers[_collectionAddress]));\r\n    }\r\n    \r\n    function cureIndividual(uint256 tokenId) external payable eventInProgress {\r\n        require(ownerOf(tokenId) == msg.sender);\r\n        require(cureSupply > 0);\r\n\r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        if(individual.lastBlock == 0) { individual.lastBlock = eventStartBlock; }\r\n        individual.lastScore = (individual.lastScore + (uint32(block.number) - individual.lastBlock) * this.getIndividualRate(tokenId,false));\r\n        individual.lastBlock = uint32(block.number);\r\n        uint32 _groupScore = this.getGroupScore(individual.groupNumber);\r\n        uint32 _totalScore = (individual.lastScore + _groupScore);\r\n        uint32 _currentInfectionProgress = this.currentInfectionProgress();\r\n        uint256 cureCost = FINAL_CURE_COST / cureSupply;\r\n        \r\n        if(_totalScore >= _currentInfectionProgress && individual.bitten) { // half cost if bitten but not fully zombie yet\r\n            cureCost = cureCost / 2;\r\n        } else if(_totalScore < _currentInfectionProgress) {\r\n            individual.lastScore = (_currentInfectionProgress + CURE_PROGRESS_INCREMENT) - _groupScore; // bump score over infection level\r\n        } else {\r\n            cureCost = cureCost * 5; // greedy people that don't need a cure pay 5x\r\n        }\r\n        individual.bitten = false;\r\n\r\n        cureSupply = cureSupply - 1;\r\n        individualRecord[tokenId] = individual;\r\n        require(msg.value >= cureCost);\r\n        emit IndividualCured(tokenId);\r\n    }\r\n\r\n    function dailyActivityIndividual(uint256 tokenId, uint32 _riskChoice) external payable eventInProgress {\r\n        require(_riskChoice >= RISK_LEVEL_LOW && _riskChoice <= RISK_LEVEL_HIGH);\r\n        require(msg.value >= INDIVIDUAL_DAILY_ACTIVITY_COST);\r\n        require(ownerOf(tokenId) == msg.sender);\r\n\r\n        uint256 _currentDay = uint256(this.currentDay());\r\n        uint256 individualDayKey = (tokenId << 32) + _currentDay;\r\n        ActivityRecord memory activity = individualActivity[individualDayKey];\r\n        require(activity.riskChoice == 0);\r\n        uint32 _activityOutcome = 0;\r\n        \r\n        IndividualData memory individual = individualRecord[tokenId];\r\n        if(individual.lastBlock == 0) { individual.lastBlock = eventStartBlock; }\r\n        individual.lastScore = (individual.lastScore + (uint32(block.number) - individual.lastBlock) * this.getIndividualRate(tokenId,false));\r\n        individual.lastBlock = uint32(block.number);\r\n        uint32 _groupScore = this.getGroupScore(individual.groupNumber);\r\n        uint32 _currentInfectionProgress = this.currentInfectionProgress();\r\n        uint32 _individualLuck = this.getIndividualLuck(tokenId);\r\n\r\n        uint32 _seed = (uint32(uint256(keccak256(abi.encodePacked(block.timestamp,block.difficulty,tokenId)))) % TOTAL_MAXIMUM_LUCK) + _individualLuck;\r\n\r\n        if((individual.lastScore + _groupScore) >= _currentInfectionProgress) {\r\n            if(_riskChoice == RISK_LEVEL_LOW) {\r\n                if(_seed > RISK_LOW_OUTCOME_LARGE) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_LARGE;\r\n                } else if(_seed > RISK_LOW_OUTCOME_MEDIUM) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_MEDIUM;\r\n                } else if(_seed > RISK_LOW_OUTCOME_SMALL) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_SMALL;\r\n                } else {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                    individual.bitten = true;\r\n                }\r\n            } else if(_riskChoice == RISK_LEVEL_MEDIUM) {\r\n                if(_seed > RISK_MEDIUM_OUTCOME_LARGE) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_LARGE;\r\n                } else if(_seed > RISK_MEDIUM_OUTCOME_MEDIUM) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_MEDIUM;\r\n                } else if(_seed > RISK_MEDIUM_OUTCOME_SMALL) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_SMALL;\r\n                } else {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                    individual.bitten = true;\r\n                }\r\n            } else if(_riskChoice == RISK_LEVEL_HIGH) {\r\n                if(_seed > RISK_HIGH_OUTCOME_LARGE) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_LARGE;\r\n                } else if(_seed > RISK_HIGH_OUTCOME_MEDIUM) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_MEDIUM;\r\n                } else if(_seed > RISK_HIGH_OUTCOME_SMALL) {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                    individual.lastScore += INDIVIDUAL_REWARD_OUTCOME_SMALL;\r\n                } else {\r\n                    _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                    individual.bitten = true;\r\n                }\r\n            }\r\n        } else { // already a zombie, chance to recover\r\n            if(_seed > RANDOM_CURE_CHANCE) {\r\n                _riskChoice = 1;\r\n                individual.lastScore = (_currentInfectionProgress + LATE_JOINER_PROGRESS) - _groupScore;\r\n                _activityOutcome = ACTIVITY_OUTCOME_CURED;\r\n                individual.bitten = false;\r\n            } else {\r\n                _riskChoice = 1;\r\n                _activityOutcome = ACTIVITY_OUTCOME_STILL_A_ZOMBIE;\r\n            }\r\n        }\r\n\r\n        activity.riskChoice = _riskChoice;\r\n        activity.activityOutcome = _activityOutcome;\r\n\r\n        individualActivity[individualDayKey] = activity;\r\n        individualRecord[tokenId] = individual;\r\n\r\n        emit IndividualDailyActivity(tokenId, _currentDay, _riskChoice, _activityOutcome);\r\n    }\r\n\r\n    function dailyActivityGroup(uint32 _groupNumber, uint32 _riskChoice) external payable eventInProgress {\r\n        require(_riskChoice >= RISK_LEVEL_LOW && _riskChoice <= RISK_LEVEL_HIGH);\r\n        require(msg.value >= GROUP_DAILY_ACTIVITY_COST);\r\n        require(groupManager[_groupNumber] == msg.sender);\r\n\r\n        uint256 _currentDay = uint256(this.currentDay());\r\n        uint256 groupDayKey = (uint256(_groupNumber) << 32) + _currentDay;\r\n        ActivityRecord memory activity = groupActivity[groupDayKey];\r\n        require(activity.riskChoice == 0);\r\n        uint32 _activityOutcome = 0;\r\n        \r\n        GroupData memory group = groupRecord[uint256(_groupNumber)];\r\n        if(group.lastBlock == 0) { group.lastBlock = eventStartBlock; }\r\n        group.lastScore = (group.lastScore + (uint32(block.number) - group.lastBlock) * this.getGroupRate(_groupNumber));\r\n        group.lastBlock = uint32(block.number);\r\n\r\n        uint32 _seed = (uint32(uint256(keccak256(abi.encodePacked(block.timestamp,block.difficulty,_groupNumber)))) % TOTAL_MAXIMUM_LUCK);\r\n\r\n        if(_riskChoice == RISK_LEVEL_LOW) {\r\n            if(_seed > RISK_LOW_OUTCOME_LARGE) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_LARGE;\r\n            } else if(_seed > RISK_LOW_OUTCOME_MEDIUM) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_MEDIUM;\r\n            } else if(_seed > RISK_LOW_OUTCOME_SMALL) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_SMALL;\r\n            } else {\r\n                _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                group.lastScore /= 2;\r\n            }\r\n        } else if(_riskChoice == RISK_LEVEL_MEDIUM) {\r\n            if(_seed > RISK_MEDIUM_OUTCOME_LARGE) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_LARGE;\r\n            } else if(_seed > RISK_MEDIUM_OUTCOME_MEDIUM) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_MEDIUM;\r\n            } else if(_seed > RISK_MEDIUM_OUTCOME_SMALL) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_SMALL;\r\n            } else {\r\n                _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                group.lastScore /= 2;\r\n            }\r\n        } else if(_riskChoice == RISK_LEVEL_HIGH) {\r\n            if(_seed > RISK_HIGH_OUTCOME_LARGE) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_LARGE;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_LARGE;\r\n            } else if(_seed > RISK_HIGH_OUTCOME_MEDIUM) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_MEDIUM;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_MEDIUM;\r\n            } else if(_seed > RISK_HIGH_OUTCOME_SMALL) {\r\n                _activityOutcome = ACTIVITY_OUTCOME_SMALL;\r\n                group.lastScore += GROUP_REWARD_OUTCOME_SMALL;\r\n            } else {\r\n                _activityOutcome = ACTIVITY_OUTCOME_DEVASTATED;\r\n                group.lastScore /= 2;\r\n            }\r\n        }\r\n\r\n        activity.riskChoice = _riskChoice;\r\n        activity.activityOutcome = _activityOutcome;\r\n\r\n        groupActivity[groupDayKey] = activity;\r\n        groupRecord[uint256(_groupNumber)] = group;\r\n\r\n        emit GroupDailyActivity(_groupNumber, _currentDay, _riskChoice, _activityOutcome);\r\n    }\r\n\r\n    /** GROUP MANAGEMENT FUNCTIONS\r\n    */\r\n\r\n    /**  Register a group to Dead Will Rise, claims ownership\r\n    */\r\n    function registerGroup(address _collectionAddress) external payable {\r\n        require(groupRegistrationOpen);\r\n        require(msg.value >= GROUP_REGISTRATION_COST);\r\n        require(groupNumbers[_collectionAddress] == 0);\r\n        require(IERC721(_collectionAddress).supportsInterface(type(IERC721).interfaceId));\r\n        groupsRegistered = groupsRegistered + 1;\r\n        uint256 newGroupNumber = groupsRegistered;\r\n        GroupData memory newGroup;\r\n        newGroup.groupSeed = uint32(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, _collectionAddress))));\r\n        if(eventStartBlock > 0) {\r\n            newGroup.lastBlock = uint32(block.number);\r\n        }\r\n\r\n        groupNumberToCollection[newGroupNumber] = _collectionAddress;\r\n        groupNumbers[_collectionAddress] = newGroupNumber;\r\n        groupRecord[newGroupNumber] = newGroup;\r\n        groupManager[newGroupNumber] = msg.sender;\r\n        emit GroupRegistered(newGroupNumber, _collectionAddress, msg.sender);\r\n    }\r\n\r\n    /** Transfer management of a group to a new user\r\n    *   Current group manager can transfer ownership anytime\r\n    */\r\n    function transferGroupManagement(address _collectionAddress, address _newManager) external {\r\n        uint256 _groupNumber = groupNumbers[_collectionAddress];\r\n        require(groupManager[_groupNumber] == msg.sender);\r\n        groupManager[_groupNumber] = _newManager;\r\n        emit GroupTransferred(_groupNumber, _collectionAddress, _newManager);\r\n    }\r\n\r\n    /** MINTING FUNCTIONS\r\n    */\r\n    function setMintingVariables(bool _groupOpen, bool _publicOpen, uint32 _maxPerWalletPerGroup, uint32 _maxPerGroup) external onlyOwner {\r\n        groupRegistrationOpen = _groupOpen;\r\n        publicMintOpen = _publicOpen;\r\n        maxPerWalletPerGroup = _maxPerWalletPerGroup;\r\n        maxPerGroup = _maxPerGroup;\r\n    }\r\n\r\n    function getCurrentRegistrationCost() external view returns (uint256) {\r\n        if(eventStartBlock > 0) {\r\n            uint256 _currentDay = this.currentDay();\r\n            if(_currentDay == MAX_DAY) {\r\n                return 5000 ether;\r\n            } else {\r\n                return address(this).balance * 50 / 100 / (MAX_DAY - _currentDay);\r\n            }\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function mintInner(address _to, address _collectionAddress, address _onBehalfOf) internal {\r\n        uint256 tokenId = totalSupply() + 1;\r\n        require(tokenId <= MAX_SUPPLY);\r\n\r\n        uint32 _groupNumber = uint32(groupNumbers[_collectionAddress]);\r\n        require((groupRegistrationOpen && _groupNumber > 0) || publicMintOpen);\r\n\r\n        uint256 mintKey = (uint256(uint160(_onBehalfOf)) << 32) + _groupNumber;\r\n        uint256 currentCount = mintCount[mintKey];\r\n        require(currentCount + 1 <= maxPerWalletPerGroup);\r\n\r\n        uint256 _eventStartBlock = eventStartBlock;\r\n        IndividualData memory individual;\r\n        individual.individualSeed = uint32(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, mintKey))));\r\n        if(_eventStartBlock > 0) {\r\n            individual.lastBlock = uint32(block.number);\r\n            individual.lastScore = this.currentInfectionProgress() * 110 / 100;\r\n            require(msg.value >= this.getCurrentRegistrationCost());\r\n        }\r\n        if(_groupNumber > 0) {\r\n            require(IERC721(_collectionAddress).balanceOf(_onBehalfOf) > 0);\r\n            GroupData memory group = groupRecord[_groupNumber];\r\n            group.totalMembers = group.totalMembers + 1;\r\n            require(group.totalMembers <= maxPerGroup);\r\n            if(_eventStartBlock > 0) {\r\n                group.lastScore = this.getGroupScore(_groupNumber);\r\n                group.lastBlock = uint32(block.number);\r\n            }\r\n            individual.groupNumber = _groupNumber;\r\n            groupRecord[_groupNumber] = group;\r\n        }\r\n\r\n        _safeMint(_to, 1);\r\n        mintCount[mintKey] = currentCount + 1;\r\n        individualRecord[tokenId] = individual;\r\n    }\r\n\r\n    function delegateMint(address _collectionAddress, address _onBehalfOf) external payable {\r\n        require(delegateCash.checkDelegateForAll(msg.sender, _onBehalfOf) || delegateCash.checkDelegateForContract(msg.sender, _onBehalfOf, _collectionAddress));\r\n        mintInner(msg.sender, _collectionAddress, _onBehalfOf);\r\n    }\r\n\r\n    function mintIndividual() external payable {\r\n        mintInner(msg.sender, address(0x0), msg.sender);\r\n    }\r\n\r\n    function mintToGroup(address _collectionAddress) external payable {\r\n        mintInner(msg.sender, _collectionAddress, msg.sender);\r\n    }\r\n\r\n    function _startTokenId() internal pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    function setBaseURI(string calldata baseURI) external onlyOwner {\r\n        _baseTokenURI = baseURI;\r\n    }\r\n\r\n    function setPlaceholderURI(string calldata placeholderURI) external onlyOwner {\r\n        _placeholderURI = placeholderURI;\r\n    }\r\n\r\n    function setContractURI(string calldata newContractURI) external onlyOwner {\r\n        _contractURI = newContractURI;\r\n    }\r\n\r\n    function setIncludeStatsInURI(bool _stats) external onlyOwner {\r\n        includeStatsInURI = _stats;\r\n    }\r\n\r\n    function contractURI() external view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        require(_exists(tokenId));\r\n\r\n        if (eventStartTime == 0) {\r\n            return _placeholderURI;\r\n        }\r\n\r\n        string memory baseURI = _baseTokenURI;\r\n        string memory infectionStatus = 'H';\r\n        if(this.getIndividualScore(tokenId) < this.currentInfectionProgress()) { infectionStatus = 'Z'; }\r\n        if(includeStatsInURI) {\r\n            uint32 individualLuck = this.getIndividualLuck(tokenId);\r\n            uint32 individualRate = this.getIndividualRate(tokenId,true);\r\n            return bytes(baseURI).length > 0\r\n                ? string(abi.encodePacked(baseURI, infectionStatus, _toString(tokenId), TOKEN_URI_SEPARATOR, _toString(individualRate), TOKEN_URI_SEPARATOR, _toString(individualLuck)))\r\n                : \"\";\r\n        } else {\r\n            return bytes(baseURI).length > 0\r\n                ? string(abi.encodePacked(baseURI, infectionStatus, _toString(tokenId)))\r\n                : \"\";\r\n        }\r\n    }\r\n\r\n    function tokensOfOwner(address owner) external view returns (uint256[] memory) {\r\n        unchecked {\r\n            uint256 tokenIdsIdx;\r\n            uint256 tokenIdsLength = balanceOf(owner);\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\r\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\r\n                if (ownerOf(i) == owner) {\r\n                    uint256 _individualScore = this.getIndividualScore(i);\r\n                    tokenIds[tokenIdsIdx++] = (i<<32)+_individualScore;\r\n                }\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "weth/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IWETH {\r\n    function balanceOf(address src) external view returns (uint);\r\n    function allowance(address src, address guy) external view returns (uint);\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n    function totalSupply() external view returns (uint);\r\n    function approve(address guy, uint wad) external returns (bool);\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\r\n}"
    },
    "delegatecash/IDelegationRegistry.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @title An immutable registry contract to be deployed as a standalone primitive\r\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\r\n * from here and integrate those permissions into their flow\r\n */\r\ninterface IDelegationRegistry {\r\n    /// @notice Delegation type\r\n    enum DelegationType {\r\n        NONE,\r\n        ALL,\r\n        CONTRACT,\r\n        TOKEN\r\n    }\r\n\r\n    /// @notice Info about a single delegation, used for onchain enumeration\r\n    struct DelegationInfo {\r\n        DelegationType type_;\r\n        address vault;\r\n        address delegate;\r\n        address contract_;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    /// @notice Info about a single contract-level delegation\r\n    struct ContractDelegation {\r\n        address contract_;\r\n        address delegate;\r\n    }\r\n\r\n    /// @notice Info about a single token-level delegation\r\n    struct TokenDelegation {\r\n        address contract_;\r\n        uint256 tokenId;\r\n        address delegate;\r\n    }\r\n\r\n    /// @notice Emitted when a user delegates their entire wallet\r\n    event DelegateForAll(address vault, address delegate, bool value);\r\n\r\n    /// @notice Emitted when a user delegates a specific contract\r\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\r\n\r\n    /// @notice Emitted when a user delegates a specific token\r\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\r\n\r\n    /// @notice Emitted when a user revokes all delegations\r\n    event RevokeAllDelegates(address vault);\r\n\r\n    /// @notice Emitted when a user revoes all delegations for a given delegate\r\n    event RevokeDelegate(address vault, address delegate);\r\n\r\n    /**\r\n     * -----------  WRITE -----------\r\n     */\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for all contracts\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForAll(address delegate, bool value) external;\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for a specific contract\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForContract(address delegate, address contract_, bool value) external;\r\n\r\n    /**\r\n     * @notice Allow the delegate to act on your behalf for a specific token\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\r\n     */\r\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\r\n\r\n    /**\r\n     * @notice Revoke all delegates\r\n     */\r\n    function revokeAllDelegates() external;\r\n\r\n    /**\r\n     * @notice Revoke a specific delegate for all their permissions\r\n     * @param delegate The hotwallet to revoke\r\n     */\r\n    function revokeDelegate(address delegate) external;\r\n\r\n    /**\r\n     * @notice Remove yourself as a delegate for a specific vault\r\n     * @param vault The vault which delegated to the msg.sender, and should be removed\r\n     */\r\n    function revokeSelf(address vault) external;\r\n\r\n    /**\r\n     * -----------  READ -----------\r\n     */\r\n\r\n    /**\r\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\r\n     * @param delegate The delegate that you would like to retrieve delegations for\r\n     * @return info Array of DelegationInfo structs\r\n     */\r\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of wallet-level delegates for a given vault\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @return addresses Array of wallet-level delegates for a given vault\r\n     */\r\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of contract-level delegates for a given vault and contract\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @return addresses Array of contract-level delegates for a given vault and contract\r\n     */\r\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns an array of contract-level delegates for a given vault's token\r\n     * @param vault The cold wallet who issued the delegation\r\n     * @param contract_ The address for the contract holding the token\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @return addresses Array of contract-level delegates for a given vault's token\r\n     */\r\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns all contract-level delegations for a given vault\r\n     * @param vault The cold wallet who issued the delegations\r\n     * @return delegations Array of ContractDelegation structs\r\n     */\r\n    function getContractLevelDelegations(address vault)\r\n        external\r\n        view\r\n        returns (ContractDelegation[] memory delegations);\r\n\r\n    /**\r\n     * @notice Returns all token-level delegations for a given vault\r\n     * @param vault The cold wallet who issued the delegations\r\n     * @return delegations Array of TokenDelegation structs\r\n     */\r\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on the entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForContract(address delegate, address vault, address contract_)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\r\n     * @param delegate The hotwallet to act on your behalf\r\n     * @param contract_ The address for the contract you're delegating\r\n     * @param tokenId The token id for the token you're delegating\r\n     * @param vault The cold wallet who issued the delegation\r\n     */\r\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n}"
    },
    "contracts/ERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\nimport './IERC721A.sol';\r\n\r\n/**\r\n * @dev Interface of ERC721 token receiver.\r\n */\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721A\r\n *\r\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\r\n * Non-Fungible Token Standard, including the Metadata extension.\r\n * Optimized for lower gas during batch mints.\r\n *\r\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\r\n * starting from `_startTokenId()`.\r\n *\r\n * Assumptions:\r\n *\r\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\ncontract ERC721A is IERC721A {\r\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\r\n    struct TokenApprovalRef {\r\n        address value;\r\n    }\r\n\r\n    // =============================================================\r\n    //                           CONSTANTS\r\n    // =============================================================\r\n\r\n    // Mask of an entry in packed address data.\r\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n\r\n    // The bit position of `numberMinted` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\r\n\r\n    // The bit position of `numberBurned` in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\r\n\r\n    // The bit position of `aux` in packed address data.\r\n    uint256 private constant _BITPOS_AUX = 192;\r\n\r\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\r\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n\r\n    // The bit position of `startTimestamp` in packed ownership.\r\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\r\n\r\n    // The bit mask of the `burned` bit in packed ownership.\r\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\r\n\r\n    // The bit position of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\r\n\r\n    // The bit mask of the `nextInitialized` bit in packed ownership.\r\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n\r\n    // The bit position of `extraData` in packed ownership.\r\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\r\n\r\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\r\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\r\n\r\n    // The mask of the lower 160 bits for addresses.\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n\r\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\r\n    // This limit is to prevent overflows on the address data entries.\r\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\r\n    // is required to cause an overflow, which is unrealistic.\r\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\r\n\r\n    // The `Transfer` event signature is given by:\r\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    // =============================================================\r\n    //                            STORAGE\r\n    // =============================================================\r\n\r\n    // The next token ID to be minted.\r\n    uint256 private _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 private _burnCounter;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned.\r\n    // See {_packedOwnershipOf} implementation for details.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..159]   `addr`\r\n    // - [160..223] `startTimestamp`\r\n    // - [224]      `burned`\r\n    // - [225]      `nextInitialized`\r\n    // - [232..255] `extraData`\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n\r\n    // Mapping owner address to address data.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..63]    `balance`\r\n    // - [64..127]  `numberMinted`\r\n    // - [128..191] `numberBurned`\r\n    // - [192..255] `aux`\r\n    mapping(address => uint256) private _packedAddressData;\r\n\r\n    // Mapping from token ID to approved address.\r\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // =============================================================\r\n    //                          CONSTRUCTOR\r\n    // =============================================================\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    // =============================================================\r\n    //                   TOKEN COUNTING OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than `_currentIndex - _startTokenId()` times.\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\r\n        // and it is initialized to `_startTokenId()`.\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens burned.\r\n     */\r\n    function _totalBurned() internal view virtual returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    // =============================================================\r\n    //                    ADDRESS DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens minted by `owner`.\r\n     */\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens burned by or on behalf of `owner`.\r\n     */\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     */\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\r\n    }\r\n\r\n    /**\r\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\r\n     * If there are multiple variables, please pack them into a uint64.\r\n     */\r\n    function _setAux(address owner, uint64 aux) internal virtual {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        // Cast `aux` with assembly to avoid redundant masking.\r\n        assembly {\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        // The interface IDs are constants representing the first 4 bytes\r\n        // of the XOR of all function selectors in the interface.\r\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\r\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return '';\r\n    }\r\n\r\n    // =============================================================\r\n    //                     OWNERSHIPS OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around over time.\r\n     */\r\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\r\n     */\r\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\r\n     */\r\n    function _initializeOwnershipAt(uint256 index) internal virtual {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the packed ownership data of `tokenId`.\r\n     */\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & _BITMASK_BURNED == 0) {\r\n                        // Invariant:\r\n                        // There will always be an initialized ownership slot\r\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\r\n                        // before an unintialized ownership slot\r\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\r\n                        // Hence, `curr` will not underflow.\r\n                        //\r\n                        // We can directly compare the packed value.\r\n                        // If the address is zero, packed will be zero.\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\r\n     */\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & _BITMASK_BURNED != 0;\r\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Packs ownership data into a single uint256.\r\n     */\r\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\r\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\r\n     */\r\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\r\n        // For branchless setting of the `nextInitialized` flag.\r\n        assembly {\r\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\r\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      APPROVAL OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) public payable virtual override {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId].value = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId].value;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted. See {_mint}.\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex && // If within bounds,\r\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\r\n     */\r\n    function _isSenderApprovedOrOwner(\r\n        address approvedAddress,\r\n        address owner,\r\n        address msgSender\r\n    ) private pure returns (bool result) {\r\n        assembly {\r\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\r\n            // `msgSender == owner || msgSender == approvedAddress`.\r\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\r\n     */\r\n    function _getApprovedSlotAndAddress(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256 approvedAddressSlot, address approvedAddress)\r\n    {\r\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\r\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\r\n        assembly {\r\n            approvedAddressSlot := tokenApproval.slot\r\n            approvedAddress := sload(approvedAddressSlot)\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      TRANSFER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        // The nested ifs save around 20+ gas over a compound boolean condition.\r\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // We can directly increment and decrement the balances.\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            // Updates:\r\n            // - `address` to the next owner.\r\n            // - `startTimestamp` to the timestamp of transfering.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public payable virtual override {\r\n        transferFrom(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token IDs\r\n     * are about to be transferred. This includes minting.\r\n     * And also called before burning one token.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token IDs\r\n     * have been transferred. This includes minting.\r\n     * And also called after one token has been burned.\r\n     *\r\n     * `startTokenId` - the first token ID to be transferred.\r\n     * `quantity` - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` has been minted for `to`.\r\n     * - When `to` is zero, `tokenId` has been burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\r\n     *\r\n     * `from` - Previous owner of the given token ID.\r\n     * `to` - Target address that will receive the token.\r\n     * `tokenId` - Token ID to be transferred.\r\n     * `_data` - Optional data to send along with the call.\r\n     *\r\n     * Returns whether the call correctly returned the expected magic value.\r\n     */\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                        MINT OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _mint(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\r\n        // `tokenId` has a maximum limit of 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            uint256 toMasked;\r\n            uint256 end = startTokenId + quantity;\r\n\r\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\r\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\r\n            // The assembly, together with the surrounding Solidity code, have been\r\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\r\n            assembly {\r\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n                toMasked := and(to, _BITMASK_ADDRESS)\r\n                // Emit the `Transfer` event.\r\n                log4(\r\n                    0, // Start of data (0, since no data).\r\n                    0, // End of data (0, since no data).\r\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                    0, // `address(0)`.\r\n                    toMasked, // `to`.\r\n                    startTokenId // `tokenId`.\r\n                )\r\n\r\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\r\n                // that overflows uint256 will make the loop run out of gas.\r\n                // The compiler will optimize the `iszero` away for performance.\r\n                for {\r\n                    let tokenId := add(startTokenId, 1)\r\n                } iszero(eq(tokenId, end)) {\r\n                    tokenId := add(tokenId, 1)\r\n                } {\r\n                    // Emit the `Transfer` event. Similar to above.\r\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\r\n                }\r\n            }\r\n            if (toMasked == 0) revert MintToZeroAddress();\r\n\r\n            _currentIndex = end;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * This function is intended for efficient minting only during contract creation.\r\n     *\r\n     * It emits only one {ConsecutiveTransfer} as defined in\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\r\n     * instead of a sequence of {Transfer} event(s).\r\n     *\r\n     * Calling this function outside of contract creation WILL make your contract\r\n     * non-compliant with the ERC721 standard.\r\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\r\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * Emits a {ConsecutiveTransfer} event.\r\n     */\r\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance += quantity`.\r\n            // - `numberMinted += quantity`.\r\n            //\r\n            // We can directly add to the `balance` and `numberMinted`.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - `address` to the owner.\r\n            // - `startTimestamp` to the timestamp of minting.\r\n            // - `burned` to `false`.\r\n            // - `nextInitialized` to `quantity == 1`.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\r\n\r\n            _currentIndex = startTokenId + quantity;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - `quantity` must be greater than 0.\r\n     *\r\n     * See {_mint}.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, quantity);\r\n\r\n        unchecked {\r\n            if (to.code.length != 0) {\r\n                uint256 end = _currentIndex;\r\n                uint256 index = end - quantity;\r\n                do {\r\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (index < end);\r\n                // Reentrancy protection.\r\n                if (_currentIndex != end) revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\r\n     */\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    // =============================================================\r\n    //                        BURN OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Equivalent to `_burn(tokenId, false)`.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (approvalCheck) {\r\n            // The nested ifs save around 20+ gas over a compound boolean condition.\r\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - `balance -= 1`.\r\n            // - `numberBurned += 1`.\r\n            //\r\n            // We can directly decrement the balance, and increment the number burned.\r\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\r\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            // Updates:\r\n            // - `address` to the last owner.\r\n            // - `startTimestamp` to the timestamp of burning.\r\n            // - `burned` to `true`.\r\n            // - `nextInitialized` to `true`.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                from,\r\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                     EXTRA DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Directly sets the extra data for the ownership data `index`.\r\n     */\r\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\r\n        uint256 packed = _packedOwnerships[index];\r\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\r\n        uint256 extraDataCasted;\r\n        // Cast `extraData` with assembly to avoid redundant masking.\r\n        assembly {\r\n            extraDataCasted := extraData\r\n        }\r\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\r\n        _packedOwnerships[index] = packed;\r\n    }\r\n\r\n    /**\r\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\r\n     * Intended to be overridden by the cosumer contract.\r\n     *\r\n     * `previousExtraData` - the value of `extraData` before transfer.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, `tokenId` will be burned by `from`.\r\n     * - `from` and `to` are never both zero.\r\n     */\r\n    function _extraData(\r\n        address from,\r\n        address to,\r\n        uint24 previousExtraData\r\n    ) internal view virtual returns (uint24) {}\r\n\r\n    /**\r\n     * @dev Returns the next extra data for the packed ownership data.\r\n     * The returned result is shifted into position.\r\n     */\r\n    function _nextExtraData(\r\n        address from,\r\n        address to,\r\n        uint256 prevOwnershipPacked\r\n    ) private view returns (uint256) {\r\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\r\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\r\n    }\r\n\r\n    // =============================================================\r\n    //                       OTHER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the message sender (defaults to `msg.sender`).\r\n     *\r\n     * If you are writing GSN compatible contracts, you need to override this function.\r\n     */\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a uint256 to its ASCII string decimal representation.\r\n     */\r\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\r\n            let m := add(mload(0x40), 0xa0)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, m)\r\n            // Assign the `str` to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n}"
    },
    "contracts/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface of ERC721A.\r\n */\r\ninterface IERC721A {\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    /**\r\n     * Cannot query the balance for the zero address.\r\n     */\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /**\r\n     * Cannot mint to the zero address.\r\n     */\r\n    error MintToZeroAddress();\r\n\r\n    /**\r\n     * The quantity of tokens minted must be more than zero.\r\n     */\r\n    error MintZeroQuantity();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token must be owned by `from`.\r\n     */\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /**\r\n     * Cannot safely transfer to a contract that does not implement the\r\n     * ERC721Receiver interface.\r\n     */\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /**\r\n     * Cannot transfer to the zero address.\r\n     */\r\n    error TransferToZeroAddress();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error URIQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\r\n     */\r\n    error MintERC2309QuantityExceedsLimit();\r\n\r\n    /**\r\n     * The `extraData` cannot be set on an unintialized ownership slot.\r\n     */\r\n    error OwnershipNotInitializedForExtraData();\r\n\r\n    // =============================================================\r\n    //                            STRUCTS\r\n    // =============================================================\r\n\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Stores the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\r\n        uint24 extraData;\r\n    }\r\n\r\n    // =============================================================\r\n    //                         TOKEN COUNTERS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                            IERC721\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables\r\n     * (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\r\n     * checking first that contract recipients are aware of the ERC721 protocol\r\n     * to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move\r\n     * this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\r\n     * whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external payable;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    // =============================================================\r\n    //                           IERC2309\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\r\n     * (inclusive) is transferred from `from` to `to`, as defined in the\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\r\n     *\r\n     * See {_mintERC2309} for more details.\r\n     */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\r\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}