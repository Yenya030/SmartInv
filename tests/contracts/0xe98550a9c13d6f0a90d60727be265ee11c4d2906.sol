{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/FairAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IToken {\n    struct UserAmount {\n        address to;\n        uint96 amount;\n    }\n    function airdrop(UserAmount[] calldata airdropData) external;\n}\n\ncontract FairAuction is Ownable {\n\n    modifier directOnly {\n        require(msg.sender == tx.origin);\n        _;\n    }\n\n    struct BidData {\n        uint240 currentBid;\n        bool mintClaimed;\n        bool refundClaimed;\n    }\n\n    mapping(address => BidData) public userToBidData;\n\n    // Auction settings\n    bool public auctionOpen;\n    uint256 public auctionSupply;\n    uint256 public finalPrice;\n\n    // Starting bid settings\n    uint256 public baseBid;\n    uint256 public startingBidMultiplier;\n    uint256 public minBalanceToIncrement;\n\n    // Secondary address\n    address public secondaryAddress;\n    uint256 public secondaryPercentage;\n\n    // Token contract address\n    IToken public token;\n\n    event Bid(address indexed user, uint256 bidAmount, uint256 currentBid, uint256 totalBid);\n    event AuctionClaimAndRefund(address indexed user, uint256 mint, uint256 refund);\n    event AuctionClaim(address indexed user, uint256 mint);\n    event AuctionRefund(address indexed user, uint256 refund);\n    \n    constructor() { \n        auctionSupply = 2888;\n        baseBid = 0.04 ether;\n        startingBidMultiplier = 0.01 ether;\n        minBalanceToIncrement = 30 ether;\n    }\n\n    function bid() external payable directOnly {\n        require(auctionOpen, \"Auction is not live\");\n\n        // Bid must have value and be multiplier of 0.01 ETH\n        require(msg.value > 0 && msg.value % 0.01 ether == 0, \"Bid is not multiplier of 0.01 ETH\");\n\n        // First time bidder must bid higher than starting bid \n        if (userToBidData[msg.sender].currentBid == 0) {\n            require (msg.value >= getStartingBid(), \"Bid is lower than starting bid\");\n        }\n        \n        // Update existing bid\n        emit Bid(msg.sender, msg.value, userToBidData[msg.sender].currentBid += uint240(msg.value), address(this).balance);\n    }\n\n    // Owner functions\n    \n\n    function setAuctionOpen(bool _status) external onlyOwner {\n        auctionOpen = _status;\n    }\n\n    function setAuctionSupply(uint256 _supply) external onlyOwner {\n        auctionSupply = _supply;\n    }\n\n    function setFinalPrice(uint256 _price) external onlyOwner {\n        finalPrice = _price;\n    }\n\n    function setBaseBid(uint256 _value) external onlyOwner {\n        baseBid = _value;\n    }\n\n    function setMinBalanceToIncrement(uint256 _value) external onlyOwner {\n        minBalanceToIncrement = _value;\n    }\n\n    function setStartingBidMultiplier(uint256 _value) external onlyOwner {\n        startingBidMultiplier = _value;\n    }\n\n\n    function setTokenAddress(address _address) external onlyOwner {\n        token = IToken(_address);\n    }\n\n    function setSecondaryAddress(address _address) external onlyOwner {\n        secondaryAddress = _address;\n    }\n\n    function setSecondaryPercentage(uint256 _percentage) external onlyOwner {\n        secondaryPercentage = _percentage;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        require(secondaryAddress != address(0), \"Secondary address is not set\");\n        require(secondaryPercentage > 0, \"Secondary percentage is not set\");\n        _sendETH(msg.sender, (100 - secondaryPercentage) * amount / 100);\n        _sendETH(secondaryAddress, (secondaryPercentage) * amount / 100);\n    }\n\n    function deposit() external onlyOwner payable { }\n\n    function adminProcessAuctionClaimAndRefund(address[] calldata users) external onlyOwner {\n        unchecked {\n            require(!auctionOpen, \"Auction is still live\");\n            require(address(token) != address(0), \"Token address is not set\");\n            require(finalPrice > 0, \"Final price is not set\");\n            uint256 len = users.length;\n            for (uint256 i = 0; i < len; ++i) {\n                address userAddress = users[i];\n                // Fetch amount of mint and refund\n                uint256 amountToMint = getAmountToMint(userAddress);\n                uint256 amountToRefund = getAmountToRefund(userAddress);\n                require (amountToMint > 0 || amountToRefund > 0, \"User doesn't have any mint or refund\");\n\n                // Set user mint and refund to true\n                BidData memory bidData = userToBidData[userAddress];\n                bidData.mintClaimed = true;\n                bidData.refundClaimed = true;\n                userToBidData[userAddress] = bidData;\n\n                // Process\n                if (amountToMint > 0) {\n                    IToken.UserAmount[] memory airdropData = new IToken.UserAmount[](1);\n                    airdropData[0] = IToken.UserAmount(userAddress, uint96(amountToMint));\n                    token.airdrop(airdropData);\n                }\n                _sendETH(userAddress, amountToRefund);\n\n                emit AuctionClaimAndRefund(userAddress, amountToMint, amountToRefund);\n            }\n        }\n    }\n\n    function adminProcessAuctionClaim(address[] calldata users) external onlyOwner {\n        unchecked {\n            require(!auctionOpen, \"Auction is still live\");\n            require(address(token) != address(0), \"Token address is not set\");\n            require(finalPrice > 0, \"Final price is not set\");\n            uint256 len = users.length;\n            for (uint256 i = 0; i < len; ++i) {\n                address userAddress = users[i];\n                // Fetch amount of mint\n                uint256 amountToMint = getAmountToMint(userAddress);\n\n                // Set user mint to true\n                BidData memory bidData = userToBidData[userAddress];\n                bidData.mintClaimed = true;\n                userToBidData[userAddress] = bidData;\n\n                // Process\n                if (amountToMint > 0) {\n                    IToken.UserAmount[] memory airdropData = new IToken.UserAmount[](1);\n                    airdropData[0] = IToken.UserAmount(userAddress, uint96(amountToMint));\n                    token.airdrop(airdropData);\n                }\n\n                emit AuctionClaim(userAddress, amountToMint);\n            }\n        }\n    }\n\n    function adminProcessAuctionRefund(address[] calldata users) external onlyOwner {\n        unchecked {\n            require(!auctionOpen, \"Auction is still live\");\n            require(address(token) != address(0), \"Token address is not set\");\n            require(finalPrice > 0, \"Final price is not set\");\n\n            uint256 len = users.length;\n            for (uint256 i = 0; i < len; ++i) {\n                address userAddress = users[i];\n                // Fetch amount of refund\n                uint256 amountToRefund = getAmountToRefund(userAddress);\n\n                // Set user refund to true\n                BidData memory bidData = userToBidData[userAddress];\n                bidData.refundClaimed = true;\n                userToBidData[userAddress] = bidData;\n\n                // Process\n                _sendETH(userAddress, amountToRefund);\n\n                emit AuctionRefund(userAddress, amountToRefund);\n            }\n        }\n    }\n\n    // View functions\n    function getAmountToMint(address user) public view returns (uint256) {\n        uint256 _finalPrice = finalPrice;\n        require (_finalPrice > 0, \"Final price is not set\");\n        BidData memory bidData = userToBidData[user];\n        return bidData.mintClaimed ? 0 : bidData.currentBid / _finalPrice;\n    }\n\n    function getAmountToRefund(address user) public view returns (uint256) {\n        uint256 _finalPrice = finalPrice;\n        require (_finalPrice > 0, \"Final price is not set\");\n        BidData memory bidData = userToBidData[user];\n        return bidData.refundClaimed ? 0 : bidData.currentBid % _finalPrice;\n    }\n\n    function getStartingBid() public view returns (uint256) {\n        return baseBid + (address(this).balance / minBalanceToIncrement) * startingBidMultiplier;\n    }\n\n    // Internal functions\n    function _sendETH(address _to, uint256 _amount) internal {\n        (bool success, ) = _to.call{ value: _amount }(\"\");\n        require(success, \"Transfer failed\");\n    }    \n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}