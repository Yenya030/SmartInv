{{
  "language": "Solidity",
  "sources": {
    "contracts/MinterestNFT.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./interfaces/IMinterestNFT.sol\";\nimport \"./libraries/ErrorCodes.sol\";\nimport \"./InterconnectorLeaf.sol\";\n\n/**\n * @title MinterestNFT\n * @dev Contract module which provides functionality to mint new ERC1155 tokens\n *      Each token connected with image and metadata. The image and metadata saved\n *      on IPFS and this contract stores the CID of the folder where lying metadata.\n *      Also each token belongs one of the Minterest tiers, and give some emission\n *      boost for Minterest distribution system.\n */\ncontract MinterestNFT is IMinterestNFT, ERC1155, AccessControl, InterconnectorLeaf {\n    using Counters for Counters.Counter;\n    using Strings for string;\n\n    /// @notice The right part is the keccak-256 hash of variable name\n    bytes32 public constant GATEKEEPER = bytes32(0x20162831d2f54c3e11eebafebfeda495d4c52c67b1708251179ec91fb76dd3b2);\n\n    /// Name for Minterst NFT Token\n    string public constant name = \"Minterest NFT\";\n    /// Symbol for Minterst NFT Token\n    string public constant symbol = \"MNFT\";\n\n    /// Address of opensea proxy registry, for opensea integration\n    ProxyRegistry public immutable proxyRegistry;\n    /// @dev ERC1155 id, Indicates a specific token or token type\n    Counters.Counter private idCounter;\n\n    /**\n     * @notice Initialize contract\n     * @param _baseURI Base of URI where stores images\n     * @param _admin The address of the Admin\n     */\n    constructor(\n        string memory _baseURI,\n        ProxyRegistry _proxyRegistry,\n        address _admin\n    ) ERC1155(_baseURI) {\n        require(address(_proxyRegistry) != address(0), ErrorCodes.ZERO_ADDRESS);\n        require(_admin != address(0), ErrorCodes.ZERO_ADDRESS);\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        _grantRole(GATEKEEPER, _admin);\n        proxyRegistry = _proxyRegistry;\n    }\n\n    /*** External user-defined functions ***/\n\n    /// @inheritdoc IMinterestNFT\n    function mint(\n        address account_,\n        uint256 amount_,\n        bytes memory data_,\n        uint256 tier_\n    ) external onlyRole(GATEKEEPER) {\n        idCounter.increment();\n        uint256 id = idCounter.current();\n\n        _mint(account_, id, amount_, data_);\n\n        if (tier_ > 0) {\n            emissionBooster().onMintToken(\n                account_,\n                _asSingletonArray2(id),\n                _asSingletonArray2(amount_),\n                _asSingletonArray2(tier_)\n            );\n        }\n    }\n\n    /// @inheritdoc IMinterestNFT\n    function mintBatch(\n        address account_,\n        uint256[] memory amounts_,\n        bytes memory data_,\n        uint256[] memory tiers_\n    ) external onlyRole(GATEKEEPER) {\n        require(tiers_.length == amounts_.length, ErrorCodes.INPUT_ARRAY_LENGTHS_ARE_NOT_EQUAL);\n\n        uint256[] memory ids = new uint256[](amounts_.length);\n        for (uint256 i = 0; i < amounts_.length; i++) {\n            idCounter.increment();\n            uint256 id = idCounter.current();\n\n            ids[i] = id;\n        }\n\n        _mintBatch(account_, ids, amounts_, data_);\n\n        emissionBooster().onMintToken(account_, ids, amounts_, tiers_);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     */\n    function _beforeTokenTransfer(\n        address,\n        address from_,\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory\n    ) internal virtual override {\n        // Ignore mint transfers\n        if (from_ != address(0)) emissionBooster().onTransferToken(from_, to_, ids_, amounts_);\n    }\n\n    /// @inheritdoc IMinterestNFT\n    function safeTransfer(\n        address to_,\n        uint256 id_,\n        uint256 amount_,\n        bytes memory data_\n    ) external {\n        safeTransferFrom(msg.sender, to_, id_, amount_, data_);\n    }\n\n    /// @inheritdoc IMinterestNFT\n    function safeBatchTransfer(\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory data_\n    ) external {\n        safeBatchTransferFrom(msg.sender, to_, ids_, amounts_, data_);\n    }\n\n    /*** Admin Functions ***/\n\n    /// @inheritdoc IMinterestNFT\n    function setURI(string memory newBaseUri) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setURI(newBaseUri);\n        emit NewBaseUri(newBaseUri);\n    }\n\n    /*** Helper special functions ***/\n\n    /// @inheritdoc IMinterestNFT\n    function uri(uint256 tokenId_) public view override(ERC1155, IMinterestNFT) returns (string memory) {\n        return\n            _exists(tokenId_)\n                ? string(abi.encodePacked(super.uri(tokenId_), Strings.toString(tokenId_), \".json\"))\n                : super.uri(tokenId_);\n    }\n\n    /// @inheritdoc IMinterestNFT\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        override(ERC1155, IMinterestNFT)\n        returns (bool isOperator)\n    {\n        // Whitelist OpenSea proxy contract for easy trading.\n        if (proxyRegistry.proxies(_owner) == _operator) {\n            return true;\n        }\n\n        return ERC1155.isApprovedForAll(_owner, _operator);\n    }\n\n    /// @inheritdoc IMinterestNFT\n    function nextIdToBeMinted() external view returns (uint256) {\n        return idCounter.current() + 1;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(AccessControl, ERC1155, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC1155).interfaceId;\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param _id uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 _id) private view returns (bool) {\n        return _id > 0 && _id <= idCounter.current();\n    }\n\n    function _asSingletonArray2(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n        return array;\n    }\n\n    function emissionBooster() internal view returns (IEmissionBooster) {\n        return getInterconnector().emissionBooster();\n    }\n}\n"
    },
    "contracts/InterconnectorLeaf.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./libraries/ProtocolLinkage.sol\";\nimport \"./interfaces/IInterconnectorLeaf.sol\";\n\nabstract contract InterconnectorLeaf is IInterconnectorLeaf, LinkageLeaf {\n    function getInterconnector() public view returns (IInterconnector) {\n        return IInterconnector(getLinkageRootAddress());\n    }\n}\n"
    },
    "contracts/interfaces/IMinterestNFT.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface ProxyRegistry {\n    function proxies(address) external view returns (address);\n}\n\n/**\n * @title MinterestNFT\n * @dev Contract module which provides functionality to mint new ERC1155 tokens\n *      Each token connected with image and metadata. The image and metadata saved\n *      on IPFS and this contract stores the CID of the folder where lying metadata.\n *      Also each token belongs one of the Minterest tiers, and give some emission\n *      boost for Minterest distribution system.\n */\ninterface IMinterestNFT is IAccessControl, IERC1155, ILinkageLeaf {\n    /**\n     * @notice Emitted when new base URI was installed\n     */\n    event NewBaseUri(string newBaseUri);\n\n    /**\n     * @notice get name for Minterst NFT Token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice get symbool for Minterst NFT Token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice get address of opensea proxy registry\n     */\n    function proxyRegistry() external view returns (ProxyRegistry);\n\n    /**\n     * @notice get keccak-256 hash of GATEKEEPER role\n     */\n    function GATEKEEPER() external view returns (bytes32);\n\n    /**\n     * @notice Mint new 1155 standard token\n     * @param account_ The address of the owner of minterestNFT\n     * @param amount_ Instance count for minterestNFT\n     * @param data_ The _data argument MAY be re-purposed for the new context.\n     * @param tier_ tier\n     */\n    function mint(\n        address account_,\n        uint256 amount_,\n        bytes memory data_,\n        uint256 tier_\n    ) external;\n\n    /**\n     * @notice Mint new ERC1155 standard tokens in one transaction\n     * @param account_ The address of the owner of tokens\n     * @param amounts_ Array of instance counts for tokens\n     * @param data_ The _data argument MAY be re-purposed for the new context.\n     * @param tiers_ Array of tiers\n     * @dev RESTRICTION: Gatekeeper only\n     */\n    function mintBatch(\n        address account_,\n        uint256[] memory amounts_,\n        bytes memory data_,\n        uint256[] memory tiers_\n    ) external;\n\n    /**\n     * @notice Transfer token to another account\n     * @param to_ The address of the token receiver\n     * @param id_ token id\n     * @param amount_ Count of tokens\n     * @param data_ The _data argument MAY be re-purposed for the new context.\n     */\n    function safeTransfer(\n        address to_,\n        uint256 id_,\n        uint256 amount_,\n        bytes memory data_\n    ) external;\n\n    /**\n     * @notice Transfer tokens to another account\n     * @param to_ The address of the tokens receiver\n     * @param ids_ Array of token ids\n     * @param amounts_ Array of tokens count\n     * @param data_ The _data argument MAY be re-purposed for the new context.\n     */\n    function safeBatchTransfer(\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory data_\n    ) external;\n\n    /**\n     * @notice Set new base URI\n     * @param newBaseUri Base URI\n     * @dev RESTRICTION: Admin only\n     */\n    function setURI(string memory newBaseUri) external;\n\n    /**\n     * @notice Override function to return image URL, opensea requirement\n     * @param tokenId_ Id of token to get URL\n     * @return IPFS URI for token id, opensea requirement\n     */\n    function uri(uint256 tokenId_) external view returns (string memory);\n\n    /**\n     * @notice Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\n     * @param _owner Owner of tokens\n     * @param _operator Address to check if the `operator` is the operator for `owner` tokens\n     * @return isOperator return true if `operator` is the operator for `owner` tokens otherwise true     *\n     */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n\n    /**\n     * @dev Returns the next token ID to be minted\n     * @return the next token ID to be minted\n     */\n    function nextIdToBeMinted() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/ErrorCodes.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nlibrary ErrorCodes {\n    // Common\n    string internal constant ADMIN_ONLY = \"E101\";\n    string internal constant UNAUTHORIZED = \"E102\";\n    string internal constant OPERATION_PAUSED = \"E103\";\n    string internal constant WHITELISTED_ONLY = \"E104\";\n    string internal constant ADDRESS_IS_NOT_IN_AML_SYSTEM = \"E105\";\n    string internal constant ADDRESS_IS_BLACKLISTED = \"E106\";\n\n    // Invalid input\n    string internal constant ADMIN_ADDRESS_CANNOT_BE_ZERO = \"E201\";\n    string internal constant INVALID_REDEEM = \"E202\";\n    string internal constant REDEEM_TOO_MUCH = \"E203\";\n    string internal constant MARKET_NOT_LISTED = \"E204\";\n    string internal constant INSUFFICIENT_LIQUIDITY = \"E205\";\n    string internal constant INVALID_SENDER = \"E206\";\n    string internal constant BORROW_CAP_REACHED = \"E207\";\n    string internal constant BALANCE_OWED = \"E208\";\n    string internal constant UNRELIABLE_LIQUIDATOR = \"E209\";\n    string internal constant INVALID_DESTINATION = \"E210\";\n    string internal constant INSUFFICIENT_STAKE = \"E211\";\n    string internal constant INVALID_DURATION = \"E212\";\n    string internal constant INVALID_PERIOD_RATE = \"E213\";\n    string internal constant EB_TIER_LIMIT_REACHED = \"E214\";\n    string internal constant INVALID_DEBT_REDEMPTION_RATE = \"E215\";\n    string internal constant LQ_INVALID_SEIZE_DISTRIBUTION = \"E216\";\n    string internal constant EB_TIER_DOES_NOT_EXIST = \"E217\";\n    string internal constant EB_ZERO_TIER_CANNOT_BE_ENABLED = \"E218\";\n    string internal constant EB_ALREADY_ACTIVATED_TIER = \"E219\";\n    string internal constant EB_END_BLOCK_MUST_BE_LARGER_THAN_CURRENT = \"E220\";\n    string internal constant EB_CANNOT_MINT_TOKEN_FOR_ACTIVATED_TIER = \"E221\";\n    string internal constant EB_EMISSION_BOOST_IS_NOT_IN_RANGE = \"E222\";\n    string internal constant TARGET_ADDRESS_CANNOT_BE_ZERO = \"E223\";\n    string internal constant INSUFFICIENT_TOKEN_IN_VESTING_CONTRACT = \"E224\";\n    string internal constant VESTING_SCHEDULE_ALREADY_EXISTS = \"E225\";\n    string internal constant INSUFFICIENT_TOKENS_TO_CREATE_SCHEDULE = \"E226\";\n    string internal constant NO_VESTING_SCHEDULE = \"E227\";\n    string internal constant SCHEDULE_IS_IRREVOCABLE = \"E228\";\n    string internal constant MNT_AMOUNT_IS_ZERO = \"E230\";\n    string internal constant INCORRECT_AMOUNT = \"E231\";\n    string internal constant MEMBERSHIP_LIMIT = \"E232\";\n    string internal constant MEMBER_NOT_EXIST = \"E233\";\n    string internal constant MEMBER_ALREADY_ADDED = \"E234\";\n    string internal constant MEMBERSHIP_LIMIT_REACHED = \"E235\";\n    string internal constant REPORTED_PRICE_SHOULD_BE_GREATER_THAN_ZERO = \"E236\";\n    string internal constant MTOKEN_ADDRESS_CANNOT_BE_ZERO = \"E237\";\n    string internal constant TOKEN_ADDRESS_CANNOT_BE_ZERO = \"E238\";\n    string internal constant REDEEM_TOKENS_OR_REDEEM_AMOUNT_MUST_BE_ZERO = \"E239\";\n    string internal constant FL_TOKEN_IS_NOT_UNDERLYING = \"E240\";\n    string internal constant FL_AMOUNT_IS_TOO_LARGE = \"E241\";\n    string internal constant FL_CALLBACK_FAILED = \"E242\";\n    string internal constant DD_UNSUPPORTED_TOKEN = \"E243\";\n    string internal constant DD_MARKET_ADDRESS_IS_ZERO = \"E244\";\n    string internal constant DD_ROUTER_ADDRESS_IS_ZERO = \"E245\";\n    string internal constant DD_RECEIVER_ADDRESS_IS_ZERO = \"E246\";\n    string internal constant DD_BOT_ADDRESS_IS_ZERO = \"E247\";\n    string internal constant DD_MARKET_NOT_FOUND = \"E248\";\n    string internal constant DD_RECEIVER_NOT_FOUND = \"E249\";\n    string internal constant DD_BOT_NOT_FOUND = \"E250\";\n    string internal constant DD_ROUTER_ALREADY_SET = \"E251\";\n    string internal constant DD_RECEIVER_ALREADY_SET = \"E252\";\n    string internal constant DD_BOT_ALREADY_SET = \"E253\";\n    string internal constant EB_MARKET_INDEX_IS_LESS_THAN_USER_INDEX = \"E254\";\n    string internal constant LQ_INVALID_DRR_ARRAY = \"E255\";\n    string internal constant LQ_INVALID_SEIZE_ARRAY = \"E256\";\n    string internal constant LQ_INVALID_DEBT_REDEMPTION_RATE = \"E257\";\n    string internal constant LQ_INVALID_SEIZE_INDEX = \"E258\";\n    string internal constant LQ_DUPLICATE_SEIZE_INDEX = \"E259\";\n    string internal constant DD_INVALID_TOKEN_IN_ADDRESS = \"E260\";\n    string internal constant DD_INVALID_TOKEN_OUT_ADDRESS = \"E261\";\n    string internal constant DD_INVALID_TOKEN_IN_AMOUNT = \"E262\";\n    string internal constant DD_LIQUIDATION_ADDRESS_IS_ZERO = \"E263\";\n    string internal constant DD_LIQUIDATION_ALREADY_SET = \"E264\";\n\n    // Protocol errors\n    string internal constant INVALID_PRICE = \"E301\";\n    string internal constant MARKET_NOT_FRESH = \"E302\";\n    string internal constant BORROW_RATE_TOO_HIGH = \"E303\";\n    string internal constant INSUFFICIENT_TOKEN_CASH = \"E304\";\n    string internal constant INSUFFICIENT_TOKENS_FOR_RELEASE = \"E305\";\n    string internal constant INSUFFICIENT_MNT_FOR_GRANT = \"E306\";\n    string internal constant TOKEN_TRANSFER_IN_UNDERFLOW = \"E307\";\n    string internal constant NOT_PARTICIPATING_IN_BUYBACK = \"E308\";\n    string internal constant NOT_ENOUGH_PARTICIPATING_ACCOUNTS = \"E309\";\n    string internal constant NOTHING_TO_DISTRIBUTE = \"E310\";\n    string internal constant ALREADY_PARTICIPATING_IN_BUYBACK = \"E311\";\n    string internal constant MNT_APPROVE_FAILS = \"E312\";\n    string internal constant TOO_EARLY_TO_DRIP = \"E313\";\n    string internal constant BB_UNSTAKE_TOO_EARLY = \"E314\";\n    string internal constant INSUFFICIENT_SHORTFALL = \"E315\";\n    string internal constant HEALTHY_FACTOR_NOT_IN_RANGE = \"E316\";\n    string internal constant BUYBACK_DRIPS_ALREADY_HAPPENED = \"E317\";\n    string internal constant EB_INDEX_SHOULD_BE_GREATER_THAN_INITIAL = \"E318\";\n    string internal constant NO_VESTING_SCHEDULES = \"E319\";\n    string internal constant INSUFFICIENT_UNRELEASED_TOKENS = \"E320\";\n    string internal constant ORACLE_PRICE_EXPIRED = \"E321\";\n    string internal constant TOKEN_NOT_FOUND = \"E322\";\n    string internal constant RECEIVED_PRICE_HAS_INVALID_ROUND = \"E323\";\n    string internal constant FL_PULL_AMOUNT_IS_TOO_LOW = \"E324\";\n    string internal constant INSUFFICIENT_TOTAL_PROTOCOL_INTEREST = \"E325\";\n    string internal constant BB_ACCOUNT_RECENTLY_VOTED = \"E326\";\n    string internal constant DD_SWAP_ROUTER_IS_ZERO = \"E327\";\n    string internal constant DD_SWAP_CALL_FAILS = \"E328\";\n    string internal constant LL_NEW_ROOT_CANNOT_BE_ZERO = \"E329\";\n    string internal constant RH_PAYOUT_FROM_FUTURE = \"E330\";\n    string internal constant RH_ACCRUE_WITHOUT_UNLOCK = \"E331\";\n    string internal constant RH_LERP_DELTA_IS_GREATER_THAN_PERIOD = \"E332\";\n    string internal constant PRECONDITIONS_NOT_MET = \"E333\";\n\n    // Invalid input - Admin functions\n    string internal constant ZERO_EXCHANGE_RATE = \"E401\";\n    string internal constant SECOND_INITIALIZATION = \"E402\";\n    string internal constant MARKET_ALREADY_LISTED = \"E403\";\n    string internal constant IDENTICAL_VALUE = \"E404\";\n    string internal constant ZERO_ADDRESS = \"E405\";\n    string internal constant EC_INVALID_PROVIDER_REPRESENTATIVE = \"E406\";\n    string internal constant EC_PROVIDER_CANT_BE_REPRESENTATIVE = \"E407\";\n    string internal constant OR_ORACLE_ADDRESS_CANNOT_BE_ZERO = \"E408\";\n    string internal constant OR_UNDERLYING_TOKENS_DECIMALS_SHOULD_BE_GREATER_THAN_ZERO = \"E409\";\n    string internal constant OR_REPORTER_MULTIPLIER_SHOULD_BE_GREATER_THAN_ZERO = \"E410\";\n    string internal constant INVALID_TOKEN = \"E411\";\n    string internal constant INVALID_PROTOCOL_INTEREST_FACTOR_MANTISSA = \"E412\";\n    string internal constant INVALID_REDUCE_AMOUNT = \"E413\";\n    string internal constant LIQUIDATION_FEE_MANTISSA_SHOULD_BE_GREATER_THAN_ZERO = \"E414\";\n    string internal constant INVALID_UTILISATION_FACTOR_MANTISSA = \"E415\";\n    string internal constant INVALID_MTOKENS_OR_BORROW_CAPS = \"E416\";\n    string internal constant FL_PARAM_IS_TOO_LARGE = \"E417\";\n    string internal constant MNT_INVALID_NONVOTING_PERIOD = \"E418\";\n    string internal constant INPUT_ARRAY_LENGTHS_ARE_NOT_EQUAL = \"E419\";\n    string internal constant EC_INVALID_BOOSTS = \"E420\";\n    string internal constant EC_ACCOUNT_IS_ALREADY_LIQUIDITY_PROVIDER = \"E421\";\n    string internal constant EC_ACCOUNT_HAS_NO_AGREEMENT = \"E422\";\n    string internal constant OR_TIMESTAMP_THRESHOLD_SHOULD_BE_GREATER_THAN_ZERO = \"E423\";\n    string internal constant OR_UNDERLYING_TOKENS_DECIMALS_TOO_BIG = \"E424\";\n    string internal constant OR_REPORTER_MULTIPLIER_TOO_BIG = \"E425\";\n    string internal constant SHOULD_HAVE_REVOCABLE_SCHEDULE = \"E426\";\n    string internal constant MEMBER_NOT_IN_DELAY_LIST = \"E427\";\n    string internal constant DELAY_LIST_LIMIT = \"E428\";\n    string internal constant NUMBER_IS_NOT_IN_SCALE = \"E429\";\n    string internal constant BB_STRATUM_OF_FIRST_LOYALTY_GROUP_IS_NOT_ZERO = \"E430\";\n    string internal constant INPUT_ARRAY_IS_EMPTY = \"E431\";\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/libraries/ProtocolLinkage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../interfaces/ILinkageLeaf.sol\";\nimport \"../interfaces/ILinkageRoot.sol\";\nimport \"./ErrorCodes.sol\";\n\nabstract contract LinkageRoot is ILinkageRoot {\n    /// @notice Store self address to prevent context changing while delegateCall\n    ILinkageRoot internal immutable _self = this;\n    /// @notice Owner address\n    address public immutable _linkage_owner;\n\n    constructor(address owner_) {\n        require(owner_ != address(0), ErrorCodes.ADMIN_ADDRESS_CANNOT_BE_ZERO);\n        _linkage_owner = owner_;\n    }\n\n    /// @inheritdoc ILinkageRoot\n    function switchLinkageRoot(ILinkageRoot newRoot) external {\n        require(msg.sender == _linkage_owner, ErrorCodes.UNAUTHORIZED);\n\n        emit LinkageRootSwitch(newRoot);\n\n        Address.functionDelegateCall(\n            address(newRoot),\n            abi.encodePacked(LinkageRoot.interconnect.selector),\n            \"LinkageRoot: low-level delegate call failed\"\n        );\n    }\n\n    /// @inheritdoc ILinkageRoot\n    function interconnect() external {\n        emit LinkageRootInterconnected();\n        interconnectInternal();\n    }\n\n    function interconnectInternal() internal virtual;\n}\n\nabstract contract LinkageLeaf is ILinkageLeaf {\n    /// @inheritdoc ILinkageLeaf\n    function switchLinkageRoot(ILinkageRoot newRoot) public {\n        require(address(newRoot) != address(0), ErrorCodes.LL_NEW_ROOT_CANNOT_BE_ZERO);\n\n        StorageSlot.AddressSlot storage slot = getRootSlot();\n        address oldRoot = slot.value;\n        if (oldRoot == address(newRoot)) return;\n\n        require(oldRoot == address(0) || oldRoot == msg.sender, ErrorCodes.UNAUTHORIZED);\n        slot.value = address(newRoot);\n\n        emit LinkageRootSwitched(newRoot, LinkageRoot(oldRoot));\n    }\n\n    /**\n     * @dev Gets current root contract address\n     */\n    function getLinkageRootAddress() internal view returns (address) {\n        return getRootSlot().value;\n    }\n\n    /**\n     * @dev Gets current root contract storage slot\n     */\n    function getRootSlot() private pure returns (StorageSlot.AddressSlot storage) {\n        // keccak256(\"minterest.slot.linkageRoot\")\n        return StorageSlot.getAddressSlot(0xc34f336ef21a27e6cdbefdb1e201a57e5e6cb9d267e34fc3134d22f9decc8bbf);\n    }\n}\n"
    },
    "contracts/interfaces/IInterconnectorLeaf.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./IInterconnector.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IInterconnectorLeaf is ILinkageLeaf {\n    function getInterconnector() external view returns (IInterconnector);\n}\n"
    },
    "contracts/interfaces/ILinkageLeaf.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./ILinkageRoot.sol\";\n\ninterface ILinkageLeaf {\n    /**\n     * @notice Emitted when root contract address is changed\n     */\n    event LinkageRootSwitched(ILinkageRoot newRoot, ILinkageRoot oldRoot);\n\n    /**\n     * @notice Connects new root contract address\n     * @param newRoot New root contract address\n     */\n    function switchLinkageRoot(ILinkageRoot newRoot) external;\n}\n"
    },
    "contracts/interfaces/ILinkageRoot.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\ninterface ILinkageRoot {\n    /**\n     * @notice Emitted when new root contract connected to all leafs\n     */\n    event LinkageRootSwitch(ILinkageRoot newRoot);\n\n    /**\n     * @notice Emitted when root interconnects its contracts\n     */\n    event LinkageRootInterconnected();\n\n    /**\n     * @notice Connects new root to all leafs contracts\n     * @param newRoot New root contract address\n     */\n    function switchLinkageRoot(ILinkageRoot newRoot) external;\n\n    /**\n     * @notice Update root for all leaf contracts\n     * @dev Should include only leaf contracts\n     */\n    function interconnect() external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IInterconnector.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./ISupervisor.sol\";\nimport \"./IRewardsHub.sol\";\nimport \"./IMnt.sol\";\nimport \"./IBuyback.sol\";\nimport \"./IVesting.sol\";\nimport \"./IMinterestNFT.sol\";\nimport \"./IPriceOracle.sol\";\nimport \"./ILiquidation.sol\";\nimport \"./IBDSystem.sol\";\nimport \"./IWeightAggregator.sol\";\nimport \"./IEmissionBooster.sol\";\n\ninterface IInterconnector {\n    function supervisor() external view returns (ISupervisor);\n\n    function buyback() external view returns (IBuyback);\n\n    function emissionBooster() external view returns (IEmissionBooster);\n\n    function bdSystem() external view returns (IBDSystem);\n\n    function rewardsHub() external view returns (IRewardsHub);\n\n    function mnt() external view returns (IMnt);\n\n    function minterestNFT() external view returns (IMinterestNFT);\n\n    function liquidation() external view returns (ILiquidation);\n\n    function oracle() external view returns (IPriceOracle);\n\n    function vesting() external view returns (IVesting);\n\n    function whitelist() external view returns (IWhitelist);\n\n    function weightAggregator() external view returns (IWeightAggregator);\n}\n"
    },
    "contracts/interfaces/ISupervisor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"./IMToken.sol\";\nimport \"./IBuyback.sol\";\nimport \"./IRewardsHub.sol\";\nimport \"./ILinkageLeaf.sol\";\nimport \"./IWhitelist.sol\";\n\n/**\n * @title Minterest Supervisor Contract\n * @author Minterest\n */\ninterface ISupervisor is IAccessControl, ILinkageLeaf {\n    /**\n     * @notice Emitted when an admin supports a market\n     */\n    event MarketListed(IMToken mToken);\n\n    /**\n     * @notice Emitted when an account enable a market\n     */\n    event MarketEnabledAsCollateral(IMToken mToken, address account);\n\n    /**\n     * @notice Emitted when an account disable a market\n     */\n    event MarketDisabledAsCollateral(IMToken mToken, address account);\n\n    /**\n     * @notice Emitted when a utilisation factor is changed by admin\n     */\n    event NewUtilisationFactor(\n        IMToken mToken,\n        uint256 oldUtilisationFactorMantissa,\n        uint256 newUtilisationFactorMantissa\n    );\n\n    /**\n     * @notice Emitted when liquidation fee is changed by admin\n     */\n    event NewLiquidationFee(IMToken marketAddress, uint256 oldLiquidationFee, uint256 newLiquidationFee);\n\n    /**\n     * @notice Emitted when borrow cap for a mToken is changed\n     */\n    event NewBorrowCap(IMToken indexed mToken, uint256 newBorrowCap);\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\"\n     */\n    function accountAssets(address, uint256) external view returns (IMToken);\n\n    /**\n     * @notice Collection of states of supported markets\n     * @dev Types containing (nested) mappings could not be parameters or return of external methods\n     */\n    function markets(IMToken)\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 utilisationFactorMantissa,\n            uint256 liquidationFeeMantissa\n        );\n\n    /**\n     * @notice get A list of all markets\n     */\n    function allMarkets(uint256) external view returns (IMToken);\n\n    /**\n     * @notice get Borrow caps enforced by beforeBorrow for each mToken address.\n     */\n    function borrowCaps(IMToken) external view returns (uint256);\n\n    /**\n     * @notice get keccak-256 hash of gatekeeper role\n     */\n    function GATEKEEPER() external view returns (bytes32);\n\n    /**\n     * @notice get keccak-256 hash of timelock\n     */\n    function TIMELOCK() external view returns (bytes32);\n\n    /**\n     * @notice Returns the assets an account has enabled as collateral\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has enabled as collateral\n     */\n    function getAccountAssets(address account) external view returns (IMToken[] memory);\n\n    /**\n     * @notice Returns whether the given account is enabled as collateral in the given asset\n     * @param account The address of the account to check\n     * @param mToken The mToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n    function checkMembership(address account, IMToken mToken) external view returns (bool);\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation\n     * @param mTokens The list of addresses of the mToken markets to be enabled as collateral\n     */\n    function enableAsCollateral(IMToken[] memory mTokens) external;\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param mTokenAddress The address of the asset to be removed\n     */\n    function disableAsCollateral(IMToken mTokenAddress) external;\n\n    /**\n     * @notice Makes checks if the account should be allowed to lend tokens in the given market\n     * @param mToken The market to verify the lend against\n     * @param lender The account which would get the lent tokens\n     */\n    function beforeLend(IMToken mToken, address lender) external;\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market and triggers emission system\n     * @param mToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of mTokens to exchange for the underlying asset in the market\n     * @param isAmlProcess Do we need to check the AML system or not\n     */\n    function beforeRedeem(\n        IMToken mToken,\n        address redeemer,\n        uint256 redeemTokens,\n        bool isAmlProcess\n    ) external;\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param mToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     */\n    function beforeBorrow(\n        IMToken mToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param mToken The market to verify the repay against\n     * @param borrower The account which would borrowed the asset\n     */\n    function beforeRepayBorrow(IMToken mToken, address borrower) external;\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur (auto liquidation process)\n     * @param mToken Asset which was used as collateral and will be seized\n     * @param liquidator_ The address of liquidator contract\n     * @param borrower The address of the borrower\n     */\n    function beforeAutoLiquidationSeize(\n        IMToken mToken,\n        address liquidator_,\n        address borrower\n    ) external;\n\n    /**\n     * @notice Checks if the sender should be allowed to repay borrow in the given market (auto liquidation process)\n     * @param liquidator_ The address of liquidator contract\n     * @param borrower_ The account which borrowed the asset\n     * @param mToken_ The market to verify the repay against\n     */\n    function beforeAutoLiquidationRepay(\n        address liquidator_,\n        address borrower_,\n        IMToken mToken_\n    ) external;\n\n    /**\n     * @notice Checks if the address is the Liquidation contract\n     * @dev Used in liquidation process\n     * @param liquidator_ Prospective address of the Liquidation contract\n     */\n    function isLiquidator(address liquidator_) external view;\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param mToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of mTokens to transfer\n     */\n    function beforeTransfer(\n        IMToken mToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external;\n\n    /**\n     * @notice Makes checks before flash loan in MToken\n     * @param mToken The address of the token\n     * receiver - The address of the loan receiver\n     * amount - How much tokens to flash loan\n     * fee - Flash loan fee\n     */\n    function beforeFlashLoan(\n        IMToken mToken,\n        address, /* receiver */\n        uint256, /* amount */\n        uint256 /* fee */\n    ) external view;\n\n    /**\n     * @notice Calculate account liquidity in USD related to utilisation factors of underlying assets\n     * @return (USD value above total utilisation requirements of all assets,\n     *           USD value below total utilisation requirements of all assets)\n     */\n    function getAccountLiquidity(address account) external view returns (uint256, uint256);\n\n    /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param mTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n    function getHypotheticalAccountLiquidity(\n        address account,\n        IMToken mTokenModify,\n        uint256 redeemTokens,\n        uint256 borrowAmount\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice Get liquidationFeeMantissa and utilisationFactorMantissa for market\n     * @param market Market for which values are obtained\n     * @return (liquidationFeeMantissa, utilisationFactorMantissa)\n     */\n    function getMarketData(IMToken market) external view returns (uint256, uint256);\n\n    /**\n     * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n    function redeemVerify(uint256 redeemAmount, uint256 redeemTokens) external view;\n\n    /**\n     * @notice Sets the utilisationFactor for a market\n     * @dev Governance function to set per-market utilisationFactor\n     * @param mToken The market to set the factor on\n     * @param newUtilisationFactorMantissa The new utilisation factor, scaled by 1e18\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setUtilisationFactor(IMToken mToken, uint256 newUtilisationFactorMantissa) external;\n\n    /**\n     * @notice Sets the liquidationFee for a market\n     * @dev Governance function to set per-market liquidationFee\n     * @param mToken The market to set the fee on\n     * @param newLiquidationFeeMantissa The new liquidation fee, scaled by 1e18\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setLiquidationFee(IMToken mToken, uint256 newLiquidationFeeMantissa) external;\n\n    /**\n     * @notice Add the market to the markets mapping and set it as listed, also initialize MNT market state.\n     * @dev Admin function to set isListed and add support for the market\n     * @param mToken The address of the market (token) to list\n     * @dev RESTRICTION: Admin only.\n     */\n    function supportMarket(IMToken mToken) external;\n\n    /**\n     * @notice Set the given borrow caps for the given mToken markets.\n     *         Borrowing that brings total borrows to or above borrow cap will revert.\n     * @dev Admin or gateKeeper function to set the borrow caps.\n     *      A borrow cap of 0 corresponds to unlimited borrowing.\n     * @param mTokens The addresses of the markets (tokens) to change the borrow caps for\n     * @param newBorrowCaps The new borrow cap values in underlying to be set.\n     *                      A value of 0 corresponds to unlimited borrowing.\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function setMarketBorrowCaps(IMToken[] calldata mTokens, uint256[] calldata newBorrowCaps) external;\n\n    /**\n     * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n    function getAllMarkets() external view returns (IMToken[] memory);\n\n    /**\n     * @notice Returns true if market is listed in Supervisor\n     */\n    function isMarketListed(IMToken) external view returns (bool);\n\n    /**\n     * @notice Check that account is not in the black list and protocol operations are available.\n     * @param account The address of the account to check\n     */\n    function isNotBlacklisted(address account) external view returns (bool);\n\n    /**\n     * @notice Check if transfer of MNT is allowed for accounts.\n     * @param from The source account address to check\n     * @param to The destination account address to check\n     */\n    function isMntTransferAllowed(address from, address to) external view returns (bool);\n\n    /**\n     * @notice Returns block number\n     */\n    function getBlockNumber() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRewardsHub.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./IMToken.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IRewardsHub is ILinkageLeaf {\n    event DistributedSupplierMnt(IMToken mToken, address supplier, uint256 mntDelta, uint256 mntSupplyIndex);\n    event DistributedBorrowerMnt(IMToken mToken, address borrower, uint256 mntDelta, uint256 mntBorrowIndex);\n    event EmissionRewardAccrued(address account, uint256 amount);\n    event RepresentativeRewardAccrued(address account, address provider, uint256 amount);\n    event BuybackRewardAccrued(address account, uint256 amount);\n\n    event RewardUnlocked(address account, uint256 amount);\n    event Withdraw(address account, uint256 amount);\n    event MntGranted(address recipient, uint256 amount);\n\n    event MntSupplyEmissionRateUpdated(IMToken mToken, uint256 newSupplyEmissionRate);\n    event MntBorrowEmissionRateUpdated(IMToken mToken, uint256 newBorrowEmissionRate);\n\n    /**\n     * @notice get keccak-256 hash of gatekeeper\n     */\n    function GATEKEEPER() external view returns (bytes32);\n\n    /**\n     * @notice get keccak-256 hash of timelock\n     */\n    function TIMELOCK() external view returns (bytes32);\n\n    /**\n     * @notice Gets the rate at which MNT is distributed to the corresponding supply market (per block)\n     */\n    function mntSupplyEmissionRate(IMToken) external view returns (uint256);\n\n    /**\n     * @notice Gets the rate at which MNT is distributed to the corresponding borrow market (per block)\n     */\n    function mntBorrowEmissionRate(IMToken) external view returns (uint256);\n\n    /**\n     * @notice Gets the MNT market supply state for each market\n     */\n    function mntSupplyState(IMToken) external view returns (uint224 index, uint32 blockN);\n\n    /**\n     * @notice Gets the MNT market borrow state for each market\n     */\n    function mntBorrowState(IMToken) external view returns (uint224 index, uint32 blockN);\n\n    /**\n     * @notice Gets the MNT supply index and block number for each market\n     */\n    function mntSupplierState(IMToken, address) external view returns (uint224 index, uint32 blockN);\n\n    /**\n     * @notice Gets the MNT borrow index and block number for each market\n     */\n    function mntBorrowerState(IMToken, address) external view returns (uint224 index, uint32 blockN);\n\n    /**\n     * @notice Gets summary amount of available and delayed balances of an account.\n     */\n    function totalBalanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice Gets amount of MNT that can be withdrawn from an account at this block.\n     */\n    function availableBalanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice Initializes market in RewardsHub. Should be called once from Supervisor.supportMarket\n     * @dev RESTRICTION: Supervisor only\n     */\n    function initMarket(IMToken mToken) external;\n\n    /**\n     * @notice Accrues MNT to the market by updating the borrow and supply indexes\n     * @dev This method doesn't update MNT index history in Minterest NFT.\n     * @param market The market whose supply and borrow index to update\n     * @return (MNT supply index, MNT borrow index)\n     */\n    function updateAndGetMntIndexes(IMToken market) external returns (uint224, uint224);\n\n    /**\n     * @notice Shorthand function to distribute MNT emissions from supplies of one market.\n     */\n    function distributeSupplierMnt(IMToken mToken, address account) external;\n\n    /**\n     * @notice Shorthand function to distribute MNT emissions from borrows of one market.\n     */\n    function distributeBorrowerMnt(IMToken mToken, address account) external;\n\n    /**\n     * @notice Updates market indexes and distributes tokens (if any) for holder\n     * @dev Updates indexes and distributes only for those markets where the holder have a\n     * non-zero supply or borrow balance.\n     * @param account The address to distribute MNT for\n     */\n    function distributeAllMnt(address account) external;\n\n    /**\n     * @notice Distribute all MNT accrued by the accounts\n     * @param accounts The addresses to distribute MNT for\n     * @param mTokens The list of markets to distribute MNT in\n     * @param borrowers Whether or not to distribute MNT earned by borrowing\n     * @param suppliers Whether or not to distribute MNT earned by supplying\n     */\n    function distributeMnt(\n        address[] memory accounts,\n        IMToken[] memory mTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    /**\n     * @notice Accrues buyback reward\n     * @dev RESTRICTION: Buyback only\n     */\n    function accrueBuybackReward(address account, uint256 amount) external;\n\n    /**\n     * @notice Gets part of delayed rewards that is unlocked and have become available.\n     */\n    function getUnlockableRewards(address account) external view returns (uint256);\n\n    /**\n     * @notice Transfers available part of MNT rewards to the sender.\n     * This will decrease accounts buyback and voting weights.\n     */\n    function withdraw(uint256 amount) external;\n\n    /**\n     * @notice Transfers\n     * @dev RESTRICTION: Admin only\n     */\n    function grant(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Set MNT borrow and supply emission rates for a single market\n     * @param mToken The market whose MNT emission rate to update\n     * @param newMntSupplyEmissionRate New supply MNT emission rate for market\n     * @param newMntBorrowEmissionRate New borrow MNT emission rate for market\n     * @dev RESTRICTION Timelock only\n     */\n    function setMntEmissionRates(\n        IMToken mToken,\n        uint256 newMntSupplyEmissionRate,\n        uint256 newMntBorrowEmissionRate\n    ) external;\n}\n"
    },
    "contracts/interfaces/IMnt.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IMnt is IERC20Upgradeable, IERC165, IAccessControlUpgradeable, ILinkageLeaf {\n    event MaxNonVotingPeriodChanged(uint256 oldPeriod, uint256 newPeriod);\n    event NewGovernor(address governor);\n    event VotesUpdated(address account, uint256 oldVotingWeight, uint256 newVotingWeight);\n    event TotalVotesUpdated(uint256 oldTotalVotes, uint256 newTotalVotes);\n\n    /**\n     * @notice get governor\n     */\n    function governor() external view returns (address);\n\n    /**\n     * @notice returns votingWeight for user\n     */\n    function votingWeight(address) external view returns (uint256);\n\n    /**\n     * @notice get total voting weight\n     */\n    function totalVotingWeight() external view returns (uint256);\n\n    /**\n     * @notice Updates voting power of the account\n     */\n    function updateVotingWeight(address account) external;\n\n    /**\n     * @notice Creates new total voting weight checkpoint\n     * @dev RESTRICTION: Governor only.\n     */\n    function updateTotalWeightCheckpoint() external;\n\n    /**\n     * @notice Checks user activity for the last `maxNonVotingPeriod` blocks\n     * @param account_ The address of the account\n     * @return returns true if the user voted or his delegatee voted for the last maxNonVotingPeriod blocks,\n     * otherwise returns false\n     */\n    function isParticipantActive(address account_) external view returns (bool);\n\n    /**\n     * @notice Updates last voting timestamp of the account\n     * @dev RESTRICTION: Governor only.\n     */\n    function updateVoteTimestamp(address account) external;\n\n    /**\n     * @notice Gets the latest voting timestamp for account.\n     * @dev If the user delegated his votes, then it also checks the timestamp of the last vote of the delegatee\n     * @param account The address of the account\n     * @return latest voting timestamp for account\n     */\n    function lastActivityTimestamp(address account) external view returns (uint256);\n\n    /**\n     * @notice set new governor\n     * @dev RESTRICTION: Admin only.\n     */\n    function setGovernor(address newGovernor) external;\n\n    /**\n     * @notice Sets the maxNonVotingPeriod\n     * @dev Admin function to set maxNonVotingPeriod\n     * @param newPeriod_ The new maxNonVotingPeriod (in sec). Must be greater than 90 days and lower than 2 years.\n     * @dev RESTRICTION: Admin only.\n     */\n    function setMaxNonVotingPeriod(uint256 newPeriod_) external;\n}\n"
    },
    "contracts/interfaces/IBuyback.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IBuyback is IAccessControl, ILinkageLeaf {\n    event Stake(address who, uint256 amount);\n    event Unstake(address who, uint256 amount);\n    event NewBuyback(uint256 amount, uint256 share);\n    event ParticipateBuyback(address who);\n    event LeaveBuyback(address who, uint256 currentStaked);\n    event BuybackWeightChanged(address who, uint256 newWeight, uint256 oldWeight, uint256 newTotalWeight);\n    event LoyaltyParametersChanged(uint256 newCoreFactor, uint32 newCoreResetPenalty);\n    event LoyaltyStrataChanged();\n    event LoyaltyGroupsChanged(uint256 newGroupCount);\n\n    /**\n     * @notice Gets info about account membership in Buyback\n     */\n    function getMemberInfo(address account)\n        external\n        view\n        returns (\n            bool participating,\n            uint256 weight,\n            uint256 lastIndex,\n            uint256 stakeAmount\n        );\n\n    /**\n     * @notice Gets info about accounts loyalty calculation\n     */\n    function getLoyaltyInfo(address account)\n        external\n        view\n        returns (\n            uint32 loyaltyStart,\n            uint256 coreBalance,\n            uint256 lastBalance\n        );\n\n    /**\n     * @notice Gets if an account is participating in Buyback\n     */\n    function isParticipating(address account) external view returns (bool);\n\n    /**\n     * @notice Gets stake of the account\n     */\n    function getStakedAmount(address account) external view returns (uint256);\n\n    /**\n     * @notice Gets buyback weight of an account\n     */\n    function getWeight(address account) external view returns (uint256);\n\n    /**\n     * @notice Gets loyalty factor of an account with given balance.\n     */\n    function getLoyaltyFactorForBalance(address account, uint256 balance) external view returns (uint256);\n\n    /**\n     * @notice Gets total Buyback weight, which is the sum of weights of all accounts.\n     */\n    function getTotalWeight() external view returns (uint256);\n\n    /**\n     * @notice Gets current Buyback index.\n     * Its the accumulated sum of MNTs shares that are given for each weight of an account.\n     */\n    function getBuybackIndex() external view returns (uint256);\n\n    /**\n     * @notice Gets all global loyalty parameters.\n     */\n    function getLoyaltyParameters()\n        external\n        view\n        returns (\n            uint256[24] memory loyaltyStrata,\n            uint256[] memory groupThresholds,\n            uint32[] memory groupStartStrata,\n            uint256 coreFactor,\n            uint32 coreResetPenalty\n        );\n\n    /**\n     * @notice Stakes the specified amount of MNT and transfers them to this contract.\n     * @notice This contract should be approved to transfer MNT from sender account\n     * @param amount The amount of MNT to stake\n     */\n    function stake(uint256 amount) external;\n\n    /**\n     * @notice Unstakes the specified amount of MNT and transfers them back to sender if he participates\n     *         in the Buyback system, otherwise just transfers MNT tokens to the sender.\n     *         would not be greater than staked amount left. If `amount == MaxUint256` unstakes all staked tokens.\n     * @param amount The amount of MNT to unstake\n     */\n    function unstake(uint256 amount) external;\n\n    /**\n     * @notice Claims buyback rewards, updates buyback weight and voting power.\n     * Does nothing if account is not participating. Reverts if operation is paused.\n     * @param account Address to update weights for\n     */\n    function updateBuybackAndVotingWeights(address account) external;\n\n    /**\n     * @notice Claims buyback rewards, updates buyback weight and voting power.\n     * Does nothing if account is not participating or update is paused.\n     * @param account Address to update weights for\n     */\n    function updateBuybackAndVotingWeightsRelaxed(address account) external;\n\n    /**\n     * @notice Does a buyback using the specified amount of MNT from sender's account\n     * @param amount The amount of MNT to take and distribute as buyback\n     * @dev RESTRICTION: Distributor only\n     */\n    function buyback(uint256 amount) external;\n\n    /**\n     * @notice Make account participating in the buyback.\n     */\n    function participate() external;\n\n    /**\n     * @notice Make accounts participate in buyback before its start.\n     * @param accounts Address to make participate in buyback.\n     * @dev RESTRICTION: Admin only\n     */\n    function participateOnBehalf(address[] memory accounts) external;\n\n    /**\n     * @notice Leave buyback participation, claim any MNTs rewarded by the buyback.\n     * Leaving does not withdraw staked MNTs but reduces weight of the account to zero\n     */\n    function leave() external;\n\n    /**\n     * @notice Leave buyback participation on behalf, claim any MNTs rewarded by the buyback and\n     * reduce the weight of account to zero. All staked MNTs remain on the buyback contract and available\n     * for their owner to be claimed\n     * Can only be called if (timestamp > participantLastVoteTimestamp + maxNonVotingPeriod).\n     * @param participant Address to leave for\n     * @dev RESTRICTION: GATEKEEPER only\n     */\n    function leaveOnBehalf(address participant) external;\n\n    /**\n     * @notice Leave buyback participation on behalf, claim any MNTs rewarded by the buyback and\n     * reduce the weight of account to zero. All staked MNTs remain on the buyback contract and available\n     * for their owner to be claimed.\n     * @dev Function to leave sanctioned accounts from Buyback system\n     * Can only be called if the participant is sanctioned by the AML system.\n     * @param participant Address to leave for\n     */\n    function leaveByAmlDecision(address participant) external;\n\n    /**\n     * @notice Changes loyalty core factor and core reset penalty parameters.\n     * @dev RESTRICTION: Admin only\n     */\n    function setLoyaltyParameters(uint256 newCoreFactor, uint32 newCoreResetPenalty) external;\n\n    /**\n     * @notice Sets new loyalty factors for all strata.\n     * @dev RESTRICTION: Admin only\n     */\n    function setLoyaltyStrata(uint256[24] memory newLoyaltyStrata) external;\n\n    /**\n     * @notice Sets new groups and their parameters\n     * @param newGroupThresholds New list of groups and their balance thresholds.\n     * @param newGroupStartStrata Indexes of starting stratum of each group. First index MUST be zero.\n     *        Length of array must be equal to the newGroupThresholds\n     * @dev RESTRICTION: Admin only\n     */\n    function setLoyaltyGroups(uint256[] memory newGroupThresholds, uint32[] memory newGroupStartStrata) external;\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\nimport \"./IMToken.sol\";\n\ninterface IPriceOracle {\n    /**\n     * @notice Get the underlying price of a mToken asset\n     * @param mToken The mToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     *\n     * @dev Price should be scaled to 1e18 for tokens with tokenDecimals = 1e18\n     *      and for 1e30 for tokens with tokenDecimals = 1e6.\n     */\n    function getUnderlyingPrice(IMToken mToken) external view returns (uint256);\n\n    /**\n     * @notice Return price for an asset\n     * @param asset address of token\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     * @dev Price should be scaled to 1e18 for tokens with tokenDecimals = 1e18\n     *      and for 1e30 for tokens with tokenDecimals = 1e6.\n     */\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILiquidation.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./IMToken.sol\";\nimport \"./IDeadDrop.sol\";\nimport \"./ILinkageLeaf.sol\";\nimport \"./IPriceOracle.sol\";\n\n/**\n * This contract provides the liquidation functionality.\n */\ninterface ILiquidation is IAccessControl, ILinkageLeaf {\n    event HealthyFactorLimitChanged(uint256 oldValue, uint256 newValue);\n    event NewDeadDrop(address oldDeadDrop, address newDeadDrop);\n    event NewInsignificantLoanThreshold(uint256 oldValue, uint256 newValue);\n    event ReliableLiquidation(\n        bool isManualLiquidation,\n        bool isDebtHealthy,\n        address liquidator,\n        address borrower,\n        IMToken[] marketAddresses,\n        uint256[] seizeIndexes,\n        uint256[] debtRates\n    );\n    event ProcessingStateUsageChanged(bool newValue);\n\n    /**\n     * @dev Local accountState for avoiding stack-depth limits in calculating liquidation amounts.\n     */\n    struct AccountLiquidationAmounts {\n        uint256 accountTotalSupplyUsd;\n        uint256 accountTotalCollateralUsd;\n        uint256 accountPresumedTotalRepayUsd;\n        uint256 accountTotalBorrowUsd;\n        uint256[] repayAmounts;\n        uint256[] seizeAmounts;\n    }\n\n    /**\n     * @notice GET The maximum allowable value of a healthy factor after liquidation, scaled by 1e18\n     */\n    function healthyFactorLimit() external view returns (uint256);\n\n    /**\n     * @notice GET Maximum sum in USD for internal liquidation. Collateral for loans that are less\n     * than this parameter will be counted as protocol interest, scaled by 1e18\n     */\n    function insignificantLoanThreshold() external view returns (uint256);\n\n    /**\n     * @notice get keccak-256 hash of TRUSTED_LIQUIDATOR role\n     */\n    function TRUSTED_LIQUIDATOR() external view returns (bytes32);\n\n    /**\n     * @notice get keccak-256 hash of MANUAL_LIQUIDATOR role\n     */\n    function MANUAL_LIQUIDATOR() external view returns (bytes32);\n\n    /**\n     * @notice get keccak-256 hash of TIMELOCK role\n     */\n    function TIMELOCK() external view returns (bytes32);\n\n    /**\n     * @notice Liquidate insolvent debt position\n     * @param borrower_ Account which is being liquidated\n     * @param seizeIndexes_ An array with market indexes that will be used as collateral.\n     *        Each element corresponds to the market index in the accountAssets array\n     * @param debtRates_  An array of debt redemption rates for each debt markets (scaled by 1e18).\n     * @dev RESTRICTION: Trusted liquidator only\n     */\n    function liquidateUnsafeLoan(\n        address borrower_,\n        uint256[] memory seizeIndexes_,\n        uint256[] memory debtRates_\n    ) external;\n\n    /**\n     * @notice Accrues interest for all required borrower's markets\n     * @dev Accrue is required if market is used as borrow (debtRate > 0)\n     *      or collateral (seizeIndex arr contains market index)\n     *      The caller must ensure that the lengths of arrays 'accountAssets' and 'debtRates' are the same,\n     *      array 'seizeIndexes' does not contain duplicates and none of the indexes exceeds the value\n     *      (accountAssets.length - 1).\n     * @param accountAssets An array with addresses of markets where the debtor is in\n     * @param seizeIndexes_ An array with market indexes that will be used as collateral\n     *        Each element corresponds to the market index in the accountAssets array\n     * @param debtRates_ An array of debt redemption rates for each debt markets (scaled by 1e18)\n     */\n    function accrue(\n        IMToken[] memory accountAssets,\n        uint256[] memory seizeIndexes_,\n        uint256[] memory debtRates_\n    ) external;\n\n    /**\n     * @notice For each market calculates the liquidation amounts based on borrower's state.\n     * @param account_ The address of the borrower\n     * @param marketAddresses An array with addresses of markets where the debtor is in\n     * @param seizeIndexes_ An array with market indexes that will be used as collateral\n     *        Each element corresponds to the market index in the accountAssets array\n     * @param debtRates_ An array of debt redemption rates for each debt markets (scaled by 1e18)\n     * @return accountState Struct that contains all balance parameters\n     *         All arrays calculated in underlying assets, all total values calculated in USD.\n     *         (the array indexes match each other)\n     */\n    function calculateLiquidationAmounts(\n        address account_,\n        IMToken[] memory marketAddresses,\n        uint256[] memory seizeIndexes_,\n        uint256[] memory debtRates_\n    ) external view returns (AccountLiquidationAmounts memory);\n\n    /**\n     * @notice Sets a new value for healthyFactorLimit\n     * @dev RESTRICTION: Timelock only\n     */\n    function setHealthyFactorLimit(uint256 newValue_) external;\n\n    /**\n     * @notice Sets a new minterest deadDrop\n     * @dev RESTRICTION: Admin only\n     */\n    function setDeadDrop(address newDeadDrop_) external;\n\n    /**\n     * @notice Sets a new insignificantLoanThreshold\n     * @dev RESTRICTION: Timelock only\n     */\n    function setInsignificantLoanThreshold(uint256 newValue_) external;\n\n    /**\n     * @notice Sets a new state for useProcessingState\n     * @dev RESTRICTION: Admin only\n     */\n    function setProcessingStateUsage(bool newValue_) external;\n}\n"
    },
    "contracts/interfaces/IBDSystem.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IBDSystem is IAccessControl, ILinkageLeaf {\n    event AgreementAdded(\n        address indexed liquidityProvider,\n        address indexed representative,\n        uint256 representativeBonus,\n        uint256 liquidityProviderBoost,\n        uint32 startBlock,\n        uint32 endBlock\n    );\n    event AgreementEnded(\n        address indexed liquidityProvider,\n        address indexed representative,\n        uint256 representativeBonus,\n        uint256 liquidityProviderBoost,\n        uint32 endBlock\n    );\n\n    /**\n     * @notice getter function to get liquidity provider agreement\n     */\n    function providerToAgreement(address)\n        external\n        view\n        returns (\n            uint256 liquidityProviderBoost,\n            uint256 representativeBonus,\n            uint32 endBlock,\n            address representative\n        );\n\n    /**\n     * @notice getter function to get counts\n     *         of liquidity providers of the representative\n     */\n    function representativesProviderCounter(address) external view returns (uint256);\n\n    /**\n     * @notice Creates a new agreement between liquidity provider and representative\n     * @dev Admin function to create a new agreement\n     * @param liquidityProvider_ address of the liquidity provider\n     * @param representative_ address of the liquidity provider representative.\n     * @param representativeBonus_ percentage of the emission boost for representative\n     * @param liquidityProviderBoost_ percentage of the boost for liquidity provider\n     * @param endBlock_ The number of the first block when agreement will not be in effect\n     * @dev RESTRICTION: Admin only\n     */\n    function createAgreement(\n        address liquidityProvider_,\n        address representative_,\n        uint256 representativeBonus_,\n        uint256 liquidityProviderBoost_,\n        uint32 endBlock_\n    ) external;\n\n    /**\n     * @notice Removes a agreement between liquidity provider and representative\n     * @dev Admin function to remove a agreement\n     * @param liquidityProvider_ address of the liquidity provider\n     * @param representative_ address of the representative.\n     * @dev RESTRICTION: Admin only\n     */\n    function removeAgreement(address liquidityProvider_, address representative_) external;\n\n    /**\n     * @notice checks if `account_` is liquidity provider.\n     * @dev account_ is liquidity provider if he has agreement.\n     * @param account_ address to check\n     * @return `true` if `account_` is liquidity provider, otherwise returns false\n     */\n    function isAccountLiquidityProvider(address account_) external view returns (bool);\n\n    /**\n     * @notice checks if `account_` is business development representative.\n     * @dev account_ is business development representative if he has liquidity providers.\n     * @param account_ address to check\n     * @return `true` if `account_` is business development representative, otherwise returns false\n     */\n    function isAccountRepresentative(address account_) external view returns (bool);\n\n    /**\n     * @notice checks if agreement is expired\n     * @dev reverts if the `account_` is not a valid liquidity provider\n     * @param account_ address of the liquidity provider\n     * @return `true` if agreement is expired, otherwise returns false\n     */\n    function isAgreementExpired(address account_) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IWeightAggregator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\ninterface IWeightAggregator {\n    /**\n     * @notice Returns MNTs of the account that are used in buyback weight calculation.\n     */\n    function getAccountFunds(address account) external view returns (uint256);\n\n    /**\n     * @notice Returns loyalty factor of the specified account.\n     */\n    function getLoyaltyFactor(address account) external view returns (uint256);\n\n    /**\n     * @notice Returns Buyback weight for the user\n     */\n    function getBuybackWeight(address account) external view returns (uint256);\n\n    /**\n     * @notice Return voting weight for the user\n     */\n    function getVotingWeight(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IBuyback.sol\";\n\n/**\n * @title Vesting contract provides unlocking of tokens on a schedule. It uses the *graded vesting* way,\n * which unlocks a specific amount of balance every period of time, until all balance unlocked.\n *\n * Vesting Schedule.\n *\n * The schedule of a vesting is described by data structure `VestingSchedule`: starting from the start timestamp\n * throughout the duration, the entire amount of totalAmount tokens will be unlocked.\n */\ninterface IVesting is IAccessControl {\n    /**\n     * @notice An event that's emitted when a new vesting schedule for a account is created.\n     */\n    event VestingScheduleAdded(address target, VestingSchedule schedule);\n\n    /**\n     * @notice An event that's emitted when a vesting schedule revoked.\n     */\n    event VestingScheduleRevoked(address target, uint256 unreleased, uint256 locked);\n\n    /**\n     * @notice An event that's emitted when the account Withdrawn the released tokens.\n     */\n    event Withdrawn(address target, uint256 withdrawn);\n\n    /**\n     * @notice Emitted when an account is added to the delay list\n     */\n    event AddedToDelayList(address account);\n\n    /**\n     * @notice Emitted when an account is removed from the delay list\n     */\n    event RemovedFromDelayList(address account);\n\n    /**\n     * @notice The structure is used in the contract constructor for create vesting schedules\n     * during contract deploying.\n     * @param totalAmount the number of tokens to be vested during the vesting duration.\n     * @param target the address that will receive tokens according to schedule parameters.\n     * @param start offset in minutes at which vesting starts. Zero will vesting immediately.\n     * @param duration duration in minutes of the period in which the tokens will vest.\n     * @param revocable whether the vesting is revocable or not.\n     */\n    struct ScheduleData {\n        uint256 totalAmount;\n        address target;\n        uint32 start;\n        uint32 duration;\n        bool revocable;\n    }\n\n    /**\n     * @notice Vesting schedules of an account.\n     * @param totalAmount the number of tokens to be vested during the vesting duration.\n     * @param released the amount of the token released. It means that the account has called withdraw() and received\n     * @param start the timestamp in minutes at which vesting starts. Must not be equal to zero, as it is used to\n     * check for the existence of a vesting schedule.\n     * @param duration duration in minutes of the period in which the tokens will vest.\n     * `released amount` of tokens to his address.\n     * @param revocable whether the vesting is revocable or not.\n     */\n    struct VestingSchedule {\n        uint256 totalAmount;\n        uint256 released;\n        uint32 created;\n        uint32 start;\n        uint32 duration;\n        bool revocable;\n    }\n\n    /// @notice get keccak-256 hash of GATEKEEPER role\n    function GATEKEEPER() external view returns (bytes32);\n\n    /// @notice get keccak-256 hash of TOKEN_PROVIDER role\n    function TOKEN_PROVIDER() external view returns (bytes32);\n\n    /**\n     * @notice get vesting schedule of an account.\n     */\n    function schedules(address)\n        external\n        view\n        returns (\n            uint256 totalAmount,\n            uint256 released,\n            uint32 created,\n            uint32 start,\n            uint32 duration,\n            bool revocable\n        );\n\n    /**\n     * @notice Gets the amount of MNT that was transferred to Vesting contract\n     * and can be transferred to other accounts via vesting process.\n     * Transferring rewards from Vesting via withdraw method will decrease this amount.\n     */\n    function allocation() external view returns (uint256);\n\n    /**\n     * @notice Gets the amount of allocated MNT tokens that are not used in any vesting schedule yet.\n     * Creation of new vesting schedules will decrease this amount.\n     */\n    function freeAllocation() external view returns (uint256);\n\n    /**\n     * @notice get Whether or not the account is in the delay list\n     */\n    function delayList(address) external view returns (bool);\n\n    /**\n     * @notice Withdraw the specified number of tokens. For a successful transaction, the requirement\n     * `amount_ > 0 && amount_ <= unreleased` must be met.\n     * If `amount_ == MaxUint256` withdraw all unreleased tokens.\n     * @param amount_ The number of tokens to withdraw.\n     */\n    function withdraw(uint256 amount_) external;\n\n    /**\n     * @notice Increases vesting schedule allocation and transfers MNT into Vesting.\n     * @dev RESTRICTION: TOKEN_PROVIDER only\n     */\n    function refill(uint256 amount) external;\n\n    /**\n     * @notice Transfers MNT that were added to the contract without calling the refill and are unallocated.\n     * @dev RESTRICTION: Admin only\n     */\n    function sweep(address recipient, uint256 amount) external;\n\n    /**\n     * @notice Allows the admin to create a new vesting schedules.\n     * @param schedulesData an array of vesting schedules that will be created.\n     * @dev RESTRICTION: Admin only.\n     */\n    function createVestingScheduleBatch(ScheduleData[] memory schedulesData) external;\n\n    /**\n     * @notice Allows the admin to revoke the vesting schedule. Tokens already vested\n     * transfer to the account, the rest are returned to the vesting contract.\n     * Accounts that are in delay list have their withdraw blocked so they would not receive anything.\n     * @param target_ the address from which the vesting schedule is revoked.\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function revokeVestingSchedule(address target_) external;\n\n    /**\n     * @notice Calculates the end of the vesting.\n     * @param who_ account address for which the parameter is returned.\n     * @return the end of the vesting.\n     */\n    function endOfVesting(address who_) external view returns (uint256);\n\n    /**\n     * @notice Calculates locked amount for a given `time`.\n     * @param who_ account address for which the parameter is returned.\n     * @return locked amount for a given `time`.\n     */\n    function lockedAmount(address who_) external view returns (uint256);\n\n    /**\n     * @notice Calculates the amount that has already vested.\n     * @param who_ account address for which the parameter is returned.\n     * @return the amount that has already vested.\n     */\n    function vestedAmount(address who_) external view returns (uint256);\n\n    /**\n     * @notice Calculates the amount that has already vested but hasn't been released yet.\n     * @param who_ account address for which the parameter is returned.\n     * @return the amount that has already vested but hasn't been released yet.\n     */\n    function releasableAmount(address who_) external view returns (uint256);\n\n    /**\n     * @notice Gets the amount that has already vested but hasn't been released yet if account\n     *      schedule had no starting delay (cliff).\n     */\n    function getReleasableWithoutCliff(address account) external view returns (uint256);\n\n    /**\n     * @notice Add an account with revocable schedule to the delay list\n     * @param who_ The account that is being added to the delay list\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function addToDelayList(address who_) external;\n\n    /**\n     * @notice Remove an account from the delay list\n     * @param who_ The account that is being removed from the delay list\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function removeFromDelayList(address who_) external;\n}\n"
    },
    "contracts/interfaces/IEmissionBooster.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./ISupervisor.sol\";\nimport \"./IRewardsHub.sol\";\nimport \"./IMToken.sol\";\nimport \"./ILinkageLeaf.sol\";\n\ninterface IEmissionBooster is IAccessControl, ILinkageLeaf {\n    /**\n     * @notice Emitted when new Tier was created\n     */\n    event NewTierCreated(uint256 createdTier, uint32 endBoostBlock, uint256 emissionBoost);\n\n    /**\n     * @notice Emitted when Tier was enabled\n     */\n    event TierEnabled(\n        IMToken market,\n        uint256 enabledTier,\n        uint32 startBoostBlock,\n        uint224 mntSupplyIndex,\n        uint224 mntBorrowIndex\n    );\n\n    /**\n     * @notice Emitted when emission boost mode was enabled\n     */\n    event EmissionBoostEnabled(address caller);\n\n    /**\n     * @notice Emitted when MNT supply index of the tier ending on the market was saved to storage\n     */\n    event SupplyIndexUpdated(address market, uint256 nextTier, uint224 newIndex, uint32 endBlock);\n\n    /**\n     * @notice Emitted when MNT borrow index of the tier ending on the market was saved to storage\n     */\n    event BorrowIndexUpdated(address market, uint256 nextTier, uint224 newIndex, uint32 endBlock);\n\n    /**\n     * @notice get the Tier for each MinterestNFT token\n     */\n    function tokenTier(uint256) external view returns (uint256);\n\n    /**\n     * @notice get a list of all created Tiers\n     */\n    function tiers(uint256)\n        external\n        view\n        returns (\n            uint32,\n            uint32,\n            uint256\n        );\n\n    /**\n     * @notice get status of emission boost mode.\n     */\n    function isEmissionBoostingEnabled() external view returns (bool);\n\n    /**\n     * @notice get Stored markets indexes per block.\n     */\n    function marketSupplyIndexes(IMToken, uint256) external view returns (uint256);\n\n    /**\n     * @notice get Stored markets indexes per block.\n     */\n    function marketBorrowIndexes(IMToken, uint256) external view returns (uint256);\n\n    /**\n     * @notice Mint token hook which is called from MinterestNFT.mint() and sets specific\n     *      settings for this NFT\n     * @param to_ NFT ovner\n     * @param ids_ NFTs IDs\n     * @param amounts_ Amounts of minted NFTs per tier\n     * @param tiers_ NFT tiers\n     * @dev RESTRICTION: MinterestNFT only\n     */\n    function onMintToken(\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        uint256[] memory tiers_\n    ) external;\n\n    /**\n     * @notice Transfer token hook which is called from MinterestNFT.transfer() and sets specific\n     *      settings for this NFT\n     * @param from_ Address of the tokens previous owner. Should not be zero (minter).\n     * @param to_ Address of the tokens new owner.\n     * @param ids_ NFTs IDs\n     * @param amounts_ Amounts of minted NFTs per tier\n     * @dev RESTRICTION: MinterestNFT only\n     */\n    function onTransferToken(\n        address from_,\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_\n    ) external;\n\n    /**\n     * @notice Enables emission boost mode.\n     * @dev Admin function for enabling emission boosts.\n     * @dev RESTRICTION: Whitelist only\n     */\n    function enableEmissionBoosting() external;\n\n    /**\n     * @notice Creates new Tiers for MinterestNFT tokens\n     * @dev Admin function for creating Tiers\n     * @param endBoostBlocks Emission boost end blocks for created Tiers\n     * @param emissionBoosts Emission boosts for created Tiers, scaled by 1e18\n     * Note: The arrays passed to the function must be of the same length and the order of the elements must match\n     *      each other\n     * @dev RESTRICTION: Admin only\n     */\n    function createTiers(uint32[] memory endBoostBlocks, uint256[] memory emissionBoosts) external;\n\n    /**\n     * @notice Enables emission boost in specified Tiers\n     * @param tiersForEnabling Tier for enabling emission boost\n     * @dev RESTRICTION: Admin only\n     */\n    function enableTiers(uint256[] memory tiersForEnabling) external;\n\n    /**\n     * @notice Return the number of created Tiers\n     * @return The number of created Tiers\n     */\n    function getNumberOfTiers() external view returns (uint256);\n\n    /**\n     * @notice Checks if the specified Tier is active\n     * @param tier_ The Tier that is being checked\n     */\n    function isTierActive(uint256 tier_) external view returns (bool);\n\n    /**\n     * @notice Checks if the specified Tier exists\n     * @param tier_ The Tier that is being checked\n     */\n    function tierExists(uint256 tier_) external view returns (bool);\n\n    /**\n     * @param account_ The address of the account\n     * @return Bitmap of all accounts tiers\n     */\n    function getAccountTiersBitmap(address account_) external view returns (uint256);\n\n    /**\n     * @param account_ The address of the account to check if they have any tokens with tier\n     */\n    function isAccountHaveTiers(address account_) external view returns (bool);\n\n    /**\n     * @param account_ Address of the account\n     * @return tier Highest tier number\n     * @return boost Highest boost amount\n     */\n    function getCurrentAccountBoost(address account_) external view returns (uint256 tier, uint256 boost);\n\n    /**\n     * @notice Calculates emission boost for the account.\n     * @param market_ Market for which we are calculating emission boost\n     * @param account_ The address of the account for which we are calculating emission boost\n     * @param userLastIndex_ The account's last updated mntBorrowIndex or mntSupplyIndex\n     * @param userLastBlock_ The block number in which the index for the account was last updated\n     * @param marketIndex_ The market's current mntBorrowIndex or mntSupplyIndex\n     * @param isSupply_ boolean value, if true, then return calculate emission boost for suppliers\n     * @return boostedIndex Boost part of delta index\n     */\n    function calculateEmissionBoost(\n        IMToken market_,\n        address account_,\n        uint256 userLastIndex_,\n        uint256 userLastBlock_,\n        uint256 marketIndex_,\n        bool isSupply_\n    ) external view returns (uint256 boostedIndex);\n\n    /**\n     * @notice Update MNT supply index for market for NFT tiers that are expired but not yet updated.\n     * @dev This function checks if there are tiers to update and process them one by one:\n     *      calculates the MNT supply index depending on the delta index and delta blocks between\n     *      last MNT supply index update and the current state,\n     *      emits SupplyIndexUpdated event and recalculates next tier to update.\n     * @param market Address of the market to update\n     * @param lastUpdatedBlock Last updated block number\n     * @param lastUpdatedIndex Last updated index value\n     * @param currentSupplyIndex Current MNT supply index value\n     * @dev RESTRICTION: RewardsHub only\n     */\n    function updateSupplyIndexesHistory(\n        IMToken market,\n        uint256 lastUpdatedBlock,\n        uint256 lastUpdatedIndex,\n        uint256 currentSupplyIndex\n    ) external;\n\n    /**\n     * @notice Update MNT borrow index for market for NFT tiers that are expired but not yet updated.\n     * @dev This function checks if there are tiers to update and process them one by one:\n     *      calculates the MNT borrow index depending on the delta index and delta blocks between\n     *      last MNT borrow index update and the current state,\n     *      emits BorrowIndexUpdated event and recalculates next tier to update.\n     * @param market Address of the market to update\n     * @param lastUpdatedBlock Last updated block number\n     * @param lastUpdatedIndex Last updated index value\n     * @param currentBorrowIndex Current MNT borrow index value\n     * @dev RESTRICTION: RewardsHub only\n     */\n    function updateBorrowIndexesHistory(\n        IMToken market,\n        uint256 lastUpdatedBlock,\n        uint256 lastUpdatedIndex,\n        uint256 currentBorrowIndex\n    ) external;\n\n    /**\n     * @notice Get Id of NFT tier to update next on provided market MNT index, supply or borrow\n     * @param market Market for which should the next Tier to update be updated\n     * @param isSupply_ Flag that indicates whether MNT supply or borrow market should be updated\n     * @return Id of tier to update\n     */\n    function getNextTierToBeUpdatedIndex(IMToken market, bool isSupply_) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IMToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"./IInterestRateModel.sol\";\n\ninterface IMToken is IAccessControl, IERC20, IERC3156FlashLender, IERC165 {\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows,\n        uint256 totalProtocolInterest\n    );\n\n    /**\n     * @notice Event emitted when tokens are lended\n     */\n    event Lend(address lender, uint256 lendAmount, uint256 lendTokens, uint256 newTotalTokenSupply);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens, uint256 newTotalTokenSupply);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are seized\n     */\n    event Seize(\n        address borrower,\n        address receiver,\n        uint256 seizeTokens,\n        uint256 accountsTokens,\n        uint256 totalSupply,\n        uint256 seizeUnderlyingAmount\n    );\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n\n    /**\n     * @notice Event emitted when a borrow is repaid during autoliquidation\n     */\n    event AutoLiquidationRepayBorrow(\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrowsNew,\n        uint256 totalBorrowsNew,\n        uint256 TotalProtocolInterestNew\n    );\n\n    /**\n     * @notice Event emitted when flash loan is executed\n     */\n    event FlashLoanExecuted(address receiver, uint256 amount, uint256 fee);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(IInterestRateModel oldInterestRateModel, IInterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when the protocol interest factor is changed\n     */\n    event NewProtocolInterestFactor(\n        uint256 oldProtocolInterestFactorMantissa,\n        uint256 newProtocolInterestFactorMantissa\n    );\n\n    /**\n     * @notice Event emitted when the flash loan max share is changed\n     */\n    event NewFlashLoanMaxShare(uint256 oldMaxShare, uint256 newMaxShare);\n\n    /**\n     * @notice Event emitted when the flash loan fee is changed\n     */\n    event NewFlashLoanFee(uint256 oldFee, uint256 newFee);\n\n    /**\n     * @notice Event emitted when the protocol interest are added\n     */\n    event ProtocolInterestAdded(address benefactor, uint256 addAmount, uint256 newTotalProtocolInterest);\n\n    /**\n     * @notice Event emitted when the protocol interest reduced\n     */\n    event ProtocolInterestReduced(address admin, uint256 reduceAmount, uint256 newTotalProtocolInterest);\n\n    /**\n     * @notice Value is the Keccak-256 hash of \"TIMELOCK\"\n     */\n    function TIMELOCK() external view returns (bytes32);\n\n    /**\n     * @notice Underlying asset for this MToken\n     */\n    function underlying() external view returns (IERC20);\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Model which tells what the current interest rate should be\n     */\n    function interestRateModel() external view returns (IInterestRateModel);\n\n    /**\n     * @notice Initial exchange rate used when lending the first MTokens (used when totalTokenSupply = 0)\n     */\n    function initialExchangeRateMantissa() external view returns (uint256);\n\n    /**\n     * @notice Fraction of interest currently set aside for protocol interest\n     */\n    function protocolInterestFactorMantissa() external view returns (uint256);\n\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    function accrualBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    function borrowIndex() external view returns (uint256);\n\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    function totalBorrows() external view returns (uint256);\n\n    /**\n     * @notice Total amount of protocol interest of the underlying held in this market\n     */\n    function totalProtocolInterest() external view returns (uint256);\n\n    /**\n     * @notice Share of market's current underlying token balance that can be used as flash loan (scaled by 1e18).\n     */\n    function maxFlashLoanShare() external view returns (uint256);\n\n    /**\n     * @notice Share of flash loan amount that would be taken as fee (scaled by 1e18).\n     */\n    function flashLoanFeeShare() external view returns (uint256);\n\n    /**\n     * @notice Returns total token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by supervisor to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (token balance, borrow balance, exchange rate mantissa)\n     */\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this mToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this mToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external returns (uint256);\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's\n     *         borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the MToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Get cash balance of this mToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256);\n\n    /**\n     * @notice Applies accrued interest to total borrows and protocol interest\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() external;\n\n    /**\n     * @notice Sender supplies assets into the market and receives mTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param lendAmount The amount of the underlying asset to supply\n     */\n    function lend(uint256 lendAmount) external;\n\n    /**\n     * @notice Sender redeems mTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of mTokens to redeem into underlying\n     */\n    function redeem(uint256 redeemTokens) external;\n\n    /**\n     * @notice Redeems all mTokens for account in exchange for the underlying asset.\n     * Can only be called within the AML system!\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param account An account that is potentially sanctioned by the AML system\n     */\n    function redeemByAmlDecision(address account) external;\n\n    /**\n     * @notice Sender redeems mTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming mTokens\n     */\n    function redeemUnderlying(uint256 redeemAmount) external;\n\n    /**\n     * @notice Sender borrows assets from the protocol to their own address\n     * @param borrowAmount The amount of the underlying asset to borrow\n     */\n    function borrow(uint256 borrowAmount) external;\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrow(uint256 repayAmount) external;\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external;\n\n    /**\n     * @notice Liquidator repays a borrow belonging to borrower\n     * @param borrower_ the account with the debt being payed off\n     * @param repayAmount_ the amount of underlying tokens being returned\n     */\n    function autoLiquidationRepayBorrow(address borrower_, uint256 repayAmount_) external;\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract.\n     *         Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     * @dev RESTRICTION: Admin only.\n     */\n    function sweepToken(IERC20 token, address admin_) external;\n\n    /**\n     * @notice Burns collateral tokens at the borrower's address, transfer underlying assets\n     to the DeadDrop or Liquidator address.\n     * @dev Called only during an auto liquidation process, msg.sender must be the Liquidation contract.\n     * @param borrower_ The account having collateral seized\n     * @param seizeUnderlyingAmount_ The number of underlying assets to seize. The caller must ensure\n     that the parameter is greater than zero.\n     * @param isLoanInsignificant_ Marker for insignificant loan whose collateral must be credited to the\n     protocolInterest\n     * @param receiver_ Address that receives accounts collateral\n     */\n    function autoLiquidationSeize(\n        address borrower_,\n        uint256 seizeUnderlyingAmount_,\n        bool isLoanInsignificant_,\n        address receiver_\n    ) external;\n\n    /**\n     * @notice The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @notice The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @notice Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n\n    /**\n     * @notice accrues interest and sets a new protocol interest factor for the protocol\n     * @dev Admin function to accrue interest and set a new protocol interest factor\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setProtocolInterestFactor(uint256 newProtocolInterestFactorMantissa) external;\n\n    /**\n     * @notice Accrues interest and increase protocol interest by transferring from msg.sender\n     * @param addAmount_ Amount of addition to protocol interest\n     */\n    function addProtocolInterest(uint256 addAmount_) external;\n\n    /**\n     * @notice Can only be called by liquidation contract. Increase protocol interest by transferring from payer.\n     * @dev Calling code should make sure that accrueInterest() was called before.\n     * @param payer_ The address from which the protocol interest will be transferred\n     * @param addAmount_ Amount of addition to protocol interest\n     */\n    function addProtocolInterestBehalf(address payer_, uint256 addAmount_) external;\n\n    /**\n     * @notice Accrues interest and reduces protocol interest by transferring to admin\n     * @param reduceAmount Amount of reduction to protocol interest\n     * @dev RESTRICTION: Admin only.\n     */\n    function reduceProtocolInterest(uint256 reduceAmount, address admin_) external;\n\n    /**\n     * @notice accrues interest and updates the interest rate model using setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setInterestRateModel(IInterestRateModel newInterestRateModel) external;\n\n    /**\n     * @notice Updates share of markets cash that can be used as maximum amount of flash loan.\n     * @param newMax New max amount share\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setFlashLoanMaxShare(uint256 newMax) external;\n\n    /**\n     * @notice Updates fee of flash loan.\n     * @param newFee New fee share of flash loan\n     * @dev RESTRICTION: Timelock only.\n     */\n    function setFlashLoanFeeShare(uint256 newFee) external;\n}\n"
    },
    "contracts/interfaces/IWhitelist.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IWhitelist is IAccessControl {\n    /**\n     * @notice The given member was added to the whitelist\n     */\n    event MemberAdded(address);\n\n    /**\n     * @notice The given member was removed from the whitelist\n     */\n    event MemberRemoved(address);\n\n    /**\n     * @notice Protocol operation mode switched\n     */\n    event WhitelistModeWasTurnedOff();\n\n    /**\n     * @notice Amount of maxMembers changed\n     */\n    event MaxMemberAmountChanged(uint256);\n\n    /**\n     * @notice get maximum number of members.\n     *      When membership reaches this number, no new members may join.\n     */\n    function maxMembers() external view returns (uint256);\n\n    /**\n     * @notice get the total number of members stored in the map.\n     */\n    function memberCount() external view returns (uint256);\n\n    /**\n     * @notice get protocol operation mode.\n     */\n    function whitelistModeEnabled() external view returns (bool);\n\n    /**\n     * @notice get is account member of whitelist\n     */\n    function accountMembership(address) external view returns (bool);\n\n    /**\n     * @notice get keccak-256 hash of GATEKEEPER role\n     */\n    function GATEKEEPER() external view returns (bytes32);\n\n    /**\n     * @notice Add a new member to the whitelist.\n     * @param newAccount The account that is being added to the whitelist.\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function addMember(address newAccount) external;\n\n    /**\n     * @notice Remove a member from the whitelist.\n     * @param accountToRemove The account that is being removed from the whitelist.\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function removeMember(address accountToRemove) external;\n\n    /**\n     * @notice Disables whitelist mode and enables emission boost mode.\n     * @dev RESTRICTION: Admin only.\n     */\n    function turnOffWhitelistMode() external;\n\n    /**\n     * @notice Set a new threshold of participants.\n     * @param newThreshold New number of participants.\n     * @dev RESTRICTION: Gatekeeper only.\n     */\n    function setMaxMembers(uint256 newThreshold) external;\n\n    /**\n     * @notice Check protocol operation mode. In whitelist mode, only members from whitelist and who have\n     *         EmissionBooster can work with protocol.\n     * @param who The address of the account to check for participation.\n     */\n    function isWhitelisted(address who) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title Minterest InterestRateModel Interface\n * @author Minterest\n */\ninterface IInterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param protocolInterest The total amount of protocol interest the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 protocolInterest\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param protocolInterest The total amount of protocol interest the market has\n     * @param protocolInterestFactorMantissa The current protocol interest factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 protocolInterest,\n        uint256 protocolInterestFactorMantissa\n    ) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IDeadDrop.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.17;\n\nimport \"./ILiquidation.sol\";\nimport \"./IMToken.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\ninterface IDeadDrop is IAccessControl {\n    event WithdrewToProtocolInterest(uint256 amount, IERC20 token, IMToken market);\n    event Withdraw(address token, address to, uint256 amount);\n    event NewLiquidation(ILiquidation liquidation);\n    event NewSwapRouter(ISwapRouter router);\n    event NewAllowedWithdrawReceiver(address receiver);\n    event NewAllowedBot(address bot);\n    event NewAllowedMarket(IERC20 token, IMToken market);\n    event AllowedWithdrawReceiverRemoved(address receiver);\n    event AllowedBotRemoved(address bot);\n    event AllowedMarketRemoved(IERC20 token, IMToken market);\n    event Swap(IERC20 tokenIn, IERC20 tokenOut, uint256 spentAmount, uint256 receivedAmount);\n    event NewProcessingState(address target, uint256 hashValue, uint256 oldState, uint256 newState);\n    event LiquidationFinalised(address target, uint256 hashValue);\n\n    /**\n     * @notice get Uniswap SwapRouter\n     */\n    function swapRouter() external view returns (ISwapRouter);\n\n    /**\n     * @notice get Whitelist for markets allowed as a withdrawal destination.\n     */\n    function allowedMarkets(IERC20) external view returns (IMToken);\n\n    /**\n     * @notice get whitelist for users who can be a withdrawal recipients\n     */\n    function allowedWithdrawReceivers(address) external view returns (bool);\n\n    /**\n     * @notice get keccak-256 hash of gatekeeper role\n     */\n    function GATEKEEPER() external view returns (bytes32);\n\n    /**\n     * @notice Perform swap on Uniswap DEX\n     * @param validationKey first part of the key used for onchain validation\n     * @param validationHash second part of the key used for onchain validation\n     * @param requiredState operation code that should precede the current operation\n     * @param targetState operation code that will be assigned after successful swap\n     * @param tokenIn input token\n     * @param tokenInAmount amount of input token\n     * @param tokenOut output token\n     * @param data Uniswap calldata\n     * @dev RESTRICTION: Gatekeeper only\n     */\n    function performSwap(\n        address validationKey,\n        uint256 validationHash,\n        uint256 requiredState,\n        uint256 targetState,\n        IERC20 tokenIn,\n        uint256 tokenInAmount,\n        IERC20 tokenOut,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Withdraw underlying asset to market's protocol interest\n     * @param validationKey first part of the key used for onchain validation\n     * @param validationHash second part of the key used for onchain validation\n     * @param requiredState operation code that should precede the current operation\n     * @param targetState operation code that will be assigned after successful withdrawal\n     * @param amount Amount to withdraw\n     * @param underlying Token to withdraw\n     * @dev RESTRICTION: Gatekeeper only\n     */\n    function withdrawToProtocolInterest(\n        address validationKey,\n        uint256 validationHash,\n        uint256 requiredState,\n        uint256 targetState,\n        uint256 amount,\n        IERC20 underlying\n    ) external;\n\n    /**\n     * @notice Set processing state of started liquidation\n     * @param target Address of the account under liquidation\n     * @param hashValue Liquidation identity hash\n     * @dev RESTRICTION: Liquidator contract only\n     */\n    function initialiseLiquidation(address target, uint256 hashValue) external;\n\n    /**\n     * @notice Update processing state of ongoing liquidation\n     * @param validationKey first part of the key used for onchain validation\n     * @param validationHash second part of the key used for onchain validation\n     * @param targetState New state value of the liquidation\n     * @dev RESTRICTION: Gatekeeper only\n     */\n    function updateProcessingState(\n        address validationKey,\n        uint256 validationHash,\n        uint256 targetState\n    ) external;\n\n    /**\n     * @notice Finalise processing state of ongoing liquidation\n     * @param validationKey first part of the key used for onchain validation\n     * @param validationHash second part of the key used for onchain validation\n     * @param requiredState State value required to complete finalization\n     * @dev RESTRICTION: Gatekeeper only\n     */\n    function finaliseLiquidation(\n        address validationKey,\n        uint256 validationHash,\n        uint256 requiredState\n    ) external;\n\n    /**\n     * @notice Withdraw tokens to the wallet\n     * @param amount Amount to withdraw\n     * @param underlying Token to withdraw\n     * @param to Receipient address\n     * @dev RESTRICTION: Admin only\n     */\n    function withdraw(\n        uint256 amount,\n        IERC20 underlying,\n        address to\n    ) external;\n\n    /**\n     * @notice Add new market to the whitelist\n     * @dev RESTRICTION: Admin only\n     */\n    function addAllowedMarket(IMToken market) external;\n\n    /**\n     * @notice Set new ILiquidation contract\n     * @dev RESTRICTION: Admin only\n     */\n    function setLiquidationAddress(ILiquidation liquidationContract) external;\n\n    /**\n     * @notice Set new ISwapRouter router\n     * @dev RESTRICTION: Admin only\n     */\n    function setRouterAddress(ISwapRouter router) external;\n\n    /**\n     * @notice Add new withdraw receiver address to the whitelist\n     * @dev RESTRICTION: TIMELOCK only\n     */\n    function addAllowedReceiver(address receiver) external;\n\n    /**\n     * @notice Add new bot address to the whitelist\n     * @dev RESTRICTION: Admin only\n     */\n    function addAllowedBot(address bot) external;\n\n    /**\n     * @notice Remove market from the whitelist\n     * @dev RESTRICTION: Admin only\n     */\n    function removeAllowedMarket(IERC20 underlying) external;\n\n    /**\n     * @notice Remove withdraw receiver address from the whitelist\n     * @dev RESTRICTION: TIMELOCK only\n     */\n    function removeAllowedReceiver(address receiver) external;\n\n    /**\n     * @notice Remove withdraw bot address from the whitelist\n     * @dev RESTRICTION: Admin only\n     */\n    function removeAllowedBot(address bot) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}