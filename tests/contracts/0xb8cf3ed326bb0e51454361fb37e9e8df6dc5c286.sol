{{
  "language": "Solidity",
  "sources": {
    "@gearbox-protocol/core-v2/contracts/pool/PoolService.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ACLTrait } from \"../core/ACLTrait.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { RAY } from \"../libraries/Constants.sol\";\nimport { PercentageMath } from \"../libraries/PercentageMath.sol\";\n\nimport { IInterestRateModel } from \"../interfaces/IInterestRateModel.sol\";\nimport { IPoolService } from \"../interfaces/IPoolService.sol\";\nimport { ICreditManagerV2 } from \"../interfaces/ICreditManagerV2.sol\";\n\nimport { AddressProvider } from \"../core/AddressProvider.sol\";\nimport { DieselToken } from \"../tokens/DieselToken.sol\";\nimport { SECONDS_PER_YEAR, MAX_WITHDRAW_FEE } from \"../libraries/Constants.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title Pool Service Interface\n/// @notice Implements business logic:\n///   - Adding/removing pool liquidity\n///   - Managing diesel tokens & diesel rates\n///   - Taking/repaying Credit Manager debt\n///\n/// More: https://dev.gearbox.fi/developers/pools/pool-service\ncontract PoolService is IPoolService, ACLTrait, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using PercentageMath for uint256;\n\n    /// @dev Expected liquidity at last update (LU)\n    uint256 public _expectedLiquidityLU;\n\n    /// @dev The limit on expected (total) liquidity\n    uint256 public override expectedLiquidityLimit;\n\n    /// @dev Total borrowed amount\n    /// @notice https://dev.gearbox.fi/developers/pools/economy/total-borrowed\n    uint256 public override totalBorrowed;\n\n    /// @dev Address provider\n    AddressProvider public override addressProvider;\n\n    /// @dev Interest rate model\n    IInterestRateModel public interestRateModel;\n\n    /// @dev The pool's underlying asset\n    address public override underlyingToken;\n\n    /// @dev Diesel(LP) token address\n    address public immutable override dieselToken;\n\n    /// @dev Map from Credit Manager addresses to the status of their ability to borrow\n    mapping(address => bool) public override creditManagersCanBorrow;\n\n    /// @dev Map from Credit Manager addresses to the status of their ability to repay\n    mapping(address => bool) public creditManagersCanRepay;\n\n    /// @dev The list of all Credit Managers\n    address[] public override creditManagers;\n\n    /// @dev Address of the protocol treasury\n    address public treasuryAddress;\n\n    /// @dev The cumulative interest index at last update\n    uint256 public override _cumulativeIndex_RAY;\n\n    /// @dev The current borrow rate\n    /// @notice https://dev.gearbox.fi/developers/pools/economy#borrow-apy\n    uint256 public override borrowAPY_RAY;\n\n    /// @dev Timestamp of last update\n    uint256 public override _timestampLU;\n\n    /// @dev Withdrawal fee in PERCENTAGE FORMAT\n    uint256 public override withdrawFee;\n\n    /// @dev Contract version\n    uint256 public constant override version = 1;\n\n    //\n    // CONSTRUCTOR\n    //\n\n    /// @dev Constructor\n    /// @param _addressProvider Address provider\n    /// @param _underlyingToken Address of the underlying token\n    /// @param _interestRateModelAddress Address of the initial interest rate model\n    constructor(\n        address _addressProvider,\n        address _underlyingToken,\n        address _interestRateModelAddress,\n        uint256 _expectedLiquidityLimit\n    ) ACLTrait(_addressProvider) {\n        require(\n            _addressProvider != address(0) &&\n                _underlyingToken != address(0) &&\n                _interestRateModelAddress != address(0),\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\n        );\n\n        addressProvider = AddressProvider(_addressProvider);\n\n        underlyingToken = _underlyingToken;\n\n        dieselToken = address(\n            new DieselToken(\n                string(\n                    abi.encodePacked(\n                        \"diesel \",\n                        IERC20Metadata(_underlyingToken).name()\n                    )\n                ),\n                string(\n                    abi.encodePacked(\n                        \"d\",\n                        IERC20Metadata(_underlyingToken).symbol()\n                    )\n                ),\n                IERC20Metadata(_underlyingToken).decimals()\n            )\n        );\n\n        treasuryAddress = addressProvider.getTreasuryContract();\n\n        _timestampLU = block.timestamp;\n        _cumulativeIndex_RAY = RAY; // T:[PS-5]\n        _updateInterestRateModel(_interestRateModelAddress);\n        expectedLiquidityLimit = _expectedLiquidityLimit;\n    }\n\n    //\n    // LIQUIDITY MANAGEMENT\n    //\n\n    /**\n     * @dev Adds liquidity to the pool\n     * - Transfers the underlying asset from sender to the pool\n     * - Mints diesel (LP) token ัะต current diesel rate\n     * - Updates expected liquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#addliquidity\n     *\n     * @param amount Amount of tokens to be deposited\n     * @param onBehalfOf The address that will receive the dToken\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without a facilitator.\n     *\n     * #if_succeeds {:msg \"After addLiquidity() the pool gets the correct amoung of underlyingToken(s)\"}\n     *      IERC20(underlyingToken).balanceOf(address(this)) == old(IERC20(underlyingToken).balanceOf(address(this))) + amount;\n     * #if_succeeds {:msg \"After addLiquidity() onBehalfOf gets the right amount of dieselTokens\"}\n     *      IERC20(dieselToken).balanceOf(onBehalfOf) == old(IERC20(dieselToken).balanceOf(onBehalfOf)) + old(toDiesel(amount));\n     * #if_succeeds {:msg \"After addLiquidity() borrow rate decreases\"}\n     *      amount > 0 ==> borrowAPY_RAY <= old(currentBorrowRate());\n     * #limit {:msg \"Not more than 1 day since last borrow rate update\"} block.timestamp <= _timestampLU + 3600 * 24;\n     */\n    function addLiquidity(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 referralCode\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n    {\n        require(onBehalfOf != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED);\n\n        require(\n            expectedLiquidity() + amount <= expectedLiquidityLimit,\n            Errors.POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT\n        ); // T:[PS-31]\n\n        uint256 balanceBefore = IERC20(underlyingToken).balanceOf(\n            address(this)\n        );\n\n        IERC20(underlyingToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        ); // T:[PS-2, 7]\n\n        amount =\n            IERC20(underlyingToken).balanceOf(address(this)) -\n            balanceBefore; // T:[FT-1]\n\n        DieselToken(dieselToken).mint(onBehalfOf, toDiesel(amount)); // T:[PS-2, 7]\n\n        _expectedLiquidityLU = _expectedLiquidityLU + amount; // T:[PS-2, 7]\n        _updateBorrowRate(0); // T:[PS-2, 7]\n\n        emit AddLiquidity(msg.sender, onBehalfOf, amount, referralCode); // T:[PS-2, 7]\n    }\n\n    /**\n     * @dev Removes liquidity from pool\n     * - Transfers to the sender the underlying amount equivalent to the passed Diesel amount\n     * - Burns Diesel tokens\n     * - Subtracts the removed underlying from expectedLiquidity\n     * - Updates borrow rate\n     *\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#removeliquidity\n     *\n     * @param amount Amount of Diesel tokens to burn\n     * @param to Address to transfer the underlying to\n     *\n     * #if_succeeds {:msg \"For removeLiquidity() sender must have sufficient diesel\"}\n     *      old(DieselToken(dieselToken).balanceOf(msg.sender)) >= amount;\n     * #if_succeeds {:msg \"After removeLiquidity() `to` gets the liquidity in underlyingToken(s)\"}\n     *      (to != address(this) && to != treasuryAddress) ==>\n     *          IERC20(underlyingToken).balanceOf(to) == old(IERC20(underlyingToken).balanceOf(to) + (let t:= fromDiesel(amount) in t.sub(t.percentMul(withdrawFee))));\n     * #if_succeeds {:msg \"After removeLiquidity() treasury gets the withdraw fee in underlyingToken(s)\"}\n     *      (to != address(this) && to != treasuryAddress) ==>\n     *          IERC20(underlyingToken).balanceOf(treasuryAddress) == old(IERC20(underlyingToken).balanceOf(treasuryAddress) + fromDiesel(amount).percentMul(withdrawFee));\n     * #if_succeeds {:msg \"After removeLiquidity() borrow rate increases\"}\n     *      (to != address(this) && amount > 0) ==> borrowAPY_RAY >= old(currentBorrowRate());\n     * #limit {:msg \"Not more than 1 day since last borrow rate update\"} block.timestamp <= _timestampLU + 3600 * 24;\n     */\n    function removeLiquidity(uint256 amount, address to)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n        nonReentrant\n        returns (uint256)\n    {\n        require(to != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED);\n\n        uint256 underlyingTokensAmount = fromDiesel(amount); // T:[PS-3, 8]\n\n        uint256 amountTreasury = underlyingTokensAmount.percentMul(withdrawFee);\n        uint256 amountSent = underlyingTokensAmount - amountTreasury;\n\n        IERC20(underlyingToken).safeTransfer(to, amountSent); // T:[PS-3, 34]\n\n        if (amountTreasury > 0) {\n            IERC20(underlyingToken).safeTransfer(\n                treasuryAddress,\n                amountTreasury\n            );\n        } // T:[PS-3, 34]\n\n        DieselToken(dieselToken).burn(msg.sender, amount); // T:[PS-3, 8]\n\n        _expectedLiquidityLU = _expectedLiquidityLU - underlyingTokensAmount; // T:[PS-3, 8]\n        _updateBorrowRate(0); // T:[PS-3,8 ]\n\n        emit RemoveLiquidity(msg.sender, to, amount); // T:[PS-3, 8]\n\n        return amountSent;\n    }\n\n    /// @dev Returns expected liquidity - the amount of money that should be in the pool\n    /// after all users close their Credit accounts and fully repay debts\n    ///\n    /// More: https://dev.gearbox.fi/developers/pools/economy#expected-liquidity\n    function expectedLiquidity() public view override returns (uint256) {\n        // timeDifference = blockTime - previous timeStamp\n        uint256 timeDifference = block.timestamp - _timestampLU;\n\n        //                                    currentBorrowRate * timeDifference\n        //  interestAccrued = totalBorrow *  ------------------------------------\n        //                                             SECONDS_PER_YEAR\n        //\n        uint256 interestAccrued = (totalBorrowed *\n            borrowAPY_RAY *\n            timeDifference) /\n            RAY /\n            SECONDS_PER_YEAR; // T:[PS-29]\n\n        return _expectedLiquidityLU + interestAccrued; // T:[PS-29]\n    }\n\n    /// @dev Returns available liquidity in the pool (pool balance)\n    /// More: https://dev.gearbox.fi/developers/\n    function availableLiquidity() public view override returns (uint256) {\n        return IERC20(underlyingToken).balanceOf(address(this));\n    }\n\n    //\n    // CREDIT ACCOUNT LENDING\n    //\n\n    /// @dev Lends funds to a Credit Account and updates the pool parameters\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#lendcreditAccount\n    ///\n    /// @param borrowedAmount Credit Account's debt principal\n    /// @param creditAccount Credit Account's address\n    ///\n    /// #if_succeeds {:msg \"After lendCreditAccount() borrow rate increases\"}\n    ///      borrowedAmount > 0 ==> borrowAPY_RAY >= old(currentBorrowRate());\n    /// #limit {:msg \"Not more than 1 day since last borrow rate update\"} block.timestamp <= _timestampLU + 3600 * 24;\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanBorrow[msg.sender],\n            Errors.POOL_CONNECTED_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12, 13]\n\n        // Transfer funds to credit account\n        IERC20(underlyingToken).safeTransfer(creditAccount, borrowedAmount); // T:[PS-14]\n\n        // Update borrow Rate\n        _updateBorrowRate(0); // T:[PS-17]\n\n        // Increase total borrowed amount\n        totalBorrowed = totalBorrowed + borrowedAmount; // T:[PS-16]\n\n        emit Borrow(msg.sender, creditAccount, borrowedAmount); // T:[PS-15]\n    }\n\n    /// @dev Registers Credit Account's debt repayment and updates parameters\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#repaycreditAccount\n    ///\n    /// @param borrowedAmount Amount of principal ro repay\n    /// @param profit The treasury profit from repayment\n    /// @param loss Amount of underlying that the CA wan't able to repay\n    /// @notice Assumes that the underlying (including principal + interest + fees)\n    ///         was already transferred\n    ///\n    /// #if_succeeds {:msg \"Cant have both profit and loss\"} !(profit > 0 && loss > 0);\n    /// #if_succeeds {:msg \"After repayCreditAccount() if we are profitabe, or treasury can cover the losses, diesel rate doesn't decrease\"}\n    ///      (profit > 0 || toDiesel(loss) >= DieselToken(dieselToken).balanceOf(treasuryAddress)) ==> getDieselRate_RAY() >= old(getDieselRate_RAY());\n    /// #limit {:msg \"Not more than 1 day since last borrow rate update\"} block.timestamp <= _timestampLU + 3600 * 24;\n    function repayCreditAccount(\n        uint256 borrowedAmount,\n        uint256 profit,\n        uint256 loss\n    )\n        external\n        override\n        whenNotPaused // T:[PS-4]\n    {\n        require(\n            creditManagersCanRepay[msg.sender],\n            Errors.POOL_CONNECTED_CREDIT_MANAGERS_ONLY\n        ); // T:[PS-12]\n\n        // For fee surplus we mint tokens for treasury\n        if (profit > 0) {\n            // T:[PS-22] provess that diesel rate will be the same within the margin of error\n            DieselToken(dieselToken).mint(treasuryAddress, toDiesel(profit)); // T:[PS-21, 22]\n            _expectedLiquidityLU = _expectedLiquidityLU + profit; // T:[PS-21, 22]\n        }\n        // If returned money < borrowed amount + interest accrued\n        // it tries to compensate loss by burning diesel (LP) tokens\n        // from treasury fund\n        else {\n            uint256 amountToBurn = toDiesel(loss); // T:[PS-19,20]\n\n            uint256 treasuryBalance = DieselToken(dieselToken).balanceOf(\n                treasuryAddress\n            ); // T:[PS-19,20]\n\n            if (treasuryBalance < amountToBurn) {\n                amountToBurn = treasuryBalance;\n                emit UncoveredLoss(\n                    msg.sender,\n                    loss - fromDiesel(treasuryBalance)\n                ); // T:[PS-23]\n            }\n\n            // If treasury has enough funds, it just burns needed amount\n            // to keep diesel rate on the same level\n            DieselToken(dieselToken).burn(treasuryAddress, amountToBurn); // T:[PS-19, 20]\n\n            //            _expectedLiquidityLU = _expectedLiquidityLU.sub(loss); //T:[PS-19,20]\n        }\n\n        // Update available liquidity\n        _updateBorrowRate(loss); // T:[PS-19, 20, 21]\n\n        // Reduce total borrowed. Should be after _updateBorrowRate() for correct calculations\n        totalBorrowed -= borrowedAmount; // T:[PS-19, 20]\n\n        emit Repay(msg.sender, borrowedAmount, profit, loss); // T:[PS-18]\n    }\n\n    //\n    // INTEREST RATE MANAGEMENT\n    //\n\n    /**\n     * @dev Calculates the most current value of the cumulative interest index\n     *\n     *                              /     currentBorrowRate * timeDifference \\\n     *  newIndex  = currentIndex * | 1 + ------------------------------------ |\n     *                              \\              SECONDS_PER_YEAR          /\n     *\n     * @return current cumulative index in RAY\n     */\n    function calcLinearCumulative_RAY() public view override returns (uint256) {\n        //solium-disable-next-line\n        uint256 timeDifference = block.timestamp - _timestampLU; // T:[PS-28]\n\n        return\n            calcLinearIndex_RAY(\n                _cumulativeIndex_RAY,\n                borrowAPY_RAY,\n                timeDifference\n            ); // T:[PS-28]\n    }\n\n    /// @dev Calculates a new cumulative index value from the initial value, borrow rate and time elapsed\n    /// @param cumulativeIndex_RAY Cumulative index at last update, in RAY\n    /// @param currentBorrowRate_RAY Current borrow rate, in RAY\n    /// @param timeDifference Time elapsed since last update, in seconds\n    function calcLinearIndex_RAY(\n        uint256 cumulativeIndex_RAY,\n        uint256 currentBorrowRate_RAY,\n        uint256 timeDifference\n    ) public pure returns (uint256) {\n        //                               /     currentBorrowRate * timeDifference \\\n        //  newIndex  = currentIndex *  | 1 + ------------------------------------ |\n        //                               \\              SECONDS_PER_YEAR          /\n        //\n        uint256 linearAccumulated_RAY = RAY +\n            (currentBorrowRate_RAY * timeDifference) /\n            SECONDS_PER_YEAR; // T:[GM-2]\n\n        return (cumulativeIndex_RAY * linearAccumulated_RAY) / RAY; // T:[GM-2]\n    }\n\n    /// @dev Updates the borrow rate when liquidity parameters are changed\n    /// @param loss The loss incurred by the pool on last parameter update, if any\n    function _updateBorrowRate(uint256 loss) internal {\n        // Update total _expectedLiquidityLU\n\n        _expectedLiquidityLU = expectedLiquidity() - loss; // T:[PS-27]\n\n        // Update cumulativeIndex\n        _cumulativeIndex_RAY = calcLinearCumulative_RAY(); // T:[PS-27]\n\n        // update borrow APY\n        borrowAPY_RAY = interestRateModel.calcBorrowRate(\n            _expectedLiquidityLU,\n            availableLiquidity()\n        ); // T:[PS-27]\n        _timestampLU = block.timestamp; // T:[PS-27]\n    }\n\n    //\n    // DIESEL TOKEN MGMT\n    //\n\n    /// @dev Returns the current exchange rate of Diesel tokens to underlying\n    /// More info: https://dev.gearbox.fi/developers/pools/economy#diesel-rate\n    function getDieselRate_RAY() public view override returns (uint256) {\n        uint256 dieselSupply = IERC20(dieselToken).totalSupply();\n        if (dieselSupply == 0) return RAY; // T:[PS-1]\n        return (expectedLiquidity() * RAY) / dieselSupply; // T:[PS-6]\n    }\n\n    /// @dev Converts a quantity of the underlying to Diesel tokens\n    /// @param amount Amount in underlyingToken tokens to be converted to diesel tokens\n    function toDiesel(uint256 amount) public view override returns (uint256) {\n        return (amount * RAY) / getDieselRate_RAY(); // T:[PS-24]\n    }\n\n    /// @dev Converts a quantity of Diesel tokens to the underlying\n    /// @param amount Amount in diesel tokens to be converted to diesel tokens\n    function fromDiesel(uint256 amount) public view override returns (uint256) {\n        return (amount * getDieselRate_RAY()) / RAY; // T:[PS-24]\n    }\n\n    //\n    // CONFIGURATION\n    //\n\n    /// @dev Connects a new Credit manager to pool\n    /// @param _creditManager Address of the Credit Manager\n    function connectCreditManager(address _creditManager)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        require(\n            address(this) == ICreditManagerV2(_creditManager).poolService(),\n            Errors.POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER\n        ); // T:[PS-10]\n\n        require(\n            !creditManagersCanRepay[_creditManager],\n            Errors.POOL_CANT_ADD_CREDIT_MANAGER_TWICE\n        ); // T:[PS-35]\n\n        creditManagersCanBorrow[_creditManager] = true; // T:[PS-11]\n        creditManagersCanRepay[_creditManager] = true; // T:[PS-11]\n        creditManagers.push(_creditManager); // T:[PS-11]\n        emit NewCreditManagerConnected(_creditManager); // T:[PS-11]\n    }\n\n    /// @dev Forbids a Credit Manager to borrow\n    /// @param _creditManager Address of the Credit Manager\n    function forbidCreditManagerToBorrow(address _creditManager)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        creditManagersCanBorrow[_creditManager] = false; // T:[PS-13]\n        emit BorrowForbidden(_creditManager); // T:[PS-13]\n    }\n\n    /// @dev Sets the new interest rate model for the pool\n    /// @param _interestRateModel Address of the new interest rate model contract\n    /// #limit {:msg \"Disallow updating the interest rate model after the constructor\"} address(interestRateModel) == address(0x0);\n    function updateInterestRateModel(address _interestRateModel)\n        public\n        configuratorOnly // T:[PS-9]\n    {\n        _updateInterestRateModel(_interestRateModel);\n    }\n\n    /// @dev IMPLEMENTATION: updateInterestRateModel\n    function _updateInterestRateModel(address _interestRateModel) internal {\n        require(\n            _interestRateModel != address(0),\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\n        );\n        interestRateModel = IInterestRateModel(_interestRateModel); // T:[PS-25]\n        _updateBorrowRate(0); // T:[PS-26]\n        emit NewInterestRateModel(_interestRateModel); // T:[PS-25]\n    }\n\n    /// @dev Sets a new expected liquidity limit\n    /// @param newLimit New expected liquidity limit\n    function setExpectedLiquidityLimit(uint256 newLimit)\n        external\n        configuratorOnly // T:[PS-9]\n    {\n        expectedLiquidityLimit = newLimit; // T:[PS-30]\n        emit NewExpectedLiquidityLimit(newLimit); // T:[PS-30]\n    }\n\n    /// @dev Sets a new withdrawal fee\n    /// @param fee The new fee amount, in bp\n    function setWithdrawFee(uint256 fee)\n        public\n        configuratorOnly // T:[PS-9]\n    {\n        require(fee <= MAX_WITHDRAW_FEE, Errors.POOL_INCORRECT_WITHDRAW_FEE); // T:[PS-32]\n        withdrawFee = fee; // T:[PS-33]\n        emit NewWithdrawFee(fee); // T:[PS-33]\n    }\n\n    /// @dev Returns the number of connected Credit Managers\n    function creditManagersCount() external view override returns (uint256) {\n        return creditManagers.length; // T:[PS-11]\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/core/ACLTrait.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { AddressProvider } from \"./AddressProvider.sol\";\nimport { IACL } from \"../interfaces/IACL.sol\";\nimport { ZeroAddressException, CallerNotConfiguratorException, CallerNotPausableAdminException, CallerNotUnPausableAdminException } from \"../interfaces/IErrors.sol\";\n\n/// @title ACL Trait\n/// @notice Utility class for ACL consumers\nabstract contract ACLTrait is Pausable {\n    // ACL contract to check rights\n    IACL public immutable _acl;\n\n    /// @dev constructor\n    /// @param addressProvider Address of address repository\n    constructor(address addressProvider) {\n        if (addressProvider == address(0)) revert ZeroAddressException(); // F:[AA-2]\n\n        _acl = IACL(AddressProvider(addressProvider).getACL());\n    }\n\n    /// @dev  Reverts if msg.sender is not configurator\n    modifier configuratorOnly() {\n        if (!_acl.isConfigurator(msg.sender))\n            revert CallerNotConfiguratorException();\n        _;\n    }\n\n    ///@dev Pause contract\n    function pause() external {\n        if (!_acl.isPausableAdmin(msg.sender))\n            revert CallerNotPausableAdminException();\n        _pause();\n    }\n\n    /// @dev Unpause contract\n    function unpause() external {\n        if (!_acl.isUnpausableAdmin(msg.sender))\n            revert CallerNotUnPausableAdminException();\n\n        _unpause();\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.10;\n\nimport { Errors } from \"./Errors.sol\";\n\nuint16 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\nuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n    /**\n     * @dev Executes a percentage multiplication\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The percentage of value\n     **/\n    function percentMul(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (value == 0 || percentage == 0) {\n            return 0; // T:[PM-1]\n        }\n\n        //        require(\n        //            value <= (type(uint256).max - HALF_PERCENT) / percentage,\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\n        //        ); // T:[PM-1]\n\n        return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; // T:[PM-1]\n    }\n\n    /**\n     * @dev Executes a percentage division\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The value divided the percentage\n     **/\n    function percentDiv(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[PM-2]\n        uint256 halfPercentage = percentage / 2; // T:[PM-2]\n\n        //        require(\n        //            value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\n        //        ); // T:[PM-2]\n\n        return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IInterestRateModel is IVersion {\n    /// @dev Returns the borrow rate calculated based on expectedLiquidity and availableLiquidity\n    /// @param expectedLiquidity Expected liquidity in the pool\n    /// @param availableLiquidity Available liquidity in the pool\n    /// @notice In RAY format\n    function calcBorrowRate(\n        uint256 expectedLiquidity,\n        uint256 availableLiquidity\n    ) external view returns (uint256);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\n// Denominations\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\n\n// 25% of type(uint256).max\nuint256 constant ALLOWANCE_THRESHOLD = type(uint96).max >> 3;\n\n// FEE = 50%\nuint16 constant DEFAULT_FEE_INTEREST = 50_00; // 50%\n\n// LIQUIDATION_FEE 1.5%\nuint16 constant DEFAULT_FEE_LIQUIDATION = 1_50; // 1.5%\n\n// LIQUIDATION PREMIUM 4%\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM = 4_00; // 4%\n\n// LIQUIDATION_FEE_EXPIRED 2%\nuint16 constant DEFAULT_FEE_LIQUIDATION_EXPIRED = 1_00; // 2%\n\n// LIQUIDATION PREMIUM EXPIRED 2%\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM_EXPIRED = 2_00; // 2%\n\n// DEFAULT PROPORTION OF MAX BORROWED PER BLOCK TO MAX BORROWED PER ACCOUNT\nuint16 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\n\n// Seconds in a year\nuint256 constant SECONDS_PER_YEAR = 365 days;\nuint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = (SECONDS_PER_YEAR * 3) / 2;\n\n// OPERATIONS\n\n// Leverage decimals - 100 is equal to 2x leverage (100% * collateral amount + 100% * borrowed amount)\nuint8 constant LEVERAGE_DECIMALS = 100;\n\n// Maximum withdraw fee for pool in PERCENTAGE_FACTOR format\nuint8 constant MAX_WITHDRAW_FEE = 100;\n\nuint256 constant EXACT_INPUT = 1;\nuint256 constant EXACT_OUTPUT = 2;\n\naddress constant UNIVERSAL_CONTRACT = 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC;\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IPoolService.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport \"../core/AddressProvider.sol\";\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IPoolServiceEvents {\n    /// @dev Emits on new liquidity being added to the pool\n    event AddLiquidity(\n        address indexed sender,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 referralCode\n    );\n\n    /// @dev Emits on liquidity being removed to the pool\n    event RemoveLiquidity(\n        address indexed sender,\n        address indexed to,\n        uint256 amount\n    );\n\n    /// @dev Emits on a Credit Manager borrowing funds for a Credit Account\n    event Borrow(\n        address indexed creditManager,\n        address indexed creditAccount,\n        uint256 amount\n    );\n\n    /// @dev Emits on repayment of a Credit Account's debt\n    event Repay(\n        address indexed creditManager,\n        uint256 borrowedAmount,\n        uint256 profit,\n        uint256 loss\n    );\n\n    /// @dev Emits on updating the interest rate model\n    event NewInterestRateModel(address indexed newInterestRateModel);\n\n    /// @dev Emits on connecting a new Credit Manager\n    event NewCreditManagerConnected(address indexed creditManager);\n\n    /// @dev Emits when a Credit Manager is forbidden to borrow\n    event BorrowForbidden(address indexed creditManager);\n\n    /// @dev Emitted when loss is incurred that can't be covered by treasury funds\n    event UncoveredLoss(address indexed creditManager, uint256 loss);\n\n    /// @dev Emits when the liquidity limit is changed\n    event NewExpectedLiquidityLimit(uint256 newLimit);\n\n    /// @dev Emits when the withdrawal fee is changed\n    event NewWithdrawFee(uint256 fee);\n}\n\n/// @title Pool Service Interface\n/// @notice Implements business logic:\n///   - Adding/removing pool liquidity\n///   - Managing diesel tokens & diesel rates\n///   - Taking/repaying Credit Manager debt\n/// More: https://dev.gearbox.fi/developers/pool/abstractpoolservice\ninterface IPoolService is IPoolServiceEvents, IVersion {\n    //\n    // LIQUIDITY MANAGEMENT\n    //\n\n    /**\n     * @dev Adds liquidity to pool\n     * - transfers the underlying to the pool\n     * - mints Diesel (LP) tokens to onBehalfOf\n     * @param amount Amount of tokens to be deposited\n     * @param onBehalfOf The address that will receive the dToken\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without a facilitator.\n     */\n    function addLiquidity(\n        uint256 amount,\n        address onBehalfOf,\n        uint256 referralCode\n    ) external;\n\n    /**\n     * @dev Removes liquidity from pool\n     * - burns LP's Diesel (LP) tokens\n     * - returns the equivalent amount of underlying to 'to'\n     * @param amount Amount of Diesel tokens to burn\n     * @param to Address to transfer the underlying to\n     */\n\n    function removeLiquidity(uint256 amount, address to)\n        external\n        returns (uint256);\n\n    /**\n     * @dev Lends pool funds to a Credit Account\n     * @param borrowedAmount Credit Account's debt principal\n     * @param creditAccount Credit Account's address\n     */\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\n        external;\n\n    /**\n     * @dev Repays the Credit Account's debt\n     * @param borrowedAmount Amount of principal ro repay\n     * @param profit The treasury profit from repayment\n     * @param loss Amount of underlying that the CA wan't able to repay\n     * @notice Assumes that the underlying (including principal + interest + fees)\n     *         was already transferred\n     */\n    function repayCreditAccount(\n        uint256 borrowedAmount,\n        uint256 profit,\n        uint256 loss\n    ) external;\n\n    //\n    // GETTERS\n    //\n\n    /**\n     * @dev Returns the total amount of liquidity in the pool, including borrowed and available funds\n     */\n    function expectedLiquidity() external view returns (uint256);\n\n    /**\n     * @dev Returns the limit on total liquidity\n     */\n    function expectedLiquidityLimit() external view returns (uint256);\n\n    /**\n     * @dev Returns the available liquidity, which is expectedLiquidity - totalBorrowed\n     */\n    function availableLiquidity() external view returns (uint256);\n\n    /**\n     * @dev Calculates the current interest index, RAY format\n     */\n    function calcLinearCumulative_RAY() external view returns (uint256);\n\n    /**\n     * @dev Calculates the current borrow rate, RAY format\n     */\n    function borrowAPY_RAY() external view returns (uint256);\n\n    /**\n     * @dev Returns the total borrowed amount (includes principal only)\n     */\n    function totalBorrowed() external view returns (uint256);\n\n    /**\n     * รง\n     **/\n\n    function getDieselRate_RAY() external view returns (uint256);\n\n    /**\n     * @dev Returns the address of the underlying\n     */\n    function underlyingToken() external view returns (address);\n\n    /**\n     * @dev Returns the address of the diesel token\n     */\n    function dieselToken() external view returns (address);\n\n    /**\n     * @dev Returns the address of a Credit Manager by its id\n     */\n    function creditManagers(uint256 id) external view returns (address);\n\n    /**\n     * @dev Returns the number of known Credit Managers\n     */\n    function creditManagersCount() external view returns (uint256);\n\n    /**\n     * @dev Maps Credit Manager addresses to their status as a borrower.\n     *      Returns false if borrowing is not allowed.\n     */\n    function creditManagersCanBorrow(address id) external view returns (bool);\n\n    /// @dev Converts a quantity of the underlying to Diesel tokens\n    function toDiesel(uint256 amount) external view returns (uint256);\n\n    /// @dev Converts a quantity of Diesel tokens to the underlying\n    function fromDiesel(uint256 amount) external view returns (uint256);\n\n    /// @dev Returns the withdrawal fee\n    function withdrawFee() external view returns (uint256);\n\n    /// @dev Returns the timestamp of the pool's last update\n    function _timestampLU() external view returns (uint256);\n\n    /// @dev Returns the interest index at the last pool update\n    function _cumulativeIndex_RAY() external view returns (uint256);\n\n    /// @dev Returns the address provider\n    function addressProvider() external view returns (AddressProvider);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/ICreditManagerV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { IPriceOracleV2 } from \"./IPriceOracle.sol\";\nimport { IVersion } from \"./IVersion.sol\";\n\nenum ClosureAction {\n    CLOSE_ACCOUNT,\n    LIQUIDATE_ACCOUNT,\n    LIQUIDATE_EXPIRED_ACCOUNT,\n    LIQUIDATE_PAUSED\n}\n\ninterface ICreditManagerV2Events {\n    /// @dev Emits when a call to an external contract is made through the Credit Manager\n    event ExecuteOrder(address indexed borrower, address indexed target);\n\n    /// @dev Emits when a configurator is upgraded\n    event NewConfigurator(address indexed newConfigurator);\n}\n\ninterface ICreditManagerV2Exceptions {\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Facade, or an allowed adapter\n    error AdaptersOrCreditFacadeOnlyException();\n\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Facade\n    error CreditFacadeOnlyException();\n\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Configurator\n    error CreditConfiguratorOnlyException();\n\n    /// @dev Thrown on attempting to open a Credit Account for or transfer a Credit Account\n    ///      to the zero address or an address that already owns a Credit Account\n    error ZeroAddressOrUserAlreadyHasAccountException();\n\n    /// @dev Thrown on attempting to execute an order to an address that is not an allowed\n    ///      target contract\n    error TargetContractNotAllowedException();\n\n    /// @dev Thrown on failing a full collateral check after an operation\n    error NotEnoughCollateralException();\n\n    /// @dev Thrown on attempting to receive a token that is not a collateral token\n    ///      or was forbidden\n    error TokenNotAllowedException();\n\n    /// @dev Thrown if an attempt to approve a collateral token to a target contract failed\n    error AllowanceFailedException();\n\n    /// @dev Thrown on attempting to perform an action for an address that owns no Credit Account\n    error HasNoOpenedAccountException();\n\n    /// @dev Thrown on attempting to add a token that is already in a collateral list\n    error TokenAlreadyAddedException();\n\n    /// @dev Thrown on configurator attempting to add more than 256 collateral tokens\n    error TooManyTokensException();\n\n    /// @dev Thrown if more than the maximal number of tokens were enabled on a Credit Account,\n    ///      and there are not enough unused token to disable\n    error TooManyEnabledTokensException();\n\n    /// @dev Thrown when a reentrancy into the contract is attempted\n    error ReentrancyLockException();\n}\n\n/// @notice All Credit Manager functions are access-restricted and can only be called\n///         by the Credit Facade or allowed adapters. Users are not allowed to\n///         interact with the Credit Manager directly\ninterface ICreditManagerV2 is\n    ICreditManagerV2Events,\n    ICreditManagerV2Exceptions,\n    IVersion\n{\n    //\n    // CREDIT ACCOUNT MANAGEMENT\n    //\n\n    ///  @dev Opens credit account and borrows funds from the pool.\n    /// - Takes Credit Account from the factory;\n    /// - Requests the pool to lend underlying to the Credit Account\n    ///\n    /// @param borrowedAmount Amount to be borrowed by the Credit Account\n    /// @param onBehalfOf The owner of the newly opened Credit Account\n    function openCreditAccount(uint256 borrowedAmount, address onBehalfOf)\n        external\n        returns (address);\n\n    ///  @dev Closes a Credit Account - covers both normal closure and liquidation\n    /// - Checks whether the contract is paused, and, if so, if the payer is an emergency liquidator.\n    ///   Only emergency liquidators are able to liquidate account while the CM is paused.\n    ///   Emergency liquidations do not pay a liquidator premium or liquidation fees.\n    /// - Calculates payments to various recipients on closure:\n    ///    + Computes amountToPool, which is the amount to be sent back to the pool.\n    ///      This includes the principal, interest and fees, but can't be more than\n    ///      total position value\n    ///    + Computes remainingFunds during liquidations - these are leftover funds\n    ///      after paying the pool and the liquidator, and are sent to the borrower\n    ///    + Computes protocol profit, which includes interest and liquidation fees\n    ///    + Computes loss if the totalValue is less than borrow amount + interest\n    /// - Checks the underlying token balance:\n    ///    + if it is larger than amountToPool, then the pool is paid fully from funds on the Credit Account\n    ///    + else tries to transfer the shortfall from the payer - either the borrower during closure, or liquidator during liquidation\n    /// - Send assets to the \"to\" address, as long as they are not included into skipTokenMask\n    /// - If convertWETH is true, the function converts WETH into ETH before sending\n    /// - Returns the Credit Account back to factory\n    ///\n    /// @param borrower Borrower address\n    /// @param closureActionType Whether the account is closed, liquidated or liquidated due to expiry\n    /// @param totalValue Portfolio value for liqution, 0 for ordinary closure\n    /// @param payer Address which would be charged if credit account has not enough funds to cover amountToPool\n    /// @param to Address to which the leftover funds will be sent\n    /// @param skipTokenMask Tokenmask contains 1 for tokens which needed to be skipped for sending\n    /// @param convertWETH If true converts WETH to ETH\n    function closeCreditAccount(\n        address borrower,\n        ClosureAction closureActionType,\n        uint256 totalValue,\n        address payer,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH\n    ) external returns (uint256 remainingFunds);\n\n    /// @dev Manages debt size for borrower:\n    ///\n    /// - Increase debt:\n    ///   + Increases debt by transferring funds from the pool to the credit account\n    ///   + Updates the cumulative index to keep interest the same. Since interest\n    ///     is always computed dynamically as borrowedAmount * (cumulativeIndexNew / cumulativeIndexOpen - 1),\n    ///     cumulativeIndexOpen needs to be updated, as the borrow amount has changed\n    ///\n    /// - Decrease debt:\n    ///   + Repays debt partially + all interest and fees accrued thus far\n    ///   + Updates cunulativeIndex to cumulativeIndex now\n    ///\n    /// @param creditAccount Address of the Credit Account to change debt for\n    /// @param amount Amount to increase / decrease the principal by\n    /// @param increase True to increase principal, false to decrease\n    /// @return newBorrowedAmount The new debt principal\n    function manageDebt(\n        address creditAccount,\n        uint256 amount,\n        bool increase\n    ) external returns (uint256 newBorrowedAmount);\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param payer Address of the account which will be charged to provide additional collateral\n    /// @param creditAccount Address of the Credit Account\n    /// @param token Collateral token to add\n    /// @param amount Amount to add\n    function addCollateral(\n        address payer,\n        address creditAccount,\n        address token,\n        uint256 amount\n    ) external;\n\n    /// @dev Transfers Credit Account ownership to another address\n    /// @param from Address of previous owner\n    /// @param to Address of new owner\n    function transferAccountOwnership(address from, address to) external;\n\n    /// @dev Requests the Credit Account to approve a collateral token to another contract.\n    /// @param borrower Borrower's address\n    /// @param targetContract Spender to change allowance for\n    /// @param token Collateral token to approve\n    /// @param amount New allowance amount\n    function approveCreditAccount(\n        address borrower,\n        address targetContract,\n        address token,\n        uint256 amount\n    ) external;\n\n    /// @dev Requests a Credit Account to make a low-level call with provided data\n    /// This is the intended pathway for state-changing interactions with 3rd-party protocols\n    /// @param borrower Borrower's address\n    /// @param targetContract Contract to be called\n    /// @param data Data to pass with the call\n    function executeOrder(\n        address borrower,\n        address targetContract,\n        bytes memory data\n    ) external returns (bytes memory);\n\n    //\n    // COLLATERAL VALIDITY AND ACCOUNT HEALTH CHECKS\n    //\n\n    /// @dev Enables a token on a Credit Account, including it\n    /// into account health and total value calculations\n    /// @param creditAccount Address of a Credit Account to enable the token for\n    /// @param token Address of the token to be enabled\n    function checkAndEnableToken(address creditAccount, address token) external;\n\n    /// @dev Optimized health check for individual swap-like operations.\n    /// @notice Fast health check assumes that only two tokens (input and output)\n    ///         participate in the operation and computes a % change in weighted value between\n    ///         inbound and outbound collateral. The cumulative negative change across several\n    ///         swaps in sequence cannot be larger than feeLiquidation (a fee that the\n    ///         protocol is ready to waive if needed). Since this records a % change\n    ///         between just two tokens, the corresponding % change in TWV will always be smaller,\n    ///         which makes this check safe.\n    ///         More details at https://dev.gearbox.fi/docs/documentation/risk/fast-collateral-check#fast-check-protection\n    /// @param creditAccount Address of the Credit Account\n    /// @param tokenIn Address of the token spent by the swap\n    /// @param tokenOut Address of the token received from the swap\n    /// @param balanceInBefore Balance of tokenIn before the operation\n    /// @param balanceOutBefore Balance of tokenOut before the operation\n    function fastCollateralCheck(\n        address creditAccount,\n        address tokenIn,\n        address tokenOut,\n        uint256 balanceInBefore,\n        uint256 balanceOutBefore\n    ) external;\n\n    /// @dev Performs a full health check on an account, summing up\n    /// value of all enabled collateral tokens\n    /// @param creditAccount Address of the Credit Account to check\n    function fullCollateralCheck(address creditAccount) external;\n\n    /// @dev Checks that the number of enabled tokens on a Credit Account\n    ///      does not violate the maximal enabled token limit and tries\n    ///      to disable unused tokens if it does\n    /// @param creditAccount Account to check enabled tokens for\n    function checkAndOptimizeEnabledTokens(address creditAccount) external;\n\n    /// @dev Disables a token on a credit account\n    /// @notice Usually called by adapters to disable spent tokens during a multicall,\n    ///         but can also be called separately from the Credit Facade to remove\n    ///         unwanted tokens\n    function disableToken(address creditAccount, address token) external;\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Returns the address of a borrower's Credit Account, or reverts if there is none.\n    /// @param borrower Borrower's address\n    function getCreditAccountOrRevert(address borrower)\n        external\n        view\n        returns (address);\n\n    /// @dev Computes amounts that must be sent to various addresses before closing an account\n    /// @param totalValue Credit Accounts total value in underlying\n    /// @param closureActionType Type of account closure\n    ///        * CLOSE_ACCOUNT: The account is healthy and is closed normally\n    ///        * LIQUIDATE_ACCOUNT: The account is unhealthy and is being liquidated to avoid bad debt\n    ///        * LIQUIDATE_EXPIRED_ACCOUNT: The account has expired and is being liquidated (lowered liquidation premium)\n    ///        * LIQUIDATE_PAUSED: The account is liquidated while the system is paused due to emergency (no liquidation premium)\n    /// @param borrowedAmount Credit Account's debt principal\n    /// @param borrowedAmountWithInterest Credit Account's debt principal + interest\n    /// @return amountToPool Amount of underlying to be sent to the pool\n    /// @return remainingFunds Amount of underlying to be sent to the borrower (only applicable to liquidations)\n    /// @return profit Protocol's profit from fees (if any)\n    /// @return loss Protocol's loss from bad debt (if any)\n    function calcClosePayments(\n        uint256 totalValue,\n        ClosureAction closureActionType,\n        uint256 borrowedAmount,\n        uint256 borrowedAmountWithInterest\n    )\n        external\n        view\n        returns (\n            uint256 amountToPool,\n            uint256 remainingFunds,\n            uint256 profit,\n            uint256 loss\n        );\n\n    /// @dev Calculates the debt accrued by a Credit Account\n    /// @param creditAccount Address of the Credit Account\n    /// @return borrowedAmount The debt principal\n    /// @return borrowedAmountWithInterest The debt principal + accrued interest\n    /// @return borrowedAmountWithInterestAndFees The debt principal + accrued interest and protocol fees\n    function calcCreditAccountAccruedInterest(address creditAccount)\n        external\n        view\n        returns (\n            uint256 borrowedAmount,\n            uint256 borrowedAmountWithInterest,\n            uint256 borrowedAmountWithInterestAndFees\n        );\n\n    /// @dev Maps Credit Accounts to bit masks encoding their enabled token sets\n    /// Only enabled tokens are counted as collateral for the Credit Account\n    /// @notice An enabled token mask encodes an enabled token by setting\n    ///         the bit at the position equal to token's index to 1\n    function enabledTokensMap(address creditAccount)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Maps the Credit Account to its current percentage drop across all swaps since\n    ///      the last full check, in RAY format\n    function cumulativeDropAtFastCheckRAY(address creditAccount)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns the collateral token at requested index and its liquidation threshold\n    /// @param id The index of token to return\n    function collateralTokens(uint256 id)\n        external\n        view\n        returns (address token, uint16 liquidationThreshold);\n\n    /// @dev Returns the collateral token with requested mask and its liquidationThreshold\n    /// @param tokenMask Token mask corresponding to the token\n    function collateralTokensByMask(uint256 tokenMask)\n        external\n        view\n        returns (address token, uint16 liquidationThreshold);\n\n    /// @dev Total number of known collateral tokens.\n    function collateralTokensCount() external view returns (uint256);\n\n    /// @dev Returns the mask for the provided token\n    /// @param token Token to returns the mask for\n    function tokenMasksMap(address token) external view returns (uint256);\n\n    /// @dev Bit mask encoding a set of forbidden tokens\n    function forbiddenTokenMask() external view returns (uint256);\n\n    /// @dev Maps allowed adapters to their respective target contracts.\n    function adapterToContract(address adapter) external view returns (address);\n\n    /// @dev Maps 3rd party contracts to their respective adapters\n    function contractToAdapter(address targetContract)\n        external\n        view\n        returns (address);\n\n    /// @dev Address of the underlying asset\n    function underlying() external view returns (address);\n\n    /// @dev Address of the connected pool\n    function pool() external view returns (address);\n\n    /// @dev Address of the connected pool\n    /// @notice [DEPRECATED]: use pool() instead.\n    function poolService() external view returns (address);\n\n    /// @dev A map from borrower addresses to Credit Account addresses\n    function creditAccounts(address borrower) external view returns (address);\n\n    /// @dev Address of the connected Credit Configurator\n    function creditConfigurator() external view returns (address);\n\n    /// @dev Address of WETH\n    function wethAddress() external view returns (address);\n\n    /// @dev Returns the liquidation threshold for the provided token\n    /// @param token Token to retrieve the LT for\n    function liquidationThresholds(address token)\n        external\n        view\n        returns (uint16);\n\n    /// @dev The maximal number of enabled tokens on a single Credit Account\n    function maxAllowedEnabledTokenLength() external view returns (uint8);\n\n    /// @dev Maps addresses to their status as emergency liquidator.\n    /// @notice Emergency liquidators are trusted addresses\n    /// that are able to liquidate positions while the contracts are paused,\n    /// e.g. when there is a risk of bad debt while an exploit is being patched.\n    /// In the interest of fairness, emergency liquidators do not receive a premium\n    /// And are compensated by the Gearbox DAO separately.\n    function canLiquidateWhilePaused(address) external view returns (bool);\n\n    /// @dev Returns the fee parameters of the Credit Manager\n    /// @return feeInterest Percentage of interest taken by the protocol as profit\n    /// @return feeLiquidation Percentage of account value taken by the protocol as profit\n    ///         during unhealthy account liquidations\n    /// @return liquidationDiscount Multiplier that reduces the effective totalValue during unhealthy account liquidations,\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremium)\n    /// @return feeLiquidationExpired Percentage of account value taken by the protocol as profit\n    ///         during expired account liquidations\n    /// @return liquidationDiscountExpired Multiplier that reduces the effective totalValue during expired account liquidations,\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremiumExpired)\n    function fees()\n        external\n        view\n        returns (\n            uint16 feeInterest,\n            uint16 feeLiquidation,\n            uint16 liquidationDiscount,\n            uint16 feeLiquidationExpired,\n            uint16 liquidationDiscountExpired\n        );\n\n    /// @dev Address of the connected Credit Facade\n    function creditFacade() external view returns (address);\n\n    /// @dev Address of the connected Price Oracle\n    function priceOracle() external view returns (IPriceOracleV2);\n\n    /// @dev Address of the universal adapter\n    function universalAdapter() external view returns (address);\n\n    /// @dev Contract's version\n    function version() external view returns (uint256);\n\n    /// @dev Paused() state\n    function checkEmergencyPausable(address caller, bool state)\n        external\n        returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/core/AddressProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { IAddressProvider } from \"../interfaces/IAddressProvider.sol\";\nimport { Claimable } from \"./access/Claimable.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n// Repositories & services\nbytes32 constant CONTRACTS_REGISTER = \"CONTRACTS_REGISTER\";\nbytes32 constant ACL = \"ACL\";\nbytes32 constant PRICE_ORACLE = \"PRICE_ORACLE\";\nbytes32 constant ACCOUNT_FACTORY = \"ACCOUNT_FACTORY\";\nbytes32 constant DATA_COMPRESSOR = \"DATA_COMPRESSOR\";\nbytes32 constant TREASURY_CONTRACT = \"TREASURY_CONTRACT\";\nbytes32 constant GEAR_TOKEN = \"GEAR_TOKEN\";\nbytes32 constant WETH_TOKEN = \"WETH_TOKEN\";\nbytes32 constant WETH_GATEWAY = \"WETH_GATEWAY\";\nbytes32 constant LEVERAGED_ACTIONS = \"LEVERAGED_ACTIONS\";\n\n/// @title AddressRepository\n/// @notice Stores addresses of deployed contracts\ncontract AddressProvider is Claimable, IAddressProvider {\n    // Mapping from contract keys to respective addresses\n    mapping(bytes32 => address) public addresses;\n\n    // Contract version\n    uint256 public constant version = 2;\n\n    constructor() {\n        // @dev Emits first event for contract discovery\n        emit AddressSet(\"ADDRESS_PROVIDER\", address(this));\n    }\n\n    /// @return Address of ACL contract\n    function getACL() external view returns (address) {\n        return _getAddress(ACL); // F:[AP-3]\n    }\n\n    /// @dev Sets address of ACL contract\n    /// @param _address Address of ACL contract\n    function setACL(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(ACL, _address); // F:[AP-3]\n    }\n\n    /// @return Address of ContractsRegister\n    function getContractsRegister() external view returns (address) {\n        return _getAddress(CONTRACTS_REGISTER); // F:[AP-4]\n    }\n\n    /// @dev Sets address of ContractsRegister\n    /// @param _address Address of ContractsRegister\n    function setContractsRegister(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(CONTRACTS_REGISTER, _address); // F:[AP-4]\n    }\n\n    /// @return Address of PriceOracle\n    function getPriceOracle() external view override returns (address) {\n        return _getAddress(PRICE_ORACLE); // F:[AP-5]\n    }\n\n    /// @dev Sets address of PriceOracle\n    /// @param _address Address of PriceOracle\n    function setPriceOracle(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(PRICE_ORACLE, _address); // F:[AP-5]\n    }\n\n    /// @return Address of AccountFactory\n    function getAccountFactory() external view returns (address) {\n        return _getAddress(ACCOUNT_FACTORY); // F:[AP-6]\n    }\n\n    /// @dev Sets address of AccountFactory\n    /// @param _address Address of AccountFactory\n    function setAccountFactory(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(ACCOUNT_FACTORY, _address); // F:[AP-6]\n    }\n\n    /// @return Address of DataCompressor\n    function getDataCompressor() external view override returns (address) {\n        return _getAddress(DATA_COMPRESSOR); // F:[AP-7]\n    }\n\n    /// @dev Sets address of AccountFactory\n    /// @param _address Address of AccountFactory\n    function setDataCompressor(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(DATA_COMPRESSOR, _address); // F:[AP-7]\n    }\n\n    /// @return Address of Treasury contract\n    function getTreasuryContract() external view returns (address) {\n        return _getAddress(TREASURY_CONTRACT); // F:[AP-8]\n    }\n\n    /// @dev Sets address of Treasury Contract\n    /// @param _address Address of Treasury Contract\n    function setTreasuryContract(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(TREASURY_CONTRACT, _address); // F:[AP-8]\n    }\n\n    /// @return Address of GEAR token\n    function getGearToken() external view override returns (address) {\n        return _getAddress(GEAR_TOKEN); // F:[AP-9]\n    }\n\n    /// @dev Sets address of GEAR token\n    /// @param _address Address of GEAR token\n    function setGearToken(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(GEAR_TOKEN, _address); // F:[AP-9]\n    }\n\n    /// @return Address of WETH token\n    function getWethToken() external view override returns (address) {\n        return _getAddress(WETH_TOKEN); // F:[AP-10]\n    }\n\n    /// @dev Sets address of WETH token\n    /// @param _address Address of WETH token\n    function setWethToken(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(WETH_TOKEN, _address); // F:[AP-10]\n    }\n\n    /// @return Address of WETH token\n    function getWETHGateway() external view override returns (address) {\n        return _getAddress(WETH_GATEWAY); // F:[AP-11]\n    }\n\n    /// @dev Sets address of WETH token\n    /// @param _address Address of WETH token\n    function setWETHGateway(address _address)\n        external\n        onlyOwner // F:[AP-12]\n    {\n        _setAddress(WETH_GATEWAY, _address); // F:[AP-11]\n    }\n\n    /// @return Address of PathFinder\n    function getLeveragedActions() external view returns (address) {\n        return _getAddress(LEVERAGED_ACTIONS); // T:[AP-7]\n    }\n\n    /// @dev Sets address of  PathFinder\n    /// @param _address Address of  PathFinder\n    function setLeveragedActions(address _address)\n        external\n        onlyOwner // T:[AP-15]\n    {\n        _setAddress(LEVERAGED_ACTIONS, _address); // T:[AP-7]\n    }\n\n    /// @return Address of key, reverts if the key doesn't exist\n    function _getAddress(bytes32 key) internal view returns (address) {\n        address result = addresses[key];\n        require(result != address(0), Errors.AS_ADDRESS_NOT_FOUND); // F:[AP-1]\n        return result; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\n    }\n\n    /// @dev Sets address to map by its key\n    /// @param key Key in string format\n    /// @param value Address\n    function _setAddress(bytes32 key, address value) internal {\n        addresses[key] = value; // F:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11]\n        emit AddressSet(key, value); // F:[AP-2]\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/tokens/DieselToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IDieselToken } from \"../interfaces/IDieselToken.sol\";\n\n/// @dev DieselToken is LP token for Gearbox pools\ncontract DieselToken is ERC20, IDieselToken {\n    uint8 private immutable _decimals;\n    address public immutable poolService;\n\n    modifier onlyPoolService() {\n        if (msg.sender != poolService) {\n            revert PoolServiceOnlyException();\n        }\n        _;\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n        poolService = msg.sender;\n    }\n\n    function mint(address to, uint256 amount) external onlyPoolService {\n        _mint(to, amount);\n    }\n\n    function burn(address to, uint256 amount) external onlyPoolService {\n        _burn(to, amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\n/// @title Errors library\nlibrary Errors {\n    //\n    // COMMON\n    //\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \"Z0\";\n    string public constant NOT_IMPLEMENTED = \"NI\";\n    string public constant INCORRECT_PATH_LENGTH = \"PL\";\n    string public constant INCORRECT_ARRAY_LENGTH = \"CR\";\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \"CP\";\n    string public constant REGISTERED_POOLS_ONLY = \"RP\";\n    string public constant INCORRECT_PARAMETER = \"IP\";\n\n    //\n    // MATH\n    //\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \"M1\";\n    string public constant MATH_ADDITION_OVERFLOW = \"M2\";\n    string public constant MATH_DIVISION_BY_ZERO = \"M3\";\n\n    //\n    // POOL\n    //\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \"PS0\";\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \"PS1\";\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \"PS2\";\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \"PS3\";\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \"PS4\";\n\n    //\n    // ACCOUNT FACTORY\n    //\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\n        \"AF1\";\n    string public constant AF_MINING_IS_FINISHED = \"AF2\";\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \"AF3\";\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \"AF4\";\n\n    //\n    // ADDRESS PROVIDER\n    //\n    string public constant AS_ADDRESS_NOT_FOUND = \"AP1\";\n\n    //\n    // CONTRACTS REGISTER\n    //\n    string public constant CR_POOL_ALREADY_ADDED = \"CR1\";\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \"CR2\";\n\n    //\n    // CREDIT ACCOUNT\n    //\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \"CA1\";\n    string public constant CA_FACTORY_ONLY = \"CA2\";\n\n    //\n    // ACL\n    //\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \"ACL1\";\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \"ACL2\";\n\n    //\n    // WETH GATEWAY\n    //\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \"WG1\";\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \"WG2\";\n    string public constant WG_NOT_ENOUGH_FUNDS = \"WG3\";\n\n    //\n    // TOKEN DISTRIBUTOR\n    //\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \"TD1\";\n    string public constant TD_INCORRECT_WEIGHTS = \"TD2\";\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \"TD3\";\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \"TD4\";\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\n/// @dev Common contract exceptions\n\n/// @dev Thrown on attempting to set an important address to zero address\nerror ZeroAddressException();\n\n/// @dev Thrown on attempting to call a non-implemented function\nerror NotImplementedException();\n\n/// @dev Thrown on attempting to set an EOA as an important contract in the system\nerror AddressIsNotContractException(address);\n\n/// @dev Thrown on attempting to use a non-ERC20 contract or an EOA as a token\nerror IncorrectTokenContractException();\n\n/// @dev Thrown on attempting to set a token price feed to an address that is not a\n///      correct price feed\nerror IncorrectPriceFeedException();\n\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\nerror CallerNotConfiguratorException();\n\n/// @dev Thrown on attempting to pause a contract as a non-Pausable admin\nerror CallerNotPausableAdminException();\n\n/// @dev Thrown on attempting to pause a contract as a non-Unpausable admin\nerror CallerNotUnPausableAdminException();\n\nerror TokenIsNotAddedToCreditManagerException(address token);\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IACL.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IACLExceptions {\n    /// @dev Thrown when attempting to delete an address from a set that is not a pausable admin\n    error AddressNotPausableAdminException(address addr);\n\n    /// @dev Thrown when attempting to delete an address from a set that is not a unpausable admin\n    error AddressNotUnpausableAdminException(address addr);\n}\n\ninterface IACLEvents {\n    /// @dev Emits when a new admin is added that can pause contracts\n    event PausableAdminAdded(address indexed newAdmin);\n\n    /// @dev Emits when a Pausable admin is removed\n    event PausableAdminRemoved(address indexed admin);\n\n    /// @dev Emits when a new admin is added that can unpause contracts\n    event UnpausableAdminAdded(address indexed newAdmin);\n\n    /// @dev Emits when an Unpausable admin is removed\n    event UnpausableAdminRemoved(address indexed admin);\n}\n\n/// @title ACL interface\ninterface IACL is IACLEvents, IACLExceptions, IVersion {\n    /// @dev Returns true if the address is a pausable admin and false if not\n    /// @param addr Address to check\n    function isPausableAdmin(address addr) external view returns (bool);\n\n    /// @dev Returns true if the address is unpausable admin and false if not\n    /// @param addr Address to check\n    function isUnpausableAdmin(address addr) external view returns (bool);\n\n    /// @dev Returns true if an address has configurator rights\n    /// @param account Address to check\n    function isConfigurator(address account) external view returns (bool);\n\n    /// @dev Returns address of configurator\n    function owner() external view returns (address);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/core/access/Claimable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Claimable\n/// @dev Implements logic for a two-step ownership transfer on top of Ownable\ncontract Claimable is Ownable {\n    /// @dev The new owner that has not claimed ownership yet\n    address public pendingOwner;\n\n    /// @dev A modifier that restricts the function to the pending owner only\n    modifier onlyPendingOwner() {\n        if (msg.sender != pendingOwner) {\n            revert(\"Claimable: Sender is not pending owner\");\n        }\n        _;\n    }\n\n    /// @dev Sets pending owner to the new owner, but does not\n    /// transfer ownership yet\n    /// @param newOwner The address to become the future owner\n    function transferOwnership(address newOwner) public override onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Claimable: new owner is the zero address\"\n        );\n        pendingOwner = newOwner;\n    }\n\n    /// @dev Used by the pending owner to claim ownership after transferOwnership\n    function claimOwnership() external onlyPendingOwner {\n        _transferOwnership(pendingOwner);\n        pendingOwner = address(0);\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IAddressProviderEvents {\n    /// @dev Emits when an address is set for a contract role\n    event AddressSet(bytes32 indexed service, address indexed newAddress);\n}\n\n/// @title Optimised for front-end Address Provider interface\ninterface IAddressProvider is IAddressProviderEvents, IVersion {\n    /// @return Address of ACL contract\n    function getACL() external view returns (address);\n\n    /// @return Address of ContractsRegister\n    function getContractsRegister() external view returns (address);\n\n    /// @return Address of AccountFactory\n    function getAccountFactory() external view returns (address);\n\n    /// @return Address of DataCompressor\n    function getDataCompressor() external view returns (address);\n\n    /// @return Address of GEAR token\n    function getGearToken() external view returns (address);\n\n    /// @return Address of WETH token\n    function getWethToken() external view returns (address);\n\n    /// @return Address of WETH Gateway\n    function getWETHGateway() external view returns (address);\n\n    /// @return Address of PriceOracle\n    function getPriceOracle() external view returns (address);\n\n    /// @return Address of DAO Treasury Multisig\n    function getTreasuryContract() external view returns (address);\n\n    /// @return Address of PathFinder\n    function getLeveragedActions() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\n\n/// @title IVersion\n/// @dev Declares a version function which returns the contract's version\ninterface IVersion {\n    /// @dev Returns contract version\n    function version() external view returns (uint256);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IPriceOracleV2Events {\n    /// @dev Emits when a new price feed is added\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\n}\n\ninterface IPriceOracleV2Exceptions {\n    /// @dev Thrown if a price feed returns 0\n    error ZeroPriceException();\n\n    /// @dev Thrown if the last recorded result was not updated in the last round\n    error ChainPriceStaleException();\n\n    /// @dev Thrown on attempting to get a result for a token that does not have a price feed\n    error PriceOracleNotExistsException();\n}\n\n/// @title Price oracle interface\ninterface IPriceOracleV2 is\n    IPriceOracleV2Events,\n    IPriceOracleV2Exceptions,\n    IVersion\n{\n    /// @dev Converts a quantity of an asset to USD (decimals = 8).\n    /// @param amount Amount to convert\n    /// @param token Address of the token to be converted\n    function convertToUSD(uint256 amount, address token)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Converts a quantity of USD (decimals = 8) to an equivalent amount of an asset\n    /// @param amount Amount to convert\n    /// @param token Address of the token converted to\n    function convertFromUSD(uint256 amount, address token)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Converts one asset into another\n    ///\n    /// @param amount Amount to convert\n    /// @param tokenFrom Address of the token to convert from\n    /// @param tokenTo Address of the token to convert to\n    function convert(\n        uint256 amount,\n        address tokenFrom,\n        address tokenTo\n    ) external view returns (uint256);\n\n    /// @dev Returns collateral values for two tokens, required for a fast check\n    /// @param amountFrom Amount of the outbound token\n    /// @param tokenFrom Address of the outbound token\n    /// @param amountTo Amount of the inbound token\n    /// @param tokenTo Address of the inbound token\n    /// @return collateralFrom Value of the outbound token amount in USD\n    /// @return collateralTo Value of the inbound token amount in USD\n    function fastCheck(\n        uint256 amountFrom,\n        address tokenFrom,\n        uint256 amountTo,\n        address tokenTo\n    ) external view returns (uint256 collateralFrom, uint256 collateralTo);\n\n    /// @dev Returns token's price in USD (8 decimals)\n    /// @param token The token to compute the price for\n    function getPrice(address token) external view returns (uint256);\n\n    /// @dev Returns the price feed address for the passed token\n    /// @param token Token to get the price feed for\n    function priceFeeds(address token)\n        external\n        view\n        returns (address priceFeed);\n\n    /// @dev Returns the price feed for the passed token,\n    ///      with additional parameters\n    /// @param token Token to get the price feed for\n    function priceFeedsWithFlags(address token)\n        external\n        view\n        returns (\n            address priceFeed,\n            bool skipCheck,\n            uint256 decimals\n        );\n}\n\ninterface IPriceOracleV2Ext is IPriceOracleV2 {\n    /// @dev Sets a price feed if it doesn't exist, or updates an existing one\n    /// @param token Address of the token to set the price feed for\n    /// @param priceFeed Address of a USD price feed adhering to Chainlink's interface\n    function addPriceFeed(address token, address priceFeed) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IDieselToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2021\npragma solidity ^0.8.10;\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDieselTokenExceptions {\n    /// @dev Thrown if an access-restricted function was called by non-PoolService\n    error PoolServiceOnlyException();\n}\n\ninterface IDieselToken is IERC20, IDieselTokenExceptions {\n    /// @dev Returns the address of the pool this Diesel token belongs to\n    function poolService() external view returns (address);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}