{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
    },
    "contracts/Distributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { BitMaps } from \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\r\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\r\nimport { IERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\r\n\r\nimport { ReentrancyGuard } from \"./utils/ReentrancyGuard.sol\";\r\nimport { SafeToken } from \"./utils/SafeToken.sol\";\r\n\r\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\r\n\r\n\r\ncontract Distributor is ReentrancyGuard\r\n{\r\n  using SafeToken for IERC20;\r\n  using BitMaps for BitMaps.BitMap;\r\n\r\n\r\n  address private constant _GLOVE = 0x70c5f366dB60A2a0C59C4C24754803Ee47Ed7284;\r\n  address private constant _LOBS = 0x026224A2940bFE258D0dbE947919B62fE321F042;\r\n\r\n  uint256 private constant _CAP = 1066e18; // LOBS + 1\r\n\r\n  uint256 private immutable _DEADLINE;\r\n\r\n\r\n  BitMaps.BitMap private _validated;\r\n\r\n  bool private _closed;\r\n  uint256 private _distributed;\r\n\r\n  mapping(address => bool) private _lobster;\r\n  mapping(address => uint) private _lobsters;\r\n\r\n\r\n  event Claim(address lobster);\r\n  event Collect(address lobster);\r\n\r\n\r\n  constructor ()\r\n  {\r\n    _DEADLINE = block.timestamp + 70 minutes;\r\n  }\r\n\r\n\r\n  function closed () external view returns (bool)\r\n  {\r\n    return _closed;\r\n  }\r\n\r\n  function deadline () external view returns (uint256)\r\n  {\r\n    return _DEADLINE;\r\n  }\r\n\r\n  function remaining () external view returns (uint256)\r\n  {\r\n    return _CAP - _distributed;\r\n  }\r\n\r\n\r\n  function claim () external nonReentrant\r\n  {\r\n    require(!_lobster[msg.sender], \"lobster\");\r\n    require(tx.origin == msg.sender, \"!seabug\");\r\n    require(block.timestamp < _DEADLINE && _distributed < _CAP, \"closed\");\r\n\r\n\r\n    uint256 balance = IERC721Enumerable(_LOBS).balanceOf(msg.sender);\r\n\r\n    require(balance >= 2, \"shrimp\");\r\n\r\n\r\n    uint lob;\r\n    bool lobstered;\r\n\r\n    for (uint256 i; i < balance;)\r\n    {\r\n      lob = IERC721Enumerable(_LOBS).tokenOfOwnerByIndex(msg.sender, i);\r\n\r\n\r\n      if (_validated.get(lob))\r\n      {\r\n        lobstered = true;\r\n      }\r\n\r\n\r\n      _validated.set(lob);\r\n\r\n\r\n      unchecked { i++; }\r\n    }\r\n\r\n\r\n    if (!lobstered)\r\n    {\r\n      _distributed += 2e18;\r\n      _lobsters[msg.sender] = 2e18;\r\n\r\n      IERC20(_GLOVE).mint(address(this), 2e18);\r\n    }\r\n\r\n\r\n    _lobster[msg.sender] = true;\r\n\r\n\r\n    emit Claim(msg.sender);\r\n  }\r\n\r\n\r\n  function lobster (address account) external view returns (bool)\r\n  {\r\n    return _lobster[account];\r\n  }\r\n\r\n\r\n  function _cleanup () private\r\n  {\r\n    if (!_closed)\r\n    {\r\n      _closed = true;\r\n\r\n      IAccessControl(_GLOVE).renounceRole(0xbe74a168a238bf2df7daa27dd5487ac84cb89ae44fd7e7d1e4b6397bfe51dcb8, address(this));\r\n    }\r\n  }\r\n\r\n  function collect () external nonReentrant\r\n  {\r\n    require(_lobster[msg.sender], \"!lobster\");\r\n    require(_distributed >= _CAP || block.timestamp > _DEADLINE, \"!closed\");\r\n\r\n\r\n    _cleanup();\r\n\r\n    _lobster[msg.sender] = false;\r\n\r\n    IERC20(_GLOVE).safeTransfer(msg.sender, _lobsters[msg.sender]);\r\n\r\n\r\n    emit Collect(msg.sender);\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\n\r\ninterface IERC20\r\n{\r\n  function name () external view returns (string memory);\r\n\r\n  function symbol () external view returns (string memory);\r\n\r\n  function decimals () external view returns (uint8);\r\n\r\n  function totalSupply () external view returns (uint256);\r\n\r\n  function balanceOf (address account) external view returns (uint256);\r\n\r\n\r\n  function allowance (address owner, address spender) external view returns (uint256);\r\n\r\n  function approve (address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n  function transfer (address to, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom (address from, address to, uint256 amount) external returns (bool);\r\n\r\n\r\n  function mint (address account, uint256 amount) external;\r\n\r\n  function burn (address account, uint256 amount) external;\r\n}"
    },
    "contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\n\r\nabstract contract ReentrancyGuard\r\n{\r\n  uint256 private _status = 1;\r\n\r\n\r\n  modifier nonReentrant ()\r\n  {\r\n    require(_status == 1, \"reentrance\");\r\n\r\n\r\n    _status = 2;\r\n\r\n    _;\r\n\r\n    _status = 1;\r\n  }\r\n}\r\n"
    },
    "contracts/utils/SafeToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { IERC20 } from \"../interfaces/IERC20.sol\";\r\n\r\n\r\nlibrary SafeToken\r\n{\r\n  function _getRevertErr (bytes memory data, string memory message) private pure returns (string memory)\r\n  {\r\n    if (data.length < 68)\r\n    {\r\n      return message;\r\n    }\r\n\r\n\r\n    assembly\r\n    {\r\n      data := add(data, 0x04)\r\n    }\r\n\r\n\r\n    return abi.decode(data, (string));\r\n  }\r\n\r\n\r\n  function _call (address token, bytes memory encoded, string memory message) private\r\n  {\r\n    (bool success, bytes memory data) = token.call(encoded);\r\n\r\n\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), _getRevertErr(data, message));\r\n  }\r\n\r\n  function safeApprove (IERC20 token, address spender, uint256 amount) internal\r\n  {\r\n    _call(address(token), abi.encodeWithSelector(IERC20.approve.selector, spender, amount), \"!sa\");\r\n  }\r\n\r\n  function safeTransfer (IERC20 token, address to, uint256 amount) internal\r\n  {\r\n    _call(address(token), abi.encodeWithSelector(IERC20.transfer.selector, to, amount), \"!st\");\r\n  }\r\n\r\n  function safeTransferFrom (IERC20 token, address from, address to, uint256 amount) internal\r\n  {\r\n    _call(address(token), abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount), \"!stf\");\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}