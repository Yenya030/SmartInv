{{
  "language": "Solidity",
  "sources": {
    "/contracts/EsgSHIPV2.sol": {
      "content": "pragma solidity >=0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./EIP20Interface.sol\";\nimport \"./SafeMath.sol\";\n\ncontract EsgSHIPV2{\n    using SafeMath for uint256;\n    /// @notice ESG token\n    EIP20Interface public esg;\n\n    /// @notice Emitted when referral set invitee\n    event SetInvitee(address inviteeAddress);\n\n    /// @notice Emitted when owner set referral\n    event SetInviteeByOwner(address referralAddress);\n\n    /// @notice Emitted when ESG is invest  \n    event EsgInvest(address account, uint amount, uint month, bool useInterest);\n\n    /// @notice Emitted when ESG is invest by owner  \n    event EsgInvestByOwner(address account, uint amount, uint month, uint starttime, uint endtime);\n\n    /// @notice Emitted when ESG is withdrawn \n    event EsgWithdraw(address account, uint amount);\n\n    /// @notice Emitted when ESG is claimed \n    event EsgClaimed(address account, uint amount);\n\n    /// @notice Emitted when change referral info\n    event EsgChangeReferrerInfo(address referralAddress, address inviteeAddress, address newInviteeAddress);\n\n    /// @notice Emitted when change Lock info\n    event EsgChangeLockInfo(address _user, uint256 _amount, uint256 _start, uint256 _end, uint256 _month, uint256 i);\n\n    struct Lock {\n        uint256 amount;\n        uint256 start;\n        uint256 end;\n        uint256 month;\n    }\n\n    mapping(uint256 => uint256) public lockRates;\n\n    mapping(address => Lock[]) public locks;\n\n    mapping(address => uint256) public interests;\n\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    struct Referrer {\n        address[] referrals;\n        uint256 totalInvestment;\n        bool dynamicReward;\n    }\n\n    mapping(address => Referrer) public referrers;\n\n    struct User {\n        address referrer_addr;\n    }\n\n    mapping (address => User) public referrerlist;\n\n    uint256 public referralThreshold = 3000 * 1e18;\n\n    uint256 public dynamicRewardThreshold = 100000 * 1e18;\n\n    uint256 public onetimeRewardPercentage = 7;\n\n    uint256 public dynamicRewardPercentage = 4;\n\n    uint256 public dynamicRewardPercentageEvery = 10;\n\n    uint256 public burnPercentage = 5;\n\n    uint256 public total_deposited;\n\n    uint256 public total_user;\n\n    bool public allow_get_esg = true;\n\n    constructor(address esgAddress) public {\n        owner = msg.sender;\n        lockRates[9] = 50;\n        lockRates[12] = 60;\n        lockRates[18] = 100;\n        esg = EIP20Interface(esgAddress);\n    }\n\n    function setLockRate(uint256 _months, uint256 _rate) public onlyOwner {\n        lockRates[_months] = _rate;\n    }\n\n    function setReferralThreshold(uint256 _amount) public onlyOwner {\n        referralThreshold = _amount;\n    }\n\n    function setDynamicRewardThreshold(uint256 _amount) public onlyOwner {\n        dynamicRewardThreshold = _amount;\n    }\n\n    function setOnetimeRewardPercentage(uint256 _percentage) public onlyOwner {\n        onetimeRewardPercentage = _percentage;\n    }\n\n    function setDynamicRewardPercentage(uint256 _percentage) public onlyOwner {\n        dynamicRewardPercentage = _percentage;\n    }\n\n    function setDynamicRewardPercentageEvery(uint256 _percentage) public onlyOwner {\n        dynamicRewardPercentageEvery = _percentage;\n    }\n\n    function setBurnPercentage(uint256 _percentage) public onlyOwner {\n        burnPercentage = _percentage;\n    }\n\n    function setInvitee(address inviteeAddress) public returns (bool) {\n        require(inviteeAddress != address(0), \"inviteeAddress cannot be 0x0.\");\n\n        User storage user = referrerlist[inviteeAddress];\n        require(user.referrer_addr == address(0), \"This account had been invited!\");\n\n        Lock[] storage referrerLocks = locks[msg.sender];\n        require(referrerLocks.length > 0, \"Referrer has no locked amount.\");\n\n        uint256 referrerAmount = 0;\n\n        for (uint256 i = 0; i < referrerLocks.length; i++) {\n            Lock storage lock = referrerLocks[i];\n            referrerAmount += lock.amount;\n        }\n\n        require(referrerAmount >= referralThreshold,\"Referrer has no referral qualification.\");\n\n        Lock[] storage inviteeLocks = locks[inviteeAddress];\n        require(inviteeLocks.length == 0, \"This account had staked!\");\n\n        Referrer storage referrer = referrers[msg.sender];\n        referrer.referrals.push(inviteeAddress);\n\n        User storage _user = referrerlist[inviteeAddress];\n        _user.referrer_addr = msg.sender;\n\n        emit SetInvitee(inviteeAddress);\n        return true;   \n    }\n\n    function setInviteeByOwner(address referrerAddress, address[] memory inviteeAddress) public onlyOwner returns (bool) {\n        require(referrerAddress != address(0), \"referrerAddress cannot be 0x0.\");\n        require(inviteeAddress.length > 0, \"inviteeAddress cannot be 0.\");\n\n        Referrer storage referrer = referrers[referrerAddress];\n        referrer.referrals = inviteeAddress;\n\n        for(uint256 i = 0; i < inviteeAddress.length; i++){\n            address _inviteeAddress = inviteeAddress[i];\n            User storage _user = referrerlist[_inviteeAddress];\n            if(_user.referrer_addr == address(0)){\n                _user.referrer_addr = referrerAddress;\n            }\n        }\n\n        emit SetInviteeByOwner(referrerAddress);\n        return true;   \n    }\n\n    function getInviteelist(address referrerAddress) public view returns (address[] memory) {\n        require(referrerAddress != address(0), \"referrerAddress cannot be 0x0.\");\n        Referrer storage referrer = referrers[referrerAddress];\n        return referrer.referrals;\n    }\n\n    function getReferrer(address inviteeAddress) public view returns (address) {\n        require(inviteeAddress != address(0), \"inviteeAddress cannot be 0x0.\");\n        User storage user = referrerlist[inviteeAddress];\n        return user.referrer_addr;\n    }\n\n    function invest(uint256 _months, uint256 _amount, bool _useInterest) public returns (bool) {\n        require(allow_get_esg == true, \"No invest allowed!\");\n        require(lockRates[_months] > 0, \"Invalid lock period.\");\n        require(_amount > 0, \"Invalid amount.\");\n\n        if (_useInterest) {\n            uint256 interest = calculateInterest(msg.sender);\n            require(interest >= _amount, \"Insufficient interest.\");\n            interests[msg.sender] -= _amount;\n        } else {\n            esg.transferFrom(msg.sender, address(this), _amount);\n        }\n\n        locks[msg.sender].push(\n            Lock(\n                _amount,\n                block.timestamp,\n                block.timestamp + _months * 30 days,\n                _months\n            )\n        );\n\n        total_deposited = total_deposited + _amount;\n        total_user = total_user + 1;\n            \n        User storage user = referrerlist[msg.sender];\n\n        if(user.referrer_addr != address(0)){\n            referrers[user.referrer_addr].totalInvestment += _amount;\n\n            if (referrers[user.referrer_addr].totalInvestment >= dynamicRewardThreshold) {\n                referrers[user.referrer_addr].dynamicReward = true;\n            }\n            uint256 onetimeTotalReward = _amount.mul(lockRates[_months]).div(100).mul(onetimeRewardPercentage).div(100);\n            uint256 onetimeReward = onetimeTotalReward.div(12).mul(_months);\n            esg.transfer(user.referrer_addr, onetimeReward);\n        }\n\n        emit EsgInvest(msg.sender, _amount, _months, _useInterest);\n        return true;\n    }\n\n    function investByOwner(uint256 start, uint256 end, uint256 _amount, uint256 month, address inviteeAddress) public onlyOwner returns (bool) {\n        require(start > 0, \"start cannot be 0.\");\n        require(end > 0, \"start cannot be 0.\");\n        require(_amount > 0, \"Invalid amount.\");\n        require(month > 0, \"month cannot be 0.\");\n        require(inviteeAddress != address(0), \"inviteeAddress cannot be 0x0.\");\n\n        locks[inviteeAddress].push(\n            Lock(\n                _amount,\n                start,\n                end,\n                month\n            )\n        );\n\n        total_deposited = total_deposited + _amount;\n        total_user = total_user + 1;\n            \n        User storage user = referrerlist[inviteeAddress];\n\n        if(user.referrer_addr != address(0)){\n            referrers[user.referrer_addr].totalInvestment += _amount;\n\n            if (referrers[user.referrer_addr].totalInvestment >= dynamicRewardThreshold) {\n                referrers[user.referrer_addr].dynamicReward = true;\n            }\n        }\n\n        emit EsgInvestByOwner(inviteeAddress, _amount, month, start, end);\n        return true;\n    }\n\n    function withdraw() public returns (bool) {\n        require(allow_get_esg == true, \"No withdrawal allowed!\");\n        Lock[] storage userLocks = locks[msg.sender];\n        require(userLocks.length > 0, \"No locked amount.\");\n\n        uint256 totalAmount = 0;\n        uint256 index = 0;\n        uint256 totalInterest = interests[msg.sender];\n\n        while (index < userLocks.length) {\n            Lock storage lock = userLocks[index];\n            if (block.timestamp >= lock.end) {\n                totalAmount += lock.amount;\n                userLocks[index] = userLocks[userLocks.length - 1];\n                userLocks.pop();\n                uint256 interest = (block.timestamp.sub(lock.start)).mul(lock.amount).mul(lockRates[lock.month]).div(100).div(360).div(86400);\n                if (interest > 0) {\n                    totalInterest += interest;\n                    lock.start = block.timestamp;\n                    totalAmount += totalInterest;\n                }\n            } else {\n                index++;\n            }\n        }\n\n        require(totalAmount > 0, \"No amount to withdraw.\");\n\n        esg.transfer(msg.sender, totalAmount);\n\n        interests[msg.sender] = 0;\n        total_deposited -= totalAmount;\n\n        User storage user = referrerlist[msg.sender];\n\n        if (user.referrer_addr != address(0)) {\n            referrers[user.referrer_addr].totalInvestment -= totalAmount;\n\n            if (referrers[user.referrer_addr].totalInvestment < dynamicRewardThreshold) {\n                referrers[user.referrer_addr].dynamicReward = false;\n            }\n        }\n\n        uint256 userAmount = 0;\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock storage lock = userLocks[i];\n            userAmount += lock.amount;\n        }\n\n        if (userAmount < referralThreshold) {\n            Referrer storage referrer = referrers[msg.sender];\n            if(referrer.referrals.length > 0){\n                for(uint256 i = 0; i < referrer.referrals.length; i++){\n                    address invitee_add = referrer.referrals[i];\n                    delete referrerlist[invitee_add];\n                }\n            }\n            delete referrers[msg.sender].referrals;\n        }\n\n        emit EsgWithdraw(msg.sender, totalAmount); \n        return true;\n    }\n\n    function claim() public returns (bool) {\n        require(allow_get_esg == true, \"No claim allowed!\");\n        Lock[] storage userLocks = locks[msg.sender];\n        require(userLocks.length > 0, \"No locked amount.\");\n\n        uint256 totalInterest = interests[msg.sender];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock storage lock = userLocks[i];\n            uint256 interest = (block.timestamp.sub(lock.start)).mul(lock.amount).mul(lockRates[lock.month]).div(100).div(360).div(86400);\n            if (interest > 0) {\n                totalInterest += interest;\n                lock.start = block.timestamp;\n            }\n        }\n\n        require(totalInterest > 0, \"No interest to claim.\");\n\n        interests[msg.sender] = 0;\n\n        uint256 burnAmount = totalInterest.mul(burnPercentage).div(1000);\n        esg.transfer(address(esg), burnAmount);\n        totalInterest -= burnAmount;\n\n        esg.transfer(msg.sender, totalInterest);\n\n        Referrer storage referrer = referrers[msg.sender];\n        User storage user = referrerlist[msg.sender];\n\n        if (user.referrer_addr != address(0)) {\n            uint256 dynamicRewardEvery = totalInterest.mul(dynamicRewardPercentageEvery).div(100);\n            esg.transfer(user.referrer_addr, dynamicRewardEvery);\n            if (referrers[user.referrer_addr].dynamicReward) {\n                uint256 dynamicReward = totalInterest.mul(dynamicRewardPercentage).div(100);\n                esg.transfer(user.referrer_addr, dynamicReward);\n            }\n        }\n\n        emit EsgClaimed (msg.sender, totalInterest); \n        return true;\n    }\n\n    function calculateInterest(address _user) public view returns (uint256) {\n        Lock[] storage userLocks = locks[_user];\n        if (userLocks.length == 0) {\n            return 0;\n        }\n        uint256 totalInterest = interests[_user];\n\n        for (uint256 i = 0; i < userLocks.length; i++) {\n            Lock storage lock = userLocks[i];\n            uint256 interest = (block.timestamp.sub(lock.start)).mul(lock.amount).mul(lockRates[lock.month]).div(100).div(360).div(86400);\n            if (interest > 0) {\n                totalInterest += interest;\n            }\n        }\n\n        return totalInterest;\n    }\n\n    function getLockInfo(address _user) public view returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        Lock[] storage userLocks = locks[_user];\n                uint256 length = userLocks.length;\n\n        uint256[] memory amounts = new uint256[](length);\n        uint256[] memory starts = new uint256[](length);\n        uint256[] memory ends = new uint256[](length);\n        uint256[] memory rates = new uint256[](length);\n        uint256[] memory interest = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Lock storage lock = userLocks[i];\n            amounts[i] = lock.amount;\n            starts[i] = lock.start;\n            ends[i] = lock.end;\n            rates[i] = lockRates[lock.month];\n            interest[i] = (block.timestamp.sub(lock.start)).mul(lock.amount).mul(lockRates[lock.month]).div(100).div(360).div(86400);\n        }\n\n        return (amounts, starts, ends, rates, interest);\n    }\n\n    function changeReferrerInfo(address referralAddress, address inviteeAddress, address newInviteeAddress) public onlyOwner returns (bool) {\n        require(referralAddress != address(0), \"referralAddress cannot be 0x0.\");\n        require(inviteeAddress != address(0), \"inviteeAddress cannot be 0x0.\");\n        require(newInviteeAddress != address(0), \"newInviteeAddress cannot be 0x0.\");\n\n        Referrer storage referrer = referrers[referralAddress];\n        if(referrer.referrals.length > 0){\n            for(uint256 i = 0; i < referrer.referrals.length; i++){\n                address invitee_add = referrer.referrals[i];\n                if(inviteeAddress == invitee_add){\n                    referrer.referrals[i] = newInviteeAddress;\n                    break;\n                }\n            }\n        }\n\n        delete referrerlist[inviteeAddress];\n        User storage _user = referrerlist[newInviteeAddress];\n        _user.referrer_addr = referralAddress;\n\n        emit EsgChangeReferrerInfo(referralAddress, inviteeAddress, newInviteeAddress);\n        return true;\n    }\n\n    function changeLockInfo(address _user, uint256 _amount, uint256 _start, uint256 _end, uint256 _month, uint256 i) public onlyOwner returns (bool) {\n        require(_user != address(0), \"_user cannot be 0x0.\");\n        Lock storage userLocks = locks[_user][i];\n        userLocks.amount = _amount;\n        userLocks.start = _start;\n        userLocks.end = _end;\n        userLocks.month = _month;\n\n        emit EsgChangeLockInfo(_user, _amount, _start, _end, _month, i);\n        return true;\n    }\n\n    function close() public onlyOwner {\n        allow_get_esg = false;\n    }\n\n    function open() public onlyOwner {\n        allow_get_esg = true;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        if (newOwner != address(0)) {\n        owner = newOwner;\n      }\n    }\n}\n"
    },
    "/contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.5.16;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    /**\n   * @dev gives square root of given x.\n   */\n  function sqrt(uint256 x) internal pure returns(uint256 y) {\n        uint256 z = ((add(x, 1)) / 2);\n        y = x;\n        while (z < y) {\n            y = z;\n            z = ((add((x / z), z)) / 2);\n        }\n  }\n\n  /**\n   * @dev gives square. multiplies x by x\n   */\n  function sq(uint256 x) internal pure returns(uint256) {\n       return (mul(x, x));\n  }\n\n  /**\n   * @dev x to the power of y\n   */\n  function pwr(uint256 x, uint256 y) internal pure returns(uint256) {\n    if (x == 0)\n      return (0);\n    else if (y == 0)\n      return (1);\n    else {\n      uint256 z = x;\n      for (uint256 i = 1; i < y; i++)\n        z = mul(z, x);\n      return (z);\n    }\n  }\n}"
    },
    "/contracts/EIP20Interface.sol": {
      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    /**\n      * @notice Get the total number of tokens in circulation\n      * @return The supply of tokens\n      */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return Whether or not the transfer succeeded\n      */\n    function transfer(address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return Whether or not the transfer succeeded\n      */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return The number of tokens allowed to be spent (-1 means infinite)\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 300
    },
    "evmVersion": "istanbul",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}