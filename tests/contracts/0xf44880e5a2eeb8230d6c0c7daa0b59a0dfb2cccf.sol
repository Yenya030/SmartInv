{{
  "language": "Solidity",
  "sources": {
    "contracts/producers/editions/EditionsFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {Ownable} from \"../../lib/Ownable.sol\";\nimport {Clones} from \"../../lib/Clones.sol\";\nimport {IEditionsFactory, IEditionsFactoryEvents} from \"./interface/IEditionsFactory.sol\";\nimport {IEditions} from \"./interface/IEditions.sol\";\n\ninterface ITributaryRegistry {\n    function registerTributary(address producer, address tributary) external;\n}\n\n/**\n * @title EditionsFactory\n * @notice The EditionsFactory contract is used to deploy edition clones.\n * @author MirrorXYZ\n */\ncontract EditionsFactory is Ownable, IEditionsFactoryEvents, IEditionsFactory {\n    /// @notice Address that holds the implementation for Crowdfunds\n    address public implementation;\n\n    /// @notice Mirror tributary registry\n    address public tributaryRegistry;\n\n    constructor(\n        address owner_,\n        address implementation_,\n        address tributaryRegistry_\n    ) Ownable(owner_) {\n        implementation = implementation_;\n        tributaryRegistry = tributaryRegistry_;\n    }\n\n    // ======== Admin function =========\n    function setImplementation(address implementation_)\n        external\n        override\n        onlyOwner\n    {\n        require(implementation_ != address(0), \"must set implementation\");\n\n        emit ImplementationSet(implementation, implementation_);\n\n        implementation = implementation_;\n    }\n\n    function setTributaryRegistry(address tributaryRegistry_)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            tributaryRegistry_ != address(0),\n            \"must set tributary registry\"\n        );\n\n        emit TributaryRegistrySet(tributaryRegistry, tributaryRegistry_);\n\n        tributaryRegistry = tributaryRegistry_;\n    }\n\n    // ======== Deploy function =========\n\n    /// @notice Deploys a new edition (ERC721) clone, and register tributary.\n    /// @param owner_ the clone owner\n    /// @param tributary the tributary receive tokens in behalf of the clone fees\n    /// @param name_ the name for the edition clone\n    /// @param symbol_ the symbol for the edition clone\n    /// @param description_ the description for the edition clone\n    /// @param contentURI_ the contentURI for the edition clone\n    /// @param animationURI_ the animationURI for the edition clone\n    /// @param contractURI_ the contractURI for the edition clone\n    /// @param edition_ the parameters for the edition sale\n    /// @param nonce additional entropy for the clone salt parameter\n    /// @param paused_ the pause state for the edition sale\n    function create(\n        address owner_,\n        address tributary,\n        string memory name_,\n        string memory symbol_,\n        string memory description_,\n        string memory contentURI_,\n        string memory animationURI_,\n        string memory contractURI_,\n        IEditions.Edition memory edition_,\n        uint256 nonce,\n        bool paused_\n    ) external override returns (address clone) {\n        clone = Clones.cloneDeterministic(\n            implementation,\n            keccak256(abi.encode(owner_, name_, symbol_, nonce))\n        );\n\n        IEditions(clone).initialize(\n            owner_,\n            name_,\n            symbol_,\n            description_,\n            contentURI_,\n            animationURI_,\n            contractURI_,\n            edition_,\n            paused_\n        );\n\n        emit EditionsDeployed(owner_, clone, implementation);\n\n        if (tributaryRegistry != address(0)) {\n            ITributaryRegistry(tributaryRegistry).registerTributary(\n                clone,\n                tributary\n            );\n        }\n    }\n\n    function predictDeterministicAddress(address implementation_, bytes32 salt)\n        external\n        view\n        override\n        returns (address)\n    {\n        return\n            Clones.predictDeterministicAddress(\n                implementation_,\n                salt,\n                address(this)\n            );\n    }\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IOwnableEvents {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n\ncontract Ownable is IOwnableEvents {\n    address public owner;\n    address private nextOwner;\n\n    // modifiers\n\n    modifier onlyOwner() {\n        require(isOwner(), \"caller is not the owner.\");\n        _;\n    }\n\n    modifier onlyNextOwner() {\n        require(isNextOwner(), \"current owner must set caller as next owner.\");\n        _;\n    }\n\n    /**\n     * @dev Initialize contract by setting transaction submitter as initial owner.\n     */\n    constructor(address owner_) {\n        owner = owner_;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Initiate ownership transfer by setting nextOwner.\n     */\n    function transferOwnership(address nextOwner_) external onlyOwner {\n        require(nextOwner_ != address(0), \"Next owner is the zero address.\");\n\n        nextOwner = nextOwner_;\n    }\n\n    /**\n     * @dev Cancel ownership transfer by deleting nextOwner.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        delete nextOwner;\n    }\n\n    /**\n     * @dev Accepts ownership transfer by setting owner.\n     */\n    function acceptOwnership() external onlyNextOwner {\n        delete nextOwner;\n\n        owner = msg.sender;\n\n        emit OwnershipTransferred(owner, msg.sender);\n    }\n\n    /**\n     * @dev Renounce ownership by setting owner to zero address.\n     */\n    function renounceOwnership() external onlyOwner {\n        _renounceOwnership();\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner;\n    }\n\n    /**\n     * @dev Returns true if the caller is the next owner.\n     */\n    function isNextOwner() public view returns (bool) {\n        return msg.sender == nextOwner;\n    }\n\n    function _setOwner(address previousOwner, address newOwner) internal {\n        owner = newOwner;\n        emit OwnershipTransferred(previousOwner, owner);\n    }\n\n    function _renounceOwnership() internal {\n        emit OwnershipTransferred(owner, address(0));\n\n        owner = address(0);\n    }\n}\n"
    },
    "contracts/lib/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Copy of OpenZeppelin's Clones contract\n * https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(\n                ptr,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(\n                add(ptr, 0x28),\n                0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000\n            )\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/producers/editions/interface/IEditionsFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {IEditions} from \"./IEditions.sol\";\n\ninterface IEditionsFactoryEvents {\n    event EditionsDeployed(\n        address indexed owner,\n        address indexed clone,\n        address indexed implementation\n    );\n\n    event TributaryRegistrySet(\n        address indexed oldTributaryRegistry,\n        address indexed newTributaryRegistry\n    );\n\n    event ImplementationSet(\n        address indexed oldImplementation,\n        address indexed newImplementation\n    );\n}\n\ninterface IEditionsFactory {\n    function setImplementation(address implementation_) external;\n\n    function setTributaryRegistry(address tributaryRegistry_) external;\n\n    function create(\n        address owner,\n        address tributary,\n        string memory name_,\n        string memory symbol_,\n        string memory description_,\n        string memory contentURI_,\n        string memory animationURI_,\n        string memory contractURI_,\n        IEditions.Edition memory edition_,\n        uint256 nonce,\n        bool paused_\n    ) external returns (address clone);\n\n    function predictDeterministicAddress(address implementation_, bytes32 salt)\n        external\n        view\n        returns (address);\n}\n"
    },
    "contracts/producers/editions/interface/IEditions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\ninterface IEditionsEvents {\n    event EditionPurchased(\n        uint256 indexed tokenId,\n        address indexed nftRecipient,\n        uint256 amountPaid\n    );\n\n    event RoyaltyChange(\n        address indexed oldRoyaltyRecipient,\n        uint256 oldRoyaltyBPS,\n        address indexed newRoyaltyRecipient,\n        uint256 newRoyaltyBPS\n    );\n\n    event RendererSet(address indexed renderer);\n\n    event EditionLimitSet(uint256 oldLimit, uint256 newLimit);\n\n    event Withdrawal(address indexed recipient, uint256 amount, uint256 fee);\n\n    event FundingRecipientSet(\n        address indexed oldFundingRecipient,\n        address indexed newFundingRecipient\n    );\n\n    event PriceSet(uint256 price);\n}\n\ninterface IEditions {\n    struct Edition {\n        // Edition price\n        uint256 price;\n        // Edition supply limit\n        uint256 limit;\n    }\n\n    // ============ Authorization ============\n\n    function factory() external returns (address);\n\n    // ============ Fee Configuration ============\n\n    function feeConfig() external returns (address);\n\n    function treasuryConfig() external returns (address);\n\n    // ============ Edition Data ============\n\n    function description() external view returns (string memory);\n\n    function price() external returns (uint256);\n\n    function limit() external returns (uint256);\n\n    // ============ Royalty Info (ERC2981) ============\n\n    function royaltyRecipient() external returns (address);\n\n    function royaltyBPS() external returns (uint256);\n\n    // ============ Rendering ============\n\n    function renderer() external view returns (address);\n\n    // ============ Initializing ============\n\n    function initialize(\n        address owner_,\n        string memory name_,\n        string memory symbol_,\n        string memory description_,\n        string memory contentURI_,\n        string memory animationURI_,\n        string memory contractURI_,\n        Edition memory edition_,\n        bool paused_\n    ) external;\n\n    // ============ Pause Methods ============\n\n    function unpause() external;\n\n    function pause() external;\n\n    // ============ Allocation ============\n\n    function allocate(address recipient, uint256 count) external;\n\n    // ============ Purchase ============\n\n    function purchase(address recipient)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // ============ Minting ============\n\n    function mint(address recipient) external returns (uint256 tokenId);\n\n    function setLimit(uint256 limit_) external;\n\n    // ============ ERC2981 Methods ============\n\n    function setRoyaltyInfo(\n        address payable royaltyRecipient_,\n        uint256 royaltyPercentage_\n    ) external;\n\n    // ============ Rendering Methods ============\n\n    function setRenderer(address renderer_) external;\n\n    function contractURI() external view returns (string memory);\n\n    // ============ Withdrawal ============\n\n    function setPrice(uint256 price_) external;\n\n    function withdraw(uint16 feeBPS, address fundingRecipient) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}