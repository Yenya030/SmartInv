{{
  "language": "Solidity",
  "sources": {
    "src/VeryFastRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMPairERC20} from \"./LSSVMPairERC20.sol\";\nimport {ILSSVMPairERC721} from \"./erc721/ILSSVMPairERC721.sol\";\nimport {LSSVMPairERC1155} from \"./erc1155/LSSVMPairERC1155.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\nimport {ICurve} from \"./bonding-curves/ICurve.sol\";\n\n/**\n * @dev Full-featured router to handle all swap types, with partial fill support\n */\ncontract VeryFastRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    // Bit shift amounts for _findMaxFillableAmtForBuy and _findMaxFillableAmtForSell\n    uint256 private constant FEE_MULTIPLIER_SHIFT_AMOUNT = 160;\n    uint256 private constant DELTA_SHIFT_AMOUNT = 128;\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    struct BuyOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isERC721;\n        uint256[] nftIds;\n        uint256 maxInputAmount;\n        uint256 ethAmount;\n        uint256 expectedSpotPrice;\n        uint256[] maxCostPerNumNFTs; // @dev This is zero-indexed, so maxCostPerNumNFTs[x] = max price we're willing to pay to buy x+1 NFTs\n    }\n\n    struct SellOrderWithPartialFill {\n        LSSVMPair pair;\n        bool isETHSell;\n        bool isERC721;\n        uint256[] nftIds;\n        bool doPropertyCheck;\n        bytes propertyCheckParams;\n        uint128 expectedSpotPrice;\n        uint256 minExpectedOutput;\n        uint256[] minExpectedOutputPerNumNFTs;\n    }\n\n    struct Order {\n        BuyOrderWithPartialFill[] buyOrders;\n        SellOrderWithPartialFill[] sellOrders;\n        address payable tokenRecipient;\n        address nftRecipient;\n        bool recycleETH;\n    }\n\n    struct PartialFillSellArgs {\n        LSSVMPair pair;\n        uint128 spotPrice;\n        uint256 maxNumNFTs;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n    }\n\n    struct PartialFillSellHelperArgs {\n        LSSVMPair pair;\n        uint256[] minOutputPerNumNFTs;\n        uint256 protocolFeeMultiplier;\n        uint256 nftId;\n        uint256 start;\n        uint256 end;\n        uint128 delta;\n        uint128 spotPrice;\n        uint256 feeMultiplier;\n        uint256 pairTokenBalance;\n        uint256 royaltyAmount;\n        uint256 numItemsToFill;\n        uint256 priceToFillAt;\n    }\n\n    error VeryFastRouter__InvalidPair();\n    error VeryFastRouter__BondingCurveQuoteError();\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /**\n     * @dev Meant to be used as a client-side utility\n     * @notice Given a pair and a number of items to buy, calculate the max price paid for 1 up to numNFTs to buy\n     */\n    function getNFTQuoteForBuyOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 assetId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory prices = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been bought and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterBuying(pair, i);\n            }\n\n            // Calculate price to purchase the remaining numNFTs - i items\n            uint256 price = _getHypotheticalNewPoolParamsAfterBuying(pair, newSpotPrice, newDelta, numNFTs - i);\n\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(assetId, price);\n            price += royaltyTotal;\n\n            // Set the price to buy numNFTs - i items\n            prices[numNFTs - i - 1] = price;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale up by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i; i < prices.length;) {\n                prices[i] += (prices[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        return prices;\n    }\n\n    function _getNewPoolParamsAfterBuying(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getBuyInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterBuying(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getBuyInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function getPairBaseQuoteTokenBalance(LSSVMPair pair) public view returns (uint256 balance) {\n        ILSSVMPairFactoryLike.PairVariant variant = pair.pairVariant();\n        if (\n            variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ETH\n                || variant == ILSSVMPairFactoryLike.PairVariant.ERC1155_ETH\n        ) {\n            balance = address(pair).balance;\n        } else {\n            balance = ERC20(LSSVMPairERC20(address(pair)).token()).balanceOf(address(pair));\n        }\n    }\n\n    function _wrapUintAsArray(uint256 valueToWrap) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n        arr[0] = valueToWrap;\n        return arr;\n    }\n\n    /**\n     * @dev Meant to be used as a client-side utility\n     * @notice Given a pair and a number of items to sell, calculate the mininum output for selling 1 to numNFTs\n     */\n    function getNFTQuoteForSellOrderWithPartialFill(\n        LSSVMPair pair,\n        uint256 numNFTs,\n        uint256 slippageScaling,\n        uint256 nftId\n    ) external view returns (uint256[] memory) {\n        uint256[] memory outputAmounts = new uint256[](numNFTs);\n\n        for (uint256 i; i < numNFTs;) {\n            uint128 newSpotPrice = pair.spotPrice();\n            uint128 newDelta = pair.delta();\n\n            // Assume that i items have been sold and get the new params\n            if (i != 0) {\n                (newSpotPrice, newDelta) = _getNewPoolParamsAfterSelling(pair, i);\n            }\n\n            // Calculate output to sell the remaining numNFTs - i items, factoring in royalties and fees\n            uint256 output = _getHypotheticalNewPoolParamsAfterSelling(pair, newSpotPrice, newDelta, numNFTs - i);\n            (,, uint256 royaltyTotal) = pair.calculateRoyaltiesView(nftId, output);\n            output -= royaltyTotal;\n\n            outputAmounts[numNFTs - i - 1] = output;\n\n            unchecked {\n                ++i;\n            }\n        }\n        // Scale down by slippage amount\n        if (slippageScaling != 0) {\n            for (uint256 i; i < outputAmounts.length;) {\n                outputAmounts[i] -= (outputAmounts[i] * slippageScaling / 1e18);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        return outputAmounts;\n    }\n\n    function _getNewPoolParamsAfterSelling(LSSVMPair pair, uint256 i)\n        internal\n        view\n        returns (uint128 newSpotPrice, uint128 newDelta)\n    {\n        CurveErrorCodes.Error errorCode;\n        (errorCode, newSpotPrice, newDelta,,,) = pair.bondingCurve().getSellInfo(\n            pair.spotPrice(), pair.delta(), i, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    function _getHypotheticalNewPoolParamsAfterSelling(\n        LSSVMPair pair,\n        uint128 newSpotPrice,\n        uint128 newDelta,\n        uint256 num\n    ) internal view returns (uint256 output) {\n        CurveErrorCodes.Error errorCode;\n        (errorCode,,, output,,) = pair.bondingCurve().getSellInfo(\n            newSpotPrice, newDelta, num, pair.fee(), pair.factory().protocolFeeMultiplier()\n        );\n        if (errorCode != CurveErrorCodes.Error.OK) {\n            revert VeryFastRouter__BondingCurveQuoteError();\n        }\n    }\n\n    /**\n     * @dev Performs a batch of sells and buys, avoids performing swaps where the price is beyond\n     * Handles selling NFTs for tokens or ETH\n     * Handles buying NFTs with tokens or ETH,\n     * @param swapOrder The struct containing all the swaps to be executed\n     * @return results Indices [0..swapOrder.sellOrders.length-1] contain the actual output amounts of the\n     * sell orders, indices [swapOrder.sellOrders.length..swapOrder.sellOrders.length+swapOrder.buyOrders.length-1]\n     * contain the actual input amounts of the buy orders.\n     */\n    function swap(Order calldata swapOrder) external payable returns (uint256[] memory results) {\n        uint256 ethAmount = msg.value;\n\n        // Get protocol to reduce gas on the _findMaxFillableAmtForSell/_findMaxFillableAmtForBuy calls\n        uint256 protocolFeeMultiplier = factory.protocolFeeMultiplier();\n\n        results = new uint256[](swapOrder.buyOrders.length + swapOrder.sellOrders.length);\n\n        // Go through each sell order\n        for (uint256 i; i < swapOrder.sellOrders.length;) {\n            SellOrderWithPartialFill calldata order = swapOrder.sellOrders[i];\n            uint128 pairSpotPrice = order.pair.spotPrice();\n            uint256 outputAmount;\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (pairSpotPrice == order.expectedSpotPrice) {\n                // If the pair is an ETH pair and we opt into recycling ETH, add the output to our total accrued\n                if (order.isETHSell && swapOrder.recycleETH) {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            payable(address(this)),\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, payable(address(this)), true, msg.sender\n                        );\n                    }\n\n                    // Accumulate ETH amount\n                    ethAmount += outputAmount;\n                }\n                // Otherwise, all tokens or ETH received from the sale go to the token recipient\n                else {\n                    // Pass in params for property checking if needed\n                    // Then do the swap with the same minExpectedTokenOutput amount\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds,\n                            order.minExpectedOutput,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    } else {\n                        outputAmount = order.pair.swapNFTsForToken(\n                            order.nftIds, order.minExpectedOutput, swapOrder.tokenRecipient, true, msg.sender\n                        );\n                    }\n                }\n            }\n            // Otherwise we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    // Grab royalty for calc in _findMaxFillableAmtForSell\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // Calculate the max number of items we can sell\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(\n                        order.pair,\n                        pairSpotPrice,\n                        order.minExpectedOutputPerNumNFTs,\n                        protocolFeeMultiplier,\n                        royaltyAmount\n                    );\n                }\n\n                // If we can sell at least 1 item...\n                if (numItemsToFill != 0) {\n                    // If property checking is needed, do the property check swap\n                    if (order.doPropertyCheck) {\n                        outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n                            order.nftIds[:numItemsToFill],\n                            priceToFillAt,\n                            swapOrder.tokenRecipient,\n                            true,\n                            msg.sender,\n                            order.propertyCheckParams\n                        );\n                    }\n                    // Otherwise do a normal sell swap\n                    else {\n                        // Get subarray if ERC721\n                        if (order.isERC721) {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n                            );\n                        }\n                        // For 1155 swaps, wrap as number\n                        else {\n                            outputAmount = order.pair.swapNFTsForToken(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.tokenRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n                }\n            }\n            results[i] = outputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Go through each buy order\n        for (uint256 i; i < swapOrder.buyOrders.length;) {\n            BuyOrderWithPartialFill calldata order = swapOrder.buyOrders[i];\n\n            // @dev We use inputAmount to store the spot price temporarily before it's overwritten\n            // (yes, it's gross)\n            uint256 inputAmount = order.pair.spotPrice();\n\n            // If the spot price parameter seen is what we expect it to be...\n            if (inputAmount == order.expectedSpotPrice) {\n                // Then do a direct swap for all items we want\n                inputAmount = order.pair.swapTokenForSpecificNFTs{value: order.ethAmount}(\n                    order.nftIds, order.maxInputAmount, swapOrder.nftRecipient, true, msg.sender\n                );\n\n                // Deduct ETH amount if it's an ETH swap\n                if (order.ethAmount != 0) {\n                    ethAmount -= inputAmount;\n                }\n            }\n            // Otherwise, we need to do some partial fill calculations first\n            else {\n                uint256 numItemsToFill;\n                uint256 priceToFillAt;\n\n                {\n                    (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n                        order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n                    );\n\n                    // uint128(inputAmount) is safe because order.pair.spotPrice() returns uint128\n                    (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForBuy(\n                        order.pair, uint128(inputAmount), order.maxCostPerNumNFTs, protocolFeeMultiplier, royaltyAmount\n                    );\n                }\n\n                // Set inputAmount to be 0 (assuming we don't fully meet all criteria for a swap)\n                inputAmount = 0;\n\n                // Continue if we can fill at least 1 item\n                if (numItemsToFill != 0) {\n                    // Set ETH amount to send (is 0 if it's an ERC20 swap)\n                    uint256 ethToSendForBuy;\n                    if (order.ethAmount != 0) {\n                        ethToSendForBuy = priceToFillAt;\n                    }\n\n                    // If ERC721 swap\n                    if (order.isERC721) {\n                        // Get list of actually valid ids to buy\n                        uint256[] memory availableIds = _findAvailableIds(order.pair, numItemsToFill, order.nftIds);\n\n                        // Only swap if there are valid IDs to buy\n                        if (availableIds.length != 0) {\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                availableIds, priceToFillAt, swapOrder.nftRecipient, true, msg.sender\n                            );\n                        }\n                    }\n                    // If ERC1155 swap\n                    else {\n                        // The amount to buy is the min(numItemsToFill, erc1155.balanceOf(pair))\n                        {\n                            uint256 availableNFTs = IERC1155(order.pair.nft()).balanceOf(\n                                address(order.pair), LSSVMPairERC1155(address(order.pair)).nftId()\n                            );\n                            numItemsToFill = numItemsToFill < availableNFTs ? numItemsToFill : availableNFTs;\n                        }\n\n                        // Only continue if we can fill for nonzero amount of items\n                        if (numItemsToFill != 0) {\n                            // Do the 1155 swap, with the modified amount to buy\n                            inputAmount = order.pair.swapTokenForSpecificNFTs{value: ethToSendForBuy}(\n                                _wrapUintAsArray(numItemsToFill),\n                                priceToFillAt,\n                                swapOrder.nftRecipient,\n                                true,\n                                msg.sender\n                            );\n                        }\n                    }\n\n                    // Deduct ETH amount if it's an ETH swap\n                    if (order.ethAmount != 0) {\n                        ethAmount -= inputAmount;\n                    }\n                }\n            }\n            // Store inputAmount in results\n            results[i + swapOrder.sellOrders.length] = inputAmount;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Send excess ETH back to token recipient\n        if (ethAmount != 0) {\n            payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount);\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * Internal helper functions\n     */\n\n    /**\n     *   @dev Performs a binary search to find the largest value where maxCostPerNumNFTs is still greater than\n     *   the pair's bonding curve's getBuyInfo() value.\n     *   @param pair The pair to calculate partial fill values for\n     *   @param maxCostPerNumNFTs The user's specified maximum price to pay for filling a number of NFTs\n     *   @param protocolFeeMultiplier The % set as protocol fee\n     *   @param royaltyAmount Royalty amount assuming a cost of BASE, used for cheaper royalty calc\n     *   @dev Note that maxPricesPerNumNFTs is 0-indexed\n     */\n    function _findMaxFillableAmtForBuy(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory maxCostPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = maxCostPerNumNFTs.length;\n\n        // Cache current pair values\n        uint128 delta = pair.delta();\n\n        uint256 feeMultiplierAndBondingCurve =\n            uint96(pair.fee()) << FEE_MULTIPLIER_SHIFT_AMOUNT | uint160(address(pair.bondingCurve()));\n\n        // Perform binary search\n        while (start <= end) {\n            // uint256 numItems = (start + end)/2; (but we hard-code it below to avoid stack too deep)\n\n            // We check the price to buy index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentCost,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = (ICurve(address(uint160(feeMultiplierAndBondingCurve)))).getBuyInfo(\n                spotPrice,\n                delta,\n                (start + end) / 2,\n                (feeMultiplierAndBondingCurve >> FEE_MULTIPLIER_SHIFT_AMOUNT),\n                protocolFeeMultiplier\n            );\n\n            currentCost += currentCost * royaltyAmount / BASE;\n\n            // If the bonding curve has a math error, or\n            // If the current price is too expensive relative to our max cost,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentCost > maxCostPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentCost;\n            }\n        }\n    }\n\n    function _findMaxFillableAmtForSell(\n        LSSVMPair pair,\n        uint128 spotPrice,\n        uint256[] memory minOutputPerNumNFTs,\n        uint256 protocolFeeMultiplier,\n        uint256 royaltyAmount\n    ) internal view returns (uint256 numItemsToFill, uint256 priceToFillAt) {\n        // Set start and end indices\n        uint256 start = 1;\n        uint256 end = minOutputPerNumNFTs.length;\n\n        // Cache current pair values\n        uint256 deltaAndPairTokenBalance;\n        uint256 feeMultiplierAndBondingCurve;\n        {\n            uint128 delta = pair.delta();\n            uint128 pairTokenBalance = uint128(getPairBaseQuoteTokenBalance(pair));\n            deltaAndPairTokenBalance = uint256(delta) << DELTA_SHIFT_AMOUNT | pairTokenBalance;\n        }\n        {\n            uint256 feeMultiplier = uint96(pair.fee());\n            address bondingCurve = address(pair.bondingCurve());\n            feeMultiplierAndBondingCurve = feeMultiplier << FEE_MULTIPLIER_SHIFT_AMOUNT | uint160(bondingCurve);\n        }\n\n        // Perform binary search\n        while (start <= end) {\n            // We check the price to sell index + 1\n            (\n                CurveErrorCodes.Error error,\n                /* newSpotPrice */\n                ,\n                /* newDelta */\n                ,\n                uint256 currentOutput,\n                /* tradeFee */\n                ,\n                /* protocolFee */\n            ) = (ICurve(address(uint160(feeMultiplierAndBondingCurve)))).getSellInfo(\n                spotPrice,\n                // get delta from deltaAndPairTokenBalance\n                uint128(deltaAndPairTokenBalance >> DELTA_SHIFT_AMOUNT),\n                (start + end) / 2,\n                // get feeMultiplier from feeMultiplierAndBondingCurve\n                uint96(feeMultiplierAndBondingCurve >> FEE_MULTIPLIER_SHIFT_AMOUNT),\n                protocolFeeMultiplier\n            );\n            currentOutput -= currentOutput * royaltyAmount / BASE;\n            // If the bonding curve has a math error, or\n            // if the current output is too low relative to our max output, or\n            // if the current output is greater than the pair's token balance,\n            // then we recurse on the left half (i.e. less items)\n            if (\n                error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the minimum output we are expecting from the sale, zero-indexed */\n                    || currentOutput > (uint256(uint128(deltaAndPairTokenBalance)))\n            ) {\n                end = (start + end) / 2 - 1;\n            }\n            // Otherwise, we recurse on the right half (i.e. more items)\n            else {\n                numItemsToFill = (start + end) / 2;\n                start = (start + end) / 2 + 1;\n                priceToFillAt = currentOutput;\n            }\n        }\n    }\n\n    /**\n     * @dev Checks ownership of all desired NFT IDs to see which ones are still fillable\n     * @param pair The pair to check for ownership\n     * @param maxIdsNeeded The maximum amount of NFTs we want, guaranteed to be up to potentialIds.length, but could be less\n     * @param potentialIds The possible NFT IDs that the pair could own\n     * @return idsToBuy Actual NFT IDs owned by the pair, guaranteed to be up to maxIdsNeeded length, but could be less\n     */\n    function _findAvailableIds(LSSVMPair pair, uint256 maxIdsNeeded, uint256[] memory potentialIds)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        IERC721 nft = IERC721(pair.nft());\n        uint256[] memory idsThatExist = new uint256[](maxIdsNeeded);\n        uint256 numIdsFound;\n\n        // Go through each potential ID, and check to see if it's still owned by the pair\n        // If it is, record the ID\n        for (uint256 i; i < maxIdsNeeded;) {\n            if (nft.ownerOf(potentialIds[i]) == address(pair)) {\n                idsThatExist[numIdsFound] = potentialIds[i];\n                numIdsFound += 1;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        // If all ids were found, return the full id list\n        if (numIdsFound == maxIdsNeeded) {\n            return idsThatExist;\n        }\n        // Otherwise, we didn't find enough IDs, so we need to return a subset\n        if (numIdsFound < maxIdsNeeded) {\n            uint256[] memory allIdsFound = new uint256[](numIdsFound);\n            for (uint256 i; i < numIdsFound;) {\n                allIdsFound[i] = idsThatExist[i];\n\n                unchecked {\n                    ++i;\n                }\n            }\n            return allIdsFound;\n        }\n        uint256[] memory emptyArr = new uint256[](0);\n        return emptyArr;\n    }\n\n    /**\n     * Restricted functions\n     */\n\n    /**\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\n     * the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\n     * @param token The ERC20 token to transfer\n     * @param from The address to transfer tokens from\n     * @param to The address to transfer tokens to\n     * @param amount The amount of tokens to transfer\n     */\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\n        // verify caller is a trusted ERC20 pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer tokens to pair\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     * @param nft The ERC721 NFT to transfer\n     * @param from The address to transfer tokens from\n     * @param to The address to transfer tokens to\n     * @param id The ID of the NFT to transfer\n     */\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC721\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.transferFrom(from, to, id);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC1155 NFTs directly from\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     * @param nft The ERC1155 NFT to transfer\n     * @param from The address to transfer tokens from\n     * @param to The address to transfer tokens to\n     * @param ids The IDs of the NFT to transfer\n     * @param amounts The amount of each ID to transfer\n     */\n    function pairTransferERC1155From(\n        IERC1155 nft,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        // verify caller is a trusted pair contract\n        if (\n            !(\n                factory.isValidPair(msg.sender)\n                    && factory.getPairNFTType(msg.sender) == ILSSVMPairFactoryLike.PairNFTType.ERC1155\n            )\n        ) {\n            revert VeryFastRouter__InvalidPair();\n        }\n\n        // transfer NFTs to pair\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\"));\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/LSSVMPair.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IRoyaltyEngineV1} from \"manifoldxyz/IRoyaltyEngineV1.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\nimport {ICurve} from \"./bonding-curves/ICurve.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\nimport {IOwnershipTransferReceiver} from \"./lib/IOwnershipTransferReceiver.sol\";\nimport {OwnableWithTransferCallback} from \"./lib/OwnableWithTransferCallback.sol\";\n\n/**\n * @title The base contract for an NFT/TOKEN AMM pair\n * @author boredGenius, 0xmons, 0xCygaar\n * @notice This implements the core swap logic from NFT to TOKEN\n */\nabstract contract LSSVMPair is OwnableWithTransferCallback, ERC721Holder, ERC1155Holder {\n    /**\n     * Library usage **\n     */\n\n    using Address for address;\n\n    /**\n     *  Enums **\n     */\n\n    enum PoolType {\n        TOKEN,\n        NFT,\n        TRADE\n    }\n\n    /**\n     * Constants **\n     */\n\n    /**\n     * @dev 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory)\n     */\n    uint256 internal constant MAX_TRADE_FEE = 0.5e18;\n\n    /**\n     *  Immutable params **\n     */\n\n    /**\n     * @notice Sudoswap Royalty Engine\n     */\n    IRoyaltyEngineV1 public immutable ROYALTY_ENGINE;\n\n    /**\n     *  Storage variables **\n     */\n\n    /**\n     * @dev This is generally used to mean the immediate sell price for the next marginal NFT.\n     * However, this should NOT be assumed, as bonding curves may use spotPrice in different ways.\n     * Use getBuyNFTQuote and getSellNFTQuote for accurate pricing info.\n     */\n    uint128 public spotPrice;\n\n    /**\n     * @notice The parameter for the pair's bonding curve.\n     * Units and meaning are bonding curve dependent.\n     */\n    uint128 public delta;\n\n    /**\n     * @notice The spread between buy and sell prices, set to be a multiplier we apply to the buy price\n     * Fee is only relevant for TRADE pools. Units are in base 1e18.\n     */\n    uint96 public fee;\n\n    /**\n     * @notice The address that swapped assets are sent to.\n     * For TRADE pools, assets are always sent to the pool, so this is used to track trade fee.\n     * If set to address(0), will default to owner() for NFT and TOKEN pools.\n     */\n    address payable internal assetRecipient;\n\n    /**\n     *  Events\n     */\n\n    event SwapNFTInPair(uint256 amountOut, uint256[] ids);\n    event SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\n    event SwapNFTOutPair(uint256 amountIn, uint256[] ids);\n    event SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\n    event SpotPriceUpdate(uint128 newSpotPrice);\n    event TokenDeposit(uint256 amount);\n    event TokenWithdrawal(uint256 amount);\n    event NFTWithdrawal(uint256[] ids);\n    event NFTWithdrawal(uint256 numNFTs);\n    event DeltaUpdate(uint128 newDelta);\n    event FeeUpdate(uint96 newFee);\n    event AssetRecipientChange(address indexed a);\n\n    /**\n     *  Errors\n     */\n\n    error LSSVMPair__NotRouter();\n    error LSSVMPair__CallFailed();\n    error LSSVMPair__InvalidDelta();\n    error LSSVMPair__WrongPoolType();\n    error LSSVMPair__OutputTooSmall();\n    error LSSVMPair__ZeroSwapAmount();\n    error LSSVMPair__RoyaltyTooLarge();\n    error LSSVMPair__TradeFeeTooLarge();\n    error LSSVMPair__InvalidSpotPrice();\n    error LSSVMPair__TargetNotAllowed();\n    error LSSVMPair__NftNotTransferred();\n    error LSSVMPair__AlreadyInitialized();\n    error LSSVMPair__FunctionNotAllowed();\n    error LSSVMPair__DemandedInputTooLarge();\n    error LSSVMPair__NonTradePoolWithTradeFee();\n    error LSSVMPair__BondingCurveError(CurveErrorCodes.Error error);\n\n    constructor(IRoyaltyEngineV1 royaltyEngine) {\n        ROYALTY_ENGINE = royaltyEngine;\n    }\n\n    /**\n     * @notice Called during pair creation to set initial parameters\n     * @dev Only called once by factory to initialize.\n     * We verify this by making sure that the current owner is address(0).\n     * The Ownable library we use disallows setting the owner to be address(0), so this condition\n     * should only be valid before the first initialize call.\n     * @param _owner The owner of the pair\n     * @param _assetRecipient The address that will receive the TOKEN or NFT sent to this pair during swaps. NOTE: If set to address(0), they will go to the pair itself.\n     * @param _delta The initial delta of the bonding curve\n     * @param _fee The initial % fee taken, if this is a trade pair\n     * @param _spotPrice The initial price to sell an asset into the pair\n     */\n    function initialize(\n        address _owner,\n        address payable _assetRecipient,\n        uint128 _delta,\n        uint96 _fee,\n        uint128 _spotPrice\n    ) external {\n        if (owner() != address(0)) revert LSSVMPair__AlreadyInitialized();\n        __Ownable_init(_owner);\n\n        ICurve _bondingCurve = bondingCurve();\n        PoolType _poolType = poolType();\n        if (_poolType != PoolType.TRADE) {\n            if (_fee != 0) revert LSSVMPair__NonTradePoolWithTradeFee();\n        } else {\n            if (_fee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\n            fee = _fee;\n        }\n\n        assetRecipient = _assetRecipient;\n\n        if (!_bondingCurve.validateDelta(_delta)) revert LSSVMPair__InvalidDelta();\n        if (!_bondingCurve.validateSpotPrice(_spotPrice)) revert LSSVMPair__InvalidSpotPrice();\n        delta = _delta;\n        spotPrice = _spotPrice;\n    }\n\n    /**\n     * External state-changing functions\n     */\n\n    /**\n     * @notice Sends token to the pair in exchange for a specific set of NFTs\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo\n     * This swap is meant for users who want specific IDs. Also higher chance of\n     * reverting if some of the specified IDs leave the pool before the swap goes through.\n     * @param nftIds The list of IDs of the NFTs to purchase\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\n     * amount is greater than this value, the transaction will be reverted.\n     * @param nftRecipient The recipient of the NFTs\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\n     * @return - The amount of token used for purchase\n     */\n    function swapTokenForSpecificNFTs(\n        uint256[] calldata nftIds,\n        uint256 maxExpectedTokenInput,\n        address nftRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external payable virtual returns (uint256);\n\n    /**\n     * @notice Sends a set of NFTs to the pair in exchange for token\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\n     * @param nftIds The list of IDs of the NFTs to sell to the pair\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\n     * amount is less than this value, the transaction will be reverted.\n     * @param tokenRecipient The recipient of the token output\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for\n     * ETH pairs.\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for\n     * ETH pairs.\n     * @return outputAmount The amount of token received\n     */\n    function swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external virtual returns (uint256 outputAmount);\n\n    /**\n     * View functions\n     */\n\n    /**\n     * @dev Used as read function to query the bonding curve for buy pricing info\n     * @param numNFTs The number of NFTs to buy from the pair\n     */\n    function getBuyNFTQuote(uint256 assetId, uint256 numNFTs)\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint256 newSpotPrice,\n            uint256 newDelta,\n            uint256 inputAmount,\n            uint256 protocolFee,\n            uint256 royaltyAmount\n        )\n    {\n        uint256 tradeFee;\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\n            bondingCurve().getBuyInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\n\n        if (numNFTs != 0) {\n            // Calculate the inputAmount minus tradeFee and protocolFee\n            uint256 inputAmountMinusFees = inputAmount - tradeFee - protocolFee;\n\n            // Compute royalties\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, inputAmountMinusFees);\n\n            inputAmount += royaltyAmount;\n        }\n    }\n\n    /**\n     * @dev Used as read function to query the bonding curve for sell pricing info including royalties\n     * @param numNFTs The number of NFTs to sell to the pair\n     */\n    function getSellNFTQuote(uint256 assetId, uint256 numNFTs)\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint256 newSpotPrice,\n            uint256 newDelta,\n            uint256 outputAmount,\n            uint256 protocolFee,\n            uint256 royaltyAmount\n        )\n    {\n        (error, newSpotPrice, newDelta, outputAmount, /* tradeFee */, protocolFee) =\n            bondingCurve().getSellInfo(spotPrice, delta, numNFTs, fee, factory().protocolFeeMultiplier());\n\n        if (numNFTs != 0) {\n            // Compute royalties\n            (,, royaltyAmount) = calculateRoyaltiesView(assetId, outputAmount);\n\n            // Deduct royalties from outputAmount\n            unchecked {\n                // Safe because we already require outputAmount >= royaltyAmount in _calculateRoyalties()\n                outputAmount -= royaltyAmount;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the pair's variant (Pair uses ETH or ERC20)\n     */\n    function pairVariant() public pure virtual returns (ILSSVMPairFactoryLike.PairVariant);\n\n    function factory() public pure returns (ILSSVMPairFactoryLike _factory) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))\n        }\n    }\n\n    /**\n     * @notice Returns the type of bonding curve that parameterizes the pair\n     */\n    function bondingCurve() public pure returns (ICurve _bondingCurve) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))\n        }\n    }\n\n    /**\n     * @notice Returns the address of NFT collection that parameterizes the pair\n     */\n    function nft() public pure returns (address _nft) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))\n        }\n    }\n\n    /**\n     * @notice Returns the pair's type (TOKEN/NFT/TRADE)\n     */\n    function poolType() public pure returns (PoolType _poolType) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))\n        }\n    }\n\n    /**\n     * @notice Returns the address that receives assets when a swap is done with this pair\n     * Can be set to another address by the owner, but has no effect on TRADE pools\n     * If set to address(0), defaults to owner() for NFT/TOKEN pools\n     */\n    function getAssetRecipient() public view returns (address payable) {\n        // TRADE pools will always receive the asset themselves\n        if (poolType() == PoolType.TRADE) {\n            return payable(address(this));\n        }\n\n        address payable _assetRecipient = assetRecipient;\n\n        // Otherwise, we return the recipient if it's been set\n        // Or, we replace it with owner() if it's address(0)\n        if (_assetRecipient == address(0)) {\n            return payable(owner());\n        }\n        return _assetRecipient;\n    }\n\n    /**\n     * @notice Returns the address that receives trade fees when a swap is done with this pair\n     * Only relevant for TRADE pools\n     * If set to address(0), defaults to the pair itself\n     */\n    function getFeeRecipient() public view returns (address payable _feeRecipient) {\n        _feeRecipient = assetRecipient;\n        if (_feeRecipient == address(0)) {\n            _feeRecipient = payable(address(this));\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Calculates the amount needed to be sent into the pair for a buy and adjusts spot price or delta if necessary\n     * @param numNFTs The amount of NFTs to purchase from the pair\n     * @param _bondingCurve The bonding curve to use for price calculation\n     * @param _factory The factory to use for protocol fee lookup\n     * @return tradeFee The amount of tokens to send as trade fee\n     * @return protocolFee The amount of tokens to send as protocol fee\n     * @return inputAmount The amount of tokens total tokens receive\n     */\n    function _calculateBuyInfoAndUpdatePoolParams(uint256 numNFTs, ICurve _bondingCurve, ILSSVMPairFactoryLike _factory)\n        internal\n        returns (uint256 tradeFee, uint256 protocolFee, uint256 inputAmount)\n    {\n        CurveErrorCodes.Error error;\n        // Save on 2 SLOADs by caching\n        uint128 currentSpotPrice = spotPrice;\n        uint128 currentDelta = delta;\n        uint128 newDelta;\n        uint128 newSpotPrice;\n        (error, newSpotPrice, newDelta, inputAmount, tradeFee, protocolFee) =\n            _bondingCurve.getBuyInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\n\n        // Revert if bonding curve had an error\n        if (error != CurveErrorCodes.Error.OK) {\n            revert LSSVMPair__BondingCurveError(error);\n        }\n\n        // Consolidate writes to save gas\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\n            spotPrice = newSpotPrice;\n            delta = newDelta;\n        }\n\n        // Emit spot price update if it has been updated\n        if (currentSpotPrice != newSpotPrice) {\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n\n        // Emit delta update if it has been updated\n        if (currentDelta != newDelta) {\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount needed to be sent by the pair for a sell and adjusts spot price or delta if necessary\n     * @param numNFTs The amount of NFTs to send to the the pair\n     * @param _bondingCurve The bonding curve to use for price calculation\n     * @param _factory The factory to use for protocol fee lookup\n     * @return protocolFee The amount of tokens to send as protocol fee\n     * @return outputAmount The amount of tokens total tokens receive\n     */\n    function _calculateSellInfoAndUpdatePoolParams(\n        uint256 numNFTs,\n        ICurve _bondingCurve,\n        ILSSVMPairFactoryLike _factory\n    ) internal returns (uint256 protocolFee, uint256 outputAmount) {\n        CurveErrorCodes.Error error;\n        // Save on 2 SLOADs by caching\n        uint128 currentSpotPrice = spotPrice;\n        uint128 currentDelta = delta;\n        uint128 newSpotPrice;\n        uint128 newDelta;\n        (error, newSpotPrice, newDelta, outputAmount, /*tradeFee*/, protocolFee) =\n            _bondingCurve.getSellInfo(currentSpotPrice, currentDelta, numNFTs, fee, _factory.protocolFeeMultiplier());\n\n        // Revert if bonding curve had an error\n        if (error != CurveErrorCodes.Error.OK) {\n            revert LSSVMPair__BondingCurveError(error);\n        }\n\n        // Consolidate writes to save gas\n        if (currentSpotPrice != newSpotPrice || currentDelta != newDelta) {\n            spotPrice = newSpotPrice;\n            delta = newDelta;\n        }\n\n        // Emit spot price update if it has been updated\n        if (currentSpotPrice != newSpotPrice) {\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n\n        // Emit delta update if it has been updated\n        if (currentDelta != newDelta) {\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Pulls the token input of a trade from the trader (including all royalties and fees)\n     * @param inputAmountExcludingRoyalty The amount of tokens to be sent, excluding the royalty (includes protocol fee)\n     * @param royaltyAmounts The amounts of tokens to be sent as royalties\n     * @param royaltyRecipients The recipients of the royalties\n     * @param royaltyTotal The sum of all royaltyAmounts\n     * @param tradeFeeAmount The amount of tokens to be sent as trade fee (if applicable)\n     * @param isRouter Whether or not the caller is LSSVMRouter\n     * @param routerCaller If called from LSSVMRouter, store the original caller\n     * @param protocolFee The protocol fee to be paid\n     */\n    function _pullTokenInputs(\n        uint256 inputAmountExcludingRoyalty,\n        uint256[] memory royaltyAmounts,\n        address payable[] memory royaltyRecipients,\n        uint256 royaltyTotal,\n        uint256 tradeFeeAmount,\n        bool isRouter,\n        address routerCaller,\n        uint256 protocolFee\n    ) internal virtual;\n\n    /**\n     * @notice Sends excess tokens back to the caller (if applicable)\n     * @dev Swap callers interacting with an ETH pair must be able to receive ETH (e.g. if the caller sends too much ETH)\n     */\n    function _refundTokenToSender(uint256 inputAmount) internal virtual;\n\n    /**\n     * @notice Sends tokens to a recipient\n     * @param tokenRecipient The address receiving the tokens\n     * @param outputAmount The amount of tokens to send\n     */\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal virtual;\n\n    /**\n     * @dev Used internally to grab pair parameters from calldata, see LSSVMPairCloner for technical details\n     */\n    function _immutableParamsLength() internal pure virtual returns (uint256);\n\n    /**\n     * Royalty support functions\n     */\n\n    function _calculateRoyalties(uint256 assetId, uint256 saleAmount)\n        internal\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        (address payable[] memory recipients, uint256[] memory amounts) =\n            ROYALTY_ENGINE.getRoyalty(nft(), assetId, saleAmount);\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\n    }\n\n    /**\n     * @dev Same as _calculateRoyalties, but uses getRoyaltyView to avoid state mutations and is public for external callers\n     */\n    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\n        public\n        view\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        (address payable[] memory recipients, uint256[] memory amounts) =\n            ROYALTY_ENGINE.getRoyaltyView(nft(), assetId, saleAmount);\n        return _calculateRoyaltiesLogic(recipients, amounts, saleAmount);\n    }\n\n    /**\n     * @dev Common logic used by _calculateRoyalties() and calculateRoyaltiesView()\n     */\n    function _calculateRoyaltiesLogic(address payable[] memory recipients, uint256[] memory amounts, uint256 saleAmount)\n        internal\n        view\n        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n    {\n        // Cache to save gas\n        uint256 numRecipients = recipients.length;\n\n        if (numRecipients != 0) {\n            // If a pair has custom Settings, use the overridden royalty amount and only use the first receiver\n            try factory().getSettingsForPair(address(this)) returns (bool settingsEnabled, uint96 bps) {\n                if (settingsEnabled) {\n                    royaltyRecipients = new address payable[](1);\n                    royaltyRecipients[0] = recipients[0];\n                    royaltyAmounts = new uint256[](1);\n                    royaltyAmounts[0] = (saleAmount * bps) / 10000;\n\n                    // Update numRecipients to match new recipients list\n                    numRecipients = 1;\n                } else {\n                    royaltyRecipients = recipients;\n                    royaltyAmounts = amounts;\n                }\n            } catch {\n                // Use the input values to calculate royalties if factory call fails\n                royaltyRecipients = recipients;\n                royaltyAmounts = amounts;\n            }\n        }\n\n        for (uint256 i; i < numRecipients;) {\n            royaltyTotal += royaltyAmounts[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Ensure royalty total is at most 25% of the sale amount\n        // This defends against a rogue Manifold registry that charges extremely high royalties\n        if (royaltyTotal > saleAmount >> 2) {\n            revert LSSVMPair__RoyaltyTooLarge();\n        }\n    }\n\n    /**\n     * Owner functions\n     */\n\n    /**\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. (onlyOwnable modifier is in the implemented function)\n     * @param a The NFT to transfer\n     * @param nftIds The list of IDs of the NFTs to send to the owner\n     */\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual;\n\n    /**\n     * @notice Rescues ERC20 tokens from the pair to the owner. Only callable by the owner (onlyOwnable modifier is in the implemented function).\n     * @param a The token to transfer\n     * @param amount The amount of tokens to send to the owner\n     */\n    function withdrawERC20(ERC20 a, uint256 amount) external virtual;\n\n    /**\n     * @notice Rescues ERC1155 tokens from the pair to the owner. Only callable by the owner.\n     * @param a The NFT to transfer\n     * @param ids The NFT ids to transfer\n     * @param amounts The amounts of each id to transfer\n     */\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts) external virtual;\n\n    /**\n     * @notice Updates the selling spot price. Only callable by the owner.\n     * @param newSpotPrice The new selling spot price value, in Token\n     */\n    function changeSpotPrice(uint128 newSpotPrice) external onlyOwner {\n        ICurve _bondingCurve = bondingCurve();\n        if (!_bondingCurve.validateSpotPrice(newSpotPrice)) revert LSSVMPair__InvalidSpotPrice();\n        if (spotPrice != newSpotPrice) {\n            spotPrice = newSpotPrice;\n            emit SpotPriceUpdate(newSpotPrice);\n        }\n    }\n\n    /**\n     * @notice Updates the delta parameter. Only callable by the owner.\n     * @param newDelta The new delta parameter\n     */\n    function changeDelta(uint128 newDelta) external onlyOwner {\n        ICurve _bondingCurve = bondingCurve();\n        if (!_bondingCurve.validateDelta(newDelta)) revert LSSVMPair__InvalidDelta();\n        if (delta != newDelta) {\n            delta = newDelta;\n            emit DeltaUpdate(newDelta);\n        }\n    }\n\n    /**\n     * @notice Updates the fee taken by the LP. Only callable by the owner.\n     * Only callable if the pool is a Trade pool. Reverts if the fee is >= MAX_FEE.\n     * @param newFee The new LP fee percentage, 18 decimals\n     */\n    function changeFee(uint96 newFee) external onlyOwner {\n        PoolType _poolType = poolType();\n        if (_poolType != PoolType.TRADE) revert LSSVMPair__NonTradePoolWithTradeFee();\n        if (newFee > MAX_TRADE_FEE) revert LSSVMPair__TradeFeeTooLarge();\n        if (fee != newFee) {\n            fee = newFee;\n            emit FeeUpdate(newFee);\n        }\n    }\n\n    /**\n     * @notice Changes the address that will receive assets received from\n     * trades. Only callable by the owner.\n     * @param newRecipient The new asset recipient\n     */\n    function changeAssetRecipient(address payable newRecipient) external onlyOwner {\n        if (assetRecipient != newRecipient) {\n            assetRecipient = newRecipient;\n            emit AssetRecipientChange(newRecipient);\n        }\n    }\n\n    function _preCallCheck(address target) internal virtual;\n\n    /**\n     * @notice Allows the pair to make arbitrary external calls to contracts\n     * whitelisted by the protocol. Only callable by the owner.\n     * @param target The contract to call\n     * @param data The calldata to pass to the contract\n     */\n    function call(address payable target, bytes calldata data) external onlyOwner {\n        ILSSVMPairFactoryLike _factory = factory();\n        if (!_factory.callAllowed(target)) revert LSSVMPair__TargetNotAllowed();\n\n        // Ensure the call isn't calling a banned function\n        bytes4 sig = bytes4(data[:4]);\n        if (\n            sig == IOwnershipTransferReceiver.onOwnershipTransferred.selector\n                || sig == LSSVMRouter.pairTransferERC20From.selector || sig == LSSVMRouter.pairTransferNFTFrom.selector\n                || sig == LSSVMRouter.pairTransferERC1155From.selector || sig == ILSSVMPairFactoryLike.openLock.selector\n                || sig == ILSSVMPairFactoryLike.closeLock.selector\n        ) {\n            revert LSSVMPair__FunctionNotAllowed();\n        }\n\n        // Prevent calling the pair's underlying nft\n        // (We ban calling the underlying NFT/ERC20 to avoid maliciously transferring assets approved for the pair to spend)\n        if (target == nft()) revert LSSVMPair__TargetNotAllowed();\n\n        _preCallCheck(target);\n\n        (bool success,) = target.call{value: 0}(data);\n        if (!success) revert LSSVMPair__CallFailed();\n    }\n\n    /**\n     * @notice Allows owner to batch multiple calls, forked from: https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/BoringBatchable.sol\n     * @notice The revert handling is forked from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c239e1af8d1a1296577108dd6989a17b57434f8e/contracts/utils/Address.sol#L201\n     * @dev Intended for withdrawing/altering pool pricing in one tx, only callable by owner, cannot change owner\n     * @param calls The calldata for each call to make\n     * @param revertOnFail Whether or not to revert the entire tx if any of the calls fail. Calls to transferOwnership will revert regardless.\n     */\n    function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner {\n        for (uint256 i; i < calls.length;) {\n            bytes4 sig = bytes4(calls[i][:4]);\n            // We ban calling transferOwnership when ownership\n            if (sig == transferOwnership.selector) revert LSSVMPair__FunctionNotAllowed();\n\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                assembly {\n                    revert(add(0x20, result), mload(result))\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "src/LSSVMPairERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\n\n/**\n * @title An NFT/Token pair where the token is an ERC20\n * @author boredGenius, 0xmons, 0xCygaar\n */\nabstract contract LSSVMPairERC20 is LSSVMPair {\n    using SafeTransferLib for ERC20;\n\n    error LSSVMPairERC20__RoyaltyNotPaid();\n    error LSSVMPairERC20__MsgValueNotZero();\n    error LSSVMPairERC20__AssetRecipientNotPaid();\n\n    /**\n     * @notice Returns the ERC20 token associated with the pair\n     * @dev See LSSVMPairCloner for an explanation on how this works\n     * @dev The last 20 bytes of the immutable data contain the ERC20 token address\n     */\n    function token() public pure returns (ERC20 _token) {\n        assembly {\n            _token := shr(0x60, calldataload(sub(calldatasize(), 20)))\n        }\n    }\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function _pullTokenInputs(\n        uint256 inputAmountExcludingRoyalty,\n        uint256[] memory royaltyAmounts,\n        address payable[] memory royaltyRecipients,\n        uint256, /* royaltyTotal */\n        uint256 tradeFeeAmount,\n        bool isRouter,\n        address routerCaller,\n        uint256 protocolFee\n    ) internal override {\n        address _assetRecipient = getAssetRecipient();\n\n        // Transfer tokens\n        if (isRouter) {\n            // Verify if router is allowed\n            // Locally scoped to avoid stack too deep\n            {\n                (bool routerAllowed,) = factory().routerStatus(LSSVMRouter(payable(msg.sender)));\n                if (!routerAllowed) revert LSSVMPair__NotRouter();\n            }\n\n            // Cache state and then call router to transfer tokens from user\n            uint256 beforeBalance = token().balanceOf(_assetRecipient);\n            LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\n                token(), routerCaller, _assetRecipient, inputAmountExcludingRoyalty - protocolFee\n            );\n\n            // Verify token transfer (protect pair against malicious router)\n            ERC20 token_ = token();\n            if (token_.balanceOf(_assetRecipient) - beforeBalance != (inputAmountExcludingRoyalty - protocolFee)) {\n                revert LSSVMPairERC20__AssetRecipientNotPaid();\n            }\n\n            // Transfer royalties (if they exist)\n            for (uint256 i; i < royaltyRecipients.length;) {\n                beforeBalance = token_.balanceOf(royaltyRecipients[i]);\n                LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\n                    token_, routerCaller, royaltyRecipients[i], royaltyAmounts[i]\n                );\n                if (token_.balanceOf(royaltyRecipients[i]) - beforeBalance != royaltyAmounts[i]) {\n                    revert LSSVMPairERC20__RoyaltyNotPaid();\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Take protocol fee (if it exists)\n            if (protocolFee != 0) {\n                LSSVMRouter(payable(msg.sender)).pairTransferERC20From(\n                    token_, routerCaller, address(factory()), protocolFee\n                );\n            }\n        } else {\n            // Transfer tokens directly (sans the protocol fee)\n            ERC20 token_ = token();\n            token_.safeTransferFrom(msg.sender, _assetRecipient, inputAmountExcludingRoyalty - protocolFee);\n\n            // Transfer royalties (if they exists)\n            for (uint256 i; i < royaltyRecipients.length;) {\n                token_.safeTransferFrom(msg.sender, royaltyRecipients[i], royaltyAmounts[i]);\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Take protocol fee (if it exists)\n            if (protocolFee != 0) {\n                token_.safeTransferFrom(msg.sender, address(factory()), protocolFee);\n            }\n        }\n        // Send trade fee if it exists, is TRADE pool, and fee recipient != pool address\n        // @dev: (note that tokens are sent from the pool and not the caller)\n        if (poolType() == PoolType.TRADE && tradeFeeAmount != 0) {\n            address payable _feeRecipient = getFeeRecipient();\n            if (_feeRecipient != _assetRecipient) {\n                token().safeTransfer(_feeRecipient, tradeFeeAmount);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function _refundTokenToSender(uint256 inputAmount) internal override {\n        // Do nothing since we transferred the exact input amount\n    }\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function _sendTokenOutput(address payable tokenRecipient, uint256 outputAmount) internal override {\n        // Send tokens to caller\n        if (outputAmount != 0) {\n            token().safeTransfer(tokenRecipient, outputAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc LSSVMPair\n     */\n    function withdrawERC20(ERC20 a, uint256 amount) external override onlyOwner {\n        a.safeTransfer(msg.sender, amount);\n\n        if (a == token()) {\n            // emit event since it is the pair token\n            emit TokenWithdrawal(amount);\n        }\n    }\n\n    function _preCallCheck(address target) internal pure override {\n        if (target == address(token())) revert LSSVMPair__TargetNotAllowed();\n    }\n}\n"
    },
    "src/erc721/ILSSVMPairERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\ninterface ILSSVMPairERC721 {\n    function swapNFTsForToken(\n        uint256[] calldata nftIds,\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller,\n        bytes calldata propertyCheckerParams\n    ) external returns (uint256 outputAmount);\n}\n"
    },
    "src/erc1155/LSSVMPairERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {LSSVMPair} from \"../LSSVMPair.sol\";\nimport {LSSVMRouter} from \"../LSSVMRouter.sol\";\nimport {ICurve} from \"../bonding-curves/ICurve.sol\";\nimport {ILSSVMPairFactoryLike} from \"../ILSSVMPairFactoryLike.sol\";\n\n/**\n * @title LSSVMPairERC1155\n * @author boredGenius, 0xmons, 0xCygaar\n * @notice An NFT/Token pair for an ERC1155 NFT where NFTs with the same ID are considered fungible.\n */\nabstract contract LSSVMPairERC1155 is LSSVMPair {\n    /**\n     * External state-changing functions\n     */\n\n    /**\n     * @notice Sends token to the pair in exchange for any `numNFTs` NFTs\n     * @dev To compute the amount of token to send, call bondingCurve.getBuyInfo.\n     * This swap function is meant for users who are ID agnostic\n     * @param numNFTs The number of NFTs to purchase\n     * @param maxExpectedTokenInput The maximum acceptable cost from the sender. If the actual\n     * amount is greater than this value, the transaction will be reverted.\n     * @param nftRecipient The recipient of the NFTs\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\n     * @return inputAmount The amount of token used for purchase\n     */\n    function swapTokenForSpecificNFTs(\n        uint256[] calldata numNFTs,\n        uint256 maxExpectedTokenInput,\n        address nftRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external payable virtual override returns (uint256) {\n        // Store locally to remove extra calls\n        factory().openLock();\n\n        // Input validation\n        {\n            if (poolType() == PoolType.TOKEN) revert LSSVMPair__WrongPoolType();\n            if (numNFTs.length != 1 || numNFTs[0] == 0) revert LSSVMPair__ZeroSwapAmount();\n        }\n\n        // Call bonding curve for pricing information\n        uint256 tradeFee;\n        uint256 protocolFee;\n        uint256 inputAmountExcludingRoyalty;\n        (tradeFee, protocolFee, inputAmountExcludingRoyalty) =\n            _calculateBuyInfoAndUpdatePoolParams(numNFTs[0], bondingCurve(), factory());\n\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\n            _calculateRoyalties(nftId(), inputAmountExcludingRoyalty - protocolFee - tradeFee);\n\n        // Revert if the input amount is too large\n        if (royaltyTotal + inputAmountExcludingRoyalty > maxExpectedTokenInput) {\n            revert LSSVMPair__DemandedInputTooLarge();\n        }\n\n        _pullTokenInputs({\n            inputAmountExcludingRoyalty: inputAmountExcludingRoyalty,\n            royaltyRecipients: royaltyRecipients,\n            royaltyAmounts: royaltyAmounts,\n            royaltyTotal: royaltyTotal,\n            tradeFeeAmount: 2 * tradeFee,\n            isRouter: isRouter,\n            routerCaller: routerCaller,\n            protocolFee: protocolFee\n        });\n\n        _sendAnyNFTsToRecipient(IERC1155(nft()), nftRecipient, numNFTs[0]);\n\n        _refundTokenToSender(royaltyTotal + inputAmountExcludingRoyalty);\n\n        factory().closeLock();\n\n        emit SwapNFTOutPair(royaltyTotal + inputAmountExcludingRoyalty, numNFTs[0]);\n\n        return (royaltyTotal + inputAmountExcludingRoyalty);\n    }\n\n    /**\n     * @notice Sends a set of NFTs to the pair in exchange for token\n     * @dev To compute the amount of token to that will be received, call bondingCurve.getSellInfo.\n     * @param numNFTs The number of NFTs to swap\n     * @param minExpectedTokenOutput The minimum acceptable token received by the sender. If the actual\n     * amount is less than this value, the transaction will be reverted.\n     * @param tokenRecipient The recipient of the token output\n     * @param isRouter True if calling from LSSVMRouter, false otherwise. Not used for ETH pairs.\n     * @param routerCaller If isRouter is true, ERC20 tokens will be transferred from this address. Not used for ETH pairs.\n     * @return outputAmount The amount of token received\n     */\n    function swapNFTsForToken(\n        uint256[] calldata numNFTs, // @dev this is a bit hacky, to allow for better interop w/ other pair interfaces\n        uint256 minExpectedTokenOutput,\n        address payable tokenRecipient,\n        bool isRouter,\n        address routerCaller\n    ) external virtual override returns (uint256 outputAmount) {\n        // Store locally to remove extra calls\n        ILSSVMPairFactoryLike _factory = factory();\n\n        _factory.openLock();\n\n        ICurve _bondingCurve = bondingCurve();\n\n        // Input validation\n        {\n            if (poolType() == PoolType.NFT) revert LSSVMPair__WrongPoolType();\n            if (numNFTs.length != 1 || numNFTs[0] == 0) revert LSSVMPair__ZeroSwapAmount();\n        }\n\n        // Call bonding curve for pricing information\n        uint256 protocolFee;\n        (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(numNFTs[0], _bondingCurve, _factory);\n\n        // Compute royalties\n        (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal) =\n            _calculateRoyalties(nftId(), outputAmount);\n\n        // Deduct royalties from outputAmount\n        unchecked {\n            // Safe because we already require outputAmount >= royaltyTotal in calculateRoyalties()\n            outputAmount -= royaltyTotal;\n        }\n\n        if (outputAmount < minExpectedTokenOutput) revert LSSVMPair__OutputTooSmall();\n\n        _takeNFTsFromSender(IERC1155(nft()), numNFTs[0], _factory, isRouter, routerCaller);\n\n        _sendTokenOutput(tokenRecipient, outputAmount);\n\n        for (uint256 i; i < royaltyRecipients.length;) {\n            _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        _sendTokenOutput(payable(address(_factory)), protocolFee);\n\n        _factory.closeLock();\n\n        emit SwapNFTInPair(outputAmount, numNFTs[0]);\n    }\n\n    /**\n     * View functions\n     */\n\n    /**\n     * @notice Returns the ERC-1155 NFT ID this pool uses\n     */\n    function nftId() public pure returns (uint256 id) {\n        uint256 paramsLength = _immutableParamsLength();\n        assembly {\n            id := calldataload(add(sub(calldatasize(), paramsLength), 61))\n        }\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Sends some number of NFTs to a recipient address\n     * @dev Even though we specify the NFT address here, this internal function is only\n     * used to send NFTs associated with this specific pool.\n     * @param _nft The address of the NFT to send\n     * @param nftRecipient The receiving address for the NFTs\n     * @param numNFTs The number of NFTs to send\n     */\n    function _sendAnyNFTsToRecipient(IERC1155 _nft, address nftRecipient, uint256 numNFTs) internal virtual {\n        _nft.safeTransferFrom(address(this), nftRecipient, nftId(), numNFTs, bytes(\"\"));\n    }\n\n    /**\n     * @notice Takes NFTs from the caller and sends them into the pair's asset recipient\n     * @dev This is used by the LSSVMPair's swapNFTForToken function.\n     * @param _nft The NFT collection to take from\n     * @param numNFTs The number of NFTs to take\n     * @param isRouter Whether or not to use the router pull flow\n     * @param routerCaller If the caller is a router, passes in which address to pull from (i.e. the router's caller)\n     */\n    function _takeNFTsFromSender(\n        IERC1155 _nft,\n        uint256 numNFTs,\n        ILSSVMPairFactoryLike factory,\n        bool isRouter,\n        address routerCaller\n    ) internal virtual {\n        address _assetRecipient = getAssetRecipient();\n\n        if (isRouter) {\n            // Verify if router is allowed\n            LSSVMRouter router = LSSVMRouter(payable(msg.sender));\n            (bool routerAllowed,) = factory.routerStatus(router);\n            if (!routerAllowed) revert LSSVMPair__NotRouter();\n\n            uint256 _nftId = nftId();\n            uint256 beforeBalance = _nft.balanceOf(_assetRecipient, _nftId);\n            uint256[] memory ids = new uint256[](1);\n            ids[0] = _nftId;\n            uint256[] memory amounts = new uint256[](1);\n            amounts[0] = numNFTs;\n            router.pairTransferERC1155From(_nft, routerCaller, _assetRecipient, ids, amounts);\n            if (_nft.balanceOf(_assetRecipient, _nftId) - beforeBalance != numNFTs) {\n                revert LSSVMPair__NftNotTransferred();\n            }\n        } else {\n            // Pull NFTs directly from sender\n            _nft.safeTransferFrom(msg.sender, _assetRecipient, nftId(), numNFTs, bytes(\"\"));\n        }\n    }\n\n    /**\n     * Owner functions\n     */\n\n    /**\n     * @notice Rescues a specified set of NFTs owned by the pair to the owner address. Only callable by the owner.\n     * @param a The NFT to transfer\n     * @param nftIds The list of IDs of the NFTs to send to the owner\n     */\n    function withdrawERC721(IERC721 a, uint256[] calldata nftIds) external virtual override onlyOwner {\n        uint256 numNFTs = nftIds.length;\n        for (uint256 i; i < numNFTs;) {\n            a.safeTransferFrom(address(this), msg.sender, nftIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers ERC1155 tokens from the pair to the owner. Only callable by the owner.\n     * @param a The NFT to transfer\n     * @param ids The NFT ids to transfer\n     * @param amounts The amounts of each id to transfer\n     */\n    function withdrawERC1155(IERC1155 a, uint256[] calldata ids, uint256[] calldata amounts)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        if (a == IERC1155(nft())) {\n            // Check if we need to emit an event for withdrawing the NFT this pool is trading\n            uint256 _nftId = nftId();\n            uint256 numNFTs = ids.length;\n            uint256 numPairNFTsWithdrawn;\n            for (uint256 i; i < numNFTs;) {\n                if (ids[i] == _nftId) {\n                    numPairNFTsWithdrawn += amounts[i];\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n\n            if (numPairNFTsWithdrawn != 0) {\n                // Only emit for the pair's NFT\n                emit NFTWithdrawal(numPairNFTsWithdrawn);\n            }\n        }\n\n        a.safeBatchTransferFrom(address(this), msg.sender, ids, amounts, bytes(\"\"));\n    }\n}\n"
    },
    "src/ILSSVMPairFactoryLike.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {LSSVMRouter} from \"./LSSVMRouter.sol\";\n\ninterface ILSSVMPairFactoryLike {\n    struct Settings {\n        uint96 bps;\n        address pairAddress;\n    }\n\n    enum PairNFTType {\n        ERC721,\n        ERC1155\n    }\n\n    enum PairTokenType {\n        ETH,\n        ERC20\n    }\n\n    enum PairVariant {\n        ERC721_ETH,\n        ERC721_ERC20,\n        ERC1155_ETH,\n        ERC1155_ERC20\n    }\n\n    function protocolFeeMultiplier() external view returns (uint256);\n\n    function protocolFeeRecipient() external view returns (address payable);\n\n    function callAllowed(address target) external view returns (bool);\n\n    function authAllowedForToken(address tokenAddress, address proposedAuthAddress) external view returns (bool);\n\n    function getSettingsForPair(address pairAddress) external view returns (bool settingsEnabled, uint96 bps);\n\n    function enableSettingsForPair(address settings, address pairAddress) external;\n\n    function disableSettingsForPair(address settings, address pairAddress) external;\n\n    function routerStatus(LSSVMRouter router) external view returns (bool allowed, bool wasEverTouched);\n\n    function isValidPair(address pairAddress) external view returns (bool);\n\n    function getPairNFTType(address pairAddress) external pure returns (PairNFTType);\n\n    function getPairTokenType(address pairAddress) external pure returns (PairTokenType);\n\n    function openLock() external;\n\n    function closeLock() external;\n}\n"
    },
    "src/bonding-curves/CurveErrorCodes.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\ncontract CurveErrorCodes {\n    enum Error {\n        OK, // No error\n        INVALID_NUMITEMS, // The numItem value is 0\n        SPOT_PRICE_OVERFLOW, // The updated spot price doesn't fit into 128 bits\n        DELTA_OVERFLOW, // The updated delta doesn't fit into 128 bits\n        SPOT_PRICE_UNDERFLOW // The updated spot price goes too low\n    }\n}\n"
    },
    "src/bonding-curves/ICurve.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {CurveErrorCodes} from \"./CurveErrorCodes.sol\";\n\ninterface ICurve {\n    /**\n     * @notice Validates if a delta value is valid for the curve. The criteria for\n     * validity can be different for each type of curve, for instance ExponentialCurve\n     * requires delta to be greater than 1.\n     * @param delta The delta value to be validated\n     * @return valid True if delta is valid, false otherwise\n     */\n    function validateDelta(uint128 delta) external pure returns (bool valid);\n\n    /**\n     * @notice Validates if a new spot price is valid for the curve. Spot price is generally assumed to be the immediate sell price of 1 NFT to the pool, in units of the pool's paired token.\n     * @param newSpotPrice The new spot price to be set\n     * @return valid True if the new spot price is valid, false otherwise\n     */\n    function validateSpotPrice(uint128 newSpotPrice) external view returns (bool valid);\n\n    /**\n     * @notice Given the current state of the pair and the trade, computes how much the user\n     * should pay to purchase an NFT from the pair, the new spot price, and other values.\n     * @param spotPrice The current selling spot price of the pair, in tokens\n     * @param delta The delta parameter of the pair, what it means depends on the curve\n     * @param numItems The number of NFTs the user is buying from the pair\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\n     * @return newSpotPrice The updated selling spot price, in tokens\n     * @return newDelta The updated delta, used to parameterize the bonding curve\n     * @return inputValue The amount that the user should pay, in tokens\n     * @return tradeFee The amount that is sent to the trade fee recipient\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\n     */\n    function getBuyInfo(\n        uint128 spotPrice,\n        uint128 delta,\n        uint256 numItems,\n        uint256 feeMultiplier,\n        uint256 protocolFeeMultiplier\n    )\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint128 newSpotPrice,\n            uint128 newDelta,\n            uint256 inputValue,\n            uint256 tradeFee,\n            uint256 protocolFee\n        );\n\n    /**\n     * @notice Given the current state of the pair and the trade, computes how much the user\n     * should receive when selling NFTs to the pair, the new spot price, and other values.\n     * @param spotPrice The current selling spot price of the pair, in tokens\n     * @param delta The delta parameter of the pair, what it means depends on the curve\n     * @param numItems The number of NFTs the user is selling to the pair\n     * @param feeMultiplier Determines how much fee the LP takes from this trade, 18 decimals\n     * @param protocolFeeMultiplier Determines how much fee the protocol takes from this trade, 18 decimals\n     * @return error Any math calculation errors, only Error.OK means the returned values are valid\n     * @return newSpotPrice The updated selling spot price, in tokens\n     * @return newDelta The updated delta, used to parameterize the bonding curve\n     * @return outputValue The amount that the user should receive, in tokens\n     * @return tradeFee The amount that is sent to the trade fee recipient\n     * @return protocolFee The amount of fee to send to the protocol, in tokens\n     */\n    function getSellInfo(\n        uint128 spotPrice,\n        uint128 delta,\n        uint256 numItems,\n        uint256 feeMultiplier,\n        uint256 protocolFeeMultiplier\n    )\n        external\n        view\n        returns (\n            CurveErrorCodes.Error error,\n            uint128 newSpotPrice,\n            uint128 newDelta,\n            uint256 outputValue,\n            uint256 tradeFee,\n            uint256 protocolFee\n        );\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/royalty-registry-solidity/contracts/IRoyaltyEngineV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Lookup engine interface\n */\ninterface IRoyaltyEngineV1 is IERC165 {\n    /**\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\n     *\n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\n        external\n        returns (address payable[] memory recipients, uint256[] memory amounts);\n\n    /**\n     * View only version of getRoyalty\n     *\n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory amounts);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "src/LSSVMRouter.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {LSSVMPair} from \"./LSSVMPair.sol\";\nimport {ILSSVMPairFactoryLike} from \"./ILSSVMPairFactoryLike.sol\";\nimport {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";\n\ncontract LSSVMRouter {\n    using SafeTransferLib for address payable;\n    using SafeTransferLib for ERC20;\n\n    struct PairSwapSpecific {\n        LSSVMPair pair;\n        uint256[] nftIds;\n    }\n\n    struct RobustPairSwapSpecific {\n        PairSwapSpecific swapInfo;\n        uint256 maxCost;\n    }\n\n    struct RobustPairSwapSpecificForToken {\n        PairSwapSpecific swapInfo;\n        uint256 minOutput;\n    }\n\n    struct NFTsForSpecificNFTsTrade {\n        PairSwapSpecific[] nftToTokenTrades;\n        PairSwapSpecific[] tokenToNFTTrades;\n    }\n\n    struct RobustPairNFTsFoTokenAndTokenforNFTsTrade {\n        RobustPairSwapSpecific[] tokenToNFTTrades;\n        RobustPairSwapSpecificForToken[] nftToTokenTrades;\n        uint256 inputAmount;\n        address payable tokenRecipient;\n        address nftRecipient;\n    }\n\n    modifier checkDeadline(uint256 deadline) {\n        _checkDeadline(deadline);\n        _;\n    }\n\n    ILSSVMPairFactoryLike public immutable factory;\n\n    constructor(ILSSVMPairFactoryLike _factory) {\n        factory = _factory;\n    }\n\n    /**\n     * ETH swaps\n     */\n\n    /**\n     * @notice Swaps ETH into specific NFTs using multiple pairs.\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     * @param ethRecipient The address that will receive the unspent ETH input\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return remainingValue The unspent ETH amount\n     */\n    function swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 remainingValue) {\n        return _swapETHForSpecificNFTs(swapList, msg.value, ethRecipient, nftRecipient);\n    }\n\n    /**\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\n     * ETH as the intermediary.\n     * @param trade The struct containing all NFT-to-ETH swaps and ETH-to-NFT swaps.\n     * @param minOutput The minimum acceptable total excess ETH received\n     * @param ethRecipient The address that will receive the ETH output\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return outputAmount The total ETH received\n     */\n    function swapNFTsForSpecificNFTsThroughETH(\n        NFTsForSpecificNFTsTrade calldata trade,\n        uint256 minOutput,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Swap NFTs for ETH\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(address(this)));\n\n        // Add extra value to buy NFTs\n        outputAmount += msg.value;\n\n        // Swap ETH for specific NFTs\n        // cost <= inputValue = outputAmount - minOutput, so outputAmount' = (outputAmount - minOutput - cost) + minOutput >= minOutput\n        outputAmount = _swapETHForSpecificNFTs(\n            trade.tokenToNFTTrades, outputAmount - minOutput, ethRecipient, nftRecipient\n        ) + minOutput;\n    }\n\n    /**\n     * ERC20 swaps\n     *\n     * Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved.\n     * Swapping using multiple tokens in the same transaction is possible, but the slippage checks\n     * & the return values will be meaningless, and may lead to undefined behavior.\n     *\n     * Note: The sender should ideally grant infinite token approval to the router in order for NFT-to-NFT\n     * swaps to work smoothly.\n     */\n\n    /**\n     * @notice Swaps ERC20 tokens into specific NFTs using multiple pairs.\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return remainingValue The unspent token amount\n     */\n    function swapERC20ForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address nftRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 remainingValue) {\n        return _swapERC20ForSpecificNFTs(swapList, inputAmount, nftRecipient);\n    }\n\n    /**\n     * @notice Swaps NFTs into ETH/ERC20 using multiple pairs.\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\n     * @param minOutput The minimum acceptable total tokens received\n     * @param tokenRecipient The address that will receive the token output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return outputAmount The total tokens received\n     */\n    function swapNFTsForToken(\n        PairSwapSpecific[] calldata swapList,\n        uint256 minOutput,\n        address tokenRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\n        return _swapNFTsForToken(swapList, minOutput, payable(tokenRecipient));\n    }\n\n    /**\n     * @notice Swaps one set of NFTs into another set of specific NFTs using multiple pairs, using\n     * an ERC20 token as the intermediary.\n     * @param trade The struct containing all NFT-to-ERC20 swaps and ERC20-to-NFT swaps.\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     * @param minOutput The minimum acceptable total excess tokens received\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return outputAmount The total ERC20 tokens received\n     */\n    function swapNFTsForSpecificNFTsThroughERC20(\n        NFTsForSpecificNFTsTrade calldata trade,\n        uint256 inputAmount,\n        uint256 minOutput,\n        address nftRecipient,\n        uint256 deadline\n    ) external checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Swap NFTs for ERC20\n        // minOutput of swap set to 0 since we're doing an aggregate slippage check\n        // output tokens are sent to msg.sender\n        outputAmount = _swapNFTsForToken(trade.nftToTokenTrades, 0, payable(msg.sender));\n\n        // Add extra value to buy NFTs\n        outputAmount += inputAmount;\n\n        // Swap ERC20 for specific NFTs\n        // cost <= maxCost = outputAmount - minOutput, so outputAmount' = outputAmount - cost >= minOutput\n        // input tokens are taken directly from msg.sender\n        outputAmount =\n            _swapERC20ForSpecificNFTs(trade.tokenToNFTTrades, outputAmount - minOutput, nftRecipient) + minOutput;\n    }\n\n    /**\n     * Robust Swaps\n     * These are \"robust\" versions of the NFT<>Token swap functions which will never revert due to slippage\n     * Instead, users specify a per-swap max cost. If the price changes more than the user specifies, no swap is attempted. This allows users to specify a batch of swaps, and execute as many of them as possible.\n     */\n\n    /**\n     * @dev Ensure msg.value >= sum of values in maxCostPerPair to make sure the transaction doesn't revert\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     * @param ethRecipient The address that will receive the unspent ETH input\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return remainingValue The unspent token amount\n     */\n    function robustSwapETHForSpecificNFTs(\n        RobustPairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) public payable virtual checkDeadline(deadline) returns (uint256 remainingValue) {\n        remainingValue = msg.value;\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate actual cost per swap\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\n            );\n\n            // If within our maxCost and no error, proceed\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                // We know how much ETH to send because we already did the math above\n                // So we just send that much\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return remaining value to sender\n        if (remainingValue > 0) {\n            ethRecipient.safeTransferETH(remainingValue);\n        }\n    }\n\n    /**\n     * @notice Swaps as many ERC20 tokens for specific NFTs as possible, respecting the per-swap max cost.\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n     * @param inputAmount The amount of ERC20 tokens to add to the ERC20-to-NFT swaps\n     * @param nftRecipient The address that will receive the NFT output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return remainingValue The unspent token amount\n     */\n    function robustSwapERC20ForSpecificNFTs(\n        RobustPairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address nftRecipient,\n        uint256 deadline\n    ) public virtual checkDeadline(deadline) returns (uint256 remainingValue) {\n        remainingValue = inputAmount;\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate actual cost per swap\n            (error,,, pairCost,,) = swapList[i].swapInfo.pair.getBuyNFTQuote(\n                swapList[i].swapInfo.nftIds[0], swapList[i].swapInfo.nftIds.length\n            );\n\n            // If within our maxCost and no error, proceed\n            if (pairCost <= swapList[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                remainingValue -= swapList[i].swapInfo.pair.swapTokenForSpecificNFTs(\n                    swapList[i].swapInfo.nftIds, pairCost, nftRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Swaps as many NFTs for tokens as possible, respecting the per-swap min output\n     * @param swapList The list of pairs to trade with and the IDs of the NFTs to sell to each.\n     * @param tokenRecipient The address that will receive the token output\n     * @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n     * @return outputAmount The total ETH/ERC20 received\n     */\n    function robustSwapNFTsForToken(\n        RobustPairSwapSpecificForToken[] calldata swapList,\n        address payable tokenRecipient,\n        uint256 deadline\n    ) public virtual checkDeadline(deadline) returns (uint256 outputAmount) {\n        // Try doing each swap\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            uint256 pairOutput;\n\n            // Locally scoped to avoid stack too deep error\n            {\n                CurveErrorCodes.Error error;\n                uint256[] memory nftIds = swapList[i].swapInfo.nftIds;\n                if (nftIds.length == 0) {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n                (error,,, pairOutput,,) = swapList[i].swapInfo.pair.getSellNFTQuote(nftIds[0], nftIds.length);\n                if (error != CurveErrorCodes.Error.OK) {\n                    unchecked {\n                        ++i;\n                    }\n                    continue;\n                }\n            }\n\n            // If at least equal to our minOutput, proceed\n            if (pairOutput >= swapList[i].minOutput) {\n                // Do the swap and update outputAmount with how many tokens we got\n                outputAmount += swapList[i].swapInfo.pair.swapNFTsForToken(\n                    swapList[i].swapInfo.nftIds, 0, tokenRecipient, true, msg.sender\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Buys NFTs with ETH and sells them for tokens in one transaction\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\n     * - ethToNFTSwapList The list of NFTs to buy\n     * - nftToTokenSwapList The list of NFTs to sell\n     * - inputAmount The max amount of tokens to send (if ERC20)\n     * - tokenRecipient The address that receives tokens from the NFTs sold\n     * - nftRecipient The address that receives NFTs\n     * - deadline UNIX timestamp deadline for the swap\n     */\n    function robustSwapETHForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\n        external\n        payable\n        virtual\n        returns (uint256 remainingValue, uint256 outputAmount)\n    {\n        {\n            remainingValue = msg.value;\n            uint256 pairCost;\n            CurveErrorCodes.Error error;\n\n            // Try doing each swap\n            uint256 numSwaps = params.tokenToNFTTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                // Calculate actual cost per swap\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\n                );\n\n                // If within our maxCost and no error, proceed\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                    // We know how much ETH to send because we already did the math above\n                    // So we just send that much\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs{value: pairCost}(\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Return remaining value to sender\n            if (remainingValue > 0) {\n                params.tokenRecipient.safeTransferETH(remainingValue);\n            }\n        }\n        {\n            // Try doing each swap\n            uint256 numSwaps = params.nftToTokenTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                uint256 pairOutput;\n\n                // Locally scoped to avoid stack too deep error\n                {\n                    CurveErrorCodes.Error error;\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\n                    );\n                    if (error != CurveErrorCodes.Error.OK) {\n                        unchecked {\n                            ++i;\n                        }\n                        continue;\n                    }\n                }\n\n                // If at least equal to our minOutput, proceed\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\n                    // Do the swap and update outputAmount with how many tokens we got\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Buys NFTs with ERC20, and sells them for tokens in one transaction\n     * @param params All the parameters for the swap (packed in struct to avoid stack too deep), containing:\n     * - ethToNFTSwapList The list of NFTs to buy\n     * - nftToTokenSwapList The list of NFTs to sell\n     * - inputAmount The max amount of tokens to send (if ERC20)\n     * - tokenRecipient The address that receives tokens from the NFTs sold\n     * - nftRecipient The address that receives NFTs\n     * - deadline UNIX timestamp deadline for the swap\n     */\n    function robustSwapERC20ForSpecificNFTsAndNFTsToToken(RobustPairNFTsFoTokenAndTokenforNFTsTrade calldata params)\n        external\n        virtual\n        returns (uint256 remainingValue, uint256 outputAmount)\n    {\n        {\n            remainingValue = params.inputAmount;\n            uint256 pairCost;\n            CurveErrorCodes.Error error;\n\n            // Try doing each swap\n            uint256 numSwaps = params.tokenToNFTTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                // Calculate actual cost per swap\n                (error,,, pairCost,,) = params.tokenToNFTTrades[i].swapInfo.pair.getBuyNFTQuote(\n                    params.tokenToNFTTrades[i].swapInfo.nftIds[0], params.tokenToNFTTrades[i].swapInfo.nftIds.length\n                );\n\n                // If within our maxCost and no error, proceed\n                if (pairCost <= params.tokenToNFTTrades[i].maxCost && error == CurveErrorCodes.Error.OK) {\n                    remainingValue -= params.tokenToNFTTrades[i].swapInfo.pair.swapTokenForSpecificNFTs(\n                        params.tokenToNFTTrades[i].swapInfo.nftIds, pairCost, params.nftRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        {\n            // Try doing each swap\n            uint256 numSwaps = params.nftToTokenTrades.length;\n            for (uint256 i; i < numSwaps;) {\n                uint256 pairOutput;\n\n                // Locally scoped to avoid stack too deep error\n                {\n                    CurveErrorCodes.Error error;\n                    uint256 assetId = params.nftToTokenTrades[i].swapInfo.nftIds[0];\n                    (error,,, pairOutput,,) = params.nftToTokenTrades[i].swapInfo.pair.getSellNFTQuote(\n                        assetId, params.nftToTokenTrades[i].swapInfo.nftIds.length\n                    );\n                    if (error != CurveErrorCodes.Error.OK) {\n                        unchecked {\n                            ++i;\n                        }\n                        continue;\n                    }\n                }\n\n                // If at least equal to our minOutput, proceed\n                if (pairOutput >= params.nftToTokenTrades[i].minOutput) {\n                    // Do the swap and update outputAmount with how many tokens we got\n                    outputAmount += params.nftToTokenTrades[i].swapInfo.pair.swapNFTsForToken(\n                        params.nftToTokenTrades[i].swapInfo.nftIds, 0, params.tokenRecipient, true, msg.sender\n                    );\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    /**\n     * Restricted functions\n     */\n\n    /**\n     * @dev Allows an ERC20 pair contract to transfer ERC20 tokens directly from\n     * the sender, in order to minimize the number of token transfers. Only callable by an ERC20 pair.\n     * @param token The ERC20 token to transfer\n     * @param from The address to transfer tokens from\n     * @param to The address to transfer tokens to\n     * @param amount The amount of tokens to transfer\n     */\n    function pairTransferERC20From(ERC20 token, address from, address to, uint256 amount) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n        // verify caller is an ERC20 pair\n        require(factory.getPairTokenType(msg.sender) == ILSSVMPairFactoryLike.PairTokenType.ERC20, \"Not ERC20 pair\");\n\n        // transfer tokens to pair\n        token.safeTransferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Allows a pair contract to transfer ERC721 NFTs directly from\n     * the sender, in order to minimize the number of token transfers. Only callable by a pair.\n     * @param nft The ERC721 NFT to transfer\n     * @param from The address to transfer tokens from\n     * @param to The address to transfer tokens to\n     * @param id The ID of the NFT to transfer\n     */\n    function pairTransferNFTFrom(IERC721 nft, address from, address to, uint256 id) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n\n        // transfer NFTs to pair\n        nft.transferFrom(from, to, id);\n    }\n\n    function pairTransferERC1155From(\n        IERC1155 nft,\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        // verify caller is a trusted pair contract\n        require(factory.isValidPair(msg.sender), \"Not pair\");\n\n        nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\"));\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @param deadline The last valid time for a swap\n     */\n    function _checkDeadline(uint256 deadline) internal view {\n        require(block.timestamp <= deadline, \"Deadline passed\");\n    }\n\n    /**\n     * @notice Internal function used to swap ETH for a specific set of NFTs\n     * @param swapList The list of pairs and swap calldata\n     * @param inputAmount The total amount of ETH to send\n     * @param ethRecipient The address receiving excess ETH\n     * @param nftRecipient The address receiving the NFTs from the pairs\n     * @return remainingValue The unspent token amount\n     */\n    function _swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        uint256 inputAmount,\n        address payable ethRecipient,\n        address nftRecipient\n    ) internal virtual returns (uint256 remainingValue) {\n        remainingValue = inputAmount;\n\n        uint256 pairCost;\n        CurveErrorCodes.Error error;\n\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Calculate the cost per swap first to send exact amount of ETH over, saves gas by avoiding the need to send back excess ETH\n            (error,,, pairCost,,) = swapList[i].pair.getBuyNFTQuote(swapList[i].nftIds[0], swapList[i].nftIds.length);\n\n            // Require no errors\n            require(error == CurveErrorCodes.Error.OK, \"Bonding curve error\");\n\n            // Total ETH taken from sender cannot exceed inputAmount\n            // because otherwise the deduction from remainingValue will fail\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return remaining value to sender\n        if (remainingValue > 0) {\n            ethRecipient.safeTransferETH(remainingValue);\n        }\n    }\n\n    /**\n     * @notice Internal function used to swap an ERC20 token for specific NFTs\n     * @dev Note that we don't need to query the pair's bonding curve first for pricing data because\n     * we just calculate and take the required amount from the caller during swap time.\n     * However, we can't \"pull\" ETH, which is why for the ETH->NFT swaps, we need to calculate the pricing info\n     * to figure out how much the router should send to the pool.\n     * @param swapList The list of pairs and swap calldata\n     * @param inputAmount The total amount of ERC20 tokens to send\n     * @param nftRecipient The address receiving the NFTs from the pairs\n     * @return remainingValue The unspent token amount\n     */\n    function _swapERC20ForSpecificNFTs(PairSwapSpecific[] calldata swapList, uint256 inputAmount, address nftRecipient)\n        internal\n        virtual\n        returns (uint256 remainingValue)\n    {\n        remainingValue = inputAmount;\n\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Tokens are transferred in by the pair calling router.pairTransferERC20From\n            // Total tokens taken from sender cannot exceed inputAmount\n            // because otherwise the deduction from remainingValue will fail\n            remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs(\n                swapList[i].nftIds, remainingValue, nftRecipient, true, msg.sender\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Swaps NFTs for tokens, designed to be used for 1 token at a time\n     * @dev Calling with multiple tokens is permitted, BUT minOutput will be\n     * far from enough of a safety check because different tokens almost certainly have different unit prices.\n     * @param swapList The list of pairs and swap calldata\n     * @param minOutput The minimum number of tokens to be receieved from the swaps\n     * @param tokenRecipient The address that receives the tokens\n     * @return outputAmount The number of tokens to be received\n     */\n    function _swapNFTsForToken(PairSwapSpecific[] calldata swapList, uint256 minOutput, address payable tokenRecipient)\n        internal\n        virtual\n        returns (uint256 outputAmount)\n    {\n        // Do swaps\n        uint256 numSwaps = swapList.length;\n        for (uint256 i; i < numSwaps;) {\n            // Do the swap for token and then update outputAmount\n            // Note: minExpectedTokenOutput is set to 0 since we're doing an aggregate slippage check below\n            outputAmount += swapList[i].pair.swapNFTsForToken(swapList[i].nftIds, 0, tokenRecipient, true, msg.sender);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Aggregate slippage check\n        require(outputAmount >= minOutput, \"outputAmount too low\");\n    }\n}\n"
    },
    "src/lib/IOwnershipTransferReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.4;\n\ninterface IOwnershipTransferReceiver {\n    function onOwnershipTransferred(address oldOwner, bytes memory data) external payable;\n}\n"
    },
    "src/lib/OwnableWithTransferCallback.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.4;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {IOwnershipTransferReceiver} from \"./IOwnershipTransferReceiver.sol\";\n\nabstract contract OwnableWithTransferCallback {\n    using ERC165Checker for address;\n    using Address for address;\n\n    bytes4 constant TRANSFER_CALLBACK = type(IOwnershipTransferReceiver).interfaceId;\n\n    error Ownable_NotOwner();\n    error Ownable_NewOwnerZeroAddress();\n\n    address private _owner;\n\n    event OwnershipTransferred(address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal {\n        _owner = initialOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert Ownable_NotOwner();\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * @param newOwner The new address to become owner\n     * @param data Any additional data to send to the ownership received callback.\n     * Disallows setting to the zero address as a way to more gas-efficiently avoid reinitialization.\n     * When ownership is transferred, if the new owner implements IOwnershipTransferCallback, we make a callback.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner, bytes calldata data) public payable virtual onlyOwner {\n        if (newOwner == address(0)) revert Ownable_NewOwnerZeroAddress();\n        _transferOwnership(newOwner);\n\n        if (newOwner.isContract()) {\n            try IOwnershipTransferReceiver(newOwner).onOwnershipTransferred{value: msg.value}(msg.sender, data) {}\n            // If revert...\n            catch (bytes memory reason) {\n                // If we just transferred to a contract w/ no callback, this is fine\n                if (reason.length == 0) {\n                    // i.e., no need to revert\n                }\n                // Otherwise, the callback had an error, and we should revert\n                else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\n     * @dev Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        _owner = newOwner;\n        emit OwnershipTransferred(newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@manifoldxyz/=lib/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@prb/math/=lib/prb-math/src/",
      "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",
      "create3-factory/=lib/create3-factory/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "libraries-solidity/=lib/libraries-solidity/contracts/",
      "manifoldxyz/=lib/royalty-registry-solidity/contracts/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "royalty-registry-solidity/=lib/royalty-registry-solidity/contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}}