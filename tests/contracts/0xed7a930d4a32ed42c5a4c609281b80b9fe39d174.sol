{{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/contracts/interfaces/IOnChainMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IOnChainMetadata {\n  /**\n   * Mint new tokens.\n   */\n  function tokenURI(uint256 tokenId_) external view returns (string memory);\n\n  function tokenImageDataURI(uint256 tokenId_) external view returns (string memory);\n}\n"
    },
    "src/contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary Math {\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow, so we distribute\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n  }\n\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b + (a % b == 0 ? 0 : 1);\n  }\n}\n"
    },
    "src/contracts/libraries/SymmetricEncryptionUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IOnChainMetadata.sol\";\nimport \"../tokens/erc721/custom-erc721/ERC721AEnumerable.sol\";\nimport \"../libraries/Math.sol\";\n\nlibrary SymmetricEncryptionUtils {\n  function bytesToBytes32Arr(bytes memory source) internal pure returns (bytes32[] memory) {\n    uint256 sourceLen = source.length;\n    bytes32[] memory result = new bytes32[](Math.ceilDiv(sourceLen, 32));\n\n    for (uint256 i = 0; i < result.length; i++) {\n      for (uint256 j = 0; j < 32; j++) {\n        uint256 index = i * 32 + j;\n        if (index >= sourceLen) {\n          result[i] |= bytes32(0) >> (8 * j);\n        } else {\n          result[i] |= bytes32(source[index]) >> (8 * j);\n        }\n      }\n    }\n    return result;\n  }\n\n  function bytes32ArrToBytes(bytes32[] memory source) internal pure returns (bytes memory) {\n    bytes memory result = new bytes(source.length * 32);\n    for (uint256 i = 0; i < source.length; i++) {\n      for (uint256 j = 0; j < 32; j++) {\n        result[i * 32 + j] = bytes1(source[i] << (8 * j));\n      }\n    }\n    return result;\n  }\n\n  function encrypt(\n    bytes32 decryptionKey,\n    bytes32[] memory secret\n  ) internal pure returns (bytes32[] memory) {\n    bytes32[] memory encrypted = new bytes32[](secret.length);\n    for (uint256 i = 0; i < secret.length; i++) {\n      encrypted[i] = secret[i] ^ decryptionKey;\n    }\n    return encrypted;\n  }\n\n  function bytesTrimEnd(bytes memory source) internal pure returns (bytes memory result) {\n    uint256 len = 0;\n    for (uint256 i = 0; i < source.length; i++) {\n      if (source[i] == 0) {\n        len = i;\n        break;\n      }\n    }\n    result = new bytes(len);\n    for (uint256 i = 0; i < len; i++) {\n      result[i] = source[i];\n    }\n    return result;\n  }\n}\n"
    },
    "src/contracts/pre-mint/MTE.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IOnChainMetadata.sol\";\nimport \"../tokens/erc721/custom-erc721/ERC721AEnumerable.sol\";\nimport \"../libraries/SymmetricEncryptionUtils.sol\";\n\n// import \"@forge-std/src/console.sol\";\n\nerror NotUnlockedYet();\nerror AlreadyUnlocked();\nerror MaxSupplyReached();\nerror AlreadyClaimed();\nerror InvalidSecret();\nerror InsufficientFunds();\nerror InvalidAmount();\n\n/// @title A title that should describe the contract/interface\n/// @author The name of the author\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\ncontract MTE is ERC721AEnumerable, Ownable {\n  IOnChainMetadata public metadata;\n  bytes32 internal immutable secretHash;\n  bytes internal hiddenLore;\n\n  uint256 public immutable price;\n  uint256 public immutable maxSupply;\n  mapping(address => bool) public hasClaimed;\n  string public externalUrl;\n\n  mapping(uint256 => uint256) public tokenTypes;\n  uint256 public constant CHOSEN_ONE = 1;\n  uint256 public constant FREE_MINT = 2;\n  uint256 public constant PREMIUM_MINT = 3;\n\n  event Unlocked(address user);\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    IOnChainMetadata metadataAddr_,\n    bytes32 secretHash_,\n    bytes memory hiddenLore_,\n    uint256 maxSupply_,\n    uint256 price_,\n    string memory externalUrl_\n  ) ERC721AEnumerable(name_, symbol_) {\n    metadata = metadataAddr_;\n    secretHash = secretHash_;\n    hiddenLore = hiddenLore_;\n    maxSupply = maxSupply_;\n    price = price_;\n    externalUrl = externalUrl_;\n  }\n\n  function setName(string memory name_) external onlyOwner {\n    _name = name_;\n  }\n\n  function setSymbol(string memory symbol_) external onlyOwner {\n    _symbol = symbol_;\n  }\n\n  function unlock(string memory secret) external {\n    if (totalSupply() > 0) revert AlreadyUnlocked();\n    if (totalSupply() >= maxSupply) revert MaxSupplyReached();\n    if (keccak256(abi.encodePacked(secret)) != secretHash) revert InvalidSecret();\n    emit Unlocked(msg.sender);\n    tokenTypes[_nextTokenId()] = CHOSEN_ONE;\n    _safeMint(msg.sender, 1);\n  }\n\n  function isUnlocked() external view returns (bool) {\n    return totalSupply() > 0;\n  }\n\n  function mint(uint8 amount_) external payable {\n    if (totalSupply() == 0) revert NotUnlockedYet();\n    if (totalSupply() + amount_ > maxSupply) revert MaxSupplyReached();\n    if (amount_ == 0) revert InvalidAmount();\n    if (hasClaimed[msg.sender]) revert AlreadyClaimed();\n    hasClaimed[msg.sender] = true;\n\n    if (amount_ == 1) {\n      tokenTypes[_nextTokenId()] = FREE_MINT;\n      _safeMint(msg.sender, 1);\n    } else if (amount_ == 2) {\n      if (msg.value != price) revert InsufficientFunds();\n      uint256 tokenId = _nextTokenId();\n      tokenTypes[tokenId] = FREE_MINT;\n      tokenTypes[tokenId + 1] = PREMIUM_MINT;\n      _safeMint(msg.sender, 2);\n    } else revert InvalidAmount();\n  }\n\n  function tokenURI(\n    uint256 tokenId\n  ) public view virtual override(IERC721A, ERC721A) returns (string memory) {\n    if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n    return metadata.tokenURI(tokenId);\n  }\n\n  function setExternalUrl(string memory externalUrl_) external onlyOwner {\n    externalUrl = externalUrl_;\n  }\n\n  function h1dd3n(string memory secretKey) external view returns (string memory) {\n    require(totalSupply() > 0, \"Not unlocked yet\");\n    bytes32 decryptionKey = keccak256(abi.encodePacked(secretKey));\n\n    return\n      string(\n        SymmetricEncryptionUtils.bytesTrimEnd(\n          SymmetricEncryptionUtils.bytes32ArrToBytes(\n            SymmetricEncryptionUtils.encrypt(\n              decryptionKey,\n              SymmetricEncryptionUtils.bytesToBytes32Arr(hiddenLore)\n            )\n          )\n        )\n      );\n  }\n\n  function reveal(IOnChainMetadata revealOnChainMetadataAddr_) external onlyOwner {\n    metadata = revealOnChainMetadataAddr_;\n  }\n\n  function withdraw() external onlyOwner {\n    payable(msg.sender).transfer(address(this).balance);\n  }\n}\n// On Tupac's Soul\n"
    },
    "src/contracts/tokens/erc721/custom-erc721/ERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on ERC721A Contracts v4.2.3 from Chiru Labs and Citizens of Tajigen's Tiny ERC721 using Mason and Chance's optimizations\n// added modifications on top\n\npragma solidity ^0.8.4;\n\nimport \"./IERC721A.sol\";\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n  // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n  struct TokenApprovalRef {\n    address value;\n  }\n\n  // =============================================================\n  //                           CONSTANTS\n  // =============================================================\n\n  // Mask of an entry in packed address data.\n  uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n  // The bit position of `numberMinted` in packed address data.\n  uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n  // The bit position of `numberBurned` in packed address data.\n  uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n  // The bit position of `aux` in packed address data.\n  uint256 private constant _BITPOS_AUX = 192;\n\n  // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n  uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n  // The bit position of `startTimestamp` in packed ownership.\n  uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n  // The bit mask of the `burned` bit in packed ownership.\n  uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n  // The bit position of the `nextInitialized` bit in packed ownership.\n  uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n  // The bit mask of the `nextInitialized` bit in packed ownership.\n  uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n  // The bit position of `extraData` in packed ownership.\n  uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n  // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n  uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n  // The mask of the lower 160 bits for addresses.\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n  // The maximum `quantity` that can be minted with {_mintERC2309}.\n  // This limit is to prevent overflows on the address data entries.\n  // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n  // is required to cause an overflow, which is unrealistic.\n  uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n  // The `Transfer` event signature is given by:\n  // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n  bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n    0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n  // =============================================================\n  //                            STORAGE\n  // =============================================================\n\n  // The next token ID to be minted.\n  uint256 private _currentIndex;\n\n  // The number of tokens burned.\n  uint256 private _burnCounter;\n\n  // Token name\n  string internal _name;\n\n  // Token symbol\n  string internal _symbol;\n\n  // Mapping from token ID to ownership details\n  // An empty struct value does not necessarily mean the token is unowned.\n  // See {_packedOwnershipOf} implementation for details.\n  //\n  // Bits Layout:\n  // - [0..159]   `addr`\n  // - [160..223] `startTimestamp`\n  // - [224]      `burned`\n  // - [225]      `nextInitialized`\n  // - [232..255] `extraData`\n  mapping(uint256 => uint256) private _packedOwnerships;\n\n  // Mapping owner address to address data.\n  //\n  // Bits Layout:\n  // - [0..63]    `balance`\n  // - [64..127]  `numberMinted`\n  // - [128..191] `numberBurned`\n  // - [192..255] `aux`\n  mapping(address => uint256) private _packedAddressData;\n\n  // Mapping from token ID to approved address.\n  mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  // =============================================================\n  //                          CONSTRUCTOR\n  // =============================================================\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _currentIndex = _startTokenId();\n  }\n\n  // =============================================================\n  //                   TOKEN COUNTING OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Returns the starting token ID.\n   * To change the starting token ID, please override this function.\n   */\n  function _startTokenId() internal view virtual returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev Returns the next token ID to be minted.\n   */\n  function _nextTokenId() internal view virtual returns (uint256) {\n    return _currentIndex;\n  }\n\n  /**\n   * @dev Returns the total number of tokens in existence.\n   * Burned tokens will reduce the count.\n   * To get the total number of tokens minted, please see {_totalMinted}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    // Counter underflow is impossible as _burnCounter cannot be incremented\n    // more than `_currentIndex - _startTokenId()` times.\n    unchecked {\n      return _currentIndex - _burnCounter - _startTokenId();\n    }\n  }\n\n  /**\n   * @dev Returns the total amount of tokens minted in the contract.\n   */\n  function _totalMinted() internal view virtual returns (uint256) {\n    // Counter underflow is impossible as `_currentIndex` does not decrement,\n    // and it is initialized to `_startTokenId()`.\n    unchecked {\n      return _currentIndex - _startTokenId();\n    }\n  }\n\n  /**\n   * @dev Returns the total number of tokens burned.\n   */\n  function _totalBurned() internal view virtual returns (uint256) {\n    return _burnCounter;\n  }\n\n  // =============================================================\n  //                    ADDRESS DATA OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Returns the number of tokens in `owner`'s account.\n   */\n  function balanceOf(address owner) public view virtual override returns (uint256) {\n    if (owner == address(0)) revert BalanceQueryForZeroAddress();\n    return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n  }\n\n  /**\n   * Returns the number of tokens minted by `owner`.\n   */\n  function _numberMinted(address owner) internal view returns (uint256) {\n    return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n  }\n\n  /**\n   * Returns the number of tokens burned by or on behalf of `owner`.\n   */\n  function _numberBurned(address owner) internal view returns (uint256) {\n    return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n  }\n\n  /**\n   * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n   */\n  function _getAux(address owner) internal view returns (uint64) {\n    return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\n  }\n\n  /**\n   * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n   * If there are multiple variables, please pack them into a uint64.\n   */\n  function _setAux(address owner, uint64 aux) internal virtual {\n    uint256 packed = _packedAddressData[owner];\n    uint256 auxCasted;\n    // Cast `aux` with assembly to avoid redundant masking.\n    assembly {\n      auxCasted := aux\n    }\n    packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n    _packedAddressData[owner] = packed;\n  }\n\n  // =============================================================\n  //                            IERC165\n  // =============================================================\n\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    // The interface IDs are constants representing the first 4 bytes\n    // of the XOR of all function selectors in the interface.\n    // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n    // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n    return\n      interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n      interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n      interfaceId == 0x5b5e139f || // ERC165 interface ID for ERC721Metadata.\n      interfaceId == type(IERC721A).interfaceId;\n  }\n\n  // =============================================================\n  //                        IERC721Metadata\n  // =============================================================\n\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \"\";\n  }\n\n  /**\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n   * by default, it can be overridden in child contracts.\n   */\n  function _baseURI() internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  // =============================================================\n  //                     OWNERSHIPS OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n    return address(uint160(_packedOwnershipOf(tokenId)));\n  }\n\n  /**\n   * @dev Gas spent here starts off proportional to the maximum mint batch size.\n   * It gradually moves to O(1) as tokens get transferred around over time.\n   */\n  function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n    return _unpackedOwnership(_packedOwnershipOf(tokenId));\n  }\n\n  /**\n   * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n   */\n  function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n    return _unpackedOwnership(_packedOwnerships[index]);\n  }\n\n  /**\n   * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n   */\n  function _initializeOwnershipAt(uint256 index) internal virtual {\n    if (_packedOwnerships[index] == 0) _packedOwnerships[index] = _packedOwnershipOf(index);\n  }\n\n  /**\n   * Returns the packed ownership data of `tokenId`.\n   */\n  function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\n    if (_startTokenId() <= tokenId) {\n      packed = _packedOwnerships[tokenId];\n      // If not burned.\n      if (packed & _BITMASK_BURNED == 0) {\n        // If the data at the starting slot does not exist, start the scan.\n        if (packed == 0) {\n          if (tokenId >= _currentIndex) revert OwnerQueryForNonexistentToken();\n          // Invariant:\n          // There will always be an initialized ownership slot\n          // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n          // before an unintialized ownership slot\n          // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n          // Hence, `tokenId` will not underflow.\n          //\n          // We can directly compare the packed value.\n          // If the address is zero, packed will be zero.\n          for (;;) {\n            unchecked {\n              packed = _packedOwnerships[--tokenId];\n            }\n            if (packed == 0) continue;\n            return packed;\n          }\n        }\n        // Otherwise, the data exists and is not burned. We can skip the scan.\n        // This is possible because we have already achieved the target condition.\n        // This saves 2143 gas on transfers of initialized tokens.\n        return packed;\n      }\n    }\n    revert OwnerQueryForNonexistentToken();\n  }\n\n  /**\n   * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n   */\n  function _unpackedOwnership(\n    uint256 packed\n  ) private pure returns (TokenOwnership memory ownership) {\n    ownership.addr = address(uint160(packed));\n    ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n    ownership.burned = packed & _BITMASK_BURNED != 0;\n    ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n  }\n\n  /**\n   * @dev Packs ownership data into a single uint256.\n   */\n  function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n    assembly {\n      // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n      owner := and(owner, _BITMASK_ADDRESS)\n      // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n      result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n    }\n  }\n\n  /**\n   * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n   */\n  function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n    // For branchless setting of the `nextInitialized` flag.\n    assembly {\n      // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n      result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n    }\n  }\n\n  // =============================================================\n  //                      APPROVAL OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   */\n  function approve(address to, uint256 tokenId) public payable virtual override {\n    _approve(to, tokenId, true);\n  }\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) public view virtual override returns (address) {\n    if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n    return _tokenApprovals[tokenId].value;\n  }\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom}\n   * for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool approved) public virtual override {\n    _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n    emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n  }\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}.\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  ) public view virtual override returns (bool) {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Returns whether `tokenId` exists.\n   *\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n   *\n   * Tokens start existing when they are minted. See {_mint}.\n   */\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    return\n      _startTokenId() <= tokenId &&\n      tokenId < _currentIndex && // If within bounds,\n      _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n  }\n\n  /**\n   * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n   */\n  function _isSenderApprovedOrOwner(\n    address approvedAddress,\n    address owner,\n    address msgSender\n  ) private pure returns (bool result) {\n    assembly {\n      // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n      owner := and(owner, _BITMASK_ADDRESS)\n      // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\n      msgSender := and(msgSender, _BITMASK_ADDRESS)\n      // `msgSender == owner || msgSender == approvedAddress`.\n      result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n    }\n  }\n\n  /**\n   * @dev Returns the storage slot and value for the approved address of `tokenId`.\n   */\n  function _getApprovedSlotAndAddress(\n    uint256 tokenId\n  ) private view returns (uint256 approvedAddressSlot, address approvedAddress) {\n    TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n    // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n    assembly {\n      approvedAddressSlot := tokenApproval.slot\n      approvedAddress := sload(approvedAddressSlot)\n    }\n  }\n\n  // =============================================================\n  //                      TRANSFER OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token\n   * by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 tokenId) public payable virtual override {\n    uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n    if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n    (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n    // The nested ifs save around 20+ gas over a compound boolean condition.\n    if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n      if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n    if (to == address(0)) revert TransferToZeroAddress();\n\n    _beforeTokenTransfers(from, to, tokenId, 1);\n\n    // Clear approvals from the previous owner.\n    assembly {\n      if approvedAddress {\n        // This is equivalent to `delete _tokenApprovals[tokenId]`.\n        sstore(approvedAddressSlot, 0)\n      }\n    }\n\n    // Underflow of the sender's balance is impossible because we check for\n    // ownership above and the recipient's balance can't realistically overflow.\n    // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n    unchecked {\n      // We can directly increment and decrement the balances.\n      --_packedAddressData[from]; // Updates: `balance -= 1`.\n      ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n      // Updates:\n      // - `address` to the next owner.\n      // - `startTimestamp` to the timestamp of transfering.\n      // - `burned` to `false`.\n      // - `nextInitialized` to `true`.\n      _packedOwnerships[tokenId] = _packOwnershipData(\n        to,\n        _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n      );\n\n      // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n      if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n        uint256 nextTokenId = tokenId + 1;\n        // If the next slot's address is zero and not burned (i.e. packed value is zero).\n        if (_packedOwnerships[nextTokenId] == 0) {\n          // If the next slot is within bounds.\n          if (nextTokenId != _currentIndex) {\n            // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n            _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n          }\n        }\n      }\n    }\n\n    emit Transfer(from, to, tokenId);\n    _afterTokenTransfers(from, to, tokenId, 1);\n  }\n\n  /**\n   * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public payable virtual override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token\n   * by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement\n   * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) public payable virtual override {\n    transferFrom(from, to, tokenId);\n    if (to.code.length != 0)\n      if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n        revert TransferToNonERC721ReceiverImplementer();\n      }\n  }\n\n  /**\n   * @dev Hook that is called before a set of serially-ordered token IDs\n   * are about to be transferred. This includes minting.\n   * And also called before burning one token.\n   *\n   * `startTokenId` - the first token ID to be transferred.\n   * `quantity` - the amount to be transferred.\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` will be minted for `to`.\n   * - When `to` is zero, `tokenId` will be burned by `from`.\n   * - `from` and `to` are never both zero.\n   */\n  function _beforeTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after a set of serially-ordered token IDs\n   * have been transferred. This includes minting.\n   * And also called after one token has been burned.\n   *\n   * `startTokenId` - the first token ID to be transferred.\n   * `quantity` - the amount to be transferred.\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` has been minted for `to`.\n   * - When `to` is zero, `tokenId` has been burned by `from`.\n   * - `from` and `to` are never both zero.\n   */\n  function _afterTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {}\n\n  /**\n   * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n   *\n   * `from` - Previous owner of the given token ID.\n   * `to` - Target address that will receive the token.\n   * `tokenId` - Token ID to be transferred.\n   * `_data` - Optional data to send along with the call.\n   *\n   * Returns whether the call correctly returned the expected magic value.\n   */\n  function _checkContractOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    try\n      ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data)\n    returns (bytes4 retval) {\n      return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n    } catch (bytes memory reason) {\n      if (reason.length == 0) {\n        revert TransferToNonERC721ReceiverImplementer();\n      } else {\n        assembly {\n          revert(add(32, reason), mload(reason))\n        }\n      }\n    }\n  }\n\n  // =============================================================\n  //                        MINT OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Mints `quantity` tokens and transfers them to `to`.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `quantity` must be greater than 0.\n   *\n   * Emits a {Transfer} event for each mint.\n   */\n  function _mint(address to, uint256 quantity) internal virtual {\n    uint256 startTokenId = _currentIndex;\n    if (quantity == 0) revert MintZeroQuantity();\n\n    _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n    // Overflows are incredibly unrealistic.\n    // `balance` and `numberMinted` have a maximum limit of 2**64.\n    // `tokenId` has a maximum limit of 2**256.\n    unchecked {\n      // Updates:\n      // - `balance += quantity`.\n      // - `numberMinted += quantity`.\n      //\n      // We can directly add to the `balance` and `numberMinted`.\n      _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n      // Updates:\n      // - `address` to the owner.\n      // - `startTimestamp` to the timestamp of minting.\n      // - `burned` to `false`.\n      // - `nextInitialized` to `quantity == 1`.\n      _packedOwnerships[startTokenId] = _packOwnershipData(\n        to,\n        _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n      );\n\n      uint256 toMasked;\n      uint256 end = startTokenId + quantity;\n\n      // Use assembly to loop and emit the `Transfer` event for gas savings.\n      // The duplicated `log4` removes an extra check and reduces stack juggling.\n      // The assembly, together with the surrounding Solidity code, have been\n      // delicately arranged to nudge the compiler into producing optimized opcodes.\n      assembly {\n        // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n        toMasked := and(to, _BITMASK_ADDRESS)\n        // Emit the `Transfer` event.\n        log4(\n          0, // Start of data (0, since no data).\n          0, // End of data (0, since no data).\n          _TRANSFER_EVENT_SIGNATURE, // Signature.\n          0, // `address(0)`.\n          toMasked, // `to`.\n          startTokenId // `tokenId`.\n        )\n\n        // The `iszero(eq(,))` check ensures that large values of `quantity`\n        // that overflows uint256 will make the loop run out of gas.\n        // The compiler will optimize the `iszero` away for performance.\n        for {\n          let tokenId := add(startTokenId, 1)\n        } iszero(eq(tokenId, end)) {\n          tokenId := add(tokenId, 1)\n        } {\n          // Emit the `Transfer` event. Similar to above.\n          log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n        }\n      }\n      if (toMasked == 0) revert MintToZeroAddress();\n\n      _currentIndex = end;\n    }\n    _afterTokenTransfers(address(0), to, startTokenId, quantity);\n  }\n\n  /**\n   * @dev Mints `quantity` tokens and transfers them to `to`.\n   *\n   * This function is intended for efficient minting only during contract creation.\n   *\n   * It emits only one {ConsecutiveTransfer} as defined in\n   * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n   * instead of a sequence of {Transfer} event(s).\n   *\n   * Calling this function outside of contract creation WILL make your contract\n   * non-compliant with the ERC721 standard.\n   * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n   * {ConsecutiveTransfer} event is only permissible during contract creation.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `quantity` must be greater than 0.\n   *\n   * Emits a {ConsecutiveTransfer} event.\n   */\n  function _mintERC2309(address to, uint256 quantity) internal virtual {\n    uint256 startTokenId = _currentIndex;\n    if (to == address(0)) revert MintToZeroAddress();\n    if (quantity == 0) revert MintZeroQuantity();\n    if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\n\n    _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n    // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n    unchecked {\n      // Updates:\n      // - `balance += quantity`.\n      // - `numberMinted += quantity`.\n      //\n      // We can directly add to the `balance` and `numberMinted`.\n      _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n      // Updates:\n      // - `address` to the owner.\n      // - `startTimestamp` to the timestamp of minting.\n      // - `burned` to `false`.\n      // - `nextInitialized` to `quantity == 1`.\n      _packedOwnerships[startTokenId] = _packOwnershipData(\n        to,\n        _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n      );\n\n      emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n      _currentIndex = startTokenId + quantity;\n    }\n    _afterTokenTransfers(address(0), to, startTokenId, quantity);\n  }\n\n  /**\n   * @dev Safely mints `quantity` tokens and transfers them to `to`.\n   *\n   * Requirements:\n   *\n   * - If `to` refers to a smart contract, it must implement\n   * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n   * - `quantity` must be greater than 0.\n   *\n   * See {_mint}.\n   *\n   * Emits a {Transfer} event for each mint.\n   */\n  function _safeMint(address to, uint256 quantity, bytes memory _data) internal virtual {\n    _mint(to, quantity);\n\n    unchecked {\n      if (to.code.length != 0) {\n        uint256 end = _currentIndex;\n        uint256 index = end - quantity;\n        do {\n          if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n          }\n        } while (index < end);\n        // Reentrancy protection.\n        if (_currentIndex != end) revert();\n      }\n    }\n  }\n\n  /**\n   * @dev Equivalent to `_safeMint(to, quantity, '')`.\n   */\n  function _safeMint(address to, uint256 quantity) internal virtual {\n    _safeMint(to, quantity, \"\");\n  }\n\n  // =============================================================\n  //                       APPROVAL OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Equivalent to `_approve(to, tokenId, false)`.\n   */\n  function _approve(address to, uint256 tokenId) internal virtual {\n    _approve(to, tokenId, false);\n  }\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the\n   * zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function _approve(address to, uint256 tokenId, bool approvalCheck) internal virtual {\n    address owner = ownerOf(tokenId);\n\n    if (approvalCheck)\n      if (_msgSenderERC721A() != owner)\n        if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n          revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n    _tokenApprovals[tokenId].value = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  // =============================================================\n  //                        BURN OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Equivalent to `_burn(tokenId, false)`.\n   */\n  function _burn(uint256 tokenId) internal virtual {\n    _burn(tokenId, false);\n  }\n\n  /**\n   * @dev Destroys `tokenId`.\n   * The approval is cleared when the token is burned.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n    uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n    address from = address(uint160(prevOwnershipPacked));\n\n    (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n    if (approvalCheck) {\n      // The nested ifs save around 20+ gas over a compound boolean condition.\n      if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n        if (!isApprovedForAll(from, _msgSenderERC721A()))\n          revert TransferCallerNotOwnerNorApproved();\n    }\n\n    _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n    // Clear approvals from the previous owner.\n    assembly {\n      if approvedAddress {\n        // This is equivalent to `delete _tokenApprovals[tokenId]`.\n        sstore(approvedAddressSlot, 0)\n      }\n    }\n\n    // Underflow of the sender's balance is impossible because we check for\n    // ownership above and the recipient's balance can't realistically overflow.\n    // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n    unchecked {\n      // Updates:\n      // - `balance -= 1`.\n      // - `numberBurned += 1`.\n      //\n      // We can directly decrement the balance, and increment the number burned.\n      // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n      _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n      // Updates:\n      // - `address` to the last owner.\n      // - `startTimestamp` to the timestamp of burning.\n      // - `burned` to `true`.\n      // - `nextInitialized` to `true`.\n      _packedOwnerships[tokenId] = _packOwnershipData(\n        from,\n        (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) |\n          _nextExtraData(from, address(0), prevOwnershipPacked)\n      );\n\n      // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n      if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n        uint256 nextTokenId = tokenId + 1;\n        // If the next slot's address is zero and not burned (i.e. packed value is zero).\n        if (_packedOwnerships[nextTokenId] == 0) {\n          // If the next slot is within bounds.\n          if (nextTokenId != _currentIndex) {\n            // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n            _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n          }\n        }\n      }\n    }\n\n    emit Transfer(from, address(0), tokenId);\n    _afterTokenTransfers(from, address(0), tokenId, 1);\n\n    // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n    unchecked {\n      _burnCounter++;\n    }\n  }\n\n  // =============================================================\n  //                     EXTRA DATA OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Directly sets the extra data for the ownership data `index`.\n   */\n  function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n    uint256 packed = _packedOwnerships[index];\n    if (packed == 0) revert OwnershipNotInitializedForExtraData();\n    uint256 extraDataCasted;\n    // Cast `extraData` with assembly to avoid redundant masking.\n    assembly {\n      extraDataCasted := extraData\n    }\n    packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n    _packedOwnerships[index] = packed;\n  }\n\n  /**\n   * @dev Called during each token transfer to set the 24bit `extraData` field.\n   * Intended to be overridden by the cosumer contract.\n   *\n   * `previousExtraData` - the value of `extraData` before transfer.\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` will be minted for `to`.\n   * - When `to` is zero, `tokenId` will be burned by `from`.\n   * - `from` and `to` are never both zero.\n   */\n  function _extraData(\n    address from,\n    address to,\n    uint24 previousExtraData\n  ) internal view virtual returns (uint24) {}\n\n  /**\n   * @dev Returns the next extra data for the packed ownership data.\n   * The returned result is shifted into position.\n   */\n  function _nextExtraData(\n    address from,\n    address to,\n    uint256 prevOwnershipPacked\n  ) private view returns (uint256) {\n    uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n    return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n  }\n\n  // =============================================================\n  //                       OTHER OPERATIONS\n  // =============================================================\n\n  /**\n   * @dev Returns the message sender (defaults to `msg.sender`).\n   *\n   * If you are writing GSN compatible contracts, you need to override this function.\n   */\n  function _msgSenderERC721A() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  /**\n   * @dev Converts a uint256 to its ASCII string decimal representation.\n   */\n  function _toString(uint256 value) internal pure virtual returns (string memory str) {\n    assembly {\n      // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n      // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n      // We will need 1 word for the trailing zeros padding, 1 word for the length,\n      // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n      let m := add(mload(0x40), 0xa0)\n      // Update the free memory pointer to allocate.\n      mstore(0x40, m)\n      // Assign the `str` to the end.\n      str := sub(m, 0x20)\n      // Zeroize the slot after the string.\n      mstore(str, 0)\n\n      // Cache the end of the memory to calculate the length later.\n      let end := str\n\n      // We write the string from rightmost digit to leftmost digit.\n      // The following is essentially a do-while loop that also handles the zero case.\n      // prettier-ignore\n      for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n      let length := sub(end, str)\n      // Move the pointer 32 bytes leftwards to make room for the length.\n      str := sub(str, 0x20)\n      // Store the length.\n      mstore(str, length)\n    }\n  }\n}\n"
    },
    "src/contracts/tokens/erc721/custom-erc721/ERC721AEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\n/// @title ERC721AEnumerable\n/// @author MilkyTaste @ Ao Collaboration Ltd.\n/// https://block.aocollab.tech\n/// An enumerable extension to ERC721A that does not increase gas costs.\n\nimport \"./IERC721AEnumerable.sol\";\nimport \"./ERC721A.sol\";\n\nerror IndexOutOfBounds();\nerror QueryForZeroAddress();\n\ncontract ERC721AEnumerable is IERC721AEnumerable, ERC721A {\n  constructor(\n    string memory name_,\n    string memory symbol_\n  ) ERC721A(name_, symbol_) {}\n\n  /**\n   * @dev Returns the total amount of tokens stored by the contract.\n   * Uses the ERC721A implementation.\n   */\n  function totalSupply()\n    public\n    view\n    override(ERC721A, IERC721AEnumerable)\n    returns (uint256)\n  {\n    return ERC721A.totalSupply();\n  }\n\n  /**\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n   * @notice This method is intended for read only purposes.\n   */\n  function tokenOfOwnerByIndex(\n    address owner,\n    uint256 index\n  ) external view override returns (uint256 tokenId) {\n    if (owner == address(0)) revert QueryForZeroAddress();\n    if (balanceOf(owner) <= index) revert IndexOutOfBounds();\n\n    uint256 upToIndex = 0;\n    uint256 highestTokenId = _startTokenId() + _totalMinted();\n    for (uint256 i = _startTokenId(); i < highestTokenId; i++) {\n      if (_ownerOfWithoutError(i) == owner) {\n        if (upToIndex == index) return i;\n        upToIndex++;\n      }\n    }\n    // Should never reach this case\n    revert IndexOutOfBounds();\n  }\n\n  /**\n   * A copy of the ERC721A._ownershipOf implementation that returns address(0) when unowned instead of an error.\n   */\n  function _ownerOfWithoutError(\n    uint256 tokenId\n  ) internal view returns (address) {\n    uint256 curr = tokenId;\n\n    unchecked {\n      if (_startTokenId() <= curr && curr < _nextTokenId()) {\n        TokenOwnership memory ownership = _ownershipAt(curr);\n        if (!ownership.burned) {\n          if (ownership.addr != address(0)) return ownership.addr;\n\n          // Invariant:\n          // There will always be an ownership that has an address and is not burned\n          // before an ownership that does not have an address and is not burned.\n          // Hence, curr will not underflow.\n          while (true) {\n            curr--;\n            ownership = _ownershipAt(curr);\n            if (ownership.addr != address(0)) return ownership.addr;\n          }\n        }\n      }\n    }\n    return address(0);\n  }\n\n  /**\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n   * Use along with {totalSupply} to enumerate all tokens.\n   * @notice This method is intended for read only purposes.\n   */\n  function tokenByIndex(\n    uint256 index\n  ) external view override returns (uint256) {\n    uint256 highestTokenId = _startTokenId() + _totalMinted();\n    if (index > highestTokenId) revert IndexOutOfBounds();\n\n    uint256 indexedId = 0;\n    for (uint256 i = _startTokenId(); i < highestTokenId; i++) {\n      if (!_ownershipAt(i).burned) {\n        if (indexedId == index) return i;\n        indexedId++;\n      }\n    }\n    revert IndexOutOfBounds();\n  }\n\n  /**\n   * @dev Returns a list of token IDs owned by `owner`.\n   * @notice This method is intended for read only purposes.\n   */\n  function tokensOfOwner(address owner) public view returns (uint256[] memory) {\n    if (owner == address(0)) revert QueryForZeroAddress();\n\n    uint256 balance = balanceOf(owner);\n    uint256[] memory tokens = new uint256[](balance);\n\n    uint256 index = 0;\n    uint256 highestTokenId = _startTokenId() + _totalMinted();\n    for (uint256 i = _startTokenId(); i < highestTokenId; i++) {\n      if (_ownerOfWithoutError(i) == owner) {\n        tokens[index] = i;\n        index++;\n        if (index == balance) break;\n      }\n    }\n    return tokens;\n  }\n}\n"
    },
    "src/contracts/tokens/erc721/custom-erc721/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n  /**\n   * The caller must own the token or be an approved operator.\n   */\n  error ApprovalCallerNotOwnerNorApproved();\n\n  /**\n   * The token does not exist.\n   */\n  error ApprovalQueryForNonexistentToken();\n\n  /**\n   * Cannot query the balance for the zero address.\n   */\n  error BalanceQueryForZeroAddress();\n\n  /**\n   * Cannot mint to the zero address.\n   */\n  error MintToZeroAddress();\n\n  /**\n   * The quantity of tokens minted must be more than zero.\n   */\n  error MintZeroQuantity();\n\n  /**\n   * The token does not exist.\n   */\n  error OwnerQueryForNonexistentToken();\n\n  /**\n   * The caller must own the token or be an approved operator.\n   */\n  error TransferCallerNotOwnerNorApproved();\n\n  /**\n   * The token must be owned by `from`.\n   */\n  error TransferFromIncorrectOwner();\n\n  /**\n   * Cannot safely transfer to a contract that does not implement the\n   * ERC721Receiver interface.\n   */\n  error TransferToNonERC721ReceiverImplementer();\n\n  /**\n   * Cannot transfer to the zero address.\n   */\n  error TransferToZeroAddress();\n\n  /**\n   * The token does not exist.\n   */\n  error URIQueryForNonexistentToken();\n\n  /**\n   * The `quantity` minted with ERC2309 exceeds the safety limit.\n   */\n  error MintERC2309QuantityExceedsLimit();\n\n  /**\n   * The `extraData` cannot be set on an unintialized ownership slot.\n   */\n  error OwnershipNotInitializedForExtraData();\n\n  // =============================================================\n  //                            STRUCTS\n  // =============================================================\n\n  struct TokenOwnership {\n    // The address of the owner.\n    address addr;\n    // Stores the start time of ownership with minimal overhead for tokenomics.\n    uint64 startTimestamp;\n    // Whether the token has been burned.\n    bool burned;\n    // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n    uint24 extraData;\n  }\n\n  // =============================================================\n  //                         TOKEN COUNTERS\n  // =============================================================\n\n  /**\n   * @dev Returns the total number of tokens in existence.\n   * Burned tokens will reduce the count.\n   * To get the total number of tokens minted, please see {_totalMinted}.\n   */\n  function totalSupply() external view returns (uint256);\n\n  // =============================================================\n  //                            IERC165\n  // =============================================================\n\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  // =============================================================\n  //                            IERC721\n  // =============================================================\n\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n\n  /**\n   * @dev Emitted when `owner` enables or disables\n   * (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  /**\n   * @dev Returns the number of tokens in `owner`'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`,\n   * checking first that contract recipients are aware of the ERC721 protocol\n   * to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be have been allowed to move\n   * this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement\n   * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external payable;\n\n  /**\n   * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n   * whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token\n   * by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the\n   * zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external payable;\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom}\n   * for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(\n    uint256 tokenId\n  ) external view returns (address operator);\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}.\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  ) external view returns (bool);\n\n  // =============================================================\n  //                        IERC721Metadata\n  // =============================================================\n\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  // =============================================================\n  //                           IERC2309\n  // =============================================================\n\n  /**\n   * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n   * (inclusive) is transferred from `from` to `to`, as defined in the\n   * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n   *\n   * See {_mintERC2309} for more details.\n   */\n  event ConsecutiveTransfer(\n    uint256 indexed fromTokenId,\n    uint256 toTokenId,\n    address indexed from,\n    address indexed to\n  );\n}\n"
    },
    "src/contracts/tokens/erc721/custom-erc721/IERC721AEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721A.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721AEnumerable is IERC721A {\n  /**\n   * @dev Returns the total amount of tokens stored by the contract.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n   */\n  function tokenOfOwnerByIndex(\n    address owner,\n    uint256 index\n  ) external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n   * Use along with {totalSupply} to enumerate all tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@contracts/=src/contracts/",
      "@forge-std/=lib/forge-std/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@solmate/=lib/solmate/",
      "@tests/=src/tests/",
      "@utils/=src/utils/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}