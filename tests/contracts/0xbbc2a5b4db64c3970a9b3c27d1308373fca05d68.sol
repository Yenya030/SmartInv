{{
  "language": "Solidity",
  "sources": {
    "contracts/EthernalOnes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* @team   : Asteria Labs\r\n* @author : Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport 'EthereumContracts/contracts/interfaces/IArrayErrors.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IEtherErrors.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC721Errors.sol';\r\nimport 'EthereumContracts/contracts/interfaces/INFTSupplyErrors.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC165.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC721.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC721Metadata.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC721Enumerable.sol';\r\nimport 'EthereumContracts/contracts/interfaces/IERC721Receiver.sol';\r\nimport 'EthereumContracts/contracts/utils/ERC173.sol';\r\nimport 'EthereumContracts/contracts/utils/ContractState.sol';\r\nimport 'EthereumContracts/contracts/utils/Whitelist_ECDSA.sol';\r\nimport 'EthereumContracts/contracts/utils/ERC2981.sol';\r\nimport 'operator-filter-registry/src/UpdatableOperatorFilterer.sol';\r\n\r\ncontract EthernalOnes is \r\nIArrayErrors, IEtherErrors, IERC721Errors, INFTSupplyErrors,\r\nIERC165, IERC721, IERC721Metadata, IERC721Enumerable,\r\nERC173, ContractState, Whitelist_ECDSA, ERC2981, UpdatableOperatorFilterer {\r\n  // Errors\r\n  error EO_PHASE_DEPLETED( uint8 currentPhase );\r\n\r\n  // Constants\r\n  uint8 public constant PHASE1_SALE = 1;\r\n  uint8 public constant PHASE2_SALE = 2;\r\n  uint8 public constant PUBLIC_SALE = 3;\r\n  address public constant DEFAULT_SUBSCRIPTION = address( 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6 );\r\n  address public constant DEFAULT_OPERATOR_FILTER_REGISTRY = address( 0x000000000000AAeB6D7670E522A718067333cd4E );\r\n  string public constant name = \"Ethernal Ones - The Awakening\";\r\n  string public constant symbol = \"EONFT\";\r\n  uint256 public constant MAX_BATCH = 2;\r\n\r\n  // Private variables\r\n  uint256 public maxSupply = 6666;\r\n  uint256 private _nextId = 1;\r\n  uint256 private _reserve = 50;\r\n  address private _treasury;\r\n  string  private _baseURI = \"ipfs://QmPcyrBaY65ZVWReFwkPXUQHGUjq4skCVhk5HfSx1FJoi7\";\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping( uint256 => address ) private _approvals;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping( address => mapping( address => bool ) ) private _operatorApprovals;\r\n\r\n  // List of owner addresses\r\n  mapping( uint256 => address ) private _owners;\r\n\r\n  // Mapping from phase to sale price\r\n  mapping( uint8 => uint256 ) private _salePrice;\r\n\r\n  // Mapping from phase to max supply\r\n  mapping( uint8 => uint256 ) private _maxPhase;\r\n\r\n  constructor() UpdatableOperatorFilterer( DEFAULT_OPERATOR_FILTER_REGISTRY, DEFAULT_SUBSCRIPTION, true ) {\r\n    _salePrice[ PHASE1_SALE ] = 59000000000000000; // 0.059 ether\r\n    _salePrice[ PHASE2_SALE ] = 79000000000000000; // 0.079 ether\r\n    _salePrice[ PUBLIC_SALE ] = 89000000000000000; // 0.089 ether\r\n    _maxPhase[ PHASE1_SALE ] = 2999;\r\n    _maxPhase[ PHASE2_SALE ] = 5665;\r\n    _treasury = 0x2b1076BF95DA326441e5bf81A1d0357b10bDb933;\r\n    _setOwner( msg.sender );\r\n    _setRoyaltyInfo( 0x4F440081A1c6a94cA5Fa5fEcc31bceC5bba62691, 500 );\r\n    _setWhitelist( 0x7df36A44FcA36F05A6fbF74B7cBdd9B43349e37F );\r\n  }\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Ensures the token exist. \r\n    * A token exists if it has been minted and is not owned by the null address.\r\n    * \r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    */\r\n    modifier exists( uint256 tokenId_ ) {\r\n      if ( ! _exists( tokenId_ ) ) {\r\n        revert IERC721_NONEXISTANT_TOKEN( tokenId_ );\r\n      }\r\n      _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensures that `qty_` is higher than 0\r\n    * \r\n    * @param qty_ : the amount to validate \r\n    */\r\n    modifier validateAmount( uint256 qty_ ) {\r\n      if ( qty_ == 0 ) {\r\n        revert NFT_INVALID_QTY();\r\n      }\r\n      _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensures that contract state is {PHASE1_SALE} or {PHASE2_SALE}\r\n    */\r\n    modifier isWhitelist() {\r\n      uint8 _currentState_ = getContractState();\r\n      if ( _currentState_ != PHASE1_SALE &&\r\n           _currentState_ != PHASE2_SALE ) {\r\n        revert ContractState_INCORRECT_STATE( _currentState_ );\r\n      }\r\n      _;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    // ***********\r\n    // * IERC721 *\r\n    // ***********\r\n      /**\r\n      * @dev Internal function returning the number of tokens in `userAddress_`'s account.\r\n      * \r\n      * @param userAddress_ : address that may own tokens\r\n      * \r\n      * @return uint256 : the number of tokens owned by `userAddress_`\r\n      */\r\n      function _balanceOf( address userAddress_ ) internal view virtual returns ( uint256 ) {\r\n        if ( userAddress_ == address( 0 ) ) {\r\n          return 0;\r\n        }\r\n\r\n        uint256 _count_;\r\n        address _currentTokenOwner_;\r\n        uint256 _index_ = 1;\r\n        while ( _index_ < _nextId ) {\r\n          if ( _exists( _index_ ) ) {\r\n            if ( _owners[ _index_ ] != address( 0 ) ) {\r\n              _currentTokenOwner_ = _owners[ _index_ ];\r\n            }\r\n            if ( userAddress_ == _currentTokenOwner_ ) {\r\n              unchecked {\r\n                ++_count_;\r\n              }\r\n            }\r\n          }\r\n          unchecked {\r\n            ++_index_;\r\n          }\r\n        }\r\n        return _count_;\r\n      }\r\n\r\n      /**\r\n      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n      * The call is not executed if the target address is not a contract.\r\n      *\r\n      * @param fromAddress_ : previous owner of the NFT\r\n      * @param toAddress_   : new owner of the NFT\r\n      * @param tokenId_     : identifier of the NFT being transferred\r\n      * @param data_        : optional data to send along with the call\r\n\r\n      * @return bool : whether the call correctly returned the expected value (IERC721Receiver.onERC721Received.selector)\r\n      */\r\n      function _checkOnERC721Received( address fromAddress_, address toAddress_, uint256 tokenId_, bytes memory data_ ) internal virtual returns ( bool ) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n        // \r\n        // IMPORTANT\r\n        // It is unsafe to assume that an address not flagged by this method\r\n        // is an externally-owned account (EOA) and not a contract.\r\n        //\r\n        // Among others, the following types of addresses will not be flagged:\r\n        //\r\n        //  - an externally-owned account\r\n        //  - a contract in construction\r\n        //  - an address where a contract will be created\r\n        //  - an address where a contract lived, but was destroyed\r\n        uint256 _size_;\r\n        assembly {\r\n          _size_ := extcodesize( toAddress_ )\r\n        }\r\n\r\n        // If address is a contract, check that it is aware of how to handle ERC721 tokens\r\n        if ( _size_ > 0 ) {\r\n          try IERC721Receiver( toAddress_ ).onERC721Received( msg.sender, fromAddress_, tokenId_, data_ ) returns ( bytes4 retval ) {\r\n            return retval == IERC721Receiver.onERC721Received.selector;\r\n          }\r\n          catch ( bytes memory reason ) {\r\n            if ( reason.length == 0 ) {\r\n              revert IERC721_NON_ERC721_RECEIVER( toAddress_ );\r\n            }\r\n            else {\r\n              assembly {\r\n                revert( add( 32, reason ), mload( reason ) )\r\n              }\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @dev Internal function returning whether a token exists. \r\n      * A token exists if it has been minted and is not owned by the null address.\r\n      * \r\n      * @param tokenId_ : identifier of the NFT to verify\r\n      * \r\n      * @return bool : whether the NFT exists\r\n      */\r\n      function _exists( uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n        if ( tokenId_ == 0 ) {\r\n          return false;\r\n        }\r\n        return tokenId_ < _nextId;\r\n      }\r\n\r\n      /**\r\n      * @dev Internal function returning whether `operator_` is allowed \r\n      * to manage tokens on behalf of `tokenOwner_`.\r\n      * \r\n      * @param tokenOwner_ : address that owns tokens\r\n      * @param operator_   : address that tries to manage tokens\r\n      * \r\n      * @return bool : whether `operator_` is allowed to handle the token\r\n      */\r\n      function _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual returns ( bool ) {\r\n        return _operatorApprovals[ tokenOwner_ ][ operator_ ];\r\n      }\r\n\r\n      /**\r\n      * @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\r\n      * \r\n      * Note: To avoid multiple checks for the same data, it is assumed that existence of `tokenId_` \r\n      * has been verified prior via {_exists}\r\n      * If it hasn't been verified, this function might panic\r\n      * \r\n      * @param tokenOwner_ : address that owns tokens\r\n      * @param operator_   : address that tries to handle the token\r\n      * @param tokenId_    : identifier of the NFT\r\n      * \r\n      * @return bool whether `operator_` is allowed to handle the token\r\n      */\r\n      function _isApprovedOrOwner( address tokenOwner_, address operator_, uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n        bool _isApproved_ = operator_ == tokenOwner_ ||\r\n                            operator_ == _approvals[ tokenId_ ] ||\r\n                            _isApprovedForAll( tokenOwner_, operator_ );\r\n        return _isApproved_;\r\n      }\r\n\r\n      /**\r\n      * @dev Mints `qty_` tokens and transfers them to `toAddress_`.\r\n      * \r\n      * This internal function can be used to perform token minting.\r\n      * \r\n      * Emits one or more {Transfer} event.\r\n      * \r\n      * @param toAddress_ : address receiving the NFTs\r\n      * @param qty_       : number of NFTs being minted\r\n      */\r\n      function _mint( address toAddress_, uint256 qty_ ) internal virtual {\r\n        uint256 _firstToken_ = _nextId;\r\n        uint256 _nextStart_ = _firstToken_ + qty_;\r\n        uint256 _lastToken_ = _nextStart_ - 1;\r\n\r\n        _owners[ _firstToken_ ] = toAddress_;\r\n        if ( _lastToken_ > _firstToken_ ) {\r\n          _owners[ _lastToken_ ] = toAddress_;\r\n        }\r\n        _nextId = _nextStart_;\r\n\r\n        if ( ! _checkOnERC721Received( address( 0 ), toAddress_, _firstToken_, \"\" ) ) {\r\n          revert IERC721_NON_ERC721_RECEIVER( toAddress_ );\r\n        }\r\n\r\n        while ( _firstToken_ < _nextStart_ ) {\r\n          emit Transfer( address( 0 ), toAddress_, _firstToken_ );\r\n          unchecked {\r\n            _firstToken_ ++;\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @dev Internal function returning the owner of the `tokenId_` token.\r\n      * \r\n      * @param tokenId_ : identifier of the NFT\r\n      * \r\n      * @return : address that owns the NFT\r\n      */\r\n      function _ownerOf( uint256 tokenId_ ) internal view virtual returns ( address ) {\r\n        uint256 _tokenId_ = tokenId_;\r\n        address _tokenOwner_ = _owners[ _tokenId_ ];\r\n        while ( _tokenOwner_ == address( 0 ) ) {\r\n          _tokenId_ --;\r\n          _tokenOwner_ = _owners[ _tokenId_ ];\r\n        }\r\n\r\n        return _tokenOwner_;\r\n      }\r\n\r\n      /**\r\n      * @dev Transfers `tokenId_` from `fromAddress_` to `toAddress_`.\r\n      *\r\n      * This internal function can be used to implement alternative mechanisms to perform \r\n      * token transfer, such as signature-based, or token burning.\r\n      * \r\n      * @param fromAddress_ : previous owner of the NFT\r\n      * @param toAddress_   : new owner of the NFT\r\n      * @param tokenId_     : identifier of the NFT being transferred\r\n      * \r\n      * Emits a {Transfer} event.\r\n      */\r\n      function _transfer( address fromAddress_, address toAddress_, uint256 tokenId_ ) internal virtual {\r\n        _approvals[ tokenId_ ] = address( 0 );\r\n        uint256 _previousId_ = tokenId_ > 1 ? tokenId_ - 1 : 1;\r\n        uint256 _nextId_     = tokenId_ + 1;\r\n        bool _previousShouldUpdate_ = _previousId_ < tokenId_ &&\r\n                                      _exists( _previousId_ ) &&\r\n                                      _owners[ _previousId_ ] == address( 0 );\r\n        bool _nextShouldUpdate_ = _exists( _nextId_ ) &&\r\n                                  _owners[ _nextId_ ] == address( 0 );\r\n\r\n        if ( _previousShouldUpdate_ ) {\r\n          _owners[ _previousId_ ] = fromAddress_;\r\n        }\r\n\r\n        if ( _nextShouldUpdate_ ) {\r\n          _owners[ _nextId_ ] = fromAddress_;\r\n        }\r\n\r\n        _owners[ tokenId_ ] = toAddress_;\r\n\r\n        emit Transfer( fromAddress_, toAddress_, tokenId_ );\r\n      }\r\n    // ***********\r\n\r\n    // *********************\r\n    // * IERC721Enumerable *\r\n    // *********************\r\n      /**\r\n      * @dev See {IERC721Enumerable-totalSupply}.\r\n      */\r\n      function _totalSupply() internal view virtual returns ( uint256 ) {\r\n        uint256 _supplyMinted_ = supplyMinted();\r\n        uint256 _count_ = _supplyMinted_;\r\n        uint256 _index_ = _supplyMinted_;\r\n\r\n        while ( _index_ > 0 ) {\r\n          if ( ! _exists( _index_ ) ) {\r\n            unchecked {\r\n              _count_ --;\r\n            }\r\n          }\r\n          unchecked {\r\n            _index_ --;\r\n          }\r\n        }\r\n        return _count_;\r\n      }\r\n    // *********************\r\n\r\n    // *******************\r\n    // * IERC721Metadata *\r\n    // *******************\r\n      /**\r\n      * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n      */\r\n      function _toString( uint256 value_ ) internal pure virtual returns ( string memory str ) {\r\n        assembly {\r\n          // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n          // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n          // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n          // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\r\n          let m := add( mload( 0x40 ), 0xa0 )\r\n          // Update the free memory pointer to allocate.\r\n          mstore( 0x40, m )\r\n          // Assign the `str` to the end.\r\n          str := sub( m, 0x20 )\r\n          // Zeroize the slot after the string.\r\n          mstore( str, 0 )\r\n\r\n          // Cache the end of the memory to calculate the length later.\r\n          let end := str\r\n\r\n          // We write the string from rightmost digit to leftmost digit.\r\n          // The following is essentially a do-while loop that also handles the zero case.\r\n          // prettier-ignore\r\n          for { let temp := value_ } 1 {} {\r\n            str := sub( str, 1 )\r\n            // Write the character to the pointer.\r\n            // The ASCII index of the '0' character is 48.\r\n            mstore8( str, add( 48, mod( temp, 10 ) ) )\r\n            // Keep dividing `temp` until zero.\r\n            temp := div( temp, 10 )\r\n            // prettier-ignore\r\n            if iszero( temp ) { break }\r\n          }\r\n\r\n          let length := sub( end, str )\r\n          // Move the pointer 32 bytes leftwards to make room for the length.\r\n          str := sub( str, 0x20 )\r\n          // Store the length.\r\n          mstore( str, length )\r\n        }\r\n      }\r\n    // *******************\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****           PUBLIC           *****\r\n  // **************************************\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_           : the amount of tokens to be minted\r\n    * @param alloted_       : the maximum alloted for that user\r\n    * @param proof_         : the signature to verify whitelist allocation\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Sale state must be {PHASE1_SALE or PHASE2_SALE}.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at private sale price.\r\n    */\r\n    function mintPrivate( uint256 qty_, uint256 alloted_, Proof memory proof_ ) public payable validateAmount( qty_ ) isWhitelist isWhitelisted( msg.sender, PHASE1_SALE, alloted_, proof_, qty_ ) {\r\n      uint8 _currentState_ = getContractState();\r\n      if ( qty_ + supplyMinted() > _maxPhase[ _currentState_ ] ) {\r\n        revert EO_PHASE_DEPLETED( _currentState_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _salePrice[ _currentState_ ];\r\n      if ( _expected_ != msg.value ) {\r\n        revert ETHER_INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _mint( msg.sender, qty_ );\r\n      _consumeWhitelist( msg.sender, PHASE1_SALE, qty_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_ : the amount of tokens to be minted\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Sale state must be {PUBLIC_SALE}.\r\n    * - There must be enough tokens left to mint outside of the reserve.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at public sale price.\r\n    */\r\n    function mintPublic( uint256 qty_ ) public payable validateAmount( qty_ ) isState( PUBLIC_SALE ) {\r\n      if ( qty_ > MAX_BATCH ) {\r\n        revert NFT_MAX_BATCH( qty_, MAX_BATCH );\r\n      }\r\n\r\n      uint256 _remainingSupply_ = maxSupply - _reserve - supplyMinted();\r\n      if ( qty_ > _remainingSupply_ ) {\r\n        revert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _salePrice[ PUBLIC_SALE ];\r\n      if ( _expected_ != msg.value ) {\r\n        revert ETHER_INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _mint( msg.sender, qty_ );\r\n    }\r\n\r\n    // ***********\r\n    // * IERC721 *\r\n    // ***********\r\n      /**\r\n      * @dev See {IERC721-approve}.\r\n      */\r\n      function approve( address to_, uint256 tokenId_ ) public virtual exists( tokenId_ ) onlyAllowedOperatorApproval( msg.sender ) {\r\n        address _operator_ = msg.sender;\r\n        address _tokenOwner_ = _ownerOf( tokenId_ );\r\n        if ( to_ == _tokenOwner_ ) {\r\n          revert IERC721_INVALID_APPROVAL( to_ );\r\n        }\r\n\r\n        bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n        if ( ! _isApproved_ ) {\r\n          revert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n        }\r\n\r\n        _approvals[ tokenId_ ] = to_;\r\n        emit Approval( _tokenOwner_, to_, tokenId_ );\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-safeTransferFrom}.\r\n      * \r\n      * Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n      * but we cannot remove this parameter to stay in conformity with IERC721\r\n      */\r\n      function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) public virtual override {\r\n        safeTransferFrom( from_, to_, tokenId_, \"\" );\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-safeTransferFrom}.\r\n      * \r\n      * Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n      * but we cannot remove this parameter to stay in conformity with IERC721\r\n      */\r\n      function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes memory data_ ) public virtual override {\r\n        transferFrom( from_, to_, tokenId_ );\r\n        if ( ! _checkOnERC721Received( from_, to_, tokenId_, data_ ) ) {\r\n          revert IERC721_NON_ERC721_RECEIVER( to_ );\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-setApprovalForAll}.\r\n      */\r\n      function setApprovalForAll( address operator_, bool approved_ ) public virtual override onlyAllowedOperatorApproval( msg.sender ) {\r\n        address _account_ = msg.sender;\r\n        if ( operator_ == _account_ ) {\r\n          revert IERC721_INVALID_APPROVAL( operator_ );\r\n        }\r\n\r\n        _operatorApprovals[ _account_ ][ operator_ ] = approved_;\r\n        emit ApprovalForAll( _account_, operator_, approved_ );\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-transferFrom}.\r\n      */\r\n      function transferFrom( address from_, address to_, uint256 tokenId_ ) public virtual exists( tokenId_ ) onlyAllowedOperator( msg.sender ) {\r\n        if ( to_ == address( 0 ) ) {\r\n          revert IERC721_INVALID_TRANSFER();\r\n        }\r\n\r\n        address _operator_ = msg.sender;\r\n        address _tokenOwner_ = _ownerOf( tokenId_ );\r\n        if ( from_ != _tokenOwner_ ) {\r\n          revert IERC721_INVALID_TRANSFER_FROM( _tokenOwner_, from_, tokenId_ );\r\n        }\r\n\r\n        bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n        if ( ! _isApproved_ ) {\r\n          revert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n        }\r\n\r\n        _transfer( _tokenOwner_, to_, tokenId_ );\r\n      }\r\n    // ***********\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****       CONTRACT_OWNER       *****\r\n  // **************************************\r\n    /**\r\n    * @notice Mints `amounts_` tokens and transfers them to `accounts_`.\r\n    * \r\n    * @param accounts_ : the list of accounts that will receive airdropped tokens\r\n    * @param amounts_  : the amount of tokens each account will receive\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `accounts_` and `amounts_` must have the same length.\r\n    * - There must be enough tokens left in the reserve.\r\n    */\r\n    function airdrop( address[] memory accounts_, uint256[] memory amounts_ ) public onlyOwner {\r\n      uint256 _count_ = accounts_.length;\r\n      if ( _count_ != amounts_.length ) {\r\n        revert ARRAY_LENGTH_MISMATCH();\r\n      }\r\n\r\n      uint256 _totalQty_;\r\n      while ( _count_ > 0 ) {\r\n        unchecked {\r\n          --_count_;\r\n        }\r\n        _totalQty_ += amounts_[ _count_ ];\r\n        _mint( accounts_[ _count_ ], amounts_[ _count_ ] );\r\n      }\r\n      if ( _totalQty_ > _reserve ) {\r\n        revert NFT_MAX_RESERVE( _totalQty_, _reserve );\r\n      }\r\n      unchecked {\r\n        _reserve -= _totalQty_;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @notice Reduces the max supply.\r\n    * \r\n    * @param newMaxSupply_ : the new max supply\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newMaxSupply_` must be lower than `maxSupply`.\r\n    * - `newMaxSupply_` must be higher than `_nextId`.\r\n    */\r\n    function reduceSupply( uint256 newMaxSupply_ ) public onlyOwner {\r\n      if ( newMaxSupply_ > maxSupply || newMaxSupply_ < _nextId + _reserve ) {\r\n        revert NFT_INVALID_SUPPLY();\r\n      }\r\n      maxSupply = newMaxSupply_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the baseURI for the tokens.\r\n    * \r\n    * @param newBaseURI_ : the new baseURI for the tokens\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setBaseURI( string memory newBaseURI_ ) public onlyOwner {\r\n      _baseURI = newBaseURI_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the contract state.\r\n    * \r\n    * @param newState_ : the new sale state\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newState_` must be a valid state.\r\n    */\r\n    function setContractState( uint8 newState_ ) external onlyOwner {\r\n      if ( newState_ > PUBLIC_SALE ) {\r\n        revert ContractState_INVALID_STATE( newState_ );\r\n      }\r\n      _setContractState( newState_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the royalty recipient and rate.\r\n    * \r\n    * @param newRoyaltyRecipient_ : the new recipient of the royalties\r\n    * @param newRoyaltyRate_      : the new royalty rate\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newRoyaltyRate_` cannot be higher than 10,000.\r\n    */\r\n    function setRoyaltyInfo( address newRoyaltyRecipient_, uint256 newRoyaltyRate_ ) external onlyOwner {\r\n      _setRoyaltyInfo( newRoyaltyRecipient_, newRoyaltyRate_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the royalty recipient and rate.\r\n    * \r\n    * @param newPhase1Price_ : the new phase 1 price\r\n    * @param newPhase2Price_ : the new phase 2 price\r\n    * @param newPublicPrice_ : the new public price\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setPrices( uint256 newPhase1Price_, uint256 newPhase2Price_, uint256 newPublicPrice_ ) external onlyOwner {\r\n      _salePrice[ PHASE1_SALE ] = newPhase1Price_;\r\n      _salePrice[ PHASE2_SALE ] = newPhase2Price_;\r\n      _salePrice[ PUBLIC_SALE ] = newPublicPrice_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the contract treasury.\r\n    * \r\n    * @param newTreasury_ : the new trasury\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setTreasury( address newTreasury_ ) external onlyOwner {\r\n      _treasury = newTreasury_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the whitelist signer.\r\n    * \r\n    * @param newAdminSigner_ : the new whitelist signer\r\n    *  \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setWhitelist( address newAdminSigner_ ) external onlyOwner {\r\n      _setWhitelist( newAdminSigner_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Withdraws all the money stored in the contract and sends it to the treasury.\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `_treasury` must be able to receive the funds.\r\n    * - Contract must have a positive balance.\r\n    */\r\n    function withdraw() public onlyOwner {\r\n      uint256 _balance_ = address( this ).balance;\r\n      if ( _balance_ == 0 ) {\r\n        revert ETHER_NO_BALANCE();\r\n      }\r\n\r\n      address _recipient_ = payable( _treasury );\r\n      ( bool _success_, ) = _recipient_.call{ value: _balance_ }( \"\" );\r\n      if ( ! _success_ ) {\r\n        revert ETHER_TRANSFER_FAIL( _recipient_, _balance_ );\r\n      }\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n    /**\r\n    * @notice Returns the current sale price\r\n    * \r\n    * @return uint256 the current sale price\r\n    */\r\n    function salePrice() public view returns ( uint256 ) {\r\n      return _salePrice[ getContractState() ];\r\n    }\r\n\r\n    /**\r\n    * @notice Returns the total number of tokens minted\r\n    * \r\n    * @return uint256 the number of tokens that have been minted so far\r\n    */\r\n    function supplyMinted() public view returns ( uint256 ) {\r\n      return _nextId - 1;\r\n    }\r\n\r\n    // ***********\r\n    // * IERC721 *\r\n    // ***********\r\n      /**\r\n      * @dev See {IERC721-balanceOf}.\r\n      */\r\n      function balanceOf( address tokenOwner_ ) public view virtual returns ( uint256 ) {\r\n        return _balanceOf( tokenOwner_ );\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-getApproved}.\r\n      */\r\n      function getApproved( uint256 tokenId_ ) public view virtual exists( tokenId_ ) returns ( address ) {\r\n        return _approvals[ tokenId_ ];\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-isApprovedForAll}.\r\n      */\r\n      function isApprovedForAll( address tokenOwner_, address operator_ ) public view virtual returns ( bool ) {\r\n        return _isApprovedForAll( tokenOwner_, operator_ );\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721-ownerOf}.\r\n      */\r\n      function ownerOf( uint256 tokenId_ ) public view virtual exists( tokenId_ ) returns ( address ) {\r\n        return _ownerOf( tokenId_ );\r\n      }\r\n    // ***********\r\n\r\n    // *********************\r\n    // * IERC721Enumerable *\r\n    // *********************\r\n      /**\r\n      * @dev See {IERC721Enumerable-tokenByIndex}.\r\n      */\r\n      function tokenByIndex( uint256 index_ ) public view virtual override returns ( uint256 ) {\r\n        if ( index_ >= supplyMinted() ) {\r\n          revert IERC721Enumerable_INDEX_OUT_OF_BOUNDS( index_ );\r\n        }\r\n        return index_ + 1;\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n      */\r\n      function tokenOfOwnerByIndex( address tokenOwner_, uint256 index_ ) public view virtual override returns ( uint256 tokenId ) {\r\n        if ( index_ >= _balanceOf( tokenOwner_ ) ) {\r\n          revert IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( tokenOwner_, index_ );\r\n        }\r\n\r\n        uint256 _count_ = 0;\r\n        uint256 _nextId_ = supplyMinted();\r\n        for ( uint256 i = 1; i < _nextId_; i++ ) {\r\n          if ( _exists( i ) && tokenOwner_ == _ownerOf( i ) ) {\r\n            if ( index_ == _count_ ) {\r\n              return i;\r\n            }\r\n            _count_++;\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @dev See {IERC721Enumerable-totalSupply}.\r\n      */\r\n      function totalSupply() public view virtual override returns ( uint256 ) {\r\n        return _totalSupply();\r\n      }\r\n    // *********************\r\n\r\n    // *******************\r\n    // * IERC721Metadata *\r\n    // *******************\r\n      /**\r\n      * @dev See {IERC721Metadata-tokenURI}.\r\n      */\r\n      function tokenURI( uint256 tokenId_ ) public view virtual override exists( tokenId_ ) returns ( string memory ) {\r\n        if ( bytes( _baseURI ).length > 0 ) {\r\n          if ( supplyMinted() == maxSupply ) {\r\n            return string( abi.encodePacked( _baseURI, _toString( tokenId_ ) ) );\r\n          }\r\n          else {\r\n            return _baseURI;\r\n          }\r\n        }\r\n        return _toString( tokenId_ );\r\n      }\r\n    // *******************\r\n\r\n    // ***********\r\n    // * IERC165 *\r\n    // ***********\r\n      /**\r\n      * @dev See {IERC165-supportsInterface}.\r\n      */\r\n      function supportsInterface( bytes4 interfaceId_ ) public view override returns ( bool ) {\r\n        return \r\n          interfaceId_ == type( IERC721 ).interfaceId ||\r\n          interfaceId_ == type( IERC721Enumerable ).interfaceId ||\r\n          interfaceId_ == type( IERC721Metadata ).interfaceId ||\r\n          interfaceId_ == type( IERC173 ).interfaceId ||\r\n          interfaceId_ == type( IERC165 ).interfaceId ||\r\n          interfaceId_ == type( IERC2981 ).interfaceId;\r\n      }\r\n    // ***********\r\n\r\n    // ***********\r\n    // * IERC173 *\r\n    // ***********\r\n      function owner() public view override(ERC173, UpdatableOperatorFilterer) returns ( address ) {\r\n        return ERC173.owner();\r\n      }\r\n    // ***********\r\n}\r\n"
    },
    "EthereumContracts/contracts/interfaces/IArrayErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\ninterface IArrayErrors {\n  /**\n  * @dev Thrown when two related arrays have different lengths\n  */\n  error ARRAY_LENGTH_MISMATCH();\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n* @dev Required interface of an ERC173 compliant contract, as defined in the\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\n*/\ninterface IERC173 /* is IERC165 */ {\n    /// @dev This emits when ownership of a contract changes.    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner    \n    /// @return The address of the owner.\n    function owner() view external returns(address);\n\t\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract    \n    function transferOwnership(address _newOwner) external;\t\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n///\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface IERC2981 /* is IERC165 */ {\n  /// ERC165 bytes to add to interface array - set in parent contract\n  /// implementing this standard\n  ///\n  /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n  /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n  /// _registerInterface(_INTERFACE_ID_ERC2981);\n\n  /// @notice Called with the sale price to determine how much royalty\n  //          is owed and to whom.\n  /// @param tokenId_ - the NFT asset queried for royalty information\n  /// @param salePrice_ - the sale price of the NFT asset specified by tokenId_\n  /// @return receiver - address of who should be sent the royalty payment\n  /// @return royaltyAmount - the royalty payment amount for salePrice_\n  function royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) external view returns ( address receiver, uint256 royaltyAmount );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is IERC165 */ {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer( address indexed from_, address indexed to_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval( address indexed owner_, address indexed approved_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll( address indexed owner_, address indexed operator_, bool approved_ );\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param owner_ An address for whom to query the balance\n  /// @return The number of NFTs owned by `owner_`, possibly zero\n  function balanceOf( address owner_ ) external view returns ( uint256 );\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param tokenId_ The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `to_` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `to_` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  /// @param data_ Additional data with no specified format, sent in call to `to_`\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `to_` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param approved_ The new approved NFT controller\n  /// @param tokenId_ The NFT to approve\n  function approve( address approved_, uint256 tokenId_ ) external;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param operator_ Address to add to the set of authorized operators\n  /// @param approved_ True if the operator is approved, false to revoke approval\n  function setApprovalForAll( address operator_, bool approved_ ) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `tokenId_` is not a valid NFT.\n  /// @param tokenId_ The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param owner_ The address that owns the NFTs\n  /// @param operator_ The address that acts on behalf of the owner\n  /// @return True if `operator_` is an approved operator for `owner_`, false otherwise\n  function isApprovedForAll( address owner_, address operator_ ) external view returns ( bool );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable /* is IERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns ( uint256 );\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `index_` >= `totalSupply()`.\n    /// @param index_ A counter less than `totalSupply()`\n    /// @return The token identifier for the `index_`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex( uint256 index_ ) external view returns ( uint256 );\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `index_` >= `balanceOf(owner_)` or if\n    ///  `owner_` is the zero address, representing invalid NFTs.\n    /// @param owner_ An address where we are interested in NFTs owned by them\n    /// @param index_ A counter less than `balanceOf(owner_)`\n    /// @return The token identifier for the `index_`th NFT assigned to `owner_`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex( address owner_, uint256 index_ ) external view returns ( uint256 );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC721Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\ninterface IERC721Errors {\n  /**\n  * @dev Thrown when `operator` has not been approved to manage `tokenId` on behalf of `tokenOwner`.\n  * \n  * @param tokenOwner : address owning the token\n  * @param operator   : address trying to manage the token\n  * @param tokenId    : identifier of the NFT being referenced\n  */\n  error IERC721_CALLER_NOT_APPROVED( address tokenOwner, address operator, uint256 tokenId );\n  /**\n  * @dev Thrown when `operator` tries to approve themselves for managing a token they own.\n  * \n  * @param operator : address that is trying to approve themselves\n  */\n  error IERC721_INVALID_APPROVAL( address operator );\n  /**\n  * @dev Thrown when a token is being transferred to the zero address.\n  */\n  error IERC721_INVALID_TRANSFER();\n  /**\n  * @dev Thrown when a token is being transferred from an address that doesn't own it.\n  * \n  * @param tokenOwner : address owning the token\n  * @param from       : address that the NFT is being transferred from\n  * @param tokenId    : identifier of the NFT being referenced\n  */\n  error IERC721_INVALID_TRANSFER_FROM( address tokenOwner, address from, uint256 tokenId );\n  /**\n  * @dev Thrown when the requested token doesn't exist.\n  * \n  * @param tokenId : identifier of the NFT being referenced\n  */\n  error IERC721_NONEXISTANT_TOKEN( uint256 tokenId );\n  /**\n  * @dev Thrown when a token is being safely transferred to a contract unable to handle it.\n  * \n  * @param receiver : address unable to receive the token\n  */\n  error IERC721_NON_ERC721_RECEIVER( address receiver );\n  /**\n  * @dev Thrown when trying to get the token at an index that doesn't exist.\n  * \n  * @param index : the inexistant index\n  */\n  error IERC721Enumerable_INDEX_OUT_OF_BOUNDS( uint256 index );\n  /**\n  * @dev Thrown when trying to get the token owned by `tokenOwner` at an index that doesn't exist.\n  * \n  * @param tokenOwner : address owning the token\n  * @param index      : the inexistant index\n  */\n  error IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( address tokenOwner, uint256 index );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata /* is IERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns ( string memory _name );\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns ( string memory _symbol );\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI( uint256 _tokenId ) external view returns ( string memory );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721Receiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param operator_ The address which called `safeTransferFrom` function\n    /// @param from_ The address which previously owned the token\n    /// @param tokenId_ The NFT identifier which is being transferred\n    /// @param data_ Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received( address operator_, address from_, uint256 tokenId_, bytes calldata data_ ) external returns( bytes4 );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/IEtherErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\ninterface IEtherErrors {\n  /**\n  * @dev Thrown when an incorrect amount of eth is being sent for a payable operation.\n  * \n  * @param amountReceived : the amount the contract received\n  * @param amountExpected : the actual amount the contract expected to receive\n  */\n  error ETHER_INCORRECT_PRICE( uint256 amountReceived, uint256 amountExpected );\n  /**\n  * @dev Thrown when trying to withdraw from the contract with no balance.\n  */\n  error ETHER_NO_BALANCE();\n  /**\n  * @dev Thrown when contract fails to send ether to recipient.\n  * \n  * @param to     : the recipient of the ether\n  * @param amount : the amount of ether being sent\n  */\n  error ETHER_TRANSFER_FAIL( address to, uint256 amount );\n}\n"
    },
    "EthereumContracts/contracts/interfaces/INFTSupplyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\ninterface INFTSupplyErrors {\n  /**\n  * @dev Thrown when trying to mint 0 token.\n  */\n  error NFT_INVALID_QTY();\n  /**\n  * @dev Thrown when trying to set max supply to an invalid amount.\n  */\n  error NFT_INVALID_SUPPLY();\n  /**\n  * @dev Thrown when trying to mint more tokens than the max allowed per transaction.\n  * \n  * @param qtyRequested : the amount of tokens requested\n  * @param maxBatch     : the maximum amount that can be minted per transaction\n  */\n  error NFT_MAX_BATCH( uint256 qtyRequested, uint256 maxBatch );\n  /**\n  * @dev Thrown when trying to mint more tokens from the reserve than the amount left.\n  * \n  * @param qtyRequested : the amount of tokens requested\n  * @param reserveLeft  : the amount of tokens left in the reserve\n  */\n  error NFT_MAX_RESERVE( uint256 qtyRequested, uint256 reserveLeft );\n  /**\n  * @dev Thrown when trying to mint more tokens than the amount left to be minted (except reserve).\n  * \n  * @param qtyRequested    : the amount of tokens requested\n  * @param remainingSupply : the amount of tokens left in the reserve\n  */\n  error NFT_MAX_SUPPLY( uint256 qtyRequested, uint256 remainingSupply );\n}\n"
    },
    "EthereumContracts/contracts/utils/ContractState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\nabstract contract ContractState {\n\t// Enum to represent the sale state, defaults to ``PAUSED``.\n\tuint8 public constant PAUSED = 0;\n\n\t// Errors\n  /**\n  * @dev Thrown when a function is called with the wrong contract state.\n  * \n  * @param currentState : the current state of the contract\n  */\n\terror ContractState_INCORRECT_STATE( uint8 currentState );\n  /**\n  * @dev Thrown when trying to set the contract state to an invalid value.\n  * \n  * @param invalidState : the invalid contract state\n  */\n\terror ContractState_INVALID_STATE( uint8 invalidState );\n\n\t// The current state of the contract\n\tuint8 private _contractState;\n\n\t/**\n\t* @dev Emitted when the sale state changes\n\t*/\n\tevent ContractStateChanged( uint8 indexed previousState, uint8 indexed newState );\n\n\t/**\n\t* @dev Ensures that contract state is `expectedState_`.\n\t* \n\t* @param expectedState_ : the desirable contract state\n\t*/\n\tmodifier isState( uint8 expectedState_ ) {\n\t\tif ( _contractState != expectedState_ ) {\n\t\t\trevert ContractState_INCORRECT_STATE( _contractState );\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Ensures that contract state is not `unexpectedState_`.\n\t* \n\t* @param unexpectedState_ : the undesirable contract state\n\t*/\n\tmodifier isNotState( uint8 unexpectedState_ ) {\n\t\tif ( _contractState == unexpectedState_ ) {\n\t\t\trevert ContractState_INCORRECT_STATE( _contractState );\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Internal function setting the contract state to `newState_`.\n\t* \n\t* Note: Contract state defaults to ``PAUSED``.\n\t* \t\t\tTo maintain extendability, this value kept as uint8 instead of enum.\n\t* \t\t\tAs a result, it is possible to set the state to an incorrect value.\n\t* \t\t\tTo avoid issues, `newState_` should be validated before calling this function\n\t*/\n\tfunction _setContractState( uint8 newState_ ) internal virtual {\n\t\tuint8 _previousState_ = _contractState;\n\t\t_contractState = newState_;\n\t\temit ContractStateChanged( _previousState_, newState_ );\n\t}\n\n\t/**\n\t* @dev Returns the current contract state.\n\t* \n\t* @return uint8 : the current contract state\n\t*/\n\tfunction getContractState() public virtual view returns ( uint8 ) {\n\t\treturn _contractState;\n\t}\n}\n"
    },
    "EthereumContracts/contracts/utils/ERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC173.sol\";\n\n/**\n* @dev Contract module which provides a basic access control mechanism, where\n* there is an account (an owner) that can be granted exclusive access to\n* specific functions.\n*\n* By default, the owner account will be the one that deploys the contract. This\n* can later be changed with {transferOwnership}.\n*\n* This module is used through inheritance. It will make available the modifier\n* `onlyOwner`, which can be applied to your functions to restrict their use to\n* the owner.\n*/\nabstract contract ERC173 is IERC173 {\n\t// Errors\n  /**\n  * @dev Thrown when `operator` is not the contract owner.\n  * \n  * @param operator : address trying to use a function reserved to contract owner without authorization\n  */\n  error IERC173_NOT_OWNER( address operator );\n\n\t// The owner of the contract\n\taddress private _owner;\n\n\t/**\n\t* @dev Throws if called by any account other than the owner.\n\t*/\n\tmodifier onlyOwner() {\n\t\taddress _sender_ = msg.sender;\n\t\tif ( owner() != _sender_ ) {\n\t\t\trevert IERC173_NOT_OWNER( _sender_ );\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Sets the contract owner.\n\t* \n\t* Note: This function needs to be called in the contract constructor to initialize the contract owner, \n\t* if it is not, then parts of the contract might be non functional\n\t* \n\t* @param owner_ : address that owns the contract\n\t*/\n\tfunction _setOwner( address owner_ ) internal {\n\t\t_owner = owner_;\n\t}\n\n\t/**\n\t* @dev Returns the address of the current contract owner.\n\t* \n\t* @return address : the current contract owner\n\t*/\n\tfunction owner() public view virtual returns ( address ) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t* @dev Transfers ownership of the contract to `newOwner_`.\n\t* \n\t* @param newOwner_ : address of the new contract owner\n\t* \n\t* Requirements:\n\t* \n  * - Caller must be the contract owner.\n\t*/\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\n\t\taddress _oldOwner_ = _owner;\n\t\t_owner = newOwner_;\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\n\t}\n}\n"
    },
    "EthereumContracts/contracts/utils/ERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC2981.sol\";\n\nabstract contract ERC2981 is IERC2981 {\n\t// Errors\n  /**\n  * @dev Thrown when the desired royalty rate is higher than 10,000\n  * \n  * @param royaltyRate : the desired royalty rate\n  * @param royaltyBase : the maximum royalty rate\n  */\n\terror IERC2981_INVALID_ROYALTIES( uint256 royaltyRate, uint256 royaltyBase );\n\n\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\n\t// up to two digits below the unit such as 2.5% or 1.25%.\n\tuint private constant ROYALTY_BASE = 10000;\n\n\t// Represents the percentage of royalties on each sale on secondary markets.\n\t// Set to 0 to have no royalties.\n\tuint256 private _royaltyRate;\n\n\t// Address of the recipient of the royalties.\n\taddress private _royaltyRecipient;\n\n\t/**\n\t* @notice Called with the sale price to determine how much royalty is owed and to whom.\n\t* \n\t* Note: This function should be overriden to revert on a query for non existent token.\n\t* \n  * @param tokenId_   : identifier of the NFT being referenced\n  * @param salePrice_ : the sale price of the token sold\n  * \n  * @return address : the address receiving the royalties\n  * @return uint256 : the royalty payment amount\n\t*/\n\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\n\t\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\n\t\t\treturn ( _royaltyRecipient, 0 );\n\t\t}\n\t\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\n\t\treturn ( _royaltyRecipient, _royaltyAmount_ );\n\t}\n\n\t/**\n\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `royaltyRecipient_`.\n\t* \n\t* @param royaltyRecipient_ : the address that will receive royalty payments\n\t* @param royaltyRate_      : the percentage of the sale price that will be taken off as royalties, expressed in Basis Points (100 BP = 1%)\n\t* \n\t* Requirements: \n\t* \n\t* - `royaltyRate_` cannot be higher than `10,000`;\n\t*/\n\tfunction _setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) internal virtual {\n\t\tif ( royaltyRate_ > ROYALTY_BASE ) {\n\t\t\trevert IERC2981_INVALID_ROYALTIES( royaltyRate_, ROYALTY_BASE );\n\t\t}\n\t\t_royaltyRate      = royaltyRate_;\n\t\t_royaltyRecipient = royaltyRecipient_;\n\t}\n}\n"
    },
    "EthereumContracts/contracts/utils/Whitelist_ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n* Edit  : Squeebo\n*/\n\npragma solidity 0.8.17;\n\nabstract contract Whitelist_ECDSA {\n\t// Errors\n  /**\n  * @dev Thrown when trying to query the whitelist while it's not set\n  */\n\terror Whitelist_NOT_SET();\n  /**\n  * @dev Thrown when `account` has consumed their alloted access and tries to query more\n  * \n  * @param account : address trying to access the whitelist\n  */\n\terror Whitelist_CONSUMED( address account );\n  /**\n  * @dev Thrown when `account` does not have enough alloted access to fulfil their query\n  * \n  * @param account : address trying to access the whitelist\n  */\n\terror Whitelist_FORBIDDEN( address account );\n\n\t/**\n  * @dev A structure representing a signature proof to be decoded by the contract\n  */\n\tstruct Proof {\n\t\tbytes32 r;\n\t\tbytes32 s;\n\t\tuint8   v;\n\t}\n\n\taddress private _adminSigner;\n\tmapping( uint8 => mapping ( address => uint256 ) ) private _consumed;\n\n\t/**\n\t* @dev Ensures that `account_` has `qty_` alloted access on the `whitelistId_` whitelist.\n\t* \n\t* @param account_     : the address to validate access\n\t* @param whitelistId_ : the identifier of the whitelist being queried\n\t* @param alloted_     : the max amount of whitelist spots allocated\n\t* @param proof_       : the signature proof to validate whitelist allocation\n\t* @param qty_         : the amount of whitelist access requested\n\t*/\n\tmodifier isWhitelisted( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_, uint256 qty_ ) {\n\t\tuint256 _allowed_ = checkWhitelistAllowance( account_, whitelistId_, alloted_, proof_ );\n\n\t\tif ( _allowed_ < qty_ ) {\n\t\t\trevert Whitelist_FORBIDDEN( account_ );\n\t\t}\n\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Sets the pass to protect the whitelist.\n\t* \n\t* @param adminSigner_ : the address validating the whitelist signatures\n\t*/\n\tfunction _setWhitelist( address adminSigner_ ) internal virtual {\n\t\t_adminSigner = adminSigner_;\n\t}\n\n\t/**\n\t* @dev Returns the amount that `account_` is allowed to access from the whitelist.\n\t* \n\t* @param account_     : the address to validate access\n\t* @param whitelistId_ : the identifier of the whitelist being queried\n\t* @param alloted_     : the max amount of whitelist spots allocated\n\t* @param proof_       : the signature proof to validate whitelist allocation\n\t* \n\t* @return uint256 : the total amount of whitelist allocation remaining for `account_`\n\t* \n\t* Requirements:\n\t* \n\t* - `_adminSigner` must be set.\n\t*/\n\tfunction checkWhitelistAllowance( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) public view returns ( uint256 ) {\n\t\tif ( _adminSigner == address( 0 ) ) {\n\t\t\trevert Whitelist_NOT_SET();\n\t\t}\n\n\t\tif ( _consumed[ whitelistId_ ][ account_ ] >= alloted_ ) {\n\t\t\trevert Whitelist_CONSUMED( account_ );\n\t\t}\n\n\t\tif ( ! _validateProof( account_, whitelistId_, alloted_, proof_ ) ) {\n\t\t\trevert Whitelist_FORBIDDEN( account_ );\n\t\t}\n\n\t\treturn alloted_ - _consumed[ whitelistId_ ][ account_ ];\n\t}\n\n\t/**\n\t* @dev Internal function to decode a signature and compare it with the `_adminSigner`.\n\t* \n\t* @param account_     : the address to validate access\n\t* @param whitelistId_ : the identifier of the whitelist being queried\n\t* @param alloted_     : the max amount of whitelist spots allocated\n\t* @param proof_       : the signature proof to validate whitelist allocation\n\t* \n\t* @return bool : whether the signature is valid or not\n\t*/ \n\tfunction _validateProof( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) private view returns ( bool ) {\n\t\tbytes32 _digest_ = keccak256( abi.encode( whitelistId_, alloted_, account_ ) );\n\t\taddress _signer_ = ecrecover( _digest_, proof_.v, proof_.r, proof_.s );\n\t\treturn _signer_ == _adminSigner;\n\t}\n\n\t/**\n\t* @dev Consumes `amount_` whitelist access passes from `account_`.\n\t* \n\t* @param account_     : the address to consume access from\n\t* @param whitelistId_ : the identifier of the whitelist being queried\n\t* @param qty_         : the amount of whitelist access consumed\n\t* \n\t* Note: Before calling this function, eligibility should be checked through {Whitelistable-checkWhitelistAllowance}.\n\t*/\n\tfunction _consumeWhitelist( address account_, uint8 whitelistId_, uint256 qty_ ) internal {\n\t\tunchecked {\n\t\t\t_consumed[ whitelistId_ ][ account_ ] += qty_;\n\t\t}\n\t}\n}\n"
    },
    "operator-filter-registry/src/IOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IOperatorFilterRegistry {\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n    function register(address registrant) external;\n    function registerAndSubscribe(address registrant, address subscription) external;\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n    function unregister(address addr) external;\n    function updateOperator(address registrant, address operator, bool filtered) external;\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n    function subscribe(address registrant, address registrantToSubscribe) external;\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n    function subscriptionOf(address addr) external returns (address registrant);\n    function subscribers(address registrant) external returns (address[] memory);\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n    function filteredOperators(address addr) external returns (address[] memory);\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n    function isRegistered(address addr) external returns (bool);\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "operator-filter-registry/src/UpdatableOperatorFilterer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\n\n/**\n * @title  UpdatableOperatorFilterer\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\n *         registrant's entries in the OperatorFilterRegistry. This contract allows the Owner to update the\n *         OperatorFilterRegistry address via updateOperatorFilterRegistryAddress, including to the zero address,\n *         which will bypass registry checks.\n *         Note that OpenSea will still disable creator fee enforcement if filtered operators begin fulfilling orders\n *         on-chain, eg, if the registry is revoked or bypassed.\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\n */\nabstract contract UpdatableOperatorFilterer {\n    error OperatorNotAllowed(address operator);\n    error OnlyOwner();\n\n    IOperatorFilterRegistry public operatorFilterRegistry;\n\n    constructor(address _registry, address subscriptionOrRegistrantToCopy, bool subscribe) {\n        IOperatorFilterRegistry registry = IOperatorFilterRegistry(_registry);\n        operatorFilterRegistry = registry;\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\n        // order for the modifier to filter addresses.\n        if (address(registry).code.length > 0) {\n            if (subscribe) {\n                registry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n            } else {\n                if (subscriptionOrRegistrantToCopy != address(0)) {\n                    registry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    registry.register(address(this));\n                }\n            }\n        }\n    }\n\n    modifier onlyAllowedOperator(address from) virtual {\n        // Allow spending tokens from addresses with balance\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n        // from an EOA.\n        if (from != msg.sender) {\n            _checkFilterOperator(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }\n\n    /**\n     * @notice Update the address that the contract will make OperatorFilter checks against. When set to the zero\n     *         address, checks will be bypassed. OnlyOwner.\n     */\n    function updateOperatorFilterRegistryAddress(address newRegistry) public virtual {\n        if (msg.sender != owner()) {\n            revert OnlyOwner();\n        }\n        operatorFilterRegistry = IOperatorFilterRegistry(newRegistry);\n    }\n\n    /**\n     * @dev assume the contract has an owner, but leave specific Ownable implementation up to inheriting contract\n     */\n    function owner() public view virtual returns (address);\n\n    function _checkFilterOperator(address operator) internal view virtual {\n        IOperatorFilterRegistry registry = operatorFilterRegistry;\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(registry) != address(0) && address(registry).code.length > 0) {\n            if (!registry.isOperatorAllowed(address(this), operator)) {\n                revert OperatorNotAllowed(operator);\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}