{{
  "language": "Solidity",
  "sources": {
    "contracts/minter-suite/Minters/MinterSetPrice/MinterSetPriceV2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"../../../interfaces/0.8.x/IGenArt721CoreContractV3.sol\";\nimport \"../../../interfaces/0.8.x/IMinterFilterV0.sol\";\nimport \"../../../interfaces/0.8.x/IFilteredMinterV0.sol\";\n\nimport \"@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol\";\n\npragma solidity 0.8.17;\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH.\n * This is designed to be used with IGenArt721CoreContractV3 contracts.\n * @author Art Blocks Inc.\n * @notice Privileged Roles and Ownership:\n * This contract is designed to be managed, with limited powers.\n * Privileged roles and abilities are controlled by the project's artist, which\n * can be modified by the core contract's Admin ACL contract. Both of these\n * roles hold extensive power and can modify minter details.\n * Care must be taken to ensure that the admin ACL contract and artist\n * addresses are secure behind a multi-sig or other access control mechanism.\n * ----------------------------------------------------------------------------\n * The following functions are restricted to a project's artist:\n * - updatePricePerTokenInWei\n * ----------------------------------------------------------------------------\n * Additional admin and artist privileged roles may be described on other\n * contracts that this minter integrates with.\n */\ncontract MinterSetPriceV2 is ReentrancyGuard, IFilteredMinterV0 {\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// This contract handles cores with interface IV3\n    IGenArt721CoreContractV3 private immutable genArtCoreContract;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MinterSetPriceV2\";\n\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    struct ProjectConfig {\n        bool maxHasBeenInvoked;\n        bool priceIsConfigured;\n        uint24 maxInvocations;\n        uint256 pricePerTokenInWei;\n    }\n\n    mapping(uint256 => ProjectConfig) public projectConfig;\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(\n            msg.sender ==\n                genArtCoreContract.projectIdToArtistAddress(_projectId),\n            \"Only Artist\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for which this will be a\n     * filtered minter.\n     */\n    constructor(address _genArt721Address, address _minterFilter)\n        ReentrancyGuard()\n    {\n        genArt721CoreAddress = _genArt721Address;\n        genArtCoreContract = IGenArt721CoreContractV3(_genArt721Address);\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n        require(\n            minterFilter.genArt721CoreAddress() == _genArt721Address,\n            \"Illegal contract pairing\"\n        );\n    }\n\n    /**\n     * @notice Syncs local maximum invocations of project `_projectId` based on\n     * the value currently defined in the core contract. Only used for gas\n     * optimization of mints after maxInvocations has been reached.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     * @dev function is intentionally not gated to any specific access control;\n     * it only syncs a local state variable to the core contract's state.\n     */\n    function setProjectMaxInvocations(uint256 _projectId) external {\n        uint256 maxInvocations;\n        (, maxInvocations, , , , ) = genArtCoreContract.projectStateData(\n            _projectId\n        );\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\n    }\n\n    /**\n     * @notice Warning: Disabling purchaseTo is not supported on this minter.\n     * This method exists purely for interface-conformance purposes.\n     */\n    function togglePurchaseToDisabled(uint256 _projectId)\n        external\n        view\n        onlyArtist(_projectId)\n    {\n        revert(\"Action not supported\");\n    }\n\n    /**\n     * @notice projectId => has project reached its maximum number of\n     * invocations? Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached. A false negative will\n     * only result in a gas cost increase, since the core contract will still\n     * enforce a maxInvocation check during minting. A false positive is not\n     * possible because the V3 core contract only allows maximum invocations\n     * to be reduced, not increased. Based on this rationale, we intentionally\n     * do not do input validation in this method as to whether or not the input\n     * `_projectId` is an existing project ID.\n     */\n    function projectMaxHasBeenInvoked(uint256 _projectId)\n        external\n        view\n        returns (bool)\n    {\n        return projectConfig[_projectId].maxHasBeenInvoked;\n    }\n\n    /**\n     * @notice projectId => project's maximum number of invocations.\n     * Optionally synced with core contract value, for gas optimization.\n     * Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached.\n     * @dev A number greater than the core contract's project max invocations\n     * will only result in a gas cost increase, since the core contract will\n     * still enforce a maxInvocation check during minting. A number less than\n     * the core contract's project max invocations is only possible when the\n     * project's max invocations have not been synced on this minter, since the\n     * V3 core contract only allows maximum invocations to be reduced, not\n     * increased. When this happens, the minter will enable minting, allowing\n     * the core contract to enforce the max invocations check. Based on this\n     * rationale, we intentionally do not do input validation in this method as\n     * to whether or not the input `_projectId` is an existing project ID.\n     */\n    function projectMaxInvocations(uint256 _projectId)\n        external\n        view\n        returns (uint256)\n    {\n        return uint256(projectConfig[_projectId].maxInvocations);\n    }\n\n    /**\n     * @notice Updates this minter's price per token of project `_projectId`\n     * to be '_pricePerTokenInWei`, in Wei.\n     * This price supersedes any legacy core contract price per token value.\n     * @dev Note that it is intentionally supported here that the configured\n     * price may be explicitly set to `0`.\n     */\n    function updatePricePerTokenInWei(\n        uint256 _projectId,\n        uint256 _pricePerTokenInWei\n    ) external onlyArtist(_projectId) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        _projectConfig.pricePerTokenInWei = _pricePerTokenInWei;\n        _projectConfig.priceIsConfigured = true;\n        emit PricePerTokenInWeiUpdated(_projectId, _pricePerTokenInWei);\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId`.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice gas-optimized version of purchase(uint256).\n     */\n    function purchase_H4M(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        tokenId = purchaseTo_do6(msg.sender, _projectId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Purchases a token from project `_projectId` and sets\n     * the token's owner to `_to`.\n     * @param _to Address to be the new token's owner.\n     * @param _projectId Project ID to mint a token on.\n     * @return tokenId Token ID of minted token\n     */\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId)\n    {\n        return purchaseTo_do6(_to, _projectId);\n    }\n\n    /**\n     * @notice gas-optimized version of purchaseTo(address, uint256).\n     */\n    function purchaseTo_do6(address _to, uint256 _projectId)\n        public\n        payable\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\n        // consumption after a project has been fully minted.\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\n        // gas consumption, but if not in sync with the core contract's value,\n        // the core contract also enforces its own max invocation check during\n        // minting.\n        require(\n            !_projectConfig.maxHasBeenInvoked,\n            \"Maximum number of invocations reached\"\n        );\n\n        // require artist to have configured price of token on this minter\n        require(_projectConfig.priceIsConfigured, \"Price not configured\");\n\n        // load price of token into memory\n        uint256 _pricePerTokenInWei = _projectConfig.pricePerTokenInWei;\n\n        require(\n            msg.value >= _pricePerTokenInWei,\n            \"Must send minimum value to mint!\"\n        );\n\n        // EFFECTS\n        tokenId = minterFilter.mint(_to, _projectId, msg.sender);\n\n        // okay if this underflows because if statement will always eval false.\n        // this is only for gas optimization (core enforces maxInvocations).\n        unchecked {\n            if (tokenId % ONE_MILLION == _projectConfig.maxInvocations - 1) {\n                _projectConfig.maxHasBeenInvoked = true;\n            }\n        }\n\n        // INTERACTIONS\n        _splitFundsETH(_projectId, _pricePerTokenInWei);\n\n        return tokenId;\n    }\n\n    /**\n     * @dev splits ETH funds between sender (if refund), foundation,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     */\n    function _splitFundsETH(uint256 _projectId, uint256 _pricePerTokenInWei)\n        internal\n    {\n        if (msg.value > 0) {\n            bool success_;\n            // send refund to sender\n            uint256 refund = msg.value - _pricePerTokenInWei;\n            if (refund > 0) {\n                (success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            // split remaining funds between foundation, artist, and artist's\n            // additional payee\n            (\n                uint256 artblocksRevenue_,\n                address payable artblocksAddress_,\n                uint256 artistRevenue_,\n                address payable artistAddress_,\n                uint256 additionalPayeePrimaryRevenue_,\n                address payable additionalPayeePrimaryAddress_\n            ) = genArtCoreContract.getPrimaryRevenueSplits(\n                    _projectId,\n                    _pricePerTokenInWei\n                );\n            // Art Blocks payment\n            if (artblocksRevenue_ > 0) {\n                (success_, ) = artblocksAddress_.call{value: artblocksRevenue_}(\n                    \"\"\n                );\n                require(success_, \"Art Blocks payment failed\");\n            }\n            // artist payment\n            if (artistRevenue_ > 0) {\n                (success_, ) = artistAddress_.call{value: artistRevenue_}(\"\");\n                require(success_, \"Artist payment failed\");\n            }\n            // additional payee payment\n            if (additionalPayeePrimaryRevenue_ > 0) {\n                (success_, ) = additionalPayeePrimaryAddress_.call{\n                    value: additionalPayeePrimaryRevenue_\n                }(\"\");\n                require(success_, \"Additional Payee payment failed\");\n            }\n        }\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if token price has been configured on\n     * this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if price has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        )\n    {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        isConfigured = _projectConfig.priceIsConfigured;\n        tokenPriceInWei = _projectConfig.pricePerTokenInWei;\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n}\n"
    },
    "contracts/interfaces/0.8.x/IGenArt721CoreContractV3.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\n/// use the Royalty Registry's IManifold interface for token royalties\nimport \"./IManifold.sol\";\n\ninterface IGenArt721CoreContractV3 is IManifold {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     */\n    event Mint(address indexed _to, uint256 indexed _tokenId);\n\n    /**\n     * @notice currentMinter updated to `_currentMinter`.\n     * @dev Implemented starting with V3 core\n     */\n    event MinterUpdated(address indexed _currentMinter);\n\n    /**\n     * @notice Platform updated on bytes32-encoded field `_field`.\n     */\n    event PlatformUpdated(bytes32 indexed _field);\n\n    /**\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\n     * `_update`.\n     */\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\n\n    event ProposedArtistAddressesAndSplits(\n        uint256 indexed _projectId,\n        address _artistAddress,\n        address _additionalPayeePrimarySales,\n        uint256 _additionalPayeePrimarySalesPercentage,\n        address _additionalPayeeSecondarySales,\n        uint256 _additionalPayeeSecondarySalesPercentage\n    );\n\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\n\n    // version and type of the core contract\n    // coreVersion is a string of the form \"0.x.y\"\n    function coreVersion() external view returns (string memory);\n\n    // coreType is a string of the form \"GenArt721CoreV3\"\n    function coreType() external view returns (string memory);\n\n    // owner (pre-V3 was named admin) of contract\n    // this is expected to be an Admin ACL contract for V3\n    function owner() external view returns (address);\n\n    // Admin ACL contract for V3, will be at the address owner()\n    function adminACLContract() external returns (IAdminACLV0);\n\n    // backwards-compatible (pre-V3) admin - equal to owner()\n    function admin() external view returns (address);\n\n    /**\n     * Function determining if _sender is allowed to call function with\n     * selector _selector on contract `_contract`. Intended to be used with\n     * peripheral contracts such as minters, as well as internally by the\n     * core contract itself.\n     */\n    function adminACLAllowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(uint256 tokenId)\n        external\n        view\n        returns (uint256 projectId);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySales(uint256 _projectId)\n        external\n        view\n        returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\n        uint256 _projectId\n    ) external view returns (uint256);\n\n    // @dev new function in V3\n    function getPrimaryRevenueSplits(uint256 _projectId, uint256 _price)\n        external\n        view\n        returns (\n            uint256 artblocksRevenue_,\n            address payable artblocksAddress_,\n            uint256 artistRevenue_,\n            address payable artistAddress_,\n            uint256 additionalPayeePrimaryRevenue_,\n            address payable additionalPayeePrimaryAddress_\n        );\n\n    // @dev new function in V3\n    function projectStateData(uint256 _projectId)\n        external\n        view\n        returns (\n            uint256 invocations,\n            uint256 maxInvocations,\n            bool active,\n            bool paused,\n            uint256 completedTimestamp,\n            bool locked\n        );\n\n    // @dev Art Blocks primary sales payment address\n    function artblocksPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\n     */\n    function artblocksAddress() external view returns (address payable);\n\n    // @dev Percentage of primary sales allocated to Art Blocks\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\n     */\n    function artblocksPercentage() external view returns (uint256);\n\n    // @dev Art Blocks secondary sales royalties payment address\n    function artblocksSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Basis points of secondary sales allocated to Art Blocks\n    function artblocksSecondarySalesBPS() external view returns (uint256);\n\n    // function to set a token's hash (must be guarded)\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\n\n    // @dev gas-optimized signature in V3 for `mint`\n    function mint_Ecf(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\n     * artist's additional payee royalty data for token ID `_tokenId`.\n     * WARNING: Does not include Art Blocks portion of royalties.\n     */\n    function getRoyaltyData(uint256 _tokenId)\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"
    },
    "contracts/interfaces/0.8.x/IMinterFilterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/0.8.x/IFilteredMinterV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(address _to, uint256 _projectId)\n        external\n        payable\n        returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(uint256 _projectId)\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"
    },
    "@openzeppelin-4.5/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/0.8.x/IAdminACLV0.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IAdminACLV0 {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     * @param previousSuperAdmin The previous superAdmin address.\n     * @param newSuperAdmin The new superAdmin address.\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\n     * addresses to update to the new superAdmin, for indexing purposes only.\n     */\n    event SuperAdminTransferred(\n        address indexed previousSuperAdmin,\n        address indexed newSuperAdmin,\n        address[] genArt721CoreAddressesToUpdate\n    );\n\n    /// Type of the Admin ACL contract, e.g. \"AdminACLV0\"\n    function AdminACLType() external view returns (string memory);\n\n    /// super admin address\n    function superAdmin() external view returns (address);\n\n    /**\n     * @notice Calls transferOwnership on other contract from this contract.\n     * This is useful for updating to a new AdminACL contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function transferOwnershipOn(address _contract, address _newAdminACL)\n        external;\n\n    /**\n     * @notice Calls renounceOwnership on other contract from this contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function renounceOwnershipOn(address _contract) external;\n\n    /**\n     * @notice Checks if sender `_sender` is allowed to call function with selector\n     * `_selector` on contract `_contract`.\n     */\n    function allowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/0.8.x/IManifold.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\n\n/// @author: manifold.xyz\n\n/**\n * @dev Royalty interface for creator core classes\n */\ninterface IManifold {\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     *\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n     *\n     *  => 0xbb3bafd6 = 0xbb3bafd6\n     */\n    function getRoyalties(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 25
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}