{{
  "language": "Solidity",
  "sources": {
    "contracts/TransferManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// LooksRare unopinionated libraries\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {LowLevelERC721Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\";\nimport {LowLevelERC1155Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol\";\n\n// Interfaces and errors\nimport {ITransferManager} from \"./interfaces/ITransferManager.sol\";\nimport {AmountInvalid, LengthsInvalid} from \"./errors/SharedErrors.sol\";\n\n// Libraries\nimport {OrderStructs} from \"./libraries/OrderStructs.sol\";\n\n// Enums\nimport {CollectionType} from \"./enums/CollectionType.sol\";\n\n/**\n * @title TransferManager\n * @notice This contract provides the transfer functions for ERC721/ERC1155 for contracts that require them.\n *         Collection type \"0\" refers to ERC721 transfer functions.\n *         Collection type \"1\" refers to ERC1155 transfer functions.\n * @dev \"Safe\" transfer functions for ERC721 are not implemented since they come with added gas costs\n *       to verify if the recipient is a contract as it requires verifying the receiver interface is valid.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract TransferManager is ITransferManager, LowLevelERC721Transfer, LowLevelERC1155Transfer, OwnableTwoSteps {\n    /**\n     * @notice This returns whether the user has approved the operator address.\n     * The first address is the user and the second address is the operator (e.g. LooksRareProtocol).\n     */\n    mapping(address => mapping(address => bool)) public hasUserApprovedOperator;\n\n    /**\n     * @notice This returns whether the operator address is allowed by this contract's owner.\n     */\n    mapping(address => bool) public isOperatorAllowed;\n\n    /**\n     * @notice Constructor\n     * @param _owner Owner address\n     */\n    constructor(address _owner) OwnableTwoSteps(_owner) {}\n\n    /**\n     * @notice This function transfers items for a single ERC721 collection.\n     * @param collection Collection address\n     * @param from Sender address\n     * @param to Recipient address\n     * @param itemIds Array of itemIds\n     * @param amounts Array of amounts\n     */\n    function transferItemsERC721(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata itemIds,\n        uint256[] calldata amounts\n    ) external {\n        uint256 length = itemIds.length;\n        if (length == 0) {\n            revert LengthsInvalid();\n        }\n\n        _isOperatorValidForTransfer(from, msg.sender);\n\n        for (uint256 i; i < length; ) {\n            if (amounts[i] != 1) {\n                revert AmountInvalid();\n            }\n            _executeERC721TransferFrom(collection, from, to, itemIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice This function transfers items for a single ERC1155 collection.\n     * @param collection Collection address\n     * @param from Sender address\n     * @param to Recipient address\n     * @param itemIds Array of itemIds\n     * @param amounts Array of amounts\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\n     */\n    function transferItemsERC1155(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata itemIds,\n        uint256[] calldata amounts\n    ) external {\n        uint256 length = itemIds.length;\n\n        if (length == 0 || amounts.length != length) {\n            revert LengthsInvalid();\n        }\n\n        _isOperatorValidForTransfer(from, msg.sender);\n\n        if (length == 1) {\n            if (amounts[0] == 0) {\n                revert AmountInvalid();\n            }\n            _executeERC1155SafeTransferFrom(collection, from, to, itemIds[0], amounts[0]);\n        } else {\n            for (uint256 i; i < length; ) {\n                if (amounts[i] == 0) {\n                    revert AmountInvalid();\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n            _executeERC1155SafeBatchTransferFrom(collection, from, to, itemIds, amounts);\n        }\n    }\n\n    /**\n     * @notice This function transfers items across an array of collections that can be both ERC721 and ERC1155.\n     * @param items Array of BatchTransferItem\n     * @param from Sender address\n     * @param to Recipient address\n     */\n    function transferBatchItemsAcrossCollections(\n        BatchTransferItem[] calldata items,\n        address from,\n        address to\n    ) external {\n        uint256 itemsLength = items.length;\n\n        if (itemsLength == 0) {\n            revert LengthsInvalid();\n        }\n\n        if (from != msg.sender) {\n            _isOperatorValidForTransfer(from, msg.sender);\n        }\n\n        for (uint256 i; i < itemsLength; ) {\n            uint256[] calldata itemIds = items[i].itemIds;\n            uint256 itemIdsLengthForSingleCollection = itemIds.length;\n            uint256[] calldata amounts = items[i].amounts;\n\n            if (itemIdsLengthForSingleCollection == 0 || amounts.length != itemIdsLengthForSingleCollection) {\n                revert LengthsInvalid();\n            }\n\n            CollectionType collectionType = items[i].collectionType;\n            if (collectionType == CollectionType.ERC721) {\n                for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\n                    if (amounts[j] != 1) {\n                        revert AmountInvalid();\n                    }\n                    _executeERC721TransferFrom(items[i].collection, from, to, itemIds[j]);\n                    unchecked {\n                        ++j;\n                    }\n                }\n            } else if (collectionType == CollectionType.ERC1155) {\n                for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\n                    if (amounts[j] == 0) {\n                        revert AmountInvalid();\n                    }\n\n                    unchecked {\n                        ++j;\n                    }\n                }\n                _executeERC1155SafeBatchTransferFrom(items[i].collection, from, to, itemIds, amounts);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice This function allows a user to grant approvals for an array of operators.\n     *         Users cannot grant approvals if the operator is not allowed by this contract's owner.\n     * @param operators Array of operator addresses\n     * @dev Each operator address must be globally allowed to be approved.\n     */\n    function grantApprovals(address[] calldata operators) external {\n        uint256 length = operators.length;\n\n        if (length == 0) {\n            revert LengthsInvalid();\n        }\n\n        for (uint256 i; i < length; ) {\n            address operator = operators[i];\n\n            if (!isOperatorAllowed[operator]) {\n                revert OperatorNotAllowed();\n            }\n\n            if (hasUserApprovedOperator[msg.sender][operator]) {\n                revert OperatorAlreadyApprovedByUser();\n            }\n\n            hasUserApprovedOperator[msg.sender][operator] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ApprovalsGranted(msg.sender, operators);\n    }\n\n    /**\n     * @notice This function allows a user to revoke existing approvals for an array of operators.\n     * @param operators Array of operator addresses\n     * @dev Each operator address must be approved at the user level to be revoked.\n     */\n    function revokeApprovals(address[] calldata operators) external {\n        uint256 length = operators.length;\n        if (length == 0) {\n            revert LengthsInvalid();\n        }\n\n        for (uint256 i; i < length; ) {\n            address operator = operators[i];\n\n            if (!hasUserApprovedOperator[msg.sender][operator]) {\n                revert OperatorNotApprovedByUser();\n            }\n\n            delete hasUserApprovedOperator[msg.sender][operator];\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ApprovalsRemoved(msg.sender, operators);\n    }\n\n    /**\n     * @notice This function allows an operator to be added for the shared transfer system.\n     *         Once the operator is allowed, users can grant NFT approvals to this operator.\n     * @param operator Operator address to allow\n     * @dev Only callable by owner.\n     */\n    function allowOperator(address operator) external onlyOwner {\n        if (isOperatorAllowed[operator]) {\n            revert OperatorAlreadyAllowed();\n        }\n\n        isOperatorAllowed[operator] = true;\n\n        emit OperatorAllowed(operator);\n    }\n\n    /**\n     * @notice This function allows the user to remove an operator for the shared transfer system.\n     * @param operator Operator address to remove\n     * @dev Only callable by owner.\n     */\n    function removeOperator(address operator) external onlyOwner {\n        if (!isOperatorAllowed[operator]) {\n            revert OperatorNotAllowed();\n        }\n\n        delete isOperatorAllowed[operator];\n\n        emit OperatorRemoved(operator);\n    }\n\n    /**\n     * @notice This function is internal and verifies whether the transfer\n     *         (by an operator on behalf of a user) is valid. If not, it reverts.\n     * @param user User address\n     * @param operator Operator address\n     */\n    function _isOperatorValidForTransfer(address user, address operator) private view {\n        if (isOperatorAllowed[operator] && hasUserApprovedOperator[user][operator]) {\n            return;\n        }\n\n        revert TransferCallerInvalid();\n    }\n}\n"
    },
    "contracts/enums/CollectionType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @notice CollectionType is used in OrderStructs.Maker's collectionType to determine the collection type being traded.\n */\nenum CollectionType {\n    ERC721,\n    ERC1155\n}\n"
    },
    "contracts/enums/QuoteType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @notice QuoteType is used in OrderStructs.Maker's quoteType to determine whether the maker order is a bid or an ask.\n */\nenum QuoteType {\n    Bid,\n    Ask\n}\n"
    },
    "contracts/errors/SharedErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @notice It is returned if the amount is invalid.\n *         For ERC721, any number that is not 1. For ERC1155, if amount is 0.\n */\nerror AmountInvalid();\n\n/**\n * @notice It is returned if the ask price is too high for the bid user.\n */\nerror AskTooHigh();\n\n/**\n * @notice It is returned if the bid price is too low for the ask user.\n */\nerror BidTooLow();\n\n/**\n * @notice It is returned if the function cannot be called by the sender.\n */\nerror CallerInvalid();\n\n/**\n * @notice It is returned if the currency is invalid.\n */\nerror CurrencyInvalid();\n\n/**\n * @notice The function selector is invalid for this strategy implementation.\n */\nerror FunctionSelectorInvalid();\n\n/**\n * @notice It is returned if there is either a mismatch or an error in the length of the array(s).\n */\nerror LengthsInvalid();\n\n/**\n * @notice It is returned if the merkle proof provided is invalid.\n */\nerror MerkleProofInvalid();\n\n/**\n * @notice It is returned if the length of the merkle proof provided is greater than tolerated.\n * @param length Proof length\n */\nerror MerkleProofTooLarge(uint256 length);\n\n/**\n * @notice It is returned if the order is permanently invalid.\n *         There may be an issue with the order formatting.\n */\nerror OrderInvalid();\n\n/**\n * @notice It is returned if the maker quote type is invalid.\n */\nerror QuoteTypeInvalid();\n"
    },
    "contracts/interfaces/ITransferManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Libraries\nimport {OrderStructs} from \"../libraries/OrderStructs.sol\";\n\n// Enums\nimport {CollectionType} from \"../enums/CollectionType.sol\";\n\n/**\n * @title ITransferManager\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface ITransferManager {\n    /**\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\n     * @param collection Collection address\n     * @param collectionType 0 for ERC721, 1 for ERC1155\n     * @param itemIds Array of item ids to transfer\n     * @param amounts Array of amounts to transfer\n     */\n    struct BatchTransferItem {\n        address collection;\n        CollectionType collectionType;\n        uint256[] itemIds;\n        uint256[] amounts;\n    }\n\n    /**\n     * @notice It is emitted if operators' approvals to transfer NFTs are granted by a user.\n     * @param user Address of the user\n     * @param operators Array of operator addresses\n     */\n    event ApprovalsGranted(address user, address[] operators);\n\n    /**\n     * @notice It is emitted if operators' approvals to transfer NFTs are revoked by a user.\n     * @param user Address of the user\n     * @param operators Array of operator addresses\n     */\n    event ApprovalsRemoved(address user, address[] operators);\n\n    /**\n     * @notice It is emitted if a new operator is added to the global allowlist.\n     * @param operator Operator address\n     */\n    event OperatorAllowed(address operator);\n\n    /**\n     * @notice It is emitted if an operator is removed from the global allowlist.\n     * @param operator Operator address\n     */\n    event OperatorRemoved(address operator);\n\n    /**\n     * @notice It is returned if the operator to approve has already been approved by the user.\n     */\n    error OperatorAlreadyApprovedByUser();\n\n    /**\n     * @notice It is returned if the operator to revoke has not been previously approved by the user.\n     */\n    error OperatorNotApprovedByUser();\n\n    /**\n     * @notice It is returned if the transfer caller is already allowed by the owner.\n     * @dev This error can only be returned for owner operations.\n     */\n    error OperatorAlreadyAllowed();\n\n    /**\n     * @notice It is returned if the operator to approve is not in the global allowlist defined by the owner.\n     * @dev This error can be returned if the user tries to grant approval to an operator address not in the\n     *      allowlist or if the owner tries to remove the operator from the global allowlist.\n     */\n    error OperatorNotAllowed();\n\n    /**\n     * @notice It is returned if the transfer caller is invalid.\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\n     *         approved by the 'from' user.\n     */\n    error TransferCallerInvalid();\n}\n"
    },
    "contracts/libraries/OrderStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// Enums\nimport {CollectionType} from \"../enums/CollectionType.sol\";\nimport {QuoteType} from \"../enums/QuoteType.sol\";\n\n/**\n * @title OrderStructs\n * @notice This library contains all order struct types for the LooksRare protocol (v2).\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nlibrary OrderStructs {\n    /**\n     * 1. Maker struct\n     */\n\n    /**\n     * @notice Maker is the struct for a maker order.\n     * @param quoteType Quote type (i.e. 0 = BID, 1 = ASK)\n     * @param globalNonce Global user order nonce for maker orders\n     * @param subsetNonce Subset nonce (shared across bid/ask maker orders)\n     * @param orderNonce Order nonce (it can be shared across bid/ask maker orders)\n     * @param strategyId Strategy id\n     * @param collectionType Collection type (i.e. 0 = ERC721, 1 = ERC1155)\n     * @param collection Collection address\n     * @param currency Currency address (@dev address(0) = ETH)\n     * @param signer Signer address\n     * @param startTime Start timestamp\n     * @param endTime End timestamp\n     * @param price Minimum price for maker ask, maximum price for maker bid\n     * @param itemIds Array of itemIds\n     * @param amounts Array of amounts\n     * @param additionalParameters Extra data specific for the order\n     */\n    struct Maker {\n        QuoteType quoteType;\n        uint256 globalNonce;\n        uint256 subsetNonce;\n        uint256 orderNonce;\n        uint256 strategyId;\n        CollectionType collectionType;\n        address collection;\n        address currency;\n        address signer;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 price;\n        uint256[] itemIds;\n        uint256[] amounts;\n        bytes additionalParameters;\n    }\n\n    /**\n     * 2. Taker struct\n     */\n\n    /**\n     * @notice Taker is the struct for a taker ask/bid order. It contains the parameters required for a direct purchase.\n     * @dev Taker struct is matched against MakerAsk/MakerBid structs at the protocol level.\n     * @param recipient Recipient address (to receive NFTs or non-fungible tokens)\n     * @param additionalParameters Extra data specific for the order\n     */\n    struct Taker {\n        address recipient;\n        bytes additionalParameters;\n    }\n\n    /**\n     * 3. Merkle tree struct\n     */\n\n    enum MerkleTreeNodePosition { Left, Right }\n\n    /**\n     * @notice MerkleTreeNode is a MerkleTree's node.\n     * @param value It can be an order hash or a proof\n     * @param position The node's position in its branch.\n     *                 It can be left or right or none\n     *                 (before the tree is sorted).\n     */\n    struct MerkleTreeNode {\n        bytes32 value;\n        MerkleTreeNodePosition position;\n    }\n\n    /**\n     * @notice MerkleTree is the struct for a merkle tree of order hashes.\n     * @dev A Merkle tree can be computed with order hashes.\n     *      It can contain order hashes from both maker bid and maker ask structs.\n     * @param root Merkle root\n     * @param proof Array containing the merkle proof\n     */\n    struct MerkleTree {\n        bytes32 root;\n        MerkleTreeNode[] proof;\n    }\n\n    /**\n     * 4. Constants\n     */\n\n    /**\n     * @notice This is the type hash constant used to compute the maker order hash.\n     */\n    bytes32 internal constant _MAKER_TYPEHASH =\n        keccak256(\n            \"Maker(\"\n                \"uint8 quoteType,\"\n                \"uint256 globalNonce,\"\n                \"uint256 subsetNonce,\"\n                \"uint256 orderNonce,\"\n                \"uint256 strategyId,\"\n                \"uint8 collectionType,\"\n                \"address collection,\"\n                \"address currency,\"\n                \"address signer,\"\n                \"uint256 startTime,\"\n                \"uint256 endTime,\"\n                \"uint256 price,\"\n                \"uint256[] itemIds,\"\n                \"uint256[] amounts,\"\n                \"bytes additionalParameters\"\n            \")\"\n        );\n\n    /**\n     * 5. Hash functions\n     */\n\n    /**\n     * @notice This function is used to compute the order hash for a maker struct.\n     * @param maker Maker order struct\n     * @return makerHash Hash of the maker struct\n     */\n    function hash(Maker memory maker) internal pure returns (bytes32) {\n        // Encoding is done into two parts to avoid stack too deep issues\n        return\n            keccak256(\n                bytes.concat(\n                    abi.encode(\n                        _MAKER_TYPEHASH,\n                        maker.quoteType,\n                        maker.globalNonce,\n                        maker.subsetNonce,\n                        maker.orderNonce,\n                        maker.strategyId,\n                        maker.collectionType,\n                        maker.collection,\n                        maker.currency\n                    ),\n                    abi.encode(\n                        maker.signer,\n                        maker.startTime,\n                        maker.endTime,\n                        maker.price,\n                        keccak256(abi.encodePacked(maker.itemIds)),\n                        keccak256(abi.encodePacked(maker.amounts)),\n                        keccak256(maker.additionalParameters)\n                    )\n                )\n            );\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IOwnableTwoSteps} from \"./interfaces/IOwnableTwoSteps.sol\";\n\n/**\n * @title OwnableTwoSteps\n * @notice This contract offers transfer of ownership in two steps with potential owner\n *         having to confirm the transaction to become the owner.\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\n    /**\n     * @notice Address of the current owner.\n     */\n    address public owner;\n\n    /**\n     * @notice Address of the potential owner.\n     */\n    address public potentialOwner;\n\n    /**\n     * @notice Ownership status.\n     */\n    Status public ownershipStatus;\n\n    /**\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\n     */\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param _owner The contract's owner\n     */\n    constructor(address _owner) {\n        owner = _owner;\n        emit NewOwner(_owner);\n    }\n\n    /**\n     * @notice This function is used to cancel the ownership transfer.\n     * @dev This function can be used for both cancelling a transfer to a new owner and\n     *      cancelling the renouncement of the ownership.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        Status _ownershipStatus = ownershipStatus;\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\n            revert NoOngoingTransferInProgress();\n        }\n\n        if (_ownershipStatus == Status.TransferInProgress) {\n            delete potentialOwner;\n        }\n\n        delete ownershipStatus;\n\n        emit CancelOwnershipTransfer();\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership renouncement.\n     */\n    function confirmOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.RenouncementInProgress) {\n            revert RenouncementNotInProgress();\n        }\n\n        delete owner;\n        delete ownershipStatus;\n\n        emit NewOwner(address(0));\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership transfer.\n     * @dev This function can only be called by the current potential owner.\n     */\n    function confirmOwnershipTransfer() external {\n        if (ownershipStatus != Status.TransferInProgress) {\n            revert TransferNotInProgress();\n        }\n\n        if (msg.sender != potentialOwner) {\n            revert WrongPotentialOwner();\n        }\n\n        owner = msg.sender;\n        delete ownershipStatus;\n        delete potentialOwner;\n\n        emit NewOwner(msg.sender);\n    }\n\n    /**\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\n     * @param newPotentialOwner New potential owner address\n     */\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.TransferInProgress;\n        potentialOwner = newPotentialOwner;\n\n        /**\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\n         *      We don't have to SLOAD the owner again.\n         */\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\n    }\n\n    /**\n     * @notice This function is used to initiate the ownership renouncement.\n     */\n    function initiateOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.RenouncementInProgress;\n\n        emit InitiateOwnershipRenouncement();\n    }\n\n    function _onlyOwner() private view {\n        if (msg.sender != owner) revert NotOwner();\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the call recipient is not a contract.\n */\nerror NotAContract();\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the ETH transfer fails.\n */\nerror ETHTransferFail();\n\n/**\n * @notice It is emitted if the ERC20 approval fails.\n */\nerror ERC20ApprovalFail();\n\n/**\n * @notice It is emitted if the ERC20 transfer fails.\n */\nerror ERC20TransferFail();\n\n/**\n * @notice It is emitted if the ERC20 transferFrom fails.\n */\nerror ERC20TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC721 transferFrom fails.\n */\nerror ERC721TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\n */\nerror ERC1155SafeTransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\n */\nerror ERC1155SafeBatchTransferFromFail();\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/IOwnableTwoSteps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title IOwnableTwoSteps\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface IOwnableTwoSteps {\n    /**\n     * @notice This enum keeps track of the ownership status.\n     * @param NoOngoingTransfer The default status when the owner is set\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\n     */\n    enum Status {\n        NoOngoingTransfer,\n        TransferInProgress,\n        RenouncementInProgress\n    }\n\n    /**\n     * @notice This is returned when there is no transfer of ownership in progress.\n     */\n    error NoOngoingTransferInProgress();\n\n    /**\n     * @notice This is returned when the caller is not the owner.\n     */\n    error NotOwner();\n\n    /**\n     * @notice This is returned when there is no renouncement in progress but\n     *         the owner tries to validate the ownership renouncement.\n     */\n    error RenouncementNotInProgress();\n\n    /**\n     * @notice This is returned when the transfer is already in progress but the owner tries\n     *         initiate a new ownership transfer.\n     */\n    error TransferAlreadyInProgress();\n\n    /**\n     * @notice This is returned when there is no ownership transfer in progress but the\n     *         ownership change tries to be approved.\n     */\n    error TransferNotInProgress();\n\n    /**\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\n     *         a caller that is not the potential owner.\n     */\n    error WrongPotentialOwner();\n\n    /**\n     * @notice This is emitted if the ownership transfer is cancelled.\n     */\n    event CancelOwnershipTransfer();\n\n    /**\n     * @notice This is emitted if the ownership renouncement is initiated.\n     */\n    event InitiateOwnershipRenouncement();\n\n    /**\n     * @notice This is emitted if the ownership transfer is initiated.\n     * @param previousOwner Previous/current owner\n     * @param potentialOwner Potential/future owner\n     */\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\n\n    /**\n     * @notice This is emitted when there is a new owner.\n     */\n    event NewOwner(address newOwner);\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC1155 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC721 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC1155Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC1155} from \"../interfaces/generic/IERC1155.sol\";\n\n// Errors\nimport {ERC1155SafeTransferFromFail, ERC1155SafeBatchTransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC1155Transfer\n * @notice This contract contains low-level calls to transfer ERC1155 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC1155Transfer {\n    /**\n     * @notice Execute ERC1155 safeTransferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenId tokenId to transfer\n     * @param amount Amount to transfer\n     */\n    function _executeERC1155SafeTransferFrom(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, amount, \"\")));\n\n        if (!status) {\n            revert ERC1155SafeTransferFromFail();\n        }\n    }\n\n    /**\n     * @notice Execute ERC1155 safeBatchTransferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenIds Array of tokenIds to transfer\n     * @param amounts Array of amounts to transfer\n     */\n    function _executeERC1155SafeBatchTransferFrom(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(\n            abi.encodeCall(IERC1155.safeBatchTransferFrom, (from, to, tokenIds, amounts, \"\"))\n        );\n\n        if (!status) {\n            revert ERC1155SafeBatchTransferFromFail();\n        }\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC721} from \"../interfaces/generic/IERC721.sol\";\n\n// Errors\nimport {ERC721TransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC721Transfer\n * @notice This contract contains low-level calls to transfer ERC721 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC721Transfer {\n    /**\n     * @notice Execute ERC721 transferFrom\n     * @param collection Address of the collection\n     * @param from Address of the sender\n     * @param to Address of the recipient\n     * @param tokenId tokenId to transfer\n     */\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\n        if (collection.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\n\n        if (!status) {\n            revert ERC721TransferFromFail();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/=node_modules/@chainlink/",
      "@ensdomains/=node_modules/@ensdomains/",
      "@eth-optimism/=node_modules/@eth-optimism/",
      "@looksrare/=node_modules/@looksrare/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "eth-gas-reporter/=node_modules/eth-gas-reporter/",
      "forge-std/=lib/forge-std/src/",
      "hardhat/=node_modules/hardhat/",
      "murky/=lib/murky/src/",
      "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/",
      "solmate/=node_modules/solmate/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 888888
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}