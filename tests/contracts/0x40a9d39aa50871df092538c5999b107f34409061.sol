{{
  "language": "Solidity",
  "sources": {
    "contracts/core/proxy/infiniteProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../infiniteProxy/proxy.sol\";\n\ncontract InstaVault is Proxy {\n    constructor(address admin_, address dummyImplementation_)\n        Proxy(admin_, dummyImplementation_)\n    {}\n}"
    },
    "contracts/infiniteProxy/proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./events.sol\";\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`.\n */\ncontract Internals is Events {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct SigsSlot {\n        bytes4[] value;\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Storage slot with the address of the current dummy-implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _DUMMY_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the storage slot which stores the sigs array set for the implementation.\n     */\n    function _getImplSigsSlot(address implementation_)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\"eip1967.proxy.implementation\", implementation_)\n            );\n    }\n\n    /**\n     * @dev Returns the storage slot which stores the implementation address for the function sig.\n     */\n    function _getSigsImplSlot(bytes4 sig_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"eip1967.proxy.implementation\", sig_));\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot_)\n        internal\n        pure\n        returns (AddressSlot storage _r)\n    {\n        assembly {\n            _r.slot := slot_\n        }\n    }\n\n    /**\n     * @dev Returns an `SigsSlot` with member `value` located at `slot`.\n     */\n    function getSigsSlot(bytes32 slot_)\n        internal\n        pure\n        returns (SigsSlot storage _r)\n    {\n        assembly {\n            _r.slot := slot_\n        }\n    }\n\n    /**\n     * @dev Sets new implementation and adds mapping from implementation to sigs and sig to implementation.\n     */\n    function _setImplementationSigs(\n        address implementation_,\n        bytes4[] memory sigs_\n    ) internal {\n        require(sigs_.length != 0, \"no-sigs\");\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\n        bytes4[] memory sigsCheck_ = getSigsSlot(slot_).value;\n        require(sigsCheck_.length == 0, \"implementation-already-exist\");\n        for (uint256 i = 0; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = _getSigsImplSlot(sigs_[i]);\n            require(\n                getAddressSlot(sigSlot_).value == address(0),\n                \"sig-already-exist\"\n            );\n            getAddressSlot(sigSlot_).value = implementation_;\n        }\n        getSigsSlot(slot_).value = sigs_;\n        emit setImplementationLog(implementation_, sigs_);\n    }\n\n    /**\n     * @dev Removes implementation and the mappings corresponding to it.\n     */\n    function _removeImplementationSigs(address implementation_) internal {\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\n        bytes4[] memory sigs_ = getSigsSlot(slot_).value;\n        require(sigs_.length != 0, \"implementation-not-exist\");\n        for (uint256 i = 0; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = _getSigsImplSlot(sigs_[i]);\n            delete getAddressSlot(sigSlot_).value;\n        }\n        delete getSigsSlot(slot_).value;\n        emit removeImplementationLog(implementation_);\n    }\n\n    /**\n     * @dev Returns bytes4[] sigs from implementation address. If implemenatation is not registered then returns empty array.\n     */\n    function _getImplementationSigs(address implementation_)\n        internal\n        view\n        returns (bytes4[] memory)\n    {\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\n        return getSigsSlot(slot_).value;\n    }\n\n    /**\n     * @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n     */\n    function _getSigImplementation(bytes4 sig_)\n        internal\n        view\n        returns (address implementation_)\n    {\n        bytes32 slot_ = _getSigsImplSlot(sig_);\n        return getAddressSlot(slot_).value;\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Returns the current dummy-implementation.\n     */\n    function _getDummyImplementation() internal view returns (address) {\n        return getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin_) internal {\n        address oldAdmin_ = _getAdmin();\n        require(\n            newAdmin_ != address(0),\n            \"ERC1967: new admin is the zero address\"\n        );\n        getAddressSlot(_ADMIN_SLOT).value = newAdmin_;\n        emit setAdminLog(oldAdmin_, newAdmin_);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setDummyImplementation(address newDummyImplementation_) internal {\n        address oldDummyImplementation_ = _getDummyImplementation();\n        getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT)\n            .value = newDummyImplementation_;\n        emit setDummyImplementationLog(\n            oldDummyImplementation_,\n            newDummyImplementation_\n        );\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation_) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(\n                gas(),\n                implementation_,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Delegates the current call to the address returned by Implementations registry.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback(bytes4 sig_) internal {\n        address implementation_ = _getSigImplementation(sig_);\n        require(\n            implementation_ != address(0),\n            \"Liquidity: Not able to find implementation_\"\n        );\n        _delegate(implementation_);\n    }\n}\n\ncontract AdminStuff is Internals {\n    /**\n     * @dev Only admin gaurd.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == _getAdmin(), \"not-the-admin\");\n        _;\n    }\n\n    /**\n     * @dev Sets new admin.\n     */\n    function setAdmin(address newAdmin_) external onlyAdmin {\n        _setAdmin(newAdmin_);\n    }\n\n    /**\n     * @dev Sets new dummy-implementation.\n     */\n    function setDummyImplementation(address newDummyImplementation_)\n        external\n        onlyAdmin\n    {\n        _setDummyImplementation(newDummyImplementation_);\n    }\n\n    /**\n     * @dev Adds new implementation address.\n     */\n    function addImplementation(address implementation_, bytes4[] calldata sigs_)\n        external\n        onlyAdmin\n    {\n        _setImplementationSigs(implementation_, sigs_);\n    }\n\n    /**\n     * @dev Removes an existing implementation address.\n     */\n    function removeImplementation(address implementation_) external onlyAdmin {\n        _removeImplementationSigs(implementation_);\n    }\n\n    constructor(address admin_, address dummyImplementation_) {\n        _setAdmin(admin_);\n        _setDummyImplementation(dummyImplementation_);\n    }\n}\n\nabstract contract Proxy is AdminStuff {\n    constructor(address admin_, address dummyImplementation_)\n        AdminStuff(admin_, dummyImplementation_)\n    {}\n\n    /**\n     * @dev Returns admin's address.\n     */\n    function getAdmin() external view returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Returns dummy-implementations's address.\n     */\n    function getDummyImplementation() external view returns (address) {\n        return _getDummyImplementation();\n    }\n\n    /**\n     * @dev Returns bytes4[] sigs from implementation address If not registered then returns empty array.\n     */\n    function getImplementationSigs(address impl_)\n        external\n        view\n        returns (bytes4[] memory)\n    {\n        return _getImplementationSigs(impl_);\n    }\n\n    /**\n     * @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n     */\n    function getSigsImplementation(bytes4 sig_)\n        external\n        view\n        returns (address)\n    {\n        return _getSigImplementation(sig_);\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\n     */\n    fallback() external payable {\n        _fallback(msg.sig);\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\n     */\n    receive() external payable {\n        if (msg.sig != 0x00000000) {\n            _fallback(msg.sig);\n        }\n    }\n}"
    },
    "contracts/infiniteProxy/events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Events {\n    event setAdminLog(address oldAdmin_, address newAdmin_);\n\n    event setDummyImplementationLog(\n        address oldDummyImplementation_,\n        address newDummyImplementation_\n    );\n\n    event setImplementationLog(address implementation_, bytes4[] sigs_);\n\n    event removeImplementationLog(address implementation_);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}