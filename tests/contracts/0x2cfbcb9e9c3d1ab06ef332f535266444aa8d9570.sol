{{
  "language": "Solidity",
  "sources": {
    "contracts/FrankenMonsters.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n ______ _____            _   _ _  ________ _   _ __  __  ____  _   _  _____ _______ ______ _____   _____ \r\n|  ____|  __ \\     /\\   | \\ | | |/ /  ____| \\ | |  \\/  |/ __ \\| \\ | |/ ____|__   __|  ____|  __ \\ / ____|\r\n| |__  | |__) |   /  \\  |  \\| | ' /| |__  |  \\| | \\  / | |  | |  \\| | (___    | |  | |__  | |__) | (___  \r\n|  __| |  _  /   / /\\ \\ | . ` |  < |  __| | . ` | |\\/| | |  | | . ` |\\___ \\   | |  |  __| |  _  / \\___ \\ \r\n| |    | | \\ \\  / ____ \\| |\\  | . \\| |____| |\\  | |  | | |__| | |\\  |____) |  | |  | |____| | \\ \\ ____) |\r\n|_|    |_|  \\_\\/_/    \\_\\_| \\_|_|\\_\\______|_| \\_|_|  |_|\\____/|_| \\_|_____/   |_|  |______|_|  \\_\\_____/ \r\n                                                                                                         \r\n */\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport { ERC721 } from \"solmate/src/tokens/ERC721.sol\";\r\nimport { Owned } from 'solmate/src/auth/Owned.sol';\r\nimport { LibString } from 'solmate/src/utils/LibString.sol';\r\nimport { IFrankenPunks } from \"./IFrankenPunks.sol\";\r\nimport \"./FrankenMonstersErrors.sol\";\r\n\r\n/**\r\n * @title FrankenMonsters contract\r\n * @author New Fundamentals, LLC\r\n *\r\n * @notice 10,000 NFT collection to support the original 10,000 NFT collection of 3D FrankenPunks\r\n */\r\ncontract FrankenMonsters is ERC721, Owned {\r\n    using LibString for uint256;\r\n\r\n    event SetContractURI(string contractURI);\r\n    event SetBaseURI(string baseTokenURI);\r\n    event SetIsRevealed(bool isRevealed);\r\n    event SetRoyaltyInfo(address royaltyRecipient, uint256 royaltyAmountNumerator);\r\n    event SetFrankenPunksContractAddress(address frankenPunksContractAddress);\r\n    event Withdrew(uint256 balance);\r\n\r\n    bytes4 private constant INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n    uint16 public constant STARTING_INDEX = 10000;\r\n    uint8 public constant LEGENDARY_SUPPLY = 10;\r\n    uint16 public constant MAX_SUPPLY = 10000 + LEGENDARY_SUPPLY;\r\n    uint64 private constant ROYALTY_AMOUNT_DENOMINATOR = 1e18;\r\n    \r\n    bool internal _isRevealed;\r\n\r\n    uint16 internal _totalSupply;\r\n\r\n    string internal _contractURI;\r\n    string internal _baseTokenURI;\r\n\r\n    address internal _royaltyRecipient;\r\n    uint256 internal _royaltyAmountNumerator;\r\n\r\n    address internal _frankenPunksContractAddress;\r\n\r\n    /**\r\n     * @param baseTokenURI A string you want the token URI to be set to, will be used as placeholder URI until reveal\r\n     * @param frankenPunksContractAddress The contract address to access FrankenPunks ownership from\r\n     */\r\n    constructor(\r\n        string memory baseTokenURI,\r\n        address frankenPunksContractAddress\r\n    ) ERC721(\"FrankenMonsters\", \"FM\") Owned(msg.sender) {\r\n        _baseTokenURI = baseTokenURI;\r\n        _frankenPunksContractAddress = frankenPunksContractAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Define all interfaces this contract supports. Make sure to always leave the super call at the end.\r\n     * \r\n     * @notice Check support for a specific interface.\r\n     * \r\n     * @param interfaceId An interface ID in byte4 to check support for.\r\n     * \r\n     * @return isSupported A boolean defining support for the interface ID.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return (\r\n            interfaceId == INTERFACE_ID_ERC2981 ||\r\n            super.supportsInterface(interfaceId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the contract's metadata.\r\n     * \r\n     * @return contractURI A string that defines the contract's URI to obtain the contract's metadata.\r\n     */\r\n    function contractURI() external view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total current supply of tokens.\r\n     * \r\n     * @return totalSupply A number of the current supply of tokens within this contract.\r\n     */\r\n    function totalSupply() external view returns (uint16) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a token's metadata\r\n     * \r\n     * @param tokenId The ID of the token you wish to get's metadata\r\n     * \r\n     * @return tokenURI A string that defines the token's URI to obtain the token's metadata.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        if (_ownerOf[tokenId] == address(0)) {\r\n            revert NonExistentToken(tokenId);\r\n        }\r\n\r\n        string memory baseURI = _baseTokenURI;\r\n\r\n        if (!_isRevealed) {\r\n            return baseURI;\r\n        }\r\n\r\n        return string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Adapted from Nanopass: https://etherscan.io/address/0xf54cc94f1f2f5de012b6aa51f1e7ebdc43ef5afc#code\r\n     * \r\n     * @notice Query tokens owned by an address, in a given range.\r\n     *\r\n     * @param owner An address you wish to query for.\r\n     * @param startIndex The starting index of the range you wish to query through.\r\n     * @param endIndex The ending index of the range you wish to query through.\r\n     * \r\n     * @return tokenIds An array of token IDs within the range provided, that the address owns.\r\n     */\r\n    function tokensOfOwner(address owner, uint16 startIndex, uint16 endIndex) external view returns(uint16[] memory) {\r\n        return _findTokensOfOwner(owner, startIndex, endIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Adapted from Nanopass: https://etherscan.io/address/0xf54cc94f1f2f5de012b6aa51f1e7ebdc43ef5afc#code\r\n     * \r\n     * @notice Query all tokens owned by an address.\r\n     *\r\n     * @param owner An address you wish to query for.\r\n     * \r\n     * @return tokenIds An array of token IDs that the address owns.\r\n     */\r\n    function walletOfOwner(address owner) external view returns(uint16[] memory) {\r\n        return _findTokensOfOwner(owner, _getMinTokenID(), _getMaxTokenID() + 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Implements ERC-2981 royalty info interface.\r\n     * \r\n     * @param salePrice The sale price of the token.\r\n     * \r\n     * @return royaltyInfo The royalty info consisting of (the address to pay, the amount to be paid).\r\n     */\r\n    function royaltyInfo(uint256 /* tokenId */, uint256 salePrice) external view returns (address, uint256) {\r\n        return (_royaltyRecipient, salePrice * _royaltyAmountNumerator / ROYALTY_AMOUNT_DENOMINATOR);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set the contract URI. This is used to set metadata for thid-parties.\r\n     * \r\n     * @param newContractURI A string you want the contract URI to be set to.\r\n     */\r\n    function setContractURI(string calldata newContractURI) external onlyOwner {\r\n        _contractURI = newContractURI;\r\n        emit SetContractURI(newContractURI);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set the base token URI. This is used in #tokenURI after reveal to compute the final URI of a token.\r\n     * \r\n     * @param baseTokenURI A string you want the base token URI to be set to.\r\n     */\r\n    function setBaseURI(string calldata baseTokenURI) external onlyOwner {\r\n        _baseTokenURI = baseTokenURI;\r\n        emit SetBaseURI(baseTokenURI);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set if the tokens are revealed or not.\r\n     * \r\n     * @param isRevealed A boolean value used to set if the contract should reveal the tokens or not.\r\n     * @param baseTokenURI A string you want the base token URI to be set to.\r\n     */\r\n    function setIsRevealed(bool isRevealed, string calldata baseTokenURI) external onlyOwner {\r\n        _baseTokenURI = baseTokenURI;\r\n        _isRevealed = isRevealed;\r\n        emit SetBaseURI(baseTokenURI);\r\n        emit SetIsRevealed(isRevealed);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set royalty information.\r\n     * \r\n     * @param royaltyRecipient An address to a wallet or contract who should get paid the royalties.\r\n     * @param royaltyAmountNumerator A uint256 number used to calculate royalty amount.\r\n     */\r\n    function setRoyaltyInfo(address royaltyRecipient, uint256 royaltyAmountNumerator) external onlyOwner {\r\n        _royaltyRecipient = royaltyRecipient;\r\n        _royaltyAmountNumerator = royaltyAmountNumerator;\r\n        emit SetRoyaltyInfo(royaltyRecipient, royaltyAmountNumerator);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set the FrankenPunks contrat address\r\n     * \r\n     * @param frankenPunksContractAddress The FrankenPunks contract address\r\n     */\r\n    function setFrankenPunksContractAddress(address frankenPunksContractAddress) external onlyOwner {\r\n        _frankenPunksContractAddress = frankenPunksContractAddress;\r\n        emit SetFrankenPunksContractAddress(frankenPunksContractAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to mint tokens and to airdrop all tokens to existing FrankenPunks holders.\r\n     * \r\n     * @param numberToMint The number of tokens to mint\r\n     * @param airdropEnabled A flag used to enable aidrops to FrankenPunks holders\r\n     */\r\n    function mintTokens(uint16 numberToMint, bool airdropEnabled) external onlyOwner {\r\n        if (_totalSupply == MAX_SUPPLY) {\r\n            revert AllTokensMinted();\r\n        }\r\n\r\n        if (numberToMint == 0) {\r\n            revert MintZeroQuantity();\r\n        }\r\n\r\n        if (_totalSupply + numberToMint > MAX_SUPPLY) {\r\n            revert  MintOverMaxSupply(numberToMint, MAX_SUPPLY - _totalSupply);   \r\n        }\r\n\r\n        IFrankenPunks frankenPunks = IFrankenPunks(_frankenPunksContractAddress);\r\n\r\n        for (uint16 i = _totalSupply; i < _totalSupply + numberToMint; i++) {\r\n            uint16 tokenId = STARTING_INDEX + i;\r\n            address receiver = msg.sender;\r\n\r\n            if (i < MAX_SUPPLY - LEGENDARY_SUPPLY && airdropEnabled) {\r\n                try frankenPunks.ownerOf(i) returns (address frankenPunksOwner) {\r\n                    receiver = frankenPunksOwner;\r\n                } catch (bytes memory) {}\r\n            }\r\n\r\n            _mint(receiver, tokenId);\r\n        }\r\n\r\n        _totalSupply = _totalSupply + numberToMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the contract owner to withdraw the balance of the contract.\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        payable(msg.sender).transfer(balance);\r\n        emit Withdrew(balance);\r\n    }\r\n\r\n    /**\r\n     * @dev We don't intend on external folks sending payments to this contract.\r\n     * \r\n     * @notice Allow the contract to receive a transaction.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Takes an address and an index range and looks to return all owned token IDs.\r\n     * \r\n     * @param owner An address you wish to query for.\r\n     * @param startIndex The starting index of the range you wish to query through.\r\n     * @param endIndex The ending index of the range you wish to query through.\r\n     * \r\n     * @return tokenIds An array of token IDs within the range provided, that the address owns.\r\n     */\r\n    function _findTokensOfOwner(address owner, uint16 startIndex, uint16 endIndex) internal view returns(uint16[] memory) {\r\n        if (_totalSupply == 0) {\r\n            revert SearchNotPossible();\r\n        }\r\n\r\n        uint256 maxTokenID = _getMaxTokenID();\r\n\r\n        if (endIndex < startIndex || startIndex > maxTokenID || endIndex > maxTokenID + 1) {\r\n            revert SearchOutOfRange(startIndex, endIndex, _getMinTokenID(), maxTokenID);\r\n        }\r\n\r\n        uint256 tokenCount = balanceOf(owner);\r\n        uint256 rangeCount = endIndex - startIndex;\r\n        uint256 maxArraySize = rangeCount < tokenCount ? rangeCount : tokenCount;\r\n        uint256 ownerIndex = 0;\r\n\r\n        uint16[] memory ownerTokens = new uint16[](maxArraySize);\r\n        \r\n        for (uint16 tokenId = startIndex; tokenId < endIndex; tokenId++) {\r\n            if (ownerIndex == maxArraySize) break;\r\n\r\n            if (ownerOf(tokenId) == owner) {\r\n                ownerTokens[ownerIndex] = tokenId;\r\n                ownerIndex++;\r\n            }\r\n        }\r\n\r\n        return ownerTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest token ID.\r\n     * \r\n     * @return minTokenId The smallest token ID.\r\n     */\r\n    function _getMinTokenID() internal view returns(uint16) {\r\n        if (_totalSupply == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return STARTING_INDEX;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest token ID.\r\n     * \r\n     * @return minTokenId The largest token ID.\r\n     */\r\n    function _getMaxTokenID() internal view returns(uint16) {\r\n        if (_totalSupply == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return STARTING_INDEX + _totalSupply - 1;\r\n    }\r\n}\r\n"
    },
    "contracts/IFrankenPunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IFrankenPunks {\r\n    function ownerOf(uint256 tokenId) external view returns(address);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n}"
    },
    "contracts/FrankenMonstersErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.17;\r\n\r\nerror NonExistentToken(uint256 tokenId);\r\nerror MintZeroQuantity();\r\nerror MintOverMaxSupply(uint16 numberToMint, uint16 remainingSupply);\r\nerror AllTokensMinted();\r\nerror SearchNotPossible();\r\nerror SearchOutOfRange(uint16 startIndex, uint16 endIndex, uint16 minTokenIndex, uint256 maxTokenIndex);"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "solmate/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Efficient library for creating string representations of integers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    function toString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes\n            // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the\n            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.\n            let newFreeMemoryPointer := add(mload(0x40), 160)\n\n            // Update the free memory pointer to avoid overriding our string.\n            mstore(0x40, newFreeMemoryPointer)\n\n            // Assign str to the end of the zone of newly allocated memory.\n            str := sub(newFreeMemoryPointer, 32)\n\n            // Clean the last word of memory it may not be overwritten.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                // Move the pointer 1 byte to the left.\n                str := sub(str, 1)\n\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n\n                // Keep dividing temp until zero.\n                temp := div(temp, 10)\n\n                 // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute and cache the final total length of the string.\n            let length := sub(end, str)\n\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 32)\n\n            // Store the string's length at the start of memory allocated for our string.\n            mstore(str, length)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}