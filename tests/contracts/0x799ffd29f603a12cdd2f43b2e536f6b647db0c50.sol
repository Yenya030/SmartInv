{{
  "language": "Solidity",
  "sources": {
    "src/Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"openzeppelin/token/ERC721/IERC721Receiver.sol\";\nimport \"openzeppelin/token/ERC1155/IERC1155.sol\";\n\nerror MustOwnKey();\nerror JoinMustBeClosed();\nerror JoinMustBeOpen();\nerror OnlyFrogOwnerMayJoin();\nerror IncorrectPaymentAmount();\nerror OneFrogMustRemainLiving();\nerror AmountMustBeLessThan256();\nerror OnlyFrogOwnerOrOperatorMayClaim();\nerror NftMustBeKingFrog();\nerror OnlyOperatorMayPerformThisAction();\nerror FrogHasAlreadyJoined(uint256 id);\nerror TransferFailed();\nerror NoPendingWithdrawal();\nerror ExceededMaxBatchLimit();\n\ncontract Game is IERC721Receiver {\n    // Associated contracts and addresses ///\n    // The game operator (can control join state)\n    address public operator;\n    // The KingFrogs contract\n    address public kingFrogAddress;\n    // The DuckGod Clave contract\n    address public keyAddress;\n\n    /// Constants ///\n    // @notice the item id also corresponds to the amount of lives it gives\n    uint256 public constant WOOD = 1;\n    uint256 public constant GOLD = 2;\n    uint256 public constant JADE = 3;\n    uint256 constant MAX_BATCH_SIZE = 25;\n\n    /// Game state ///\n    // Which item each frog has equipped\n    mapping(uint256 => uint256) public frogsToItem;\n    // Whether or not new players can join the game\n    bool public joinAllowed = true;\n    // The price (in wei) to join\n    uint256 public joinPrice;\n    // All frogs that have been staked\n    mapping(uint256 => address) public frogsToOwner;\n    // All frogs that have joined\n    mapping(uint256 => bool) public frogsJoined;\n    // All the frogs that are alive\n    uint256[] public frogsAlive;\n    // The lives reamining for each frog\n    mapping(uint256 => uint256) public livesRemaining;\n    // The amount of ETH the winner gets\n    mapping(address => uint256) public pendingWithdrawals;\n\n    /// Events ///\n    event EquipmentPurchased(\n        address indexed user,\n        uint256 indexed item,\n        uint256 indexed frogId\n    );\n    event FrogStaked(uint256 frogId, address indexed owner);\n    event FrogJoined(uint256 frogId, address indexed owner);\n    event Attack(uint256 amount, uint256 killed);\n\n    // @param _operator The address of the operator\n    // @param _kingFrogAddress The address of the KingFrogs contract\n    // @param _joinPrice The price (in wei) to join the game\n    // @param _keyAddress The address of the DuckGod Clave contract\n    constructor(\n        address _operator,\n        address _kingFrogAddress,\n        address _keyAddress,\n        uint256 _joinPrice\n    ) {\n        operator = _operator;\n        kingFrogAddress = _kingFrogAddress;\n        keyAddress = _keyAddress;\n        joinPrice = _joinPrice;\n    }\n\n    // @dev purchases equipment for the battel\n    // @notice you must first transfer your KingFrog to this contract\n    // @notice you must own a Duck God Clave to purchase equipment\n    // @notice requires the purchaser to send the correct amount of ether\n    // @notice requires join to be open\n    // @param item the item id (see items above)\n    // @param frogId the id of the KingFrog\n    function purchaseEquipment(uint256 item, uint256 frogId) external payable {\n        // check if the user owns a key\n        if (IERC1155(keyAddress).balanceOf(msg.sender, 0) == 0) {\n            revert MustOwnKey();\n        }\n        // check if join is open\n        if (!joinAllowed) {\n            revert JoinMustBeOpen();\n        }\n        // check if the user owns the frog\n        if (frogsToOwner[frogId] != msg.sender) {\n            revert OnlyFrogOwnerMayJoin();\n        }\n\n        // user can only upgrade items\n        require(frogsToItem[frogId] < item, \"you may only upgrade equipment\");\n\n        // charge the join price if the user hasn't joined yet\n        uint256 joinFee;\n        if (!frogsJoined[frogId]) {\n            joinFee = joinPrice;\n        }\n\n        if (item == WOOD) {\n            require(\n                msg.value == joinFee + 0.01 ether,\n                \"wood equipment costs 0.01 ether\"\n            );\n        } else if (item == GOLD) {\n            require(\n                msg.value == joinFee + 0.025 ether,\n                \"gold equipment costs 0.025 ether\"\n            );\n        } else if (item == JADE) {\n            require(\n                msg.value == joinFee + 0.05 ether,\n                \"jade equipment costs 0.05 ether\"\n            );\n        } else {\n            revert(\"invalid item\");\n        }\n\n        emit EquipmentPurchased(msg.sender, item, frogId);\n        frogsToItem[frogId] = item;\n\n        if (!frogsJoined[frogId]) {\n            _join(frogId);\n        }\n    }\n\n    // @param _joinAllowed Whether or not to allow new players to join\n    function setJoinOpen(bool _joinAllowed) public onlyOperator {\n        joinAllowed = _joinAllowed;\n    }\n\n    // @param _joinPrice The price (in wei) to join the game\n    function setJoinPrice(uint256 _joinPrice) public onlyOperator {\n        joinPrice = _joinPrice;\n    }\n\n    // @param frogId The id of the frog to join\n    // @notice requires join to be open\n    // @notice requires the frog to be owned by the sender\n    // @notice requires the sender to send the correct amount of ether\n    // @notice requires the sender to own a Duck God Clave\n    function join(uint256 frogId) public payable {\n        if (!joinAllowed) {\n            revert JoinMustBeOpen();\n        }\n        if (frogsToOwner[frogId] != msg.sender) {\n            revert OnlyFrogOwnerMayJoin();\n        }\n        if (msg.value != joinPrice) {\n            revert IncorrectPaymentAmount();\n        }\n        if (IERC1155(keyAddress).balanceOf(msg.sender, 0) == 0) {\n            revert MustOwnKey();\n        }\n        _join(frogId);\n    }\n\n    // @param frogIds The ids of the frogs to join\n    // @notice requires join to be open\n    // @notice requires the sender to own a Duck God Clave\n    // @notice requires the number of frogs to be less than the max batch size\n    // @notice requires the sender to send the correct amount of ether\n    // @notice requires the sender to own all the frogs\n    function batchJoin(uint256[] calldata frogIds) public payable {\n        if (!joinAllowed) {\n            revert JoinMustBeOpen();\n        }\n        if (IERC1155(keyAddress).balanceOf(msg.sender, 0) == 0) {\n            revert MustOwnKey();\n        }\n        if (frogIds.length > MAX_BATCH_SIZE) {\n            revert ExceededMaxBatchLimit();\n        }\n        if (msg.value / joinPrice != frogIds.length) {\n            revert IncorrectPaymentAmount();\n        }\n        for (uint256 i; i < frogIds.length; ) {\n            if (frogsToOwner[frogIds[i]] != msg.sender) {\n                revert OnlyFrogOwnerMayJoin();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        for (uint256 i; i < frogIds.length; ) {\n            _join(frogIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    // @param frogId The id of the frog to get the lives remaining for\n    function getLivesRemaining(uint256 frogId) public view returns (uint256) {\n        return livesRemaining[frogId];\n    }\n\n    // @notice The operator can choose to attack the game while joining is\n    //         closed, reducing the lives of random frogs until there is only\n    //         one frog remaining\n    // @notice Burns frogs that have no lives remaining\n    // @param amount The number of frogs to attack (must be less than 256)\n    function attack(uint256 amount) public onlyOperator {\n        if (joinAllowed) {\n            revert JoinMustBeClosed();\n        }\n        if (amount >= frogsAlive.length) {\n            revert OneFrogMustRemainLiving();\n        }\n        if (amount >= 256) {\n            revert AmountMustBeLessThan256();\n        }\n\n        uint256 killed;\n\n        for (uint256 i; i < amount; ) {\n            uint256 randomIndex = uint256(blockhash(block.number - i)) %\n                frogsAlive.length;\n            uint256 frogId = frogsAlive[randomIndex];\n            uint256 newLivesRemaining = getLivesRemaining(frogId) - 1;\n\n            if (newLivesRemaining == 0) {\n                frogsAlive[randomIndex] = frogsAlive[frogsAlive.length - 1];\n                frogsAlive.pop();\n\n                // burn frog\n                (bool success, ) = kingFrogAddress.call(\n                    abi.encodeWithSignature(\"burn(uint256)\", frogId)\n                );\n\n                killed += success ? 1 : 0;\n            } else {\n                livesRemaining[frogId] = newLivesRemaining;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit Attack(amount, killed);\n    }\n\n    // @notice 70% of the contract balance is sent to the winner, 30% is sent\n    //         to the operator\n    function claim() public {\n        if (frogsAlive.length != 1) {\n            revert OneFrogMustRemainLiving();\n        }\n        if (\n            frogsToOwner[frogsAlive[0]] != msg.sender && msg.sender != operator\n        ) {\n            revert OnlyFrogOwnerOrOperatorMayClaim();\n        }\n\n        // allocate rewards\n        uint256 prize = (address(this).balance * 7) / 10;\n        uint256 operatorReward = address(this).balance - prize;\n\n        pendingWithdrawals[msg.sender] += prize;\n        pendingWithdrawals[operator] += operatorReward;\n\n        // send nft back to winner\n        (bool success, ) = kingFrogAddress.call(\n            abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256)\",\n                address(this),\n                msg.sender,\n                frogsAlive[0]\n            )\n        );\n        if (!success) {\n            revert TransferFailed();\n        }\n    }\n\n    // @notice Withdraws the sender's pending refund\n    function withdraw() public {\n        uint256 amount = pendingWithdrawals[msg.sender];\n        if (amount == 0) {\n            revert NoPendingWithdrawal();\n        }\n\n        // Zero the pending refund before sending\n        pendingWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n\n    // @notice Sending a KingFrog to this contract will stake it\n    function onERC721Received(\n        address,\n        address from,\n        uint256 id,\n        bytes calldata\n    ) external override returns (bytes4) {\n        if (msg.sender != kingFrogAddress) {\n            revert NftMustBeKingFrog();\n        }\n        frogsToOwner[id] = from;\n        emit FrogStaked(id, from);\n        return this.onERC721Received.selector;\n    }\n\n    /// Internal functions ///\n\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert OnlyOperatorMayPerformThisAction();\n        }\n        _;\n    }\n\n    function _join(uint256 frogId) private {\n        if (frogsJoined[frogId]) {\n            revert FrogHasAlreadyJoined(frogId);\n        }\n        frogsJoined[frogId] = true;\n        frogsAlive.push(frogId);\n        livesRemaining[frogId] = frogsToItem[frogId] + 1;\n        emit FrogJoined(frogId, frogsToOwner[frogId]);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/=lib/contracts/node_modules/@chainlink/contracts/src/v0.8/dev/vendor/@arbitrum/nitro-contracts/src/",
      "@chainlink/contracts/src/=lib/contracts/node_modules/@chainlink/contracts/src/",
      "@ds-test/=lib/contracts/lib/ds-test/src/",
      "@openzeppelin/=lib/contracts/node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@std/=lib/contracts/lib/forge-std/src/",
      "@thirdweb/=lib/contracts/contracts/",
      "contracts/=lib/contracts/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "dynamic-contracts/=lib/contracts/lib/dynamic-contracts/src/",
      "erc721a-upgradeable/=lib/contracts/node_modules/erc721a-upgradeable/",
      "erc721a/=lib/contracts/node_modules/erc721a/",
      "forge-std/=lib/forge-std/src/",
      "hardhat/=lib/contracts/node_modules/hardhat/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin/=lib/openzeppelin-contracts/contracts/",
      "supducks/=lib/Sup-Ducks-Upgradable/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}