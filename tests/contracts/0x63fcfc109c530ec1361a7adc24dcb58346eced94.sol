{{
  "language": "Solidity",
  "sources": {
    "contracts/NFTvGenesisBox.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\ninterface IERC721 is IERC165 {\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n\ninterface IERC721Receiver {\n   \n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n\ninterface IERC721Metadata is IERC721 {\n   \n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    function toString(uint256 value) internal pure returns (string memory) {\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n\nabstract contract ERC165 is IERC165 {\n  \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI(); \n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        _beforeTokenTransfer(address(0), to, tokenId);\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\ninterface IERC721Enumerable is IERC721 {\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n    uint256[] private _allTokens;\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n       \n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \n            _ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n  \n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \n        _allTokensIndex[lastTokenId] = tokenIndex; \n\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\ninterface IAccessControl {\n\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n\nlibrary MerkleProof {\n    \n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    \n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n\ncontract NFTvGenesisBox is ERC721Enumerable, AccessControl {\n\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant SUBADMIN_ROLE = keccak256(\"SUBADMIN_ROLE\");\n    string public baseURI = \"\";\n    address public multisig; // address to withdraw\n    bool public isPaused;\n    uint256 public id; // id of the next token minted\n\n    // MAINNET SETTINGS\n    uint256 public maxSupply = 9999; // PLEASE UNCOMMENT THIS LINE BEFORE MAINNET LAUNCH\n\n    uint256 public allowedByRoundByAddress = 2;\n    uint256 public teamRound = 3;\n    uint256 public publicRound = 4;\n\n    mapping(uint256=>bytes32) public root; // should be set each round\n    mapping(uint256=>uint256) public tokenPrice; // nft price to set by round\n    mapping(uint256=>uint256) public maxRoundSupply;\n    mapping(uint256=>uint256) public roundSold;\n    mapping(address=>mapping(uint256 => uint256)) public ownedByRound;  // nft alredy minted by round by address\n    mapping(uint256=>bool) public sellAvailable; // is the round available\n\n    constructor() ERC721(\"NFTvGenesisBox\", \"NFTvGenBox\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); // Maybe to define a different owner address\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(SUBADMIN_ROLE, _msgSender());\n\n        // MAINNET SETTINGS !!!!\n        maxRoundSupply[0] = 3333;    // round 0     \n        maxRoundSupply[1] = 3333;    // round 1     \n        maxRoundSupply[2] = 3100;    // round 2     \n        maxRoundSupply[3] = 33;      // team round  \n        \n    }\n\n    // public mint: in public sell, proof array must set empty\n    function mint(uint256 _round, uint256 _amount, bytes32[] memory _proof) external payable {\n        require(!isPaused, \"contract paused\"); // allow pause buy\n        require(sellAvailable[_round], \"round unavailable\"); // need to allow each round\n        require(totalSupply() + _amount <= maxSupply, \"max supply\"); // this to ensure max supply\n        require(_amount > 0, \"amount 0\"); // this to request at least 1 nft\n        \n        if(_round != teamRound){\n            require(tokenPrice[_round] > 0, \"tokenPrice unset\"); // this to ensure price is already fixed in wei\n            // this to ensure value deposited is enough\n            require(msg.value >= _amount * tokenPrice[_round], \"value too low\"); \n        }\n\n        // ensure user round already minted + amount less than max by round by address\n        require(\n            ownedByRound[_msgSender()][_round] + _amount <= allowedByRoundByAddress,\n            \"max by round by address\"\n        );\n     \n        if( _round != publicRound){ \n\n            // ensure maxRoundSupply is set and round nft sold + amount less or equal than maxRoundSuply\n            require(\n                maxRoundSupply[_round] > 0 &&\n                roundSold[_round] + _amount <= maxRoundSupply[_round],\n                \"max total by round\"\n            );\n\n            // ensure root of the round is set and user is in whitelist\n            require(\n                root[_round].length > 0 &&\n                MerkleProof.verify(_proof, root[_round], keccak256(abi.encodePacked(_msgSender()))),\n                \"not allowed to mint\"\n            );\n        }\n\n        // user by round increment\n        ownedByRound[_msgSender()][_round] += _amount;\n\n        // total sold by round increment\n        roundSold[_round] += _amount;\n\n        // loop of mint\n        for(uint256 i = 0; i < _amount; i++){\n            require(internalMint(_msgSender()), \"mint error\");\n        }\n    }\n\n\n    //   ###############################################################################################################\n    //   RESTRICTED ROLES FUNCTIONS\n    //   ###############################################################################################################\n\n    // simple mint for certain roles with less verifications steps to save gas \n    function mintForMinter(uint256 _amount, address _receiver) external onlyRole(MINTER_ROLE) returns(bool) {\n        require(_amount > 0, \"amount 0\");\n        require(totalSupply() + _amount <= maxSupply, \"max supply\");\n        for(uint256 i = 0; i < _amount; i++){\n            require(internalMint(_receiver), \"mint error\");\n        }\n        return true;\n    }\n\n    function setTokenPrice(uint256 _round, uint256 _tokenPrice) external onlyRole(SUBADMIN_ROLE) {\n        tokenPrice[_round] = _tokenPrice;\n    }\n\n    function setBaseURI(string memory baseURI_) external onlyRole(SUBADMIN_ROLE) {\n        baseURI = baseURI_;\n    }\n\n    function setPause(bool _isPaused) external onlyRole(SUBADMIN_ROLE) {\n        isPaused = _isPaused; \n    }\n\n    function setRoot(uint256 _round, bytes32 _root) external onlyRole(SUBADMIN_ROLE) {\n        root[_round] = _root; \n    }\n\n    function setMultiSig(address _multisig) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        multisig = _multisig; \n    }\n\n    function setAllowedByRoundByAddress(uint256 _allowedByRoundByAddress) external onlyRole(SUBADMIN_ROLE) {\n        allowedByRoundByAddress = _allowedByRoundByAddress;\n    }\n\n    function setMaxRoundSupply(uint256 _round, uint256 _maxRoundSupply) external onlyRole(SUBADMIN_ROLE) { \n        maxRoundSupply[_round] = _maxRoundSupply; \n    }\n\n    function setSellAvailable(uint256 _round, bool _sellAvailable) external onlyRole(SUBADMIN_ROLE) { \n        sellAvailable[_round] = _sellAvailable; \n    }\n\n    function setTeamRound(uint256 _teamRound) external onlyRole(SUBADMIN_ROLE) { \n        teamRound = _teamRound; \n    }\n\n    function setPublicRound(uint256 _publicRound) external onlyRole(SUBADMIN_ROLE) { \n        publicRound = _publicRound; \n    }\n\n    // withdraw balance of the contract fully or partially\n    function withdraw(uint256 _ethAmount, bool _withdrawAll) external onlyRole(SUBADMIN_ROLE) returns(bool) {\n        require(multisig != address(0), \"multisig not set\");\n        uint256 ethBalance = address(this).balance;\n        uint256 ethAmount;\n        if(_withdrawAll){\n            ethAmount = ethBalance;\n        } else {\n            ethAmount = _ethAmount;\n        }\n        require(ethAmount <= ethBalance, \"eth balance too low\");\n        require(ethAmount  > 0, \"eth amount 0\");\n        (bool success,) = payable(multisig).call{value: ethAmount}(new bytes(0));\n        require(success, \"transfer error\");\n        return true;\n    }\n\n\n    //   ###############################################################################################################\n    //   VIEW FUNCTIONS\n    //   ###############################################################################################################\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    // required by ERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(\n        ERC721Enumerable, \n        AccessControl\n    ) returns (bool) {\n        return  interfaceId == type(IAccessControl).interfaceId ||\n                interfaceId == type(IERC721).interfaceId ||\n                interfaceId == type(IERC721Metadata).interfaceId ||\n                interfaceId == type(IERC721Enumerable).interfaceId ||\n                interfaceId == type(IERC165).interfaceId ||\n                super.supportsInterface(interfaceId);\n    }\n    \n    function exists(uint256 _tokenId) external view returns(bool){\n        return _exists(_tokenId);\n    }\n\n\n    //   ###############################################################################################################\n    //   PRIVATE FUNCTION\n    //   ###############################################################################################################\n\n    // ERC721 mint function increment id\n    function internalMint(address _address) private returns(bool){\n        _mint(_address, id);\n        id++;\n        return true;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}