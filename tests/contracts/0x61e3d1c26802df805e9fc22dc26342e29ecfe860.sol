{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/interfaces/DefaultOperatorFilterer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {OperatorFilterer} from \"./OperatorFilterer.sol\";\n\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\n\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\n}"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n* @dev Required interface of an ERC173 compliant contract, as defined in the\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\n*/\ninterface IERC173 /* is IERC165 */ {\n    /// @dev This emits when ownership of a contract changes.    \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner    \n    /// @return The address of the owner.\n    function owner() view external returns(address);\n\t\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract    \n    function transferOwnership(address _newOwner) external;\t\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is IERC165 */ {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer( address indexed from_, address indexed to_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval( address indexed owner_, address indexed approved_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll( address indexed owner_, address indexed operator_, bool approved_ );\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param owner_ An address for whom to query the balance\n  /// @return The number of NFTs owned by `owner_`, possibly zero\n  function balanceOf( address owner_ ) external view returns ( uint256 );\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param tokenId_ The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `to_` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `to_` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  /// @param data_ Additional data with no specified format, sent in call to `to_`\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `to_` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param approved_ The new approved NFT controller\n  /// @param tokenId_ The NFT to approve\n  function approve( address approved_, uint256 tokenId_ ) external;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param operator_ Address to add to the set of authorized operators\n  /// @param approved_ True if the operator is approved, false to revoke approval\n  function setApprovalForAll( address operator_, bool approved_ ) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `tokenId_` is not a valid NFT.\n  /// @param tokenId_ The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param owner_ The address that owns the NFTs\n  /// @param operator_ The address that acts on behalf of the owner\n  /// @return True if `operator_` is an approved operator for `owner_`, false otherwise\n  function isApprovedForAll( address owner_, address operator_ ) external view returns ( bool );\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable /* is IERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns ( uint256 );\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `index_` >= `totalSupply()`.\n    /// @param index_ A counter less than `totalSupply()`\n    /// @return The token identifier for the `index_`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex( uint256 index_ ) external view returns ( uint256 );\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `index_` >= `balanceOf(owner_)` or if\n    ///  `owner_` is the zero address, representing invalid NFTs.\n    /// @param owner_ An address where we are interested in NFTs owned by them\n    /// @param index_ A counter less than `balanceOf(owner_)`\n    /// @return The token identifier for the `index_`th NFT assigned to `owner_`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex( address owner_, uint256 index_ ) external view returns ( uint256 );\n}\n"
    },
    "contracts/interfaces/IERC721Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\ninterface IERC721Errors {\n  /**\n  * @dev Thrown when `operator` has not been approved to manage `tokenId` on behalf of `tokenOwner`.\n  * \n  * @param tokenOwner : address owning the token\n  * @param operator   : address trying to manage the token\n  * @param tokenId    : identifier of the NFT being referenced\n  */\n  error IERC721_CALLER_NOT_APPROVED( address tokenOwner, address operator, uint256 tokenId );\n  /**\n  * @dev Thrown when `operator` tries to approve themselves for managing a token they own.\n  * \n  * @param operator : address that is trying to approve themselves\n  */\n  error IERC721_INVALID_APPROVAL( address operator );\n  /**\n  * @dev Thrown when a token is being transferred to the zero address.\n  */\n  error IERC721_INVALID_TRANSFER();\n  /**\n  * @dev Thrown when a token is being transferred from an address that doesn't own it.\n  * \n  * @param tokenOwner : address owning the token\n  * @param from       : address that the NFT is being transferred from\n  * @param tokenId    : identifier of the NFT being referenced\n  */\n  error IERC721_INVALID_TRANSFER_FROM( address tokenOwner, address from, uint256 tokenId );\n  /**\n  * @dev Thrown when the requested token doesn't exist.\n  * \n  * @param tokenId : identifier of the NFT being referenced\n  */\n  error IERC721_NONEXISTANT_TOKEN( uint256 tokenId );\n  /**\n  * @dev Thrown when a token is being safely transferred to a contract unable to handle it.\n  * \n  * @param receiver : address unable to receive the token\n  */\n  error IERC721_NON_ERC721_RECEIVER( address receiver );\n  /**\n  * @dev Thrown when trying to get the token at an index that doesn't exist.\n  * \n  * @param index : the inexistant index\n  */\n  error IERC721Enumerable_INDEX_OUT_OF_BOUNDS( uint256 index );\n  /**\n  * @dev Thrown when trying to get the token owned by `tokenOwner` at an index that doesn't exist.\n  * \n  * @param tokenOwner : address owning the token\n  * @param index      : the inexistant index\n  */\n  error IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( address tokenOwner, uint256 index );\n}\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata /* is IERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns ( string memory _name );\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns ( string memory _symbol );\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI( uint256 _tokenId ) external view returns ( string memory );\n}\n"
    },
    "contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721Receiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param operator_ The address which called `safeTransferFrom` function\n    /// @param from_ The address which previously owned the token\n    /// @param tokenId_ The NFT identifier which is being transferred\n    /// @param data_ Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received( address operator_, address from_, uint256 tokenId_, bytes calldata data_ ) external returns( bytes4 );\n}\n"
    },
    "contracts/interfaces/IOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IOperatorFilterRegistry {\n    function isOperatorAllowed(address registrant, address operator)\n        external\n        view\n        returns (bool);\n\n    function register(address registrant) external;\n\n    function registerAndSubscribe(address registrant, address subscription)\n        external;\n\n    function registerAndCopyEntries(\n        address registrant,\n        address registrantToCopy\n    ) external;\n\n    function updateOperator(\n        address registrant,\n        address operator,\n        bool filtered\n    ) external;\n\n    function updateOperators(\n        address registrant,\n        address[] calldata operators,\n        bool filtered\n    ) external;\n\n    function updateCodeHash(\n        address registrant,\n        bytes32 codehash,\n        bool filtered\n    ) external;\n\n    function updateCodeHashes(\n        address registrant,\n        bytes32[] calldata codeHashes,\n        bool filtered\n    ) external;\n\n    function subscribe(address registrant, address registrantToSubscribe)\n        external;\n\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n\n    function subscriptionOf(address addr) external returns (address registrant);\n\n    function subscribers(address registrant)\n        external\n        returns (address[] memory);\n\n    function subscriberAt(address registrant, uint256 index)\n        external\n        returns (address);\n\n    function copyEntriesOf(address registrant, address registrantToCopy)\n        external;\n\n    function isOperatorFiltered(address registrant, address operator)\n        external\n        returns (bool);\n\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode)\n        external\n        returns (bool);\n\n    function isCodeHashFiltered(address registrant, bytes32 codeHash)\n        external\n        returns (bool);\n\n    function filteredOperators(address addr)\n        external\n        returns (address[] memory);\n\n    function filteredCodeHashes(address addr)\n        external\n        returns (bytes32[] memory);\n\n    function filteredOperatorAt(address registrant, uint256 index)\n        external\n        returns (address);\n\n    function filteredCodeHashAt(address registrant, uint256 index)\n        external\n        returns (bytes32);\n\n    function isRegistered(address addr) external returns (bool);\n\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/OperatorFilterer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\n\nabstract contract OperatorFilterer {\n    error OperatorNotAllowed(address operator);\n\n    IOperatorFilterRegistry constant operatorFilterRegistry =\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\n        // order for the modifier to filter addresses.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            if (subscribe) {\n                operatorFilterRegistry.registerAndSubscribe(\n                    address(this),\n                    subscriptionOrRegistrantToCopy\n                );\n            } else {\n                if (subscriptionOrRegistrantToCopy != address(0)) {\n                    operatorFilterRegistry.registerAndCopyEntries(\n                        address(this),\n                        subscriptionOrRegistrantToCopy\n                    );\n                } else {\n                    operatorFilterRegistry.register(address(this));\n                }\n            }\n        }\n    }\n\n    modifier onlyAllowedOperator(address from) virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(operatorFilterRegistry).code.length > 0) {\n            // Allow spending tokens from addresses with balance\n            // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n            // from an EOA.\n            if (from == msg.sender) {\n                _;\n                return;\n            }\n            if (\n                !(operatorFilterRegistry.isOperatorAllowed(\n                    address(this),\n                    msg.sender\n                ) &&\n                    operatorFilterRegistry.isOperatorAllowed(\n                        address(this),\n                        from\n                    ))\n            ) {\n                revert OperatorNotAllowed(msg.sender);\n            }\n        }\n        _;\n    }\n}\n"
    },
    "contracts/Reg_ERC721Batch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Author: Lambdalf the White\n */\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/IERC721Errors.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/IERC721Enumerable.sol\";\nimport \"./interfaces/IERC721Metadata.sol\";\nimport \"./interfaces/IERC721Receiver.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n * This contract features:\n * ~ Very Cheap batch minting\n * ~ Token tracker support\n *\n * Note: This implementation imposes a very expensive `balanceOf()` and `ownerOf()`.\n * It is not recommended to interract with those from another contract.\n */\nabstract contract Reg_ERC721Batch is\n    IERC721Errors,\n    IERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    uint256 private _nextId = 1;\n    string public name;\n    string public symbol;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) public getApproved;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // List of owner addresses\n    mapping(uint256 => address) private _owners;\n\n    // Token Base URI\n    string private _baseURI;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __init_ERC721Metadata(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_\n    ) internal {\n        name = name_;\n        symbol = symbol_;\n        _baseURI = baseURI_;\n    }\n\n    // **************************************\n    // *****          MODIFIER          *****\n    // **************************************\n    /**\n     * @dev Ensures the token exist.\n     * A token exists if it has been minted and is not owned by the null address.\n     *\n     * @param tokenId_ : identifier of the NFT being referenced\n     */\n    modifier exists(uint256 tokenId_) {\n        if (!_exists(tokenId_)) {\n            revert IERC721_NONEXISTANT_TOKEN(tokenId_);\n        }\n        _;\n    }\n\n    // **************************************\n\n    // **************************************\n    // *****          INTERNAL          *****\n    // **************************************\n    /**\n     * @dev Internal function returning the number of tokens in `tokenOwner_`'s account.\n     */\n    function _balanceOf(address tokenOwner_)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (tokenOwner_ == address(0)) {\n            return 0;\n        }\n\n        uint256 _count_ = 0;\n        address _currentTokenOwner_;\n        for (uint256 i = 1; i < _nextId; ++i) {\n            if (_exists(i)) {\n                if (_owners[i] != address(0)) {\n                    _currentTokenOwner_ = _owners[i];\n                }\n                if (tokenOwner_ == _currentTokenOwner_) {\n                    _count_++;\n                }\n            }\n        }\n        return _count_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from_ address representing the previous owner of the given token ID\n     * @param to_ target address that will receive the tokens\n     * @param tokenId_ uint256 ID of the token to be transferred\n     * @param data_ bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) internal virtual returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        //\n        // IMPORTANT\n        // It is unsafe to assume that an address not flagged by this method\n        // is an externally-owned account (EOA) and not a contract.\n        //\n        // Among others, the following types of addresses will not be flagged:\n        //\n        //  - an externally-owned account\n        //  - a contract in construction\n        //  - an address where a contract will be created\n        //  - an address where a contract lived, but was destroyed\n        uint256 _size_;\n        assembly {\n            _size_ := extcodesize(to_)\n        }\n\n        // If address is a contract, check that it is aware of how to handle ERC721 tokens\n        if (_size_ > 0) {\n            try\n                IERC721Receiver(to_).onERC721Received(\n                    msg.sender,\n                    from_,\n                    tokenId_,\n                    data_\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert IERC721_NON_ERC721_RECEIVER(to_);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Internal function returning whether a token exists.\n     * A token exists if it has been minted and is not owned by the null address.\n     *\n     * @param tokenId_ uint256 ID of the token to verify\n     *\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId_) internal view virtual returns (bool) {\n        if (tokenId_ == 0) {\n            return false;\n        }\n        return tokenId_ < _nextId;\n    }\n\n    /**\n     * @dev Internal function returning whether `operator_` is allowed\n     * to manage tokens on behalf of `tokenOwner_`.\n     *\n     * @param tokenOwner_ address that owns tokens\n     * @param operator_ address that tries to manage tokens\n     *\n     * @return bool whether `operator_` is allowed to handle the token\n     */\n    function _isApprovedForAll(address tokenOwner_, address operator_)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _operatorApprovals[tokenOwner_][operator_];\n    }\n\n    /**\n     * @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\n     *\n     * Note: To avoid multiple checks for the same data, it is assumed that existence of `tokeId_`\n     * has been verified prior via {_exists}\n     * If it hasn't been verified, this function might panic\n     *\n     * @param operator_ address that tries to handle the token\n     * @param tokenId_ uint256 ID of the token to be handled\n     *\n     * @return bool whether `operator_` is allowed to handle the token\n     */\n    function _isApprovedOrOwner(\n        address tokenOwner_,\n        address operator_,\n        uint256 tokenId_\n    ) internal view virtual returns (bool) {\n        bool _isApproved_ = operator_ == tokenOwner_ ||\n            operator_ == getApproved[tokenId_] ||\n            _isApprovedForAll(tokenOwner_, operator_);\n        return _isApproved_;\n    }\n\n    /**\n     * @dev Mints `qty_` tokens and transfers them to `to_`.\n     *\n     * This internal function can be used to perform token minting.\n     *\n     * Emits one or more {Transfer} event.\n     */\n    function _mint(address to_, uint256 qty_) internal virtual {\n        uint256 _firstToken_ = _nextId;\n        uint256 _nextStart_ = _firstToken_ + qty_;\n        uint256 _lastToken_ = _nextStart_ - 1;\n\n        _owners[_firstToken_] = to_;\n        if (_lastToken_ > _firstToken_) {\n            _owners[_lastToken_] = to_;\n        }\n        _nextId = _nextStart_;\n\n        if (!_checkOnERC721Received(address(0), to_, _firstToken_, \"\")) {\n            revert IERC721_NON_ERC721_RECEIVER(to_);\n        }\n\n        for (uint256 i = _firstToken_; i < _nextStart_; ++i) {\n            emit Transfer(address(0), to_, i);\n        }\n    }\n\n    /**\n     * @dev Internal function returning the owner of the `tokenId_` token.\n     *\n     * @param tokenId_ uint256 ID of the token to verify\n     *\n     * @return address the address of the token owner\n     */\n    function _ownerOf(uint256 tokenId_)\n        internal\n        view\n        virtual\n        returns (address)\n    {\n        uint256 _tokenId_ = tokenId_;\n        address _tokenOwner_ = _owners[_tokenId_];\n        while (_tokenOwner_ == address(0)) {\n            _tokenId_--;\n            _tokenOwner_ = _owners[_tokenId_];\n        }\n\n        return _tokenOwner_;\n    }\n\n    /**\n     * @dev Internal function used to set the base URI of the collection.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function returning the total supply.\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return supplyMinted();\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function _toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Transfers `tokenId_` from `from_` to `to_`.\n     *\n     * This internal function can be used to implement alternative mechanisms to perform\n     * token transfer, such as signature-based, or token burning.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual {\n        getApproved[tokenId_] = address(0);\n        uint256 _previousId_ = tokenId_ > 1 ? tokenId_ - 1 : 1;\n        uint256 _nextId_ = tokenId_ + 1;\n        bool _previousShouldUpdate_ = _previousId_ < tokenId_ &&\n            _exists(_previousId_) &&\n            _owners[_previousId_] == address(0);\n        bool _nextShouldUpdate_ = _exists(_nextId_) &&\n            _owners[_nextId_] == address(0);\n\n        if (_previousShouldUpdate_) {\n            _owners[_previousId_] = from_;\n        }\n\n        if (_nextShouldUpdate_) {\n            _owners[_nextId_] = from_;\n        }\n\n        _owners[tokenId_] = to_;\n\n        emit Transfer(from_, to_, tokenId_);\n    }\n\n    // **************************************\n\n    // **************************************\n    // *****           PUBLIC           *****\n    // **************************************\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to_, uint256 tokenId_)\n        public\n        virtual\n        exists(tokenId_)\n    {\n        address _operator_ = msg.sender;\n        address _tokenOwner_ = _ownerOf(tokenId_);\n        if (to_ == _tokenOwner_) {\n            revert IERC721_INVALID_APPROVAL(to_);\n        }\n\n        bool _isApproved_ = _isApprovedOrOwner(\n            _tokenOwner_,\n            _operator_,\n            tokenId_\n        );\n        if (!_isApproved_) {\n            revert IERC721_CALLER_NOT_APPROVED(\n                _tokenOwner_,\n                _operator_,\n                tokenId_\n            );\n        }\n\n        getApproved[tokenId_] = to_;\n        emit Approval(_tokenOwner_, to_, tokenId_);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\n     * Note: We can ignore `from_` as we can compare everything to the actual token owner,\n     * but we cannot remove this parameter to stay in conformity with IERC721\n     */\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual override {\n        safeTransferFrom(from_, to_, tokenId_, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     *\n     * Note: We can ignore `from_` as we can compare everything to the actual token owner,\n     * but we cannot remove this parameter to stay in conformity with IERC721\n     */\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        bytes memory data_\n    ) public virtual override {\n        transferFrom(from_, to_, tokenId_);\n        if (!_checkOnERC721Received(from_, to_, tokenId_, data_)) {\n            revert IERC721_NON_ERC721_RECEIVER(to_);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator_, bool approved_)\n        public\n        virtual\n        override\n    {\n        address _account_ = msg.sender;\n        if (operator_ == _account_) {\n            revert IERC721_INVALID_APPROVAL(operator_);\n        }\n\n        _operatorApprovals[_account_][operator_] = approved_;\n        emit ApprovalForAll(_account_, operator_, approved_);\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     *\n     * Note: We can ignore `from_` as we can compare everything to the actual token owner,\n     * but we cannot remove this parameter to stay in conformity with IERC721\n     */\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) public virtual exists(tokenId_) {\n        if (to_ == address(0)) {\n            revert IERC721_INVALID_TRANSFER();\n        }\n\n        address _operator_ = msg.sender;\n        address _tokenOwner_ = _ownerOf(tokenId_);\n        if (from_ != _tokenOwner_) {\n            revert IERC721_INVALID_TRANSFER_FROM(_tokenOwner_, from_, tokenId_);\n        }\n\n        bool _isApproved_ = _isApprovedOrOwner(\n            _tokenOwner_,\n            _operator_,\n            tokenId_\n        );\n        if (!_isApproved_) {\n            revert IERC721_CALLER_NOT_APPROVED(\n                _tokenOwner_,\n                _operator_,\n                tokenId_\n            );\n        }\n\n        _transfer(_tokenOwner_, to_, tokenId_);\n    }\n\n    // **************************************\n\n    // **************************************\n    // *****            VIEW            *****\n    // **************************************\n    /**\n     * @dev Returns the number of tokens in `tokenOwner_`'s account.\n     */\n    function balanceOf(address tokenOwner_)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return _balanceOf(tokenOwner_);\n    }\n\n    /**\n     * @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address tokenOwner_, address operator_)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return _isApprovedForAll(tokenOwner_, operator_);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId_` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId_` must exist.\n     */\n    function ownerOf(uint256 tokenId_)\n        public\n        view\n        virtual\n        exists(tokenId_)\n        returns (address)\n    {\n        return _ownerOf(tokenId_);\n    }\n\n    /**\n     * @dev Returns the total number of tokens minted\n     *\n     * @return uint256 the number of tokens that have been minted so far\n     */\n    function supplyMinted() public view virtual returns (uint256) {\n        return _nextId - 1;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId_)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId_ == type(IERC721Enumerable).interfaceId ||\n            interfaceId_ == type(IERC721Metadata).interfaceId ||\n            interfaceId_ == type(IERC721).interfaceId ||\n            interfaceId_ == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        if (index_ >= supplyMinted()) {\n            revert IERC721Enumerable_INDEX_OUT_OF_BOUNDS(index_);\n        }\n        return index_ + 1;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address tokenOwner_, uint256 index_)\n        public\n        view\n        virtual\n        override\n        returns (uint256 tokenId)\n    {\n        if (index_ >= _balanceOf(tokenOwner_)) {\n            revert IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS(\n                tokenOwner_,\n                index_\n            );\n        }\n\n        uint256 _count_ = 0;\n        for (uint256 i = 1; i < _nextId; i++) {\n            if (_exists(i) && tokenOwner_ == _ownerOf(i)) {\n                if (index_ == _count_) {\n                    return i;\n                }\n                _count_++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId_)\n        public\n        view\n        virtual\n        override\n        exists(tokenId_)\n        returns (string memory)\n    {\n        return\n            bytes(_baseURI).length > 0\n                ? string(abi.encodePacked(_baseURI, _toString(tokenId_)))\n                : _toString(tokenId_);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply();\n    }\n    // **************************************\n}\n"
    },
    "contracts/SavageNation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Contract by @AsteriaLabs\nimport \"./Reg_ERC721Batch.sol\";\nimport \"./utils/Whitelist_Merkle.sol\";\nimport \"./utils/ERC173.sol\";\nimport \"./interfaces/DefaultOperatorFilterer.sol\";\n\n/// @title Savage Nation\n/// @author Goku <@Suleman132446>\ncontract SavageNation is\n    Reg_ERC721Batch,\n    Whitelist_Merkle,\n    ERC173,\n    DefaultOperatorFilterer\n{\n    using MerkleProof for bytes32[];\n\n    uint256 public whitelistPrice = 0.039 ether;\n    uint256 public publicPrice = 0.059 ether;\n    uint256 public maxPerWhitelist = 2;\n    uint256 public maxPerPublic = 2;\n    uint256 public maxSupply = 10000;\n\n    /**\n     @dev An enum representing the sale state\n     */\n    enum Sale {\n        PAUSED,\n        PRIVATE,\n        PUBLIC\n    }\n\n    Sale public saleState = Sale.PAUSED;\n    // Mapping of nft minted by a wallet in public\n    mapping(address => uint256) public mintedPerWallet;\n\n    // Modifier to allow only owner\n\n    // Modifier to check the sale state\n    modifier isSaleState(Sale sale_) {\n        require(saleState == sale_, \"Sale not active\");\n        _;\n    }\n\n    // Modifier to block the other contracts\n    modifier blockContracts() {\n        require(tx.origin == msg.sender, \"No smart contracts are allowed\");\n        _;\n    }\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_\n    ) {\n        __init_ERC721Metadata(name_, symbol_, baseURI_);\n        _setOwner(msg.sender);\n    }\n\n    /**\n     * @dev tranfer the funds from contract\n     *\n     * @param to_ : the address of the wallet to transfer the funds\n     */\n    function withdraw(address to_, uint amount_) public onlyOwner {\n        uint256 _balance_ = address(this).balance;\n        require(_balance_ > 0, \"No balance to withdraw\");\n        require(amount_ <= _balance_, \"Amount is not valid\");\n        address _recipient_ = payable(to_);\n        (bool _success_, ) = _recipient_.call{value: amount_}(\"\");\n        require(_success_, \"Transaction failed\");\n    }\n\n    /**\n     * @dev set the whiltelist price\n     *\n     * @param price_ : the price of whitelist mint\n     */\n    function setWhitelistPrice(uint256 price_) external onlyOwner {\n        whitelistPrice = price_;\n    }\n\n    /**\n     * @dev set the public mint price\n     *\n     * @param price_ : the price of public mint\n     */\n    function setPublicPrice(uint256 price_) external onlyOwner {\n        publicPrice = price_;\n    }\n\n    /**\n     * @dev set the mints per wallet in whitelist\n     *\n     * @param mints_ : the amount of for whitelist mint\n     */\n    function setMintsPerWhitelist(uint256 mints_) external onlyOwner {\n        maxPerWhitelist = mints_;\n    }\n\n    /**\n     * @dev set the mints per wallet in public\n     *\n     * @param mints_ : the amount of for public mint\n     */\n    function setMintsPerPublic(uint256 mints_) external onlyOwner {\n        maxPerPublic = mints_;\n    }\n\n    /**\n     * @dev set the max supply for collection\n     *\n     * @param supply_ : the amount for  supply\n     */\n    function setMaxSupply(uint256 supply_) external onlyOwner {\n        uint _currentSupply_ = totalSupply();\n        require(\n            supply_ > _currentSupply_,\n            \"Max supply should be greater than current supply\"\n        );\n        require(\n            supply_ < maxSupply,\n            \"Max supply should be greater than previous max supply\"\n        );\n        maxSupply = supply_;\n    }\n\n    /**\n     * @dev set the merkle root for whitelist\n     *\n     * @param root_ : the merkle for whitelist\n     */\n    function setWhitelistRoot(bytes32 root_) external onlyOwner {\n        _setWhitelist(root_);\n    }\n\n    /**\n     * @dev set the base uri for collection\n     *\n     * @param baseURI_ : the base uri for collection\n     */\n    function setBaseURI(string memory baseURI_) external onlyOwner {\n        _setBaseURI(baseURI_);\n    }\n\n    /**\n     * @dev set the sale state\n     *\n     * @param sale_ : the new sale state\n     */\n    function setSaleState(Sale sale_) external onlyOwner {\n        saleState = sale_;\n    }\n\n    /**\n     * @dev mint the token in whitelist sale\n     *\n     * @param proof_ : the proof for verificaton\n     * @param qty_ : the quantity of mint\n     */\n    function mintWhitelist(bytes32[] memory proof_, uint256 qty_)\n        external\n        payable\n        blockContracts\n        isSaleState(Sale.PRIVATE)\n        isWhitelisted(msg.sender, proof_, maxPerWhitelist, qty_)\n    {\n        uint _supply_ = totalSupply();\n        require(_supply_ + qty_ <= maxSupply, \"Exceeds supply\");\n        require(\n            msg.value == qty_ * whitelistPrice,\n            \"Ether sent is not correct\"\n        );\n        _mint(msg.sender, qty_);\n        _consumeWhitelist(msg.sender, qty_);\n    }\n\n    /**\n     * @dev mint the token for airdrop\n     *\n     * @param qty_ : the quantity of mint\n     * @param to_: the address to send to\n     */\n    function airdrop( uint256 qty_ , address to_) onlyOwner\n        external\n        payable\n        blockContracts\n    {\n        uint _supply_ = totalSupply();\n        require(_supply_ + qty_ <= maxSupply, \"Exceeds supply\");\n        _mint(to_, qty_);\n    }\n\n    /**\n     * @dev mint the token in public sale\n     *\n     * @param qty_ : the quantity of mint\n     */\n    function mintPublic(uint256 qty_)\n        external\n        payable\n        blockContracts\n        isSaleState(Sale.PUBLIC)\n    {\n        uint _supply_ = totalSupply();\n        require(\n            mintedPerWallet[msg.sender] + qty_ <= maxPerPublic,\n            \"Exceeds mint per wallet\"\n        );\n        require(_supply_ + qty_ <= maxSupply, \"Exceeds supply\");\n        require(msg.value == qty_ * publicPrice, \"Ether sent is not correct\");\n        _mint(msg.sender, qty_);\n        mintedPerWallet[msg.sender] += qty_;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.transferFrom(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }\n}\n"
    },
    "contracts/utils/ERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n* Author: Lambdalf the White\n*/\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC173.sol\";\n\n/**\n* @dev Contract module which provides a basic access control mechanism, where\n* there is an account (an owner) that can be granted exclusive access to\n* specific functions.\n*\n* By default, the owner account will be the one that deploys the contract. This\n* can later be changed with {transferOwnership}.\n*\n* This module is used through inheritance. It will make available the modifier\n* `onlyOwner`, which can be applied to your functions to restrict their use to\n* the owner.\n*/\nabstract contract ERC173 is IERC173 {\n\t// Errors\n  /**\n  * @dev Thrown when `operator` is not the contract owner.\n  * \n  * @param operator : address trying to use a function reserved to contract owner without authorization\n  */\n  error IERC173_NOT_OWNER( address operator );\n\n\t// The owner of the contract\n\taddress private _owner;\n\n\t/**\n\t* @dev Throws if called by any account other than the owner.\n\t*/\n\tmodifier onlyOwner() {\n\t\taddress _sender_ = msg.sender;\n\t\tif ( owner() != _sender_ ) {\n\t\t\trevert IERC173_NOT_OWNER( _sender_ );\n\t\t}\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Sets the contract owner.\n\t* \n\t* Note: This function needs to be called in the contract constructor to initialize the contract owner, \n\t* if it is not, then parts of the contract might be non functional\n\t* \n\t* @param owner_ : address that owns the contract\n\t*/\n\tfunction _setOwner( address owner_ ) internal {\n\t\t_owner = owner_;\n\t}\n\n\t/**\n\t* @dev Returns the address of the current contract owner.\n\t* \n\t* @return address : the current contract owner\n\t*/\n\tfunction owner() public view virtual returns ( address ) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t* @dev Transfers ownership of the contract to `newOwner_`.\n\t* \n\t* @param newOwner_ : address of the new contract owner\n\t* \n\t* Requirements:\n\t* \n  * - Caller must be the contract owner.\n\t*/\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\n\t\taddress _oldOwner_ = _owner;\n\t\t_owner = newOwner_;\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\n\t}\n}\n"
    },
    "contracts/utils/Whitelist_Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Author: Lambdalf the White\n * Edit  : Squeebo\n */\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nabstract contract Whitelist_Merkle {\n    // Errors\n    /**\n     * @dev Thrown when trying to query the whitelist while it's not set\n     */\n    error Whitelist_NOT_SET();\n    /**\n     * @dev Thrown when `account` has consumed their alloted access and tries to query more\n     *\n     * @param account : address trying to access the whitelist\n     */\n    error Whitelist_CONSUMED(address account);\n    /**\n     * @dev Thrown when `account` does not have enough alloted access to fulfil their query\n     *\n     * @param account : address trying to access the whitelist\n     */\n    error Whitelist_FORBIDDEN(address account);\n\n    bytes32 private _root;\n    mapping(address => uint256) private _consumed;\n\n    /**\n     * @dev Ensures that `account_` has `qty_` alloted access on the whitelist.\n     *\n     * @param account_ : the address to validate access\n     * @param proof_   : the Merkle proof to validate whitelist allocation\n     * @param alloted_ : the max amount of whitelist spots allocated\n     * @param qty_     : the amount of whitelist access requested\n     */\n    modifier isWhitelisted(\n        address account_,\n        bytes32[] memory proof_,\n        uint256 alloted_,\n        uint256 qty_\n    ) {\n        if (qty_ > alloted_) {\n            revert Whitelist_FORBIDDEN(account_);\n        }\n\n        uint256 _allowed_ = checkWhitelistAllowance(account_, proof_, alloted_);\n\n        if (_allowed_ < qty_) {\n            revert Whitelist_FORBIDDEN(account_);\n        }\n\n        _;\n    }\n\n    /**\n     * @dev Internal function setting the pass to protect the whitelist.\n     *\n     * @param root_ : the Merkle root to hold the whitelist\n     */\n    function _setWhitelist(bytes32 root_) internal virtual {\n        _root = root_;\n    }\n\n    /**\n     * @dev Returns the amount that `account_` is allowed to access from the whitelist.\n     *\n     * @param account_ : the address to validate access\n     * @param proof_   : the Merkle proof to validate whitelist allocation\n     *\n     * @return uint256 : the total amount of whitelist allocation remaining for `account_`\n     *\n     * Requirements:\n     *\n     * - `_root` must be set.\n     */\n    function checkWhitelistAllowance(\n        address account_,\n        bytes32[] memory proof_,\n        uint256 alloted_\n    ) public view returns (uint256) {\n        if (_root == 0) {\n            revert Whitelist_NOT_SET();\n        }\n\n        if (_consumed[account_] >= alloted_) {\n            revert Whitelist_CONSUMED(account_);\n        }\n\n        if (!_computeProof(account_, proof_)) {\n            revert Whitelist_FORBIDDEN(account_);\n        }\n\n        uint256 _res_;\n        unchecked {\n            _res_ = alloted_ - _consumed[account_];\n        }\n\n        return _res_;\n    }\n\n    /**\n     * @dev Processes the Merkle proof to determine if `account_` is whitelisted.\n     *\n     * @param account_ : the address to validate access\n     * @param proof_   : the Merkle proof to validate whitelist allocation\n     *\n     * @return bool : whether `account_` is whitelisted or not\n     */\n    function _computeProof(address account_, bytes32[] memory proof_)\n        private\n        view\n        returns (bool)\n    {\n        bytes32 leaf = keccak256(abi.encodePacked(account_));\n        return MerkleProof.processProof(proof_, leaf) == _root;\n    }\n\n    /**\n     * @dev Consumes `amount_` whitelist access passes from `account_`.\n     *\n     * @param account_ : the address to consume access from\n     *\n     * Note: Before calling this function, eligibility should be checked through {Whitelistable-checkWhitelistAllowance}.\n     */\n    function _consumeWhitelist(address account_, uint256 qty_) internal {\n        unchecked {\n            _consumed[account_] += qty_;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}