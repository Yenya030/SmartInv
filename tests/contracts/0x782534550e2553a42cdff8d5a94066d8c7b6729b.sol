{{
  "language": "Solidity",
  "sources": {
    "contracts/TwapDelay.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport './interfaces/ITwapPair.sol';\nimport './interfaces/ITwapDelay.sol';\nimport './interfaces/IWETH.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/Orders.sol';\nimport './libraries/TokenShares.sol';\nimport './libraries/AddLiquidity.sol';\nimport './libraries/WithdrawHelper.sol';\n\ncontract TwapDelay is ITwapDelay {\n    using SafeMath for uint256;\n    using Orders for Orders.Data;\n    using TokenShares for TokenShares.Data;\n\n    Orders.Data internal orders;\n    TokenShares.Data internal tokenShares;\n\n    uint256 private constant ORDER_CANCEL_TIME = 24 hours;\n    uint256 private constant BOT_EXECUTION_TIME = 20 minutes;\n    uint256 private constant ORDER_LIFESPAN = 48 hours;\n    uint16 private constant MAX_TOLERANCE = 10;\n\n    address public override owner;\n    mapping(address => bool) public override isBot;\n\n    mapping(address => uint16) public override tolerance;\n\n    constructor(\n        address _factory,\n        address _weth,\n        address _bot\n    ) {\n        orders.factory = _factory;\n        owner = msg.sender;\n        isBot[_bot] = true;\n        orders.gasPrice = tx.gasprice - (tx.gasprice % 1e6);\n        tokenShares.weth = _weth;\n        orders.delay = 30 minutes;\n        orders.maxGasLimit = 5_000_000;\n        orders.gasPriceInertia = 20_000_000;\n        orders.maxGasPriceImpact = 1_000_000;\n        orders.setTransferGasCost(address(0), Orders.ETHER_TRANSFER_CALL_COST);\n\n        emit OwnerSet(msg.sender);\n    }\n\n    function getTransferGasCost(address token) external view override returns (uint256 gasCost) {\n        return orders.transferGasCosts[token];\n    }\n\n    function getDepositOrder(uint256 orderId) external view override returns (Orders.DepositOrder memory order) {\n        (order, , ) = orders.getDepositOrder(orderId);\n    }\n\n    function getWithdrawOrder(uint256 orderId) external view override returns (Orders.WithdrawOrder memory order) {\n        return orders.getWithdrawOrder(orderId);\n    }\n\n    function getSellOrder(uint256 orderId) external view override returns (Orders.SellOrder memory order) {\n        (order, ) = orders.getSellOrder(orderId);\n    }\n\n    function getBuyOrder(uint256 orderId) external view override returns (Orders.BuyOrder memory order) {\n        (order, ) = orders.getBuyOrder(orderId);\n    }\n\n    function getDepositDisabled(address pair) external view override returns (bool) {\n        return orders.getDepositDisabled(pair);\n    }\n\n    function getWithdrawDisabled(address pair) external view override returns (bool) {\n        return orders.getWithdrawDisabled(pair);\n    }\n\n    function getBuyDisabled(address pair) external view override returns (bool) {\n        return orders.getBuyDisabled(pair);\n    }\n\n    function getSellDisabled(address pair) external view override returns (bool) {\n        return orders.getSellDisabled(pair);\n    }\n\n    function getOrderStatus(uint256 orderId) external view override returns (Orders.OrderStatus) {\n        return orders.getOrderStatus(orderId);\n    }\n\n    uint256 private locked;\n    modifier lock() {\n        require(locked == 0, 'TD06');\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    function factory() external view override returns (address) {\n        return orders.factory;\n    }\n\n    function totalShares(address token) external view override returns (uint256) {\n        return tokenShares.totalShares[token];\n    }\n\n    function weth() external view override returns (address) {\n        return tokenShares.weth;\n    }\n\n    function delay() external view override returns (uint32) {\n        return orders.delay;\n    }\n\n    function lastProcessedOrderId() external view returns (uint256) {\n        return orders.lastProcessedOrderId;\n    }\n\n    function newestOrderId() external view returns (uint256) {\n        return orders.newestOrderId;\n    }\n\n    function getOrder(uint256 orderId) external view returns (Orders.OrderType orderType, uint32 validAfterTimestamp) {\n        return orders.getOrder(orderId);\n    }\n\n    function isOrderCanceled(uint256 orderId) external view returns (bool) {\n        return orders.canceled[orderId];\n    }\n\n    function maxGasLimit() external view override returns (uint256) {\n        return orders.maxGasLimit;\n    }\n\n    function maxGasPriceImpact() external view override returns (uint256) {\n        return orders.maxGasPriceImpact;\n    }\n\n    function gasPriceInertia() external view override returns (uint256) {\n        return orders.gasPriceInertia;\n    }\n\n    function gasPrice() external view override returns (uint256) {\n        return orders.gasPrice;\n    }\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external payable override {\n        require(msg.sender == owner, 'TD00');\n        orders.setOrderDisabled(pair, orderType, disabled);\n    }\n\n    function setOwner(address _owner) external payable override {\n        require(msg.sender == owner, 'TD00');\n        // require(_owner != owner, 'TD01'); // Comment out to save size\n        require(_owner != address(0), 'TD02');\n        owner = _owner;\n        emit OwnerSet(_owner);\n    }\n\n    function setBot(address _bot, bool _isBot) external payable override {\n        require(msg.sender == owner, 'TD00');\n        // require(_isBot != isBot[_bot], 'TD01'); // Comment out to save size\n        isBot[_bot] = _isBot;\n        emit BotSet(_bot, _isBot);\n    }\n\n    function setMaxGasLimit(uint256 _maxGasLimit) external payable override {\n        require(msg.sender == owner, 'TD00');\n        orders.setMaxGasLimit(_maxGasLimit);\n    }\n\n    function setDelay(uint32 _delay) external payable override {\n        require(msg.sender == owner, 'TD00');\n        // require(_delay != orders.delay, 'TD01'); // Comment out to save size\n        orders.delay = _delay;\n        emit DelaySet(_delay);\n    }\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) external payable override {\n        require(msg.sender == owner, 'TD00');\n        orders.setGasPriceInertia(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external payable override {\n        require(msg.sender == owner, 'TD00');\n        orders.setMaxGasPriceImpact(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(address token, uint256 gasCost) external payable override {\n        require(msg.sender == owner, 'TD00');\n        orders.setTransferGasCost(token, gasCost);\n    }\n\n    function setTolerance(address pair, uint16 amount) external payable override {\n        require(msg.sender == owner, 'TD00');\n        require(amount <= MAX_TOLERANCE, 'TD54');\n        tolerance[pair] = amount;\n        emit ToleranceSet(pair, amount);\n    }\n\n    function deposit(Orders.DepositParams calldata depositParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.deposit(depositParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\n        external\n        payable\n        override\n        lock\n        returns (uint256 orderId)\n    {\n        orders.withdraw(withdrawParams);\n        return orders.newestOrderId;\n    }\n\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\n        orders.sell(sellParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\n        orders.buy(buyParams, tokenShares);\n        return orders.newestOrderId;\n    }\n\n    function execute(uint256 n) external payable override lock {\n        emit Execute(msg.sender, n);\n        uint256 gasBefore = gasleft();\n        bool orderExecuted;\n        bool senderCanExecute = isBot[msg.sender] || isBot[address(0)];\n        for (uint256 i; i < n; ++i) {\n            if (orders.canceled[orders.lastProcessedOrderId + 1]) {\n                orders.dequeueCanceledOrder();\n                continue;\n            }\n            (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getNextOrder();\n            if (orderType == Orders.OrderType.Empty || validAfterTimestamp >= block.timestamp) {\n                break;\n            }\n            require(senderCanExecute || block.timestamp >= validAfterTimestamp + BOT_EXECUTION_TIME, 'TD00');\n            orderExecuted = true;\n            if (orderType == Orders.OrderType.Deposit) {\n                executeDeposit();\n            } else if (orderType == Orders.OrderType.Withdraw) {\n                executeWithdraw();\n            } else if (orderType == Orders.OrderType.Sell) {\n                executeSell();\n            } else if (orderType == Orders.OrderType.Buy) {\n                executeBuy();\n            }\n        }\n        if (orderExecuted) {\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\n        }\n    }\n\n    function executeDeposit() internal {\n        uint256 gasStart = gasleft();\n        (Orders.DepositOrder memory depositOrder, uint256 amountLimit0, uint256 amountLimit1) = orders\n            .dequeueDepositOrder();\n        (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: depositOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[token0]).add(orders.transferGasCosts[token1])\n            )\n        }(abi.encodeWithSelector(this._executeDeposit.selector, depositOrder, amountLimit0, amountLimit1));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundTokens(\n                depositOrder.to,\n                token0,\n                depositOrder.share0,\n                token1,\n                depositOrder.share1,\n                depositOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            depositOrder.gasLimit,\n            depositOrder.gasPrice,\n            gasStart,\n            depositOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeWithdraw() internal {\n        uint256 gasStart = gasleft();\n        Orders.WithdrawOrder memory withdrawOrder = orders.dequeueWithdrawOrder();\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: withdrawOrder.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, withdrawOrder));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n            refundSuccess = Orders.refundLiquidity(\n                pair,\n                withdrawOrder.to,\n                withdrawOrder.liquidity,\n                this._refundLiquidity.selector\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(\n            withdrawOrder.gasLimit,\n            withdrawOrder.gasPrice,\n            gasStart,\n            withdrawOrder.to\n        );\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeSell() internal {\n        uint256 gasStart = gasleft();\n        (Orders.SellOrder memory sellOrder, uint256 amountLimit) = orders.dequeueSellOrder();\n\n        (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: sellOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[sellOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeSell.selector, sellOrder, amountLimit));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                sellOrder.inverse ? token1 : token0,\n                sellOrder.to,\n                sellOrder.shareIn,\n                sellOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(sellOrder.gasLimit, sellOrder.gasPrice, gasStart, sellOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function executeBuy() internal {\n        uint256 gasStart = gasleft();\n        (Orders.BuyOrder memory buyOrder, uint256 amountLimit) = orders.dequeueBuyOrder();\n        (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (bool executionSuccess, bytes memory data) = address(this).call{\n            gas: buyOrder.gasLimit.sub(\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[buyOrder.inverse ? token1 : token0])\n            )\n        }(abi.encodeWithSelector(this._executeBuy.selector, buyOrder, amountLimit));\n        bool refundSuccess = true;\n        if (!executionSuccess) {\n            refundSuccess = refundToken(\n                buyOrder.inverse ? token1 : token0,\n                buyOrder.to,\n                buyOrder.shareInMax,\n                buyOrder.unwrap\n            );\n        }\n        finalizeOrder(refundSuccess);\n        (uint256 gasUsed, uint256 ethRefund) = refund(buyOrder.gasLimit, buyOrder.gasPrice, gasStart, buyOrder.to);\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\n    }\n\n    function finalizeOrder(bool refundSuccess) private {\n        if (!refundSuccess) {\n            orders.markRefundFailed();\n        } else {\n            orders.forgetLastProcessedOrder();\n        }\n    }\n\n    function refund(\n        uint256 gasLimit,\n        uint256 gasPriceInOrder,\n        uint256 gasStart,\n        address to\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_BASE_COST);\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\n        leftOver = feeCollected.sub(actualRefund);\n        require(refundEth(msg.sender, actualRefund), 'TD40');\n        refundEth(payable(to), leftOver);\n    }\n\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\n        if (value == 0) {\n            return true;\n        }\n        success = TransferHelper.transferETH(to, value, orders.transferGasCosts[address(0)]);\n        emit EthRefund(to, success, value);\n    }\n\n    function refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) private returns (bool) {\n        if (share == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: orders.transferGasCosts[token] }(\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\n        );\n        if (!success) {\n            emit RefundFailed(to, token, share, data);\n        }\n        return success;\n    }\n\n    function refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) private returns (bool) {\n        (bool success, bytes memory data) = address(this).call{\n            gas: orders.transferGasCosts[token0].add(orders.transferGasCosts[token1])\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\n        if (!success) {\n            emit RefundFailed(to, token0, share0, data);\n            emit RefundFailed(to, token1, share1, data);\n        }\n        return success;\n    }\n\n    function _refundTokens(\n        address to,\n        address token0,\n        uint256 share0,\n        address token1,\n        uint256 share1,\n        bool unwrap\n    ) external payable {\n        // no need to check sender, because it is checked in _refundToken\n        _refundToken(token0, to, share0, unwrap);\n        _refundToken(token1, to, share1, unwrap);\n    }\n\n    function _refundToken(\n        address token,\n        address to,\n        uint256 share,\n        bool unwrap\n    ) public payable {\n        require(msg.sender == address(this), 'TD00');\n        if (token == tokenShares.weth && unwrap) {\n            uint256 amount = tokenShares.sharesToAmount(token, share, 0, to);\n            IWETH(tokenShares.weth).withdraw(amount);\n            TransferHelper.safeTransferETH(to, amount, orders.transferGasCosts[address(0)]);\n        } else {\n            TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share, 0, to));\n        }\n    }\n\n    function _refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity\n    ) external payable {\n        require(msg.sender == address(this), 'TD00');\n        return TransferHelper.safeTransfer(pair, to, liquidity);\n    }\n\n    function _executeDeposit(\n        Orders.DepositOrder calldata depositOrder,\n        uint256 amountLimit0,\n        uint256 amountLimit1\n    ) external payable {\n        require(msg.sender == address(this), 'TD00');\n        require(depositOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (\n            Orders.PairInfo memory pairInfo,\n            uint256 amount0Left,\n            uint256 amount1Left,\n            uint256 swapToken\n        ) = _initialDeposit(depositOrder, amountLimit0, amountLimit1);\n        if (depositOrder.swap && swapToken != 0) {\n            bytes memory data = encodePriceInfo(pairInfo.pair, depositOrder.priceAccumulator, depositOrder.timestamp);\n            if (amount0Left != 0 && swapToken == 1) {\n                uint256 extraAmount1;\n                (amount0Left, extraAmount1) = AddLiquidity.swapDeposit0(\n                    pairInfo.pair,\n                    pairInfo.token0,\n                    amount0Left,\n                    depositOrder.minSwapPrice,\n                    tolerance[pairInfo.pair],\n                    data\n                );\n                amount1Left = amount1Left.add(extraAmount1);\n            } else if (amount1Left != 0 && swapToken == 2) {\n                uint256 extraAmount0;\n                (extraAmount0, amount1Left) = AddLiquidity.swapDeposit1(\n                    pairInfo.pair,\n                    pairInfo.token1,\n                    amount1Left,\n                    depositOrder.maxSwapPrice,\n                    tolerance[pairInfo.pair],\n                    data\n                );\n                amount0Left = amount0Left.add(extraAmount0);\n            }\n        }\n\n        if (amount0Left != 0 && amount1Left != 0) {\n            (amount0Left, amount1Left, ) = AddLiquidity.addLiquidityAndMint(\n                pairInfo.pair,\n                depositOrder.to,\n                pairInfo.token0,\n                pairInfo.token1,\n                amount0Left,\n                amount1Left\n            );\n        }\n\n        AddLiquidity._refundDeposit(depositOrder.to, pairInfo.token0, pairInfo.token1, amount0Left, amount1Left);\n    }\n\n    function _initialDeposit(\n        Orders.DepositOrder calldata depositOrder,\n        uint256 amountLimit0,\n        uint256 amountLimit1\n    )\n        private\n        returns (\n            Orders.PairInfo memory pairInfo,\n            uint256 amount0Left,\n            uint256 amount1Left,\n            uint256 swapToken\n        )\n    {\n        pairInfo = orders.pairs[depositOrder.pairId];\n        uint256 amount0Desired = tokenShares.sharesToAmount(\n            pairInfo.token0,\n            depositOrder.share0,\n            amountLimit0,\n            depositOrder.to\n        );\n        uint256 amount1Desired = tokenShares.sharesToAmount(\n            pairInfo.token1,\n            depositOrder.share1,\n            amountLimit1,\n            depositOrder.to\n        );\n        ITwapPair(pairInfo.pair).sync();\n        (amount0Left, amount1Left, swapToken) = AddLiquidity.addLiquidityAndMint(\n            pairInfo.pair,\n            depositOrder.to,\n            pairInfo.token0,\n            pairInfo.token1,\n            amount0Desired,\n            amount1Desired\n        );\n    }\n\n    function _executeWithdraw(Orders.WithdrawOrder calldata withdrawOrder) external payable {\n        require(msg.sender == address(this), 'TD00');\n        require(withdrawOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n        (address pair, address token0, address token1) = orders.getPairInfo(withdrawOrder.pairId);\n        ITwapPair(pair).sync();\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\n        uint256 wethAmount;\n        uint256 amount0;\n        uint256 amount1;\n        if (withdrawOrder.unwrap && (token0 == tokenShares.weth || token1 == tokenShares.weth)) {\n            bool success;\n            (success, wethAmount, amount0, amount1) = WithdrawHelper.withdrawAndUnwrap(\n                token0,\n                token1,\n                pair,\n                tokenShares.weth,\n                withdrawOrder.to,\n                orders.transferGasCosts[address(0)]\n            );\n            if (!success) {\n                tokenShares.onUnwrapFailed(withdrawOrder.to, wethAmount);\n            }\n        } else {\n            (amount0, amount1) = ITwapPair(pair).burn(withdrawOrder.to);\n        }\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'TD03');\n    }\n\n    function _executeBuy(Orders.BuyOrder calldata buyOrder, uint256 amountLimit) external payable {\n        require(msg.sender == address(this), 'TD00');\n        require(buyOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(buyOrder.pairId, buyOrder.inverse);\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax, amountLimit, buyOrder.to);\n        ITwapPair(pairAddress).sync();\n        bytes memory priceInfo = encodePriceInfo(pairAddress, buyOrder.priceAccumulator, buyOrder.timestamp);\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 reserveOut;\n        {\n            // scope for reserve out logic, avoids stack too deep errors\n            (uint112 reserve0, uint112 reserve1) = ITwapPair(pairAddress).getReserves();\n            // subtract 1 to prevent reserve going to 0\n            reserveOut = uint256(buyOrder.inverse ? reserve0 : reserve1).sub(1);\n        }\n        {\n            // scope for partial fill logic, avoids stack too deep errors\n            address oracle = ITwapPair(pairAddress).oracle();\n            uint256 swapFee = ITwapPair(pairAddress).swapFee();\n            (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMaxOut(\n                buyOrder.inverse,\n                swapFee,\n                buyOrder.amountOut,\n                priceInfo\n            );\n            uint256 amountInMaxScaled;\n            if (amountOut > reserveOut) {\n                amountInMaxScaled = amountInMax.mul(reserveOut).ceil_div(buyOrder.amountOut);\n                (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMinOut(\n                    buyOrder.inverse,\n                    swapFee,\n                    reserveOut,\n                    priceInfo\n                );\n            } else {\n                amountInMaxScaled = amountInMax;\n                amountOut = buyOrder.amountOut; // Truncate to desired out\n            }\n            require(amountInMaxScaled >= amountIn, 'TD08');\n            if (amountInMax > amountIn) {\n                if (tokenIn == tokenShares.weth && buyOrder.unwrap) {\n                    _forceEtherTransfer(buyOrder.to, amountInMax.sub(amountIn));\n                } else {\n                    TransferHelper.safeTransfer(tokenIn, buyOrder.to, amountInMax.sub(amountIn));\n                }\n            }\n            TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        }\n        amountOut = amountOut.sub(tolerance[pairAddress]);\n        uint256 amount0Out;\n        uint256 amount1Out;\n        if (buyOrder.inverse) {\n            amount0Out = amountOut;\n        } else {\n            amount1Out = amountOut;\n        }\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\n            ITwapPair(pairAddress).swap(amount0Out, amount1Out, address(this), priceInfo);\n            _forceEtherTransfer(buyOrder.to, amountOut);\n        } else {\n            ITwapPair(pairAddress).swap(amount0Out, amount1Out, buyOrder.to, priceInfo);\n        }\n    }\n\n    function _executeSell(Orders.SellOrder calldata sellOrder, uint256 amountLimit) external payable {\n        require(msg.sender == address(this), 'TD00');\n        require(sellOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\n\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(\n            sellOrder.pairId,\n            sellOrder.inverse\n        );\n        ITwapPair(pairAddress).sync();\n        bytes memory priceInfo = encodePriceInfo(pairAddress, sellOrder.priceAccumulator, sellOrder.timestamp);\n\n        uint256 amountOut = _executeSellHelper(sellOrder, amountLimit, pairAddress, tokenIn, priceInfo);\n\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\n            ? (amountOut, uint256(0))\n            : (uint256(0), amountOut);\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\n            ITwapPair(pairAddress).swap(amount0Out, amount1Out, address(this), priceInfo);\n            _forceEtherTransfer(sellOrder.to, amountOut);\n        } else {\n            ITwapPair(pairAddress).swap(amount0Out, amount1Out, sellOrder.to, priceInfo);\n        }\n    }\n\n    function _executeSellHelper(\n        Orders.SellOrder calldata sellOrder,\n        uint256 amountLimit,\n        address pairAddress,\n        address tokenIn,\n        bytes memory priceInfo\n    ) internal returns (uint256 amountOut) {\n        uint256 reserveOut;\n        {\n            // scope for determining reserve out, avoids stack too deep errors\n            (uint112 reserve0, uint112 reserve1) = ITwapPair(pairAddress).getReserves();\n            // subtract 1 to prevent reserve going to 0\n            reserveOut = uint256(sellOrder.inverse ? reserve0 : reserve1).sub(1);\n        }\n        {\n            // scope for calculations, avoids stack too deep errors\n            address oracle = ITwapPair(pairAddress).oracle();\n            uint256 swapFee = ITwapPair(pairAddress).swapFee();\n            uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn, amountLimit, sellOrder.to);\n            amountOut = sellOrder.inverse\n                ? ITwapOracle(oracle).getSwapAmount0Out(swapFee, amountIn, priceInfo)\n                : ITwapOracle(oracle).getSwapAmount1Out(swapFee, amountIn, priceInfo);\n\n            uint256 amountOutMinScaled;\n            if (amountOut > reserveOut) {\n                amountOutMinScaled = sellOrder.amountOutMin.mul(reserveOut).div(amountOut);\n                uint256 _amountIn = amountIn;\n                (amountIn, amountOut) = ITwapOracle(oracle).getSwapAmountInMinOut(\n                    sellOrder.inverse,\n                    swapFee,\n                    reserveOut,\n                    priceInfo\n                );\n                if (tokenIn == tokenShares.weth && sellOrder.unwrap) {\n                    _forceEtherTransfer(sellOrder.to, _amountIn.sub(amountIn));\n                } else {\n                    TransferHelper.safeTransfer(tokenIn, sellOrder.to, _amountIn.sub(amountIn));\n                }\n            } else {\n                amountOutMinScaled = sellOrder.amountOutMin;\n            }\n            amountOut = amountOut.sub(tolerance[pairAddress]);\n            require(amountOut >= amountOutMinScaled, 'TD37');\n            TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        }\n    }\n\n    function _getPairAndTokens(uint32 pairId, bool pairInversed)\n        private\n        view\n        returns (\n            address,\n            address,\n            address\n        )\n    {\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(pairId);\n        (address tokenIn, address tokenOut) = pairInversed ? (token1, token0) : (token0, token1);\n        return (pairAddress, tokenIn, tokenOut);\n    }\n\n    function _forceEtherTransfer(address to, uint256 amount) internal {\n        IWETH(tokenShares.weth).withdraw(amount);\n        (bool success, ) = to.call{ value: amount, gas: orders.transferGasCosts[address(0)] }('');\n        if (!success) {\n            tokenShares.onUnwrapFailed(to, amount);\n        }\n    }\n\n    function performRefund(\n        Orders.OrderType orderType,\n        uint256 validAfterTimestamp,\n        uint256 orderId,\n        bool shouldRefundEth\n    ) internal {\n        require(orderType != Orders.OrderType.Empty, 'TD41');\n        bool canOwnerRefund = validAfterTimestamp.add(365 days) < block.timestamp;\n\n        if (orderType == Orders.OrderType.Deposit) {\n            (Orders.DepositOrder memory depositOrder, , ) = orders.getDepositOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\n            address to = canOwnerRefund ? owner : depositOrder.to;\n            require(\n                refundTokens(to, token0, depositOrder.share0, token1, depositOrder.share1, depositOrder.unwrap),\n                'TD14'\n            );\n            if (shouldRefundEth) {\n                require(refundEth(payable(to), depositOrder.gasPrice.mul(depositOrder.gasLimit)), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Withdraw) {\n            Orders.WithdrawOrder memory withdrawOrder = orders.getWithdrawOrder(orderId);\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\n            address to = canOwnerRefund ? owner : withdrawOrder.to;\n            require(Orders.refundLiquidity(pair, to, withdrawOrder.liquidity, this._refundLiquidity.selector), 'TD14');\n            if (shouldRefundEth) {\n                require(refundEth(payable(to), withdrawOrder.gasPrice.mul(withdrawOrder.gasLimit)), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Sell) {\n            (Orders.SellOrder memory sellOrder, ) = orders.getSellOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n            address to = canOwnerRefund ? owner : sellOrder.to;\n            require(refundToken(sellOrder.inverse ? token1 : token0, to, sellOrder.shareIn, sellOrder.unwrap), 'TD14');\n            if (shouldRefundEth) {\n                require(refundEth(payable(to), sellOrder.gasPrice.mul(sellOrder.gasLimit)), 'TD40');\n            }\n        } else if (orderType == Orders.OrderType.Buy) {\n            (Orders.BuyOrder memory buyOrder, ) = orders.getBuyOrder(orderId);\n            (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n            address to = canOwnerRefund ? owner : buyOrder.to;\n            require(refundToken(buyOrder.inverse ? token1 : token0, to, buyOrder.shareInMax, buyOrder.unwrap), 'TD14');\n            if (shouldRefundEth) {\n                require(refundEth(payable(to), buyOrder.gasPrice.mul(buyOrder.gasLimit)), 'TD40');\n            }\n        }\n        orders.forgetOrder(orderId);\n    }\n\n    function retryRefund(uint256 orderId) external override lock {\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getFailedOrderType(orderId);\n        performRefund(orderType, validAfterTimestamp, orderId, false);\n    }\n\n    function cancelOrder(uint256 orderId) external override lock {\n        require(orders.getOrderStatus(orderId) == Orders.OrderStatus.EnqueuedReady, 'TD52');\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getOrder(orderId);\n        require(validAfterTimestamp.sub(orders.delay).add(ORDER_CANCEL_TIME) < block.timestamp, 'TD1C');\n        orders.canceled[orderId] = true;\n        performRefund(orderType, validAfterTimestamp, orderId, true);\n    }\n\n    function encodePriceInfo(\n        address pair,\n        uint256 priceAccumulator,\n        uint32 priceTimestamp\n    ) internal view returns (bytes memory data) {\n        uint256 price = ITwapOracle(ITwapPair(pair).oracle()).getAveragePrice(priceAccumulator, priceTimestamp);\n        // Pack everything as 32 bytes / uint256 to simplify decoding\n        data = abi.encode(price);\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/ITwapDelay.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../libraries/Orders.sol';\n\ninterface ITwapDelay {\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\n    event OwnerSet(address owner);\n    event BotSet(address bot, bool isBot);\n    event DelaySet(uint256 delay);\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n    event ToleranceSet(address pair, uint16 amount);\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\n    event UnwrapFailed(address to, uint256 amount);\n    event Execute(address sender, uint256 n);\n\n    function factory() external returns (address);\n\n    function owner() external returns (address);\n\n    function isBot(address bot) external returns (bool);\n\n    function tolerance(address pair) external returns (uint16);\n\n    function gasPriceInertia() external returns (uint256);\n\n    function gasPrice() external returns (uint256);\n\n    function maxGasPriceImpact() external returns (uint256);\n\n    function maxGasLimit() external returns (uint256);\n\n    function delay() external returns (uint32);\n\n    function totalShares(address token) external returns (uint256);\n\n    function weth() external returns (address);\n\n    function getTransferGasCost(address token) external returns (uint256);\n\n    function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);\n\n    function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);\n\n    function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);\n\n    function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);\n\n    function getDepositDisabled(address pair) external returns (bool);\n\n    function getWithdrawDisabled(address pair) external returns (bool);\n\n    function getBuyDisabled(address pair) external returns (bool);\n\n    function getSellDisabled(address pair) external returns (bool);\n\n    function getOrderStatus(uint256 orderId) external view returns (Orders.OrderStatus);\n\n    function setOrderDisabled(\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external payable;\n\n    function setOwner(address _owner) external payable;\n\n    function setBot(address _bot, bool _isBot) external payable;\n\n    function setMaxGasLimit(uint256 _maxGasLimit) external payable;\n\n    function setDelay(uint32 _delay) external payable;\n\n    function setGasPriceInertia(uint256 _gasPriceInertia) external payable;\n\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external payable;\n\n    function setTransferGasCost(address token, uint256 gasCost) external payable;\n\n    function setTolerance(address pair, uint16 amount) external payable;\n\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\n\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\n\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\n\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\n\n    function execute(uint256 n) external payable;\n\n    function retryRefund(uint256 orderId) external;\n\n    function cancelOrder(uint256 orderId) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/libraries/TokenShares.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport '../interfaces/IERC20.sol';\nimport '../interfaces/IWETH.sol';\nimport './SafeMath.sol';\nimport './TransferHelper.sol';\n\nlibrary TokenShares {\n    using SafeMath for uint256;\n    using TransferHelper for address;\n\n    uint256 private constant PRECISION = 10**18;\n    uint256 private constant TOLERANCE = 10**18 + 10**16;\n\n    event UnwrapFailed(address to, uint256 amount);\n\n    struct Data {\n        mapping(address => uint256) totalShares;\n        address weth;\n    }\n\n    function sharesToAmount(\n        Data storage data,\n        address token,\n        uint256 share,\n        uint256 amountLimit,\n        address refundTo\n    ) external returns (uint256) {\n        if (share == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            return share;\n        }\n\n        uint256 totalTokenShares = data.totalShares[token];\n        require(totalTokenShares >= share, 'TS3A');\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        uint256 value = balance.mul(share).div(totalTokenShares);\n        data.totalShares[token] = totalTokenShares.sub(share);\n\n        if (amountLimit > 0) {\n            uint256 amountLimitWithTolerance = amountLimit.mul(TOLERANCE).div(PRECISION);\n            if (value > amountLimitWithTolerance) {\n                TransferHelper.safeTransfer(token, refundTo, value.sub(amountLimitWithTolerance));\n                return amountLimitWithTolerance;\n            }\n        }\n\n        return value;\n    }\n\n    function amountToShares(\n        Data storage data,\n        address token,\n        uint256 amount,\n        bool wrap\n    ) external returns (uint256) {\n        if (amount == 0) {\n            return 0;\n        }\n        if (token == data.weth) {\n            if (wrap) {\n                require(msg.value >= amount, 'TS03');\n                IWETH(token).deposit{ value: amount }();\n            } else {\n                token.safeTransferFrom(msg.sender, address(this), amount);\n            }\n            return amount;\n        } else {\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n            uint256 totalTokenShares = data.totalShares[token];\n            require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\n            if (totalTokenShares == 0) {\n                totalTokenShares = balanceBefore;\n            }\n            token.safeTransferFrom(msg.sender, address(this), amount);\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n            require(balanceAfter > balanceBefore, 'TS2C');\n            if (balanceBefore > 0) {\n                uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\n                data.totalShares[token] = newShares;\n                return newShares - totalTokenShares;\n            } else {\n                data.totalShares[token] = balanceAfter;\n                return balanceAfter;\n            }\n        }\n    }\n\n    function onUnwrapFailed(\n        Data storage data,\n        address to,\n        uint256 amount\n    ) external {\n        emit UnwrapFailed(to, amount);\n        IWETH(data.weth).deposit{ value: amount }();\n        TransferHelper.safeTransfer(data.weth, to, amount);\n    }\n}\n"
    },
    "contracts/interfaces/ITwapPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './ITwapERC20.sol';\nimport './IReserves.sol';\n\ninterface ITwapPair is ITwapERC20, IReserves {\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event SetMintFee(uint256 fee);\n    event SetBurnFee(uint256 fee);\n    event SetSwapFee(uint256 fee);\n    event SetOracle(address account);\n    event SetTrader(address trader);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function trader() external view returns (address);\n\n    function mintFee() external view returns (uint256);\n\n    function setMintFee(uint256 fee) external;\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burnFee() external view returns (uint256);\n\n    function setBurnFee(uint256 fee) external;\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swapFee() external view returns (uint256);\n\n    function setSwapFee(uint256 fee) external;\n\n    function setOracle(address account) external;\n\n    function setTrader(address account) external;\n\n    function collect(address to) external;\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function sync() external;\n\n    function initialize(\n        address _token0,\n        address _token1,\n        address _oracle,\n        address _trader\n    ) external;\n\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\n\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\n\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\n\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\n\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\n\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\n}\n"
    },
    "contracts/libraries/Orders.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport './SafeMath.sol';\nimport '../libraries/Math.sol';\nimport '../interfaces/ITwapFactory.sol';\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/ITwapOracle.sol';\nimport '../libraries/TokenShares.sol';\n\nlibrary Orders {\n    using SafeMath for uint256;\n    using TokenShares for TokenShares.Data;\n    using TransferHelper for address;\n\n    enum OrderType {\n        Empty,\n        Deposit,\n        Withdraw,\n        Sell,\n        Buy\n    }\n    enum OrderStatus {\n        NonExistent,\n        EnqueuedWaiting,\n        EnqueuedReady,\n        ExecutedSucceeded,\n        ExecutedFailed,\n        Canceled\n    }\n\n    event MaxGasLimitSet(uint256 maxGasLimit);\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\n    event TransferGasCostSet(address token, uint256 gasCost);\n\n    event DepositEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event WithdrawEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event SellEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n    event BuyEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\n\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\n\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\n\n    uint8 private constant DEPOSIT_TYPE = 1;\n    uint8 private constant WITHDRAW_TYPE = 2;\n    uint8 private constant BUY_TYPE = 3;\n    uint8 private constant BUY_INVERTED_TYPE = 4;\n    uint8 private constant SELL_TYPE = 5;\n    uint8 private constant SELL_INVERTED_TYPE = 6;\n\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\n    uint8 private constant KEEP_NOT_FAILED = 1;\n    uint8 private constant UNWRAP_FAILED = 2;\n    uint8 private constant KEEP_FAILED = 3;\n\n    uint256 private constant ETHER_TRANSFER_COST = 2600 + 1504; // EIP-2929 acct access cost + Gnosis Safe receive ETH cost\n    uint256 private constant BUFFER_COST = 10000;\n    uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\n\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\n    uint256 public constant REFUND_BASE_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;\n\n    // Masks used for setting order disabled\n    // Different bits represent different order types\n    uint8 private constant DEPOSIT_MASK = uint8(1 << uint8(OrderType.Deposit)); //   00000010\n    uint8 private constant WITHDRAW_MASK = uint8(1 << uint8(OrderType.Withdraw)); // 00000100\n    uint8 private constant SELL_MASK = uint8(1 << uint8(OrderType.Sell)); //         00001000\n    uint8 private constant BUY_MASK = uint8(1 << uint8(OrderType.Buy)); //           00010000\n\n    struct PairInfo {\n        address pair;\n        address token0;\n        address token1;\n    }\n\n    struct Data {\n        uint32 delay;\n        uint256 newestOrderId;\n        uint256 lastProcessedOrderId;\n        mapping(uint256 => StoredOrder) orderQueue;\n        address factory;\n        uint256 maxGasLimit;\n        uint256 gasPrice;\n        uint256 gasPriceInertia;\n        uint256 maxGasPriceImpact;\n        mapping(uint32 => PairInfo) pairs;\n        mapping(address => uint256) transferGasCosts;\n        mapping(uint256 => bool) canceled;\n        // Bit on specific positions indicates whether order type is disabled (1) or enabled (0) on specific pair\n        mapping(address => uint8) orderDisabled;\n    }\n\n    struct StoredOrder {\n        // slot 0\n        uint8 orderType;\n        uint32 validAfterTimestamp;\n        uint8 unwrapAndFailure;\n        uint32 timestamp;\n        uint32 gasLimit;\n        uint32 gasPrice;\n        uint112 liquidity;\n        // slot 1\n        uint112 value0;\n        uint112 value1;\n        uint32 pairId;\n        // slot2\n        address to;\n        uint32 minSwapPrice;\n        uint32 maxSwapPrice;\n        bool swap;\n        // slot3\n        uint256 priceAccumulator;\n        // slot4\n        uint112 amountLimit0;\n        uint112 amountLimit1;\n    }\n\n    struct DepositOrder {\n        uint32 pairId;\n        uint256 share0;\n        uint256 share1;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool unwrap;\n        bool swap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    struct WithdrawOrder {\n        uint32 pairId;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n    }\n\n    struct SellOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareIn;\n        uint256 amountOutMin;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    struct BuyOrder {\n        uint32 pairId;\n        bool inverse;\n        uint256 shareInMax;\n        uint256 amountOut;\n        bool unwrap;\n        address to;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        uint32 validAfterTimestamp;\n        uint256 priceAccumulator;\n        uint32 timestamp;\n    }\n\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\n        if (internalType == DEPOSIT_TYPE) {\n            orderType = OrderType.Deposit;\n        } else if (internalType == WITHDRAW_TYPE) {\n            orderType = OrderType.Withdraw;\n        } else if (internalType == BUY_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == BUY_INVERTED_TYPE) {\n            orderType = OrderType.Buy;\n        } else if (internalType == SELL_TYPE) {\n            orderType = OrderType.Sell;\n        } else if (internalType == SELL_INVERTED_TYPE) {\n            orderType = OrderType.Sell;\n        } else {\n            orderType = OrderType.Empty;\n        }\n    }\n\n    function getOrder(Data storage data, uint256 orderId)\n        internal\n        view\n        returns (OrderType orderType, uint32 validAfterTimestamp)\n    {\n        StoredOrder storage order = data.orderQueue[orderId];\n        validAfterTimestamp = order.validAfterTimestamp;\n        orderType = decodeType(order.orderType);\n    }\n\n    function getOrderStatus(Data storage data, uint256 orderId) internal view returns (OrderStatus orderStatus) {\n        if (orderId > data.newestOrderId) {\n            return OrderStatus.NonExistent;\n        }\n        if (data.canceled[orderId]) {\n            return OrderStatus.Canceled;\n        }\n        if (isRefundFailed(data, orderId)) {\n            return OrderStatus.ExecutedFailed;\n        }\n        (OrderType orderType, uint32 validAfterTimestamp) = getOrder(data, orderId);\n        if (orderType == OrderType.Empty) {\n            return OrderStatus.ExecutedSucceeded;\n        }\n        if (validAfterTimestamp >= block.timestamp) {\n            return OrderStatus.EnqueuedWaiting;\n        }\n        return OrderStatus.EnqueuedReady;\n    }\n\n    function getPair(\n        Data storage data,\n        address tokenA,\n        address tokenB\n    )\n        internal\n        returns (\n            address pair,\n            uint32 pairId,\n            bool inverted\n        )\n    {\n        inverted = tokenA > tokenB;\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\n        pair = ITwapFactory(data.factory).getPair(token0, token1);\n        require(pair != address(0), 'OS17');\n        pairId = uint32(bytes4(keccak256(abi.encodePacked(pair))));\n        if (data.pairs[pairId].pair == address(0)) {\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\n        }\n    }\n\n    function getPairInfo(Data storage data, uint32 pairId)\n        internal\n        view\n        returns (\n            address pair,\n            address token0,\n            address token1\n        )\n    {\n        PairInfo storage info = data.pairs[pairId];\n        pair = info.pair;\n        token0 = info.token0;\n        token1 = info.token1;\n    }\n\n    function getDepositDisabled(Data storage data, address pair) internal view returns (bool) {\n        return data.orderDisabled[pair] & DEPOSIT_MASK != 0;\n    }\n\n    function getWithdrawDisabled(Data storage data, address pair) internal view returns (bool) {\n        return data.orderDisabled[pair] & WITHDRAW_MASK != 0;\n    }\n\n    function getSellDisabled(Data storage data, address pair) internal view returns (bool) {\n        return data.orderDisabled[pair] & SELL_MASK != 0;\n    }\n\n    function getBuyDisabled(Data storage data, address pair) internal view returns (bool) {\n        return data.orderDisabled[pair] & BUY_MASK != 0;\n    }\n\n    function getDepositOrder(Data storage data, uint256 index)\n        public\n        view\n        returns (\n            DepositOrder memory order,\n            uint256 amountLimit0,\n            uint256 amountLimit1\n        )\n    {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == DEPOSIT_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.share0 = stored.value0;\n        order.share1 = stored.value1;\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.swap = stored.swap;\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n        order.timestamp = stored.timestamp;\n\n        amountLimit0 = stored.amountLimit0;\n        amountLimit1 = stored.amountLimit1;\n    }\n\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == WITHDRAW_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.liquidity = stored.liquidity;\n        order.amount0Min = stored.value0;\n        order.amount1Min = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n    }\n\n    function getSellOrder(Data storage data, uint256 index)\n        public\n        view\n        returns (SellOrder memory order, uint256 amountLimit)\n    {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\n        order.shareIn = stored.value0;\n        order.amountOutMin = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n        order.timestamp = stored.timestamp;\n\n        amountLimit = stored.amountLimit0;\n    }\n\n    function getBuyOrder(Data storage data, uint256 index)\n        public\n        view\n        returns (BuyOrder memory order, uint256 amountLimit)\n    {\n        StoredOrder memory stored = data.orderQueue[index];\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS32');\n        order.pairId = stored.pairId;\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\n        order.shareInMax = stored.value0;\n        order.amountOut = stored.value1;\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\n        order.to = stored.to;\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\n        order.gasLimit = stored.gasLimit;\n        order.validAfterTimestamp = stored.validAfterTimestamp;\n        order.timestamp = stored.timestamp;\n        order.priceAccumulator = stored.priceAccumulator;\n\n        amountLimit = stored.amountLimit0;\n    }\n\n    function getFailedOrderType(Data storage data, uint256 orderId)\n        internal\n        view\n        returns (OrderType orderType, uint32 validAfterTimestamp)\n    {\n        require(isRefundFailed(data, orderId), 'OS21');\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\n    }\n\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\n    }\n\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\n    }\n\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\n        if (timestamp == type(uint256).max) {\n            return type(uint32).max;\n        }\n        timestamp32 = timestamp.toUint32();\n    }\n\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS3C');\n        gasPrice32 = (gasPrice / 1e6).toUint32();\n    }\n\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\n        gasPrice = uint256(gasPrice32) * 1e6;\n    }\n\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // If the number fits in the mantissa we set the exponent to zero and return.\n        if (number < 1 << 24) {\n            return uint32(number << 8);\n        }\n        // We find the exponent by counting the number of trailing zeroes.\n        // Simultaneously we remove those zeroes from the number.\n        uint32 exponent;\n        for (; exponent < 256 - 24; ++exponent) {\n            // Last bit is one.\n            if (number & 1 == 1) {\n                break;\n            }\n            number = number >> 1;\n        }\n        // The number must fit in the mantissa.\n        require(number < 1 << 24, 'OS1A');\n        // Set the first three bytes to the number and the fourth to the exponent.\n        float32 = uint32(number << 8) | exponent;\n    }\n\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\n        // We get the exponent by extracting the last byte.\n        uint256 exponent = float32 & 0xFF;\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\n        require(exponent <= 256 - 24, 'OS1B');\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\n        // We add exponent number zeroes after the mantissa.\n        number = mantissa << exponent;\n    }\n\n    function setOrderDisabled(\n        Data storage data,\n        address pair,\n        Orders.OrderType orderType,\n        bool disabled\n    ) external {\n        require(orderType != Orders.OrderType.Empty, 'OS32');\n        uint8 currentSettings = data.orderDisabled[pair];\n\n        // zeros with 1 bit set at position specified by orderType\n        uint8 mask = uint8(1 << uint8(orderType));\n\n        // set/unset a bit accordingly to 'disabled' value\n        if (disabled) {\n            // OR operation to disable order\n            // e.g. for disable DEPOSIT\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\n            // mask for DEPOSIT  = 00000010\n            // the result of OR  = 00010110\n            currentSettings = currentSettings | mask;\n        } else {\n            // AND operation with a mask negation to enable order\n            // e.g. for enable DEPOSIT\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\n            // 0xff              = 11111111\n            // mask for Deposit  = 00000010\n            // mask negation     = 11111101\n            // the result of AND = 00010100\n            currentSettings = currentSettings & (mask ^ 0xff);\n        }\n        require(currentSettings != data.orderDisabled[pair], 'OS01');\n        data.orderDisabled[pair] = currentSettings;\n\n        emit OrderDisabled(pair, orderType, disabled);\n    }\n\n    function enqueueDepositOrder(\n        Data storage data,\n        DepositOrder memory depositOrder,\n        uint256 amountIn0,\n        uint256 amountIn1\n    ) internal {\n        ++data.newestOrderId;\n        emit DepositEnqueued(data.newestOrderId, depositOrder.validAfterTimestamp, depositOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            DEPOSIT_TYPE,\n            depositOrder.validAfterTimestamp,\n            getUnwrapAndFailure(depositOrder.unwrap),\n            depositOrder.timestamp,\n            depositOrder.gasLimit.toUint32(),\n            gasPriceToUint32(depositOrder.gasPrice),\n            0, // liquidity\n            depositOrder.share0.toUint112(),\n            depositOrder.share1.toUint112(),\n            depositOrder.pairId,\n            depositOrder.to,\n            uintToFloat32(depositOrder.minSwapPrice),\n            uintToFloat32(depositOrder.maxSwapPrice),\n            depositOrder.swap,\n            depositOrder.priceAccumulator,\n            amountIn0.toUint112(),\n            amountIn1.toUint112()\n        );\n    }\n\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\n        ++data.newestOrderId;\n        emit WithdrawEnqueued(data.newestOrderId, withdrawOrder.validAfterTimestamp, withdrawOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            WITHDRAW_TYPE,\n            withdrawOrder.validAfterTimestamp,\n            getUnwrapAndFailure(withdrawOrder.unwrap),\n            0, // timestamp\n            withdrawOrder.gasLimit.toUint32(),\n            gasPriceToUint32(withdrawOrder.gasPrice),\n            withdrawOrder.liquidity.toUint112(),\n            withdrawOrder.amount0Min.toUint112(),\n            withdrawOrder.amount1Min.toUint112(),\n            withdrawOrder.pairId,\n            withdrawOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            0, // priceAccumulator\n            0, // amountLimit0\n            0 // amountLimit1\n        );\n    }\n\n    function enqueueSellOrder(\n        Data storage data,\n        SellOrder memory sellOrder,\n        uint256 amountIn\n    ) internal {\n        ++data.newestOrderId;\n        emit SellEnqueued(data.newestOrderId, sellOrder.validAfterTimestamp, sellOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\n            sellOrder.validAfterTimestamp,\n            getUnwrapAndFailure(sellOrder.unwrap),\n            sellOrder.timestamp,\n            sellOrder.gasLimit.toUint32(),\n            gasPriceToUint32(sellOrder.gasPrice),\n            0, // liquidity\n            sellOrder.shareIn.toUint112(),\n            sellOrder.amountOutMin.toUint112(),\n            sellOrder.pairId,\n            sellOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            sellOrder.priceAccumulator,\n            amountIn.toUint112(),\n            0 // amountLimit1\n        );\n    }\n\n    function enqueueBuyOrder(\n        Data storage data,\n        BuyOrder memory buyOrder,\n        uint256 amountInMax\n    ) internal {\n        ++data.newestOrderId;\n        emit BuyEnqueued(data.newestOrderId, buyOrder.validAfterTimestamp, buyOrder.gasPrice);\n        data.orderQueue[data.newestOrderId] = StoredOrder(\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\n            buyOrder.validAfterTimestamp,\n            getUnwrapAndFailure(buyOrder.unwrap),\n            buyOrder.timestamp,\n            buyOrder.gasLimit.toUint32(),\n            gasPriceToUint32(buyOrder.gasPrice),\n            0, // liquidity\n            buyOrder.shareInMax.toUint112(),\n            buyOrder.amountOut.toUint112(),\n            buyOrder.pairId,\n            buyOrder.to,\n            0, // minSwapPrice\n            0, // maxSwapPrice\n            false, // swap\n            buyOrder.priceAccumulator,\n            amountInMax.toUint112(),\n            0 // amountLimit1\n        );\n    }\n\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\n    }\n\n    function markRefundFailed(Data storage data) internal {\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\n    }\n\n    struct DepositParams {\n        address token0;\n        address token1;\n        uint256 amount0;\n        uint256 amount1;\n        uint256 minSwapPrice;\n        uint256 maxSwapPrice;\n        bool wrap;\n        bool swap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function deposit(\n        Data storage data,\n        DepositParams calldata depositParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        {\n            // scope for checks, avoids stack too deep errors\n            uint256 token0TransferCost = data.transferGasCosts[depositParams.token0];\n            uint256 token1TransferCost = data.transferGasCosts[depositParams.token1];\n            require(token0TransferCost != 0 && token1TransferCost != 0, 'OS0F');\n            checkOrderParams(\n                data,\n                depositParams.to,\n                depositParams.gasLimit,\n                depositParams.submitDeadline,\n                ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost)\n            );\n        }\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\n        require(!getDepositDisabled(data, pairAddress), 'OS46');\n        {\n            // scope for value, avoids stack too deep errors\n            uint256 value = msg.value;\n\n            // allocate gas refund\n            if (depositParams.wrap) {\n                if (depositParams.token0 == tokenShares.weth) {\n                    value = msg.value.sub(depositParams.amount0, 'OS1E');\n                } else if (depositParams.token1 == tokenShares.weth) {\n                    value = msg.value.sub(depositParams.amount1, 'OS1E');\n                }\n            }\n            allocateGasRefund(data, value, depositParams.gasLimit);\n        }\n\n        uint256 shares0 = tokenShares.amountToShares(\n            inverted ? depositParams.token1 : depositParams.token0,\n            inverted ? depositParams.amount1 : depositParams.amount0,\n            depositParams.wrap\n        );\n        uint256 shares1 = tokenShares.amountToShares(\n            inverted ? depositParams.token0 : depositParams.token1,\n            inverted ? depositParams.amount0 : depositParams.amount1,\n            depositParams.wrap\n        );\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueDepositOrder(\n            data,\n            DepositOrder(\n                pairId,\n                shares0,\n                shares1,\n                depositParams.minSwapPrice,\n                depositParams.maxSwapPrice,\n                depositParams.wrap,\n                depositParams.swap,\n                depositParams.to,\n                data.gasPrice,\n                depositParams.gasLimit,\n                timestamp + data.delay, // validAfterTimestamp\n                priceAccumulator,\n                timestamp\n            ),\n            inverted ? depositParams.amount1 : depositParams.amount0,\n            inverted ? depositParams.amount0 : depositParams.amount1\n        );\n    }\n\n    struct WithdrawParams {\n        address token0;\n        address token1;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        bool unwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\n        require(!getWithdrawDisabled(data, pair), 'OS0A');\n        checkOrderParams(\n            data,\n            withdrawParams.to,\n            withdrawParams.gasLimit,\n            withdrawParams.submitDeadline,\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\n        );\n        require(withdrawParams.liquidity != 0, 'OS22');\n\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\n        enqueueWithdrawOrder(\n            data,\n            WithdrawOrder(\n                pairId,\n                withdrawParams.liquidity,\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\n                withdrawParams.unwrap,\n                withdrawParams.to,\n                data.gasPrice,\n                withdrawParams.gasLimit,\n                timestampToUint32(block.timestamp) + data.delay\n            )\n        );\n    }\n\n    struct SellParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function sell(\n        Data storage data,\n        SellParams calldata sellParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        uint256 tokenTransferCost = data.transferGasCosts[sellParams.tokenIn];\n        require(tokenTransferCost != 0, 'OS0F');\n        checkOrderParams(\n            data,\n            sellParams.to,\n            sellParams.gasLimit,\n            sellParams.submitDeadline,\n            ORDER_BASE_COST.add(tokenTransferCost)\n        );\n        require(sellParams.amountIn != 0, 'OS24');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\n        require(!getSellDisabled(data, pairAddress), 'OS13');\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\n            value = msg.value.sub(sellParams.amountIn, 'OS1E');\n        }\n\n        allocateGasRefund(data, value, sellParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueSellOrder(\n            data,\n            SellOrder(\n                pairId,\n                inverted,\n                shares,\n                sellParams.amountOutMin,\n                sellParams.wrapUnwrap,\n                sellParams.to,\n                data.gasPrice,\n                sellParams.gasLimit,\n                timestamp + data.delay,\n                priceAccumulator,\n                timestamp\n            ),\n            sellParams.amountIn\n        );\n    }\n\n    struct BuyParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountInMax;\n        uint256 amountOut;\n        bool wrapUnwrap;\n        address to;\n        uint256 gasLimit;\n        uint32 submitDeadline;\n    }\n\n    function buy(\n        Data storage data,\n        BuyParams calldata buyParams,\n        TokenShares.Data storage tokenShares\n    ) external {\n        uint256 tokenTransferCost = data.transferGasCosts[buyParams.tokenIn];\n        require(tokenTransferCost != 0, 'OS0F');\n        checkOrderParams(\n            data,\n            buyParams.to,\n            buyParams.gasLimit,\n            buyParams.submitDeadline,\n            ORDER_BASE_COST.add(tokenTransferCost)\n        );\n        require(buyParams.amountOut != 0, 'OS23');\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\n        require(!getBuyDisabled(data, pairAddress), 'OS49');\n        uint256 value = msg.value;\n\n        // allocate gas refund\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\n            value = msg.value.sub(buyParams.amountInMax, 'OS1E');\n        }\n\n        allocateGasRefund(data, value, buyParams.gasLimit);\n\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\n\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\n        enqueueBuyOrder(\n            data,\n            BuyOrder(\n                pairId,\n                inverted,\n                shares,\n                buyParams.amountOut,\n                buyParams.wrapUnwrap,\n                buyParams.to,\n                data.gasPrice,\n                buyParams.gasLimit,\n                timestamp + data.delay,\n                priceAccumulator,\n                timestamp\n            ),\n            buyParams.amountInMax\n        );\n    }\n\n    function checkOrderParams(\n        Data storage data,\n        address to,\n        uint256 gasLimit,\n        uint32 submitDeadline,\n        uint256 minGasLimit\n    ) private view {\n        require(submitDeadline >= block.timestamp, 'OS04');\n        require(gasLimit <= data.maxGasLimit, 'OS3E');\n        require(gasLimit >= minGasLimit, 'OS3D');\n        require(to != address(0), 'OS26');\n    }\n\n    function allocateGasRefund(\n        Data storage data,\n        uint256 value,\n        uint256 gasLimit\n    ) private returns (uint256 futureFee) {\n        futureFee = data.gasPrice.mul(gasLimit);\n        require(value >= futureFee, 'OS1E');\n        if (value > futureFee) {\n            TransferHelper.safeTransferETH(msg.sender, value.sub(futureFee), data.transferGasCosts[address(0)]);\n        }\n    }\n\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\n            data.gasPriceInertia\n        );\n        // we lower the precision for gas savings in order queue\n        data.gasPrice = updated - (updated % 1e6);\n    }\n\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\n        require(_maxGasLimit != data.maxGasLimit, 'OS01');\n        require(_maxGasLimit <= 10000000, 'OS2B');\n        data.maxGasLimit = _maxGasLimit;\n        emit MaxGasLimitSet(_maxGasLimit);\n    }\n\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\n        require(_gasPriceInertia != data.gasPriceInertia, 'OS01');\n        require(_gasPriceInertia >= 1, 'OS35');\n        data.gasPriceInertia = _gasPriceInertia;\n        emit GasPriceInertiaSet(_gasPriceInertia);\n    }\n\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\n        require(_maxGasPriceImpact != data.maxGasPriceImpact, 'OS01');\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS33');\n        data.maxGasPriceImpact = _maxGasPriceImpact;\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\n    }\n\n    function setTransferGasCost(\n        Data storage data,\n        address token,\n        uint256 gasCost\n    ) external {\n        require(gasCost != data.transferGasCosts[token], 'OS01');\n        data.transferGasCosts[token] = gasCost;\n        emit TransferGasCostSet(token, gasCost);\n    }\n\n    function refundLiquidity(\n        address pair,\n        address to,\n        uint256 liquidity,\n        bytes4 selector\n    ) internal returns (bool) {\n        if (liquidity == 0) {\n            return true;\n        }\n        (bool success, bytes memory data) = address(this).call{ gas: PAIR_TRANSFER_COST }(\n            abi.encodeWithSelector(selector, pair, to, liquidity, false)\n        );\n        if (!success) {\n            emit RefundFailed(to, pair, liquidity, data);\n        }\n        return success;\n    }\n\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\n        return getOrder(data, data.lastProcessedOrderId + 1);\n    }\n\n    function dequeueCanceledOrder(Data storage data) internal {\n        ++data.lastProcessedOrderId;\n    }\n\n    function dequeueDepositOrder(Data storage data)\n        external\n        returns (\n            DepositOrder memory order,\n            uint256 amountLimit0,\n            uint256 amountLimit1\n        )\n    {\n        ++data.lastProcessedOrderId;\n        (order, amountLimit0, amountLimit1) = getDepositOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\n        ++data.lastProcessedOrderId;\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order, uint256 amountLimit) {\n        ++data.lastProcessedOrderId;\n        (order, amountLimit) = getSellOrder(data, data.lastProcessedOrderId);\n    }\n\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order, uint256 amountLimit) {\n        ++data.lastProcessedOrderId;\n        (order, amountLimit) = getBuyOrder(data, data.lastProcessedOrderId);\n    }\n\n    function forgetOrder(Data storage data, uint256 orderId) internal {\n        delete data.orderQueue[orderId];\n    }\n\n    function forgetLastProcessedOrder(Data storage data) internal {\n        delete data.orderQueue[data.lastProcessedOrderId];\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    int256 private constant _INT256_MIN = -2**255;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'SM4E');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = sub(x, y, 'SM12');\n    }\n\n    function sub(\n        uint256 x,\n        uint256 y,\n        string memory message\n    ) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, message);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, 'SM43');\n        return a / b;\n    }\n\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = div(a, b);\n        if (a != mul(b, c)) {\n            return add(c, 1);\n        }\n    }\n\n    function toUint32(uint256 n) internal pure returns (uint32) {\n        require(n <= type(uint32).max, 'SM50');\n        return uint32(n);\n    }\n\n    function toUint112(uint256 n) internal pure returns (uint112) {\n        require(n <= type(uint112).max, 'SM51');\n        return uint112(n);\n    }\n\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\n        require(unsigned <= uint256(type(int256).max), 'SM34');\n        signed = int256(unsigned);\n    }\n\n    // int256\n\n    function add(int256 a, int256 b) internal pure returns (int256 c) {\n        c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256 c) {\n        c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\n    }\n\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\n\n        c = a * b;\n        require(c / a == b, 'SM29');\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, 'SM43');\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\n\n        return a / b;\n    }\n\n    function neg_floor_div(int256 a, int256 b) internal pure returns (int256 c) {\n        c = div(a, b);\n        if ((a < 0 && b > 0) || (a >= 0 && b < 0)) {\n            if (a != mul(b, c)) {\n                c = sub(c, 1);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/AddLiquidity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './TransferHelper.sol';\nimport './SafeMath.sol';\nimport './Math.sol';\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/ITwapOracle.sol';\n\nlibrary AddLiquidity {\n    using SafeMath for uint256;\n\n    function addLiquidity(\n        address pair,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    )\n        internal\n        view\n        returns (\n            uint256 amount0,\n            uint256 amount1,\n            uint256 swapToken\n        )\n    {\n        if (amount0Desired == 0 || amount1Desired == 0) {\n            if (amount0Desired > 0) {\n                swapToken = 1;\n            } else if (amount1Desired > 0) {\n                swapToken = 2;\n            }\n            return (0, 0, swapToken);\n        }\n        (uint256 reserve0, uint256 reserve1) = ITwapPair(pair).getReserves();\n        if (reserve0 == 0 && reserve1 == 0) {\n            (amount0, amount1) = (amount0Desired, amount1Desired);\n        } else {\n            require(reserve0 > 0 && reserve1 > 0, 'AL07');\n            uint256 amount1Optimal = amount0Desired.mul(reserve1) / reserve0;\n            if (amount1Optimal <= amount1Desired) {\n                swapToken = 2;\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\n            } else {\n                uint256 amount0Optimal = amount1Desired.mul(reserve0) / reserve1;\n                assert(amount0Optimal <= amount0Desired);\n                swapToken = 1;\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\n            }\n\n            uint256 totalSupply = ITwapPair(pair).totalSupply();\n            uint256 liquidityOut = Math.min(amount0.mul(totalSupply) / reserve0, amount1.mul(totalSupply) / reserve1);\n            if (liquidityOut == 0) {\n                amount0 = 0;\n                amount1 = 0;\n            }\n        }\n    }\n\n    function addLiquidityAndMint(\n        address pair,\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired\n    )\n        external\n        returns (\n            uint256 amount0Left,\n            uint256 amount1Left,\n            uint256 swapToken\n        )\n    {\n        uint256 amount0;\n        uint256 amount1;\n        (amount0, amount1, swapToken) = addLiquidity(pair, amount0Desired, amount1Desired);\n        if (amount0 == 0 || amount1 == 0) {\n            return (amount0Desired, amount1Desired, swapToken);\n        }\n        TransferHelper.safeTransfer(token0, pair, amount0);\n        TransferHelper.safeTransfer(token1, pair, amount1);\n        ITwapPair(pair).mint(to);\n\n        amount0Left = amount0Desired.sub(amount0);\n        amount1Left = amount1Desired.sub(amount1);\n    }\n\n    function swapDeposit0(\n        address pair,\n        address token0,\n        uint256 amount0,\n        uint256 minSwapPrice,\n        uint16 tolerance,\n        bytes calldata data\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount0In = ITwapPair(pair).getDepositAmount0In(amount0, data);\n        amount1Left = ITwapPair(pair).getSwapAmount1Out(amount0In, data).sub(tolerance);\n        if (amount1Left == 0) {\n            return (amount0, amount1Left);\n        }\n        uint256 price = getPrice(amount0In, amount1Left, pair);\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL15');\n        TransferHelper.safeTransfer(token0, pair, amount0In);\n        ITwapPair(pair).swap(0, amount1Left, address(this), data);\n        amount0Left = amount0.sub(amount0In);\n    }\n\n    function swapDeposit1(\n        address pair,\n        address token1,\n        uint256 amount1,\n        uint256 maxSwapPrice,\n        uint16 tolerance,\n        bytes calldata data\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\n        uint256 amount1In = ITwapPair(pair).getDepositAmount1In(amount1, data);\n        amount0Left = ITwapPair(pair).getSwapAmount0Out(amount1In, data).sub(tolerance);\n        if (amount0Left == 0) {\n            return (amount0Left, amount1);\n        }\n        uint256 price = getPrice(amount0Left, amount1In, pair);\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL16');\n        TransferHelper.safeTransfer(token1, pair, amount1In);\n        ITwapPair(pair).swap(amount0Left, 0, address(this), data);\n        amount1Left = amount1.sub(amount1In);\n    }\n\n    function getPrice(\n        uint256 amount0,\n        uint256 amount1,\n        address pair\n    ) internal view returns (uint256) {\n        ITwapOracle oracle = ITwapOracle(ITwapPair(pair).oracle());\n        return amount1.mul(uint256(oracle.decimalsConverter())).div(amount0);\n    }\n\n    function _refundDeposit(\n        address to,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1\n    ) internal {\n        if (amount0 > 0) {\n            TransferHelper.safeTransfer(token0, to, amount0);\n        }\n        if (amount1 > 0) {\n            TransferHelper.safeTransfer(token1, to, amount1);\n        }\n    }\n}\n"
    },
    "contracts/libraries/WithdrawHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../interfaces/ITwapPair.sol';\nimport '../interfaces/IWETH.sol';\nimport './Orders.sol';\n\nlibrary WithdrawHelper {\n    using SafeMath for uint256;\n\n    function _transferToken(\n        uint256 balanceBefore,\n        address token,\n        address to\n    ) internal {\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\n        TransferHelper.safeTransfer(token, to, tokenAmount);\n    }\n\n    function _unwrapWeth(\n        uint256 ethAmount,\n        address weth,\n        address to,\n        uint256 gasLimit\n    ) internal returns (bool) {\n        IWETH(weth).withdraw(ethAmount);\n        (bool success, ) = to.call{ value: ethAmount, gas: gasLimit }('');\n        return success;\n    }\n\n    function withdrawAndUnwrap(\n        address token0,\n        address token1,\n        address pair,\n        address weth,\n        address to,\n        uint256 gasLimit\n    )\n        external\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        bool isToken0Weth = token0 == weth;\n        address otherToken = isToken0Weth ? token1 : token0;\n\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\n        (uint256 amount0, uint256 amount1) = ITwapPair(pair).burn(address(this));\n        _transferToken(balanceBefore, otherToken, to);\n\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to, gasLimit);\n\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ITwapOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface ITwapOracle {\n    event OwnerSet(address owner);\n    event UniswapPairSet(address uniswapPair);\n\n    function decimalsConverter() external view returns (int256);\n\n    function xDecimals() external view returns (uint8);\n\n    function yDecimals() external view returns (uint8);\n\n    function owner() external view returns (address);\n\n    function uniswapPair() external view returns (address);\n\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);\n\n    function getSpotPrice() external view returns (uint256);\n\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);\n\n    function setOwner(address _owner) external;\n\n    function setUniswapPair(address _uniswapPair) external;\n\n    function tradeX(\n        uint256 xAfter,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view returns (uint256 yAfter);\n\n    function tradeY(\n        uint256 yAfter,\n        uint256 yBefore,\n        uint256 xBefore,\n        bytes calldata data\n    ) external view returns (uint256 xAfter);\n\n    function depositTradeXIn(\n        uint256 xLeft,\n        uint256 xBefore,\n        uint256 yBefore,\n        bytes calldata data\n    ) external view returns (uint256 xIn);\n\n    function depositTradeYIn(\n        uint256 yLeft,\n        uint256 yBefore,\n        uint256 xBefore,\n        bytes calldata data\n    ) external view returns (uint256 yIn);\n\n    function getSwapAmount0Out(\n        uint256 swapFee,\n        uint256 amount1In,\n        bytes calldata data\n    ) external view returns (uint256 amount0Out);\n\n    function getSwapAmount1Out(\n        uint256 swapFee,\n        uint256 amount0In,\n        bytes calldata data\n    ) external view returns (uint256 amount1Out);\n\n    function getSwapAmountInMaxOut(\n        bool inverse,\n        uint256 swapFee,\n        uint256 _amountOut,\n        bytes calldata data\n    ) external view returns (uint256 amountIn, uint256 amountOut);\n\n    function getSwapAmountInMinOut(\n        bool inverse,\n        uint256 swapFee,\n        uint256 _amountOut,\n        bytes calldata data\n    ) external view returns (uint256 amountIn, uint256 amountOut);\n}\n"
    },
    "contracts/interfaces/ITwapFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface ITwapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n    event OwnerSet(address owner);\n\n    function owner() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        address oracle,\n        address trader\n    ) external returns (address pair);\n\n    function setOwner(address) external;\n\n    function setMintFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setBurnFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setSwapFee(\n        address tokenA,\n        address tokenB,\n        uint256 fee\n    ) external;\n\n    function setOracle(\n        address tokenA,\n        address tokenB,\n        address oracle\n    ) external;\n\n    function setTrader(\n        address tokenA,\n        address tokenB,\n        address trader\n    ) external;\n\n    function collect(\n        address tokenA,\n        address tokenB,\n        address to\n    ) external;\n\n    function withdraw(\n        address tokenA,\n        address tokenB,\n        uint256 amount,\n        address to\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITwapERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\nimport './IERC20.sol';\n\ninterface ITwapERC20 is IERC20 {\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IReserves.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IReserves {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Deployed with donations via Gitcoin GR9\n\npragma solidity 0.7.6;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\n    }\n\n    function safeTransferETH(\n        address to,\n        uint256 value,\n        uint256 gasLimit\n    ) internal {\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\n        require(success, 'TH3F');\n    }\n\n    function transferETH(\n        address to,\n        uint256 value,\n        uint256 gasLimit\n    ) internal returns (bool success) {\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {
      "contracts/libraries/AddLiquidity.sol": {
        "AddLiquidity": "0x0ec2323adafbebc6c80257c7359692bcceb0b3f1"
      },
      "contracts/libraries/Orders.sol": {
        "Orders": "0x9cb505f2b41aa426257ed2a0bba005fff0af9e9a"
      },
      "contracts/libraries/TokenShares.sol": {
        "TokenShares": "0x412da11751b0a36d03b060890f4e41b7ce32971e"
      },
      "contracts/libraries/WithdrawHelper.sol": {
        "WithdrawHelper": "0x6195015b38773f468dd43620dd5a64e9bb63c2e3"
      }
    }
  }
}}