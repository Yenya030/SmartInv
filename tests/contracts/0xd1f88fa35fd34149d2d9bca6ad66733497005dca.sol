{{
  "language": "Solidity",
  "sources": {
    "contracts/TwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/ITwapOracle.sol\";\n\nimport \"./external/IUniswapV2Pair.sol\";\nimport \"./external/UniswapV2OracleLibrary.sol\";\n\n/// @title TwapOracle\n/// @author Bluejay Core Team\n/// @notice TwapOracle provides a Time-Weighted Average Price (TWAP) of a Uniswap V2 pool.\n/// This is a fixed window oracle that recomputes the average price for the entire period once every period\n/// https://github.com/Uniswap/v2-periphery/blob/master/contracts/examples/ExampleOracleSimple.sol\ncontract TwapOracle is ITwapOracle {\n  /// @notice Minimum period which the oracle will compute the average price\n  uint256 public immutable period;\n\n  /// @notice Address of Uniswap V2 pool address which the average price will be computed for\n  IUniswapV2Pair public immutable pair;\n\n  /// @notice Cache of token0 on the Uniswap V2 pool\n  address public immutable token0;\n\n  /// @notice Cache of token1 on the Uniswap V2 pool\n  address public immutable token1;\n\n  /// @notice Last stored cumulative price of token 0\n  uint256 public price0CumulativeLast;\n\n  /// @notice Last stored cumulative price of token 1\n  uint256 public price1CumulativeLast;\n\n  /// @notice Timestamp where cumulative prices were last fetched\n  uint32 public blockTimestampLast;\n\n  /// @notice Average price of token 0, updated on `blockTimestampLast`\n  uint224 public price0Average;\n\n  /// @notice Average price of token 1, updated on `blockTimestampLast`\n  uint224 public price1Average;\n\n  /// @notice Constructor to initialize the contract\n  /// @param poolAddress Address of Uniswap V2 pool address which the average price will be computed for\n  /// @param _period Minimum period which the oracle will compute the average price\n  constructor(address poolAddress, uint256 _period) {\n    period = _period;\n    IUniswapV2Pair _pair = IUniswapV2Pair(poolAddress);\n    pair = _pair;\n    token0 = _pair.token0();\n    token1 = _pair.token1();\n    price0CumulativeLast = _pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\n    price1CumulativeLast = _pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\n    uint112 reserve0;\n    uint112 reserve1;\n    (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\n    require(reserve0 != 0 && reserve1 != 0, \"No liquidity in pool\"); // ensure that there's liquidity in the pair\n  }\n\n  // =============================== INTERNAL FUNCTIONS =================================\n\n  /// @notice Decode a UQ112x112 into a uint112 by truncating after the radix point\n  /// https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/FixedPoint.sol\n  function _decode144(uint256 num) internal pure returns (uint144) {\n    return uint144(num >> 112);\n  }\n\n  // =============================== PUBLIC FUNCTIONS =================================\n\n  /// @notice Update the average price of both tokens over the period elapsed\n  /// @dev This function can only be called after the minimum period have passed since the last update\n  function update() public override {\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n    require(timeElapsed >= period, \"Period not elapsed\");\n\n    unchecked {\n      price0Average = uint224(\n        (price0Cumulative - price0CumulativeLast) / timeElapsed\n      );\n      price1Average = uint224(\n        (price1Cumulative - price1CumulativeLast) / timeElapsed\n      );\n    }\n\n    price0CumulativeLast = price0Cumulative;\n    price1CumulativeLast = price1Cumulative;\n    blockTimestampLast = blockTimestamp;\n    emit UpdatedPrice(\n      price0Average,\n      price1Average,\n      price0CumulativeLast,\n      price1CumulativeLast\n    );\n  }\n\n  /// @notice Non-reverting function to update the average prices\n  function tryUpdate() public override {\n    if (\n      UniswapV2OracleLibrary.currentBlockTimestamp() - blockTimestampLast >=\n      period\n    ) {\n      update();\n    }\n  }\n\n  // =============================== STATIC CALL QUERY FUNCTIONS =================================\n\n  /// @notice Non-reverting function to update the average prices and returning the prices\n  /// @dev Use static call on this function to get the latest average price.\n  /// Note that this will always return 0 before update has been called successfully for the first time.\n  /// @param token Address of input token\n  /// @param amountIn Amount of tokens input\n  /// @return amountOut Amount of tokens output after the swap using the average price\n  function updateAndConsult(address token, uint256 amountIn)\n    public\n    override\n    returns (uint256 amountOut)\n  {\n    tryUpdate();\n    return consult(token, amountIn);\n  }\n\n  // =============================== VIEW FUNCTIONS =================================\n\n  /// @notice Get the swap output of the token using the average price\n  /// @dev Note that this will always return 0 before update has been called successfully for the first time.\n  /// @param token Address of input token\n  /// @param amountIn Amount of tokens input\n  /// @return amountOut Amount of tokens output after the swap using the average price\n  function consult(address token, uint256 amountIn)\n    public\n    view\n    override\n    returns (uint256 amountOut)\n  {\n    if (token == token0) {\n      amountOut = _decode144(price0Average * amountIn);\n    } else {\n      require(token == token1, \"Invalid swap\");\n      amountOut = _decode144(price1Average * amountIn);\n    }\n    require(amountOut > 0, \"Zero output\");\n  }\n}\n"
    },
    "contracts/interfaces/ITwapOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface ITwapOracle {\n  function update() external;\n\n  function tryUpdate() external;\n\n  function consult(address token, uint256 amountIn)\n    external\n    view\n    returns (uint256 amountOut);\n\n  function updateAndConsult(address token, uint256 amountIn)\n    external\n    returns (uint256 amountOut);\n\n  event UpdatedPrice(\n    uint256 price0Average,\n    uint256 price1Average,\n    uint256 price0CumulativeLast,\n    uint256 price1CumulativeLast\n  );\n}\n"
    },
    "contracts/external/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\ninterface IUniswapV2Pair is IERC20 {\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/external/UniswapV2OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/FixedPoint.sol\npragma solidity ^0.8.4;\n\nimport \"./IUniswapV2Pair.sol\";\n\n// References\n// https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/external/UniswapV2OracleLibrary.sol\n// https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/FullMath.sol\n// https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n\nlibrary FullMath {\n  uint256 constant MAX_256 = type(uint256).max;\n\n  function fullMul(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256 l, uint256 h)\n  {\n    uint256 mm = mulmod(x, y, MAX_256);\n    l = x * y;\n    h = mm - l;\n    if (mm < l) h -= 1;\n  }\n\n  function fullDiv(\n    uint256 l,\n    uint256 h,\n    uint256 d\n  ) private pure returns (uint256) {\n    uint256 pow2 = uint256(int256(d) & -int256(d));\n    d /= pow2;\n    l /= pow2;\n    l += h * (uint256((-int256(pow2)) / int256(pow2 + 1)));\n    uint256 r = 1;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    r *= 2 - d * r;\n    return l * r;\n  }\n\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 d\n  ) internal pure returns (uint256) {\n    (uint256 l, uint256 h) = fullMul(x, y);\n\n    uint256 mm = mulmod(x, y, d);\n    if (mm > l) h -= 1;\n    l -= mm;\n\n    if (h == 0) return l / d;\n\n    require(h < d, \"FullMath: FULLDIV_OVERFLOW\");\n    return fullDiv(l, h, d);\n  }\n}\n\nlibrary FixedPoint {\n  // range: [0, 2**112 - 1]\n  // resolution: 1 / 2**112\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  uint8 public constant RESOLUTION = 112;\n  uint256 public constant Q112 = 2**112;\n  uint144 constant MAX_144 = type(uint144).max;\n  uint224 constant MAX_224 = type(uint224).max;\n\n  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n  // can be lossy\n  function fraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (uq112x112 memory)\n  {\n    require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n    if (numerator == 0) return FixedPoint.uq112x112(0);\n\n    if (numerator <= MAX_144) {\n      uint256 result = (numerator << RESOLUTION) / denominator;\n      require(result <= MAX_224, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    } else {\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n      require(result <= MAX_224, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    }\n  }\n}\n\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    if (blockTimestampLast != blockTimestamp) {\n      unchecked {\n        // subtraction overflow is desired\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n        // addition overflow is desired\n        price0Cumulative +=\n          uint256(FixedPoint.fraction(reserve1, reserve0)._x) *\n          timeElapsed;\n        price1Cumulative +=\n          uint256(FixedPoint.fraction(reserve0, reserve1)._x) *\n          timeElapsed;\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}