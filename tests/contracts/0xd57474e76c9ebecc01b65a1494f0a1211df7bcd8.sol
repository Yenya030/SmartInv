{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts-starter/contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {    \n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet, \n            action: IDiamondCut.FacetCutAction.Add, \n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");        \n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts-starter/contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts-starter/contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {                    \n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts-starter/contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts-starter/contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts-starter/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts-starter/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts-starter/contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/extensions/IERC721AQueryableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721AUpgradeable.sol';\n\n/**\n * @dev Interface of ERC721AQueryable.\n */\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\n    /**\n     * Invalid query range (`start` >= `stop`).\n     */\n    error InvalidQueryRange();\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n}\n"
    },
    "erc721a-upgradeable/contracts/IERC721AUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721AUpgradeable {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
    },
    "src/DevDiamond.sol": {
      "content": "\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IERC721AUpgradeable } from 'erc721a-upgradeable/contracts/IERC721AUpgradeable.sol';\nimport { IERC721AQueryableUpgradeable } from 'erc721a-upgradeable/contracts/extensions/IERC721AQueryableUpgradeable.sol';\nimport { IERC165 } from '@openzeppelin/contracts/interfaces/IERC165.sol';\nimport { IERC2981 } from '@openzeppelin/contracts/interfaces/IERC2981.sol';\nimport { Diamond } from 'contracts-starter/contracts/Diamond.sol';\nimport { DiamondCutFacet } from 'contracts-starter/contracts/facets/DiamondCutFacet.sol';\nimport { DiamondLoupeFacet } from 'contracts-starter/contracts/facets/DiamondLoupeFacet.sol';\nimport { LibDiamond } from 'contracts-starter/contracts/libraries/LibDiamond.sol';\nimport { IDiamondCut } from 'contracts-starter/contracts/interfaces/IDiamondCut.sol';\nimport { IDiamondLoupe } from 'contracts-starter/contracts/interfaces/IDiamondLoupe.sol';\nimport { IERC173 } from 'contracts-starter/contracts/interfaces/IERC173.sol';\n\ncontract DevDiamond is Diamond {\n\tconstructor(address contractOwner, address diamondCutFacet, address diamondLoupeFacet)\n\t\tDiamond(contractOwner, diamondCutFacet) payable\n\t{\n\t\t// Add ERC165 data\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n\t\tds.supportedInterfaces[type(IERC165).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC721AUpgradeable).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC721AQueryableUpgradeable).interfaceId] = true;\n\t\tds.supportedInterfaces[type(IERC2981).interfaceId] = true;\n\n\t\t// Add functions to the diamond\n\t\tIDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n\t\tbytes4[] memory diamondLoupeSelectors = new bytes4[](5);\n\t\tdiamondLoupeSelectors[0] = IDiamondLoupe.facets.selector;\n\t\tdiamondLoupeSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\n        diamondLoupeSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        diamondLoupeSelectors[3] = IDiamondLoupe.facetAddress.selector;\n\t\tdiamondLoupeSelectors[4] = IERC165.supportsInterface.selector;\n\t\tcut[0] = IDiamondCut.FacetCut({\n\t\t\tfacetAddress: diamondLoupeFacet,\n\t\t\taction: IDiamondCut.FacetCutAction.Add,\n\t\t\tfunctionSelectors: diamondLoupeSelectors\n\t\t});\n\t\tLibDiamond.diamondCut(cut, address(0), '');\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}