{{
  "language": "Solidity",
  "sources": {
    "TheInGods.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC721A {\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n    error ApprovalQueryForNonexistentToken();\r\n    error ApproveToCaller();\r\n    error ApprovalToCurrentOwner();\r\n    error BalanceQueryForZeroAddress();\r\n    error MintToZeroAddress();\r\n    error MintZeroQuantity();\r\n    error OwnerQueryForNonexistentToken();\r\n    error TransferCallerNotOwnerNorApproved();\r\n    error TransferFromIncorrectOwner();\r\n    error TransferToNonERC721ReceiverImplementer();\r\n    error TransferToZeroAddress();\r\n    error URIQueryForNonexistentToken();\r\n\r\n    struct TokenOwnership {\r\n        address addr;\r\n        uint64 startTimestamp;\r\n        bool burned;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract TheInGods is IERC721A { \r\n\r\n    address private _owner;\r\n    modifier onlyOwner() { \r\n        require(_owner==msg.sender, \"only owner is allowed\"); \r\n        _; \r\n    }\r\n\r\n    bool public saleIsActive = false;\r\n\r\n    uint256 public constant MAX_SUPPLY = 4421;\r\n    uint256 public constant MAX_FREE_PER_WALLET = 2;\r\n    uint256 public constant MAX_BUY_PER_TX = 20;\r\n    uint256 public constant COST = 0.002 ether;\r\n\r\n    string private _name = \"The In Gods\";\r\n    string private _symbol = \"INGODS\";\r\n    string private _baseURI = \"ipfs://bafybeifbklbabuktufdtz3mmvr7lr7gnxp4kksjlaztd5hfm3h74wrhlna/\";\r\n    string private _contractURI = \"ipfs://bafybeifbklbabuktufdtz3mmvr7lr7gnxp4kksjlaztd5hfm3h74wrhlna/\";\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function mint(uint256 _amount) external payable{\r\n        address _caller = _msgSenderERC721A();\r\n\r\n        require(saleIsActive, \"Mint is not active right now.\");\r\n        require(totalSupply() + _amount <= MAX_SUPPLY, \"Sold out\");\r\n        require(_amount <= MAX_BUY_PER_TX, \"Max Tx Limit reached\");\r\n        require(msg.value >= _amount*COST, \"Not enought Cash provided\");\r\n        \r\n        _safeMint(_caller, _amount);\r\n    }\r\n\r\n    function mintFree(uint256 _amount) external{\r\n        address _caller = _msgSenderERC721A();\r\n\r\n        require(saleIsActive, \"Mint is not active right now.\");\r\n        require(totalSupply() + _amount <= MAX_SUPPLY, \"Sold out\");\r\n\r\n        uint magicTokenNum;\r\n        uint count = totalSupply();\r\n\r\n        if(count <= 10){\r\n            magicTokenNum = 5;\r\n        } else if (count <= 2000) {\r\n            magicTokenNum = 3; \r\n        } else if (count <= 4000) {\r\n            magicTokenNum = 2; \r\n        } else {\r\n            magicTokenNum = 1; \r\n        }\r\n\r\n        require(_amount <= magicTokenNum, \"Tx limit exceeded\");\r\n        require(_amount + _numberMinted(msg.sender) <= magicTokenNum, \"Acc has token limit\");\r\n\r\n        _safeMint(_caller, _amount);\r\n    }   \r\n\r\n    uint256 private constant BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n    uint256 private constant BITPOS_NUMBER_MINTED = 64;\r\n    uint256 private constant BITPOS_NUMBER_BURNED = 128;\r\n    uint256 private constant BITPOS_AUX = 192;\r\n    uint256 private constant BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n    uint256 private constant BITPOS_START_TIMESTAMP = 160;\r\n    uint256 private constant BITMASK_BURNED = 1 << 224;\r\n    uint256 private constant BITPOS_NEXT_INITIALIZED = 225;\r\n    uint256 private constant BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n    uint256 private _currentIndex = 0;\r\n\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n    mapping(address => uint256) private _packedAddressData;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\r\n    // SETTER\r\n    function setName(string memory _newName, string memory _newSymbol) external onlyOwner {\r\n        _name = _newName;\r\n        _symbol = _newSymbol;\r\n    }\r\n\r\n    function setSale(bool _saleIsActive) external onlyOwner{\r\n        saleIsActive = _saleIsActive;\r\n    }\r\n\r\n    function setBaseURI(string memory _newBaseURI) external onlyOwner{\r\n        _baseURI = _newBaseURI;\r\n    }\r\n\r\n    function setContractURI(string memory _new_contractURI) external onlyOwner{\r\n        _contractURI = _new_contractURI;\r\n    }\r\n\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n    function _nextTokenId() internal view returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n    function _totalMinted() internal view returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        if (_addressToUint256(owner) == 0) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_MINTED) & BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> BITPOS_AUX);\r\n    }\r\n\r\n    function _setAux(address owner, uint64 aux) internal {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        assembly { // Cast aux without masking.\r\nauxCasted := aux\r\n        }\r\n        packed = (packed & BITMASK_AUX_COMPLEMENT) | (auxCasted << BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & BITMASK_BURNED == 0) {\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & BITMASK_BURNED != 0;\r\n    }\r\n    function _ownershipAt(uint256 index) internal view returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n    function _initializeOwnershipAt(uint256 index) internal {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n        string memory baseURI = _baseURI;\r\n\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId), \".json\")) : \"\";\r\n    }\r\n\r\n    function contractURI() public view returns (string memory) {\r\n        return _contractURI;\r\n    }\r\n    function _addressToUint256(address value) private pure returns (uint256 result) {\r\n        assembly {\r\nresult := value\r\n        }\r\n    }\r\n    function _boolToUint256(bool value) private pure returns (uint256 result) {\r\n        assembly {\r\nresult := value\r\n        }\r\n    }\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\r\n        if (to == owner) revert ApprovalToCurrentOwner();\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\r\n\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n    function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n            ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n    function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n            ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n    function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes memory //_data\r\n            ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex;\r\n    }\r\n    function _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    function _safeMint(\r\n            address to,\r\n            uint256 quantity,\r\n            bytes memory //_data\r\n            ) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        unchecked {\r\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            _packedOwnerships[startTokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + quantity;\r\n\r\n            if (to.code.length != 0) {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex);\r\n                } while (updatedIndex < end);\r\n                // Reentrancy protection\r\n                if (_currentIndex != startTokenId) revert();\r\n            } else {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex++);\r\n                } while (updatedIndex < end);\r\n            }\r\n            _currentIndex = updatedIndex;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _mint(address to, uint256 quantity) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (_addressToUint256(to) == 0) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        unchecked {\r\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\r\n            _packedOwnerships[startTokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + quantity;\r\n\r\n            do {\r\n                emit Transfer(address(0), to, updatedIndex++);\r\n            } while (updatedIndex < end);\r\n\r\n            _currentIndex = updatedIndex;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _transfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n            ) private {\r\n\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n        address approvedAddress = _tokenApprovals[tokenId];\r\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n                isApprovedForAll(from, _msgSenderERC721A()) ||\r\n                approvedAddress == _msgSenderERC721A());\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        //X if (_addressToUint256(to) == 0) revert TransferToZeroAddress();\r\n\r\n        if (_addressToUint256(approvedAddress) != 0) {\r\n            delete _tokenApprovals[tokenId];\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_NEXT_INITIALIZED;\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    function _afterTokenTransfers(\r\n            address from,\r\n            address to,\r\n            uint256 startTokenId,\r\n            uint256 quantity\r\n            ) internal virtual {}\r\n\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\r\n        assembly {\r\nptr := add(mload(0x40), 128)\r\n\r\n         mstore(0x40, ptr)\r\n\r\n         let end := ptr\r\n         for { \r\n             let temp := value\r\n                 ptr := sub(ptr, 1)\r\n                 mstore8(ptr, add(48, mod(temp, 10)))\r\n                 temp := div(temp, 10)\r\n         } temp { \r\n        temp := div(temp, 10)\r\n         } { \r\n        ptr := sub(ptr, 1)\r\n         mstore8(ptr, add(48, mod(temp, 10)))\r\n         }\r\n\r\n     let length := sub(end, ptr)\r\n         ptr := sub(ptr, 32)\r\n         mstore(ptr, length)\r\n        }\r\n    }\r\n\r\n    function WhitelistMint(address _to, uint256 _amount) external onlyOwner{\r\n        require(totalSupply()+_amount<MAX_SUPPLY, 'max supply reached');\r\n        _safeMint(_to, _amount);\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        payable(msg.sender).transfer(balance);\r\n    }\r\n\r\n    function treasuryMint(uint256 quantity) public onlyOwner {\r\n        require(quantity > 0, \"Invalid mint amount\");\r\n      require(totalSupply()+ quantity<MAX_SUPPLY, 'max supply reached');\r\n        _safeMint(msg.sender, quantity);\r\n    }\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}