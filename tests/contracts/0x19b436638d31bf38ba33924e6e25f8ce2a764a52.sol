{{
  "language": "Solidity",
  "sources": {
    "contracts/Asteria/NFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport '../EthereumContracts/contracts/interfaces/IERC165.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC721.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC721Metadata.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC721Enumerable.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC721Receiver.sol';\r\nimport '../EthereumContracts/contracts/interfaces/IERC2981.sol';\r\nimport '../EthereumContracts/contracts/utils/IOwnable.sol';\r\nimport '../EthereumContracts/contracts/utils/IPausable.sol';\r\nimport '../EthereumContracts/contracts/utils/ITradable.sol';\r\nimport '../EthereumContracts/contracts/utils/IWhitelistable_ECDSA.sol';\r\nimport '../EthereumContracts/contracts/utils/ERC2981Base.sol';\r\n\r\ncontract NFT721 is IERC721, IERC721Metadata, IERC721Enumerable, ERC2981Base, IOwnable, IPausable, ITradable, IWhitelistable_ECDSA, IERC165 {\r\n  // **************************************\r\n  // *****           ERRORS           *****\r\n  // **************************************\r\n    /**\r\n    * @dev Thrown when two related arrays have different lengths\r\n    */\r\n    error ARRAY_LENGTH_MISMATCH();\r\n    /**\r\n    * @dev Thrown when contract fails to send ether to recipient.\r\n    * \r\n    * @param to     : the recipient of the ether\r\n    * @param amount : the amount of ether being sent\r\n    */\r\n    error ETHER_TRANSFER_FAIL( address to, uint256 amount );\r\n    /**\r\n    * @dev Thrown when `operator` has not been approved to manage `tokenId` on behalf of `tokenOwner`.\r\n    * \r\n    * @param tokenOwner : address owning the token\r\n    * @param operator   : address trying to manage the token\r\n    * @param tokenId    : identifier of the NFT being referenced\r\n    */\r\n    error IERC721_CALLER_NOT_APPROVED( address tokenOwner, address operator, uint256 tokenId );\r\n    /**\r\n    * @dev Thrown when `operator` tries to approve themselves for managing a token they own.\r\n    * \r\n    * @param operator : address that is trying to approve themselves\r\n    */\r\n    error IERC721_INVALID_APPROVAL( address operator );\r\n    /**\r\n    * @dev Thrown when a token is being transferred to the zero address.\r\n    */\r\n    error IERC721_INVALID_TRANSFER();\r\n    /**\r\n    * @dev Thrown when a token is being transferred from an address that doesn't own it.\r\n    * \r\n    * @param tokenOwner : address owning the token\r\n    * @param from       : address that the NFT is being transferred from\r\n    * @param tokenId    : identifier of the NFT being referenced\r\n    */\r\n    error IERC721_INVALID_TRANSFER_FROM( address tokenOwner, address from, uint256 tokenId );\r\n    /**\r\n    * @dev Thrown when the requested token doesn't exist.\r\n    * \r\n    * @param tokenId : identifier of the NFT being referenced\r\n    */\r\n    error IERC721_NONEXISTANT_TOKEN( uint256 tokenId );\r\n    /**\r\n    * @dev Thrown when a token is being safely transferred to a contract unable to handle it.\r\n    * \r\n    * @param receiver : address unable to receive the token\r\n    */\r\n    error IERC721_NON_ERC721_RECEIVER( address receiver );\r\n    /**\r\n    * @dev Thrown when trying to get the token at an index that doesn't exist.\r\n    * \r\n    * @param index : the inexistant index\r\n    */\r\n    error IERC721Enumerable_INDEX_OUT_OF_BOUNDS( uint256 index );\r\n    /**\r\n    * @dev Thrown when trying to get the token owned by `tokenOwner` at an index that doesn't exist.\r\n    * \r\n    * @param tokenOwner : address owning the token\r\n    * @param index      : the inexistant index\r\n    */\r\n    error IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( address tokenOwner, uint256 index );\r\n    /**\r\n    * @dev Thrown when an incorrect amount of eth is being sent for a payable operation.\r\n    * \r\n    * @param amountReceived : the amount the contract received\r\n    * @param amountExpected : the actual amount the contract expected to receive\r\n    */\r\n    error INCORRECT_PRICE( uint256 amountReceived, uint256 amountExpected );\r\n    /**\r\n    * @dev Thrown when trying to mint 0 token.\r\n    */\r\n    error NFT_INVALID_QTY();\r\n    /**\r\n    * @dev Thrown when trying to mint more tokens than the max allowed per transaction.\r\n    * \r\n    * @param qtyRequested : the amount of tokens requested\r\n    * @param maxBatch     : the maximum amount that can be minted per transaction\r\n    */\r\n    error NFT_MAX_BATCH( uint256 qtyRequested, uint256 maxBatch );\r\n    /**\r\n    * @dev Thrown when trying to mint more tokens from the reserve than the amount left.\r\n    * \r\n    * @param qtyRequested : the amount of tokens requested\r\n    * @param reserveLeft  : the amount of tokens left in the reserve\r\n    */\r\n    error NFT_MAX_RESERVE( uint256 qtyRequested, uint256 reserveLeft );\r\n    /**\r\n    * @dev Thrown when trying to mint more tokens than the amount left to be minted (except reserve).\r\n    * \r\n    * @param qtyRequested    : the amount of tokens requested\r\n    * @param remainingSupply : the amount of tokens left in the reserve\r\n    */\r\n    error NFT_MAX_SUPPLY( uint256 qtyRequested, uint256 remainingSupply );\r\n    /**\r\n    * @dev Thrown when trying to withdraw from the contract with no balance.\r\n    */\r\n    error NO_ETHER_BALANCE();\r\n  // **************************************\r\n\r\n  /**\r\n  * @dev A structure representing the deployment configuration of the contract.\r\n  * It contains several pieces of information:\r\n  * - reserve          : The amount of tokens that are reserved for airdrops\r\n  * - maxBatch         : The maximum amount of tokens that can be minted in one transaction (for public sale)\r\n  * - maxSupply        : The maximum amount of tokens that can be minted\r\n  * - publicSalePrice  : The price of the tokens during public sale\r\n  * - privateSalePrice : The price of the tokens during private sale\r\n  * - treasury         : The address that will receive the proceeds of the mint\r\n  * - name             : The name of the tokens, for token trackers (i.e. 'Cool Cats')\r\n  * - symbol           : The symbol of the tokens, for token trackers (i.e. 'COOL')\r\n  */\r\n  struct Config {\r\n    uint256 maxBatch;\r\n    uint256 maxSupply;\r\n    uint256 publicSalePrice;\r\n    uint256 privateSalePrice;\r\n    string  name;\r\n    string  symbol;\r\n  }\r\n\r\n  // Constants\r\n  uint8   public constant PUBLIC_SALE   = 1;\r\n  uint8   public constant PRIVATE_SALE  = 2;\r\n  uint8   public constant WAITLIST_SALE = 3;\r\n  uint8   public constant CLAIM         = 4;\r\n\r\n  uint256 private _nextId = 1;\r\n  uint256 private _reserve;\r\n  string  private _baseURI;\r\n  Config  private _config;\r\n  address private _treasury;\r\n\r\n  // Mapping from token ID to approved address\r\n  mapping( uint256 => address ) private _approvals;\r\n\r\n  // Mapping from owner to operator approvals\r\n  mapping( address => mapping( address => bool ) ) private _operatorApprovals;\r\n\r\n  // List of owner addresses\r\n  mapping( uint256 => address ) private _owners;\r\n\r\n  constructor(\r\n    uint256 maxSupply_,\r\n    uint256 maxBatch_,\r\n    uint256 reserve_,\r\n    uint256 salePrice_,\r\n    uint256 royaltyRate_,\r\n    address treasury_,\r\n    string memory name_,\r\n    string memory symbol_\r\n  ) {\r\n    _config = Config(\r\n      maxBatch_,\r\n      maxSupply_,\r\n      salePrice_,\r\n      salePrice_,\r\n      name_,\r\n      symbol_\r\n    );\r\n    _reserve = reserve_;\r\n    _treasury = treasury_;\r\n    _setRoyaltyInfo( treasury_, royaltyRate_ );\r\n    _initIOwnable( msg.sender );\r\n  }\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Ensures the token exist. \r\n    * A token exists if it has been minted and is not owned by the null address.\r\n    * \r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    */\r\n    modifier exists( uint256 tokenId_ ) {\r\n      if ( ! _exists( tokenId_ ) ) {\r\n        revert IERC721_NONEXISTANT_TOKEN( tokenId_ );\r\n      }\r\n      _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensures that `qty_` is higher than 0\r\n    * \r\n    * @param qty_ : the amount to validate \r\n    */\r\n    modifier validateAmount( uint256 qty_ ) {\r\n      if ( qty_ == 0 ) {\r\n        revert NFT_INVALID_QTY();\r\n      }\r\n      _;\r\n    }\r\n\r\n    /**\r\n    * @dev Ensures that contract state is `{PRIVATE_SALE}` or `{WAITLIST_SALE}`.\r\n    */\r\n    modifier isPrivateOrWaitlist() {\r\n      uint8 _currentState_ = getPauseState();\r\n      if ( _currentState_ != PRIVATE_SALE && _currentState_ != WAITLIST_SALE ) {\r\n        revert IPausable_INCORRECT_STATE( PRIVATE_SALE );\r\n      }\r\n      _;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n    * The call is not executed if the target address is not a contract.\r\n    *\r\n    * @param from_    : address owning the token being transferred\r\n    * @param to_      : address the token is being transferred to\r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    * @param data_    : optional data to send along with the call\r\n    * \r\n    * @return bool : whether the call correctly returned the expected magic value\r\n    */\r\n    function _checkOnERC721Received( address from_, address to_, uint256 tokenId_, bytes memory data_ ) internal returns ( bool ) {\r\n      // This method relies on extcodesize, which returns 0 for contracts in\r\n      // construction, since the code is only stored at the end of the\r\n      // constructor execution.\r\n      // \r\n      // IMPORTANT\r\n      // It is unsafe to assume that an address not flagged by this method\r\n      // is an externally-owned account (EOA) and not a contract.\r\n      //\r\n      // Among others, the following types of addresses will not be flagged:\r\n      //\r\n      //  - an externally-owned account\r\n      //  - a contract in construction\r\n      //  - an address where a contract will be created\r\n      //  - an address where a contract lived, but was destroyed\r\n      uint256 _size_;\r\n      assembly {\r\n        _size_ := extcodesize( to_ )\r\n      }\r\n\r\n      // If address is a contract, check that it is aware of how to handle ERC721 tokens\r\n      if ( _size_ > 0 ) {\r\n        try IERC721Receiver( to_ ).onERC721Received( msg.sender, from_, tokenId_, data_ ) returns ( bytes4 retval ) {\r\n          return retval == IERC721Receiver.onERC721Received.selector;\r\n        }\r\n        catch ( bytes memory reason ) {\r\n          if ( reason.length == 0 ) {\r\n            revert IERC721_NON_ERC721_RECEIVER( to_ );\r\n          }\r\n          else {\r\n            assembly {\r\n              revert( add( 32, reason ), mload( reason ) )\r\n            }\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function returning whether a token exists. \r\n    * A token exists if it has been minted and is not owned by the null address.\r\n    * \r\n    * Note: this function must be overriden if tokens are burnable.\r\n    * \r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    * \r\n    * @return bool : whether the token exists\r\n    */\r\n    function _exists( uint256 tokenId_ ) internal view returns ( bool ) {\r\n      if ( tokenId_ == 0 ) {\r\n        return false;\r\n      }\r\n      return tokenId_ < _nextId;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function returning whether `operator_` is allowed \r\n    * to manage tokens on behalf of `tokenOwner_`.\r\n    * \r\n    * @param tokenOwner_ : address that owns tokens\r\n    * @param operator_   : address that tries to manage tokens\r\n    * \r\n    * @return bool : whether `operator_` is allowed to manage the tokens\r\n    */\r\n    function _isApprovedForAll( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\r\n      return _isRegisteredProxy( tokenOwner_, operator_ ) ||\r\n             _operatorApprovals[ tokenOwner_ ][ operator_ ];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\r\n    * \r\n    * Note: To avoid multiple checks for the same data, it is assumed \r\n    * that existence of `tokenId_` has been verified prior via {_exists}\r\n    * If it hasn't been verified, this function might panic\r\n    * \r\n    * @param operator_ : address that tries to handle the token\r\n    * @param tokenId_  : identifier of the NFT being referenced\r\n    * \r\n    * @return bool : whether `operator_` is allowed to manage the token\r\n    */\r\n    function _isApprovedOrOwner( address tokenOwner_, address operator_, uint256 tokenId_ ) internal view returns ( bool ) {\r\n      bool _isApproved_ = operator_ == tokenOwner_ ||\r\n                          operator_ == getApproved( tokenId_ ) ||\r\n                          isApprovedForAll( tokenOwner_, operator_ );\r\n      return _isApproved_;\r\n    }\r\n\r\n    /**\r\n    * @dev Mints `qty_` tokens and transfers them to `to_`.\r\n    * \r\n    * This internal function can be used to perform token minting.\r\n    * \r\n    * @param to_  : address receiving the tokens\r\n    * @param qty_ : the amount of tokens to be minted\r\n    * \r\n    * Emits one or more {Transfer} event.\r\n    */\r\n    function _mint( address to_, uint256 qty_ ) internal {\r\n      uint256 _firstToken_ = _nextId;\r\n      uint256 _nextStart_ = _firstToken_ + qty_;\r\n      uint256 _lastToken_ = _nextStart_ - 1;\r\n\r\n      _owners[ _firstToken_ ] = to_;\r\n      if ( _lastToken_ > _firstToken_ ) {\r\n        _owners[ _lastToken_ ] = to_;\r\n      }\r\n      _nextId = _nextStart_;\r\n\r\n      for ( uint256 i = _firstToken_; i < _nextStart_; ++i ) {\r\n        emit Transfer( address( 0 ), to_, i );\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function returning the owner of the `tokenId_` token.\r\n    * \r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    * \r\n    * @return address the address of the token owner\r\n    */\r\n    function _ownerOf( uint256 tokenId_ ) internal view returns ( address ) {\r\n      uint256 _index_ = tokenId_;\r\n      address _tokenOwner_ = _owners[ _index_ ];\r\n      while ( _tokenOwner_ == address( 0 ) ) {\r\n        _index_ --;\r\n        _tokenOwner_ = _owners[ _index_ ];\r\n      }\r\n\r\n      return _tokenOwner_;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function returning the total supply.\r\n    * \r\n    * Note: this function must be overriden if tokens are burnable.\r\n    */\r\n    function _totalSupply() internal view returns ( uint256 ) {\r\n      return supplyMinted();\r\n    }\r\n\r\n    /**\r\n    * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n    */\r\n    function _toString( uint256 value ) internal pure returns ( string memory ) {\r\n      // Inspired by OraclizeAPI's implementation - MIT licence\r\n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n      if ( value == 0 ) {\r\n        return \"0\";\r\n      }\r\n      uint256 temp = value;\r\n      uint256 digits;\r\n      while ( temp != 0 ) {\r\n        digits ++;\r\n        temp /= 10;\r\n      }\r\n      bytes memory buffer = new bytes( digits );\r\n      while ( value != 0 ) {\r\n        digits -= 1;\r\n        buffer[ digits ] = bytes1( uint8( 48 + uint256( value % 10 ) ) );\r\n        value /= 10;\r\n      }\r\n      return string( buffer );\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers `tokenId_` from `from_` to `to_`.\r\n    *\r\n    * This internal function can be used to implement alternative mechanisms to perform \r\n    * token transfer, such as signature-based, or token burning.\r\n    * \r\n    * @param from_    : the current owner of the NFT\r\n    * @param to_      : the new owner\r\n    * @param tokenId_ : identifier of the NFT being referenced\r\n    * \r\n    * Emits a {Transfer} event.\r\n    */\r\n    function _transfer( address from_, address to_, uint256 tokenId_ ) internal {\r\n      _approvals[ tokenId_ ] = address( 0 );\r\n      uint256 _previousId_ = tokenId_ > 1 ? tokenId_ - 1 : 1;\r\n      uint256 _nextId_     = tokenId_ + 1;\r\n      bool _previousShouldUpdate_ = _previousId_ < tokenId_ &&\r\n                                    _exists( _previousId_ ) &&\r\n                                    _owners[ _previousId_ ] == address( 0 );\r\n      bool _nextShouldUpdate_ = _exists( _nextId_ ) &&\r\n                                _owners[ _nextId_ ] == address( 0 );\r\n\r\n      if ( _previousShouldUpdate_ ) {\r\n        _owners[ _previousId_ ] = from_;\r\n      }\r\n\r\n      if ( _nextShouldUpdate_ ) {\r\n        _owners[ _nextId_ ] = from_;\r\n      }\r\n\r\n      _owners[ tokenId_ ] = to_;\r\n\r\n      emit Transfer( from_, to_, tokenId_ );\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****           PUBLIC           *****\r\n  // **************************************\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_           : the amount of tokens to be minted\r\n    * @param alloted_       : the maximum alloted for that user\r\n    * @param proof_         : the signature to verify whitelist allocation\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Sale state must be {PRIVATE_SALE}.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at private sale price.\r\n    */\r\n    function mintPrivate( uint256 qty_, uint256 alloted_, Proof memory proof_ ) public payable validateAmount( qty_ ) isPrivateOrWaitlist isWhitelisted( msg.sender, PRIVATE_SALE, alloted_, proof_, qty_ ) {\r\n      uint256 _remainingSupply_ = _config.maxSupply - _reserve - supplyMinted();\r\n      if ( qty_ > _remainingSupply_ ) {\r\n        revert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _config.privateSalePrice;\r\n      if ( _expected_ != msg.value ) {\r\n        revert INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _consumeWhitelist( msg.sender, PRIVATE_SALE, qty_ );\r\n      _mint( msg.sender, qty_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_           : the amount of tokens to be minted\r\n    * @param alloted_       : the maximum alloted for that user\r\n    * @param proof_         : the signature to verify whitelist allocation\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Sale state must be {WAITLIST_SALE}.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at private sale price.\r\n    */\r\n    function mintWaitlist( uint256 qty_, uint256 alloted_, Proof memory proof_ ) public payable validateAmount( qty_ ) isState( WAITLIST_SALE ) isWhitelisted( msg.sender, WAITLIST_SALE, alloted_, proof_, qty_ ) {\r\n      uint256 _remainingSupply_ = _config.maxSupply - _reserve - supplyMinted();\r\n      if ( qty_ > _remainingSupply_ ) {\r\n        revert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _config.privateSalePrice;\r\n      if ( _expected_ != msg.value ) {\r\n        revert INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _consumeWhitelist( msg.sender, WAITLIST_SALE, qty_ );\r\n      _mint( msg.sender, qty_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_           : the amount of tokens to be minted\r\n    * @param alloted_       : the maximum alloted for that user\r\n    * @param proof_         : the signature to verify whitelist allocation\r\n    * \r\n    * - Sale state must not be {PAUSED}.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at private sale price.\r\n    */\r\n    function claimDualSouls( uint256 qty_, uint256 alloted_, Proof memory proof_ ) public payable validateAmount( qty_ ) isPrivateOrWaitlist isWhitelisted( msg.sender, CLAIM, alloted_, proof_, qty_ ) {\r\n      uint256 _remainingSupply_ = _config.maxSupply - _reserve - supplyMinted();\r\n      if ( qty_ > _remainingSupply_ ) {\r\n        revert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _config.privateSalePrice;\r\n      if ( _expected_ != msg.value ) {\r\n        revert INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _consumeWhitelist( msg.sender, CLAIM, qty_ );\r\n      _mint( msg.sender, qty_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Mints `qty_` tokens and transfers them to the caller.\r\n    * \r\n    * @param qty_ : the amount of tokens to be minted\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Sale state must be {PUBLIC_SALE}.\r\n    * - There must be enough tokens left to mint outside of the reserve.\r\n    * - Caller must send enough ether to pay for `qty_` tokens at public sale price.\r\n    */\r\n    function mintPublic( uint256 qty_ ) public payable validateAmount( qty_ ) isState( PUBLIC_SALE ) {\r\n      if ( qty_ > _config.maxBatch ) {\r\n        revert NFT_MAX_BATCH( qty_, _config.maxBatch );\r\n      }\r\n\r\n      uint256 _remainingSupply_ = _config.maxSupply - _reserve - supplyMinted();\r\n      if ( qty_ > _remainingSupply_ ) {\r\n        revert NFT_MAX_SUPPLY( qty_, _remainingSupply_ );\r\n      }\r\n\r\n      uint256 _expected_ = qty_ * _config.publicSalePrice;\r\n      if ( _expected_ != msg.value ) {\r\n        revert INCORRECT_PRICE( msg.value, _expected_ );\r\n      }\r\n\r\n      _mint( msg.sender, qty_ );\r\n    }\r\n\r\n    // +---------+\r\n    // | IERC721 |\r\n    // +---------+\r\n      /**\r\n      * @notice Gives permission to `to_` to transfer the token number `tokenId_` on behalf of its owner.\r\n      * The approval is cleared when the token is transferred.\r\n      * \r\n      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n      * \r\n      * @param to_      : The new approved NFT controller\r\n      * @param tokenId_ : The NFT to approve\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - The token number `tokenId_` must exist.\r\n      * - The caller must own the token or be an approved operator.\r\n      * - Must emit an {Approval} event.\r\n      */\r\n      function approve( address to_, uint256 tokenId_ ) public override exists( tokenId_ ) {\r\n        address _operator_ = msg.sender;\r\n        address _tokenOwner_ = _ownerOf( tokenId_ );\r\n        if ( to_ == _tokenOwner_ ) {\r\n          revert IERC721_INVALID_APPROVAL( to_ );\r\n        }\r\n\r\n        bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n        if ( ! _isApproved_ ) {\r\n          revert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n        }\r\n\r\n        _approvals[ tokenId_ ] = to_;\r\n        emit Approval( _tokenOwner_, to_, tokenId_ );\r\n      }\r\n\r\n      /**\r\n      * @notice Transfers the token number `tokenId_` from `from_` to `to_`.\r\n      * \r\n      * @param from_    : The current owner of the NFT\r\n      * @param to_      : The new owner\r\n      * @param tokenId_ : identifier of the NFT being referenced\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - The token number `tokenId_` must exist.\r\n      * - `from_` must be the token owner.\r\n      * - The caller must own the token or be an approved operator.\r\n      * - `to_` must not be the zero address.\r\n      * - If `to_` is a contract, it must implement {IERC721Receiver-onERC721Received} with a return value of `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n      * - Must emit a {Transfer} event.\r\n      */\r\n      function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) public override {\r\n        safeTransferFrom( from_, to_, tokenId_, \"\" );\r\n      }\r\n\r\n      /**\r\n      * @notice Transfers the token number `tokenId_` from `from_` to `to_`.\r\n      * \r\n      * @param from_    : The current owner of the NFT\r\n      * @param to_      : The new owner\r\n      * @param tokenId_ : identifier of the NFT being referenced\r\n      * @param data_    : Additional data with no specified format, sent in call to `to_`\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - The token number `tokenId_` must exist.\r\n      * - `from_` must be the token owner.\r\n      * - The caller must own the token or be an approved operator.\r\n      * - `to_` must not be the zero address.\r\n      * - If `to_` is a contract, it must implement {IERC721Receiver-onERC721Received} with a return value of `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n      * - Must emit a {Transfer} event.\r\n      */\r\n      function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes memory data_ ) public override {\r\n        transferFrom( from_, to_, tokenId_ );\r\n        if ( ! _checkOnERC721Received( from_, to_, tokenId_, data_ ) ) {\r\n          revert IERC721_NON_ERC721_RECEIVER( to_ );\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @notice Allows or disallows `operator_` to manage the caller's tokens on their behalf.\r\n      * \r\n      * @param operator_ : Address to add to the set of authorized operators\r\n      * @param approved_ : True if the operator is approved, false to revoke approval\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - Must emit an {ApprovalForAll} event.\r\n      */\r\n      function setApprovalForAll( address operator_, bool approved_ ) public override {\r\n        address _account_ = msg.sender;\r\n        if ( operator_ == _account_ ) {\r\n          revert IERC721_INVALID_APPROVAL( operator_ );\r\n        }\r\n\r\n        _operatorApprovals[ _account_ ][ operator_ ] = approved_;\r\n        emit ApprovalForAll( _account_, operator_, approved_ );\r\n      }\r\n\r\n      /**\r\n      * @notice Transfers the token number `tokenId_` from `from_` to `to_`.\r\n      * \r\n      * @param from_    : the current owner of the NFT\r\n      * @param to_      : the new owner\r\n      * @param tokenId_ : identifier of the NFT being referenced\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - The token number `tokenId_` must exist.\r\n      * - `from_` must be the token owner.\r\n      * - The caller must own the token or be an approved operator.\r\n      * - `to_` must not be the zero address.\r\n      * - Must emit a {Transfer} event.\r\n      */\r\n      function transferFrom( address from_, address to_, uint256 tokenId_ ) public override exists( tokenId_ ) {\r\n        if ( to_ == address( 0 ) ) {\r\n          revert IERC721_INVALID_TRANSFER();\r\n        }\r\n\r\n        address _operator_ = msg.sender;\r\n        address _tokenOwner_ = _ownerOf( tokenId_ );\r\n        if ( from_ != _tokenOwner_ ) {\r\n          revert IERC721_INVALID_TRANSFER_FROM( _tokenOwner_, from_, tokenId_ );\r\n        }\r\n\r\n        bool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n        if ( ! _isApproved_ ) {\r\n          revert IERC721_CALLER_NOT_APPROVED( _tokenOwner_, _operator_, tokenId_ );\r\n        }\r\n\r\n        _transfer( _tokenOwner_, to_, tokenId_ );\r\n      }\r\n    // +---------+\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****       CONTRACT_OWNER       *****\r\n  // **************************************\r\n    /**\r\n    * @dev Adds a proxy registry to the list of accepted proxy registries.\r\n    * \r\n    * @param proxyRegistryAddress_ : the address of the proxy registry to be added\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function addProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n      _addProxyRegistry( proxyRegistryAddress_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Mints `amounts_` tokens and transfers them to `accounts_`.\r\n    * \r\n    * @param accounts_ : the list of accounts that will receive airdropped tokens\r\n    * @param amounts_  : the amount of tokens each account will receive\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `accounts_` and `amounts_` must have the same length.\r\n    * - There must be enough tokens left in the reserve.\r\n    */\r\n    function airdrop( address[] memory accounts_, uint256[] memory amounts_ ) public onlyOwner {\r\n      uint256 _amountsLen_ = amounts_.length;\r\n      if ( accounts_.length != _amountsLen_ ) {\r\n        revert ARRAY_LENGTH_MISMATCH();\r\n      }\r\n\r\n      uint256 _totalQty_;\r\n      for ( uint256 i = _amountsLen_; i > 0; i -- ) {\r\n        _totalQty_ += amounts_[ i - 1 ];\r\n      }\r\n      if ( _totalQty_ > _reserve ) {\r\n        revert NFT_MAX_RESERVE( _totalQty_, _reserve );\r\n      }\r\n      unchecked {\r\n        _reserve -= _totalQty_;\r\n      }\r\n\r\n      uint256 _count_ = _amountsLen_;\r\n      while ( _count_ > 0 ) {\r\n        unchecked {\r\n          _count_ --;\r\n        }\r\n        _mint( accounts_[ _count_ ], amounts_[ _count_ ] );\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Removes a proxy registry from the list of accepted proxy registries.\r\n    * \r\n    * @param proxyRegistryAddress_ : the address of the proxy registry to be removed\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function removeProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n      _removeProxyRegistry( proxyRegistryAddress_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the baseURI for the tokens.\r\n    * \r\n    * @param baseURI_ : the new baseURI for the tokens\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setBaseURI( string memory baseURI_ ) public onlyOwner {\r\n      _baseURI = baseURI_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the contract state.\r\n    * \r\n    * @param newState_ : the new sale state\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newState_` must be a valid state.\r\n    */\r\n    function setPauseState( uint8 newState_ ) external onlyOwner {\r\n      if ( newState_ > CLAIM ) {\r\n        revert IPausable_INVALID_STATE( newState_ );\r\n      }\r\n      _setPauseState( newState_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the prices.\r\n    * \r\n    * Note: We shouldn't need to use this function, but just in case.\r\n    * \r\n    * @param publicSalePrice_  : the new public sale price\r\n    * @param privateSalePrice_ : the new private sale price\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setPrice( uint256 publicSalePrice_, uint256 privateSalePrice_ ) external onlyOwner {\r\n      _config.publicSalePrice = publicSalePrice_;\r\n      _config.privateSalePrice = privateSalePrice_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the royalty recipient and rate.\r\n    * \r\n    * @param royaltyRecipient_ : the new recipient of the royalties\r\n    * @param royaltyRate_      : the new royalty rate\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `royaltyRate_` cannot be higher than 10,000.\r\n    */\r\n    function setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) external onlyOwner {\r\n      _setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the contract treasury.\r\n    * \r\n    * @param newTreasury_ : the new trasury\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setTreasury( address newTreasury_ ) external onlyOwner {\r\n      _treasury = newTreasury_;\r\n    }\r\n\r\n    /**\r\n    * @notice Updates the whitelist signer.\r\n    * \r\n    * @param adminSigner_ : the new whitelist signer\r\n    *  \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setWhitelist( address adminSigner_ ) external onlyOwner {\r\n      _setWhitelist( adminSigner_ );\r\n    }\r\n\r\n    /**\r\n    * @notice Withdraws all the money stored in the contract and sends it to the treasury.\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - Contract must have a positive balance.\r\n    */\r\n    function withdraw() public onlyOwner {\r\n      uint256 _balance_ = address( this ).balance;\r\n      if ( _balance_ == 0 ) {\r\n        revert NO_ETHER_BALANCE();\r\n      }\r\n\r\n      address _recipient_ = payable( _treasury );\r\n      ( bool _success_, ) = _recipient_.call{ value: _balance_ }( \"\" );\r\n      if ( ! _success_ ) {\r\n        revert ETHER_TRANSFER_FAIL( _recipient_, _balance_ );\r\n      }\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n    /**\r\n    * @notice Returns the total number of tokens minted\r\n    * \r\n    * @return uint256 the number of tokens that have been minted so far\r\n    */\r\n    function supplyMinted() public view returns ( uint256 ) {\r\n      return _nextId - 1;\r\n    }\r\n\r\n\t/**\r\n\t* @notice Called with the sale price to determine how much royalty is owed and to whom.\r\n\t* \r\n\t* @param tokenId_   : identifier of the NFT being referenced\r\n\t* @param salePrice_ : the sale price of the token sold\r\n\t* \r\n\t* @return address : the address receiving the royalties\r\n\t* @return uint256 : the royalty payment amount\r\n\t*/\r\n\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override exists( tokenId_ ) returns ( address, uint256 ) {\r\n\t\treturn super.royaltyInfo( tokenId_, salePrice_ );\r\n\t}\r\n\r\n    // +---------+\r\n    // | IERC721 |\r\n    // +---------+\r\n      /**\r\n      * @notice Returns the number of tokens in `tokenOwner_`'s account.\r\n      * \r\n      * @param tokenOwner_ : address that owns tokens\r\n      * \r\n      * @return uint256 : the nomber of tokens owned by `tokenOwner_`\r\n      */\r\n      function balanceOf( address tokenOwner_ ) public view override returns ( uint256 ) {\r\n        if ( tokenOwner_ == address( 0 ) ) {\r\n          return 0;\r\n        }\r\n\r\n        uint256 _count_ = 0;\r\n        address _currentTokenOwner_;\r\n        for ( uint256 i = 1; i < _nextId; ++ i ) {\r\n          if ( _exists( i ) ) {\r\n            if ( _owners[ i ] != address( 0 ) ) {\r\n              _currentTokenOwner_ = _owners[ i ];\r\n            }\r\n            if ( tokenOwner_ == _currentTokenOwner_ ) {\r\n              _count_++;\r\n            }\r\n          }\r\n        }\r\n        return _count_;\r\n      }\r\n\r\n      /**\r\n      * @notice Returns the address that has been specifically allowed to manage `tokenId_` on behalf of its owner.\r\n      * \r\n      * @param tokenId_ : the NFT that has been approved\r\n      * \r\n      * @return address : the address allowed to manage `tokenId_`\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - `tokenId_` must exist.\r\n      * \r\n      * Note: See {Approve}\r\n      */\r\n      function getApproved( uint256 tokenId_ ) public view override exists( tokenId_ ) returns ( address ) {\r\n        return _approvals[ tokenId_ ];\r\n      }\r\n\r\n      /**\r\n      * @notice Returns whether `operator_` is allowed to manage tokens on behalf of `tokenOwner_`.\r\n      * \r\n      * @param tokenOwner_ : address that owns tokens\r\n      * @param operator_   : address that tries to manage tokens\r\n      * \r\n      * @return bool : whether `operator_` is allowed to handle `tokenOwner`'s tokens\r\n      * \r\n      * Note: See {setApprovalForAll}\r\n      */\r\n      function isApprovedForAll( address tokenOwner_, address operator_ ) public view override returns ( bool ) {\r\n        return _operatorApprovals[ tokenOwner_ ][ operator_ ];\r\n      }\r\n\r\n      /**\r\n      * @notice Returns the owner of the token number `tokenId_`.\r\n      * \r\n      * @param tokenId_ : the NFT to verify ownership of\r\n      * \r\n      * @return address : the owner of token number `tokenId_`\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - `tokenId_` must exist.\r\n      */\r\n      function ownerOf( uint256 tokenId_ ) public view override exists( tokenId_ ) returns ( address ) {\r\n        return _ownerOf( tokenId_ );\r\n      }\r\n    // +---------+\r\n\r\n    // +-----------------+\r\n    // | IERC721Metadata |\r\n    // +-----------------+\r\n      /**\r\n      * @notice A descriptive name for a collection of NFTs in this contract.\r\n      * \r\n      * @return string : The name of the collection\r\n      */\r\n      function name() public view override returns ( string memory ) {\r\n        return _config.name;\r\n      }\r\n\r\n      /**\r\n      * @notice An abbreviated name for NFTs in this contract.\r\n      * \r\n      * @return string : The abbreviated name of the collection\r\n      */\r\n      function symbol() public view override returns ( string memory ) {\r\n        return _config.symbol;\r\n      }\r\n\r\n      /**\r\n      * @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n      * \r\n      * @param tokenId_ : the NFT that has been approved\r\n      * \r\n      * @return string : the URI of the token\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - `tokenId_` must exist.\r\n      */\r\n      function tokenURI( uint256 tokenId_ ) public view override exists( tokenId_ ) returns ( string memory ) {\r\n        return bytes( _baseURI ).length > 0 ? string( abi.encodePacked( _baseURI, _toString( tokenId_ ) ) ) : _toString( tokenId_ );\r\n      }\r\n    // +---------+\r\n\r\n    // +-------------------+\r\n    // | IERC721Enumerable |\r\n    // +-------------------+\r\n      /**\r\n      * @notice Enumerate valid NFTs.\r\n      * \r\n      * @param index_ : a counter less than `totalSupply()`\r\n      * \r\n      * @return uint256 : the token identifier of the `index_`th NFT\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - `index_` must be lower than `totalSupply()`.\r\n      */\r\n      function tokenByIndex( uint256 index_ ) public view override returns ( uint256 ) {\r\n        if ( index_ >= supplyMinted() ) {\r\n          revert IERC721Enumerable_INDEX_OUT_OF_BOUNDS( index_ );\r\n        }\r\n        return index_;\r\n      }\r\n\r\n      /**\r\n      * @notice Enumerate NFTs assigned to an owner.\r\n      * \r\n      * @param tokenOwner_ : the address for which we want to know the tokens owned\r\n      * @param index_      : a counter less than `balanceOf(tokenOwner_)`\r\n      * \r\n      * @return tokenId : the token identifier of the `index_`th NFT\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - `index_` must be lower than `balanceOf(tokenOwner_)`.\r\n      */\r\n      function tokenOfOwnerByIndex( address tokenOwner_, uint256 index_ ) public view override returns ( uint256 tokenId ) {\r\n        if ( index_ >= balanceOf( tokenOwner_ ) ) {\r\n          revert IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS( tokenOwner_, index_ );\r\n        }\r\n\r\n        uint256 _count_ = 0;\r\n        for ( uint256 i = 1; i < _nextId; ++i ) {\r\n          if ( _exists( i ) && tokenOwner_ == _ownerOf( i ) ) {\r\n            if ( index_ == _count_ ) {\r\n              return i;\r\n            }\r\n            unchecked {\r\n              _count_++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n      * @notice Count NFTs tracked by this contract.\r\n      * \r\n      * @return the total number of existing NFTs tracked by the contract\r\n      */\r\n      function totalSupply() public view override returns ( uint256 ) {\r\n        return _totalSupply();\r\n      }\r\n    // +---------+\r\n\r\n    // +---------+\r\n    // | IERC165 |\r\n    // +---------+\r\n      /**\r\n      * @notice Query if a contract implements an interface.\r\n      * @dev see https://eips.ethereum.org/EIPS/eip-165\r\n      * \r\n      * @param interfaceId_ : the interface identifier, as specified in ERC-165\r\n      * \r\n      * @return bool : true if the contract implements the specified interface, false otherwise\r\n      * \r\n      * Requirements:\r\n      * \r\n      * - This function must use less than 30,000 gas.\r\n      */\r\n      function supportsInterface( bytes4 interfaceId_ ) public pure override returns ( bool ) {\r\n        return \r\n          interfaceId_ == type( IERC721 ).interfaceId ||\r\n          interfaceId_ == type( IERC721Enumerable ).interfaceId ||\r\n          interfaceId_ == type( IERC721Metadata ).interfaceId ||\r\n          interfaceId_ == type( IERC173 ).interfaceId ||\r\n          interfaceId_ == type( IERC165 ).interfaceId ||\r\n          interfaceId_ == type( IERC2981 ).interfaceId;\r\n      }\r\n    // +---------+\r\n  // **************************************\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/utils/ERC2981Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IERC2981.sol\";\r\n\r\nabstract contract ERC2981Base is IERC2981 {\r\n\t// Errors\r\n\t/**\r\n\t* @dev Thrown when the desired royalty rate is higher than 10,000\r\n\t* \r\n\t* @param royaltyRate : the desired royalty rate\r\n\t* @param royaltyBase : the maximum royalty rate\r\n\t*/\r\n\terror IERC2981_INVALID_ROYALTIES( uint256 royaltyRate, uint256 royaltyBase );\r\n\r\n\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\r\n\t// up to two digits below the unit such as 2.5% or 1.25%.\r\n\tuint private constant ROYALTY_BASE = 10000;\r\n\r\n\t// Represents the percentage of royalties on each sale on secondary markets.\r\n\t// Set to 0 to have no royalties.\r\n\tuint256 private _royaltyRate;\r\n\r\n\t// Address of the recipient of the royalties.\r\n\taddress private _royaltyRecipient;\r\n\r\n\t/**\r\n\t* @notice Called with the sale price to determine how much royalty is owed and to whom.\r\n\t* \r\n\t* Note: This function should be overriden to revert on a query for non existent token.\r\n\t* \r\n\t*  param tokenId_   : identifier of the NFT being referenced\r\n\t* @param salePrice_ : the sale price of the token sold\r\n\t* \r\n\t* @return address : the address receiving the royalties\r\n\t* @return uint256 : the royalty payment amount\r\n\t*/\r\n\tfunction royaltyInfo( uint256 /* tokenId_ */, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\r\n\t\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\r\n\t\t\treturn ( _royaltyRecipient, 0 );\r\n\t\t}\r\n\t\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\r\n\t\treturn ( _royaltyRecipient, _royaltyAmount_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `royaltyRecipient_`.\r\n\t* \r\n\t* @param royaltyRecipient_ : the address that will receive royalty payments\r\n\t* @param royaltyRate_      : the percentage of the sale price that will be taken off as royalties, expressed in Basis Points (100 BP = 1%)\r\n\t* \r\n\t* Requirements: \r\n\t* \r\n\t* - `royaltyRate_` cannot be higher than `10,000`;\r\n\t*/\r\n\tfunction _setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) internal virtual {\r\n\t\tif ( royaltyRate_ > ROYALTY_BASE ) {\r\n\t\t\trevert IERC2981_INVALID_ROYALTIES( royaltyRate_, ROYALTY_BASE );\r\n\t\t}\r\n\t\t_royaltyRate      = royaltyRate_;\r\n\t\t_royaltyRecipient = royaltyRecipient_;\r\n\t}\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/utils/IWhitelistable_ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n* Edit  : Squeebo\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract IWhitelistable_ECDSA {\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when trying to query the whitelist while it's not set\r\n  */\r\n\terror IWhitelistable_NOT_SET();\r\n  /**\r\n  * @dev Thrown when `account` has consumed their alloted access and tries to query more\r\n  * \r\n  * @param account : address trying to access the whitelist\r\n  */\r\n\terror IWhitelistable_CONSUMED( address account );\r\n  /**\r\n  * @dev Thrown when `account` does not have enough alloted access to fulfil their query\r\n  * \r\n  * @param account : address trying to access the whitelist\r\n  */\r\n\terror IWhitelistable_FORBIDDEN( address account );\r\n\r\n\t/**\r\n  * @dev A structure representing a signature proof to be decoded by the contract\r\n  */\r\n\tstruct Proof {\r\n\t\tbytes32 r;\r\n\t\tbytes32 s;\r\n\t\tuint8   v;\r\n\t}\r\n\r\n\taddress private _adminSigner;\r\n\tmapping( uint8 => mapping ( address => uint256 ) ) private _consumed;\r\n\r\n\t/**\r\n\t* @dev Ensures that `account_` has `qty_` alloted access on the `whitelistId_` whitelist.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* @param qty_         : the amount of whitelist access requested\r\n\t*/\r\n\tmodifier isWhitelisted( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_, uint256 qty_ ) {\r\n\t\tuint256 _allowed_ = checkWhitelistAllowance( account_, whitelistId_, alloted_, proof_ );\r\n\r\n\t\tif ( _allowed_ < qty_ ) {\r\n\t\t\trevert IWhitelistable_FORBIDDEN( account_ );\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the pass to protect the whitelist.\r\n\t* \r\n\t* @param adminSigner_ : the address validating the whitelist signatures\r\n\t*/\r\n\tfunction _setWhitelist( address adminSigner_ ) internal virtual {\r\n\t\t_adminSigner = adminSigner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the amount that `account_` is allowed to access from the whitelist.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* \r\n\t* @return uint256 : the total amount of whitelist allocation remaining for `account_`\r\n\t* \r\n\t* Requirements:\r\n\t* \r\n\t* - `_adminSigner` must be set.\r\n\t*/\r\n\tfunction checkWhitelistAllowance( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) public view returns ( uint256 ) {\r\n\t\tif ( _adminSigner == address( 0 ) ) {\r\n\t\t\trevert IWhitelistable_NOT_SET();\r\n\t\t}\r\n\r\n\t\tif ( _consumed[ whitelistId_ ][ account_ ] >= alloted_ ) {\r\n\t\t\trevert IWhitelistable_CONSUMED( account_ );\r\n\t\t}\r\n\r\n\t\tif ( ! _validateProof( account_, whitelistId_, alloted_, proof_ ) ) {\r\n\t\t\trevert IWhitelistable_FORBIDDEN( account_ );\r\n\t\t}\r\n\r\n\t\treturn alloted_ - _consumed[ whitelistId_ ][ account_ ];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function to decode a signature and compare it with the `_adminSigner`.\r\n\t* \r\n\t* @param account_     : the address to validate access\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param alloted_     : the max amount of whitelist spots allocated\r\n\t* @param proof_       : the signature proof to validate whitelist allocation\r\n\t* \r\n\t* @return bool : whether the signature is valid or not\r\n\t*/ \r\n\tfunction _validateProof( address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_ ) private view returns ( bool ) {\r\n\t\tbytes32 _digest_ = keccak256( abi.encode( whitelistId_, alloted_, account_ ) );\r\n\t\taddress _signer_ = ecrecover( _digest_, proof_.v, proof_.r, proof_.s );\r\n\t\treturn _signer_ == _adminSigner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Consumes `amount_` whitelist access passes from `account_`.\r\n\t* \r\n\t* @param account_     : the address to consume access from\r\n\t* @param whitelistId_ : the identifier of the whitelist being queried\r\n\t* @param qty_         : the amount of whitelist access consumed\r\n\t* \r\n\t* Note: Before calling this function, eligibility should be checked through {IWhitelistable-checkWhitelistAllowance}.\r\n\t*/\r\n\tfunction _consumeWhitelist( address account_, uint8 whitelistId_, uint256 qty_ ) internal {\r\n\t\tunchecked {\r\n\t\t\t_consumed[ whitelistId_ ][ account_ ] += qty_;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/utils/ITradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n\tmapping( address => OwnableDelegateProxy ) public proxies;\r\n}\r\n\r\nabstract contract ITradable {\r\n\t// list of accepted proxy registries\r\n\taddress[] public proxyRegistries;\r\n\r\n\t/**\r\n\t* @dev Internal function that adds a proxy registry to the list of accepted proxy registries.\r\n\t* \r\n\t* @param proxyRegistryAddress_ : the address of the new proxy registry\r\n\t*/\r\n\tfunction _addProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _index_ = proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tproxyRegistries.push( proxyRegistryAddress_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function that removes a proxy registry from the list of accepted proxy registries.\r\n\t* \r\n\t* @param proxyRegistryAddress_ : the address of the proxy registry to remove\r\n\t*/\r\n\tfunction _removeProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\tuint256 _len_ = proxyRegistries.length;\r\n\t\tuint256 _index_ = _len_;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tif ( proxyRegistries[ _index_ ] == proxyRegistryAddress_ ) {\r\n\t\t\t\tif ( _index_ + 1 != _len_ ) {\r\n\t\t\t\t\tproxyRegistries[ _index_ ] = proxyRegistries[ _len_ - 1 ];\r\n\t\t\t\t}\r\n\t\t\t\tproxyRegistries.pop();\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function that checks if `operator_` is a registered proxy for `tokenOwner_`.\r\n\t* \r\n\t* Note: Use this function to allow whitelisting of registered proxy.\r\n\t* \r\n\t* @param tokenOwner_ : the address the proxy operates on the behalf of\r\n\t* @param operator_   : the proxy address that operates on behalf of the token owner\r\n\t* \r\n\t* @return bool : whether `operator_` is allowed to operate on behalf of `tokenOwner_` or not\r\n\t*/\r\n\tfunction _isRegisteredProxy( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\r\n\t\tuint256 _index_ = proxyRegistries.length;\r\n\t\twhile ( _index_ > 0 ) {\r\n\t\t\tunchecked {\r\n\t\t\t\t_index_ --;\r\n\t\t\t}\r\n\t\t\tProxyRegistry _proxyRegistry_ = ProxyRegistry( proxyRegistries[ _index_ ] );\r\n\t\t\tif ( address( _proxyRegistry_.proxies( tokenOwner_ ) ) == operator_ ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}"
    },
    "contracts/EthereumContracts/contracts/utils/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract IPausable {\r\n\t// Enum to represent the sale state, defaults to ``PAUSED``.\r\n\tuint8 public constant PAUSED = 0;\r\n\r\n\t// Errors\r\n\t/**\r\n\t* @dev Thrown when a function is called with the wrong contract state.\r\n\t* \r\n\t* @param currentState : the current state of the contract\r\n\t*/\r\n\terror IPausable_INCORRECT_STATE( uint8 currentState );\r\n\t/**\r\n\t* @dev Thrown when trying to set the contract state to an invalid value.\r\n\t* \r\n\t* @param invalidState : the invalid contract state\r\n\t*/\r\n\terror IPausable_INVALID_STATE( uint8 invalidState );\r\n\r\n\t// The current state of the contract\r\n\tuint8 private _contractState;\r\n\r\n\t/**\r\n\t* @dev Emitted when the sale state changes\r\n\t*/\r\n\tevent ContractStateChanged( uint8 indexed previousState, uint8 indexed newState );\r\n\r\n\t/**\r\n\t* @dev Ensures that contract state is `expectedState_`.\r\n\t* \r\n\t* @param expectedState_ : the desirable contract state\r\n\t*/\r\n\tmodifier isState( uint8 expectedState_ ) {\r\n\t\tif ( _contractState != expectedState_ ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Ensures that contract state is not `unexpectedState_`.\r\n\t* \r\n\t* @param unexpectedState_ : the undesirable contract state\r\n\t*/\r\n\tmodifier isNotState( uint8 unexpectedState_ ) {\r\n\t\tif ( _contractState == unexpectedState_ ) {\r\n\t\t\trevert IPausable_INCORRECT_STATE( _contractState );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Internal function setting the contract state to `newState_`.\r\n\t* \r\n\t* Note: Contract state defaults to ``PAUSED``.\r\n\t* \t\t\tTo maintain extendability, this value kept as uint8 instead of enum.\r\n\t* \t\t\tAs a result, it is possible to set the state to an incorrect value.\r\n\t* \t\t\tTo avoid issues, `newState_` should be validated before calling this function\r\n\t*/\r\n\tfunction _setPauseState( uint8 newState_ ) internal virtual {\r\n\t\tuint8 _previousState_ = _contractState;\r\n\t\t_contractState = newState_;\r\n\t\temit ContractStateChanged( _previousState_, newState_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the current contract state.\r\n\t* \r\n\t* @return uint8 : the current contract state\r\n\t*/\r\n\tfunction getPauseState() public virtual view returns ( uint8 ) {\r\n\t\treturn _contractState;\r\n\t}\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/utils/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IERC173.sol\";\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract IOwnable is IERC173 {\r\n\t// Errors\r\n  /**\r\n  * @dev Thrown when `operator` is not the contract owner.\r\n  * \r\n  * @param operator : address trying to use a function reserved to contract owner without authorization\r\n  */\r\n  error IERC173_NOT_OWNER( address operator );\r\n\r\n\t// The owner of the contract\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\taddress _sender_ = msg.sender;\r\n\t\tif ( owner() != _sender_ ) {\r\n\t\t\trevert IERC173_NOT_OWNER( _sender_ );\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Initializes the contract setting `owner_` as the initial owner.\r\n\t* \r\n\t* Note: This function needs to be called in the contract constructor to initialize the contract owner, \r\n\t* if it is not, then parts of the contract might be non functional\r\n\t* \r\n\t* @param owner_ : address that owns the contract\r\n\t*/\r\n\tfunction _initIOwnable( address owner_ ) internal {\r\n\t\t_owner = owner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the address of the current owner.\r\n\t* \r\n\t* @return address : the current contract owner\r\n\t*/\r\n\tfunction owner() public view virtual returns ( address ) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfers ownership of the contract to `newOwner`.\r\n\t* \r\n\t* @param newOwner_ : address of the new contract owner\r\n\t* \r\n\t* Requirements:\r\n\t* \r\n  * - Caller must be the contract owner.\r\n\t*/\r\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\r\n\t\taddress _oldOwner_ = _owner;\r\n\t\t_owner = newOwner_;\r\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\r\n\t}\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n///\r\n/// @dev Interface for the NFT Royalty Standard\r\n///\r\ninterface IERC2981 /* is IERC165 */ {\r\n  /// ERC165 bytes to add to interface array - set in parent contract\r\n  /// implementing this standard\r\n  ///\r\n  /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n  /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n  /// _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n  /// @notice Called with the sale price to determine how much royalty\r\n  //          is owed and to whom.\r\n  /// @param tokenId_ - the NFT asset queried for royalty information\r\n  /// @param salePrice_ - the sale price of the NFT asset specified by tokenId_\r\n  /// @return receiver - address of who should be sent the royalty payment\r\n  /// @return royaltyAmount - the royalty payment amount for salePrice_\r\n  function royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) external view returns ( address receiver, uint256 royaltyAmount );\r\n}\r\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721Receiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param operator_ The address which called `safeTransferFrom` function\n    /// @param from_ The address which previously owned the token\n    /// @param tokenId_ The NFT identifier which is being transferred\n    /// @param data_ Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received( address operator_, address from_, uint256 tokenId_, bytes calldata data_ ) external returns( bytes4 );\n}\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable /* is IERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns ( uint256 );\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `index_` >= `totalSupply()`.\n    /// @param index_ A counter less than `totalSupply()`\n    /// @return The token identifier for the `index_`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex( uint256 index_ ) external view returns ( uint256 );\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `index_` >= `balanceOf(owner_)` or if\n    ///  `owner_` is the zero address, representing invalid NFTs.\n    /// @param owner_ An address where we are interested in NFTs owned by them\n    /// @param index_ A counter less than `balanceOf(owner_)`\n    /// @return The token identifier for the `index_`th NFT assigned to `owner_`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex( address owner_, uint256 index_ ) external view returns ( uint256 );\n}\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata /* is IERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns ( string memory _name );\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns ( string memory _symbol );\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI( uint256 _tokenId ) external view returns ( string memory );\n}\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity 0.8.17;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is IERC165 */ {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer( address indexed from_, address indexed to_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval( address indexed owner_, address indexed approved_, uint256 indexed tokenId_ );\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll( address indexed owner_, address indexed operator_, bool approved_ );\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param owner_ An address for whom to query the balance\n  /// @return The number of NFTs owned by `owner_`, possibly zero\n  function balanceOf( address owner_ ) external view returns ( uint256 );\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param tokenId_ The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `to_` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `to_` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  /// @param data_ Additional data with no specified format, sent in call to `to_`\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_, bytes calldata data_ ) external;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function safeTransferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `to_` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `from_` is\n  ///  not the current owner. Throws if `to_` is the zero address. Throws if\n  ///  `tokenId_` is not a valid NFT.\n  /// @param from_ The current owner of the NFT\n  /// @param to_ The new owner\n  /// @param tokenId_ The NFT to transfer\n  function transferFrom( address from_, address to_, uint256 tokenId_ ) external;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param approved_ The new approved NFT controller\n  /// @param tokenId_ The NFT to approve\n  function approve( address approved_, uint256 tokenId_ ) external;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param operator_ Address to add to the set of authorized operators\n  /// @param approved_ True if the operator is approved, false to revoke approval\n  function setApprovalForAll( address operator_, bool approved_ ) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `tokenId_` is not a valid NFT.\n  /// @param tokenId_ The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved( uint256 tokenId_ ) external view returns ( address );\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param owner_ The address that owns the NFTs\n  /// @param operator_ The address that acts on behalf of the owner\n  /// @return True if `operator_` is an approved operator for `owner_`, false otherwise\n  function isApprovedForAll( address owner_, address operator_ ) external view returns ( bool );\n}\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/EthereumContracts/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n* @dev Required interface of an ERC173 compliant contract, as defined in the\r\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\r\n*/\r\ninterface IERC173 /* is IERC165 */ {\r\n    /// @dev This emits when ownership of a contract changes.    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner    \r\n    /// @return The address of the owner.\r\n    function owner() view external returns(address);\r\n\t\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract    \r\n    function transferOwnership(address _newOwner) external;\t\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}