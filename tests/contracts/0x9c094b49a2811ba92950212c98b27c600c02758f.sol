{{
  "language": "Solidity",
  "sources": {
    "/contracts/BubblehouseNFTV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// Used to delegate ownership of a contract to another address, to save on unneeded transactions to approve contract use for users\ninterface IOpenSeaProxyRegistry {\n    function proxies(address wallet) external view returns (address proxy);\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool _approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract BubblehouseNFT4 is IERC165, IERC721, IERC721Metadata {\n\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef; // keccak256(bytes(\"Transfer(address,address,uint256)\"))\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to); // ERC2309\n\n    // only non-obvious errors are returned; obvious error conditions just call revert()\n    error TokenBurned();\n    error TransferFromIncorrectOwner();\n    error TransferToContractForbidden();\n    error OverSupplyLimit();\n\n    string private _name;\n    string private _symbol;\n    string private _baseMetadataURI;\n\n    address private _contractOwner; // assigns minter and operator, and adjusts other global settings\n    address private _minter; // the only entity that can mint\n    address private _bubblehouseOperator; // implicitly approved to transfer from all wallets\n    address private _openSeaProxyRegistryAddress; // implicitly approved to transfer from all wallets\n   \n    // Token state bit layout:\n    // - [0..159]   `addr`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    mapping(uint256 => uint256) private _tokenStates;\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n    uint256 private constant _BITMASK_BURNED_AND_NEXT_INITIALIZED = (1 << 224) | (1 << 225);\n\n    mapping(address => uint256) private _walletBalances;\n    mapping(address => mapping(address => bool)) private _walletOperators;\n    mapping(uint256 => address) private _tokenApprovals;\n    uint256 private _stride;\n    uint256 private _totalMinted = 0;\n    uint256 private _burnCounter;\n    uint256 private _supplyLimit;\n\n    function totalMinted() external view returns (uint256) {\n        return _totalMinted;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        unchecked {\n            return _totalMinted - _burnCounter;\n        }\n    }\n    modifier onlyContractOwner() {\n        if (msg.sender != _contractOwner) {\n            revert();\n        }\n        _;\n    }\n\n    constructor(string memory name_, string memory symbol_, uint64 supplyLimit_, uint64 stride_, uint64 premintQuantity_, address premintOwner_, address owner_, address minter_, address bubblehouseOperator_,  address openSeaProxyRegistryAddress_, string memory baseMetadataURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        _supplyLimit = supplyLimit_;\n        _stride = stride_;\n        if (owner_ == address(0)) {\n            _contractOwner = msg.sender;\n        } else {\n            _contractOwner = owner_;\n        }\n        _minter = minter_;\n        _bubblehouseOperator = bubblehouseOperator_;\n        _openSeaProxyRegistryAddress = openSeaProxyRegistryAddress_;\n        _baseMetadataURI = baseMetadataURI_;\n        if (premintQuantity_ != 0) {\n            _premint(premintOwner_, premintQuantity_);\n        }\n    }\n\n\n    // --- Inquiries ---\n\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        if (bytes(_symbol).length == 0) {\n            return _name;\n        } else {\n            return _symbol;\n        }\n    }\n\n    function supplyLimit() external view returns (uint256) {\n        return _supplyLimit;\n    }\n\n    function stride() external view returns (uint256) {\n        return _stride;\n    }\n\n    function balanceOf(address wallet) external view override returns (uint256) {\n        if (wallet == address(0)) {\n            revert();\n        }\n        return _walletBalances[wallet];\n    }\n\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        _revertUnlessValidTokenID(tokenId);\n        uint256 state = _tokenStateOf(tokenId);\n        if ((state & _BITMASK_BURNED) != 0) {\n            revert();\n        }\n        return address(uint160(state));\n    }\n\n    // TODO: do we need this function for some sort of weird interface complience? if not, remove.\n    function baseTokenURI() external view returns (string memory) {\n        return _baseMetadataURI;\n    }\n\n    function tokenURI(uint256 tokenId) external view override returns (string memory) {\n        _revertUnlessValidTokenID(tokenId);\n        return string.concat(_baseMetadataURI, \"/0x\", addressToString(address(this)), \"/\", intToString(tokenId));\n    }\n\n    function contractURI() external view returns (string memory) {\n        return string.concat(_baseMetadataURI, \"/0x\", addressToString(address(this)), \"/-1\");\n    }\n\n    function internalRawTokenState(uint256 tokenId) external view returns (uint256) {\n        return _tokenStates[tokenId];\n    }\n    function internalRawTokenStates(uint256 start, uint256 end) external view returns (uint256[] memory) {\n        unchecked {\n            if (start == 0) {\n                start = 1; // prevents overflow when computing `end-start+1` below\n            }\n            if (end > _totalMinted) {\n                end = _totalMinted;\n            }\n            if (end < start) {\n                return new uint256[](0);\n            }\n\n            uint256[] memory result = new uint256[](end - start + 1);\n            for (uint256 i = start; i <= end; ++i) {\n                result[i - start] = _tokenStates[i];\n            }\n            return result;\n        }\n    }\n\n    function internalResolvedTokenState(uint256 tokenId) external view returns (uint256) {\n        return _tokenStateOf(tokenId);\n    }\n    function internalResolvedTokenStates(uint256 start, uint256 end) external view returns (uint256[] memory) {\n        unchecked {\n            if (start == 0) {\n                start = 1; // prevents overflow when computing `end-start+1` below\n            }\n            if (end > _totalMinted) {\n                end = _totalMinted;\n            }\n            if (end < start) {\n                return new uint256[](0);\n            }\n\n            uint256 state = _tokenStateOf(start);\n\n            uint256[] memory result = new uint256[](end - start + 1);\n            for (uint256 i = start; i <= end; ++i) {\n                uint256 prev = state;\n                state = _tokenStates[i];\n                if (state == 0) {\n                    state = prev;\n                }\n                result[i - start] = state;\n            }\n            return result;\n        }\n    }\n\n    function tokensOfOwnerIn(address wallet, uint256 start, uint256 end) external view returns (uint256[] memory) {\n        unchecked {\n            if (start == 0) {\n                start = 1; // prevents overflow when computing `end-start+1` below\n            }\n            if (end > _totalMinted) {\n                end = _totalMinted;\n            }\n            uint256 maxCount = _walletBalances[wallet];\n            if (end < start || maxCount == 0) {\n                return new uint256[](0);\n            }\n            uint256 range = end - start + 1;\n            if (range < maxCount) {\n                maxCount = range;\n            }\n\n            uint256[] memory tokenIds = new uint256[](maxCount);\n            uint256 outIdx = 0;\n\n            address currentOwner = address(0);\n            uint256 state = _tokenStateOf(start);\n            if ((state & _BITMASK_BURNED) == 0) {\n                currentOwner = address(uint160(state));\n            }\n\n            for (uint256 i = start; i <= end && outIdx != maxCount; ++i) {\n                state = _tokenStates[i];\n                if (state != 0) {\n                    if ((state & _BITMASK_BURNED) != 0) {\n                        continue;\n                    }\n                    currentOwner = address(uint160(state));\n                }\n                if (currentOwner == wallet) {\n                    tokenIds[outIdx++] = i;\n                }\n            }\n\n            assembly { mstore(tokenIds, outIdx) } // shrink to actual size\n            return tokenIds;\n        }\n    }\n\n\n    // --- Mint, Transfer, Burn ---\n\n    function mint(address to, uint256 quantity) external {\n        if (msg.sender != _minter) revert();\n        if (quantity == 0) revert();\n\n        unchecked {\n            if (to.code.length != 0) revert TransferToContractForbidden();\n            uint256 oldTotalMinted = _totalMinted;\n            uint256 newTotalMinted = oldTotalMinted + quantity;\n            if (newTotalMinted > _supplyLimit) revert OverSupplyLimit();\n\n            uint256 start = oldTotalMinted + 1;\n\n            _walletBalances[to] += quantity;\n\n            uint256 toMasked;\n            uint256 newState;\n            assembly {\n                toMasked := and(to, _BITMASK_ADDRESS)\n                newState := or(toMasked, shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1)))\n            }\n            if (toMasked == 0) revert();\n            _tokenStates[start] = newState;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            assembly {\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, start)\n\n                let end := add(newTotalMinted, 1)\n                for {\n                    let tokenId := add(start, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n\n            _totalMinted = newTotalMinted;\n        }\n    }\n\n    function _premint(address to, uint256 quantity) private {\n        if (quantity == 0) return;\n        if (to == address(0)) revert();\n        if (to.code.length != 0) revert TransferToContractForbidden();\n\n        unchecked {\n            uint256 oldTotalMinted = _totalMinted;\n            uint256 newTotalMinted = oldTotalMinted + quantity;\n            if (newTotalMinted > _supplyLimit) revert OverSupplyLimit();\n            uint256 start = oldTotalMinted + 1;\n\n            _walletBalances[to] += quantity;\n\n            uint256 newState;\n            assembly {\n                newState := or(and(to, _BITMASK_ADDRESS), shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1)))\n            }\n            _tokenStates[start] = newState;\n\n            emit ConsecutiveTransfer(start, start + quantity - 1, address(0), to);\n\n            _totalMinted = newTotalMinted;\n        }\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external override {\n        transferFrom(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata /*data*/) external override {\n        transferFrom(from, to, tokenId);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public override {\n        if (to == address(0)) revert();\n        if (to.code.length != 0) revert TransferToContractForbidden();\n        _revertUnlessValidTokenID(tokenId);\n        uint256 state = _tokenStateOf(tokenId);\n        if ((state & _BITMASK_BURNED) != 0) revert TokenBurned();\n        address tokenOwner = address(uint160(state));\n        if (from != tokenOwner) revert TransferFromIncorrectOwner();\n        _revertUnlessAllowedToManageToken(_actualSender(), tokenId, tokenOwner);\n        _clearApproval(tokenId, tokenOwner);\n\n        unchecked {\n            _walletBalances[from] -= 1;\n            _walletBalances[to] += 1;\n\n            uint256 newState;\n            assembly {\n                newState := or(and(to, _BITMASK_ADDRESS), _BITMASK_NEXT_INITIALIZED)\n            }\n            _tokenStates[tokenId] = newState;\n\n            // Fill in next token's data\n            if ((state & _BITMASK_NEXT_INITIALIZED) == 0) {\n                uint256 next = tokenId + 1;\n                if (_tokenStates[next] == 0) {\n                    if (next <= _totalMinted) {\n                        _tokenStates[next] = state;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function burn(uint256 tokenId) external {\n        _revertUnlessValidTokenID(tokenId);\n        uint256 state = _tokenStateOf(tokenId);\n        if ((state & _BITMASK_BURNED) != 0) {\n            return;\n        }\n        address tokenOwner = address(uint160(state));\n        _revertUnlessAllowedToManageToken(_actualSender(), tokenId, tokenOwner);\n        _clearApproval(tokenId, tokenOwner);\n\n        unchecked {\n            _walletBalances[tokenOwner] -= 1;\n            assembly {\n                state := or(state, _BITMASK_BURNED_AND_NEXT_INITIALIZED)\n            }\n            _tokenStates[tokenId] = state;\n            _burnCounter += 1;\n        }\n\n        emit Transfer(tokenOwner, address(0), tokenId);\n    }\n\n\n    // --- Approvals ---\n    \n    function approve(address to, uint256 tokenId) external override {\n        _revertUnlessValidTokenID(tokenId);\n        uint256 state = _tokenStateOf(tokenId);\n        if ((state & _BITMASK_BURNED) != 0) revert TokenBurned();\n        address tokenOwner = address(uint160(state));\n        address actor = _actualSender();\n        _revertUnlessAllowedToManageToken(actor, tokenId, tokenOwner);\n        _tokenApprovals[tokenId] = to;\n        emit Approval(tokenOwner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) external view override returns (address) {\n        _revertUnlessValidTokenID(tokenId);\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) external override {\n        address actor = _actualSender();\n        if (actor == operator) {\n            revert();\n        }\n        _walletOperators[actor][operator] = approved;\n        emit ApprovalForAll(actor, operator, approved);\n    }\n\n    function isApprovedForAll(address wallet, address operator) external view override returns (bool) {\n        return _walletOperators[wallet][operator];\n    }\n\n    function _clearApproval(uint256 tokenId, address tokenOwner) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n            emit Approval(tokenOwner, address(0), tokenId);\n        }\n    }\n\n\n    // --- Marketplaces ---\n\n    function isOpenSeaOperator(address actor, address wallet) private view returns (bool) {\n        if (_openSeaProxyRegistryAddress == address(0)) {\n            return false;\n        }\n        IOpenSeaProxyRegistry proxyRegistry = IOpenSeaProxyRegistry(_openSeaProxyRegistryAddress);\n        return (address(proxyRegistry.proxies(wallet)) == actor);\n    }\n\n\n    // -- Access checks ---\n\n    function _revertUnlessValidTokenID(uint256 tokenId) private view {\n        if (tokenId < 1) {\n            revert();\n        }\n        if (tokenId > _totalMinted) {\n            revert();\n        }\n    }\n\n    // assumes token ID is valid\n    function _revertUnlessAllowedToManageToken(address actor, uint256 tokenId, address wallet) private view {\n        if (actor == wallet) {\n            return;\n        }\n        if (actor == _bubblehouseOperator) {\n            if (_bubblehouseOperator != address(0)) {\n                return;\n            }\n        }\n        if (_walletOperators[wallet][actor]) {\n            return;\n        }\n        if (isOpenSeaOperator(actor, wallet)) {\n            return;\n        }\n        if (_tokenApprovals[tokenId] == actor) {\n            return;\n        }\n        revert();\n    }\n\n\n    // --- Sparse Packed Token Info ---\n\n    function _tokenStateOf(uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n        unchecked {\n            uint256 state = _tokenStates[curr];\n            // There will always be a non-zero state before any zero state.\n            while (state == 0) {\n                --curr;\n                state = _tokenStates[curr];\n            }\n            return state;\n        }\n    }\n\n\n    // --- Admin Stuff ---\n\n    function rename(string calldata name_, string calldata symbol_) external onlyContractOwner {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function baseMetadataURI() external view returns (string memory) {\n        return _baseMetadataURI;\n    }\n\n    function setBaseMetadataURI(string calldata newBaseURI) external onlyContractOwner {\n        _baseMetadataURI = newBaseURI;\n    }\n\n    function replaceContractOwner(address newOwner) external onlyContractOwner {\n        if (newOwner == address(0)) {\n            revert();\n        }\n        address oldOwner = _contractOwner;\n        if (newOwner == oldOwner) {\n            return;\n        }\n        _contractOwner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function bubblehouseOperator() external view returns (address) {\n        return _bubblehouseOperator;\n    }\n    function replaceBubblehouseOperator(address newOperator) external onlyContractOwner {\n        if (_bubblehouseOperator == address(0)) {\n            revert();\n        }\n        if (newOperator == address(0)) {\n            revert();\n        }\n        _bubblehouseOperator = newOperator;\n    }\n    // Irevocably disables Bubblehouse operator priviledges. Wallets will need operator approvals\n    // to be managed by the platform after this.\n    function burnBubblehouseOperator() external onlyContractOwner {\n        _bubblehouseOperator = address(0);\n    }\n\n    function setOpenSeaProxyRegistryAddress(address addr) external onlyContractOwner {\n        _openSeaProxyRegistryAddress = addr;\n    }\n\n    function owner() external view returns (address) {\n        return _contractOwner;\n    }\n\n    function minter() external view returns (address) {\n        return _minter;\n    }\n    function replaceMinter(address newMinter) external onlyContractOwner {\n        if (_minter == address(0)) {\n            revert();\n        }\n        if (newMinter == address(0)) {\n            revert();\n        }\n        _minter = newMinter;\n    }\n    // Irevocably disables minter priviledges. Nothing can be minted after this.\n    function burnMinter() external onlyContractOwner {\n        _minter = address(0);\n    }\n\n    function decreaseSupplyLimit(uint64 supplyLimit_) external onlyContractOwner {\n        if (supplyLimit_ >= _supplyLimit) revert();\n        _supplyLimit = supplyLimit_;\n    }\n\n\n    // --- Utils ---\n    \n    // TODO: handle metatransactions in the future if we need to.\n    function _actualSender() private view returns (address) {\n        return msg.sender;\n    }\n\n    // From @openzeppelin/contracts/utils/Strings.sol\n    function intToString(uint256 value) private pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function addressToString(address x) private pure returns (string memory) {\n        unchecked {\n            bytes memory s = new bytes(40);\n            for (uint i = 0; i < 20; i++) {\n                bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n                bytes1 hi = bytes1(uint8(b) / 16);\n                s[2*i] = hexChar(hi);\n                s[2*i+1] = hexChar(bytes1(uint8(b) - 16 * uint8(hi)));            \n            }\n            return string(s);\n        }\n    }\n\n    function hexChar(bytes1 b) private pure returns (bytes1 c) {\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n        else return bytes1(uint8(b) + 0x57);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "constantinople",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}