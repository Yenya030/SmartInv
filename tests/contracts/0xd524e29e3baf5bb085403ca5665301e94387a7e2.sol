{{
  "language": "Solidity",
  "sources": {
    "contracts/mining/EulDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../vendor/MerkleProof.sol\";\nimport \"../Utils.sol\";\n\ninterface IEulStakes {\n    function stakeGift(address beneficiary, address underlying, uint amount) external;\n}\n\ncontract EulDistributor {\n    address public immutable eul;\n    address public immutable eulStakes;\n    string public constant name = \"EUL Distributor\";\n\n    address public owner;\n    bytes32 public currRoot;\n    bytes32 public prevRoot;\n    mapping(address => mapping(address => uint)) public claimed; // account -> token -> amount\n\n    event OwnerChanged(address indexed newOwner);\n\n    constructor(address eul_, address eulStakes_) {\n        eul = eul_;\n        eulStakes = eulStakes_;\n        owner = msg.sender;\n        Utils.safeApprove(eul_, eulStakes_, type(uint).max);\n    }\n\n    // Owner functions\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"unauthorized\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerChanged(newOwner);\n    }\n\n    function updateRoot(bytes32 newRoot) external onlyOwner {\n        prevRoot = currRoot;\n        currRoot = newRoot;\n    }\n\n    // Claiming\n\n    /// @notice Claim distributed tokens\n    /// @param account Address that should receive tokens\n    /// @param token Address of token being claimed (ie EUL)\n    /// @param proof Merkle proof that validates this claim\n    /// @param stake If non-zero, then the address of a token to auto-stake to, instead of claiming\n    function claim(address account, address token, uint claimable, bytes32[] calldata proof, address stake) external {\n        bytes32 candidateRoot = MerkleProof.processProof(proof, keccak256(abi.encodePacked(account, token, claimable))); // 72 byte leaf\n        require(candidateRoot == currRoot || candidateRoot == prevRoot, \"proof invalid/expired\");\n\n        uint alreadyClaimed = claimed[account][token];\n        require(claimable > alreadyClaimed, \"already claimed\");\n\n        uint amount;\n        unchecked {\n            amount = claimable - alreadyClaimed;\n        }\n\n        claimed[account][token] = claimable;\n\n        if (stake == address(0)) {\n            Utils.safeTransfer(token, account, amount);\n        } else {\n            require(msg.sender == account, \"can only auto-stake for yourself\");\n            require(token == eul, \"can only auto-stake EUL\");\n            IEulStakes(eulStakes).stakeGift(account, stake, amount);\n        }\n    }\n}\n"
    },
    "contracts/vendor/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Interfaces.sol\";\n\nlibrary Utils {\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n\n    function safeApprove(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n}\n"
    },
    "contracts/Interfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IERC20Permit {\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n    function permit(address owner, address spender, uint value, uint deadline, bytes calldata signature) external;\n}\n\ninterface IERC3156FlashBorrower {\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);\n}\n\ninterface IERC3156FlashLender {\n    function maxFlashLoan(address token) external view returns (uint256);\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}