{{
  "language": "Solidity",
  "sources": {
    "src/ChainWaves.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\nimport \"solmate/tokens/ERC721.sol\";\r\nimport \"solmate/auth/Owned.sol\";\r\nimport \"openzeppelin-contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"./AnonymiceLibrary.sol\";\r\nimport \"./ChainWavesGenerator.sol\";\r\nimport \"./ChainWavesErrors.sol\";\r\n\r\ncontract ChainWaves is ChainWavesErrors, ERC721, Owned {\r\n    using AnonymiceLibrary for uint8;\r\n\r\n    struct Trait {\r\n        string traitName;\r\n        string traitType;\r\n    }\r\n\r\n    uint256 public constant MAX_SUPPLY = 512;\r\n    uint256 public constant MINT_PRICE = 0.0256 ether;\r\n    uint256 public constant MINT_START = 1674156600;\r\n    uint256 public constant MAX_MINT = 3;\r\n    uint256 public snowcrashReserve = 120;\r\n    bool public MINTING_LIVE;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    // TODO: generate actual root (this is folded faces)\r\n    bytes32 constant snowcrashRoot =\r\n        0xea35e50958ff75fe96e04a6dd792de75a26dd0c2a2d12e8a4c485d938961eb39;\r\n\r\n    bool private freeMinted;\r\n\r\n    mapping(address => uint256) mintInfo;\r\n    mapping(uint256 => uint256) tokenIdToHash;\r\n    mapping(uint256 => Trait[]) public traitTypes;\r\n\r\n    //Mappings\r\n\r\n    ChainWavesGenerator chainWavesGenerator;\r\n\r\n    //uint arrays\r\n    uint16[][6] private TIERS;\r\n\r\n    constructor()\r\n        ERC721(\"ChainWaves\", \"CA\")\r\n        Owned(0xB6eE8B1899e4cad7e28015995B82969e44BD0bb0)\r\n    {\r\n        chainWavesGenerator = new ChainWavesGenerator();\r\n\r\n        //Palette\r\n        TIERS[0] = [1000, 1500, 1400, 1700, 1200, 400, 400, 1600, 800];\r\n        //Noise\r\n        TIERS[1] = [1000, 4000, 4000, 1000];\r\n        //Speed\r\n        TIERS[2] = [1000, 4000, 4000, 1000];\r\n        //Char set\r\n        TIERS[3] = [2250, 2250, 2250, 2250, 600, 400];\r\n        //Detail\r\n        TIERS[4] = [1000, 6000, 3000];\r\n        //NumCols\r\n        TIERS[5] = [800, 6200, 2600, 400];\r\n    }\r\n\r\n    //prevents someone calling read functions the same block they mint\r\n    modifier disallowIfStateIsChanging() {\r\n        if ((mintInfo[msg.sender] >> 8) == block.number) revert Stap();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a digit from 0 - 10000 into its corresponding rarity based on the given rarity tier.\r\n     * @param _randinput The input from 0 - 10000 to use for rarity gen.\r\n     * @param _rarityTier The tier to use.\r\n     */\r\n    function rarityGen(uint256 _randinput, uint8 _rarityTier)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        uint16 currentLowerBound;\r\n        uint256 tiersLength = TIERS[_rarityTier].length;\r\n        for (uint8 i; i < tiersLength; ++i) {\r\n            uint16 thisPercentage = TIERS[_rarityTier][i];\r\n            if (\r\n                _randinput >= currentLowerBound &&\r\n                _randinput < currentLowerBound + thisPercentage\r\n            ) return i;\r\n            currentLowerBound = currentLowerBound + thisPercentage;\r\n        }\r\n\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @param _a The address to be used within the hash.\r\n     */\r\n    function hash(address _a, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        block.timestamp,\r\n                        block.difficulty,\r\n                        _a,\r\n                        _tokenId\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function normieMint(uint256 _amount) external payable {\r\n        if (_amount > MAX_MINT) revert MaxThree();\r\n        if (msg.value != MINT_PRICE * _amount) revert MintPrice();\r\n\r\n        uint256 minterInfo = mintInfo[msg.sender];\r\n        if ((minterInfo & 0xF) != 0) revert PublicMinted();\r\n\r\n        minterInfo |= 1;\r\n        minterInfo = (minterInfo & 0xFF) + (block.number << 8);\r\n        mintInfo[msg.sender] = minterInfo;\r\n\r\n        mintInternal(msg.sender, _amount);\r\n    }\r\n\r\n    // TODO: add merkle root,\r\n    function snowcrashMint(bytes32[] calldata merkleProof) external payable {\r\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\r\n        require(\r\n            MerkleProof.verify(merkleProof, snowcrashRoot, node),\r\n            \"Not on WL\"\r\n        );\r\n        if (msg.value != MINT_PRICE) revert MintPrice();\r\n\r\n        uint256 minterInfo = mintInfo[msg.sender];\r\n        if (((minterInfo & 0xF0) >> 4) != 0) revert SnowcrashMinted();\r\n        if (snowcrashReserve == 0) revert ReserveClosed();\r\n        --snowcrashReserve;\r\n\r\n        minterInfo |= (1 << 4);\r\n        minterInfo = (minterInfo & 0xFF) + (block.number << 8);\r\n        mintInfo[msg.sender] = minterInfo;\r\n\r\n        mintInternal(msg.sender, 1);\r\n    }\r\n\r\n    function freeMints(\r\n        address[] calldata _addresses,\r\n        uint256[] calldata _amount\r\n    ) external payable onlyOwner {\r\n        if (freeMinted) revert FreeMintDone();\r\n        uint256 addressesLength = _addresses.length;\r\n        if (addressesLength != _amount.length) revert ArrayLengths();\r\n        for (uint256 i; i < addressesLength; ++i) {\r\n            mintInternal(_addresses[i], _amount[i]);\r\n        }\r\n\r\n        freeMinted = true;\r\n    }\r\n\r\n    function mintInternal(address _to, uint256 _amount) internal {\r\n        if (!MINTING_LIVE || block.timestamp < MINT_START) revert NotLive();\r\n        if (_amount == 0) revert MintZero();\r\n        if (totalSupply + _amount + snowcrashReserve > MAX_SUPPLY)\r\n            revert SoldOut();\r\n        uint256 nextTokenId = totalSupply;\r\n        uint256 newTotalSupply = totalSupply + _amount;\r\n\r\n        for (; nextTokenId < newTotalSupply; ++nextTokenId) {\r\n            tokenIdToHash[nextTokenId] = hash(_to, nextTokenId);\r\n            _mint(_to, nextTokenId);\r\n        }\r\n        totalSupply = newTotalSupply;\r\n    }\r\n\r\n    // hash stuff\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     * From anonymice\r\n     */\r\n\r\n    function buildHash(uint256 _t) internal view returns (string memory) {\r\n        // This will generate a 4 character string.\r\n        string memory currentHash = \"\";\r\n        uint256 tokenHash = tokenIdToHash[_t];\r\n\r\n        for (uint8 i; i < 6; ++i) {\r\n            uint16 _randinput = uint16(\r\n                uint256(keccak256(abi.encodePacked(tokenHash, i))) % 10000\r\n            );\r\n            currentHash = string(\r\n                abi.encodePacked(\r\n                    currentHash,\r\n                    rarityGen(_randinput, i).toString()\r\n                )\r\n            );\r\n        }\r\n        return currentHash;\r\n    }\r\n\r\n    // Views\r\n\r\n    function hashToMetadata(string memory _hash)\r\n        public\r\n        view\r\n        disallowIfStateIsChanging\r\n        returns (string memory)\r\n    {\r\n        string memory metadataString;\r\n\r\n        for (uint8 i; i < 6; ++i) {\r\n            uint8 thisTraitIndex = AnonymiceLibrary.parseInt(\r\n                AnonymiceLibrary.substring(_hash, i, i + 1)\r\n            );\r\n\r\n            metadataString = string(\r\n                abi.encodePacked(\r\n                    metadataString,\r\n                    '{\"trait_type\":\"',\r\n                    traitTypes[i][thisTraitIndex].traitType,\r\n                    '\",\"value\":\"',\r\n                    traitTypes[i][thisTraitIndex].traitName,\r\n                    '\"}'\r\n                )\r\n            );\r\n\r\n            if (i != 5)\r\n                metadataString = string(abi.encodePacked(metadataString, \",\"));\r\n        }\r\n\r\n        return string(abi.encodePacked(\"[\", metadataString, \"]\"));\r\n    }\r\n\r\n    function _tokenIdToHash(uint256 _tokenId)\r\n        public\r\n        view\r\n        disallowIfStateIsChanging\r\n        returns (string memory tokenHash)\r\n    {\r\n        if (_tokenId >= totalSupply) revert NonExistantId();\r\n        tokenHash = buildHash(_tokenId);\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory _URI)\r\n    {\r\n        if (_tokenId >= totalSupply) revert NonExistantId();\r\n        string memory _hash = _tokenIdToHash(_tokenId);\r\n        _URI = string(\r\n            abi.encodePacked(\r\n                \"data:application/json;base64,\",\r\n                AnonymiceLibrary.encode(\r\n                    bytes(\r\n                        string(\r\n                            abi.encodePacked(\r\n                                '{\"name\": \"CH41NW4V35 #',\r\n                                AnonymiceLibrary.toString(_tokenId),\r\n                                '\",\"description\": \"Fully onchain generative art SVG collection. Created by McToady & Circolors.\"',\r\n                                ',\"image\": \"data:image/svg+xml;base64,',\r\n                                AnonymiceLibrary.encode(\r\n                                    bytes(\r\n                                        abi.encodePacked(\r\n                                            \"<svg viewBox='0 0 20 20' width='600' height='600' xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMin'><rect width='20' height='20' fill='#\",\r\n                                            chainWavesGenerator.buildSVG(\r\n                                                _tokenId,\r\n                                                _hash\r\n                                            ),\r\n                                            \"</svg>\"\r\n                                        )\r\n                                    )\r\n                                ),\r\n                                '\",\"attributes\":',\r\n                                hashToMetadata(_hash),\r\n                                \"}\"\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // Owner Functions\r\n    /**\r\n     * @dev Add a trait type\r\n     * @param _traitTypeIndex The trait type index\r\n     * @param traits Array of traits to add\r\n     */\r\n\r\n    function addTraitType(uint256 _traitTypeIndex, Trait[] memory traits)\r\n        external\r\n        payable\r\n        onlyOwner\r\n    {\r\n        for (uint256 i; i < traits.length; ++i) {\r\n            traitTypes[_traitTypeIndex].push(\r\n                Trait(traits[i].traitName, traits[i].traitType)\r\n            );\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    function flipMint() external payable onlyOwner {\r\n        MINTING_LIVE = !MINTING_LIVE;\r\n    }\r\n\r\n    function withdraw() external payable onlyOwner {\r\n        uint256 twelve = (address(this).balance / 100) * 12;\r\n        uint256 eightythree = (address(this).balance / 100) * 83;\r\n        uint256 five = (address(this).balance / 100) * 5;\r\n        (bool sentI, ) = payable(\r\n            address(0x4533d1F65906368ebfd61259dAee561DF3f3559D)\r\n        ).call{value: twelve}(\"\");\r\n        if (!sentI) revert WithdrawFail();\r\n        (bool sentC, ) = payable(\r\n            address(0x888f8AA938dbb18b28bdD111fa4A0D3B8e10C871)\r\n        ).call{value: five}(\"\");\r\n        if (!sentC) revert WithdrawFail();\r\n        (bool sentT, ) = payable(\r\n            address(0xE4260Df86f5261A41D19c2066f1Eb2Eb4F009e84)\r\n        ).call{value: eightythree}(\"\");\r\n        if (!sentT) revert WithdrawFail();\r\n    }\r\n\r\n    function wipeSnowcrashReserve() external payable onlyOwner {\r\n        snowcrashReserve = 0;\r\n    }\r\n}\r\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\r\nabstract contract ERC721 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                         METADATA STORAGE/LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                      ERC721 BALANCE/OWNER STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(uint256 => address) internal _ownerOf;\r\n\r\n    mapping(address => uint256) internal _balanceOf;\r\n\r\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\r\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual returns (uint256) {\r\n        require(owner != address(0), \"ZERO_ADDRESS\");\r\n\r\n        return _balanceOf[owner];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                         ERC721 APPROVAL STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 id) public virtual {\r\n        address owner = _ownerOf[id];\r\n\r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\r\n\r\n        getApproved[id] = spender;\r\n\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        require(from == _ownerOf[id], \"WRONG_FROM\");\r\n\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(\r\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        unchecked {\r\n            _balanceOf[from]--;\r\n\r\n            _balanceOf[to]++;\r\n        }\r\n\r\n        _ownerOf[id] = to;\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\r\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 id) internal virtual {\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\r\n\r\n        // Counter overflow is incredibly unrealistic.\r\n        unchecked {\r\n            _balanceOf[to]++;\r\n        }\r\n\r\n        _ownerOf[id] = to;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(uint256 id) internal virtual {\r\n        address owner = _ownerOf[id];\r\n\r\n        require(owner != address(0), \"NOT_MINTED\");\r\n\r\n        // Ownership check above ensures no underflow.\r\n        unchecked {\r\n            _balanceOf[owner]--;\r\n        }\r\n\r\n        delete _ownerOf[id];\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(owner, address(0), id);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL SAFE MINT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeMint(address to, uint256 id) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\r\nabstract contract ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC721TokenReceiver.onERC721Received.selector;\r\n    }\r\n}\r\n"
    },
    "lib/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\r\nabstract contract Owned {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            OWNERSHIP STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public owner;\r\n\r\n    modifier onlyOwner() virtual {\r\n        require(msg.sender == owner, \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNERSHIP LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        owner = newOwner;\r\n\r\n        emit OwnershipTransferred(msg.sender, newOwner);\r\n    }\r\n}\r\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n"
    },
    "src/AnonymiceLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary AnonymiceLibrary {\r\n    string internal constant TABLE =\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return \"\";\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {\r\n\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                dataPtr := add(dataPtr, 3)\r\n\r\n                // read 3 bytes\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function parseInt(string memory _a)\r\n        internal\r\n        pure\r\n        returns (uint8 _parsedInt)\r\n    {\r\n        bytes memory bresult = bytes(_a);\r\n        uint8 mint = 0;\r\n        for (uint8 i = 0; i < bresult.length; i++) {\r\n            if (\r\n                (uint8(uint8(bresult[i])) >= 48) &&\r\n                (uint8(uint8(bresult[i])) <= 57)\r\n            ) {\r\n                mint *= 10;\r\n                mint += uint8(bresult[i]) - 48;\r\n            }\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function substring(\r\n        string memory str,\r\n        uint256 startIndex,\r\n        uint256 endIndex\r\n    ) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex - startIndex);\r\n        for (uint256 i = startIndex; i < endIndex; i++) {\r\n            result[i - startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n"
    },
    "src/ChainWavesGenerator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./AnonymiceLibrary.sol\";\r\n\r\ncontract ChainWavesGenerator {\r\n    using AnonymiceLibrary for uint8;\r\n\r\n    string[][9] private PALETTES;\r\n    uint256[] private NOISE;\r\n    uint256[] private SPEED;\r\n    string[] private CHARS;\r\n    uint256[] private TIGHTNESS;\r\n\r\n    struct Traits {\r\n        string[] palette;\r\n        uint256 noise;\r\n        uint256 speed;\r\n        string charSet;\r\n        uint256 tightness;\r\n        uint256 numCols;\r\n    }\r\n\r\n    constructor() {\r\n        //lava\r\n        PALETTES[0] = [\"d00000\", \"370617\", \"faa307\", \"e85d04\", \"03071e\"];\r\n        //flamingo\r\n        PALETTES[1] = [\"3a0ca3\", \"f72585\", \"4cc9f0\", \"7209b7\", \"4cc9f0\"];\r\n        //rioja\r\n        PALETTES[2] = [\"250902\", \"38040e\", \"640d14\", \"800e13\", \"ad2831\"];\r\n        //forest\r\n        PALETTES[3] = [\"013026\", \"a1ce3f\", \"107e57\", \"014760\", \"cbe58e\"];\r\n        //samba\r\n        PALETTES[4] = [\"009638\", \"F6D800\", \"002672\", \"fff\", \"f8961e\"];\r\n        //pepewaves\r\n        PALETTES[5] = [\"23B024\", \"F02423\", \"294AF6\", \"fff\", \"000\"];\r\n        //cow\r\n        PALETTES[6] = [\"aabf98\", \"1f1f1f\", \"f2f2f2\", \"b5caa3\", \"20251e\"];\r\n        //pastelize\r\n        PALETTES[7] = [\"7067cf\", \"b7c0ee\", \"cbf3d2\", \"f87575\", \"ef626c\"];\r\n        //dank\r\n        PALETTES[8] = [\"414Cb3\", \"06061a\", \"e80663\", \"fff\", \"ff0066\"];\r\n\r\n        NOISE = [20, 35, 55, 85];\r\n\r\n        SPEED = [95, 75, 50, 25];\r\n\r\n        CHARS = [\"#83!:\", \"@94?;\", \"W72a+\", \"N$50c\", \"0101/\", \"gm;)'\"];\r\n\r\n        TIGHTNESS = [2, 3, 5];\r\n    }\r\n\r\n    struct Palette {\r\n        bytes3 bg;\r\n        bytes3 colOne;\r\n        bytes3 colTwo;\r\n    }\r\n\r\n    function buildLine(\r\n        string memory _chars,\r\n        uint256 _modJump,\r\n        uint8 _x,\r\n        uint8 _y\r\n    ) public pure returns (string memory lineOut) {\r\n        bytes memory byteChars = bytes(_chars);\r\n\r\n        uint256 randomModulo = 1;\r\n        lineOut = string(\r\n            abi.encodePacked(\r\n                \"<text x ='-\",\r\n                _x.toString(),\r\n                \"' y='\",\r\n                _y.toString(),\r\n                \"'>\"\r\n            )\r\n        );\r\n        for (uint256 i; i < 12; ++i) {\r\n            string memory charChoice = string(\r\n                abi.encodePacked(byteChars[randomModulo % 4])\r\n            );\r\n            lineOut = string(abi.encodePacked(lineOut, charChoice));\r\n            randomModulo += _modJump;\r\n        }\r\n        lineOut = string(abi.encodePacked(lineOut, \"</text>\"));\r\n    }\r\n\r\n    function buildXLines(\r\n        string memory _chars,\r\n        uint256 _modStart,\r\n        uint256 numLines\r\n    ) public pure returns (string memory lineOut) {\r\n        uint8 x = 1;\r\n        uint8 y;\r\n        for (uint256 i; i < numLines; ++i) {\r\n            lineOut = string(\r\n                abi.encodePacked(lineOut, buildLine(_chars, _modStart, x, y))\r\n            );\r\n            _modStart += 7;\r\n            y += 4;\r\n            if (x == 1) {\r\n                x = 3;\r\n            } else {\r\n                x = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function buildSVG(uint256 _tokenId, string memory _hash)\r\n        public\r\n        view\r\n        returns (string memory _svg)\r\n    {\r\n        // get traits from id\r\n        Traits memory tokenTraits = buildTraits(_hash);\r\n\r\n        uint256 modStart = tokenTraits.noise + tokenTraits.tightness;\r\n        _svg = string(\r\n            abi.encodePacked(\r\n                tokenTraits.palette[0],\r\n                \"'/><defs><g id='chars' font-family='monospace'>\",\r\n                buildXLines(\r\n                    tokenTraits.charSet,\r\n                    modStart,\r\n                    10 - tokenTraits.numCols\r\n                ),\r\n                \"<animate attributeName='font-size' attributeType='XML' values='100%;\",\r\n                AnonymiceLibrary.toString(tokenTraits.speed),\r\n                \"%;100%' begin='0s' dur='15s' repeatCount='indefinite'/></g><filter id='turbulence'><feTurbulence type='turbulence' baseFrequency='0.\",\r\n                AnonymiceLibrary.toString(tokenTraits.noise),\r\n                \"' numOctaves='\",\r\n                AnonymiceLibrary.toString(tokenTraits.tightness),\r\n                \"' result='noise' seed='\",\r\n                AnonymiceLibrary.toString(_tokenId),\r\n                buildUseLines(tokenTraits.palette, tokenTraits.numCols)\r\n            )\r\n        );\r\n    }\r\n\r\n    function buildTraits(string memory _hash)\r\n        public\r\n        view\r\n        returns (Traits memory tokenTraits)\r\n    {\r\n        uint256[] memory traitArray = new uint256[](6);\r\n\r\n        for (uint256 i; i < 6; ++i) {\r\n            traitArray[i] = AnonymiceLibrary.parseInt(\r\n                AnonymiceLibrary.substring(_hash, i, i + 1)\r\n            );\r\n        }\r\n        tokenTraits = Traits(\r\n            PALETTES[traitArray[0]],\r\n            NOISE[traitArray[1]],\r\n            SPEED[traitArray[2]],\r\n            CHARS[traitArray[3]],\r\n            TIGHTNESS[traitArray[4]],\r\n            traitArray[5] + 1\r\n        );\r\n        // Go palettes array and return this palette\r\n    }\r\n\r\n    function buildUseLines(string[] memory _pal, uint256 _numCols)\r\n        internal\r\n        pure\r\n        returns (string memory output)\r\n    {\r\n        output = \"'/><feDisplacementMap in='SourceGraphic' in2='noise' scale='3' /></filter></defs>\";\r\n        uint256 y;\r\n\r\n        for (uint256 i; i < _numCols; ++i) {\r\n            output = string(\r\n                abi.encodePacked(\r\n                    output,\r\n                    \"<use href='#chars' y='\",\r\n                    AnonymiceLibrary.toString(y),\r\n                    \"' x='0' filter='url(#turbulence)' width='20' height='20' fill='#\",\r\n                    _pal[i + 1],\r\n                    \"'/>\"\r\n                )\r\n            );\r\n\r\n            y += 3;\r\n        }\r\n    }\r\n}\r\n"
    },
    "src/ChainWavesErrors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\ninterface ChainWavesErrors {\r\n    error SoldOut();\r\n    error NotLive();\r\n    error MintPrice();\r\n    error MaxThree();\r\n    error PublicMinted();\r\n    error SnowcrashMinted();\r\n    error NotToad();\r\n    error FreeMintDone();\r\n    error NotSnowcrashList();\r\n    error ReserveClosed();\r\n    error SelfMintOnly();\r\n    error ArrayLengths();\r\n    error NonExistantId();\r\n    error Stap();\r\n    error WithdrawFail();\r\n    error MintZero();\r\n}\r\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "solmate/=lib/solmate/src/",
      "src/=src/",
      "test/=test/",
      "script/=script/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}