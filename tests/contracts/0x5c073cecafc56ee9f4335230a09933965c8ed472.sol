{{
  "language": "Solidity",
  "sources": {
    "contracts/SeasonRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {OwnableTwoSteps} from \"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\";\nimport {Pausable} from \"@looksrare/contracts-libs/contracts/Pausable.sol\";\nimport {ReentrancyGuard} from \"@looksrare/contracts-libs/contracts/ReentrancyGuard.sol\";\n\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title SeasonRewardsDistributor\n * @notice It distributes LOOKS tokens with rolling Merkle airdrops.\n */\ncontract SeasonRewardsDistributor is Pausable, ReentrancyGuard, OwnableTwoSteps, LowLevelERC20Transfer {\n    uint256 public constant BUFFER_ADMIN_WITHDRAW = 3 days;\n\n    address public immutable looksRareToken;\n\n    // Current reward round (users can only claim pending rewards for the current round)\n    uint256 public currentRewardRound;\n\n    // Last paused timestamp\n    uint256 public lastPausedTimestamp;\n\n    // Max amount per user in current tree\n    uint256 public maximumAmountPerUserInCurrentTree;\n\n    // Total amount claimed by user (in LOOKS)\n    mapping(address => uint256) public amountClaimedByUser;\n\n    // Merkle root for a reward round\n    mapping(uint256 => bytes32) public merkleRootOfRewardRound;\n\n    // Checks whether a merkle root was used\n    mapping(bytes32 => bool) public merkleRootUsed;\n\n    // Keeps track on whether user has claimed at a given reward round\n    mapping(uint256 => mapping(address => bool)) public hasUserClaimedForRewardRound;\n\n    event RewardsClaim(address indexed user, uint256 indexed rewardRound, uint256 amount);\n    event UpdateSeasonRewards(uint256 indexed rewardRound);\n    event TokenWithdrawnOwner(uint256 amount);\n\n    error AlreadyClaimed();\n    error AmountHigherThanMax();\n    error InvalidProof();\n    error MerkleRootAlreadyUsed();\n    error TooEarlyToWithdraw();\n\n    /**\n     * @notice Constructor\n     * @param _looksRareToken address of the LooksRare token\n     * @param _owner address of the owner\n     */\n    constructor(address _looksRareToken, address _owner) OwnableTwoSteps(_owner) {\n        looksRareToken = _looksRareToken;\n        merkleRootUsed[bytes32(0)] = true;\n    }\n\n    /**\n     * @notice Claim pending rewards\n     * @param amount amount to claim\n     * @param merkleProof array containing the merkle proof\n     */\n    function claim(uint256 amount, bytes32[] calldata merkleProof) external whenNotPaused nonReentrant {\n        // Verify the reward round is not claimed already\n        if (hasUserClaimedForRewardRound[currentRewardRound][msg.sender]) {\n            revert AlreadyClaimed();\n        }\n\n        (bool claimStatus, uint256 adjustedAmount) = _canClaim(msg.sender, amount, merkleProof);\n\n        if (!claimStatus) {\n            revert InvalidProof();\n        }\n        if (amount > maximumAmountPerUserInCurrentTree) {\n            revert AmountHigherThanMax();\n        }\n\n        // Set mapping for user and round as true\n        hasUserClaimedForRewardRound[currentRewardRound][msg.sender] = true;\n\n        // Adjust amount claimed\n        amountClaimedByUser[msg.sender] += adjustedAmount;\n\n        // Transfer adjusted amount\n        _executeERC20DirectTransfer(looksRareToken, msg.sender, adjustedAmount);\n\n        emit RewardsClaim(msg.sender, currentRewardRound, adjustedAmount);\n    }\n\n    /**\n     * @notice Update season rewards with a new merkle root\n     * @dev It automatically increments the currentRewardRound\n     * @param merkleRoot root of the computed merkle tree\n     */\n    function updateSeasonRewards(bytes32 merkleRoot, uint256 newMaximumAmountPerUser) external onlyOwner {\n        if (merkleRootUsed[merkleRoot]) {\n            revert MerkleRootAlreadyUsed();\n        }\n\n        currentRewardRound++;\n        merkleRootOfRewardRound[currentRewardRound] = merkleRoot;\n        merkleRootUsed[merkleRoot] = true;\n        maximumAmountPerUserInCurrentTree = newMaximumAmountPerUser;\n\n        emit UpdateSeasonRewards(currentRewardRound);\n    }\n\n    /**\n     * @notice Pause distribution\n     */\n    function pauseDistribution() external onlyOwner whenNotPaused {\n        lastPausedTimestamp = block.timestamp;\n        _pause();\n    }\n\n    /**\n     * @notice Unpause distribution\n     */\n    function unpauseDistribution() external onlyOwner whenPaused {\n        _unpause();\n    }\n\n    /**\n     * @notice Transfer LOOKS tokens back to owner\n     * @dev It is for emergency purposes\n     * @param amount amount to withdraw\n     */\n    function withdrawTokenRewards(uint256 amount) external onlyOwner whenPaused {\n        if (block.timestamp <= (lastPausedTimestamp + BUFFER_ADMIN_WITHDRAW)) {\n            revert TooEarlyToWithdraw();\n        }\n        _executeERC20DirectTransfer(looksRareToken, msg.sender, amount);\n\n        emit TokenWithdrawnOwner(amount);\n    }\n\n    /**\n     * @notice Check whether it is possible to claim and how much based on previous distribution\n     * @param user address of the user\n     * @param amount amount to claim\n     * @param merkleProof array with the merkle proof\n     */\n    function canClaim(\n        address user,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external view returns (bool, uint256) {\n        return _canClaim(user, amount, merkleProof);\n    }\n\n    /**\n     * @notice Check whether it is possible to claim and how much based on previous distribution\n     * @param user address of the user\n     * @param amount amount to claim\n     * @param merkleProof array with the merkle proof\n     */\n    function _canClaim(\n        address user,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) internal view returns (bool, uint256) {\n        // Compute the node and verify the merkle proof\n        bytes32 node = keccak256(bytes.concat(keccak256(abi.encodePacked(user, amount))));\n\n        bool canUserClaim = MerkleProof.verify(merkleProof, merkleRootOfRewardRound[currentRewardRound], node);\n\n        if ((!canUserClaim) || (hasUserClaimedForRewardRound[currentRewardRound][user])) {\n            return (false, 0);\n        } else {\n            return (true, amount - amountClaimedByUser[user]);\n        }\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IERC20} from \"../interfaces/generic/IERC20.sol\";\n\n// Errors\nimport {ERC20TransferFail, ERC20TransferFromFail} from \"../errors/LowLevelErrors.sol\";\nimport {NotAContract} from \"../errors/GenericErrors.sol\";\n\n/**\n * @title LowLevelERC20Transfer\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract LowLevelERC20Transfer {\n    /**\n     * @notice Execute ERC20 transferFrom\n     * @param currency Currency address\n     * @param from Sender address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     */\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\n        if (currency.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\n\n        if (!status) {\n            revert ERC20TransferFromFail();\n        }\n\n        if (data.length > 0) {\n            if (!abi.decode(data, (bool))) {\n                revert ERC20TransferFromFail();\n            }\n        }\n    }\n\n    /**\n     * @notice Execute ERC20 (direct) transfer\n     * @param currency Currency address\n     * @param to Recipient address\n     * @param amount Amount to transfer\n     */\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\n        if (currency.code.length == 0) {\n            revert NotAContract();\n        }\n\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\n\n        if (!status) {\n            revert ERC20TransferFail();\n        }\n\n        if (data.length > 0) {\n            if (!abi.decode(data, (bool))) {\n                revert ERC20TransferFail();\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IOwnableTwoSteps} from \"./interfaces/IOwnableTwoSteps.sol\";\n\n/**\n * @title OwnableTwoSteps\n * @notice This contract offers transfer of ownership in two steps with potential owner\n *         having to confirm the transaction to become the owner.\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\n    /**\n     * @notice Address of the current owner.\n     */\n    address public owner;\n\n    /**\n     * @notice Address of the potential owner.\n     */\n    address public potentialOwner;\n\n    /**\n     * @notice Ownership status.\n     */\n    Status public ownershipStatus;\n\n    /**\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\n     */\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    /**\n     * @notice Constructor\n     * @param _owner The contract's owner\n     */\n    constructor(address _owner) {\n        owner = _owner;\n        emit NewOwner(_owner);\n    }\n\n    /**\n     * @notice This function is used to cancel the ownership transfer.\n     * @dev This function can be used for both cancelling a transfer to a new owner and\n     *      cancelling the renouncement of the ownership.\n     */\n    function cancelOwnershipTransfer() external onlyOwner {\n        Status _ownershipStatus = ownershipStatus;\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\n            revert NoOngoingTransferInProgress();\n        }\n\n        if (_ownershipStatus == Status.TransferInProgress) {\n            delete potentialOwner;\n        }\n\n        delete ownershipStatus;\n\n        emit CancelOwnershipTransfer();\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership renouncement.\n     */\n    function confirmOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.RenouncementInProgress) {\n            revert RenouncementNotInProgress();\n        }\n\n        delete owner;\n        delete ownershipStatus;\n\n        emit NewOwner(address(0));\n    }\n\n    /**\n     * @notice This function is used to confirm the ownership transfer.\n     * @dev This function can only be called by the current potential owner.\n     */\n    function confirmOwnershipTransfer() external {\n        if (ownershipStatus != Status.TransferInProgress) {\n            revert TransferNotInProgress();\n        }\n\n        if (msg.sender != potentialOwner) {\n            revert WrongPotentialOwner();\n        }\n\n        owner = msg.sender;\n        delete ownershipStatus;\n        delete potentialOwner;\n\n        emit NewOwner(msg.sender);\n    }\n\n    /**\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\n     * @param newPotentialOwner New potential owner address\n     */\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.TransferInProgress;\n        potentialOwner = newPotentialOwner;\n\n        /**\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\n         *      We don't have to SLOAD the owner again.\n         */\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\n    }\n\n    /**\n     * @notice This function is used to initiate the ownership renouncement.\n     */\n    function initiateOwnershipRenouncement() external onlyOwner {\n        if (ownershipStatus != Status.NoOngoingTransfer) {\n            revert TransferAlreadyInProgress();\n        }\n\n        ownershipStatus = Status.RenouncementInProgress;\n\n        emit InitiateOwnershipRenouncement();\n    }\n\n    function _onlyOwner() private view {\n        if (msg.sender != owner) revert NotOwner();\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title Pausable\n * @notice This contract makes it possible to pause the contract.\n *         It is adjusted from OpenZeppelin.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract Pausable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    error IsPaused();\n    error NotPaused();\n\n    bool private _paused;\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert IsPaused();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert NotPaused();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// Interfaces\nimport {IReentrancyGuard} from \"./interfaces/IReentrancyGuard.sol\";\n\n/**\n * @title ReentrancyGuard\n * @notice This contract protects against reentrancy attacks.\n *         It is adjusted from OpenZeppelin.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\nabstract contract ReentrancyGuard is IReentrancyGuard {\n    uint256 private _status;\n\n    /**\n     * @notice Modifier to wrap functions to prevent reentrancy calls.\n     */\n    modifier nonReentrant() {\n        if (_status == 2) {\n            revert ReentrancyFail();\n        }\n\n        _status = 2;\n        _;\n        _status = 1;\n    }\n\n    constructor() {\n        _status = 1;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the ETH transfer fails.\n */\nerror ETHTransferFail();\n\n/**\n * @notice It is emitted if the ERC20 approval fails.\n */\nerror ERC20ApprovalFail();\n\n/**\n * @notice It is emitted if the ERC20 transfer fails.\n */\nerror ERC20TransferFail();\n\n/**\n * @notice It is emitted if the ERC20 transferFrom fails.\n */\nerror ERC20TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC721 transferFrom fails.\n */\nerror ERC721TransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\n */\nerror ERC1155SafeTransferFromFail();\n\n/**\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\n */\nerror ERC1155SafeBatchTransferFromFail();\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice It is emitted if the call recipient is not a contract.\n */\nerror NotAContract();\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/IOwnableTwoSteps.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title IOwnableTwoSteps\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface IOwnableTwoSteps {\n    /**\n     * @notice This enum keeps track of the ownership status.\n     * @param NoOngoingTransfer The default status when the owner is set\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\n     */\n    enum Status {\n        NoOngoingTransfer,\n        TransferInProgress,\n        RenouncementInProgress\n    }\n\n    /**\n     * @notice This is returned when there is no transfer of ownership in progress.\n     */\n    error NoOngoingTransferInProgress();\n\n    /**\n     * @notice This is returned when the caller is not the owner.\n     */\n    error NotOwner();\n\n    /**\n     * @notice This is returned when there is no renouncement in progress but\n     *         the owner tries to validate the ownership renouncement.\n     */\n    error RenouncementNotInProgress();\n\n    /**\n     * @notice This is returned when the transfer is already in progress but the owner tries\n     *         initiate a new ownership transfer.\n     */\n    error TransferAlreadyInProgress();\n\n    /**\n     * @notice This is returned when there is no ownership transfer in progress but the\n     *         ownership change tries to be approved.\n     */\n    error TransferNotInProgress();\n\n    /**\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\n     *         a caller that is not the potential owner.\n     */\n    error WrongPotentialOwner();\n\n    /**\n     * @notice This is emitted if the ownership transfer is cancelled.\n     */\n    event CancelOwnershipTransfer();\n\n    /**\n     * @notice This is emitted if the ownership renouncement is initiated.\n     */\n    event InitiateOwnershipRenouncement();\n\n    /**\n     * @notice This is emitted if the ownership transfer is initiated.\n     * @param previousOwner Previous/current owner\n     * @param potentialOwner Potential/future owner\n     */\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\n\n    /**\n     * @notice This is emitted when there is a new owner.\n     */\n    event NewOwner(address newOwner);\n}\n"
    },
    "node_modules/@looksrare/contracts-libs/contracts/interfaces/IReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title IReentrancyGuard\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ninterface IReentrancyGuard {\n    /**\n     * @notice This is returned when there is a reentrant call.\n     */\n    error ReentrancyFail();\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@ensdomains/=node_modules/@ensdomains/",
      "@looksrare/=node_modules/@looksrare/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "eth-gas-reporter/=node_modules/eth-gas-reporter/",
      "hardhat/=node_modules/hardhat/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 888888
    },
    "metadata": {
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}