{{
  "language": "Solidity",
  "sources": {
    "contracts/marketplace/GigaMartProxyRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\nimport \"./proxy/ProxyRegistry.sol\";\r\n\r\n/// Thrown if any initial caller of this proxy registry is already set.\r\nerror InitialCallerIsAlreadySet ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title GigaMart Proxy Registry\r\n\t@author Tim Clancy <@_Enoch>\r\n\t@author Rostislav Khlebnikov <@catpic5buck>\r\n\t\r\n\tA fully-implemented proxy registry contract.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\ncontract GigaMartProxyRegistry is ProxyRegistry {\r\n\r\n\t/// The public name of this registry.\r\n\tstring public constant name = \"GigaMart Proxy Registry\";\r\n\r\n\t/// A flag for whether or not the initial authorized caller has been set.\r\n\tbool public initialCallersSet = false;\r\n\r\n\t/**\r\n\t\tConstructing a new instance of this registry is passed through to the \r\n\t\t`ProxyRegistry` constructor.\r\n\t*/\r\n\tconstructor () ProxyRegistry() { }\r\n\r\n\t/**\r\n\t\tAllow the owner of this registry to grant immediate authorization to a\r\n\t\tset of addresses for calling proxies in this registry. This is to avoid\r\n\t\twaiting for the `DELAY_PERIOD` otherwise specified for further caller\r\n\t\tadditions.\r\n\r\n\t\t@param _initials The array of initial callers authorized to operate in this \r\n\t\t\tregistry.\r\n\r\n\t\t@custom:throws InitialCallerIsAlreadySet if an intial caller is already set \r\n\t\t\tfor this proxy registry.\r\n\t*/\r\n\tfunction grantInitialAuthentication (\r\n\t\taddress[] calldata _initials\r\n\t) external onlyOwner {\r\n\t\tif (initialCallersSet) {\r\n\t\t\trevert InitialCallerIsAlreadySet();\r\n\t\t}\r\n\t\tinitialCallersSet = true;\r\n\r\n\t\t// Authorize each initial caller.\r\n\t\tfor (uint256 i; i < _initials.length; ) {\r\n\t\t\tauthorizedCallers[_initials[i]] = true;\r\n\t\t\tunchecked {\r\n\t\t\t\t++i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    "contracts/marketplace/proxy/ProxyRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./AuthenticatedProxy.sol\";\r\nimport \"../interfaces/IProxyRegistry.sol\";\r\nimport \"../proxy/OwnableDelegateProxy.sol\";\r\n\r\n/// Thrown if an address authentifying is already an authorized caller.\r\nerror AlreadyAuthorized ();\r\n\r\n/// Thrown if an address is already pending authentication.\r\nerror AlreadyPendingAuthentication ();\r\n\r\n/// Thrown if an address ending authentication has not yet started it.\r\nerror AddressHasntStartedAuth ();\r\n\r\n/// Thrown if an address ending authentication has not delayed long enough.\r\nerror AddressHasntClearedTimelock ();\r\n\r\n/// Thrown if a caller has already registered a proxy.\r\nerror ProxyAlreadyRegistered ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title Ownable Delegate Proxy\r\n\t@author Protinam, Project Wyvern\r\n\t@author Tim Clancy <@_Enoch>\r\n\t@author Rostislav Khlebnikov <@catpic5buck>\r\n\r\n\tA proxy registry contract. This contract was originally developed \r\n\tby Project Wyvern. It has been modified to support a more modern version of \r\n\tSolidity with associated best practices. The documentation has also been \r\n\timproved to provide more clarity.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\ncontract ProxyRegistry is IProxyRegistry, Ownable {\r\n\r\n\t/**\r\n\t\tEach `OwnableDelegateProxy` contract ultimately dictates its implementation\r\n\t\tdetails elsewhere, to `delegateProxyImplementation`.\r\n\t*/\r\n\taddress public delegateProxyImplementation;\r\n\r\n\t/**\r\n\t\tThis mapping relates an addresses to its own personal `OwnableDelegateProxy`\r\n\t\twhich allow it to proxy functionality to the various callers contained in\r\n\t\t`authorizedCallers`.\r\n\t*/\r\n\tmapping ( address => address ) public proxies;\r\n\r\n\t/**\r\n\t\tThis mapping relates addresses which are pending access to the registry to\r\n\t\tthe timestamp where they began the `startGrantAuthentication` process.\r\n\t*/\r\n\tmapping ( address => uint256 ) public pendingCallers;\r\n\r\n\t/**\r\n\t\tThis mapping relates an address to a boolean specifying whether or not it is\r\n\t\tallowed to call the `OwnableDelegateProxy` for any given address in the\r\n\t\t`proxies` mapping.\r\n\t*/\r\n\tmapping ( address => bool ) public authorizedCallers;\r\n\r\n\t/**\r\n\t\tA delay period which must elapse before adding an authenticated contract to\r\n\t\tthe registry, thus allowing it to call the `OwnableDelegateProxy` for an\r\n\t\taddress in the `proxies` mapping.\r\n\r\n\t\tThis `ProxyRegistry` contract was designed with the intent to be owned by a\r\n\t\tDAO, so this delay mitigates a particular class of attack against an owning\r\n\t\tDAO. If at any point the value of assets accessible to the\r\n\t\t`OwnableDelegateProxy` contracts exceeded the cost of gaining control of the\r\n\t\tDAO, a malicious but rational attacker could spend (potentially \r\n\t\tconsiderable) resources to then have access to all `OwnableDelegateProxy`\r\n\t\tcontracts via a malicious contract upgrade. This delay period renders this\r\n\t\tattack ineffective by granting time for addresses to remove assets from\r\n\t\tcompromised `OwnableDelegateProxy` contracts.\r\n\r\n\t\tUnder its present usage, this delay period protects exchange users from a \r\n\t\tmalicious upgrade.\r\n\t*/\r\n\tuint256 public DELAY_PERIOD = 1 weeks;\r\n\r\n\t/**\r\n\t\tConstruct this registry by specifying the initial implementation of all\r\n\t\t`OwnableDelegateProxy` contracts that are registered by users. This registry\r\n\t\twill use `AuthenticatedProxy` as its initial implementation.\r\n\t*/\r\n\tconstructor () {\r\n\t\tdelegateProxyImplementation = address(new AuthenticatedProxy());\r\n\t}\r\n\r\n\t/**\r\n\t\tAllow the `ProxyRegistry` owner to begin the process of enabling access to\r\n\t\tthe registry for the unauthenticated address `_unauthenticated`. Once the\r\n\t\tgrant authentication process has begun, it is subject to the `DELAY_PERIOD`\r\n\t\tbefore the authentication process may conclude. Once concluded, the new\r\n\t\taddress `_unauthenticated` will have access to the registry.\r\n\r\n\t\t@param _unauthenticated The new address to grant access to the registry.\r\n\r\n\t\t@custom:throws AlreadyAuthorized if the address beginning authentication is \r\n\t\t\talready an authorized caller.\r\n\t\t@custom:throws AlreadyPendingAuthentication if the address beginning \r\n\t\t\tauthentication is already pending.\r\n\t*/\r\n\tfunction startGrantAuthentication (\r\n\t\taddress _unauthenticated\r\n\t) external onlyOwner {\r\n\t\tif (authorizedCallers[_unauthenticated]) {\r\n\t\t\trevert AlreadyAuthorized();\r\n\t\t}\r\n\t\tif (pendingCallers[_unauthenticated] != 0) {\r\n\t\t\trevert AlreadyPendingAuthentication();\r\n\t\t}\r\n\t\tpendingCallers[_unauthenticated] = block.timestamp;\r\n\t}\r\n\r\n\t/**\r\n\t\tAllow the `ProxyRegistry` owner to end the process of enabling access to the\r\n\t\tregistry for the unauthenticated address `_unauthenticated`. If the required\r\n\t\t`DELAY_PERIOD` has passed, then the new address `_unauthenticated` will have\r\n\t\taccess to the registry.\r\n\r\n\t\t@param _unauthenticated The new address to grant access to the registry.\r\n\r\n\t\t@custom:throws AlreadyAuthorized if the address beginning authentication is\r\n\t\t\talready an authorized caller.\r\n\t\t@custom:throws AddressHasntStartedAuth if the address attempting to end \r\n\t\t\tauthentication has not yet started it.\r\n\t\t@custom:throws AddressHasntClearedTimelock if the address attempting to end \r\n\t\t\tauthentication has not yet incurred a sufficient delay.\r\n\t*/\r\n\tfunction endGrantAuthentication(\r\n\t\taddress _unauthenticated\r\n\t) external onlyOwner {\r\n\t\tif (authorizedCallers[_unauthenticated]) {\r\n\t\t\trevert AlreadyAuthorized();\r\n\t\t}\r\n\t\tif (pendingCallers[_unauthenticated] == 0) {\r\n\t\t\trevert AddressHasntStartedAuth();\r\n\t\t}\r\n\t\tunchecked {\r\n\t\t\tif (\r\n\t\t\t\t(pendingCallers[_unauthenticated] + DELAY_PERIOD) >= block.timestamp\r\n\t\t\t) {\r\n\t\t\t\trevert AddressHasntClearedTimelock();\r\n\t\t\t}\r\n\t\t}\r\n\t\tpendingCallers[_unauthenticated] = 0;\r\n\t\tauthorizedCallers[_unauthenticated] = true;\r\n\t}\r\n\r\n\t/**\r\n\t\tAllow the owner of the `ProxyRegistry` to immediately revoke authorization\r\n\t\tto call proxies from the specified address.\r\n\r\n\t\t@param _caller The address to revoke authentication from.\r\n\t*/\r\n\tfunction revokeAuthentication (\r\n\t\taddress _caller\r\n\t) external onlyOwner {\r\n\t\tauthorizedCallers[_caller] = false;\r\n\t}\r\n\r\n\t/**\r\n\t\tEnables an address to register its own proxy contract with this registry.\r\n\r\n\t\t@return _ The address of the new `OwnableMutableDelegateProxy` contract \r\n\t\t\twith its `delegateProxyImplementation` implementation.\r\n\r\n\t\t@custom:throws ProxyAlreadyRegistered if the caller has already registered \r\n\t\t\ta proxy.\r\n\t*/\r\n\tfunction registerProxy () external returns (address) {\r\n\t\tif (address(proxies[_msgSender()]) != address(0)) {\r\n\t\t\trevert ProxyAlreadyRegistered();\r\n\t\t}\r\n\r\n\t\t/** \r\n\t\t\tConstruct the new `OwnableDelegateProxy` with this registry's initial\r\n\t\t\timplementation and call said implementation's \"initialize\" function.\r\n\t\t*/\r\n\t\tOwnableDelegateProxy proxy = new OwnableDelegateProxy(\r\n\t\t\t_msgSender(),\r\n\t\t\tdelegateProxyImplementation,\r\n\t\t\tabi.encodeWithSignature(\"initialize(address)\", address(this))\r\n\t\t);\r\n\t\taddress proxyAddr = address(proxy);\r\n\t\tproxies[_msgSender()] = proxyAddr;\r\n\t\treturn proxyAddr;\r\n\t}\r\n\r\n\t/**\r\n\t\tReturns the address of the caller's proxy and the current implementation \r\n\t\taddress.\r\n\r\n\t\t@param _caller The address of the caller.\r\n\r\n\t\t@return _ A tuple containing the address of the caller's proxy and the \r\n\t\t\taddress of the current implementation of the proxy.\r\n\t*/\r\n\tfunction userProxyConfig(\r\n\t\taddress _caller\r\n\t) external view returns (address, address) {\r\n\t\treturn (proxies[_caller], delegateProxyImplementation);\r\n\t}\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/marketplace/proxy/AuthenticatedProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"../interfaces/IProxyRegistry.sol\";\r\n\r\n/**\r\n\tThrown if attempting to initialize a proxy which has already been initialized.\r\n*/\r\nerror ProxyAlreadyInitialized ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title Authenticated Proxy\r\n\t@author Protinam, Project Wyvern\r\n\t@author Tim Clancy <@_Enoch>\r\n\t@custom:contributor Rostislav Khlebnikov <@catpic5buck>\r\n\r\n\tAn ownable call-delegating proxy which can receive tokens and only make calls \r\n\tagainst contracts that have been approved by a `ProxyRegistry`. This contract \r\n\twas originally developed by Project Wyvern. It has been modified to support a \r\n\tmore modern version of Solidity with associated best practices. The \r\n\tdocumentation has also been improved to provide more clarity.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\ncontract AuthenticatedProxy is Ownable {\r\n\r\n\t/**\r\n\t\tAn enum for selecting the method by which we would like to perform a call \r\n\t\tin the `proxy` function.\r\n\t*/\r\n\tenum CallType {\r\n\t\tCall,\r\n\t\tDelegateCall\r\n\t}\r\n\r\n\t/// Whether or not this proxy is initialized. It may only initialize once.\r\n\tbool public initialized = false;\r\n\r\n\t/// The associated `ProxyRegistry` contract with authentication information.\r\n\taddress public registry;\r\n\r\n\t/// Whether or not access has been revoked.\r\n\tbool public revoked;\r\n\r\n\t/**\r\n\t\tAn event fired when the proxy contract's access is revoked or unrevoked.\r\n\r\n\t\t@param revoked The status of the revocation call; true if access is \r\n\t\t\trevoked and false if access is unrevoked.\r\n\t*/\r\n\tevent Revoked (\r\n\t\tbool revoked\r\n\t);\r\n\r\n\t/**\r\n\t\tInitialize this authenticated proxy for its owner against a specified\r\n\t\t`ProxyRegistry`. The registry controls the eligible targets.\r\n\r\n\t\t@param _registry The registry to create this proxy against.\r\n\t*/\r\n\tfunction initialize (\r\n\t\taddress _registry\r\n\t) external {\r\n\t\tif (initialized) {\r\n\t\t\trevert ProxyAlreadyInitialized();\r\n\t\t}\r\n\t\tinitialized = true;\r\n\t\tregistry = _registry;\r\n\t}\r\n\r\n\t/**\r\n\t\tAllow the owner of this proxy to set the revocation flag. This permits them\r\n\t\tto revoke access from the associated `ProxyRegistry` if needed.\r\n\r\n\t\t@param _revoke The revocation flag to set for this proxy.\r\n\t*/\r\n\tfunction setRevoke (\r\n\t\tbool _revoke\r\n\t) external onlyOwner {\r\n\t\trevoked = _revoke;\r\n\t\temit Revoked(_revoke);\r\n\t}\r\n\r\n\t/**\r\n\t\tTrigger this proxy to call a specific address with the provided data. The\r\n\t\tproxy may perform a direct or a delegate call. This proxy can only be called\r\n\t\tby the owner, or on behalf of the owner by a caller authorized by the\r\n\t\tregistry. Unless the user has revoked access to the registry, that is.\r\n\r\n\t\t@param _target The target address to make the call to.\r\n\t\t@param _type The type of call to make: direct or delegated.\r\n\t\t@param _data The call data to send to `_target`.\r\n\r\n\t\t@return _ Whether or not the call succeeded.\r\n\r\n\t\t@custom:throws NonAuthorizedCaller if the proxy caller is not the owner or \r\n\t\t\tan authorized caller from the proxy registry.\r\n\t*/\r\n\tfunction call (\r\n\t\taddress _target,\r\n\t\tCallType _type,\r\n\t\tbytes calldata _data\r\n\t) public returns (bool) {\r\n\t\tif (\r\n\t\t\t_msgSender() != owner() &&\r\n\t\t\t(revoked || !IProxyRegistry(registry).authorizedCallers(_msgSender()))\r\n\t\t) {\r\n\t\t\trevert NonAuthorizedCaller();\r\n\t\t}\r\n\r\n\t\t// The call is authorized to be performed, now select a type and return.\r\n\t\tif (_type == CallType.Call) {\r\n\t\t\t(bool success, ) = _target.call(_data);\r\n\t\t\treturn success;\r\n\t\t} else if (_type == CallType.DelegateCall) {\r\n\t\t\t(bool success, ) = _target.delegatecall(_data);\r\n\t\t\treturn success;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n"
    },
    "contracts/marketplace/interfaces/IProxyRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\n/// Thrown if a caller is not authorized in the proxy registry.\r\nerror NonAuthorizedCaller ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title Ownable Delegate Proxy\r\n\t@author Protinam, Project Wyvern\r\n\t@author Tim Clancy <@_Enoch>\r\n\t@author Rostislav Khlebnikov <@catpic5buck>\r\n\r\n\tA proxy registry contract. This contract was originally developed \r\n\tby Project Wyvern. It has been modified to support a more modern version of \r\n\tSolidity with associated best practices. The documentation has also been \r\n\timproved to provide more clarity.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\ninterface IProxyRegistry {\r\n\r\n\t/// Return the address of tje current valid implementation of delegate proxy.\r\n\tfunction delegateProxyImplementation () external view returns (address);\r\n\r\n\t/**\r\n\t\tReturns the address of a proxy which was registered for the user address \r\n\t\tbefore listing items.\r\n\r\n\t\t@param _owner The address of items lister.\r\n\t*/\r\n\tfunction proxies (\r\n\t\taddress _owner\r\n\t) external view returns (address);\r\n\r\n\t/**\r\n\t\tReturns true if the `_caller` to the proxy registry is eligible and \r\n\t\tregistered.\r\n\r\n\t\t@param _caller The address of the caller.\r\n\t*/\r\n\tfunction authorizedCallers (\r\n\t\taddress _caller\r\n\t) external view returns (bool);\r\n\r\n\t/**\r\n\t\tReturns the address of the `_caller`'s proxy and current implementation \r\n\t\taddress.\r\n\r\n\t\t@param _caller The address of the caller.\r\n\t*/\r\n\tfunction userProxyConfig (\r\n\t\taddress _caller\r\n\t) external view returns (address, address);\r\n\r\n\t/**\r\n\t\tEnables an address to register its own proxy contract with this registry.\r\n\r\n\t\t@return _ The new contract with its implementation.\r\n\t*/\r\n\tfunction registerProxy () external returns (address);\r\n}\r\n"
    },
    "contracts/marketplace/proxy/OwnableDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./DelegateProxy.sol\";\r\n\r\n/// Thrown if the initial delgate call from this proxy is not successful.\r\nerror InitialTargetCallFailed ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title Ownable Delegate Proxy\r\n\t@author Protinam, Project Wyvern\r\n\t@author Tim Clancy <@_Enoch>\r\n\t@author Rostislav Khlebnikov <@catpic5buck>\r\n\r\n\tA call-delegating proxy with an owner. This contract was originally developed \r\n\tby Project Wyvern. It has been modified to support a more modern version of \r\n\tSolidity with associated best practices. The documentation has also been \r\n\timproved to provide more clarity.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\ncontract OwnableDelegateProxy is Ownable, DelegateProxy {\r\n\r\n\t/// Whether or not the proxy was initialized.\r\n\tbool public initialized;\r\n\r\n\t/**\r\n\t\tThis is a storage escape slot to match `AuthenticatedProxy` storage.\r\n\t\tuint8(bool) + uint184 = 192 bits. This prevents target (160 bits) from\r\n\t\tbeing placed in this storage slot.\r\n\t*/\r\n\tuint184 private _escape;\r\n\r\n\t/// The address of the proxy's current target.\r\n\taddress public target;\r\n\r\n\t/**\r\n\t\tConstruct this delegate proxy with an owner, initial target, and an initial\r\n\t\tcall sent to the target.\r\n\r\n\t\t@param _owner The address which should own this proxy.\r\n\t\t@param _target The initial target of this proxy.\r\n\t\t@param _data The initial call to delegate to `_target`.\r\n\r\n\t\t@custom:throws InitialTargetCallFailed if the proxy initialization call \r\n\t\t\tfails.\r\n\t*/\r\n\tconstructor (\r\n\t\taddress _owner,\r\n\t\taddress _target,\r\n\t\tbytes memory _data\r\n\t) {\r\n\t\r\n\t\t/*\r\n\t\t\tDo not perform a redundant ownership transfer if the deployer should remain as the owner of this contract.\r\n\t\t*/\r\n\t\tif (_owner != owner()) {\r\n\t\t\ttransferOwnership(_owner);\r\n\t\t}\r\n\t\ttarget = _target;\r\n\r\n\t\t/**\r\n\t\t\tImmediately delegate a call to the initial implementation and require it \r\n\t\t\tto succeed. This is often used to trigger some kind of initialization \r\n\t\t\tfunction on the target.\r\n\t\t*/\r\n\t\t(bool success, ) = _target.delegatecall(_data);\r\n\t\tif (!success) {\r\n\t\t\trevert InitialTargetCallFailed();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tReturn the current address where all calls to this proxy are delegated. If\r\n\t\t`proxyType()` returns `1`, ERC-897 dictates that this address MUST not\r\n\t\tchange.\r\n\r\n\t\t@return _ The current address where calls to this proxy are delegated.\r\n\t*/\r\n\tfunction implementation () public view override returns (address) {\r\n\t\treturn target;\r\n\t}\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/marketplace/proxy/DelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.15;\r\n\r\n/// Thrown if the proxy's implementation is not set.\r\nerror ImplementationIsNotSet ();\r\n\r\n/**\r\n\t@custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVS MEAM\r\n\t@title Delegate Proxy\r\n\t@author Facu Spagnuolo, OpenZeppelin\r\n\t@author Protinam, Project Wyvern\r\n\t@author Tim Clancy <@_Enoch>\r\n\r\n\tA basic call-delegating proxy contract which is compliant with the current \r\n\tdraft version of ERC-897. This contract was originally developed by Project \r\n\tWyvern. It has been modified to support a more modern version of Solidity \r\n\twith associated best practices. The documentation has also been improved to \r\n\tprovide more clarity.\r\n\r\n\t@custom:date December 4th, 2022.\r\n*/\r\nabstract contract DelegateProxy {\r\n\r\n\t/**\r\n\t\tThis payable fallback function exists to automatically delegate all calls to\r\n\t\tthis proxy to the contract specified from `implementation()`. Anything\r\n\t\treturned from the delegated call will also be returned here.\r\n\r\n\t\t@custom:throws ImplementationIsNotSet if the contract implementation is not \r\n\t\t\tset.\r\n\t*/\r\n\tfallback () external payable virtual {\r\n\t\taddress target = implementation();\r\n\r\n\t\t// Ensure that the proxy implementation has been set correctly.\r\n\t\tif (target == address(0)) {\r\n\t\t\trevert ImplementationIsNotSet();\r\n\t\t}\r\n\r\n\t\t// Perform the actual call delegation.\r\n\t\tassembly {\r\n\t\t\tlet ptr := mload(0x40)\r\n\t\t\tcalldatacopy(ptr, 0, calldatasize())\r\n\t\t\tlet result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)\r\n\t\t\tlet size := returndatasize()\r\n\t\t\treturndatacopy(ptr, 0, size)\r\n\t\t\tswitch result\r\n\t\t\tcase 0 {\r\n\t\t\t\trevert(ptr, size)\r\n\t\t\t}\r\n\t\t\tdefault {\r\n\t\t\t\treturn(ptr, size)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t\tReturn the current address where all calls to this proxy are delegated. If\r\n\t\t`proxyType()` returns `1`, ERC-897 dictates that this address MUST not\r\n\t\tchange.\r\n\r\n\t\t@return _ The current address where calls to this proxy are delegated.\r\n\t*/\r\n\tfunction implementation () public view virtual returns (address);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1337
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}