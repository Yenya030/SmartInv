{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IParaProxy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* EIP-2535: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IParaProxy {\n    enum ProxyImplementationAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct ProxyImplementation {\n        address implAddress;\n        ProxyImplementationAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _implementationParams Contains the implementation addresses and function selectors\n    /// @param _init The address of the contract or implementation to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function updateImplementation(\n        ProxyImplementation[] calldata _implementationParams,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event ImplementationUpdated(\n        ProxyImplementation[] _implementationParams,\n        address _init,\n        bytes _calldata\n    );\n}\n"
    },
    "contracts/protocol/libraries/paraspace-upgradeability/ParaProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* A custom implementation of EIP-2535\n* EIP-2535: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {ParaProxyLib} from \"./lib/ParaProxyLib.sol\";\nimport {IParaProxy} from \"../../../interfaces/IParaProxy.sol\";\n\ncontract ParaProxy is IParaProxy {\n    constructor(address _contractOwner) payable {\n        ParaProxyLib.setContractOwner(_contractOwner);\n    }\n\n    function updateImplementation(\n        ProxyImplementation[] calldata _implementationParams,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        ParaProxyLib.enforceIsContractOwner();\n        ParaProxyLib.updateImplementation(\n            _implementationParams,\n            _init,\n            _calldata\n        );\n    }\n\n    // Find implementation for function that is called and execute the\n    // function if a implementation is found and return any value.\n    fallback() external payable {\n        ParaProxyLib.ProxyStorage storage ds;\n        bytes32 position = ParaProxyLib.PROXY_STORAGE_POSITION;\n        // get proxy storage\n        assembly {\n            ds.slot := position\n        }\n        // get implementation from function selector\n        address implementation = ds\n            .selectorToImplAndPosition[msg.sig]\n            .implAddress;\n        require(\n            implementation != address(0),\n            \"ParaProxy: Function does not exist\"\n        );\n        // Execute external function from implementation using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the implementation\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/protocol/libraries/paraspace-upgradeability/lib/ParaProxyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IParaProxy} from \"../../../../interfaces/IParaProxy.sol\";\n\nlibrary ParaProxyLib {\n    bytes32 constant PROXY_STORAGE_POSITION =\n        bytes32(\n            uint256(keccak256(\"paraspace.proxy.implementation.storage\")) - 1\n        );\n\n    struct ImplementationAddressAndPosition {\n        address implAddress;\n        uint96 functionSelectorPosition; // position in implementationFunctionSelectors.functionSelectors array\n    }\n\n    struct ImplementationFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 implementationAddressPosition; // position of implAddress in implementationAddresses array\n    }\n\n    struct ProxyStorage {\n        // maps function selector to the implementation address and\n        // the position of the selector in the implementationFunctionSelectors.selectors array\n        mapping(bytes4 => ImplementationAddressAndPosition) selectorToImplAndPosition;\n        // maps implementation addresses to function selectors\n        mapping(address => ImplementationFunctionSelectors) implementationFunctionSelectors;\n        // implementation addresses\n        address[] implementationAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (ProxyStorage storage ds) {\n        bytes32 position = PROXY_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        ProxyStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"ParaProxy: Must be contract owner\"\n        );\n    }\n\n    event ImplementationUpdated(\n        IParaProxy.ProxyImplementation[] _implementationData,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function updateImplementation(\n        IParaProxy.ProxyImplementation[] memory _implementationData,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (\n            uint256 implIndex;\n            implIndex < _implementationData.length;\n            implIndex++\n        ) {\n            IParaProxy.ProxyImplementationAction action = _implementationData[\n                implIndex\n            ].action;\n            if (action == IParaProxy.ProxyImplementationAction.Add) {\n                addFunctions(\n                    _implementationData[implIndex].implAddress,\n                    _implementationData[implIndex].functionSelectors\n                );\n            } else if (action == IParaProxy.ProxyImplementationAction.Replace) {\n                replaceFunctions(\n                    _implementationData[implIndex].implAddress,\n                    _implementationData[implIndex].functionSelectors\n                );\n            } else if (action == IParaProxy.ProxyImplementationAction.Remove) {\n                removeFunctions(\n                    _implementationData[implIndex].implAddress,\n                    _implementationData[implIndex].functionSelectors\n                );\n            } else {\n                revert(\"ParaProxy: Incorrect ProxyImplementationAction\");\n            }\n        }\n        emit ImplementationUpdated(_implementationData, _init, _calldata);\n        initializeImplementation(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _implementationAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"ParaProxy: No selectors in implementation to cut\"\n        );\n        ProxyStorage storage ds = diamondStorage();\n        require(\n            _implementationAddress != address(0),\n            \"ParaProxy: Add implementation can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .functionSelectors\n                .length\n        );\n        // add new implementation address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _implementationAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldImplementationAddress = ds\n                .selectorToImplAndPosition[selector]\n                .implAddress;\n            require(\n                oldImplementationAddress == address(0),\n                \"ParaProxy: Can't add function that already exists\"\n            );\n            addFunction(ds, selector, selectorPosition, _implementationAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(\n        address _implementationAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"ParaProxy: No selectors in implementation to cut\"\n        );\n        ProxyStorage storage ds = diamondStorage();\n        require(\n            _implementationAddress != address(0),\n            \"ParaProxy: Add implementation can't be address(0)\"\n        );\n        uint96 selectorPosition = uint96(\n            ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .functionSelectors\n                .length\n        );\n        // add new implementation address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _implementationAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldImplementationAddress = ds\n                .selectorToImplAndPosition[selector]\n                .implAddress;\n            require(\n                oldImplementationAddress != _implementationAddress,\n                \"ParaProxy: Can't replace function with same function\"\n            );\n            removeFunction(ds, oldImplementationAddress, selector);\n            addFunction(ds, selector, selectorPosition, _implementationAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(\n        address _implementationAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        require(\n            _functionSelectors.length > 0,\n            \"ParaProxy: No selectors in implementation to cut\"\n        );\n        ProxyStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(\n            _implementationAddress == address(0),\n            \"ParaProxy: Remove implementation address must be address(0)\"\n        );\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n            selectorIndex++\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldImplementationAddress = ds\n                .selectorToImplAndPosition[selector]\n                .implAddress;\n            removeFunction(ds, oldImplementationAddress, selector);\n        }\n    }\n\n    function addFacet(ProxyStorage storage ds, address _implementationAddress)\n        internal\n    {\n        enforceHasContractCode(\n            _implementationAddress,\n            \"ParaProxy: New implementation has no code\"\n        );\n        ds\n            .implementationFunctionSelectors[_implementationAddress]\n            .implementationAddressPosition = ds.implementationAddresses.length;\n        ds.implementationAddresses.push(_implementationAddress);\n    }\n\n    function addFunction(\n        ProxyStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _implementationAddress\n    ) internal {\n        ds\n            .selectorToImplAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds\n            .implementationFunctionSelectors[_implementationAddress]\n            .functionSelectors\n            .push(_selector);\n        ds\n            .selectorToImplAndPosition[_selector]\n            .implAddress = _implementationAddress;\n    }\n\n    function removeFunction(\n        ProxyStorage storage ds,\n        address _implementationAddress,\n        bytes4 _selector\n    ) internal {\n        require(\n            _implementationAddress != address(0),\n            \"ParaProxy: Can't remove function that doesn't exist\"\n        );\n        // an immutable function is a function defined directly in a paraProxy\n        require(\n            _implementationAddress != address(this),\n            \"ParaProxy: Can't remove immutable function\"\n        );\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToImplAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .implementationFunctionSelectors[_implementationAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .functionSelectors[selectorPosition] = lastSelector;\n            ds\n                .selectorToImplAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds\n            .implementationFunctionSelectors[_implementationAddress]\n            .functionSelectors\n            .pop();\n        delete ds.selectorToImplAndPosition[_selector];\n\n        // if no more selectors for implementation address then delete the implementation address\n        if (lastSelectorPosition == 0) {\n            // replace implementation address with last implementation address and delete last implementation address\n            uint256 lastImplementationAddressPosition = ds\n                .implementationAddresses\n                .length - 1;\n            uint256 implementationAddressPosition = ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .implementationAddressPosition;\n            if (\n                implementationAddressPosition !=\n                lastImplementationAddressPosition\n            ) {\n                address lastImplementationAddress = ds.implementationAddresses[\n                    lastImplementationAddressPosition\n                ];\n                ds.implementationAddresses[\n                    implementationAddressPosition\n                ] = lastImplementationAddress;\n                ds\n                    .implementationFunctionSelectors[lastImplementationAddress]\n                    .implementationAddressPosition = implementationAddressPosition;\n            }\n            ds.implementationAddresses.pop();\n            delete ds\n                .implementationFunctionSelectors[_implementationAddress]\n                .implementationAddressPosition;\n        }\n    }\n\n    function initializeImplementation(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            require(\n                _calldata.length == 0,\n                \"ParaProxy: _init is address(0) but_calldata is not empty\"\n            );\n        } else {\n            require(\n                _calldata.length > 0,\n                \"ParaProxy: _calldata is empty but _init is not address(0)\"\n            );\n            if (_init != address(this)) {\n                enforceHasContractCode(\n                    _init,\n                    \"ParaProxy: _init address has no code\"\n                );\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"ParaProxy: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "contracts/=contracts/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "pnm-contracts/=lib/pnm-contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}