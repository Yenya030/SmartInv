{{
  "language": "Solidity",
  "sources": {
    "TransitSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/RevertReasonParser.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/TransitStructs.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/Pausable.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ITransitSwapFees.sol\";\n\ncontract TransitSwapRouter is Ownable, ReentrancyGuard, Pausable {\n\n    using SafeMath for uint256;\n\n    address private _transit_swap;\n    address private _transit_cross;\n    address private _transit_fees;\n    //default: Pre-trade fee model\n    mapping(uint8 => bool) private _swap_type_mode;\n\n    event Receipt(address from, uint256 amount);\n    event Withdraw(address indexed token, address indexed executor, address indexed recipient, uint amount);\n    event ChangeTransitSwap(address indexed previousTransit, address indexed newTransit);\n    event ChangeTransitCross(address indexed previousTransit, address indexed newTransit);\n    event ChangeTransitFees(address indexed previousTransitFees, address indexed newTransitFees);\n    event ChangeSwapTypeMode(uint8[] types, bool[] newModes);\n    event TransitSwapped(address indexed srcToken, address indexed dstToken, address indexed dstReceiver, address trader, bool feeMode, uint256 amount, uint256 returnAmount, uint256 minReturnAmount, uint256 fee, uint256 toChainID, string channel, uint256 time);\n\n\n    constructor(address transitSwap_, address transitCross_, address transitFees_, address executor) Ownable (executor) {\n        _transit_swap = transitSwap_;\n        _transit_cross = transitCross_;\n        _transit_fees = transitFees_;\n    }\n\n    receive() external payable {\n        emit Receipt(msg.sender, msg.value);\n    }\n\n    function transitSwap() external view returns (address) {\n        return _transit_swap;\n    }\n\n    function transitCross() external view returns (address) {\n        return _transit_cross;\n    }\n\n    function transitFees() external view returns (address) {\n        return _transit_fees;\n    }\n\n    function swapTypeMode(uint8 swapType) external view returns (bool) {\n        return _swap_type_mode[swapType];\n    }\n\n    function changeTransitSwap(address newTransit) external onlyExecutor {\n        address oldTransit = _transit_swap;\n        _transit_swap = newTransit;\n        emit ChangeTransitSwap(oldTransit, newTransit);\n    }\n\n    function changeTransitCross(address newTransit) external onlyExecutor {\n        address oldTransit = _transit_cross;\n        _transit_cross = newTransit;\n        emit ChangeTransitCross(oldTransit, newTransit);\n    }\n\n    function changeTransitFees(address newTransitFees) external onlyExecutor {\n        address oldTransitFees = _transit_fees;\n        _transit_fees = newTransitFees;\n        emit ChangeTransitFees(oldTransitFees, newTransitFees);\n    }\n\n    function changeSwapTypeMode(uint8[] memory swapTypes) external onlyExecutor {\n        bool[] memory newModes = new bool[](swapTypes.length);\n        for (uint index; index < swapTypes.length; index++) {\n            _swap_type_mode[swapTypes[index]] = !_swap_type_mode[swapTypes[index]];\n            newModes[index] = _swap_type_mode[swapTypes[index]];\n        }\n        emit ChangeSwapTypeMode(swapTypes, newModes);\n    }\n\n    function changePause(bool paused) external onlyExecutor {\n        if (paused) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    function _beforeSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n        if (preTradeModel) {\n            fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n        }\n        if (TransferHelper.isETH(desc.srcToken)) {\n            require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n            swapAmount = desc.amount.sub(fee);\n        } else {\n            if (preTradeModel) {\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n                TransferHelper.safeTransfer(desc.srcToken, desc.srcReceiver, desc.amount.sub(fee));\n            } else {\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, desc.srcReceiver, desc.amount);\n            }\n        }\n        if (TransferHelper.isETH(desc.dstToken)) {\n            if (preTradeModel) {\n                beforeBalance = desc.dstReceiver.balance;\n            } else {\n                if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n                    beforeBalance = IERC20(desc.wrappedNative).balanceOf(address(this));\n                } else {\n                    beforeBalance = address(this).balance;\n                }\n            }\n        } else {\n            if (preTradeModel) {\n                beforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n            } else {\n                beforeBalance = IERC20(desc.dstToken).balanceOf(address(this));\n            }\n        }\n    }\n\n    function _afterSwap(bool preTradeModel, TransitStructs.TransitSwapDescription calldata desc, uint256 beforeBalance) private returns (uint256 returnAmount, uint256 fee) {\n        if (TransferHelper.isETH(desc.dstToken)) {\n            if (preTradeModel) {\n                returnAmount = desc.dstReceiver.balance.sub(beforeBalance);\n                require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n            } else {\n                if (desc.swapType == uint8(TransitStructs.SwapTypes.swap)) {\n                    returnAmount = IERC20(desc.wrappedNative).balanceOf(address(this)).sub(beforeBalance);\n                    TransferHelper.safeWithdraw(desc.wrappedNative, returnAmount);\n                } else {\n                    returnAmount = address(this).balance.sub(beforeBalance);\n                }\n                fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n                returnAmount = returnAmount.sub(fee);\n                require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n                TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);\n            }\n        } else {\n            if (preTradeModel) {\n                returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(beforeBalance);\n                require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n            } else {\n                returnAmount = IERC20(desc.dstToken).balanceOf(address(this)).sub(beforeBalance);\n                fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, returnAmount, desc.swapType, desc.channel);\n                returnAmount = returnAmount.sub(fee);\n                uint256 receiverBeforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\n                TransferHelper.safeTransfer(desc.dstToken, desc.dstReceiver, returnAmount);\n                returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(receiverBeforeBalance);\n                require(returnAmount >= desc.minReturnAmount, \"TransitSwap: insufficient return amount\");\n            }\n        }        \n    }\n\n    function swap(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n        require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n        require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n        require(desc.dstReceiver != address(0), \"TransitSwap: receiver should be not address(0)\");\n        require(desc.minReturnAmount > 0, \"TransitSwap: minReturnAmount should be greater than 0\");\n        if (callbytesDesc.flag == uint8(TransitStructs.Flag.aggregate)) {\n            require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n        }\n        bool preTradeModel = !_swap_type_mode[desc.swapType];\n        (uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeSwap(preTradeModel, desc);\n\n        {\n            //bytes4(keccak256(bytes('callbytes(TransitStructs.CallbytesDescription)')));\n            (bool success, bytes memory result) = _transit_swap.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n            if (!success) {\n                revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n            }\n        }\n\n        (uint256 returnAmount, uint256 postFee) = _afterSwap(preTradeModel, desc, beforeBalance);\n        if (postFee > fee) {\n            fee = postFee;\n        }\n        _emitTransit(desc, preTradeModel, fee, returnAmount);\n    }\n\n    function _beforeCross(TransitStructs.TransitSwapDescription calldata desc) private returns (uint256 swapAmount, uint256 fee, uint256 beforeBalance) {\n        fee = ITransitSwapFees(_transit_fees).getFeeRate(msg.sender, desc.amount, desc.swapType, desc.channel);\n        if (TransferHelper.isETH(desc.srcToken)) {\n            require(msg.value == desc.amount, \"TransitSwap: invalid msg.value\");\n            swapAmount = desc.amount.sub(fee);\n        } else {\n            beforeBalance = IERC20(desc.srcToken).balanceOf(_transit_cross);\n            if (fee == 0) {\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, _transit_cross, desc.amount);\n            } else {\n                TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\n                TransferHelper.safeTransfer(desc.srcToken, _transit_cross, desc.amount.sub(fee));\n            }\n        }\n    }\n\n    function cross(TransitStructs.TransitSwapDescription calldata desc, TransitStructs.CallbytesDescription calldata callbytesDesc) external payable nonReentrant whenNotPaused {\n        require(callbytesDesc.calldatas.length > 0, \"TransitSwap: data should be not zero\");\n        require(desc.amount > 0, \"TransitSwap: amount should be greater than 0\");\n        require(desc.srcToken == callbytesDesc.srcToken, \"TransitSwap: invalid callbytesDesc\");\n        (uint256 swapAmount, uint256 fee, uint256 beforeBalance) = _beforeCross(desc);\n        \n        {\n            //bytes4(keccak256(bytes('callbytes(TransitStructs.CallbytesDescription)')));\n            (bool success, bytes memory result) = _transit_cross.call{value:swapAmount}(abi.encodeWithSelector(0xccbe4007, callbytesDesc));\n            if (!success) {\n                revert(RevertReasonParser.parse(result,\"TransitSwap:\"));\n            }\n        }\n        \n        if (!TransferHelper.isETH(desc.srcToken)) {\n            require(IERC20(desc.srcToken).balanceOf(_transit_cross) >= beforeBalance, \"TransitSwap: invalid cross\");\n        }\n\n        _emitTransit(desc, true, fee, 0);\n    }\n\n    function _emitTransit(TransitStructs.TransitSwapDescription calldata desc, bool preTradeModel, uint256 fee, uint256 returnAmount) private {\n        emit TransitSwapped(\n            desc.srcToken, \n            desc.dstToken, \n            desc.dstReceiver, \n            msg.sender, \n            preTradeModel, \n            desc.amount, \n            returnAmount, \n            desc.minReturnAmount, \n            fee, \n            desc.toChainID, \n            desc.channel,\n            block.timestamp\n        );\n    }\n\n    function withdrawTokens(address[] memory tokens, address recipient) external onlyExecutor {\n        for(uint index; index < tokens.length; index++) {\n            uint amount;\n            if(TransferHelper.isETH(tokens[index])) {\n                amount = address(this).balance;\n                TransferHelper.safeTransferETH(recipient, amount);\n            } else {\n                amount = IERC20(tokens[index]).balanceOf(address(this));\n                TransferHelper.safeTransferWithoutRequire(tokens[index], recipient, amount);\n            }\n            emit Withdraw(tokens[index], msg.sender, recipient, amount);\n        }\n    }\n}"
    },
    "interfaces/ITransitSwapFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.9;\n\ninterface ITransitSwapFees {\n    \n    function getFeeRate(address trader, uint256 tradeAmount, uint8 swapType, string memory channel) external  view returns (uint payFees);\n\n}"
    },
    "interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.9;\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n}"
    },
    "libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n    \n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y != 0 , 'ds-math-div-zero');\n        z = x / y;\n    }\n}"
    },
    "libraries/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"
    },
    "libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n// Add executor extension\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n    address private _pendingOwner;\n    address private _executor;\n    address private _pendingExecutor;\n    bool internal _initialized;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event ExecutorshipTransferStarted(address indexed previousExecutor, address indexed newExecutor);\n    event ExecutorshipTransferred(address indexed previousExecutor, address indexed newExecutor);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor(address newExecutor) {\n        require(!_initialized, \"Ownable: initialized\");\n        _transferOwnership(msg.sender);\n        _transferExecutorship(newExecutor);\n        _initialized = true;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the executor.\n     */\n    modifier onlyExecutor() {\n        _checkExecutor();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the current executor.\n     */\n    function executor() public view virtual returns (address) {\n        return _executor;\n    }\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Returns the address of the pending executor.\n     */\n    function pendingExecutor() public view virtual returns (address) {\n        return _pendingExecutor;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Throws if the sender is not the executor.\n     */\n    function _checkExecutor() internal view virtual {\n        require(executor() == msg.sender, \"Ownable: caller is not the executor\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers executorship of the contract to a new account (`newExecutor`).\n     * Can only be called by the current executor.\n     */\n    function transferExecutorship(address newExecutor) public virtual onlyExecutor {\n        _pendingExecutor = newExecutor;\n        emit ExecutorshipTransferStarted(executor(), newExecutor);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        delete _pendingOwner;\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function _transferExecutorship(address newExecutor) internal virtual {\n        delete _pendingExecutor;\n        address oldExecutor = _executor;\n        _executor = newExecutor;\n        emit ExecutorshipTransferred(oldExecutor, newExecutor);\n    }\n\n    function acceptOwnership() external {\n        address sender = msg.sender;\n        require(pendingOwner() == sender, \"Ownable: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    function acceptExecutorship() external {\n        address sender = msg.sender;\n        require(pendingExecutor() == sender, \"Ownable: caller is not the new executor\");\n        _transferExecutorship(sender);\n    }\n}"
    },
    "libraries/TransitStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary TransitStructs {\n\n    enum SwapTypes {aggregatePreMode, aggregatePostMode, swap, cross}\n    enum Flag {aggregate, swap, cross}\n\n    struct TransitSwapDescription {\n        uint8 swapType;\n        address srcToken;\n        address dstToken;\n        address srcReceiver;\n        address dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        string channel;\n        uint256 toChainID;\n        address wrappedNative;\n    }\n\n    struct CallbytesDescription {\n        uint8 flag;\n        address srcToken;\n        bytes calldatas;\n    }\n\n    struct AggregateDescription {\n        address dstToken;\n        address receiver;\n        uint[] amounts;\n        uint[] needTransfer;\n        address[] callers;\n        address[] approveProxy;\n        bytes[] calls;\n    }\n\n    struct SwapDescription {\n        address[][] paths;\n        address[][] pairs;\n        uint[] fees;\n        address receiver;\n        uint deadline;\n    }\n\n    struct CrossDescription {\n        address caller;\n        uint256 amount;\n        bool needWrapped;\n        bytes calls;\n    }\n\n    function decodeAggregateDesc(bytes calldata calldatas) internal pure returns (AggregateDescription memory desc) {\n        desc = abi.decode(calldatas, (AggregateDescription));\n    }\n\n    function decodeSwapDesc(bytes calldata calldatas) internal pure returns (SwapDescription memory desc) {\n        desc = abi.decode(calldatas, (SwapDescription));\n    }\n\n    function decodeCrossDesc(bytes calldata calldatas) internal pure returns (CrossDescription memory desc) {\n        desc = abi.decode(calldatas, (CrossDescription));\n    }\n}"
    },
    "libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nlibrary TransferHelper {\n    \n    address private constant _ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    address private constant _ZERO_ADDRESS = address(0);\n    \n    function isETH(address token) internal pure returns (bool) {\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n    }\n    \n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_TOKEN_FAILED');\n    }\n    \n    function safeTransferWithoutRequire(address token, address to, uint256 value) internal returns (bool) {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        // solium-disable-next-line\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeDeposit(address wrapped, uint value) internal {\n        // bytes4(keccak256(bytes('deposit()')));\n        (bool success, bytes memory data) = wrapped.call{value:value}(abi.encodeWithSelector(0xd0e30db0));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: DEPOSIT_FAILED');\n    }\n\n    function safeWithdraw(address wrapped, uint value) internal {\n        // bytes4(keccak256(bytes('withdraw(uint256 wad)')));\n        (bool success, bytes memory data) = wrapped.call{value:0}(abi.encodeWithSelector(0x2e1a7d4d, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: WITHDRAW_FAILED');\n    }\n}"
    },
    "libraries/RevertReasonParser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nlibrary RevertReasonParser {\n        function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\n        // https://solidity.readthedocs.io/en/latest/control-structures.html#revert\n        // We assume that revert reason is abi-encoded as Error(string)\n\n        // 68 = 4-byte selector 0x08c379a0 + 32 bytes offset + 32 bytes length\n        if (data.length >= 68 && data[0] == \"\\x08\" && data[1] == \"\\xc3\" && data[2] == \"\\x79\" && data[3] == \"\\xa0\") {\n            string memory reason;\n            // solhint-disable no-inline-assembly\n            assembly {\n                // 68 = 32 bytes data length + 4-byte selector + 32 bytes offset\n                reason := add(data, 68)\n            }\n            /*\n                revert reason is padded up to 32 bytes with ABI encoder: Error(string)\n                also sometimes there is extra 32 bytes of zeros padded in the end:\n                https://github.com/ethereum/solidity/issues/10170\n                because of that we can't check for equality and instead check\n                that string length + extra 68 bytes is less than overall data length\n            */\n            require(data.length >= 68 + bytes(reason).length, \"Invalid revert reason\");\n            return string(abi.encodePacked(prefix, \"Error(\", reason, \")\"));\n        }\n        // 36 = 4-byte selector 0x4e487b71 + 32 bytes integer\n        else if (data.length == 36 && data[0] == \"\\x4e\" && data[1] == \"\\x48\" && data[2] == \"\\x7b\" && data[3] == \"\\x71\") {\n            uint256 code;\n            // solhint-disable no-inline-assembly\n            assembly {\n                // 36 = 32 bytes data length + 4-byte selector\n                code := mload(add(data, 36))\n            }\n            return string(abi.encodePacked(prefix, \"Panic(\", _toHex(code), \")\"));\n        }\n\n        return string(abi.encodePacked(prefix, \"Unknown(\", _toHex(data), \")\"));\n    }\n    \n    function _toHex(uint256 value) private pure returns(string memory) {\n        return _toHex(abi.encodePacked(value));\n    }\n\n    function _toHex(bytes memory data) private pure returns(string memory) {\n        bytes16 alphabet = 0x30313233343536373839616263646566;\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\n        }\n        return string(str);\n    }\n}"
    },
    "libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}