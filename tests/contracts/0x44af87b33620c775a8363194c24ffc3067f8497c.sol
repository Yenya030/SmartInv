{{
  "language": "Solidity",
  "sources": {
    "contracts/stakingV2/EsAPEX2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IEsAPEX2.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/FullMath.sol\";\n\ncontract EsAPEX2 is IEsAPEX2, Ownable {\n    using FullMath for uint256;\n\n    string public constant override name = \"esApeX\";\n    string public constant override symbol = \"esAPEX\";\n    uint8 public constant override decimals = 18;\n\n    address public immutable override apeXToken;\n    address public override treasury;\n\n    uint256 public override forceWithdrawMinRemainRatio; // max:10000, default:1666\n    uint256 public override vestTime;\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    mapping(address => bool) public isMinter;\n    mapping(address => VestInfo[]) public userVestInfos;\n\n    constructor(\n        address owner_,\n        address apeXToken_,\n        address treasury_,\n        uint256 vestTime_,\n        uint256 forceWithdrawMinRemainRatio_\n    ) {\n        owner = owner_;\n        apeXToken = apeXToken_;\n        treasury = treasury_;\n        vestTime = vestTime_;\n        forceWithdrawMinRemainRatio = forceWithdrawMinRemainRatio_;\n        isMinter[owner] = true;\n    }\n\n    function addMinter(address minter) external onlyOwner {\n        require(!isMinter[minter], \"minter already exist\");\n        isMinter[minter] = true;\n    }\n\n    function removeMinter(address minter) external onlyOwner {\n        require(isMinter[minter], \"minter not found\");\n        isMinter[minter] = false;\n    }\n\n    function updateTreasury(address newTreasury) external onlyOwner {\n        require(newTreasury != address(0), \"zero address\");\n        treasury = newTreasury;\n    }\n\n    function updateVestTime(uint256 newVestTime) external onlyOwner {\n        emit VestTimeChanged(vestTime, newVestTime);\n        vestTime = newVestTime;\n    }\n\n    function updateForceWithdrawMinRemainRatio(uint256 newRatio) external onlyOwner {\n        require(newRatio <= 10000, \"newRatio > 10000\");\n        emit ForceWithdrawMinRemainRatioChanged(forceWithdrawMinRemainRatio, newRatio);\n        forceWithdrawMinRemainRatio = newRatio;\n    }\n\n    function mint(address to, uint256 amount) external override returns (bool) {\n        require(isMinter[msg.sender], \"not minter\");\n        require(amount > 0, \"zero amount\");\n        TransferHelper.safeTransferFrom(apeXToken, msg.sender, address(this), amount);\n        _mint(to, amount);\n        return true;\n    }\n\n    function vest(uint256 amount) external override {\n        require(amount > 0, \"zero amount\");\n        uint256 fromBalance = balanceOf[msg.sender];\n        require(fromBalance >= amount, \"not enough balance to be vest\");\n        _transfer(msg.sender, address(this), amount);\n\n        VestInfo memory info = VestInfo({\n            startTime: block.timestamp,\n            endTime: block.timestamp + vestTime,\n            vestAmount: amount,\n            claimedAmount: 0,\n            forceWithdrawn: false\n        });\n\n        uint256 vestId = userVestInfos[msg.sender].length;\n        userVestInfos[msg.sender].push(info);\n\n        emit Vest(msg.sender, amount, info.endTime, vestId);\n    }\n\n    function withdraw(address to, uint256 vestId, uint256 amount) external override {\n        _withdraw(to, vestId, amount);\n    }\n\n    function batchWithdraw(address to, uint256[] memory vestIds, uint256[] memory amounts) external override {\n        require(vestIds.length == amounts.length, \"two arrays' length not the same\");\n        for (uint256 i = 0; i < vestIds.length; i++) {\n            _withdraw(to, vestIds[i], amounts[i]);\n        }\n    }\n\n    function forceWithdraw(\n        address to,\n        uint256 vestId\n    ) external override returns (uint256 withdrawAmount, uint256 penalty) {\n        return _forceWithdraw(to, vestId);\n    }\n\n    function batchForceWithdraw(\n        address to,\n        uint256[] memory vestIds\n    ) external override returns (uint256 withdrawAmount, uint256 penalty) {\n        for (uint256 i = 0; i < vestIds.length; i++) {\n            (uint256 withdrawAmount_, uint256 penalty_) = _forceWithdraw(to, vestIds[i]);\n            withdrawAmount += withdrawAmount_;\n            penalty += penalty_;\n        }\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n        _spendAllowance(from, msg.sender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function getVestInfo(address user, uint256 vestId) external view override returns (VestInfo memory) {\n        return userVestInfos[user][vestId];\n    }\n\n    function getVestInfosByPage(\n        address user,\n        uint256 offset,\n        uint256 size\n    ) external view override returns (VestInfo[] memory vestInfos) {\n        uint256 len = userVestInfos[user].length;\n        if (offset > len) {\n            return vestInfos;\n        }\n        if (size >= len - offset) {\n            size = len - offset;\n        }\n        vestInfos = new VestInfo[](size);\n        for (uint256 i = 0; i < len; i++) {\n            vestInfos[i] = userVestInfos[user][offset + i];\n        }\n    }\n\n    function getVestInfosLength(address user) external view override returns (uint256 length) {\n        return userVestInfos[user].length;\n    }\n\n    function getClaimable(address user, uint256 vestId) external view override returns (uint256 claimable) {\n        return _getClaimable(user, vestId);\n    }\n\n    function getTotalClaimable(\n        address user,\n        uint256[] memory vestIds\n    ) external view override returns (uint256 claimable) {\n        for (uint256 i = 0; i < vestIds.length; i++) {\n            claimable += _getClaimable(user, vestIds[i]);\n        }\n    }\n\n    function getLocking(address user, uint256 vestId) external view override returns (uint256 locking) {\n        return _getLocking(user, vestId);\n    }\n\n    function getTotalLocking(address user, uint256[] memory vestIds) external view override returns (uint256 locking) {\n        for (uint256 i = 0; i < vestIds.length; i++) {\n            locking += _getLocking(user, vestIds[i]);\n        }\n    }\n\n    function getForceWithdrawable(\n        address user,\n        uint256 vestId\n    ) external view override returns (uint256 withdrawable, uint256 penalty) {\n        return _getForceWithdrawable(user, vestId);\n    }\n\n    function getTotalForceWithdrawable(\n        address user,\n        uint256[] memory vestIds\n    ) external view override returns (uint256 withdrawable, uint256 penalty) {\n        for (uint256 i = 0; i < vestIds.length; i++) {\n            (uint256 withdrawable_, uint256 penalty_) = _getForceWithdrawable(user, vestIds[i]);\n            withdrawable += withdrawable_;\n            penalty += penalty_;\n        }\n    }\n\n    function _getClaimable(address user, uint256 vestId) internal view returns (uint256 claimable) {\n        VestInfo memory info = userVestInfos[user][vestId];\n        if (!info.forceWithdrawn) {\n            uint256 pastTime = block.timestamp - info.startTime;\n            uint256 wholeTime = info.endTime - info.startTime;\n            if (pastTime >= wholeTime) {\n                claimable = info.vestAmount;\n            } else {\n                claimable = info.vestAmount.mulDiv(pastTime, wholeTime);\n            }\n            claimable = claimable - info.claimedAmount;\n        }\n    }\n\n    function _getLocking(address user, uint256 vestId) internal view returns (uint256 locking) {\n        VestInfo memory info = userVestInfos[user][vestId];\n        if (!info.forceWithdrawn) {\n            if (block.timestamp >= info.endTime) {\n                locking = 0;\n            } else {\n                uint256 leftTime = info.endTime - block.timestamp;\n                uint256 wholeTime = info.endTime - info.startTime;\n                locking = info.vestAmount.mulDiv(leftTime, wholeTime);\n            }\n        }\n    }\n\n    function _getForceWithdrawable(\n        address user,\n        uint256 vestId\n    ) internal view returns (uint256 withdrawable, uint256 penalty) {\n        VestInfo memory info = userVestInfos[user][vestId];\n        uint256 locking = _getLocking(user, vestId);\n        uint256 left = (locking *\n            (forceWithdrawMinRemainRatio +\n                ((10000 - forceWithdrawMinRemainRatio) * (block.timestamp - info.startTime)) /\n                vestTime)) / 10000;\n        if (left > locking) left = locking;\n        uint256 claimable = _getClaimable(user, vestId);\n        withdrawable = claimable + left;\n        penalty = locking - left;\n    }\n\n    function _withdraw(address to, uint256 vestId, uint256 amount) internal {\n        require(to != address(0), \"can not withdraw to zero address\");\n        require(amount > 0, \"zero amount\");\n        VestInfo storage info = userVestInfos[msg.sender][vestId];\n        require(!info.forceWithdrawn, \"already force withdrawn\");\n\n        uint256 claimable = _getClaimable(msg.sender, vestId);\n        require(amount <= claimable, \"amount > claimable\");\n\n        info.claimedAmount += amount;\n        TransferHelper.safeTransfer(apeXToken, to, amount);\n        _burn(address(this), amount);\n        emit Withdraw(msg.sender, to, amount, vestId);\n    }\n\n    function _forceWithdraw(address to, uint256 vestId) internal returns (uint256 withdrawAmount, uint256 penalty) {\n        require(to != address(0), \"can not withdraw to zero address\");\n        VestInfo storage info = userVestInfos[msg.sender][vestId];\n        require(!info.forceWithdrawn, \"already force withdrawn\");\n\n        (withdrawAmount, penalty) = _getForceWithdrawable(msg.sender, vestId);\n        require(withdrawAmount > 0, \"withdrawAmount is zero\");\n        TransferHelper.safeTransfer(apeXToken, to, withdrawAmount);\n        if (penalty > 0) TransferHelper.safeTransfer(apeXToken, treasury, penalty);\n        info.claimedAmount += withdrawAmount;\n        info.forceWithdrawn = true;\n        _burn(address(this), withdrawAmount + penalty);\n        emit ForceWithdraw(msg.sender, to, withdrawAmount, penalty, vestId);\n    }\n\n    function _spendAllowance(address from, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance[from][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= value, \"insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - value);\n            }\n        }\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply + value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        require(balanceOf[from] >= value, \"balance of from < value\");\n        balanceOf[from] = balanceOf[from] - value;\n        totalSupply = totalSupply - value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address _owner, address spender, uint256 value) private {\n        allowance[_owner][spender] = value;\n        emit Approval(_owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) private {\n        require(to != address(0), \"can not tranfer to zero address\");\n        uint256 fromBalance = balanceOf[from];\n        require(fromBalance >= value, \"transfer amount exceeds balance\");\n        balanceOf[from] = fromBalance - value;\n        balanceOf[to] = balanceOf[to] + value;\n        emit Transfer(from, to, value);\n    }\n}\n"
    },
    "contracts/stakingV2/interfaces/IEsAPEX2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC20.sol\";\n\ninterface IEsAPEX2 is IERC20 {\n    event ForceWithdrawMinRemainRatioChanged(uint256 oldRatio, uint256 newRatio);\n    event VestTimeChanged(uint256 oldVestTime, uint256 newVestTime);\n    event Vest(address indexed user, uint256 amount, uint256 endTime, uint256 vestId);\n    event Withdraw(address indexed user, address indexed to, uint256 amount, uint256 vestId);\n    event ForceWithdraw(\n        address indexed user,\n        address indexed to,\n        uint256 withdrawAmount,\n        uint256 penalty,\n        uint256 vestId\n    );\n\n    struct VestInfo {\n        uint256 startTime;\n        uint256 endTime;\n        uint256 vestAmount;\n        uint256 claimedAmount;\n        bool forceWithdrawn;\n    }\n\n    function apeXToken() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function forceWithdrawMinRemainRatio() external view returns (uint256);\n\n    function vestTime() external view returns (uint256);\n\n    function getVestInfo(address user, uint256 vestId) external view returns (VestInfo memory);\n\n    function getVestInfosByPage(\n        address user,\n        uint256 offset,\n        uint256 size\n    ) external view returns (VestInfo[] memory vestInfos);\n\n    function getVestInfosLength(address user) external view returns (uint256 length);\n\n    function getClaimable(address user, uint256 vestId) external view returns (uint256 claimable);\n\n    function getTotalClaimable(address user, uint256[] memory vestIds) external view returns (uint256 claimable);\n\n    function getLocking(address user, uint256 vestId) external view returns (uint256 locking);\n\n    function getTotalLocking(address user, uint256[] memory vestIds) external view returns (uint256 locking);\n\n    function getForceWithdrawable(address user, uint256 vestId)\n        external\n        view\n        returns (uint256 withdrawable, uint256 penalty);\n\n    function getTotalForceWithdrawable(address user, uint256[] memory vestIds)\n        external\n        view\n        returns (uint256 withdrawable, uint256 penalty);\n\n    function mint(address to, uint256 apeXAmount) external returns (bool);\n\n    function vest(uint256 amount) external;\n\n    function withdraw(\n        address to,\n        uint256 vestId,\n        uint256 amount\n    ) external;\n\n    function batchWithdraw(\n        address to,\n        uint256[] memory vestIds,\n        uint256[] memory amounts\n    ) external;\n\n    function forceWithdraw(address to, uint256 vestId) external returns (uint256 withdrawAmount, uint256 penalty);\n\n    function batchForceWithdraw(address to, uint256[] memory vestIds)\n        external\n        returns (uint256 withdrawAmount, uint256 penalty);\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nabstract contract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n    event NewOwner(address indexed oldOwner, address indexed newOwner);\n    event NewPendingOwner(address indexed oldPendingOwner, address indexed newPendingOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: REQUIRE_OWNER\");\n        _;\n    }\n\n    function setPendingOwner(address newPendingOwner) external onlyOwner {\n        require(pendingOwner != newPendingOwner, \"Ownable: ALREADY_SET\");\n        emit NewPendingOwner(pendingOwner, newPendingOwner);\n        pendingOwner = newPendingOwner;\n    }\n\n    function acceptOwner() external {\n        require(msg.sender == pendingOwner, \"Ownable: REQUIRE_PENDING_OWNER\");\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n        owner = pendingOwner;\n        pendingOwner = address(0);\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeApprove: approve failed\"\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::transferFrom: transferFrom failed\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\n    }\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n\n        // todo unchecked\n        unchecked {\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (~denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external pure returns (uint8);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}