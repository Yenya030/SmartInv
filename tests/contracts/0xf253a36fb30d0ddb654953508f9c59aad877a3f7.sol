{{
  "language": "Solidity",
  "sources": {
    "lib/ERC721A/contracts/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
    },
    "lib/ERC721A/contracts/interfaces/IERC721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721A.sol';\n"
    },
    "lib/ERC721H/src/interfaces/IERC721ACH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ninterface IERC721ACH {\n    /**\n     * @dev Enumerated list of all available hook types for the ERC721ACH contract.\n     */\n    enum HookType {\n        /// @notice Hook for custom logic before a token transfer occurs.\n        BeforeTokenTransfers,\n        /// @notice Hook for custom logic after a token transfer occurs.\n        AfterTokenTransfers,\n        /// @notice Hook for custom logic for ownerOf() function.\n        OwnerOf\n    }\n\n    /**\n     * @notice An event that gets emitted when a hook is updated.\n     * @param setter The address that set the hook.\n     * @param hookType The type of the hook that was set.\n     * @param hookAddress The address of the contract that implements the hook.\n     */\n    event UpdatedHook(\n        address indexed setter,\n        HookType hookType,\n        address indexed hookAddress\n    );\n\n    /**\n     * @notice Sets the contract address for a specified hook type.\n     * @param hookType The type of hook to set, as defined in the HookType enum.\n     * @param hookAddress The address of the contract implementing the hook interface.\n     */\n    function setHook(HookType hookType, address hookAddress) external;\n\n    /**\n     * @notice Returns the contract address for a specified hook type.\n     * @param hookType The type of hook to set, as defined in the HookType enum.\n     * @return The address of the contract implementing the hook interface.\n     */\n    function getHook(HookType hookType) external view returns (address);\n}\n"
    },
    "src/interfaces/ICollectionHolderMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @title ICollectionHolderMint\n * @dev This interface represents the functions related to minting a collection of tokens.\n */\ninterface ICollectionHolderMint {\n    // Events\n    error AlreadyClaimedFreeMint(); // Fired when a free mint has already been claimed\n    error NoTokensProvided(); // Fired when a mint function is called with no tokens provided\n    error DuplicatesFound(); // Fired when a mint function is called with duplicate tokens\n\n    /**\n     * @dev Returns whether a specific mint has been claimed\n     * @param tokenId The ID of the token in question\n     * @return A boolean indicating whether the mint has been claimed\n     */\n    function freeMintClaimed(uint256 tokenId) external view returns (bool);\n\n    /**\n     * @dev Returns the address of the collection contract\n     * @return The address of the collection contract\n     */\n    function cre8orsNFTContractAddress() external view returns (address);\n\n    /**\n     * @dev Returns the address of the minter utility contract\n     * @return The address of the minter utility contract\n     */\n    function minterUtilityContractAddress() external view returns (address);\n\n    /**\n     * @dev Returns the maximum number of free mints claimed by an address\n     * @return The maximum number of free mints claimed\n     */\n    function totalClaimed(address) external view returns (uint256);\n\n    /**\n     * @dev Mints a batch of tokens and sends them to a recipient\n     * @param tokenIds An array of token IDs to mint\n     * @param recipient The address to send the minted tokens to\n     * @return The last token ID minted in this batch\n     */\n    function mint(\n        uint256[] calldata tokenIds,\n        address recipient\n    ) external returns (uint256);\n\n    /**\n     * @dev Changes the address of the minter utility contract\n     * @param _newMinterUtilityContractAddress The new minter utility contract address\n     */\n    function setNewMinterUtilityContractAddress(\n        address _newMinterUtilityContractAddress\n    ) external;\n\n    /**\n     * @dev Toggles the claim status of a free mint\n     * @param tokenId The ID of the token whose claim status is being toggled\n     */\n    function toggleHasClaimedFreeMint(uint256 tokenId) external;\n}\n"
    },
    "src/interfaces/ICre8ing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ILockup} from \"./ILockup.sol\";\n\ninterface ICre8ing {\n    /// @notice Getter for Lockup interface\n    function lockUp(address) external view returns (ILockup);\n\n    /// @dev Emitted when a CRE8OR begins cre8ing.\n    event Cre8ed(address, uint256 indexed tokenId);\n\n    /// @dev Emitted when a CRE8OR stops cre8ing; either through standard means or\n    ///     by expulsion.\n    event Uncre8ed(address, uint256 indexed tokenId);\n\n    /// @dev Emitted when a CRE8OR is expelled from the Warehouse.\n    event Expelled(address, uint256 indexed tokenId);\n\n    /// @notice Missing cre8ing status\n    error CRE8ING_NotCre8ing(address, uint256 tokenId);\n\n    /// @notice Cre8ing Closed\n    error Cre8ing_Cre8ingClosed();\n\n    /// @notice Cre8ing\n    error Cre8ing_Cre8ing();\n\n    /// @notice Missing Lockup\n    error Cre8ing_MissingLockup();\n\n    /// @notice Cre8ing period\n    function cre8ingPeriod(\n        address,\n        uint256\n    ) external view returns (bool cre8ing, uint256 current, uint256 total);\n\n    /// @notice open / close staking\n    function setCre8ingOpen(address, bool) external;\n\n    /// @notice force removal from staking\n    function expelFromWarehouse(address, uint256) external;\n\n    /// @notice function getCre8ingStarted(\n    function getCre8ingStarted(\n        address _target,\n        uint256 tokenId\n    ) external view returns (uint256);\n\n    /// @notice array of staked tokenIDs\n    /// @dev used in cre8ors ui to quickly get list of staked NFTs.\n    function cre8ingTokens(\n        address _target\n    ) external view returns (uint256[] memory stakedTokens);\n\n    /// @notice initialize both staking and lockups\n    function inializeStakingAndLockup(\n        address _target,\n        uint256[] memory,\n        bytes memory\n    ) external;\n\n    /// @notice Set a new lockup for the target.\n    /// @param _target The target address.\n    /// @param newLockup The new lockup contract address.\n    function setLockup(address _target, ILockup newLockup) external;\n}\n"
    },
    "src/interfaces/ICre8ors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC721Drop} from \"./IERC721Drop.sol\";\nimport {ILockup} from \"./ILockup.sol\";\nimport {IERC721A} from \"erc721a/contracts/IERC721A.sol\";\nimport {ICre8ing} from \"./ICre8ing.sol\";\nimport {ISubscription} from \"../subscription/interfaces/ISubscription.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n*/\n/// @notice Interface for Cre8ors Drops contract\ninterface ICre8ors is IERC721Drop, IERC721A {\n    function cre8ing() external view returns (ICre8ing);\n\n    /// @notice Getter for last minted token ID (gets next token id and subtracts 1)\n    function _lastMintedTokenId() external view returns (uint256);\n\n    /// @dev Returns `true` if `account` has been granted `role`.\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    function subscription() external view returns (address);\n\n    function setSubscription(address newSubscription) external;\n\n    function setCre8ing(ICre8ing _cre8ing) external;\n\n    function MINTER_ROLE() external returns (bytes32);\n}\n"
    },
    "src/interfaces/IERC721Drop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IMetadataRenderer} from \"../interfaces/IMetadataRenderer.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n*/\n/// @notice Interface for Cre8ors Drop contract\ninterface IERC721Drop {\n    // Access errors\n\n    /// @notice Only admin can access this function\n    error Access_OnlyAdmin();\n    /// @notice Missing the given role or admin access\n    error Access_MissingRoleOrAdmin(bytes32 role);\n    /// @notice Withdraw is not allowed by this user\n    error Access_WithdrawNotAllowed();\n    /// @notice Cannot withdraw funds due to ETH send failure.\n    error Withdraw_FundsSendFailure();\n    /// @notice Missing the owner role.\n    error Access_OnlyOwner();\n    /// @notice Missing the owner role or approved nft access.\n    error Access_MissingOwnerOrApproved();\n\n    // Sale/Purchase errors\n    /// @notice Sale is inactive\n    error Sale_Inactive();\n    /// @notice Presale is inactive\n    error Presale_Inactive();\n    /// @notice Presale merkle root is invalid\n    error Presale_MerkleNotApproved();\n    /// @notice Wrong price for purchase\n    error Purchase_WrongPrice(uint256 correctPrice);\n    /// @notice NFT sold out\n    error Mint_SoldOut();\n    /// @notice Too many purchase for address\n    error Purchase_TooManyForAddress();\n    /// @notice Too many presale for address\n    error Presale_TooManyForAddress();\n\n    // Admin errors\n    /// @notice Royalty percentage too high\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n    /// @notice Invalid admin upgrade address\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n    error Admin_UnableToFinalizeNotOpenEdition();\n\n    /// @notice Event emitted for each sale\n    /// @param to address sale was made to\n    /// @param quantity quantity of the minted nfts\n    /// @param pricePerToken price for each token\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n    event Sale(\n        address indexed to,\n        uint256 indexed quantity,\n        uint256 indexed pricePerToken,\n        uint256 firstPurchasedTokenId\n    );\n\n    /// @notice Sales configuration has been changed\n    /// @dev To access new sales configuration, use getter function.\n    /// @param changedBy Changed by user\n    event SalesConfigChanged(address indexed changedBy);\n\n    /// @notice Event emitted when the funds recipient is changed\n    /// @param newAddress new address for the funds recipient\n    /// @param changedBy address that the recipient is changed by\n    event FundsRecipientChanged(\n        address indexed newAddress,\n        address indexed changedBy\n    );\n\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\n    /// @param withdrawnBy address that issued the withdraw\n    /// @param withdrawnTo address that the funds were withdrawn to\n    /// @param amount amount that was withdrawn\n    event FundsWithdrawn(\n        address indexed withdrawnBy,\n        address indexed withdrawnTo,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n    /// @param sender address sending close mint\n    /// @param numberOfMints number of mints the contract is finalized at\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n    /// @notice Event emitted when metadata renderer is updated.\n    /// @param sender address of the updater\n    /// @param renderer new metadata renderer address\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n    /// @notice General configuration for NFT Minting and bookkeeping\n    struct Configuration {\n        /// @dev Metadata renderer (uint160)\n        IMetadataRenderer metadataRenderer;\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\n        uint64 editionSize;\n        /// @dev Royalty amount in bps (uint224+16 = 240)\n        uint16 royaltyBPS;\n        /// @dev Funds recipient for sale (new slot, uint160)\n        address payable fundsRecipient;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct SalesConfiguration {\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\n    struct BurnConfiguration {\n        /// @dev Token to burn\n        address burnToken;\n        /// @dev Required number of tokens to burn\n        uint256 burnQuantity;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct ERC20SalesConfiguration {\n        /// @notice Public sale price\n        /// @dev max ether value > 1000 ether with this value\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct SaleDetails {\n        // Synthesized status variables for sale and presale\n        bool publicSaleActive;\n        bool presaleActive;\n        // Price for public sale\n        uint256 publicSalePrice;\n        // Timed sale actions for public sale\n        uint64 publicSaleStart;\n        uint64 publicSaleEnd;\n        // Timed sale actions for presale\n        uint64 presaleStart;\n        uint64 presaleEnd;\n        // Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        // Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        // Information about the rest of the supply\n        // Total that have been minted\n        uint256 totalMinted;\n        // The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct ERC20SaleDetails {\n        /// @notice Synthesized status variables for sale\n        bool publicSaleActive;\n        /// @notice Synthesized status variables for presale\n        bool presaleActive;\n        /// @notice Price for public sale\n        uint256 publicSalePrice;\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\n        address erc20PaymentToken;\n        /// @notice public sale start\n        uint64 publicSaleStart;\n        /// @notice public sale end\n        uint64 publicSaleEnd;\n        /// @notice Timed sale actions for presale start\n        uint64 presaleStart;\n        /// @notice Timed sale actions for presale end\n        uint64 presaleEnd;\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        /// @notice Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        /// @notice Total that have been minted\n        uint256 totalMinted;\n        /// @notice The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return type of specific mint counts and details per address\n    struct AddressMintDetails {\n        /// Number of total mints from the given address\n        uint256 totalMints;\n        /// Number of presale mints from the given address\n        uint256 presaleMints;\n        /// Number of public mints from the given address\n        uint256 publicMints;\n    }\n\n    /// @notice External purchase function (payable in eth)\n    /// @param quantity to purchase\n    /// @return first minted token ID\n    function purchase(uint256 quantity) external payable returns (uint256);\n\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n    /// @param quantity to purchase\n    /// @param maxQuantity can purchase (verified by merkle root)\n    /// @param pricePerToken price per token allowed (verified by merkle root)\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\n    /// @return first minted token ID\n    function purchasePresale(\n        uint256 quantity,\n        uint256 maxQuantity,\n        uint256 pricePerToken,\n        bytes32[] memory merkleProof\n    ) external payable returns (uint256);\n\n    /// @notice Function to return the global sales details for the given drop\n    function saleDetails() external view returns (ERC20SaleDetails memory);\n\n    /// @notice Function to return the specific sales details for a given address\n    /// @param minter address for minter to return mint information for\n    function mintedPerAddress(\n        address minter\n    ) external view returns (AddressMintDetails memory);\n\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\n    function owner() external view returns (address);\n\n    /// @notice Update the metadata renderer\n    /// @param newRenderer new address for renderer\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n    function setMetadataRenderer(\n        IMetadataRenderer newRenderer,\n        bytes memory setupRenderer\n    ) external;\n\n    /// @notice This is an admin mint function to mint a quantity to a specific address\n    /// @param to address to mint to\n    /// @param quantity quantity to mint\n    /// @return the id of the first minted NFT\n    function adminMint(address to, uint256 quantity) external returns (uint256);\n\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n    /// @param to list of addresses to mint an NFT each to\n    /// @return the id of the first minted NFT\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n    /// @dev Getter for admin role associated with the contract to handle metadata\n    /// @return boolean if address is admin\n    function isAdmin(address user) external view returns (bool);\n}\n"
    },
    "src/interfaces/IFriendsAndFamilyMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title FriendsAndFamilyMinter Interface\n/// @notice This interface defines the functions and events for the FriendsAndFamilyMinter contract.\ninterface IFriendsAndFamilyMinter {\n    // Events\n    error MissingDiscount();\n    error ExistingDiscount();\n\n    // Functions\n\n    /// @dev Checks if the specified recipient has a discount.\n    /// @param recipient The address of the recipient to check for the discount.\n    /// @return A boolean indicating whether the recipient has a discount or not.\n    function hasDiscount(address recipient) external view returns (bool);\n\n    /// @dev Retrieves the address of the Cre8orsNFT contract used by the FriendsAndFamilyMinter.\n    /// @return The address of the Cre8orsNFT contract.\n    function cre8orsNFT() external view returns (address);\n\n    /// @dev Retrieves the address of the MinterUtilities contract used by the FriendsAndFamilyMinter.\n    /// @return The address of the MinterUtilities contract.\n    function minterUtilityContractAddress() external view returns (address);\n\n    /// @dev Retrieves the maximum number of tokens claimed for free by the specified recipient.\n    /// @param recipient The address of the recipient to query for the maximum claimed free tokens.\n    /// @return The maximum number of tokens claimed for free by the recipient.\n    function totalClaimed(address recipient) external view returns (uint256);\n\n    /// @dev Mints a new token for the specified recipient and returns the token ID.\n    /// @param recipient The address of the recipient who will receive the minted token.\n    /// @return The token ID of the minted token.\n    function mint(address recipient) external returns (uint256);\n\n    /// @dev Grants a discount to the specified recipient, allowing them to mint tokens without paying the regular price.\n    /// @param recipient The address of the recipient who will receive the discount.\n    function addDiscount(address recipient) external;\n\n    /// @dev Grants a discount to the specified recipient, allowing them to mint tokens without paying the regular price.\n    /// @param recipient The address of the recipients who will receive the discount.\n    function addDiscount(address[] memory recipient) external;\n\n    /// @dev Removes the discount from the specified recipient, preventing them from minting tokens with a discount.\n    /// @param recipient The address of the recipient whose discount will be removed.\n    function removeDiscount(address recipient) external;\n\n    /// @dev Sets a new address for the MinterUtilities contract.\n    /// @param _newMinterUtilityContractAddress The address of the new MinterUtilities contract.\n    function setNewMinterUtilityContractAddress(\n        address _newMinterUtilityContractAddress\n    ) external;\n}\n"
    },
    "src/interfaces/ILockup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\ninterface ILockup {\n    /// @notice Storage for token edition information\n    struct TokenLockupInfo {\n        uint64 unlockDate;\n        uint256 priceToUnlock;\n    }\n\n    /// @notice Locked\n    error Lockup_Locked();\n\n    /// @notice Wrong price for unlock\n    error Unlock_WrongPrice(uint256 correctPrice);\n\n    /// @notice Event for updated Lockup\n    event TokenLockupUpdated(\n        address indexed target,\n        uint256 tokenId,\n        uint64 unlockDate,\n        uint256 priceToUnlock\n    );\n\n    /// @notice retrieves locked state for token\n    function isLocked(address, uint256) external view returns (bool);\n\n    /// @notice retieves unlock date for token\n    function unlockInfo(\n        address,\n        uint256\n    ) external view returns (TokenLockupInfo memory);\n\n    /// @notice sets unlock tier for token\n    function setUnlockInfo(address, uint256, bytes memory) external;\n\n    /// @notice pay to unlock a locked token\n    function payToUnlock(address payable, uint256) external payable;\n}\n"
    },
    "src/interfaces/IMetadataRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\ninterface IMetadataRenderer {\n    function tokenURI(uint256) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function initializeWithData(bytes memory initData) external;\n}\n"
    },
    "src/interfaces/IMinterUtilities.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n * @title Minter Utilities Interface\n * @notice Interface for the MinterUtilities contract, which provides utility functions for the minter.\n */\ninterface IMinterUtilities {\n    /**\n     * @dev Emitted when the price of a tier is updated.\n     * @param tier The tier whose price is updated.\n     * @param price The new price for the tier.\n     */\n    event TierPriceUpdated(uint256 tier, uint256 price);\n\n    /**\n     * @dev Emitted when the lockup period of a tier is updated.\n     * @param tier The tier whose lockup period is updated.\n     * @param lockup The new lockup period for the tier.\n     */\n    event TierLockupUpdated(uint256 tier, uint256 lockup);\n\n    /**\n     * @dev Represents pricing and lockup information for a specific tier.\n     */\n    struct TierInfo {\n        uint256 price;\n        uint256 lockup;\n    }\n\n    /**\n     * @dev Represents a tier and quantity of NFTs.\n     */\n    struct Cart {\n        uint8 tier;\n        uint256 quantity;\n    }\n\n    /**\n     * @notice Calculates the total price for a given quantity of NFTs in a specific tier.\n     * @param tier The tier to calculate the price for.\n     * @param quantity The quantity of NFTs to calculate the price for.\n     * @return The total price in wei for the given quantity in the specified tier.\n     */\n    function calculatePrice(\n        uint8 tier,\n        uint256 quantity\n    ) external view returns (uint256);\n\n    /**\n     * @notice Returns the quantity of NFTs left that can be minted by the given recipient.\n     * @param passportHolderMinter The address of the PassportHolderMinter contract.\n     * @param friendsAndFamilyMinter The address of the FriendsAndFamilyMinter contract.\n     * @param target The address of the target contract (ICre8ors contract).\n     * @param recipient The recipient's address.\n     * @return The quantity of NFTs that can still be minted by the recipient.\n     */\n    function quantityLeft(\n        address passportHolderMinter,\n        address friendsAndFamilyMinter,\n        address target,\n        address recipient\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the total cost for a given list of NFTs in different tiers.\n     * @param carts An array of Cart struct representing the tiers and quantities.\n     * @return The total cost in wei for the given list of NFTs.\n     */\n    function calculateTotalCost(\n        uint256[] memory carts\n    ) external view returns (uint256);\n\n    /**\n     * @dev Calculates the unlock price for a given tier and minting option.\n     * @param tier The tier for which to calculate the unlock price.\n     * @param freeMint A boolean flag indicating whether the minting option is free or not.\n     * @return The calculated unlock price in wei.\n     */\n    function calculateUnlockPrice(\n        uint8 tier,\n        bool freeMint\n    ) external view returns (uint256);\n\n    /**\n     * @notice Calculates the lockup period for a specific tier.\n     * @param tier The tier to calculate the lockup period for.\n     * @return The lockup period in seconds for the specified tier.\n     */\n    function calculateLockupDate(uint8 tier) external view returns (uint256);\n\n    /**\n     * @notice Calculates the total quantity of NFTs in a given list of Cart structs.\n     * @param carts An array of Cart struct representing the tiers and quantities.\n     * @return Total quantity of NFTs in the given list of carts.\n     */\n\n    function calculateTotalQuantity(\n        uint256[] memory carts\n    ) external view returns (uint256);\n\n    /**\n     * @notice Updates the prices for all tiers in the MinterUtilities contract.\n     * @param tierPrices A bytes array representing the new prices for all tiers (in wei).\n     */\n    function updateAllTierPrices(bytes calldata tierPrices) external;\n\n    /**\n     * @notice Sets new default lockup periods for all tiers.\n     * @param lockupInfo A bytes array representing the new lockup periods for all tiers (in seconds).\n     */\n    function setNewDefaultLockups(bytes calldata lockupInfo) external;\n\n    /**\n     * @notice Retrieves tier information for a specific tier ID.\n     * @param tierId The ID of the tier to get information for.\n     * @return TierInfo tier information struct containing lockup duration and unlock price in wei.\n     */\n    function getTierInfo(uint8 tierId) external view returns (TierInfo memory);\n\n    /**\n     * @notice Retrieves all tier information.\n     * @return bytes data of tier information struct containing lockup duration and unlock price in wei.\n     */\n    function getTierInfo() external view returns (bytes memory);\n}\n"
    },
    "src/minter/CollectionHolderMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ICollectionHolderMint} from \"../interfaces/ICollectionHolderMint.sol\";\nimport {ICre8ors} from \"../interfaces/ICre8ors.sol\";\nimport {IERC721A} from \"lib/ERC721A/contracts/interfaces/IERC721A.sol\";\nimport {IERC721Drop} from \"../interfaces/IERC721Drop.sol\";\nimport {IFriendsAndFamilyMinter} from \"../interfaces/IFriendsAndFamilyMinter.sol\";\nimport {IMinterUtilities} from \"../interfaces/IMinterUtilities.sol\";\nimport {IERC721ACH} from \"ERC721H/interfaces/IERC721ACH.sol\";\n\ncontract CollectionHolderMint is ICollectionHolderMint {\n    ///@notice Mapping to track whether a specific uint256 value (token ID) has been claimed or not.\n    mapping(uint256 => bool) public freeMintClaimed;\n\n    ///@notice The address of the collection contract that mints and manages the tokens.\n    address public cre8orsNFTContractAddress;\n\n    ///@notice The address of the passport contract.\n    address public passportContractAddress;\n\n    ///@notice The address of the minter utility contract that contains shared utility info.\n    address public minterUtilityContractAddress;\n\n    ///@notice The address of the friends and family minter contract.\n    address public friendsAndFamilyMinterContractAddress;\n\n    ///@notice mapping of address to quantity of free mints claimed.\n    mapping(address => uint256) public totalClaimed;\n\n    /**\n     * @notice Constructs a new CollectionHolderMint contract.\n     * @param _cre8orsNFTContractAddress The address of the collection contract that mints and manages the tokens.\n     * @param _passportContractAddress The address of the passport contract.\n     * @param _minterUtility The address of the minter utility contract that contains shared utility info.\n     * @param _friendsAndFamilyMinterContractAddress The address of the friends and family minter contract.\n     */\n    constructor(\n        address _cre8orsNFTContractAddress,\n        address _passportContractAddress,\n        address _minterUtility,\n        address _friendsAndFamilyMinterContractAddress\n    ) {\n        cre8orsNFTContractAddress = _cre8orsNFTContractAddress;\n        passportContractAddress = _passportContractAddress;\n        minterUtilityContractAddress = _minterUtility;\n        friendsAndFamilyMinterContractAddress = _friendsAndFamilyMinterContractAddress;\n    }\n\n    /**\n     * @dev Mint function to create a new token, assign it to the specified recipient, and trigger additional actions.\n     *\n     * This function creates a new token with the given `tokenId` and assigns it to the `recipient` address.\n     * It requires the `tokenId` to be eligible for a free mint, and the caller must be the owner of the specified `tokenId`\n     * to successfully execute the minting process.\n     *\n     * @param passportTokenIDs The IDs of passports.\n     * @param recipient The address to whom the newly minted token will be assigned.\n     * @return pfpTokenId The ID of the corresponding PFP token that was minted for the `recipient`.\n     *\n     */\n    function mint(\n        uint256[] calldata passportTokenIDs,\n        address recipient\n    )\n        external\n        tokensPresentInList(passportTokenIDs)\n        noDuplicates(passportTokenIDs)\n        onlyTokenOwner(passportTokenIDs, recipient)\n        hasFreeMint(passportTokenIDs)\n        returns (uint256)\n    {\n        _friendsAndFamilyMint(recipient);\n\n        return _passportMint(passportTokenIDs, recipient);\n    }\n\n    /**\n     * @notice Toggle the free mint claim status of a token.\n     * @param tokenId Passport token ID to toggle free mint claim status.\n     */\n    function toggleHasClaimedFreeMint(uint256 tokenId) external onlyAdmin {\n        freeMintClaimed[tokenId] = !freeMintClaimed[tokenId];\n    }\n\n    ////////////////////////////////////////\n    ////////////// MODIFIERS //////////////\n    ///////////////////////////////////////\n\n    /**\n     * @dev Modifier to ensure the caller owns the specified tokens or has appropriate approval.\n     * @param passportTokenIDs An array of token IDs.\n     * @param recipient The recipient address.\n     */\n    modifier onlyTokenOwner(\n        uint256[] calldata passportTokenIDs,\n        address recipient\n    ) {\n        for (uint256 i = 0; i < passportTokenIDs.length; i++) {\n            if (\n                IERC721A(passportContractAddress).ownerOf(\n                    passportTokenIDs[i]\n                ) != recipient\n            ) {\n                revert IERC721A.ApprovalCallerNotOwnerNorApproved();\n            }\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the caller is an admin.\n     */\n    modifier onlyAdmin() {\n        if (!ICre8ors(cre8orsNFTContractAddress).isAdmin(msg.sender)) {\n            revert IERC721Drop.Access_OnlyAdmin();\n        }\n\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the specified token IDs are not duplicates.\n     */\n    modifier noDuplicates(uint[] calldata _passportpassportTokenIDs) {\n        if (_hasDuplicates(_passportpassportTokenIDs)) {\n            revert DuplicatesFound();\n        }\n        _;\n    }\n    /**\n     * @dev Modifier to ensure the specified token IDs are eligible for a free mint.\n     * @param passportTokenIDs An array of token IDs.\n     */\n    modifier hasFreeMint(uint256[] calldata passportTokenIDs) {\n        for (uint256 i = 0; i < passportTokenIDs.length; i++) {\n            if (freeMintClaimed[passportTokenIDs[i]]) {\n                revert AlreadyClaimedFreeMint();\n            }\n        }\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the specified token ID list is not empty.\n     * @param passportTokenIDs An array of token IDs.\n     */\n    modifier tokensPresentInList(uint256[] calldata passportTokenIDs) {\n        if (passportTokenIDs.length == 0) {\n            revert NoTokensProvided();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////\n    ////////// SETTER FUNCTIONS //////////\n    /////////////////////////////////////\n    /**\n     * @notice Set New Minter Utility Contract Address\n     * @notice Allows the admin to set a new address for the Minter Utility Contract.\n     * @param _newMinterUtilityContractAddress The address of the new Minter Utility Contract.\n     * @dev Only the admin can call this function.\n     */\n    function setNewMinterUtilityContractAddress(\n        address _newMinterUtilityContractAddress\n    ) external onlyAdmin {\n        minterUtilityContractAddress = _newMinterUtilityContractAddress;\n    }\n\n    /**\n     * @notice Set the address of the friends and family minter contract.\n     * @param _newfriendsAndFamilyMinterContractAddressAddress The address of the new friends and family minter contract.\n     */\n    function setFriendsAndFamilyMinterContractAddress(\n        address _newfriendsAndFamilyMinterContractAddressAddress\n    ) external onlyAdmin {\n        friendsAndFamilyMinterContractAddress = _newfriendsAndFamilyMinterContractAddressAddress;\n    }\n\n    /**\n     * @notice Updates the passport contract address.\n     * @dev This function can only be called by the admin.\n     * @param _newPassportContractAddress The new passport contract address.\n     */\n    function setNewPassportContractAddress(\n        address _newPassportContractAddress\n    ) external onlyAdmin {\n        passportContractAddress = _newPassportContractAddress;\n    }\n\n    /**\n     * @notice Updates the Cre8ors NFT contract address.\n     * @dev This function can only be called by the admin.\n     * @param _newCre8orsNFTContractAddress The new Cre8ors NFT contract address.\n     */\n    function setNewCre8orsNFTContractAddress(\n        address _newCre8orsNFTContractAddress\n    ) external onlyAdmin {\n        cre8orsNFTContractAddress = _newCre8orsNFTContractAddress;\n    }\n\n    ////////////////////////////////////////\n    ////////// INTERNALFUNCTIONS //////////\n    ///////////////////////////////////////\n\n    function _setpassportTokenIDsToClaimed(\n        uint256[] calldata passportTokenIDs\n    ) internal {\n        for (uint256 i = 0; i < passportTokenIDs.length; i++) {\n            freeMintClaimed[passportTokenIDs[i]] = true;\n        }\n    }\n\n    function _lockAndStakeTokens(uint256[] memory _mintedPFPTokenIDs) internal {\n        IMinterUtilities minterUtility = IMinterUtilities(\n            minterUtilityContractAddress\n        );\n        uint256 lockupDate = block.timestamp + 8 weeks;\n        uint256 unlockPrice = minterUtility.getTierInfo(3).price;\n        bytes memory data = abi.encode(lockupDate, unlockPrice);\n        ICre8ors(\n            IERC721ACH(cre8orsNFTContractAddress).getHook(\n                IERC721ACH.HookType.BeforeTokenTransfers\n            )\n        ).cre8ing().inializeStakingAndLockup(\n                cre8orsNFTContractAddress,\n                _mintedPFPTokenIDs,\n                data\n            );\n    }\n\n    function _passportMint(\n        uint256[] calldata _passportTokenIDs,\n        address recipient\n    ) internal returns (uint256) {\n        uint256 pfpTokenId = ICre8ors(cre8orsNFTContractAddress).adminMint(\n            recipient,\n            _passportTokenIDs.length\n        );\n        uint256[] memory _pfpTokenIds = new uint256[](_passportTokenIDs.length);\n        uint256 startingTokenId = pfpTokenId - _passportTokenIDs.length + 1;\n        for (uint256 i = 0; i < _passportTokenIDs.length; ) {\n            _pfpTokenIds[i] = startingTokenId + i;\n            unchecked {\n                i++;\n            }\n        }\n        totalClaimed[recipient] += _passportTokenIDs.length;\n        _lockAndStakeTokens(_pfpTokenIds);\n        _setpassportTokenIDsToClaimed(_passportTokenIDs);\n        return pfpTokenId;\n    }\n\n    function _friendsAndFamilyMint(address buyer) internal {\n        IFriendsAndFamilyMinter ffMinter = IFriendsAndFamilyMinter(\n            friendsAndFamilyMinterContractAddress\n        );\n\n        if (ffMinter.hasDiscount(buyer)) {\n            ffMinter.mint(buyer);\n        }\n    }\n\n    function _hasDuplicates(\n        uint[] calldata values\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < values.length; i++) {\n            for (uint j = i + 1; j < values.length; j++) {\n                if (values[i] == values[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "src/subscription/interfaces/ISubscription.sol": {
      "content": "/// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title ISubscription\n/// @dev Interface for managing subscriptions to NFTs.\ninterface ISubscription {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The subscription associated with the provided token ID is invalid or has expired.\n    error InvalidSubscription();\n\n    /// @notice Attempting to set a subscription contract address with a zero address value.\n    error SubscriptionCannotBeZeroAddress();\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Emitted when the renewability status of subscriptions is updated.\n    event RenewableUpdate(bool renewable);\n\n    /// @dev Emitted when the minimum duration for subscription renewal is updated.\n    event MinRenewalDurationUpdate(uint64 duration);\n\n    /// @dev Emitted when the maximum duration for subscription renewal is updated.\n    event MaxRenewalDurationUpdate(uint64 duration);\n\n    /*//////////////////////////////////////////////////////////////\n                           CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks the subscription for the given `tokenId`.\n    /// Throws if `tokenId` subscription has expired.\n    /// @param tokenId The unique identifier of the NFT token.\n    function checkSubscription(uint256 tokenId) external view;\n\n    /// @notice Returns whether the subscription for the given `tokenId` is valid.\n    /// @param tokenId The unique identifier of the NFT token.\n    /// @return A boolean indicating if the subscription is valid.\n    function isSubscriptionValid(uint256 tokenId) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                         NON-CONSTANT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /*//////////   updateSubscriptionForFree variants   //////////*/\n\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration` for free.\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\n    /// @param target The address of the contract implementing the access control\n    /// @param duration The duration (in seconds) to extend the subscription for.\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\n    function updateSubscriptionForFree(address target, uint64 duration, uint256 tokenId) external;\n\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration` for free.\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\n    /// @param target The address of the contract implementing the access control\n    /// @param duration The duration (in seconds) to extend the subscription for.\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\n    function updateSubscriptionForFree(address target, uint64 duration, uint256[] calldata tokenIds) external;\n\n    /*//////////////   updateSubscription variants   /////////////*/\n\n    /// @notice Extends the subscription for the given `tokenId` with a specified `duration`, using native currency as\n    /// payment.\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\n    /// @param target The address of the contract implementing the access control\n    /// @param duration The duration (in seconds) to extend the subscription for.\n    /// @param tokenId The unique identifier of the NFT token to be subscribed.\n    function updateSubscription(address target, uint64 duration, uint256 tokenId) external payable;\n\n    /// @notice Extends the subscription for the given `tokenIds` with a specified `duration`, using native currency as\n    /// payment.\n    /// @dev This function is meant to be called by the minter when minting the NFT to subscribe.\n    /// @param target The address of the contract implementing the access control\n    /// @param duration The duration (in seconds) to extend the subscription for.\n    /// @param tokenIds An array of unique identifiers of the NFT tokens to update the subscriptions for.\n    function updateSubscription(address target, uint64 duration, uint256[] calldata tokenIds) external payable;\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ERC6551/=lib/ERC6551/src/",
      "ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",
      "ERC721A/=lib/ERC721A/contracts/",
      "ERC721C/=lib/creator-token-contracts/contracts/",
      "ERC721H/=lib/ERC721H/src/",
      "account-abstraction/=lib/account-abstraction/contracts/",
      "creator-token-contracts/=lib/creator-token-contracts/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "erc6551/=lib/tokenbound/lib/reference/src/",
      "erc721a/=lib/ERC721A/",
      "forge-std/=lib/forge-std/src/",
      "hardhat/=lib/creator-token-contracts/node_modules/hardhat/",
      "murky/=lib/creator-token-contracts/lib/murky/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",
      "reference/=lib/tokenbound/lib/reference/src/",
      "sstore2/=lib/ERC6551/lib/sstore2/contracts/",
      "tokenbound/=lib/tokenbound/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}