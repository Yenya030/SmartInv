{{
  "language": "Solidity",
  "sources": {
    "contracts/KillaCubsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\nimport \"./KillaCubs/KillaCubsStaking.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract KillaCubsV2 is KillaCubsERC721, IURIManager {\n    using Strings for uint256;\n    using Strings for uint16;\n\n    constructor(\n        address bitsAddress,\n        address gearAddress,\n        address bearsAddress,\n        address passesAddress,\n        address kiltonAddress,\n        address labsAddress,\n        address superOwner\n    )\n        KillaCubsERC721(\n            bitsAddress,\n            gearAddress,\n            bearsAddress,\n            passesAddress,\n            kiltonAddress,\n            labsAddress,\n            superOwner\n        )\n    {\n        uriManager = IURIManager(this);\n    }\n\n    function toggleClaims(bool enabled) external onlyOwner {\n        claimsStarted = enabled;\n    }\n\n    function tokenURI(uint256 id) external view returns (string memory) {\n        Token memory token = resolveToken(id);\n        return uriManager.getTokenURI(id, token);\n    }\n\n    function getTokenURI(\n        uint256 id,\n        Token memory token\n    ) public view returns (string memory) {\n        bool staked = token.stakeTimestamp > 0;\n        uint256 phase = calculateIncubationPhase(\n            token.incubationPhase,\n            token.stakeTimestamp,\n            token.generation\n        );\n        uint256 gen = token.generation;\n        if (laterGenerations[id] != 0) gen = laterGenerations[id];\n\n        if (staked) {\n            return\n                string(\n                    abi.encodePacked(\n                        baseURI,\n                        gen == 0 ? \"initial-\" : \"remix-\",\n                        id.toString(),\n                        \"-\",\n                        phase.toString(),\n                        \"-\",\n                        token.bit.toString()\n                    )\n                );\n        }\n\n        string storage base = gen > finalizedGeneration || gen == 0\n            ? baseURI\n            : baseURIFinalized;\n\n        return\n            string(\n                abi.encodePacked(\n                    base,\n                    gen == 0 ? \"cubryo-\" : \"cub-\",\n                    id.toString(),\n                    \"-\",\n                    phase.toString()\n                )\n            );\n    }\n\n    function configureRoyalties(\n        address royaltyReceiver,\n        uint96 royaltyAmount\n    ) external onlyOwner {\n        _setDefaultRoyalty(royaltyReceiver, royaltyAmount);\n    }\n\n    function finalizeGeneration(\n        uint256 gen,\n        string calldata uri\n    ) external onlyOwner {\n        finalizedGeneration = gen;\n        baseURIFinalized = uri;\n    }\n\n    function setURIManager(address addr) external onlyOwner {\n        uriManager = IURIManager(addr);\n    }\n\n    function setBaseUri(string calldata uri) external onlyOwner {\n        baseURI = uri;\n    }\n\n    function copyTokensClaimed(address, uint256, uint256) external onlyOwner {\n        (bool success, ) = _delegatecall(airdropper, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function copyTokensBatched(address, uint256, uint256) external onlyOwner {\n        (bool success, ) = _delegatecall(airdropper, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function stake(uint256[] calldata) external {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function unstake(uint256[] calldata, bool) external {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function addBits(uint256[] calldata, uint16[] calldata) external {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function removeBits(uint256[] calldata) external {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function extractGear(uint256[] calldata) external {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function fastForward(\n        address,\n        uint256[] calldata,\n        uint256\n    ) external onlyAuthority {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function configureStakingWindows(uint256, uint256) external onlyOwner {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function setIncubator(address) external onlyOwner {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function startNexGeneration() external onlyOwner {\n        (bool success, ) = _delegatecall(staker, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function claim(uint256[] calldata, bool) public {\n        (bool success, ) = _delegatecall(claimer, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    function redeem(uint16, bool) external {\n        (bool success, ) = _delegatecall(claimer, msg.data);\n        require(success, \"delegatecall failed\");\n    }\n\n    fallback() external payable {\n        address extension = extensions[msg.sig];\n        require(extension != address(0));\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                extension,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/KillaCubs/KillaCubsStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\nimport \"./KillaCubsERC721.sol\";\n\nabstract contract KillaCubsStaking is KillaCubsERC721 {\n    \n\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/KillaCubs/KillaCubsERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"operator-filter-registry/src/DefaultOperatorFilterer.sol\";\nimport \"./KillaCubsStorage.sol\";\n\nabstract contract KillaCubsERC721 is KillaCubsStorage {\n    constructor(\n        address bitsAddress,\n        address gearAddress,\n        address bearsAddress,\n        address passesAddress,\n        address kiltonAddress,\n        address labsAddress,\n        address superOwner\n    )\n        KillaCubsStorage(\n            bitsAddress,\n            gearAddress,\n            bearsAddress,\n            passesAddress,\n            kiltonAddress,\n            labsAddress,\n            superOwner\n        )\n    {\n        name = \"KillaCubs\";\n        symbol = \"KillaCubs\";\n        _setDefaultRoyalty(msg.sender, 500);\n    }\n\n    function _mint(address to, uint256 n, bool staked) internal {\n        uint256 tokenId = 3334 + counters.batched;\n        uint256 end = tokenId + n - 1;\n        if (end > 8888) revert NotAllowed();\n\n        Token storage token = tokens[tokenId];\n        token.owner = to;\n\n        counters.batched += uint16(n);\n        wallets[to].batchedMints += uint16(n);\n\n        if (staked) {\n            incubator.add(to, tokenId, n);\n            token.stakeTimestamp = uint32(block.timestamp);\n            counters.stakes += uint16(n);\n            wallets[to].stakes += uint16(n);\n\n            while (tokenId <= end) {\n                emit Transfer(address(0), to, tokenId);\n                emit Transfer(to, address(this), tokenId);\n                tokenId++;\n            }\n        } else {\n            wallets[to].balance += uint16(n);\n            while (tokenId <= end) {\n                emit Transfer(address(0), to, tokenId);\n                tokenId++;\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        uint256[] calldata tokenIds,\n        bool staked\n    ) internal {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 id = tokenIds[i];\n\n            Token storage token = tokens[id];\n\n            if (id == 0) revert NotAllowed();\n            if (token.owner != address(0)) revert NotAllowed();\n            if (token.linkedPrev != 0) revert NotAllowed();\n\n            token.owner = to;\n            emit Transfer(address(0), to, id);\n\n            if (staked) {\n                emit Transfer(to, address(this), id);\n                token.stakeTimestamp = uint32(block.timestamp);\n            }\n\n            if (i == 0) {\n                token.owner = to;\n            } else {\n                token.linkedPrev = uint16(tokenIds[i - 1]);\n                tokens[tokenIds[i - 1]].linkedNext = uint16(id);\n            }\n        }\n\n        counters.linked += uint16(tokenIds.length);\n        if (staked) {\n            counters.stakes += uint16(tokenIds.length);\n            wallets[to].stakes += uint16(tokenIds.length);\n            incubator.add(to, tokenIds);\n        } else {\n            wallets[to].balance += uint16(tokenIds.length);\n        }\n        wallets[to].linkedMints += uint16(tokenIds.length);\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return counters.linked + counters.batched;\n    }\n\n    function balanceOf(\n        address owner\n    ) external view virtual returns (uint256 balance) {\n        if (owner == address(this)) return counters.stakes;\n        return wallets[owner].balance;\n    }\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        Token memory token = resolveToken(id);\n        if (token.stakeTimestamp != 0) return address(this);\n        return token.owner;\n    }\n\n    function rightfulOwnerOf(\n        uint256 tokenId\n    ) public view virtual returns (address) {\n        return resolveToken(tokenId).owner;\n    }\n\n    function resolveToken(uint256 id) public view returns (Token memory) {\n        Token memory token = tokens[id];\n        if (token.owner == address(0)) {\n            Token memory temp = token;\n            if (token.linkedPrev != 0) {\n                do token = tokens[token.linkedPrev]; while (\n                    token.owner == address(0)\n                );\n            } else if (id > 3333 && id <= 3333 + counters.batched) {\n                do token = tokens[--id]; while (token.owner == address(0));\n            } else {\n                revert NonExistentToken();\n            }\n\n            token.bit = temp.bit;\n            token.linkedNext = temp.linkedNext;\n            token.linkedPrev = temp.linkedPrev;\n        }\n        return token;\n    }\n\n    function resolveTokens(\n        uint256[] calldata ids\n    ) public view returns (Token[] memory) {\n        Token[] memory ret = new Token[](ids.length);\n        bool skip = false;\n        Token memory token;\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n\n            if (skip) skip = false;\n            else token = resolveToken(id);\n\n            ret[i] = token;\n\n            uint256 nextId;\n            if (token.linkedNext != 0) {\n                nextId = token.linkedNext;\n            } else if (id > 3333 && id < 3333 + counters.batched) {\n                nextId = id + 1;\n            } else {\n                continue;\n            }\n\n            if (tokens[nextId].owner != address(0)) continue;\n            if (i + 1 < ids.length && ids[i + 1] == nextId) {\n                skip = true;\n                token.bit = tokens[nextId].bit;\n                token.linkedNext = tokens[nextId].linkedNext;\n                token.linkedPrev = tokens[nextId].linkedPrev;\n                continue;\n            }\n        }\n        return ret;\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n        if (to.code.length != 0)\n            if (!_checkOnERC721Received(from, to, id, data))\n                revert TransferToNonERC721ReceiverImplementer();\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n        if (to.code.length != 0)\n            if (!_checkOnERC721Received(from, to, id, \"\"))\n                revert TransferToNonERC721ReceiverImplementer();\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual onlyAllowedOperator(from) {\n        if (to == from) revert NotAllowed();\n        if (to == address(0)) revert NotAllowed();\n\n        Token memory token = resolveToken(id);\n\n        if (token.stakeTimestamp > 0 || token.owner != from)\n            revert NotAllowed();\n\n        if (msg.sender != token.owner) {\n            if (\n                !operatorApprovals[token.owner][msg.sender] &&\n                tokenApprovals[id] != msg.sender\n            ) revert NotAllowed();\n        }\n\n        if (tokenApprovals[id] != address(0)) {\n            delete tokenApprovals[id];\n            emit Approval(from, address(0), id);\n        }\n\n        emit Transfer(token.owner, to, id);\n        _bakeNextToken(token, id);\n\n        token.owner = to;\n\n        wallets[from].balance--;\n        wallets[to].balance++;\n        tokens[id] = token;\n    }\n\n    function _bakeNextToken(Token memory current, uint256 id) internal {\n        uint256 nextId;\n        if (current.linkedNext != 0) {\n            nextId = current.linkedNext;\n        } else if (id > 3333) {\n            nextId = id + 1;\n            if (nextId > 3333 + counters.batched) return;\n        } else {\n            return;\n        }\n\n        Token memory temp = tokens[nextId];\n        if (temp.owner != address(0)) return;\n\n        tokens[nextId] = current;\n\n        tokens[nextId].linkedNext = temp.linkedNext;\n        tokens[nextId].linkedPrev = temp.linkedPrev;\n        tokens[nextId].bit = temp.bit;\n    }\n\n    function approve(\n        address to,\n        uint256 id\n    ) public virtual onlyAllowedOperatorApproval(to) {\n        address owner = ownerOf(id);\n        if (msg.sender != owner) {\n            if (!isApprovedForAll(owner, msg.sender)) {\n                revert NotAllowed();\n            }\n        }\n\n        tokenApprovals[id] = to;\n        emit Approval(msg.sender, to, id);\n    }\n\n    function setApprovalForAll(\n        address operator,\n        bool approved\n    ) public virtual onlyAllowedOperatorApproval(operator) {\n        operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function getApproved(\n        uint256 id\n    ) external view virtual returns (address operator) {\n        return tokenApprovals[id];\n    }\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) public view virtual returns (bool) {\n        return operatorApprovals[owner][operator];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165\n            interfaceId == 0x80ac58cd || // ERC721\n            interfaceId == 0x5b5e139f || // ERC721Metadata;\n            interfaceId == 0x4e2312e0 || // ERC1155Receiver\n            interfaceId == 0x2a55205a; // ERC2981\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) private returns (bool) {\n        try\n            IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)\n        returns (bytes4 retval) {\n            return retval == IERC721Receiver.onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return\n            bytes4(\n                keccak256(\n                    \"onERC1155Received(address,address,uint256,uint256,bytes)\"\n                )\n            );\n    }\n\n    function calculateIncubationPhase(\n        uint256 phase,\n        uint256 ts,\n        uint256 gen\n    ) public view returns (uint256) {\n        if (ts != 0) {\n            phase += (block.timestamp - ts) / 1 weeks;\n        }\n        uint256 max = gen == 0\n            ? initialIncubationLength\n            : remixIncubationLength;\n        if (phase > max) return max;\n        return phase;\n    }\n\n    function getIncubationPhase(uint256 id) public view returns (uint256) {\n        Token memory token = resolveToken(id);\n        return\n            calculateIncubationPhase(\n                token.incubationPhase,\n                token.stakeTimestamp,\n                token.generation\n            );\n    }\n\n    function getGeneration(uint256 id) public view returns (uint256) {\n        if (laterGenerations[id] != 0) return laterGenerations[id];\n        Token memory token = resolveToken(id);\n        return token.generation;\n    }\n}\n"
    },
    "contracts/KillaCubs/KillaCubsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/common/ERC2981.sol\";\nimport \"operator-filter-registry/src/DefaultOperatorFilterer.sol\";\nimport \"../SuperOwnable.sol\";\n\ninterface IKillaPasses {\n    function burn(uint256 typeId, address owner, uint256 n) external;\n}\n\ninterface IURIManager {\n    function getTokenURI(\n        uint256 id,\n        Token memory token\n    ) external view returns (string memory);\n}\n\ninterface IKILLABITS {\n    function detachUpgrade(uint256 token) external;\n\n    function tokenUpgrade(uint256 token) external view returns (uint64);\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\ninterface IKILLAGEAR {\n    function detokenize(\n        address addr,\n        uint256[] calldata types,\n        uint256[] calldata amounts\n    ) external;\n}\n\nstruct Token {\n    address owner;\n    uint16 linkedNext;\n    uint16 linkedPrev;\n    uint32 stakeTimestamp;\n    uint8 generation;\n    uint8 incubationPhase;\n    uint16 bit;\n}\n\nstruct Wallet {\n    uint16 balance;\n    uint16 stakes;\n    uint16 linkedMints;\n    uint16 batchedMints;\n    uint16 allowlistMints;\n    uint16 privateMints;\n    uint16 holderMints;\n    uint16 redeems;\n}\n\nstruct MintCounters {\n    uint16 linked;\n    uint16 batched;\n    uint16 redeems;\n    uint16 stakes;\n}\n\ninterface IIncubator {\n    function add(address owner, uint256[] calldata tokenIds) external;\n\n    function add(address owner, uint256 start, uint256 count) external;\n\n    function remove(address owner, uint256[] calldata tokenIds) external;\n\n    function remove(address owner, uint256 start, uint256 count) external;\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC721 {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n}\n\nabstract contract KillaCubsStorage is\n    DefaultOperatorFilterer,\n    SuperOwnable,\n    ERC2981\n{\n    string public name;\n    string public symbol;\n\n    uint256 public activeGeneration = 1;\n    uint256 public initialIncubationLength = 8;\n    uint256 public remixIncubationLength = 4;\n\n    IIncubator public incubator;\n\n    MintCounters public counters;\n\n    mapping(address => Wallet) public wallets;\n    mapping(uint256 => Token) public tokens;\n    mapping(uint256 => address) internal tokenApprovals;\n    mapping(address => mapping(address => bool)) internal operatorApprovals;\n\n    IKILLABITS public bitsContract;\n    IKILLAGEAR public gearContract;\n\n    IERC721 public bears;\n    IKillaPasses public passes;\n    IERC721 public kilton;\n    IERC721 public labs;\n    bool public claimsStarted;\n\n    mapping(uint256 => bool) public bitsUsed;\n    mapping(uint256 => uint256) public laterGenerations;\n\n    address public airdropper;\n    address public staker;\n    address public claimer;\n\n    IURIManager public uriManager;\n\n    string public baseURI;\n    string public baseURIFinalized;\n    uint256 public finalizedGeneration;\n\n    mapping(bytes4 => address) extensions;\n    mapping(uint256 => address) externalStorage;\n\n    error TransferToNonERC721ReceiverImplementer();\n    error NonExistentToken();\n    error NotAllowed();\n    error Overflow();\n    error ClaimNotStarted();\n\n    event BitsAdded(uint256[] indexed tokens, uint16[] indexed bits);\n    event BitRemoved(uint256 indexed token, uint16 indexed bit);\n    event FastForwarded(uint256[] indexed tokens, uint256 indexed numberOfDays);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    constructor(\n        address bitsAddress,\n        address gearAddress,\n        address bearsAddress,\n        address passesAddress,\n        address kiltonAddress,\n        address labsAddress,\n        address superOwner\n    ) SuperOwnable(superOwner) {\n        bitsContract = IKILLABITS(bitsAddress);\n        gearContract = IKILLAGEAR(gearAddress);\n        bears = IERC721(bearsAddress);\n        passes = IKillaPasses(passesAddress);\n        kilton = IERC721(kiltonAddress);\n        labs = IERC721(labsAddress);\n    }\n\n    function setAirdropper(address a) external onlyOwner {\n        airdropper = a;\n    }\n\n    function setStaker(address a) external onlyOwner {\n        staker = a;\n    }\n\n    function setClaimer(address a) external onlyOwner {\n        claimer = a;\n    }\n\n    function setExtension(bytes4 id, address a) external onlyOwner {\n        extensions[id] = a;\n    }\n\n    function setExternalStorage(uint256 id, address a) external onlyOwner {\n        externalStorage[id] = a;\n    }\n\n    function _delegatecall(\n        address target,\n        bytes memory data\n    ) internal returns (bool, bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        if (!success) {\n            if (returndata.length == 0) revert();\n            assembly {\n                revert(add(32, returndata), mload(returndata))\n            }\n        }\n        return (success, returndata);\n    }\n}\n"
    },
    "operator-filter-registry/src/DefaultOperatorFilterer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {OperatorFilterer} from \"./OperatorFilterer.sol\";\n\n/**\n * @title  DefaultOperatorFilterer\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\n */\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\n    address constant DEFAULT_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\n\n    constructor() OperatorFilterer(DEFAULT_SUBSCRIPTION, true) {}\n}\n"
    },
    "contracts/SuperOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nabstract contract SuperOwnable {\n    address public owner;\n    address public superOwner;\n\n    mapping(address => bool) authorities;\n\n    error Denied();\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor(address superOwner_) {\n        _transferOwnership(msg.sender);\n        superOwner = superOwner_;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner && msg.sender != superOwner) revert Denied();\n        _;\n    }\n\n    modifier onlySuperOwner() {\n        if (msg.sender != superOwner) revert Denied();\n        _;\n    }\n\n    modifier onlyAuthority() {\n        if (!authorities[msg.sender] && msg.sender != owner) revert Denied();\n        _;\n    }\n\n    function transferOwnership(address addr) public virtual onlyOwner {\n        _transferOwnership(addr);\n    }\n\n    function _transferOwnership(address addr) internal virtual {\n        address oldOwner = owner;\n        owner = addr;\n        emit OwnershipTransferred(oldOwner, addr);\n    }\n\n    function setSuperOwner(address addr) public onlySuperOwner {\n        if (addr == address(0)) revert Denied();\n        superOwner = addr;\n    }\n\n    function toggleAuthority(address addr, bool enabled) public onlyOwner {\n        authorities[addr] = enabled;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/common/ERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/common/ERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IERC2981.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\n *\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\n *\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\n * fee is specified in basis points by default.\n *\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\n *\n * _Available since v4.5._\n */\nabstract contract ERC2981 is IERC2981, ERC165 {\n    struct RoyaltyInfo {\n        address receiver;\n        uint96 royaltyFraction;\n    }\n\n    RoyaltyInfo private _defaultRoyaltyInfo;\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC2981\n     */\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[_tokenId];\n\n        if (royalty.receiver == address(0)) {\n            royalty = _defaultRoyaltyInfo;\n        }\n\n        uint256 royaltyAmount = (_salePrice * royalty.royaltyFraction) / _feeDenominator();\n\n        return (royalty.receiver, royaltyAmount);\n    }\n\n    /**\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\n     * override.\n     */\n    function _feeDenominator() internal pure virtual returns (uint96) {\n        return 10000;\n    }\n\n    /**\n     * @dev Sets the royalty information that all ids in this contract will default to.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: invalid receiver\");\n\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Removes default royalty information.\n     */\n    function _deleteDefaultRoyalty() internal virtual {\n        delete _defaultRoyaltyInfo;\n    }\n\n    /**\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\n     *\n     * Requirements:\n     *\n     * - `receiver` cannot be the zero address.\n     * - `feeNumerator` cannot be greater than the fee denominator.\n     */\n    function _setTokenRoyalty(\n        uint256 tokenId,\n        address receiver,\n        uint96 feeNumerator\n    ) internal virtual {\n        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");\n        require(receiver != address(0), \"ERC2981: Invalid parameters\");\n\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\n    }\n\n    /**\n     * @dev Resets royalty information for the token id back to the global default.\n     */\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\n        delete _tokenRoyaltyInfo[tokenId];\n    }\n}\n"
    },
    "operator-filter-registry/src/OperatorFilterer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IOperatorFilterRegistry} from \"./IOperatorFilterRegistry.sol\";\n\n/**\n * @title  OperatorFilterer\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\n *         registrant's entries in the OperatorFilterRegistry.\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\n *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.\n *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.\n */\nabstract contract OperatorFilterer {\n    error OperatorNotAllowed(address operator);\n\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\n        IOperatorFilterRegistry(0x000000000000AAeB6D7670E522A718067333cd4E);\n\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\n        // order for the modifier to filter addresses.\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\n            if (subscribe) {\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\n            } else {\n                if (subscriptionOrRegistrantToCopy != address(0)) {\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\n                } else {\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\n                }\n            }\n        }\n    }\n\n    modifier onlyAllowedOperator(address from) virtual {\n        // Allow spending tokens from addresses with balance\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\n        // from an EOA.\n        if (from != msg.sender) {\n            _checkFilterOperator(msg.sender);\n        }\n        _;\n    }\n\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }\n\n    function _checkFilterOperator(address operator) internal view virtual {\n        // Check registry code length to facilitate testing in environments without a deployed registry.\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\n                revert OperatorNotAllowed(operator);\n            }\n        }\n    }\n}\n"
    },
    "operator-filter-registry/src/IOperatorFilterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IOperatorFilterRegistry {\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\n    function register(address registrant) external;\n    function registerAndSubscribe(address registrant, address subscription) external;\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\n    function unregister(address addr) external;\n    function updateOperator(address registrant, address operator, bool filtered) external;\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\n    function subscribe(address registrant, address registrantToSubscribe) external;\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\n    function subscriptionOf(address addr) external returns (address registrant);\n    function subscribers(address registrant) external returns (address[] memory);\n    function subscriberAt(address registrant, uint256 index) external returns (address);\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\n    function filteredOperators(address addr) external returns (address[] memory);\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\n    function isRegistered(address addr) external returns (bool);\n    function codeHashOf(address addr) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}