{"ballot.sol":{"content":"pragma solidity ^0.4.0;\r\ncontract Ballot {\r\n\r\n    struct Voter {\r\n        uint weight;\r\n        bool voted;\r\n        uint8 vote;\r\n        address delegate;\r\n    }\r\n    struct Proposal {\r\n        uint voteCount;\r\n    }\r\n\r\n    address chairperson;\r\n    mapping(address =\u003e Voter) voters;\r\n    Proposal[] proposals;\r\n\r\n    /// Create a new ballot with $(_numProposals) different proposals.\r\n    function Ballot(uint8 _numProposals) public {\r\n        chairperson = msg.sender;\r\n        voters[chairperson].weight = 1;\r\n        proposals.length = _numProposals;\r\n    }\r\n\r\n    /// Give $(toVoter) the right to vote on this ballot.\r\n    /// May only be called by $(chairperson).\r\n    function giveRightToVote(address toVoter) public {\r\n        if (msg.sender != chairperson || voters[toVoter].voted) return;\r\n        voters[toVoter].weight = 1;\r\n    }\r\n\r\n    /// Delegate your vote to the voter $(to).\r\n    function delegate(address to) public {\r\n        Voter storage sender = voters[msg.sender]; // assigns reference\r\n        if (sender.voted) return;\r\n        while (voters[to].delegate != address(0) \u0026\u0026 voters[to].delegate != msg.sender)\r\n            to = voters[to].delegate;\r\n        if (to == msg.sender) return;\r\n        sender.voted = true;\r\n        sender.delegate = to;\r\n        Voter storage delegateTo = voters[to];\r\n        if (delegateTo.voted)\r\n            proposals[delegateTo.vote].voteCount += sender.weight;\r\n        else\r\n            delegateTo.weight += sender.weight;\r\n    }\r\n\r\n    /// Give a single vote to proposal $(toProposal).\r\n    function vote(uint8 toProposal) public {\r\n        Voter storage sender = voters[msg.sender];\r\n        if (sender.voted || toProposal \u003e= proposals.length) return;\r\n        sender.voted = true;\r\n        sender.vote = toProposal;\r\n        proposals[toProposal].voteCount += sender.weight;\r\n    }\r\n\r\n    function winningProposal() public constant returns (uint8 _winningProposal) {\r\n        uint256 winningVoteCount = 0;\r\n        for (uint8 prop = 0; prop \u003c proposals.length; prop++)\r\n            if (proposals[prop].voteCount \u003e winningVoteCount) {\r\n                winningVoteCount = proposals[prop].voteCount;\r\n                _winningProposal = prop;\r\n            }\r\n    }\r\n}"},"coins.sol":{"content":"pragma solidity ^0.4.11;\r\nimport \u0027./iERC20.sol\u0027;\r\nimport \u0027./SafeMath.sol\u0027;\r\n\r\ncontract ALA is iERC20{\r\n\r\n  \r\n    uint public _totalSupply = 475000000000000000; //100 M\r\n    string public constant symbol = \"ALA\";\r\n    string public constant name = \"ALADIN\";\r\n    uint8 public constant decimals = 8;\r\n    mapping (address =\u003e uint256) balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\r\n    \r\n    function ALA(){\r\n        balances[msg.sender] = _totalSupply;\r\n    }\r\n    function totalSupply() constant returns (uint256 totalSupply){\r\n         return _totalSupply;\r\n    }\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(\r\n            balances[msg.sender]\u003e= _value\r\n            \u0026\u0026 _value \u003e 0\r\n        );\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(\r\n            allowed[_from][msg.sender]  \u003e= _value\r\n            \u0026\u0026 balances[_from] \u003e= _value\r\n            \u0026\u0026 _value \u003e 0\r\n        );\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;    \r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        // require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n        // allowed[msg.sender][_spender] = _value;\r\n        // Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n}"},"iERC20.sol":{"content":"pragma solidity ^0.4.11;\r\ninterface iERC20{\r\n  function totalSupply() constant returns (uint256 totalSupply);\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n  function approve(address _spender, uint256 _value) returns (bool success);\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.4.11;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b \u003c= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c \u003e= a);\r\n    return c;\r\n  }\r\n}"}}