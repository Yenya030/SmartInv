{"GovStaking.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./ReentrantGuard.sol\";\nimport \"./IUniswapV2Router02.sol\";\n\ninterface IGovernance {\n    function mint(address account, uint256 amount) external returns (bool);\n}\n\n/**\n    GOVERNANCE TAO Staking Contract\n */\ncontract GOVERNANCETAO is Ownable, IERC20, ReentrancyGuard {\n\n    // name and symbol for tokenized contract\n    string private constant _name = \u0027MTAO STAKE\u0027;\n    string private constant _symbol = \u0027SMTAO\u0027;\n    uint8 private constant _decimals = 9;\n\n    // constants\n    uint256 private constant precision = 10**24;\n    uint256 public constant minLockTimeMultiplier = 10**6;\n    address private constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    address public constant token = 0x1E8E29CA51363D923725aB9DaC73Bd7e9C440f71;\n\n    // Router for reinvesting\n    IUniswapV2Router02 public router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n    // maximum lock time in blocks\n    uint256 public maxLockTime = 730 days;\n    uint256 public minLockTime = 7 days;\n    uint256 public maxLockTimeMultiplier = 25 * minLockTimeMultiplier / 10;\n\n    // maximum leave early fee multiplier\n    uint256 public minEarlyFee = 2 * 10**16;\n    uint256 public maxEarlyFee = 15 * 10**16;\n\n    // Lock Info\n    struct LockInfo {\n        uint256 lockAmount;\n        uint256 unlockTime;\n        uint256 lockDuration;\n        uint256 rewardPointsAssigned;\n        uint256 index;\n        address locker;\n    }\n\n    // Nonce For Lock Info\n    uint256 public lockInfoNonce;\n\n    // Nonce =\u003e LockInfo\n    mapping(uint256 =\u003e LockInfo) public lockInfo;\n\n    // User Info\n    struct UserInfo {\n        uint256 totalAmountStaked;\n        uint256 rewardPoints;\n        uint256[] lockIds;\n        uint256 totalRewardsClaimed;\n    }\n\n    // Address =\u003e UserInfo\n    mapping(address =\u003e UserInfo) public userInfo;\n\n    // list of all users for airdrop functionality\n    address[] public allUsers;\n\n    // Tracks Dividends\n    uint256 public totalStaked;\n    uint256 public totalRewardPoints;\n\n    // Average Lock Times\n    uint256 public totalTimeLocked;\n\n    // Reward tracking info\n    uint256 public totalRewards;\n    uint256 private dividendsPerPoint;\n    mapping ( address =\u003e uint256 ) private totalExcluded;\n\n    // Governance Token\n    IGovernance public GTAO;\n\n    // Events\n    event SetMaxLockTime(uint256 newMaxLockTime);\n    event SetMinLockTime(uint256 newMinLockTime);\n    event SetMaxLeaveEarlyFee(uint256 newMaxFee);\n    event SetMinLeaveEarlyFee(uint256 newMinFee);\n    event SetMaxLockTimeMultiplier(uint256 newMaxLockTimeMultiplier);\n\n    constructor() {\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /** Returns the total number of tokens in existence */\n    function totalSupply() external view override returns (uint256) {\n        return totalStaked;\n    }\n\n    /** Returns the number of tokens owned by `account` */\n    function balanceOf(address account) public view override returns (uint256) {\n        return userInfo[account].totalAmountStaked;\n    }\n\n    /** Returns the number of tokens `spender` can transfer from `holder` */\n    function allowance(address, address)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    /** Token Name */\n    function name() public pure override returns (string memory) {\n        return _name;\n    }\n\n    /** Token Ticker Symbol */\n    function symbol() public pure override returns (string memory) {\n        return _symbol;\n    }\n\n    /** Tokens decimals */\n    function decimals() public pure override returns (uint8) {\n        return _decimals;\n    }\n\n    /** Approves `spender` to transfer `amount` tokens from caller */\n    function approve(address spender, uint256) public override returns (bool) {\n        emit Approval(msg.sender, spender, 0);\n        return true;\n    }\n\n    /** Transfer Function */\n    function transfer(address recipient, uint256)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        _claimReward(msg.sender, false);\n        emit Transfer(msg.sender, recipient, 0);\n        return true;\n    }\n\n    /** Transfer Function */\n    function transferFrom(\n        address,\n        address recipient,\n        uint256\n    ) external override nonReentrant returns (bool) {\n        _claimReward(msg.sender, false);\n        emit Transfer(msg.sender, recipient, 0);\n        return true;\n    }\n\n    ///////////////////////////////////////////\n    ////////      OWNER FUNCTIONS     /////////\n    ///////////////////////////////////////////\n\n    /**\n        Sets The Governance Token, Can Only Be Set Once\n     */\n    function setGTAO(address GTAO_) external onlyOwner {\n        require(\n            GTAO_ != address(0) \u0026\u0026\n            address(GTAO) == address(0),\n            \u0027Already Set\u0027\n        );\n        GTAO = IGovernance(GTAO_);\n    }\n\n    /**\n        Sets the router for reinvesting\n     */\n    function setRouter(address newRouter) external onlyOwner {\n        router = IUniswapV2Router02(newRouter);\n    }\n\n    /**\n        Sets The Minimum Allowed Lock Time That Users Can Stake \n        Requirements:\n            - newMinLockTime must be less than the maxLockTime\n     */\n    function setMinLockTime(uint256 newMinLockTime) external onlyOwner {\n        require(\n            newMinLockTime \u003c maxLockTime,\n            \"Min Lock Time Cannot Exceed Max Lock Time\"\n        );\n        minLockTime = newMinLockTime;\n        emit SetMinLockTime(newMinLockTime);\n    }\n\n    /**\n        Sets The Maximum Allowed Lock Time That Users Can Stake \n        Requirements:\n            - newMaxLockTime must be greater than the minLockTime\n     */\n    function setMaxLockTime(uint256 newMaxLockTime) external onlyOwner {\n        require(\n            newMaxLockTime \u003e minLockTime,\n            \"Max Lock Time Must Exceed Min Lock Time\"\n        );\n        maxLockTime = newMaxLockTime;\n        emit SetMaxLockTime(newMaxLockTime);\n    }\n\n    /**\n        Sets The Minimum Penalty For Unstaking Before Stake Unlocks\n        Requirements:\n            - newMinLeaveEarlyFee must be less than the maxEarlyFee\n     */\n    function setMinLeaveEarlyFee(uint256 newMinLeaveEarlyFee) external onlyOwner {\n        require(\n            newMinLeaveEarlyFee \u003c maxEarlyFee,\n            \"Min Lock Time Cannot Exceed Max Lock Time\"\n        );\n        minEarlyFee = newMinLeaveEarlyFee;\n        emit SetMinLeaveEarlyFee(newMinLeaveEarlyFee);\n    }\n\n    /**\n        Sets The Maximum Penalty For Unstaking Before Stake Unlocks\n        Requirements:\n            - newMaxLeaveEarlyFee must be less than the minEarlyFee\n     */\n    function setMaxLeaveEarlyFee(uint256 newMaxLeaveEarlyFee) external onlyOwner {\n        require(\n            newMaxLeaveEarlyFee \u003e minEarlyFee,\n            \"Max Lock Time Must Exceed Min Lock Time\"\n        );\n        maxEarlyFee = newMaxLeaveEarlyFee;\n        emit SetMaxLeaveEarlyFee(newMaxLeaveEarlyFee);\n    }\n\n    /**\n        Sets The Multiplier For Maximum Lock Time\n        A Multiplier Of 4 * 10^18 Would Make A Max Lock Time Stake\n        Gain 4x The Rewards Of A Min Lock Time Stake For The Same Amount Of Tokens Staked\n        Requirements:\n            - newMaxLockTimeMultiplier MUST Be Greater Than Or Equal To 10^18\n     */\n    function setMaxLockTimeMultiplier(uint256 newMaxLockTimeMultiplier)\n        external\n        onlyOwner\n    {\n        require(\n            newMaxLockTimeMultiplier \u003e= minLockTimeMultiplier,\n            \"Max Lock Time Multiplier Too Small\"\n        );\n        maxLockTimeMultiplier = newMaxLockTimeMultiplier;\n        emit SetMaxLockTimeMultiplier(newMaxLockTimeMultiplier);\n    }\n\n    /**\n        Withdraws Any Token That Is Not MTAO\n        NOTE: Withdrawing Reward Tokens Will Mess Up The Math Associated With Rewarding\n              The Contract will still function as desired, but the last users to claim\n              Will not receive their full amount, or any, of the reward token\n     */\n    function withdrawForeignToken(address token_) external onlyOwner {\n        require(token != token_, \"Cannot Withdraw Staked Token\");\n        _send(token_, msg.sender, balanceOfToken(token_));\n    }\n\n    /**\n        Withdraws The Native Chain Token To Owner\u0027s Address\n     */\n    function withdrawNative() external onlyOwner {\n        (bool s, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(s, \"Failure To Withdraw Native\");\n    }\n\n    /**\n        Stakes `amount` of MTAO for the specified `lockTime`\n        Increasing the user\u0027s rewardPoints and overall share of the pool\n        Also claims the current pending rewards for the user\n        Requirements:\n            - `amount` is greater than zero\n            - lock time is within bounds for min and max lock time, lock time is in blocks\n            - emergencyWithdraw has not been enabled by contract owner\n     */\n    function stakeFor(address user, uint256 amount, uint256 lockTime) external nonReentrant onlyOwner {\n        require(amount \u003e 0, \"Zero Amount\");\n        require(user != address(0), \u0027Zero Address\u0027);\n        require(lockTime \u003c= maxLockTime, \"Lock Time Exceeds Maximum\");\n        require(lockTime \u003e= minLockTime, \"Lock Time Preceeds Minimum\");\n\n        // attempt to claim rewards\n        if (userInfo[user].totalAmountStaked \u003e 0) {\n            _claimReward(user, false);\n        }\n\n        // transfer in tokens\n        uint256 received = _transferIn(token, amount);\n\n        // total reward multiplier\n        uint256 multiplier = calculateRewardPoints(received, lockTime);\n\n        // update reward multiplier data\n        unchecked {\n            userInfo[user].rewardPoints += multiplier;\n            totalRewardPoints += multiplier;\n        }\n\n        // update staked data\n        unchecked {\n            totalStaked += received;\n            userInfo[user].totalAmountStaked += received;\n        }\n\n        // update reward data for each reward token\n        totalExcluded[user] = getCumulativeDividends(userInfo[user].rewardPoints);\n\n        // Map Lock Nonce To Lock Info\n        lockInfo[lockInfoNonce] = LockInfo({\n            lockAmount: received,\n            unlockTime: block.timestamp + lockTime,\n            lockDuration: lockTime,\n            rewardPointsAssigned: multiplier,\n            index: userInfo[user].lockIds.length,\n            locker: user\n        });\n\n        // Push Lock Nonce To User\u0027s Lock IDs\n        userInfo[user].lockIds.push(lockInfoNonce);\n\n        unchecked {\n            // Increment Global Lock Nonce\n            lockInfoNonce++;\n\n            // Increment Total Time Locked\n            totalTimeLocked += lockTime;\n        }\n\n        // show transfer for Staking Token\n        emit Transfer(address(0), user, received);\n\n        // mint governance tokens\n        GTAO.mint(user, multiplier);\n    }\n\n\n    ///////////////////////////////////////////\n    ////////     PUBLIC FUNCTIONS     /////////\n    ///////////////////////////////////////////\n\n\n    /**\n        Claims All The Rewards Associated With `msg.sender` in ETH\n     */\n    function claimRewards() external nonReentrant {\n        _claimReward(msg.sender, false);\n    }\n\n    /**\n        Claims All The Rewards Associated With `msg.sender` in MTAO\n     */\n    function claimRewardsAsMTAO() external nonReentrant {\n        _claimReward(msg.sender, true);\n    }\n\n    /**\n        Stakes `amount` of MTAO for the specified `lockTime`\n        Increasing the user\u0027s rewardPoints and overall share of the pool\n        Also claims the current pending rewards for the user\n        Requirements:\n            - `amount` is greater than zero\n            - lock time is within bounds for min and max lock time, lock time is in blocks\n            - emergencyWithdraw has not been enabled by contract owner\n     */\n    function stake(uint256 amount, uint256 lockTime) external nonReentrant {\n        require(amount \u003e 0, \"Zero Amount\");\n        require(lockTime \u003c= maxLockTime, \"Lock Time Exceeds Maximum\");\n        require(lockTime \u003e= minLockTime, \"Lock Time Preceeds Minimum\");\n\n        // gas savings\n        address user = msg.sender;\n\n        // attempt to claim rewards\n        if (userInfo[user].totalAmountStaked \u003e 0) {\n            _claimReward(user, false);\n        }\n\n        // transfer in tokens\n        uint256 received = _transferIn(token, amount);\n\n        // total reward multiplier\n        uint256 multiplier = calculateRewardPoints(received, lockTime);\n\n        // update reward multiplier data\n        unchecked {\n            userInfo[user].rewardPoints += multiplier;\n            totalRewardPoints += multiplier;\n        }\n\n        // update staked data\n        unchecked {\n            totalStaked += received;\n            userInfo[user].totalAmountStaked += received;\n        }\n\n        // update reward data for each reward token\n        totalExcluded[user] = getCumulativeDividends(userInfo[user].rewardPoints);\n\n        // Map Lock Nonce To Lock Info\n        lockInfo[lockInfoNonce] = LockInfo({\n            lockAmount: received,\n            unlockTime: block.timestamp + lockTime,\n            lockDuration: lockTime,\n            rewardPointsAssigned: multiplier,\n            index: userInfo[user].lockIds.length,\n            locker: user\n        });\n\n        // Push Lock Nonce To User\u0027s Lock IDs\n        userInfo[user].lockIds.push(lockInfoNonce);\n\n        unchecked {\n            // Increment Global Lock Nonce\n            lockInfoNonce++;\n\n            // Increment Total Time Locked\n            totalTimeLocked += lockTime;\n        }\n\n        // show transfer for Staking Token\n        emit Transfer(address(0), user, received);\n\n        // mint governance tokens\n        GTAO.mint(user, multiplier);\n    }\n\n    /**\n        Withdraws `amount` of MTAO Associated With `lockId`\n        Claims All Pending Rewards For The User\n        Requirements:\n            - `lockId` is a valid lock ID\n            - locker of `lockId` is msg.sender\n            - lock amount for `lockId` is greater than zero\n            - the time left until unlock for `lockId` is zero\n            - Emergency Withdraw is disabled\n     */\n    function withdraw(uint256 lockId, uint256 amount) external nonReentrant {\n        \n        // gas savings\n        address user = msg.sender;\n        uint256 lockIdAmount = lockInfo[lockId].lockAmount;\n\n        // Require Input Data Is Correct\n        require(lockId \u003c lockInfoNonce, \"Invalid LockID\");\n        require(lockInfo[lockId].locker == user, \"Not Owner Of LockID\");\n        require(lockIdAmount \u003e 0 \u0026\u0026 amount \u003e 0, \"Insufficient Amount\");\n\n        // claim reward for user\n        if (userInfo[user].totalAmountStaked \u003e 0) {\n            _claimReward(user, false);\n        }\n\n        // ensure we are not trying to unlock more than we own\n        if (amount \u003e lockIdAmount) {\n            amount = lockIdAmount;\n        }\n\n        // update amount staked\n        totalStaked -= amount;\n        userInfo[user].totalAmountStaked -= amount;\n\n        // see if early fee should be applied\n        uint earlyFee = timeUntilUnlock(lockId) == 0 ? 0 : amount * getEarlyFee(lockId) / 10**18;\n\n        // if withdrawing full amount, remove lock ID\n        if (amount == lockIdAmount) {\n            // reduce reward points assigned\n            uint256 rewardPointsAssigned = lockInfo[lockId].rewardPointsAssigned;\n            userInfo[user].rewardPoints -= rewardPointsAssigned;\n            totalRewardPoints -= rewardPointsAssigned;\n\n            // remove all lockId data\n            _removeLock(lockId);\n        } else {\n            // reduce rewardPoints by rewardPoints * ( amount / lockAmount )\n            uint256 rewardPointsToRemove = (amount *\n                lockInfo[lockId].rewardPointsAssigned) / lockIdAmount;\n            \n            // decrement reward points\n            userInfo[user].rewardPoints -= rewardPointsToRemove;\n            totalRewardPoints -= rewardPointsToRemove;\n\n            // update lock data\n            lockInfo[lockId].lockAmount -= amount;\n            lockInfo[lockId].rewardPointsAssigned -= rewardPointsToRemove;\n        }\n\n        // update reward data for each reward token\n        totalExcluded[user] = getCumulativeDividends(userInfo[user].rewardPoints);\n\n        // remove user from list if unstaked completely\n        if (userInfo[user].totalAmountStaked == 0) {\n            delete userInfo[user];\n        }\n\n        // burn early fee if applicable\n        if (earlyFee \u003e 0) {\n            _send(token, burnAddress, earlyFee);\n        }\n\n        // send rest of amount to user\n        _send(token, user, amount - earlyFee);\n\n        // emit token transfer\n        emit Transfer(user, address(0), amount);\n    }\n\n\n    /**\n        Allows Contract To Receive Native Currency\n     */\n    receive() external payable nonReentrant {\n        // update rewards\n        unchecked {\n            totalRewards += msg.value;   \n        }\n        if (totalRewardPoints \u003e 0) {\n            dividendsPerPoint += ( precision * msg.value ) / totalRewardPoints;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ////////    INTERNAL FUNCTIONS    /////////\n    ///////////////////////////////////////////\n\n    function _claimReward(address user, bool asMTAO) internal {\n        // exit if zero value locked\n        if (userInfo[user].totalAmountStaked == 0) {\n            return;\n        }\n\n        // get pending rewards\n        uint256 pending = pendingRewards(user);\n\n        // reset total excluded\n        totalExcluded[user] = getCumulativeDividends(userInfo[user].rewardPoints);\n\n        // increment total rewards claimed\n        unchecked {\n            userInfo[user].totalRewardsClaimed += pending;\n        }\n\n        if (asMTAO) {\n\n            // amount of MTAO in contract before swap\n            uint256 amountBefore = IERC20(token).balanceOf(address(this));\n            \n            // define swap path\n            address[] memory path = new address[](2);\n            path[0] = router.WETH();\n            path[1] = token;\n\n            // swap ETH for MTAO\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: pending}(\n                0, path, address(this), block.timestamp + 10000\n            );\n\n            // amount of MTAO in contract after swap\n            uint256 amountAfter = IERC20(token).balanceOf(address(this));\n            require(\n                amountAfter \u003e amountBefore,\n                \u0027No Received\u0027\n            );\n\n            // calculate amount of MTAO purchased\n            uint256 received = amountAfter - amountBefore;\n\n            // send MTAO to user\n            _send(token, user, received);\n\n            // save memory, refund gas\n            delete path;\n        } else {\n\n            // send ETH value to user\n            _send(address(0), user, pending);\n        }\n    }\n\n    function _transferIn(address _token, uint256 amount)\n        internal\n        returns (uint256)\n    {\n        require(\n            IERC20(_token).allowance(msg.sender, address(this)) \u003e= amount,\n            \u0027Insufficient Allowance\u0027\n        );\n        uint256 before = balanceOfToken(_token);\n        IERC20(_token).transferFrom(msg.sender, address(this), amount);\n        uint256 After = balanceOfToken(_token);\n        require(After \u003e before, \"Error On Transfer From\");\n        return After - before;\n    }\n\n    function _send(\n        address _token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (to == address(0)) {\n            return;\n        }\n\n        // fetch and validate contract owns necessary balance\n        uint256 bal = _token == address(0) ? address(this).balance : balanceOfToken(_token);\n        if (amount \u003e bal) {\n            amount = bal;\n        }\n\n        // return if amount is zero\n        if (amount == 0) {\n            return;\n        }\n\n        if (_token == address(0)) {\n            (bool s,) = payable(to).call{value: amount}(\"\");\n            require(s, \u0027Failure On Eth Transfer\u0027);\n        } else {\n            // ensure transfer succeeds\n            require(\n                IERC20(_token).transfer(to, amount),\n                \"Failure On Token Transfer\"\n            );\n        }\n    }\n\n    function _removeLock(uint256 id) internal {\n        // fetch elements to make function more readable\n        address user = lockInfo[id].locker;\n        uint256 rmIndex = lockInfo[id].index;\n        uint256 lastElement = userInfo[user].lockIds[\n            userInfo[user].lockIds.length - 1\n        ];\n\n        // set last element\u0027s index to be removed index\n        lockInfo[lastElement].index = rmIndex;\n        // set removed index\u0027s position to be the last element\n        userInfo[user].lockIds[rmIndex] = lastElement;\n        // pop last element off the user array\n        userInfo[user].lockIds.pop();\n\n        // delete lock data\n        delete lockInfo[id];\n    }\n\n    ///////////////////////////////////////////\n    ////////      READ FUNCTIONS      /////////\n    ///////////////////////////////////////////\n\n    function getCumulativeDividends(uint256 share) public view returns (uint256) {\n        return ( share * dividendsPerPoint ) / precision;\n    }\n\n    function getEarlyFee(uint lockId) public view returns (uint256) {\n        return calculateLeaveEarlyFee(lockInfo[lockId].lockDuration);\n    }\n\n    function balanceOfToken(address _token) public view returns (uint256) {\n        return IERC20(_token).balanceOf(address(this));\n    }\n\n    function tokenBalanceOf(address user) external view returns (uint256) {\n        return userInfo[user].totalAmountStaked;\n    }\n\n    function calculateRewardPoints(uint256 lockAmount, uint256 lockTime)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            lockAmount *\n            (minLockTimeMultiplier +\n                (((lockTime - minLockTime) *\n                    (maxLockTimeMultiplier - minLockTimeMultiplier)) /\n                    (maxLockTime - minLockTime)));\n    }\n\n    function calculateLeaveEarlyFee(uint256 lockTime)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            minEarlyFee +\n                (((lockTime - minLockTime) *\n                    (maxEarlyFee - minEarlyFee)) /\n                    (maxLockTime - minLockTime));\n    }\n\n    function timeUntilUnlock(uint256 lockId) public view returns (uint256) {\n        return\n            lockInfo[lockId].unlockTime \u003c= block.timestamp\n                ? 0\n                : lockInfo[lockId].unlockTime - block.timestamp;\n    }\n\n    function pendingRewards(address user)\n        public\n        view\n        returns (uint256)\n    {\n        if (userInfo[user].totalAmountStaked == 0) {\n            return 0;\n        }\n\n        uint256 holderTotalDividends = getCumulativeDividends(userInfo[user].rewardPoints);\n        uint256 holderTotalExcluded = totalExcluded[user];\n\n        return\n            holderTotalDividends \u003e holderTotalExcluded\n                ? holderTotalDividends - holderTotalExcluded\n                : 0;\n    }\n\n    function averageTimeLocked() external view returns (uint256) {\n        return totalTimeLocked / lockInfoNonce;\n    }\n\n    function getAllLockIDsForUser(address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return userInfo[user].lockIds;\n    }\n\n    function getNumberOfLockIDsForUser(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userInfo[user].lockIds.length;\n    }\n\n    function getTotalRewardsClaimedForUser(address user)\n        external\n        view\n        returns (uint256)\n    {\n        return userInfo[user].totalRewardsClaimed;\n    }\n\n    function fetchLockData(address user)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 len = userInfo[user].lockIds.length;\n        uint256[] memory amounts = new uint256[](len);\n        uint256[] memory durations = new uint256[](len);\n        uint256[] memory timeRemaining = new uint256[](len);\n        uint256[] memory earlyFees = new uint256[](len);\n\n        for (uint256 i = 0; i \u003c len; ) {\n            amounts[i] = lockInfo[userInfo[user].lockIds[i]].lockAmount;\n            durations[i] = lockInfo[userInfo[user].lockIds[i]].lockDuration;\n            timeRemaining[i] = timeUntilUnlock(userInfo[user].lockIds[i]);\n            earlyFees[i] = getEarlyFee(userInfo[user].lockIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (userInfo[user].lockIds, amounts, durations, timeRemaining, earlyFees);\n    }\n}\n"},"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    \n    function symbol() external view returns(string memory);\n    \n    function name() external view returns(string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n     * @dev Returns the number of decimal places\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IUniswapV2Router02.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"},"Ownable.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Ownable {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier onlyOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"},"ReentrantGuard.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}"}}