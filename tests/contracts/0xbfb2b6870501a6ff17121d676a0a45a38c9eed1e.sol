{{
  "language": "Solidity",
  "sources": {
    "contracts/LuckyToadv3.sol": {
      "content": "/**\r\n * This is a tax demo token, to show off a new idea mainly\r\n */\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"./LuckyJackpots.sol\";\r\n// Seriously if you audit this and ping it for \"no safemath used\" you're gonna out yourself as an idiot\r\n// SafeMath is by default included in solidity 0.8, I've only included it for the transferFrom\r\n\r\ncontract LuckyToadv3 is Context, IERC20, Ownable {\r\n\r\n    event Bought(address indexed buyer, uint256 amount);\r\n    event Sold(address indexed seller, uint256 amount);\r\n    using SafeMath for uint256;\r\n    // Constants\r\n    string private constant _name = \"LuckyToadv3\";\r\n    string private constant _symbol = \"TOAD\";\r\n    // 0, 1, 2\r\n    uint8 private constant _bl = 2;\r\n    // Standard decimals\r\n    uint8 private constant _decimals = 9;\r\n    // 1 quad\r\n    uint256 private constant totalTokens = 1000000000 * 10**9;\r\n    // USDC\r\n    address private constant _usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\r\n    // Mappings\r\n    mapping(address => uint256) private tokensOwned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    \r\n\r\n    struct mappingStructs {\r\n        bool _isExcludedFromFee;\r\n        bool _bots;\r\n        uint32 _lastTxBlock;\r\n        uint32 botBlock;\r\n        bool isLPPair;\r\n    }\r\n\r\n    \r\n    mapping(address => mappingStructs) mappedAddresses;\r\n\r\n    mapping(address => uint256) private botBalance;\r\n    mapping(address => uint256) private airdropTokens;\r\n\r\n    // Arrays\r\n    address[] private airdropPrivateList;\r\n    address[] private holders;\r\n    address[] private jackpotExclusions;\r\n    // Global variables\r\n\r\n    // Block of 256 bits\r\n    address payable private _feeAddrWallet1;\r\n    uint32 private openBlock;\r\n    uint32 private pair1Pct = 50;\r\n    uint32 private transferTax = 0;\r\n    // Storage block closed\r\n\r\n    // Block of 256 bits\r\n    address payable private _feeAddrWallet2;\r\n    // Tax distribution ratios\r\n    uint32 private devRatio = 3000;\r\n    uint32 private marketingRatio = 3000;\r\n    // Another tax disti ratio\r\n    uint32 private creatorRatio = 2000;\r\n    // Storage block closed\r\n\r\n    // Block of 256 bits\r\n    address payable private _feeAddrWallet3;\r\n    uint32 private pair2Pct = 50;\r\n    uint32 private buyTax = 8000;\r\n    uint32 private sellTax = 8000;\r\n    // Storage block closed\r\n\r\n\r\n    // Block of 256 bits\r\n    address private _controller;\r\n    uint32 private maxTxDivisor = 1;\r\n    uint32 private maxWalletDivisor = 1;\r\n    bool private tradingOpen;\r\n    bool private inSwap = false;\r\n    bool private swapEnabled = false;\r\n    bool private cooldownEnabled = false;\r\n    // Storage block closed\r\n\r\n    // Block of 256 bits\r\n    address payable private _LTJackpotCA;\r\n    uint32 ethSendThresholdDivisor = 1000;\r\n    bool disableAddToBlocklist = false;\r\n    bool removedLimits = false;\r\n    // 48 bits left\r\n\r\n    \r\n    IUniswapV2Router02 private uniswapV2Router;\r\n\r\n    modifier onlyERC20Controller() {\r\n        require(\r\n            _msgSender() == _controller,\r\n            \"TokenClawback: caller is not the ERC20 controller.\"\r\n        );\r\n        _;\r\n    }\r\n    modifier onlyDev() {\r\n        require(\r\n            _msgSender() == _feeAddrWallet2,\r\n            \"LT: Only developer can set this.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        // ERC20 controller\r\n        _controller = payable(0x4Cdd1d9EaF9Ff87ED8235Bb5190c92EA4454D435);\r\n        // Marketing \r\n        _feeAddrWallet1 = payable(0xA1588d0b520d634092bB1a13358c4522bDd6b888);\r\n        // Developer\r\n        _feeAddrWallet2 = payable(0x4Cdd1d9EaF9Ff87ED8235Bb5190c92EA4454D435);\r\n        // Creator\r\n        _feeAddrWallet3 = payable(0x9c9F6c443A67a322e2682b82e720dee187F16263);\r\n        tokensOwned[_msgSender()] = totalTokens;\r\n        // Create the Jackpot CA -  set the bot address\r\n        LuckyJackpots jpca = new LuckyJackpots(_msgSender());\r\n        // Change owner to the msgSender\r\n        jpca.transferOwnership(_msgSender());\r\n        // Stash the address so we can send eth to it\r\n        _LTJackpotCA = payable(address(jpca));\r\n        // Set the struct values\r\n        // Push all these accounts to excluded\r\n        jackpotExclusions.push(_msgSender());\r\n        jackpotExclusions.push(_LTJackpotCA);\r\n        jackpotExclusions.push(address(this));\r\n        jackpotExclusions.push(_feeAddrWallet1);\r\n        jackpotExclusions.push(_feeAddrWallet2);\r\n        jackpotExclusions.push(_feeAddrWallet3);\r\n        mappedAddresses[_msgSender()] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n        });\r\n        mappedAddresses[_LTJackpotCA] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n        });\r\n        mappedAddresses[address(this)] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n        });\r\n        mappedAddresses[_feeAddrWallet1] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n        });\r\n        mappedAddresses[_feeAddrWallet2] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n        });\r\n        mappedAddresses[_feeAddrWallet3] = mappingStructs({\r\n            _isExcludedFromFee: true,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: false\r\n         });\r\n        emit Transfer(address(0), _msgSender(), totalTokens);\r\n        \r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return abBalance(account);\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /// @notice Sets cooldown status. Only callable by owner.\r\n    /// @param onoff The boolean to set.\r\n    function setCooldownEnabled(bool onoff) external onlyOwner {\r\n        cooldownEnabled = onoff;\r\n    }\r\n\r\n    /// @notice Starts trading. Only callable by owner.\r\n    function openTrading() public onlyOwner {\r\n        require(!tradingOpen, \"trading is already open\");\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n        uniswapV2Router = _uniswapV2Router;\r\n        _approve(address(this), address(uniswapV2Router), totalTokens);\r\n        address uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n        // Create a USDC pair - this is to provide a second pool to process taxes through\r\n        address uniswapV2Pair2 = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(\r\n                address(this),\r\n                _usdc\r\n            );\r\n        // Add Pair1Pct of the eth and LP to the first (ETH) pair\r\n        uint256 pair1TAmt = (balanceOf(address(this)) * pair1Pct) / 100;\r\n        uint256 pair2TAmt = (balanceOf(address(this)) * pair2Pct) / 100;\r\n        uint256 pair1EAmt = (address(this).balance * pair1Pct) / 100;\r\n        uint256 pair2EAmt = (address(this).balance * pair2Pct) / 100;\r\n        uniswapV2Router.addLiquidityETH{value: pair1EAmt}(\r\n            address(this),\r\n            pair1TAmt,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n        // Swap the pair2Pct eth amount for USDC\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = _usdc;\r\n        uniswapV2Router.swapExactETHForTokens{value: pair2EAmt}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        // Approve the USDC spend\r\n        IERC20 usdc = IERC20(_usdc);\r\n        // Actually get our balance\r\n        uint256 pair2UAmt = usdc.balanceOf(address(this));\r\n        usdc.approve(address(uniswapV2Router), pair2UAmt);\r\n        // Create a token/usdc pool\r\n        uniswapV2Router.addLiquidity(\r\n            _usdc,\r\n            address(this),\r\n            pair2UAmt,\r\n            pair2TAmt,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n        swapEnabled = true;\r\n        cooldownEnabled = true;\r\n\r\n        // no max tx\r\n        maxTxDivisor = 1;\r\n        // no max wallet\r\n        maxWalletDivisor = 1;\r\n        tradingOpen = true;\r\n        openBlock = uint32(block.number);\r\n        IERC20(uniswapV2Pair).approve(\r\n            address(uniswapV2Router),\r\n            type(uint256).max\r\n        );\r\n        IERC20(uniswapV2Pair2).approve(\r\n            address(uniswapV2Router),\r\n            type(uint256).max\r\n        );\r\n        // Add the pairs to the list \r\n        mappedAddresses[uniswapV2Pair] = mappingStructs({\r\n            _isExcludedFromFee: false,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: true\r\n        });\r\n        mappedAddresses[uniswapV2Pair2] = mappingStructs({\r\n            _isExcludedFromFee: false,\r\n            _bots: false,\r\n            _lastTxBlock: 0,\r\n            botBlock: 0,\r\n            isLPPair: true\r\n        });\r\n        jackpotExclusions.push(uniswapV2Pair);\r\n        jackpotExclusions.push(uniswapV2Pair2);\r\n        \r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        bool isBot = false;\r\n        uint32 _taxAmt;\r\n        bool isSell = false;\r\n\r\n        if (\r\n            from != owner() &&\r\n            to != owner() &&\r\n            from != address(this) &&\r\n            !mappedAddresses[to]._isExcludedFromFee &&\r\n            !mappedAddresses[from]._isExcludedFromFee\r\n        ) {\r\n            require(\r\n                !mappedAddresses[to]._bots && !mappedAddresses[from]._bots,\r\n                \"LT: Blocklisted.\"\r\n            );\r\n\r\n            // Buys\r\n            if (\r\n                (mappedAddresses[from].isLPPair) &&\r\n                to != address(uniswapV2Router)\r\n            ) {\r\n                _taxAmt = buyTax;\r\n                if (cooldownEnabled) {\r\n                    // Check if last tx occurred this block - prevents sandwich attacks\r\n                    require(\r\n                        mappedAddresses[to]._lastTxBlock != block.number,\r\n                        \"LT: One tx per block.\"\r\n                    );\r\n                    mappedAddresses[to]._lastTxBlock = uint32(block.number);\r\n                }\r\n                // Set it now\r\n\r\n                if (openBlock + _bl > block.number) {\r\n                    // Bot\r\n                    isBot = true;\r\n                } else {\r\n                    checkTxMax(to, amount, _taxAmt);\r\n                }\r\n            } else if (\r\n                (mappedAddresses[to].isLPPair) &&\r\n                from != address(uniswapV2Router)\r\n            ) {\r\n                isSell = true;\r\n                // Sells\r\n                // Check if last tx occurred this block - prevents sandwich attacks\r\n                if (cooldownEnabled) {\r\n                    require(\r\n                        mappedAddresses[from]._lastTxBlock != block.number,\r\n                        \"LT: One tx per block.\"\r\n                    );\r\n                    mappedAddresses[from]._lastTxBlock == block.number;\r\n                }\r\n                // Sells\r\n                _taxAmt = sellTax;\r\n                // Max TX checked with respect to sell tax\r\n                require(\r\n                    (amount * (100000 - _taxAmt)) / 100000 <=\r\n                        totalTokens / maxTxDivisor,\r\n                    \"LT: Over max transaction amount.\"\r\n                );\r\n            } else {\r\n                _taxAmt = transferTax;\r\n            }\r\n        } else {\r\n            // Only make it here if it's from or to owner or from contract address.\r\n            _taxAmt = 0;\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, _taxAmt, isBot, isSell);\r\n    }\r\n\r\n    function doTaxes(uint256 tokenAmount, bool useEthPair, bool isSell, address sender) private {\r\n        // Reentrancy guard/stop infinite tax sells mainly\r\n        inSwap = true;\r\n        \r\n        if(_allowances[address(this)][address(uniswapV2Router)] < tokenAmount) {\r\n            // Our approvals run low, redo it\r\n            _approve(address(this), address(uniswapV2Router), totalTokens);\r\n        }\r\n        if (useEthPair) {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = uniswapV2Router.WETH();\r\n            // Swap direct to WETH and let router unwrap\r\n\r\n            uniswapV2Router.swapExactTokensForETH(\r\n                tokenAmount,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n        } else {\r\n            // Use a 3 point path to run the sells via the USDC pools\r\n            address[] memory path = new address[](3);\r\n            path[0] = address(this);\r\n            // USDC\r\n            path[1] = _usdc;\r\n            path[2] = uniswapV2Router.WETH();\r\n            // Swap our tokens to WETH using the this->USDC->WETH path\r\n            uniswapV2Router.swapExactTokensForETH(\r\n                tokenAmount,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n        }\r\n        if(isSell) {\r\n            // Send it to the jackpot wallet and issue a jackpot pending\r\n            LuckyJackpots ca = LuckyJackpots(_LTJackpotCA);\r\n            ca.addPendingWin{value: address(this).balance}(sender);\r\n        } else {\r\n            // Does what it says on the tin - sends eth to the tax wallets\r\n            sendETHToFee(address(this).balance);\r\n        }\r\n        \r\n        \r\n        inSwap = false;\r\n    }\r\n\r\n    function sendETHToFee(uint256 amount) private {\r\n        // This fixes gas reprice issues - reentrancy is not an issue as the fee wallets are trusted.\r\n        uint32 divisor = marketingRatio + devRatio + creatorRatio;\r\n        // Marketing\r\n        Address.sendValue(_feeAddrWallet1, (amount * marketingRatio) / divisor);\r\n        // Dev\r\n        Address.sendValue(_feeAddrWallet2, (amount * devRatio) / divisor);\r\n        // Creator\r\n        Address.sendValue(_feeAddrWallet3, (amount * creatorRatio) / divisor);\r\n    }\r\n\r\n\r\n    function checkTxMax(\r\n        address to,\r\n        uint256 amount,\r\n        uint32 _taxAmt\r\n    ) private view {\r\n        // Calculate txMax with respect to taxes,\r\n        uint256 taxLeft = (amount * (100000 - _taxAmt)) / 100000;\r\n        // Not over max tx amount\r\n        require(\r\n            taxLeft <= totalTokens / maxTxDivisor,\r\n            \"LT: Over max transaction amount.\"\r\n        );\r\n        // Max wallet\r\n        require(\r\n            trueBalance(to) + taxLeft <= totalTokens / maxWalletDivisor,\r\n            \"LT: Over max wallet amount.\"\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function abBalance(address who) private view returns (uint256) {\r\n        if (mappedAddresses[who].botBlock == block.number) {\r\n            return botBalance[who];\r\n        } else {\r\n            return trueBalance(who);\r\n        }\r\n    }\r\n\r\n    function trueBalance(address who) private view returns (uint256) {\r\n        return tokensOwned[who];\r\n    }\r\n\r\n    // Underlying transfer functions go here\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        uint32 _taxAmt,\r\n        bool isBot,\r\n        bool isSell\r\n    ) private {\r\n        uint256 receiverAmount;\r\n        uint256 taxAmount;\r\n        // Check bot flag\r\n        if (isBot) {\r\n            // Set the amounts to send around\r\n            receiverAmount = 1;\r\n            taxAmount = amount - receiverAmount;\r\n            // Set the fake amounts\r\n            mappedAddresses[recipient].botBlock = uint32(block.number);\r\n            // Turns out when we refactored this the 1 token thingy stopped working properly \r\n            // THIS DOES NOT ISSUE REAL TOKENS AND IS NOT A HIDDEN MINT\r\n            botBalance[recipient] = tokensOwned[recipient] + amount;\r\n        } else {\r\n            // Do the normal tax setup\r\n            taxAmount = calculateTaxesFee(amount, _taxAmt);\r\n\r\n            receiverAmount = amount - taxAmount;\r\n        }\r\n\r\n        if (taxAmount > 0) {\r\n            tokensOwned[address(this)] = tokensOwned[address(this)] + taxAmount;\r\n            emit Transfer(sender, address(this), taxAmount);\r\n            // Sell the tokens - work out what pool is being used as the trade pool\r\n            address uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\r\n            .getPair(address(this), uniswapV2Router.WETH());\r\n            doTaxes(taxAmount, !(sender == uniswapV2Pair), isSell, sender);\r\n        }\r\n        if(isSell) {\r\n            emit Sold(sender, receiverAmount);\r\n        } else {\r\n            emit Bought(recipient, receiverAmount);\r\n        }\r\n        // Actually send tokens\r\n        subtractTokens(sender, amount);\r\n        addTokens(recipient, receiverAmount);\r\n\r\n        // Emit transfers, because the specs say to\r\n        emit Transfer(sender, recipient, receiverAmount);\r\n    }\r\n\r\n\r\n    /// @dev Does holder count maths\r\n    function subtractTokens(address account, uint256 amount) private {\r\n        tokensOwned[account] = tokensOwned[account] - amount;\r\n    }\r\n\r\n    /// @dev Does holder count maths and adds to the raffle list if a new buyer\r\n    function addTokens(address account, uint256 amount) private {\r\n        if(tokensOwned[account] == 0) {\r\n            holders.push(account);\r\n        }\r\n        tokensOwned[account] = tokensOwned[account] + amount;\r\n        \r\n    }\r\n    function calculateTaxesFee(uint256 _amount, uint32 _taxAmt) private pure returns (uint256 tax) { \r\n        tax = (_amount * _taxAmt) / 100000;\r\n    }\r\n\r\n    /// @notice Sets an ETH send divisor. Only callable by owner.\r\n    /// @param newDivisor the new divisor to set.\r\n    function setEthSendDivisor(uint32 newDivisor) public onlyOwner {\r\n        ethSendThresholdDivisor = newDivisor;\r\n    }\r\n\r\n    /// @notice Sets new max tx amount. Only callable by owner.\r\n    /// @param divisor The new divisor to set.\r\n    function setMaxTxDivisor(uint32 divisor) external onlyOwner {\r\n        require(!removedLimits, \"LT: Limits have been removed and cannot be re-set.\");\r\n        maxTxDivisor = divisor;\r\n    }\r\n\r\n    /// @notice Sets new max wallet amount. Only callable by owner.\r\n    /// @param divisor The new divisor to set.\r\n    function setMaxWalletDivisor(uint32 divisor) external onlyOwner {\r\n        require(!removedLimits, \"LT: Limits have been removed and cannot be re-set.\");\r\n        maxWalletDivisor = divisor;\r\n    }\r\n\r\n    /// @notice Removes limits, so they cannot be set again. Only callable by owner.\r\n    function removeLimits() external onlyOwner {\r\n        removedLimits = true;\r\n    }\r\n\r\n    /// @notice Changes wallet 1 address. Only callable by owner.\r\n    /// @param newWallet The address to set as wallet 1.\r\n    function changeWallet1(address newWallet) external onlyOwner {\r\n        _feeAddrWallet1 = payable(newWallet);\r\n    }\r\n\r\n    /// @notice Changes wallet 2 address. Only callable by the ERC20 controller.\r\n    /// @param newWallet The address to set as wallet 2.\r\n    function changeWallet2(address newWallet) external onlyERC20Controller {\r\n        _feeAddrWallet2 = payable(newWallet);\r\n    }\r\n\r\n    /// @notice Changes wallet 3 address. Only callable by the ERC20 controller.\r\n    /// @param newWallet The address to set as wallet 3.\r\n    function changeWallet3(address newWallet) external onlyOwner {\r\n        _feeAddrWallet3 = payable(newWallet);\r\n    }\r\n\r\n    /// @notice Changes ERC20 controller address. Only callable by dev.\r\n    /// @param newWallet the address to set as the controller.\r\n    function changeERC20Controller(address newWallet) external onlyDev {\r\n        _controller = payable(newWallet);\r\n    }\r\n    \r\n    /// @notice Allows new pairs to be added to the \"watcher\" code\r\n    /// @param pair the address to add as the liquidity pair\r\n    function addNewLPPair(address pair) external onlyOwner {\r\n         mappedAddresses[pair].isLPPair = true;\r\n    }\r\n\r\n    /// @notice Irreversibly disables blocklist additions after launch has settled.\r\n    /// @dev Added to prevent the code to be considered to have a hidden honeypot-of-sorts. \r\n    function disableBlocklistAdd() external onlyOwner {\r\n        disableAddToBlocklist = true;\r\n    }\r\n    \r\n\r\n    /// @notice Sets an account exclusion or inclusion from fees.\r\n    /// @param account the account to change state on\r\n    /// @param isExcluded the boolean to set it to\r\n    function setExcludedFromFee(address account, bool isExcluded) public onlyOwner {\r\n        mappedAddresses[account]._isExcludedFromFee = isExcluded;\r\n    }\r\n    \r\n    /// @notice Sets the buy tax, out of 100000. Only callable by owner. Max of 20000.\r\n    /// @param amount the tax out of 100000.\r\n    function setBuyTax(uint32 amount) external onlyOwner {\r\n        require(amount <= 20000, \"LT: Maximum buy tax of 20%.\");\r\n        buyTax = amount;\r\n    }\r\n\r\n    /// @notice Sets the sell tax, out of 100000. Only callable by owner. Max of 20000.\r\n    /// @param amount the tax out of 100000.\r\n    function setSellTax(uint32 amount) external onlyOwner {\r\n        require(amount <= 20000, \"LT: Maximum sell tax of 20%.\");\r\n        sellTax = amount;\r\n    }\r\n\r\n    /// @notice Sets the transfer tax, out of 100000. Only callable by owner. Max of 20000.\r\n    /// @param amount the tax out of 100000.\r\n    function setTransferTax(uint32 amount) external onlyOwner {\r\n        require(amount <= 20000, \"LT: Maximum transfer tax of 20%.\");\r\n        transferTax = amount;\r\n    }\r\n\r\n    /// @notice Sets the dev ratio. Only callable by dev account.\r\n    /// @param amount dev ratio to set.\r\n    function setDevRatio(uint32 amount) external onlyDev {\r\n        devRatio = amount;\r\n    }\r\n\r\n    /// @notice Sets the marketing ratio. Only callable by dev account.\r\n    /// @param amount marketing ratio to set\r\n    function setMarketingRatio(uint32 amount) external onlyDev {\r\n        marketingRatio = amount;\r\n    }\r\n\r\n    /// @notice Sets the creator ratio. Only callable by dev account.\r\n    /// @param amount creator ratio to set\r\n    function setCreatorRatio(uint32 amount) external onlyDev {\r\n        creatorRatio = amount;\r\n    }\r\n\r\n    /// @notice Changes bot flag. Only callable by owner. Can only add bots to list if disableBlockListAdd() not called and theBot is not a liquidity pair (prevents honeypot behaviour)\r\n    /// @param theBot The address to change bot of.\r\n    /// @param toSet The value to set.\r\n    function setBot(address theBot, bool toSet) external onlyOwner {\r\n        require(!mappedAddresses[theBot].isLPPair, \"LT: Cannot manipulate blocklist status of a liquidity pair.\");\r\n        if(toSet) {\r\n            require(!disableAddToBlocklist, \"LT: Blocklist additions have been disabled.\");\r\n        }\r\n        mappedAddresses[theBot]._bots = toSet;\r\n    }\r\n\r\n    /// @notice Gets all eligible holders and balances. Used to do jackpot calcs quickly.\r\n    /// @return addresses the addresses\r\n    /// @return balances the balances\r\n    function getBalances() external view returns (address[] memory addresses, uint256[] memory balances) {\r\n        addresses = holders;\r\n        balances = new uint256[](addresses.length);\r\n        for(uint i = 0; i < addresses.length; i++) {\r\n            balances[i] = trueBalance(addresses[i]);\r\n        }\r\n    }\r\n\r\n    function getExcluded() external view returns (address[] memory addresses) {\r\n        addresses = jackpotExclusions;\r\n    }\r\n\r\n\r\n    /// @notice Loads the airdrop values into storage\r\n    /// @param addr array of addresses to airdrop to\r\n    /// @param val array of values for addresses to airdrop\r\n    function loadAirdropValues(address[] calldata addr, uint256[] calldata val)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(addr.length == val.length, \"Lengths don't match.\");\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            // Loads values in\r\n            airdropTokens[addr[i]] = val[i];\r\n            airdropPrivateList.push(addr[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Runs airdrops previously stored, cleaning up as it goes\r\n    function doAirdropPrivate() external onlyOwner {\r\n        // Do the same for private presale\r\n        uint privListLen = airdropPrivateList.length;\r\n        if (privListLen > 0) {\r\n            bool isBot = false;\r\n            for (uint i = 0; i < privListLen; i++) {\r\n                address addr = airdropPrivateList[i];\r\n                _tokenTransfer(msg.sender, addr, airdropTokens[addr], 0, isBot, false);\r\n                airdropTokens[addr] = 0;\r\n            }\r\n            delete airdropPrivateList;\r\n        }\r\n    }\r\n\r\n    function checkBot(address bot) public view returns(bool) {\r\n        return mappedAddresses[bot]._bots;\r\n    }\r\n\r\n    /// @notice Returns if an account is excluded from fees.\r\n    /// @param account the account to check\r\n    function isExcludedFromFee(address account) public view returns (bool) {\r\n        return mappedAddresses[account]._isExcludedFromFee;\r\n    }\r\n\r\n\r\n    /// @dev Debug code used in test suite to check airdrops are successfully stored\r\n    function getAirdropValues() public view returns (address[] memory airdropList, uint256[] memory vals) {\r\n        airdropList =  new address[](airdropPrivateList.length);\r\n        vals = new uint256[](airdropPrivateList.length);\r\n        for(uint i = 0; i < airdropPrivateList.length; i++) {\r\n            airdropList[i] = (airdropPrivateList[i]);\r\n            vals[i] = (airdropTokens[airdropPrivateList[i]]);\r\n        }\r\n    }\r\n\r\n    /// @dev Debug code for checking max tx get/set\r\n    function getMaxTx() public view returns (uint256 maxTx) {\r\n        maxTx = (totalTokens / maxTxDivisor);\r\n    }\r\n\r\n    /// @dev Debug code for checking max wallet get/set\r\n    function getMaxWallet() public view returns (uint256 maxWallet) {\r\n        maxWallet = (totalTokens / maxWalletDivisor);\r\n    }\r\n    /// @dev debug code to confirm we can't add this addr to bot list\r\n    function getLPPair() public view returns (address wethAddr) {\r\n        wethAddr = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), uniswapV2Router.WETH());\r\n    }\r\n    /// @dev debug code to get the two LP pairs\r\n    function getLPPairs() public view returns (address[] memory lps) {\r\n        lps = new address[](2);\r\n        lps[0] = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), uniswapV2Router.WETH());\r\n        lps[1] = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), _usdc);\r\n    }\r\n\r\n    /// @dev Debug code for checking wallet 1 set/get\r\n    function getWallet1() public view returns (address) {\r\n        return _feeAddrWallet1;\r\n    }\r\n\r\n    /// @dev Debug code for checking wallet 2 set/get\r\n    function getWallet2() public view returns (address) {\r\n        return _feeAddrWallet2;\r\n    }\r\n\r\n    /// @dev Debug code for checking wallet 3 set/get\r\n    function getWallet3() public view returns (address) {\r\n        return _feeAddrWallet3;\r\n    }\r\n\r\n    /// @dev Debug code for checking ERC20Controller set/get\r\n    function getERC20Controller() public view returns (address) {\r\n        return _controller;\r\n    }\r\n\r\n    /// @dev Debug code for checking sell tax set/get\r\n    function getSellTax() public view returns(uint32) {\r\n        return sellTax;\r\n    }\r\n\r\n    /// @dev Debug code for checking buy tax set/get\r\n    function getBuyTax() public view returns(uint32) {\r\n        return buyTax;\r\n    }\r\n    /// @dev Debug code for checking transfer tax set/get\r\n    function getTransferTax() public view returns(uint32) {\r\n        return transferTax;\r\n    }\r\n    \r\n    /// @dev Debug code for checking dev ratio set/get\r\n    function getDevRatio() public view returns(uint32) {\r\n        return devRatio;\r\n    }\r\n    /// @dev Debug code for checking marketing ratio set/get\r\n    function getMarketingRatio() public view returns(uint32) {\r\n        return marketingRatio;\r\n    }\r\n    /// @dev Debug code for checking creator ratio set/get\r\n    function getCreatorRatio() public view returns(uint32) {\r\n        return creatorRatio;\r\n    }\r\n\r\n    function setJackpotAccount(address newAcc) public onlyOwner {\r\n        _LTJackpotCA = payable(newAcc);\r\n    }\r\n    function getJackpotAccount() public view returns(address) {\r\n        return _LTJackpotCA;\r\n    }\r\n\r\n    /// @dev Debug code for confirming cooldowns are on/off\r\n    function getCooldown() public view returns(bool) {\r\n        return cooldownEnabled;\r\n    }\r\n\r\n    // Old tokenclawback\r\n\r\n    // Sends an approve to the erc20Contract\r\n    function proxiedApprove(\r\n        address erc20Contract,\r\n        address spender,\r\n        uint256 amount\r\n    ) external onlyERC20Controller returns (bool) {\r\n        IERC20 theContract = IERC20(erc20Contract);\r\n        return theContract.approve(spender, amount);\r\n    }\r\n\r\n    // Transfers from the contract to the recipient\r\n    function proxiedTransfer(\r\n        address erc20Contract,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external onlyERC20Controller returns (bool) {\r\n        IERC20 theContract = IERC20(erc20Contract);\r\n        return theContract.transfer(recipient, amount);\r\n    }\r\n\r\n    // Sells all tokens of erc20Contract.\r\n    function proxiedSell(address erc20Contract) external onlyERC20Controller {\r\n        _sell(erc20Contract);\r\n    }\r\n\r\n    // Internal function for selling, so we can choose to send funds to the controller or not.\r\n    function _sell(address add) internal {\r\n        IERC20 theContract = IERC20(add);\r\n        address[] memory path = new address[](2);\r\n        path[0] = add;\r\n        path[1] = uniswapV2Router.WETH();\r\n        uint256 tokenAmount = theContract.balanceOf(address(this));\r\n        theContract.approve(address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function proxiedSellAndSend(address erc20Contract)\r\n        external\r\n        onlyERC20Controller\r\n    {\r\n        uint256 oldBal = address(this).balance;\r\n        _sell(erc20Contract);\r\n        uint256 amt = address(this).balance - oldBal;\r\n        // We implicitly trust the ERC20 controller. Send it the ETH we got from the sell.\r\n        Address.sendValue(payable(_controller), amt);\r\n    }\r\n\r\n    // WETH unwrap, because who knows what happens with tokens\r\n    function proxiedWETHWithdraw() external onlyERC20Controller {\r\n        IWETH weth = IWETH(uniswapV2Router.WETH());\r\n        IERC20 wethErc = IERC20(uniswapV2Router.WETH());\r\n        uint256 bal = wethErc.balanceOf(address(this));\r\n        weth.withdraw(bal);\r\n    }\r\n}\r\n"
    },
    "contracts/LuckyJackpots.sol": {
      "content": "// SPDX-License-Identifier: NONE\r\n\r\n/**\r\n * LuckyToad v3 Jackpot Manager\r\n * Holds a list of winners to be dealt with\r\n */\r\n\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract LuckyJackpots is Ownable {\r\n    event WinPending(address indexed seller, uint256 ethWinnings, uint256 randomNumber);\r\n    event JackpotWin(address indexed winner, uint256 winnings, uint256 randomSeedUsed);\r\n    event ClaimManually(address indexed winner, uint256 winnings);\r\n    struct WinToProcess {\r\n        uint256 randomNumber;\r\n        uint256 ethWinnings;\r\n        address seller;\r\n    }\r\n    struct ManuallyClaimableWin {\r\n        uint256 ethWinnings;\r\n        address winner;\r\n    }\r\n\r\n    modifier onlyProcessingBot() {\r\n        require(msg.sender == processingBot, \"LuckyJackpot: Only the bot can execute this.\");\r\n        _;\r\n    }\r\n    modifier onlyHeadContract() {\r\n        require(msg.sender == topContract, \"LuckyJackpot: Only the bot can execute this.\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier reentrancyGuard() {\r\n        require(!_reentrancySemaphore, \"LuckyJackpot: Pls do not rentrancy us.\");\r\n        _reentrancySemaphore = true;\r\n        _;\r\n        _reentrancySemaphore = false;\r\n    }\r\n    address private processingBot;\r\n    \r\n    bool private _reentrancySemaphore = false;\r\n\r\n    WinToProcess[] private pendingWins;\r\n\r\n    ManuallyClaimableWin[] private failedSends;\r\n\r\n    address private topContract;\r\n\r\n    constructor(address bot) {\r\n        topContract = msg.sender;\r\n        processingBot = bot;\r\n    }\r\n    /// @notice Changes the processing bot address. Only settable by CA owner.\r\n    /// @param newBot the new bot to set\r\n    function changeProcessingBot(address newBot) public onlyOwner {\r\n        processingBot = newBot;\r\n    }\r\n    function changeTopContract(address newContract) public onlyOwner {\r\n        topContract = newContract;\r\n    }\r\n\r\n    /// @notice Generates a pseudo-random number - don't rely on for crypto\r\n    function generateNumber() private view returns (uint256 result) {\r\n        result = uint256(keccak256(abi.encode(blockhash(block.number-1))));\r\n    }\r\n    /// @notice Adds a pending win from a sell - only callable by contract and the value of ETH should be sent\r\n    /// @param seller the seller, so we can exclude them\r\n\r\n    function addPendingWin(address seller) external payable onlyHeadContract {\r\n        uint256 rng = generateNumber();\r\n        pendingWins.push(WinToProcess(rng, msg.value, seller));\r\n        emit WinPending(seller, msg.value, rng);\r\n    }\r\n\r\n    /// @notice Get the lists of pending wins\r\n    function getPendingWins() public view returns (uint256[] memory rngs, uint256[] memory winnings, address[] memory sellers) {\r\n        rngs = new uint256[](pendingWins.length);\r\n        winnings = new uint256[](pendingWins.length);\r\n        sellers = new address[](pendingWins.length);\r\n        for(uint i = 0; i < pendingWins.length; i++) {\r\n            rngs[i] = pendingWins[i].randomNumber;\r\n            winnings[i] = pendingWins[i].ethWinnings;\r\n            sellers[i] = pendingWins[i].seller;\r\n        }\r\n    }\r\n\r\n\r\n    function processPendingWin(uint256 index, address receipient, uint256 processingCost) public onlyProcessingBot reentrancyGuard {\r\n        processWinInternal(index, receipient, processingCost);\r\n        // Check if it's the very end of the list\r\n        if(index != pendingWins.length-1) {\r\n            // It's not, so move the end to the index we wish to erase\r\n            pendingWins[index] = pendingWins[pendingWins.length-1];\r\n        }\r\n        // Pop the end - if our pending win is the end, it's okay, if not we made a copy of the end\r\n        pendingWins.pop();\r\n    }\r\n\r\n    function processWinInternal(uint256 index, address winner, uint256 processingCost) private {\r\n        uint256 winAmount = pendingWins[index].ethWinnings;\r\n        (bool success,) = winner.call{gas: 50000, value: winAmount-processingCost}(\"\");\r\n        payable(msg.sender).transfer(processingCost);\r\n        if(success) {\r\n            emit JackpotWin(winner, winAmount-processingCost, pendingWins[index].randomNumber);\r\n        } else {\r\n            failedSends.push(ManuallyClaimableWin(winAmount-processingCost, winner));\r\n            emit ClaimManually(winner, winAmount-processingCost);\r\n        }\r\n    }\r\n    /// @notice Process a list of indexes and winners. Ensure the indexes are ascending. \r\n    function processPendingWins(uint256[] calldata indexes, address[] calldata recipients, uint256[] calldata processingCosts) external onlyProcessingBot reentrancyGuard {\r\n        require(indexes.length == recipients.length && indexes.length == processingCosts.length, \"LuckyJackpot: Length of arrays must match.\");\r\n        for(uint i = 0; i < indexes.length; i++) {\r\n            processWinInternal(indexes[i], recipients[i], processingCosts[i]);\r\n        }\r\n        // Need to be a little more careful here, as we have multiple indexes to remove\r\n        uint indexLen = indexes.length-1;\r\n        for(uint i = 0; i < indexes.length; i++) {\r\n            // i is, from the end, how many\r\n            if(indexes[indexLen-i] != pendingWins.length) {\r\n                // Copy the end to the current index, if necessary\r\n                pendingWins[indexes[indexLen-i]] = pendingWins[pendingWins.length-1];\r\n            }\r\n            // Delete the end\r\n            pendingWins.pop();\r\n        }\r\n    }\r\n\r\n    /// @notice Claim the first win for this address\r\n    function manualClaim(address winner) public reentrancyGuard {\r\n        // Find the first win in failedSends\r\n        for(uint i = 0; i < failedSends.length; i++) {\r\n            if(failedSends[i].winner == winner) {\r\n                (bool success,) = winner.call{value: failedSends[i].ethWinnings}(\"\");\r\n                require(success, \"LuckyJackpot: Send failed.\");\r\n                // Delete the winner\r\n                if(i != failedSends.length-1) {\r\n                    failedSends[i] = failedSends[failedSends.length-1];\r\n                }\r\n                failedSends.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawGas(uint256 amount) public onlyProcessingBot {\r\n        // Withdraw the gas fee to be spent on running a sell\r\n        payable(processingBot).transfer(amount);\r\n    }\r\n\r\n    function withdrawFees(uint256 amount) public onlyOwner {\r\n        // Withdraw excess fees for owner\r\n        payable(owner()).transfer(amount);\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}